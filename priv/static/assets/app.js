(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/tom-select/dist/js/tom-select.complete.js
  var require_tom_select_complete = __commonJS({
    "node_modules/tom-select/dist/js/tom-select.complete.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.TomSelect = factory());
      })(exports, function() {
        "use strict";
        function forEvents(events, callback) {
          events.split(/\s+/).forEach((event) => {
            callback(event);
          });
        }
        class MicroEvent {
          constructor() {
            this._events = void 0;
            this._events = {};
          }
          on(events, fct) {
            forEvents(events, (event) => {
              const event_array = this._events[event] || [];
              event_array.push(fct);
              this._events[event] = event_array;
            });
          }
          off(events, fct) {
            var n = arguments.length;
            if (n === 0) {
              this._events = {};
              return;
            }
            forEvents(events, (event) => {
              if (n === 1) {
                delete this._events[event];
                return;
              }
              const event_array = this._events[event];
              if (event_array === void 0)
                return;
              event_array.splice(event_array.indexOf(fct), 1);
              this._events[event] = event_array;
            });
          }
          trigger(events, ...args) {
            var self2 = this;
            forEvents(events, (event) => {
              const event_array = self2._events[event];
              if (event_array === void 0)
                return;
              event_array.forEach((fct) => {
                fct.apply(self2, args);
              });
            });
          }
        }
        function MicroPlugin(Interface) {
          Interface.plugins = {};
          return class extends Interface {
            constructor(...args) {
              super(...args);
              this.plugins = {
                names: [],
                settings: {},
                requested: {},
                loaded: {}
              };
            }
            static define(name, fn) {
              Interface.plugins[name] = {
                "name": name,
                "fn": fn
              };
            }
            initializePlugins(plugins) {
              var key, name;
              const self2 = this;
              const queue = [];
              if (Array.isArray(plugins)) {
                plugins.forEach((plugin) => {
                  if (typeof plugin === "string") {
                    queue.push(plugin);
                  } else {
                    self2.plugins.settings[plugin.name] = plugin.options;
                    queue.push(plugin.name);
                  }
                });
              } else if (plugins) {
                for (key in plugins) {
                  if (plugins.hasOwnProperty(key)) {
                    self2.plugins.settings[key] = plugins[key];
                    queue.push(key);
                  }
                }
              }
              while (name = queue.shift()) {
                self2.require(name);
              }
            }
            loadPlugin(name) {
              var self2 = this;
              var plugins = self2.plugins;
              var plugin = Interface.plugins[name];
              if (!Interface.plugins.hasOwnProperty(name)) {
                throw new Error('Unable to find "' + name + '" plugin');
              }
              plugins.requested[name] = true;
              plugins.loaded[name] = plugin.fn.apply(self2, [self2.plugins.settings[name] || {}]);
              plugins.names.push(name);
            }
            require(name) {
              var self2 = this;
              var plugins = self2.plugins;
              if (!self2.plugins.loaded.hasOwnProperty(name)) {
                if (plugins.requested[name]) {
                  throw new Error('Plugin has circular dependency ("' + name + '")');
                }
                self2.loadPlugin(name);
              }
              return plugins.loaded[name];
            }
          };
        }
        const arrayToPattern = (chars) => {
          chars = chars.filter(Boolean);
          if (chars.length < 2) {
            return chars[0] || "";
          }
          return maxValueLength(chars) == 1 ? "[" + chars.join("") + "]" : "(?:" + chars.join("|") + ")";
        };
        const sequencePattern = (array) => {
          if (!hasDuplicates(array)) {
            return array.join("");
          }
          let pattern = "";
          let prev_char_count = 0;
          const prev_pattern = () => {
            if (prev_char_count > 1) {
              pattern += "{" + prev_char_count + "}";
            }
          };
          array.forEach((char, i) => {
            if (char === array[i - 1]) {
              prev_char_count++;
              return;
            }
            prev_pattern();
            pattern += char;
            prev_char_count = 1;
          });
          prev_pattern();
          return pattern;
        };
        const setToPattern = (chars) => {
          let array = toArray(chars);
          return arrayToPattern(array);
        };
        const hasDuplicates = (array) => {
          return new Set(array).size !== array.length;
        };
        const escape_regex = (str) => {
          return (str + "").replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, "\\$1");
        };
        const maxValueLength = (array) => {
          return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);
        };
        const unicodeLength = (str) => {
          return toArray(str).length;
        };
        const toArray = (p) => Array.from(p);
        const allSubstrings = (input) => {
          if (input.length === 1)
            return [[input]];
          let result = [];
          const start = input.substring(1);
          const suba = allSubstrings(start);
          suba.forEach(function(subresult) {
            let tmp = subresult.slice(0);
            tmp[0] = input.charAt(0) + tmp[0];
            result.push(tmp);
            tmp = subresult.slice(0);
            tmp.unshift(input.charAt(0));
            result.push(tmp);
          });
          return result;
        };
        const code_points = [[0, 65535]];
        const accent_pat = "[\u0300-\u036F\xB7\u02BE\u02BC]";
        let unicode_map;
        let multi_char_reg;
        const max_char_length = 3;
        const latin_convert = {};
        const latin_condensed = {
          "/": "\u2044\u2215",
          "0": "\u07C0",
          "a": "\u2C65\u0250\u0251",
          "aa": "\uA733",
          "ae": "\xE6\u01FD\u01E3",
          "ao": "\uA735",
          "au": "\uA737",
          "av": "\uA739\uA73B",
          "ay": "\uA73D",
          "b": "\u0180\u0253\u0183",
          "c": "\uA73F\u0188\u023C\u2184",
          "d": "\u0111\u0257\u0256\u1D05\u018C\uABB7\u0501\u0266",
          "e": "\u025B\u01DD\u1D07\u0247",
          "f": "\uA77C\u0192",
          "g": "\u01E5\u0260\uA7A1\u1D79\uA77F\u0262",
          "h": "\u0127\u2C68\u2C76\u0265",
          "i": "\u0268\u0131",
          "j": "\u0249\u0237",
          "k": "\u0199\u2C6A\uA741\uA743\uA745\uA7A3",
          "l": "\u0142\u019A\u026B\u2C61\uA749\uA747\uA781\u026D",
          "m": "\u0271\u026F\u03FB",
          "n": "\uA7A5\u019E\u0272\uA791\u1D0E\u043B\u0509",
          "o": "\xF8\u01FF\u0254\u0275\uA74B\uA74D\u1D11",
          "oe": "\u0153",
          "oi": "\u01A3",
          "oo": "\uA74F",
          "ou": "\u0223",
          "p": "\u01A5\u1D7D\uA751\uA753\uA755\u03C1",
          "q": "\uA757\uA759\u024B",
          "r": "\u024D\u027D\uA75B\uA7A7\uA783",
          "s": "\xDF\u023F\uA7A9\uA785\u0282",
          "t": "\u0167\u01AD\u0288\u2C66\uA787",
          "th": "\xFE",
          "tz": "\uA729",
          "u": "\u0289",
          "v": "\u028B\uA75F\u028C",
          "vy": "\uA761",
          "w": "\u2C73",
          "y": "\u01B4\u024F\u1EFF",
          "z": "\u01B6\u0225\u0240\u2C6C\uA763",
          "hv": "\u0195"
        };
        for (let latin in latin_condensed) {
          let unicode = latin_condensed[latin] || "";
          for (let i = 0; i < unicode.length; i++) {
            let char = unicode.substring(i, i + 1);
            latin_convert[char] = latin;
          }
        }
        const convert_pat = new RegExp(Object.keys(latin_convert).join("|") + "|" + accent_pat, "gu");
        const initialize = (_code_points) => {
          if (unicode_map !== void 0)
            return;
          unicode_map = generateMap(_code_points || code_points);
        };
        const normalize = (str, form = "NFKD") => str.normalize(form);
        const asciifold = (str) => {
          return toArray(str).reduce((result, char) => {
            return result + _asciifold(char);
          }, "");
        };
        const _asciifold = (str) => {
          str = normalize(str).toLowerCase().replace(convert_pat, (char) => {
            return latin_convert[char] || "";
          });
          return normalize(str, "NFC");
        };
        function* generator(code_points2) {
          for (const [code_point_min, code_point_max] of code_points2) {
            for (let i = code_point_min; i <= code_point_max; i++) {
              let composed = String.fromCharCode(i);
              let folded = asciifold(composed);
              if (folded == composed.toLowerCase()) {
                continue;
              }
              if (folded.length > max_char_length) {
                continue;
              }
              if (folded.length == 0) {
                continue;
              }
              yield {
                folded,
                composed,
                code_point: i
              };
            }
          }
        }
        const generateSets = (code_points2) => {
          const unicode_sets = {};
          const addMatching = (folded, to_add) => {
            const folded_set = unicode_sets[folded] || /* @__PURE__ */ new Set();
            const patt = new RegExp("^" + setToPattern(folded_set) + "$", "iu");
            if (to_add.match(patt)) {
              return;
            }
            folded_set.add(escape_regex(to_add));
            unicode_sets[folded] = folded_set;
          };
          for (let value of generator(code_points2)) {
            addMatching(value.folded, value.folded);
            addMatching(value.folded, value.composed);
          }
          return unicode_sets;
        };
        const generateMap = (code_points2) => {
          const unicode_sets = generateSets(code_points2);
          const unicode_map2 = {};
          let multi_char = [];
          for (let folded in unicode_sets) {
            let set = unicode_sets[folded];
            if (set) {
              unicode_map2[folded] = setToPattern(set);
            }
            if (folded.length > 1) {
              multi_char.push(escape_regex(folded));
            }
          }
          multi_char.sort((a, b) => b.length - a.length);
          const multi_char_patt = arrayToPattern(multi_char);
          multi_char_reg = new RegExp("^" + multi_char_patt, "u");
          return unicode_map2;
        };
        const mapSequence = (strings, min_replacement = 1) => {
          let chars_replaced = 0;
          strings = strings.map((str) => {
            if (unicode_map[str]) {
              chars_replaced += str.length;
            }
            return unicode_map[str] || str;
          });
          if (chars_replaced >= min_replacement) {
            return sequencePattern(strings);
          }
          return "";
        };
        const substringsToPattern = (str, min_replacement = 1) => {
          min_replacement = Math.max(min_replacement, str.length - 1);
          return arrayToPattern(allSubstrings(str).map((sub_pat) => {
            return mapSequence(sub_pat, min_replacement);
          }));
        };
        const sequencesToPattern = (sequences, all = true) => {
          let min_replacement = sequences.length > 1 ? 1 : 0;
          return arrayToPattern(sequences.map((sequence) => {
            let seq = [];
            const len = all ? sequence.length() : sequence.length() - 1;
            for (let j = 0; j < len; j++) {
              seq.push(substringsToPattern(sequence.substrs[j] || "", min_replacement));
            }
            return sequencePattern(seq);
          }));
        };
        const inSequences = (needle_seq, sequences) => {
          for (const seq of sequences) {
            if (seq.start != needle_seq.start || seq.end != needle_seq.end) {
              continue;
            }
            if (seq.substrs.join("") !== needle_seq.substrs.join("")) {
              continue;
            }
            let needle_parts = needle_seq.parts;
            const filter = (part) => {
              for (const needle_part of needle_parts) {
                if (needle_part.start === part.start && needle_part.substr === part.substr) {
                  return false;
                }
                if (part.length == 1 || needle_part.length == 1) {
                  continue;
                }
                if (part.start < needle_part.start && part.end > needle_part.start) {
                  return true;
                }
                if (needle_part.start < part.start && needle_part.end > part.start) {
                  return true;
                }
              }
              return false;
            };
            let filtered = seq.parts.filter(filter);
            if (filtered.length > 0) {
              continue;
            }
            return true;
          }
          return false;
        };
        class Sequence {
          constructor() {
            this.parts = [];
            this.substrs = [];
            this.start = 0;
            this.end = 0;
          }
          add(part) {
            if (part) {
              this.parts.push(part);
              this.substrs.push(part.substr);
              this.start = Math.min(part.start, this.start);
              this.end = Math.max(part.end, this.end);
            }
          }
          last() {
            return this.parts[this.parts.length - 1];
          }
          length() {
            return this.parts.length;
          }
          clone(position, last_piece) {
            let clone2 = new Sequence();
            let parts = JSON.parse(JSON.stringify(this.parts));
            let last_part = parts.pop();
            for (const part of parts) {
              clone2.add(part);
            }
            let last_substr = last_piece.substr.substring(0, position - last_part.start);
            let clone_last_len = last_substr.length;
            clone2.add({
              start: last_part.start,
              end: last_part.start + clone_last_len,
              length: clone_last_len,
              substr: last_substr
            });
            return clone2;
          }
        }
        const getPattern = (str) => {
          initialize();
          str = asciifold(str);
          let pattern = "";
          let sequences = [new Sequence()];
          for (let i = 0; i < str.length; i++) {
            let substr = str.substring(i);
            let match = substr.match(multi_char_reg);
            const char = str.substring(i, i + 1);
            const match_str = match ? match[0] : null;
            let overlapping = [];
            let added_types = /* @__PURE__ */ new Set();
            for (const sequence of sequences) {
              const last_piece = sequence.last();
              if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {
                if (match_str) {
                  const len = match_str.length;
                  sequence.add({
                    start: i,
                    end: i + len,
                    length: len,
                    substr: match_str
                  });
                  added_types.add("1");
                } else {
                  sequence.add({
                    start: i,
                    end: i + 1,
                    length: 1,
                    substr: char
                  });
                  added_types.add("2");
                }
              } else if (match_str) {
                let clone2 = sequence.clone(i, last_piece);
                const len = match_str.length;
                clone2.add({
                  start: i,
                  end: i + len,
                  length: len,
                  substr: match_str
                });
                overlapping.push(clone2);
              } else {
                added_types.add("3");
              }
            }
            if (overlapping.length > 0) {
              overlapping = overlapping.sort((a, b) => {
                return a.length() - b.length();
              });
              for (let clone2 of overlapping) {
                if (inSequences(clone2, sequences)) {
                  continue;
                }
                sequences.push(clone2);
              }
              continue;
            }
            if (i > 0 && added_types.size == 1 && !added_types.has("3")) {
              pattern += sequencesToPattern(sequences, false);
              let new_seq = new Sequence();
              const old_seq = sequences[0];
              if (old_seq) {
                new_seq.add(old_seq.last());
              }
              sequences = [new_seq];
            }
          }
          pattern += sequencesToPattern(sequences, true);
          return pattern;
        };
        const getAttr = (obj, name) => {
          if (!obj)
            return;
          return obj[name];
        };
        const getAttrNesting = (obj, name) => {
          if (!obj)
            return;
          var part, names = name.split(".");
          while ((part = names.shift()) && (obj = obj[part]))
            ;
          return obj;
        };
        const scoreValue = (value, token, weight) => {
          var score, pos;
          if (!value)
            return 0;
          value = value + "";
          if (token.regex == null)
            return 0;
          pos = value.search(token.regex);
          if (pos === -1)
            return 0;
          score = token.string.length / value.length;
          if (pos === 0)
            score += 0.5;
          return score * weight;
        };
        const propToArray = (obj, key) => {
          var value = obj[key];
          if (typeof value == "function")
            return value;
          if (value && !Array.isArray(value)) {
            obj[key] = [value];
          }
        };
        const iterate$1 = (object, callback) => {
          if (Array.isArray(object)) {
            object.forEach(callback);
          } else {
            for (var key in object) {
              if (object.hasOwnProperty(key)) {
                callback(object[key], key);
              }
            }
          }
        };
        const cmp = (a, b) => {
          if (typeof a === "number" && typeof b === "number") {
            return a > b ? 1 : a < b ? -1 : 0;
          }
          a = asciifold(a + "").toLowerCase();
          b = asciifold(b + "").toLowerCase();
          if (a > b)
            return 1;
          if (b > a)
            return -1;
          return 0;
        };
        class Sifter {
          constructor(items, settings) {
            this.items = void 0;
            this.settings = void 0;
            this.items = items;
            this.settings = settings || {
              diacritics: true
            };
          }
          tokenize(query, respect_word_boundaries, weights) {
            if (!query || !query.length)
              return [];
            const tokens = [];
            const words = query.split(/\s+/);
            var field_regex;
            if (weights) {
              field_regex = new RegExp("^(" + Object.keys(weights).map(escape_regex).join("|") + "):(.*)$");
            }
            words.forEach((word) => {
              let field_match;
              let field = null;
              let regex = null;
              if (field_regex && (field_match = word.match(field_regex))) {
                field = field_match[1];
                word = field_match[2];
              }
              if (word.length > 0) {
                if (this.settings.diacritics) {
                  regex = getPattern(word) || null;
                } else {
                  regex = escape_regex(word);
                }
                if (regex && respect_word_boundaries)
                  regex = "\\b" + regex;
              }
              tokens.push({
                string: word,
                regex: regex ? new RegExp(regex, "iu") : null,
                field
              });
            });
            return tokens;
          }
          getScoreFunction(query, options) {
            var search = this.prepareSearch(query, options);
            return this._getScoreFunction(search);
          }
          _getScoreFunction(search) {
            const tokens = search.tokens, token_count = tokens.length;
            if (!token_count) {
              return function() {
                return 0;
              };
            }
            const fields = search.options.fields, weights = search.weights, field_count = fields.length, getAttrFn = search.getAttrFn;
            if (!field_count) {
              return function() {
                return 1;
              };
            }
            const scoreObject = function() {
              if (field_count === 1) {
                return function(token, data) {
                  const field = fields[0].field;
                  return scoreValue(getAttrFn(data, field), token, weights[field] || 1);
                };
              }
              return function(token, data) {
                var sum = 0;
                if (token.field) {
                  const value = getAttrFn(data, token.field);
                  if (!token.regex && value) {
                    sum += 1 / field_count;
                  } else {
                    sum += scoreValue(value, token, 1);
                  }
                } else {
                  iterate$1(weights, (weight, field) => {
                    sum += scoreValue(getAttrFn(data, field), token, weight);
                  });
                }
                return sum / field_count;
              };
            }();
            if (token_count === 1) {
              return function(data) {
                return scoreObject(tokens[0], data);
              };
            }
            if (search.options.conjunction === "and") {
              return function(data) {
                var score, sum = 0;
                for (let token of tokens) {
                  score = scoreObject(token, data);
                  if (score <= 0)
                    return 0;
                  sum += score;
                }
                return sum / token_count;
              };
            } else {
              return function(data) {
                var sum = 0;
                iterate$1(tokens, (token) => {
                  sum += scoreObject(token, data);
                });
                return sum / token_count;
              };
            }
          }
          getSortFunction(query, options) {
            var search = this.prepareSearch(query, options);
            return this._getSortFunction(search);
          }
          _getSortFunction(search) {
            var implicit_score, sort_flds = [];
            const self2 = this, options = search.options, sort = !search.query && options.sort_empty ? options.sort_empty : options.sort;
            if (typeof sort == "function") {
              return sort.bind(this);
            }
            const get_field = function get_field2(name, result) {
              if (name === "$score")
                return result.score;
              return search.getAttrFn(self2.items[result.id], name);
            };
            if (sort) {
              for (let s of sort) {
                if (search.query || s.field !== "$score") {
                  sort_flds.push(s);
                }
              }
            }
            if (search.query) {
              implicit_score = true;
              for (let fld of sort_flds) {
                if (fld.field === "$score") {
                  implicit_score = false;
                  break;
                }
              }
              if (implicit_score) {
                sort_flds.unshift({
                  field: "$score",
                  direction: "desc"
                });
              }
            } else {
              sort_flds = sort_flds.filter((fld) => fld.field !== "$score");
            }
            const sort_flds_count = sort_flds.length;
            if (!sort_flds_count) {
              return null;
            }
            return function(a, b) {
              var result, field;
              for (let sort_fld of sort_flds) {
                field = sort_fld.field;
                let multiplier = sort_fld.direction === "desc" ? -1 : 1;
                result = multiplier * cmp(get_field(field, a), get_field(field, b));
                if (result)
                  return result;
              }
              return 0;
            };
          }
          prepareSearch(query, optsUser) {
            const weights = {};
            var options = Object.assign({}, optsUser);
            propToArray(options, "sort");
            propToArray(options, "sort_empty");
            if (options.fields) {
              propToArray(options, "fields");
              const fields = [];
              options.fields.forEach((field) => {
                if (typeof field == "string") {
                  field = {
                    field,
                    weight: 1
                  };
                }
                fields.push(field);
                weights[field.field] = "weight" in field ? field.weight : 1;
              });
              options.fields = fields;
            }
            return {
              options,
              query: query.toLowerCase().trim(),
              tokens: this.tokenize(query, options.respect_word_boundaries, weights),
              total: 0,
              items: [],
              weights,
              getAttrFn: options.nesting ? getAttrNesting : getAttr
            };
          }
          search(query, options) {
            var self2 = this, score, search;
            search = this.prepareSearch(query, options);
            options = search.options;
            query = search.query;
            const fn_score = options.score || self2._getScoreFunction(search);
            if (query.length) {
              iterate$1(self2.items, (item, id) => {
                score = fn_score(item);
                if (options.filter === false || score > 0) {
                  search.items.push({
                    "score": score,
                    "id": id
                  });
                }
              });
            } else {
              iterate$1(self2.items, (_, id) => {
                search.items.push({
                  "score": 1,
                  "id": id
                });
              });
            }
            const fn_sort = self2._getSortFunction(search);
            if (fn_sort)
              search.items.sort(fn_sort);
            search.total = search.items.length;
            if (typeof options.limit === "number") {
              search.items = search.items.slice(0, options.limit);
            }
            return search;
          }
        }
        const iterate = (object, callback) => {
          if (Array.isArray(object)) {
            object.forEach(callback);
          } else {
            for (var key in object) {
              if (object.hasOwnProperty(key)) {
                callback(object[key], key);
              }
            }
          }
        };
        const getDom = (query) => {
          if (query.jquery) {
            return query[0];
          }
          if (query instanceof HTMLElement) {
            return query;
          }
          if (isHtmlString(query)) {
            var tpl = document.createElement("template");
            tpl.innerHTML = query.trim();
            return tpl.content.firstChild;
          }
          return document.querySelector(query);
        };
        const isHtmlString = (arg) => {
          if (typeof arg === "string" && arg.indexOf("<") > -1) {
            return true;
          }
          return false;
        };
        const escapeQuery = (query) => {
          return query.replace(/['"\\]/g, "\\$&");
        };
        const triggerEvent = (dom_el, event_name) => {
          var event = document.createEvent("HTMLEvents");
          event.initEvent(event_name, true, false);
          dom_el.dispatchEvent(event);
        };
        const applyCSS = (dom_el, css) => {
          Object.assign(dom_el.style, css);
        };
        const addClasses = (elmts, ...classes) => {
          var norm_classes = classesArray(classes);
          elmts = castAsArray(elmts);
          elmts.map((el) => {
            norm_classes.map((cls) => {
              el.classList.add(cls);
            });
          });
        };
        const removeClasses = (elmts, ...classes) => {
          var norm_classes = classesArray(classes);
          elmts = castAsArray(elmts);
          elmts.map((el) => {
            norm_classes.map((cls) => {
              el.classList.remove(cls);
            });
          });
        };
        const classesArray = (args) => {
          var classes = [];
          iterate(args, (_classes) => {
            if (typeof _classes === "string") {
              _classes = _classes.trim().split(/[\11\12\14\15\40]/);
            }
            if (Array.isArray(_classes)) {
              classes = classes.concat(_classes);
            }
          });
          return classes.filter(Boolean);
        };
        const castAsArray = (arg) => {
          if (!Array.isArray(arg)) {
            arg = [arg];
          }
          return arg;
        };
        const parentMatch = (target, selector, wrapper) => {
          if (wrapper && !wrapper.contains(target)) {
            return;
          }
          while (target && target.matches) {
            if (target.matches(selector)) {
              return target;
            }
            target = target.parentNode;
          }
        };
        const getTail = (list, direction = 0) => {
          if (direction > 0) {
            return list[list.length - 1];
          }
          return list[0];
        };
        const isEmptyObject = (obj) => {
          return Object.keys(obj).length === 0;
        };
        const nodeIndex = (el, amongst) => {
          if (!el)
            return -1;
          amongst = amongst || el.nodeName;
          var i = 0;
          while (el = el.previousElementSibling) {
            if (el.matches(amongst)) {
              i++;
            }
          }
          return i;
        };
        const setAttr = (el, attrs) => {
          iterate(attrs, (val, attr) => {
            if (val == null) {
              el.removeAttribute(attr);
            } else {
              el.setAttribute(attr, "" + val);
            }
          });
        };
        const replaceNode = (existing, replacement) => {
          if (existing.parentNode)
            existing.parentNode.replaceChild(replacement, existing);
        };
        const highlight = (element, regex) => {
          if (regex === null)
            return;
          if (typeof regex === "string") {
            if (!regex.length)
              return;
            regex = new RegExp(regex, "i");
          }
          const highlightText = (node) => {
            var match = node.data.match(regex);
            if (match && node.data.length > 0) {
              var spannode = document.createElement("span");
              spannode.className = "highlight";
              var middlebit = node.splitText(match.index);
              middlebit.splitText(match[0].length);
              var middleclone = middlebit.cloneNode(true);
              spannode.appendChild(middleclone);
              replaceNode(middlebit, spannode);
              return 1;
            }
            return 0;
          };
          const highlightChildren = (node) => {
            if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== "highlight" || node.tagName !== "SPAN")) {
              Array.from(node.childNodes).forEach((element2) => {
                highlightRecursive(element2);
              });
            }
          };
          const highlightRecursive = (node) => {
            if (node.nodeType === 3) {
              return highlightText(node);
            }
            highlightChildren(node);
            return 0;
          };
          highlightRecursive(element);
        };
        const removeHighlight = (el) => {
          var elements = el.querySelectorAll("span.highlight");
          Array.prototype.forEach.call(elements, function(el2) {
            var parent = el2.parentNode;
            parent.replaceChild(el2.firstChild, el2);
            parent.normalize();
          });
        };
        const KEY_A = 65;
        const KEY_RETURN = 13;
        const KEY_ESC = 27;
        const KEY_LEFT = 37;
        const KEY_UP = 38;
        const KEY_RIGHT = 39;
        const KEY_DOWN = 40;
        const KEY_BACKSPACE = 8;
        const KEY_DELETE = 46;
        const KEY_TAB = 9;
        const IS_MAC = typeof navigator === "undefined" ? false : /Mac/.test(navigator.userAgent);
        const KEY_SHORTCUT = IS_MAC ? "metaKey" : "ctrlKey";
        var defaults = {
          options: [],
          optgroups: [],
          plugins: [],
          delimiter: ",",
          splitOn: null,
          persist: true,
          diacritics: true,
          create: null,
          createOnBlur: false,
          createFilter: null,
          highlight: true,
          openOnFocus: true,
          shouldOpen: null,
          maxOptions: 50,
          maxItems: null,
          hideSelected: null,
          duplicates: false,
          addPrecedence: false,
          selectOnTab: false,
          preload: null,
          allowEmptyOption: false,
          refreshThrottle: 300,
          loadThrottle: 300,
          loadingClass: "loading",
          dataAttr: null,
          optgroupField: "optgroup",
          valueField: "value",
          labelField: "text",
          disabledField: "disabled",
          optgroupLabelField: "label",
          optgroupValueField: "value",
          lockOptgroupOrder: false,
          sortField: "$order",
          searchField: ["text"],
          searchConjunction: "and",
          mode: null,
          wrapperClass: "ts-wrapper",
          controlClass: "ts-control",
          dropdownClass: "ts-dropdown",
          dropdownContentClass: "ts-dropdown-content",
          itemClass: "item",
          optionClass: "option",
          dropdownParent: null,
          controlInput: '<input type="text" autocomplete="off" size="1" />',
          copyClassesToDropdown: false,
          placeholder: null,
          hidePlaceholder: null,
          shouldLoad: function(query) {
            return query.length > 0;
          },
          render: {}
        };
        const hash_key = (value) => {
          if (typeof value === "undefined" || value === null)
            return null;
          return get_hash(value);
        };
        const get_hash = (value) => {
          if (typeof value === "boolean")
            return value ? "1" : "0";
          return value + "";
        };
        const escape_html = (str) => {
          return (str + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
        };
        const timeout = (fn, timeout2) => {
          if (timeout2 > 0) {
            return setTimeout(fn, timeout2);
          }
          fn.call(null);
          return null;
        };
        const loadDebounce = (fn, delay) => {
          var timeout2;
          return function(value, callback) {
            var self2 = this;
            if (timeout2) {
              self2.loading = Math.max(self2.loading - 1, 0);
              clearTimeout(timeout2);
            }
            timeout2 = setTimeout(function() {
              timeout2 = null;
              self2.loadedSearches[value] = true;
              fn.call(self2, value, callback);
            }, delay);
          };
        };
        const debounce_events = (self2, types, fn) => {
          var type;
          var trigger = self2.trigger;
          var event_args = {};
          self2.trigger = function() {
            var type2 = arguments[0];
            if (types.indexOf(type2) !== -1) {
              event_args[type2] = arguments;
            } else {
              return trigger.apply(self2, arguments);
            }
          };
          fn.apply(self2, []);
          self2.trigger = trigger;
          for (type of types) {
            if (type in event_args) {
              trigger.apply(self2, event_args[type]);
            }
          }
        };
        const getSelection = (input) => {
          return {
            start: input.selectionStart || 0,
            length: (input.selectionEnd || 0) - (input.selectionStart || 0)
          };
        };
        const preventDefault = (evt, stop = false) => {
          if (evt) {
            evt.preventDefault();
            if (stop) {
              evt.stopPropagation();
            }
          }
        };
        const addEvent = (target, type, callback, options) => {
          target.addEventListener(type, callback, options);
        };
        const isKeyDown = (key_name, evt) => {
          if (!evt) {
            return false;
          }
          if (!evt[key_name]) {
            return false;
          }
          var count = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);
          if (count === 1) {
            return true;
          }
          return false;
        };
        const getId = (el, id) => {
          const existing_id = el.getAttribute("id");
          if (existing_id) {
            return existing_id;
          }
          el.setAttribute("id", id);
          return id;
        };
        const addSlashes = (str) => {
          return str.replace(/[\\"']/g, "\\$&");
        };
        const append = (parent, node) => {
          if (node)
            parent.append(node);
        };
        function getSettings(input, settings_user) {
          var settings = Object.assign({}, defaults, settings_user);
          var attr_data = settings.dataAttr;
          var field_label = settings.labelField;
          var field_value = settings.valueField;
          var field_disabled = settings.disabledField;
          var field_optgroup = settings.optgroupField;
          var field_optgroup_label = settings.optgroupLabelField;
          var field_optgroup_value = settings.optgroupValueField;
          var tag_name = input.tagName.toLowerCase();
          var placeholder = input.getAttribute("placeholder") || input.getAttribute("data-placeholder");
          if (!placeholder && !settings.allowEmptyOption) {
            let option = input.querySelector('option[value=""]');
            if (option) {
              placeholder = option.textContent;
            }
          }
          var settings_element = {
            placeholder,
            options: [],
            optgroups: [],
            items: [],
            maxItems: null
          };
          var init_select = () => {
            var tagName;
            var options = settings_element.options;
            var optionsMap = {};
            var group_count = 1;
            let $order = 0;
            var readData = (el) => {
              var data = Object.assign({}, el.dataset);
              var json = attr_data && data[attr_data];
              if (typeof json === "string" && json.length) {
                data = Object.assign(data, JSON.parse(json));
              }
              return data;
            };
            var addOption = (option, group) => {
              var value = hash_key(option.value);
              if (value == null)
                return;
              if (!value && !settings.allowEmptyOption)
                return;
              if (optionsMap.hasOwnProperty(value)) {
                if (group) {
                  var arr = optionsMap[value][field_optgroup];
                  if (!arr) {
                    optionsMap[value][field_optgroup] = group;
                  } else if (!Array.isArray(arr)) {
                    optionsMap[value][field_optgroup] = [arr, group];
                  } else {
                    arr.push(group);
                  }
                }
              } else {
                var option_data = readData(option);
                option_data[field_label] = option_data[field_label] || option.textContent;
                option_data[field_value] = option_data[field_value] || value;
                option_data[field_disabled] = option_data[field_disabled] || option.disabled;
                option_data[field_optgroup] = option_data[field_optgroup] || group;
                option_data.$option = option;
                option_data.$order = option_data.$order || ++$order;
                optionsMap[value] = option_data;
                options.push(option_data);
              }
              if (option.selected) {
                settings_element.items.push(value);
              }
            };
            var addGroup = (optgroup) => {
              var id, optgroup_data;
              optgroup_data = readData(optgroup);
              optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute("label") || "";
              optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;
              optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;
              optgroup_data.$order = optgroup_data.$order || ++$order;
              settings_element.optgroups.push(optgroup_data);
              id = optgroup_data[field_optgroup_value];
              iterate(optgroup.children, (option) => {
                addOption(option, id);
              });
            };
            settings_element.maxItems = input.hasAttribute("multiple") ? null : 1;
            iterate(input.children, (child) => {
              tagName = child.tagName.toLowerCase();
              if (tagName === "optgroup") {
                addGroup(child);
              } else if (tagName === "option") {
                addOption(child);
              }
            });
          };
          var init_textbox = () => {
            const data_raw = input.getAttribute(attr_data);
            if (!data_raw) {
              var value = input.value.trim() || "";
              if (!settings.allowEmptyOption && !value.length)
                return;
              const values = value.split(settings.delimiter);
              iterate(values, (value2) => {
                const option = {};
                option[field_label] = value2;
                option[field_value] = value2;
                settings_element.options.push(option);
              });
              settings_element.items = values;
            } else {
              settings_element.options = JSON.parse(data_raw);
              iterate(settings_element.options, (opt) => {
                settings_element.items.push(opt[field_value]);
              });
            }
          };
          if (tag_name === "select") {
            init_select();
          } else {
            init_textbox();
          }
          return Object.assign({}, defaults, settings_element, settings_user);
        }
        var instance_i = 0;
        class TomSelect4 extends MicroPlugin(MicroEvent) {
          constructor(input_arg, user_settings) {
            super();
            this.control_input = void 0;
            this.wrapper = void 0;
            this.dropdown = void 0;
            this.control = void 0;
            this.dropdown_content = void 0;
            this.focus_node = void 0;
            this.order = 0;
            this.settings = void 0;
            this.input = void 0;
            this.tabIndex = void 0;
            this.is_select_tag = void 0;
            this.rtl = void 0;
            this.inputId = void 0;
            this._destroy = void 0;
            this.sifter = void 0;
            this.isOpen = false;
            this.isDisabled = false;
            this.isReadOnly = false;
            this.isRequired = void 0;
            this.isInvalid = false;
            this.isValid = true;
            this.isLocked = false;
            this.isFocused = false;
            this.isInputHidden = false;
            this.isSetup = false;
            this.ignoreFocus = false;
            this.ignoreHover = false;
            this.hasOptions = false;
            this.currentResults = void 0;
            this.lastValue = "";
            this.caretPos = 0;
            this.loading = 0;
            this.loadedSearches = {};
            this.activeOption = null;
            this.activeItems = [];
            this.optgroups = {};
            this.options = {};
            this.userOptions = {};
            this.items = [];
            this.refreshTimeout = null;
            instance_i++;
            var dir;
            var input = getDom(input_arg);
            if (input.tomselect) {
              throw new Error("Tom Select already initialized on this element");
            }
            input.tomselect = this;
            var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
            dir = computedStyle.getPropertyValue("direction");
            const settings = getSettings(input, user_settings);
            this.settings = settings;
            this.input = input;
            this.tabIndex = input.tabIndex || 0;
            this.is_select_tag = input.tagName.toLowerCase() === "select";
            this.rtl = /rtl/i.test(dir);
            this.inputId = getId(input, "tomselect-" + instance_i);
            this.isRequired = input.required;
            this.sifter = new Sifter(this.options, {
              diacritics: settings.diacritics
            });
            settings.mode = settings.mode || (settings.maxItems === 1 ? "single" : "multi");
            if (typeof settings.hideSelected !== "boolean") {
              settings.hideSelected = settings.mode === "multi";
            }
            if (typeof settings.hidePlaceholder !== "boolean") {
              settings.hidePlaceholder = settings.mode !== "multi";
            }
            var filter = settings.createFilter;
            if (typeof filter !== "function") {
              if (typeof filter === "string") {
                filter = new RegExp(filter);
              }
              if (filter instanceof RegExp) {
                settings.createFilter = (input2) => filter.test(input2);
              } else {
                settings.createFilter = (value) => {
                  return this.settings.duplicates || !this.options[value];
                };
              }
            }
            this.initializePlugins(settings.plugins);
            this.setupCallbacks();
            this.setupTemplates();
            const wrapper = getDom("<div>");
            const control = getDom("<div>");
            const dropdown = this._render("dropdown");
            const dropdown_content = getDom(`<div role="listbox" tabindex="-1">`);
            const classes = this.input.getAttribute("class") || "";
            const inputMode = settings.mode;
            var control_input;
            addClasses(wrapper, settings.wrapperClass, classes, inputMode);
            addClasses(control, settings.controlClass);
            append(wrapper, control);
            addClasses(dropdown, settings.dropdownClass, inputMode);
            if (settings.copyClassesToDropdown) {
              addClasses(dropdown, classes);
            }
            addClasses(dropdown_content, settings.dropdownContentClass);
            append(dropdown, dropdown_content);
            getDom(settings.dropdownParent || wrapper).appendChild(dropdown);
            if (isHtmlString(settings.controlInput)) {
              control_input = getDom(settings.controlInput);
              var attrs = ["autocorrect", "autocapitalize", "autocomplete", "spellcheck"];
              iterate$1(attrs, (attr) => {
                if (input.getAttribute(attr)) {
                  setAttr(control_input, {
                    [attr]: input.getAttribute(attr)
                  });
                }
              });
              control_input.tabIndex = -1;
              control.appendChild(control_input);
              this.focus_node = control_input;
            } else if (settings.controlInput) {
              control_input = getDom(settings.controlInput);
              this.focus_node = control_input;
            } else {
              control_input = getDom("<input/>");
              this.focus_node = control;
            }
            this.wrapper = wrapper;
            this.dropdown = dropdown;
            this.dropdown_content = dropdown_content;
            this.control = control;
            this.control_input = control_input;
            this.setup();
          }
          setup() {
            const self2 = this;
            const settings = self2.settings;
            const control_input = self2.control_input;
            const dropdown = self2.dropdown;
            const dropdown_content = self2.dropdown_content;
            const wrapper = self2.wrapper;
            const control = self2.control;
            const input = self2.input;
            const focus_node = self2.focus_node;
            const passive_event = {
              passive: true
            };
            const listboxId = self2.inputId + "-ts-dropdown";
            setAttr(dropdown_content, {
              id: listboxId
            });
            setAttr(focus_node, {
              role: "combobox",
              "aria-haspopup": "listbox",
              "aria-expanded": "false",
              "aria-controls": listboxId
            });
            const control_id = getId(focus_node, self2.inputId + "-ts-control");
            const query = "label[for='" + escapeQuery(self2.inputId) + "']";
            const label = document.querySelector(query);
            const label_click = self2.focus.bind(self2);
            if (label) {
              addEvent(label, "click", label_click);
              setAttr(label, {
                for: control_id
              });
              const label_id = getId(label, self2.inputId + "-ts-label");
              setAttr(focus_node, {
                "aria-labelledby": label_id
              });
              setAttr(dropdown_content, {
                "aria-labelledby": label_id
              });
            }
            wrapper.style.width = input.style.width;
            if (self2.plugins.names.length) {
              const classes_plugins = "plugin-" + self2.plugins.names.join(" plugin-");
              addClasses([wrapper, dropdown], classes_plugins);
            }
            if ((settings.maxItems === null || settings.maxItems > 1) && self2.is_select_tag) {
              setAttr(input, {
                multiple: "multiple"
              });
            }
            if (settings.placeholder) {
              setAttr(control_input, {
                placeholder: settings.placeholder
              });
            }
            if (!settings.splitOn && settings.delimiter) {
              settings.splitOn = new RegExp("\\s*" + escape_regex(settings.delimiter) + "+\\s*");
            }
            if (settings.load && settings.loadThrottle) {
              settings.load = loadDebounce(settings.load, settings.loadThrottle);
            }
            addEvent(dropdown, "mousemove", () => {
              self2.ignoreHover = false;
            });
            addEvent(dropdown, "mouseenter", (e) => {
              var target_match = parentMatch(e.target, "[data-selectable]", dropdown);
              if (target_match)
                self2.onOptionHover(e, target_match);
            }, {
              capture: true
            });
            addEvent(dropdown, "click", (evt) => {
              const option = parentMatch(evt.target, "[data-selectable]");
              if (option) {
                self2.onOptionSelect(evt, option);
                preventDefault(evt, true);
              }
            });
            addEvent(control, "click", (evt) => {
              var target_match = parentMatch(evt.target, "[data-ts-item]", control);
              if (target_match && self2.onItemSelect(evt, target_match)) {
                preventDefault(evt, true);
                return;
              }
              if (control_input.value != "") {
                return;
              }
              self2.onClick();
              preventDefault(evt, true);
            });
            addEvent(focus_node, "keydown", (e) => self2.onKeyDown(e));
            addEvent(control_input, "keypress", (e) => self2.onKeyPress(e));
            addEvent(control_input, "input", (e) => self2.onInput(e));
            addEvent(focus_node, "blur", (e) => self2.onBlur(e));
            addEvent(focus_node, "focus", (e) => self2.onFocus(e));
            addEvent(control_input, "paste", (e) => self2.onPaste(e));
            const doc_mousedown = (evt) => {
              const target = evt.composedPath()[0];
              if (!wrapper.contains(target) && !dropdown.contains(target)) {
                if (self2.isFocused) {
                  self2.blur();
                }
                self2.inputState();
                return;
              }
              if (target == control_input && self2.isOpen) {
                evt.stopPropagation();
              } else {
                preventDefault(evt, true);
              }
            };
            const win_scroll = () => {
              if (self2.isOpen) {
                self2.positionDropdown();
              }
            };
            addEvent(document, "mousedown", doc_mousedown);
            addEvent(window, "scroll", win_scroll, passive_event);
            addEvent(window, "resize", win_scroll, passive_event);
            this._destroy = () => {
              document.removeEventListener("mousedown", doc_mousedown);
              window.removeEventListener("scroll", win_scroll);
              window.removeEventListener("resize", win_scroll);
              if (label)
                label.removeEventListener("click", label_click);
            };
            this.revertSettings = {
              innerHTML: input.innerHTML,
              tabIndex: input.tabIndex
            };
            input.tabIndex = -1;
            input.insertAdjacentElement("afterend", self2.wrapper);
            self2.sync(false);
            settings.items = [];
            delete settings.optgroups;
            delete settings.options;
            addEvent(input, "invalid", () => {
              if (self2.isValid) {
                self2.isValid = false;
                self2.isInvalid = true;
                self2.refreshState();
              }
            });
            self2.updateOriginalInput();
            self2.refreshItems();
            self2.close(false);
            self2.inputState();
            self2.isSetup = true;
            if (input.disabled) {
              self2.disable();
            } else if (input.readOnly) {
              self2.setReadOnly(true);
            } else {
              self2.enable();
            }
            self2.on("change", this.onChange);
            addClasses(input, "tomselected", "ts-hidden-accessible");
            self2.trigger("initialize");
            if (settings.preload === true) {
              self2.preload();
            }
          }
          setupOptions(options = [], optgroups = []) {
            this.addOptions(options);
            iterate$1(optgroups, (optgroup) => {
              this.registerOptionGroup(optgroup);
            });
          }
          setupTemplates() {
            var self2 = this;
            var field_label = self2.settings.labelField;
            var field_optgroup = self2.settings.optgroupLabelField;
            var templates = {
              "optgroup": (data) => {
                let optgroup = document.createElement("div");
                optgroup.className = "optgroup";
                optgroup.appendChild(data.options);
                return optgroup;
              },
              "optgroup_header": (data, escape) => {
                return '<div class="optgroup-header">' + escape(data[field_optgroup]) + "</div>";
              },
              "option": (data, escape) => {
                return "<div>" + escape(data[field_label]) + "</div>";
              },
              "item": (data, escape) => {
                return "<div>" + escape(data[field_label]) + "</div>";
              },
              "option_create": (data, escape) => {
                return '<div class="create">Add <strong>' + escape(data.input) + "</strong>&hellip;</div>";
              },
              "no_results": () => {
                return '<div class="no-results">No results found</div>';
              },
              "loading": () => {
                return '<div class="spinner"></div>';
              },
              "not_loading": () => {
              },
              "dropdown": () => {
                return "<div></div>";
              }
            };
            self2.settings.render = Object.assign({}, templates, self2.settings.render);
          }
          setupCallbacks() {
            var key, fn;
            var callbacks = {
              "initialize": "onInitialize",
              "change": "onChange",
              "item_add": "onItemAdd",
              "item_remove": "onItemRemove",
              "item_select": "onItemSelect",
              "clear": "onClear",
              "option_add": "onOptionAdd",
              "option_remove": "onOptionRemove",
              "option_clear": "onOptionClear",
              "optgroup_add": "onOptionGroupAdd",
              "optgroup_remove": "onOptionGroupRemove",
              "optgroup_clear": "onOptionGroupClear",
              "dropdown_open": "onDropdownOpen",
              "dropdown_close": "onDropdownClose",
              "type": "onType",
              "load": "onLoad",
              "focus": "onFocus",
              "blur": "onBlur"
            };
            for (key in callbacks) {
              fn = this.settings[callbacks[key]];
              if (fn)
                this.on(key, fn);
            }
          }
          sync(get_settings = true) {
            const self2 = this;
            const settings = get_settings ? getSettings(self2.input, {
              delimiter: self2.settings.delimiter
            }) : self2.settings;
            self2.setupOptions(settings.options, settings.optgroups);
            self2.setValue(settings.items || [], true);
            self2.lastQuery = null;
          }
          onClick() {
            var self2 = this;
            if (self2.activeItems.length > 0) {
              self2.clearActiveItems();
              self2.focus();
              return;
            }
            if (self2.isFocused && self2.isOpen) {
              self2.blur();
            } else {
              self2.focus();
            }
          }
          onMouseDown() {
          }
          onChange() {
            triggerEvent(this.input, "input");
            triggerEvent(this.input, "change");
          }
          onPaste(e) {
            var self2 = this;
            if (self2.isInputHidden || self2.isLocked) {
              preventDefault(e);
              return;
            }
            if (!self2.settings.splitOn) {
              return;
            }
            setTimeout(() => {
              var pastedText = self2.inputValue();
              if (!pastedText.match(self2.settings.splitOn)) {
                return;
              }
              var splitInput = pastedText.trim().split(self2.settings.splitOn);
              iterate$1(splitInput, (piece) => {
                const hash = hash_key(piece);
                if (hash) {
                  if (this.options[piece]) {
                    self2.addItem(piece);
                  } else {
                    self2.createItem(piece);
                  }
                }
              });
            }, 0);
          }
          onKeyPress(e) {
            var self2 = this;
            if (self2.isLocked) {
              preventDefault(e);
              return;
            }
            var character = String.fromCharCode(e.keyCode || e.which);
            if (self2.settings.create && self2.settings.mode === "multi" && character === self2.settings.delimiter) {
              self2.createItem();
              preventDefault(e);
              return;
            }
          }
          onKeyDown(e) {
            var self2 = this;
            self2.ignoreHover = true;
            if (self2.isLocked) {
              if (e.keyCode !== KEY_TAB) {
                preventDefault(e);
              }
              return;
            }
            switch (e.keyCode) {
              case KEY_A:
                if (isKeyDown(KEY_SHORTCUT, e)) {
                  if (self2.control_input.value == "") {
                    preventDefault(e);
                    self2.selectAll();
                    return;
                  }
                }
                break;
              case KEY_ESC:
                if (self2.isOpen) {
                  preventDefault(e, true);
                  self2.close();
                }
                self2.clearActiveItems();
                return;
              case KEY_DOWN:
                if (!self2.isOpen && self2.hasOptions) {
                  self2.open();
                } else if (self2.activeOption) {
                  let next = self2.getAdjacent(self2.activeOption, 1);
                  if (next)
                    self2.setActiveOption(next);
                }
                preventDefault(e);
                return;
              case KEY_UP:
                if (self2.activeOption) {
                  let prev = self2.getAdjacent(self2.activeOption, -1);
                  if (prev)
                    self2.setActiveOption(prev);
                }
                preventDefault(e);
                return;
              case KEY_RETURN:
                if (self2.canSelect(self2.activeOption)) {
                  self2.onOptionSelect(e, self2.activeOption);
                  preventDefault(e);
                } else if (self2.settings.create && self2.createItem()) {
                  preventDefault(e);
                } else if (document.activeElement == self2.control_input && self2.isOpen) {
                  preventDefault(e);
                }
                return;
              case KEY_LEFT:
                self2.advanceSelection(-1, e);
                return;
              case KEY_RIGHT:
                self2.advanceSelection(1, e);
                return;
              case KEY_TAB:
                if (self2.settings.selectOnTab) {
                  if (self2.canSelect(self2.activeOption)) {
                    self2.onOptionSelect(e, self2.activeOption);
                    preventDefault(e);
                  }
                  if (self2.settings.create && self2.createItem()) {
                    preventDefault(e);
                  }
                }
                return;
              case KEY_BACKSPACE:
              case KEY_DELETE:
                self2.deleteSelection(e);
                return;
            }
            if (self2.isInputHidden && !isKeyDown(KEY_SHORTCUT, e)) {
              preventDefault(e);
            }
          }
          onInput(e) {
            if (this.isLocked) {
              return;
            }
            const value = this.inputValue();
            if (this.lastValue === value)
              return;
            this.lastValue = value;
            if (value == "") {
              this._onInput();
              return;
            }
            if (this.refreshTimeout) {
              clearTimeout(this.refreshTimeout);
            }
            this.refreshTimeout = timeout(() => {
              this.refreshTimeout = null;
              this._onInput();
            }, this.settings.refreshThrottle);
          }
          _onInput() {
            const value = this.lastValue;
            if (this.settings.shouldLoad.call(this, value)) {
              this.load(value);
            }
            this.refreshOptions();
            this.trigger("type", value);
          }
          onOptionHover(evt, option) {
            if (this.ignoreHover)
              return;
            this.setActiveOption(option, false);
          }
          onFocus(e) {
            var self2 = this;
            var wasFocused = self2.isFocused;
            if (self2.isDisabled || self2.isReadOnly) {
              self2.blur();
              preventDefault(e);
              return;
            }
            if (self2.ignoreFocus)
              return;
            self2.isFocused = true;
            if (self2.settings.preload === "focus")
              self2.preload();
            if (!wasFocused)
              self2.trigger("focus");
            if (!self2.activeItems.length) {
              self2.inputState();
              self2.refreshOptions(!!self2.settings.openOnFocus);
            }
            self2.refreshState();
          }
          onBlur(e) {
            if (document.hasFocus() === false)
              return;
            var self2 = this;
            if (!self2.isFocused)
              return;
            self2.isFocused = false;
            self2.ignoreFocus = false;
            var deactivate = () => {
              self2.close();
              self2.setActiveItem();
              self2.setCaret(self2.items.length);
              self2.trigger("blur");
            };
            if (self2.settings.create && self2.settings.createOnBlur) {
              self2.createItem(null, deactivate);
            } else {
              deactivate();
            }
          }
          onOptionSelect(evt, option) {
            var value, self2 = this;
            if (option.parentElement && option.parentElement.matches("[data-disabled]")) {
              return;
            }
            if (option.classList.contains("create")) {
              self2.createItem(null, () => {
                if (self2.settings.closeAfterSelect) {
                  self2.close();
                }
              });
            } else {
              value = option.dataset.value;
              if (typeof value !== "undefined") {
                self2.lastQuery = null;
                self2.addItem(value);
                if (self2.settings.closeAfterSelect) {
                  self2.close();
                }
                if (!self2.settings.hideSelected && evt.type && /click/.test(evt.type)) {
                  self2.setActiveOption(option);
                }
              }
            }
          }
          canSelect(option) {
            if (this.isOpen && option && this.dropdown_content.contains(option)) {
              return true;
            }
            return false;
          }
          onItemSelect(evt, item) {
            var self2 = this;
            if (!self2.isLocked && self2.settings.mode === "multi") {
              preventDefault(evt);
              self2.setActiveItem(item, evt);
              return true;
            }
            return false;
          }
          canLoad(value) {
            if (!this.settings.load)
              return false;
            if (this.loadedSearches.hasOwnProperty(value))
              return false;
            return true;
          }
          load(value) {
            const self2 = this;
            if (!self2.canLoad(value))
              return;
            addClasses(self2.wrapper, self2.settings.loadingClass);
            self2.loading++;
            const callback = self2.loadCallback.bind(self2);
            self2.settings.load.call(self2, value, callback);
          }
          loadCallback(options, optgroups) {
            const self2 = this;
            self2.loading = Math.max(self2.loading - 1, 0);
            self2.lastQuery = null;
            self2.clearActiveOption();
            self2.setupOptions(options, optgroups);
            self2.refreshOptions(self2.isFocused && !self2.isInputHidden);
            if (!self2.loading) {
              removeClasses(self2.wrapper, self2.settings.loadingClass);
            }
            self2.trigger("load", options, optgroups);
          }
          preload() {
            var classList = this.wrapper.classList;
            if (classList.contains("preloaded"))
              return;
            classList.add("preloaded");
            this.load("");
          }
          setTextboxValue(value = "") {
            var input = this.control_input;
            var changed = input.value !== value;
            if (changed) {
              input.value = value;
              triggerEvent(input, "update");
              this.lastValue = value;
            }
          }
          getValue() {
            if (this.is_select_tag && this.input.hasAttribute("multiple")) {
              return this.items;
            }
            return this.items.join(this.settings.delimiter);
          }
          setValue(value, silent) {
            var events = silent ? [] : ["change"];
            debounce_events(this, events, () => {
              this.clear(silent);
              this.addItems(value, silent);
            });
          }
          setMaxItems(value) {
            if (value === 0)
              value = null;
            this.settings.maxItems = value;
            this.refreshState();
          }
          setActiveItem(item, e) {
            var self2 = this;
            var eventName;
            var i, begin, end, swap;
            var last;
            if (self2.settings.mode === "single")
              return;
            if (!item) {
              self2.clearActiveItems();
              if (self2.isFocused) {
                self2.inputState();
              }
              return;
            }
            eventName = e && e.type.toLowerCase();
            if (eventName === "click" && isKeyDown("shiftKey", e) && self2.activeItems.length) {
              last = self2.getLastActive();
              begin = Array.prototype.indexOf.call(self2.control.children, last);
              end = Array.prototype.indexOf.call(self2.control.children, item);
              if (begin > end) {
                swap = begin;
                begin = end;
                end = swap;
              }
              for (i = begin; i <= end; i++) {
                item = self2.control.children[i];
                if (self2.activeItems.indexOf(item) === -1) {
                  self2.setActiveItemClass(item);
                }
              }
              preventDefault(e);
            } else if (eventName === "click" && isKeyDown(KEY_SHORTCUT, e) || eventName === "keydown" && isKeyDown("shiftKey", e)) {
              if (item.classList.contains("active")) {
                self2.removeActiveItem(item);
              } else {
                self2.setActiveItemClass(item);
              }
            } else {
              self2.clearActiveItems();
              self2.setActiveItemClass(item);
            }
            self2.inputState();
            if (!self2.isFocused) {
              self2.focus();
            }
          }
          setActiveItemClass(item) {
            const self2 = this;
            const last_active = self2.control.querySelector(".last-active");
            if (last_active)
              removeClasses(last_active, "last-active");
            addClasses(item, "active last-active");
            self2.trigger("item_select", item);
            if (self2.activeItems.indexOf(item) == -1) {
              self2.activeItems.push(item);
            }
          }
          removeActiveItem(item) {
            var idx = this.activeItems.indexOf(item);
            this.activeItems.splice(idx, 1);
            removeClasses(item, "active");
          }
          clearActiveItems() {
            removeClasses(this.activeItems, "active");
            this.activeItems = [];
          }
          setActiveOption(option, scroll2 = true) {
            if (option === this.activeOption) {
              return;
            }
            this.clearActiveOption();
            if (!option)
              return;
            this.activeOption = option;
            setAttr(this.focus_node, {
              "aria-activedescendant": option.getAttribute("id")
            });
            setAttr(option, {
              "aria-selected": "true"
            });
            addClasses(option, "active");
            if (scroll2)
              this.scrollToOption(option);
          }
          scrollToOption(option, behavior) {
            if (!option)
              return;
            const content = this.dropdown_content;
            const height_menu = content.clientHeight;
            const scrollTop = content.scrollTop || 0;
            const height_item = option.offsetHeight;
            const y = option.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;
            if (y + height_item > height_menu + scrollTop) {
              this.scroll(y - height_menu + height_item, behavior);
            } else if (y < scrollTop) {
              this.scroll(y, behavior);
            }
          }
          scroll(scrollTop, behavior) {
            const content = this.dropdown_content;
            if (behavior) {
              content.style.scrollBehavior = behavior;
            }
            content.scrollTop = scrollTop;
            content.style.scrollBehavior = "";
          }
          clearActiveOption() {
            if (this.activeOption) {
              removeClasses(this.activeOption, "active");
              setAttr(this.activeOption, {
                "aria-selected": null
              });
            }
            this.activeOption = null;
            setAttr(this.focus_node, {
              "aria-activedescendant": null
            });
          }
          selectAll() {
            const self2 = this;
            if (self2.settings.mode === "single")
              return;
            const activeItems = self2.controlChildren();
            if (!activeItems.length)
              return;
            self2.inputState();
            self2.close();
            self2.activeItems = activeItems;
            iterate$1(activeItems, (item) => {
              self2.setActiveItemClass(item);
            });
          }
          inputState() {
            var self2 = this;
            if (!self2.control.contains(self2.control_input))
              return;
            setAttr(self2.control_input, {
              placeholder: self2.settings.placeholder
            });
            if (self2.activeItems.length > 0 || !self2.isFocused && self2.settings.hidePlaceholder && self2.items.length > 0) {
              self2.setTextboxValue();
              self2.isInputHidden = true;
            } else {
              if (self2.settings.hidePlaceholder && self2.items.length > 0) {
                setAttr(self2.control_input, {
                  placeholder: ""
                });
              }
              self2.isInputHidden = false;
            }
            self2.wrapper.classList.toggle("input-hidden", self2.isInputHidden);
          }
          inputValue() {
            return this.control_input.value.trim();
          }
          focus() {
            var self2 = this;
            if (self2.isDisabled || self2.isReadOnly)
              return;
            self2.ignoreFocus = true;
            if (self2.control_input.offsetWidth) {
              self2.control_input.focus();
            } else {
              self2.focus_node.focus();
            }
            setTimeout(() => {
              self2.ignoreFocus = false;
              self2.onFocus();
            }, 0);
          }
          blur() {
            this.focus_node.blur();
            this.onBlur();
          }
          getScoreFunction(query) {
            return this.sifter.getScoreFunction(query, this.getSearchOptions());
          }
          getSearchOptions() {
            var settings = this.settings;
            var sort = settings.sortField;
            if (typeof settings.sortField === "string") {
              sort = [{
                field: settings.sortField
              }];
            }
            return {
              fields: settings.searchField,
              conjunction: settings.searchConjunction,
              sort,
              nesting: settings.nesting
            };
          }
          search(query) {
            var result, calculateScore;
            var self2 = this;
            var options = this.getSearchOptions();
            if (self2.settings.score) {
              calculateScore = self2.settings.score.call(self2, query);
              if (typeof calculateScore !== "function") {
                throw new Error('Tom Select "score" setting must be a function that returns a function');
              }
            }
            if (query !== self2.lastQuery) {
              self2.lastQuery = query;
              result = self2.sifter.search(query, Object.assign(options, {
                score: calculateScore
              }));
              self2.currentResults = result;
            } else {
              result = Object.assign({}, self2.currentResults);
            }
            if (self2.settings.hideSelected) {
              result.items = result.items.filter((item) => {
                let hashed = hash_key(item.id);
                return !(hashed && self2.items.indexOf(hashed) !== -1);
              });
            }
            return result;
          }
          refreshOptions(triggerDropdown = true) {
            var i, j, k, n, optgroup, optgroups, html, has_create_option, active_group;
            var create;
            const groups = {};
            const groups_order = [];
            var self2 = this;
            var query = self2.inputValue();
            const same_query = query === self2.lastQuery || query == "" && self2.lastQuery == null;
            var results = self2.search(query);
            var active_option = null;
            var show_dropdown = self2.settings.shouldOpen || false;
            var dropdown_content = self2.dropdown_content;
            if (same_query) {
              active_option = self2.activeOption;
              if (active_option) {
                active_group = active_option.closest("[data-group]");
              }
            }
            n = results.items.length;
            if (typeof self2.settings.maxOptions === "number") {
              n = Math.min(n, self2.settings.maxOptions);
            }
            if (n > 0) {
              show_dropdown = true;
            }
            const getGroupFragment = (optgroup2, order) => {
              let group_order_i = groups[optgroup2];
              if (group_order_i !== void 0) {
                let order_group = groups_order[group_order_i];
                if (order_group !== void 0) {
                  return [group_order_i, order_group.fragment];
                }
              }
              let group_fragment = document.createDocumentFragment();
              group_order_i = groups_order.length;
              groups_order.push({
                fragment: group_fragment,
                order,
                optgroup: optgroup2
              });
              return [group_order_i, group_fragment];
            };
            for (i = 0; i < n; i++) {
              let item = results.items[i];
              if (!item)
                continue;
              let opt_value = item.id;
              let option = self2.options[opt_value];
              if (option === void 0)
                continue;
              let opt_hash = get_hash(opt_value);
              let option_el = self2.getOption(opt_hash, true);
              if (!self2.settings.hideSelected) {
                option_el.classList.toggle("selected", self2.items.includes(opt_hash));
              }
              optgroup = option[self2.settings.optgroupField] || "";
              optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];
              for (j = 0, k = optgroups && optgroups.length; j < k; j++) {
                optgroup = optgroups[j];
                let order = option.$order;
                let self_optgroup = self2.optgroups[optgroup];
                if (self_optgroup === void 0) {
                  optgroup = "";
                } else {
                  order = self_optgroup.$order;
                }
                const [group_order_i, group_fragment] = getGroupFragment(optgroup, order);
                if (j > 0) {
                  option_el = option_el.cloneNode(true);
                  setAttr(option_el, {
                    id: option.$id + "-clone-" + j,
                    "aria-selected": null
                  });
                  option_el.classList.add("ts-cloned");
                  removeClasses(option_el, "active");
                  if (self2.activeOption && self2.activeOption.dataset.value == opt_value) {
                    if (active_group && active_group.dataset.group === optgroup.toString()) {
                      active_option = option_el;
                    }
                  }
                }
                group_fragment.appendChild(option_el);
                if (optgroup != "") {
                  groups[optgroup] = group_order_i;
                }
              }
            }
            if (self2.settings.lockOptgroupOrder) {
              groups_order.sort((a, b) => {
                return a.order - b.order;
              });
            }
            html = document.createDocumentFragment();
            iterate$1(groups_order, (group_order) => {
              let group_fragment = group_order.fragment;
              let optgroup2 = group_order.optgroup;
              if (!group_fragment || !group_fragment.children.length)
                return;
              let group_heading = self2.optgroups[optgroup2];
              if (group_heading !== void 0) {
                let group_options = document.createDocumentFragment();
                let header = self2.render("optgroup_header", group_heading);
                append(group_options, header);
                append(group_options, group_fragment);
                let group_html = self2.render("optgroup", {
                  group: group_heading,
                  options: group_options
                });
                append(html, group_html);
              } else {
                append(html, group_fragment);
              }
            });
            dropdown_content.innerHTML = "";
            append(dropdown_content, html);
            if (self2.settings.highlight) {
              removeHighlight(dropdown_content);
              if (results.query.length && results.tokens.length) {
                iterate$1(results.tokens, (tok) => {
                  highlight(dropdown_content, tok.regex);
                });
              }
            }
            var add_template = (template) => {
              let content = self2.render(template, {
                input: query
              });
              if (content) {
                show_dropdown = true;
                dropdown_content.insertBefore(content, dropdown_content.firstChild);
              }
              return content;
            };
            if (self2.loading) {
              add_template("loading");
            } else if (!self2.settings.shouldLoad.call(self2, query)) {
              add_template("not_loading");
            } else if (results.items.length === 0) {
              add_template("no_results");
            }
            has_create_option = self2.canCreate(query);
            if (has_create_option) {
              create = add_template("option_create");
            }
            self2.hasOptions = results.items.length > 0 || has_create_option;
            if (show_dropdown) {
              if (results.items.length > 0) {
                if (!active_option && self2.settings.mode === "single" && self2.items[0] != void 0) {
                  active_option = self2.getOption(self2.items[0]);
                }
                if (!dropdown_content.contains(active_option)) {
                  let active_index = 0;
                  if (create && !self2.settings.addPrecedence) {
                    active_index = 1;
                  }
                  active_option = self2.selectable()[active_index];
                }
              } else if (create) {
                active_option = create;
              }
              if (triggerDropdown && !self2.isOpen) {
                self2.open();
                self2.scrollToOption(active_option, "auto");
              }
              self2.setActiveOption(active_option);
            } else {
              self2.clearActiveOption();
              if (triggerDropdown && self2.isOpen) {
                self2.close(false);
              }
            }
          }
          selectable() {
            return this.dropdown_content.querySelectorAll("[data-selectable]");
          }
          addOption(data, user_created = false) {
            const self2 = this;
            if (Array.isArray(data)) {
              self2.addOptions(data, user_created);
              return false;
            }
            const key = hash_key(data[self2.settings.valueField]);
            if (key === null || self2.options.hasOwnProperty(key)) {
              return false;
            }
            data.$order = data.$order || ++self2.order;
            data.$id = self2.inputId + "-opt-" + data.$order;
            self2.options[key] = data;
            self2.lastQuery = null;
            if (user_created) {
              self2.userOptions[key] = user_created;
              self2.trigger("option_add", key, data);
            }
            return key;
          }
          addOptions(data, user_created = false) {
            iterate$1(data, (dat) => {
              this.addOption(dat, user_created);
            });
          }
          registerOption(data) {
            return this.addOption(data);
          }
          registerOptionGroup(data) {
            var key = hash_key(data[this.settings.optgroupValueField]);
            if (key === null)
              return false;
            data.$order = data.$order || ++this.order;
            this.optgroups[key] = data;
            return key;
          }
          addOptionGroup(id, data) {
            var hashed_id;
            data[this.settings.optgroupValueField] = id;
            if (hashed_id = this.registerOptionGroup(data)) {
              this.trigger("optgroup_add", hashed_id, data);
            }
          }
          removeOptionGroup(id) {
            if (this.optgroups.hasOwnProperty(id)) {
              delete this.optgroups[id];
              this.clearCache();
              this.trigger("optgroup_remove", id);
            }
          }
          clearOptionGroups() {
            this.optgroups = {};
            this.clearCache();
            this.trigger("optgroup_clear");
          }
          updateOption(value, data) {
            const self2 = this;
            var item_new;
            var index_item;
            const value_old = hash_key(value);
            const value_new = hash_key(data[self2.settings.valueField]);
            if (value_old === null)
              return;
            const data_old = self2.options[value_old];
            if (data_old == void 0)
              return;
            if (typeof value_new !== "string")
              throw new Error("Value must be set in option data");
            const option = self2.getOption(value_old);
            const item = self2.getItem(value_old);
            data.$order = data.$order || data_old.$order;
            delete self2.options[value_old];
            self2.uncacheValue(value_new);
            self2.options[value_new] = data;
            if (option) {
              if (self2.dropdown_content.contains(option)) {
                const option_new = self2._render("option", data);
                replaceNode(option, option_new);
                if (self2.activeOption === option) {
                  self2.setActiveOption(option_new);
                }
              }
              option.remove();
            }
            if (item) {
              index_item = self2.items.indexOf(value_old);
              if (index_item !== -1) {
                self2.items.splice(index_item, 1, value_new);
              }
              item_new = self2._render("item", data);
              if (item.classList.contains("active"))
                addClasses(item_new, "active");
              replaceNode(item, item_new);
            }
            self2.lastQuery = null;
          }
          removeOption(value, silent) {
            const self2 = this;
            value = get_hash(value);
            self2.uncacheValue(value);
            delete self2.userOptions[value];
            delete self2.options[value];
            self2.lastQuery = null;
            self2.trigger("option_remove", value);
            self2.removeItem(value, silent);
          }
          clearOptions(filter) {
            const boundFilter = (filter || this.clearFilter).bind(this);
            this.loadedSearches = {};
            this.userOptions = {};
            this.clearCache();
            const selected = {};
            iterate$1(this.options, (option, key) => {
              if (boundFilter(option, key)) {
                selected[key] = option;
              }
            });
            this.options = this.sifter.items = selected;
            this.lastQuery = null;
            this.trigger("option_clear");
          }
          clearFilter(option, value) {
            if (this.items.indexOf(value) >= 0) {
              return true;
            }
            return false;
          }
          getOption(value, create = false) {
            const hashed = hash_key(value);
            if (hashed === null)
              return null;
            const option = this.options[hashed];
            if (option != void 0) {
              if (option.$div) {
                return option.$div;
              }
              if (create) {
                return this._render("option", option);
              }
            }
            return null;
          }
          getAdjacent(option, direction, type = "option") {
            var self2 = this, all;
            if (!option) {
              return null;
            }
            if (type == "item") {
              all = self2.controlChildren();
            } else {
              all = self2.dropdown_content.querySelectorAll("[data-selectable]");
            }
            for (let i = 0; i < all.length; i++) {
              if (all[i] != option) {
                continue;
              }
              if (direction > 0) {
                return all[i + 1];
              }
              return all[i - 1];
            }
            return null;
          }
          getItem(item) {
            if (typeof item == "object") {
              return item;
            }
            var value = hash_key(item);
            return value !== null ? this.control.querySelector(`[data-value="${addSlashes(value)}"]`) : null;
          }
          addItems(values, silent) {
            var self2 = this;
            var items = Array.isArray(values) ? values : [values];
            items = items.filter((x) => self2.items.indexOf(x) === -1);
            const last_item = items[items.length - 1];
            items.forEach((item) => {
              self2.isPending = item !== last_item;
              self2.addItem(item, silent);
            });
          }
          addItem(value, silent) {
            var events = silent ? [] : ["change", "dropdown_close"];
            debounce_events(this, events, () => {
              var item, wasFull;
              const self2 = this;
              const inputMode = self2.settings.mode;
              const hashed = hash_key(value);
              if (hashed && self2.items.indexOf(hashed) !== -1) {
                if (inputMode === "single") {
                  self2.close();
                }
                if (inputMode === "single" || !self2.settings.duplicates) {
                  return;
                }
              }
              if (hashed === null || !self2.options.hasOwnProperty(hashed))
                return;
              if (inputMode === "single")
                self2.clear(silent);
              if (inputMode === "multi" && self2.isFull())
                return;
              item = self2._render("item", self2.options[hashed]);
              if (self2.control.contains(item)) {
                item = item.cloneNode(true);
              }
              wasFull = self2.isFull();
              self2.items.splice(self2.caretPos, 0, hashed);
              self2.insertAtCaret(item);
              if (self2.isSetup) {
                if (!self2.isPending && self2.settings.hideSelected) {
                  let option = self2.getOption(hashed);
                  let next = self2.getAdjacent(option, 1);
                  if (next) {
                    self2.setActiveOption(next);
                  }
                }
                if (!self2.isPending && !self2.settings.closeAfterSelect) {
                  self2.refreshOptions(self2.isFocused && inputMode !== "single");
                }
                if (self2.settings.closeAfterSelect != false && self2.isFull()) {
                  self2.close();
                } else if (!self2.isPending) {
                  self2.positionDropdown();
                }
                self2.trigger("item_add", hashed, item);
                if (!self2.isPending) {
                  self2.updateOriginalInput({
                    silent
                  });
                }
              }
              if (!self2.isPending || !wasFull && self2.isFull()) {
                self2.inputState();
                self2.refreshState();
              }
            });
          }
          removeItem(item = null, silent) {
            const self2 = this;
            item = self2.getItem(item);
            if (!item)
              return;
            var i, idx;
            const value = item.dataset.value;
            i = nodeIndex(item);
            item.remove();
            if (item.classList.contains("active")) {
              idx = self2.activeItems.indexOf(item);
              self2.activeItems.splice(idx, 1);
              removeClasses(item, "active");
            }
            self2.items.splice(i, 1);
            self2.lastQuery = null;
            if (!self2.settings.persist && self2.userOptions.hasOwnProperty(value)) {
              self2.removeOption(value, silent);
            }
            if (i < self2.caretPos) {
              self2.setCaret(self2.caretPos - 1);
            }
            self2.updateOriginalInput({
              silent
            });
            self2.refreshState();
            self2.positionDropdown();
            self2.trigger("item_remove", value, item);
          }
          createItem(input = null, callback = () => {
          }) {
            if (arguments.length === 3) {
              callback = arguments[2];
            }
            if (typeof callback != "function") {
              callback = () => {
              };
            }
            var self2 = this;
            var caret = self2.caretPos;
            var output;
            input = input || self2.inputValue();
            if (!self2.canCreate(input)) {
              callback();
              return false;
            }
            self2.lock();
            var created = false;
            var create = (data) => {
              self2.unlock();
              if (!data || typeof data !== "object")
                return callback();
              var value = hash_key(data[self2.settings.valueField]);
              if (typeof value !== "string") {
                return callback();
              }
              self2.setTextboxValue();
              self2.addOption(data, true);
              self2.setCaret(caret);
              self2.addItem(value);
              callback(data);
              created = true;
            };
            if (typeof self2.settings.create === "function") {
              output = self2.settings.create.call(this, input, create);
            } else {
              output = {
                [self2.settings.labelField]: input,
                [self2.settings.valueField]: input
              };
            }
            if (!created) {
              create(output);
            }
            return true;
          }
          refreshItems() {
            var self2 = this;
            self2.lastQuery = null;
            if (self2.isSetup) {
              self2.addItems(self2.items);
            }
            self2.updateOriginalInput();
            self2.refreshState();
          }
          refreshState() {
            const self2 = this;
            self2.refreshValidityState();
            const isFull = self2.isFull();
            const isLocked = self2.isLocked;
            self2.wrapper.classList.toggle("rtl", self2.rtl);
            const wrap_classList = self2.wrapper.classList;
            wrap_classList.toggle("focus", self2.isFocused);
            wrap_classList.toggle("disabled", self2.isDisabled);
            wrap_classList.toggle("readonly", self2.isReadOnly);
            wrap_classList.toggle("required", self2.isRequired);
            wrap_classList.toggle("invalid", !self2.isValid);
            wrap_classList.toggle("locked", isLocked);
            wrap_classList.toggle("full", isFull);
            wrap_classList.toggle("input-active", self2.isFocused && !self2.isInputHidden);
            wrap_classList.toggle("dropdown-active", self2.isOpen);
            wrap_classList.toggle("has-options", isEmptyObject(self2.options));
            wrap_classList.toggle("has-items", self2.items.length > 0);
          }
          refreshValidityState() {
            var self2 = this;
            if (!self2.input.validity) {
              return;
            }
            self2.isValid = self2.input.validity.valid;
            self2.isInvalid = !self2.isValid;
          }
          isFull() {
            return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
          }
          updateOriginalInput(opts = {}) {
            const self2 = this;
            var option, label;
            const empty_option = self2.input.querySelector('option[value=""]');
            if (self2.is_select_tag) {
              let AddSelected = function(option_el, value, label2) {
                if (!option_el) {
                  option_el = getDom('<option value="' + escape_html(value) + '">' + escape_html(label2) + "</option>");
                }
                if (option_el != empty_option) {
                  self2.input.append(option_el);
                }
                selected.push(option_el);
                if (option_el != empty_option || has_selected > 0) {
                  option_el.selected = true;
                }
                return option_el;
              };
              const selected = [];
              const has_selected = self2.input.querySelectorAll("option:checked").length;
              self2.input.querySelectorAll("option:checked").forEach((option_el) => {
                option_el.selected = false;
              });
              if (self2.items.length == 0 && self2.settings.mode == "single") {
                AddSelected(empty_option, "", "");
              } else {
                self2.items.forEach((value) => {
                  option = self2.options[value];
                  label = option[self2.settings.labelField] || "";
                  if (selected.includes(option.$option)) {
                    const reuse_opt = self2.input.querySelector(`option[value="${addSlashes(value)}"]:not(:checked)`);
                    AddSelected(reuse_opt, value, label);
                  } else {
                    option.$option = AddSelected(option.$option, value, label);
                  }
                });
              }
            } else {
              self2.input.value = self2.getValue();
            }
            if (self2.isSetup) {
              if (!opts.silent) {
                self2.trigger("change", self2.getValue());
              }
            }
          }
          open() {
            var self2 = this;
            if (self2.isLocked || self2.isOpen || self2.settings.mode === "multi" && self2.isFull())
              return;
            self2.isOpen = true;
            setAttr(self2.focus_node, {
              "aria-expanded": "true"
            });
            self2.refreshState();
            applyCSS(self2.dropdown, {
              visibility: "hidden",
              display: "block"
            });
            self2.positionDropdown();
            applyCSS(self2.dropdown, {
              visibility: "visible",
              display: "block"
            });
            self2.focus();
            self2.trigger("dropdown_open", self2.dropdown);
          }
          close(setTextboxValue = true) {
            var self2 = this;
            var trigger = self2.isOpen;
            if (setTextboxValue) {
              self2.setTextboxValue();
              if (self2.settings.mode === "single" && self2.items.length) {
                self2.inputState();
              }
            }
            self2.isOpen = false;
            setAttr(self2.focus_node, {
              "aria-expanded": "false"
            });
            applyCSS(self2.dropdown, {
              display: "none"
            });
            if (self2.settings.hideSelected) {
              self2.clearActiveOption();
            }
            self2.refreshState();
            if (trigger)
              self2.trigger("dropdown_close", self2.dropdown);
          }
          positionDropdown() {
            if (this.settings.dropdownParent !== "body") {
              return;
            }
            var context = this.control;
            var rect = context.getBoundingClientRect();
            var top = context.offsetHeight + rect.top + window.scrollY;
            var left = rect.left + window.scrollX;
            applyCSS(this.dropdown, {
              width: rect.width + "px",
              top: top + "px",
              left: left + "px"
            });
          }
          clear(silent) {
            var self2 = this;
            if (!self2.items.length)
              return;
            var items = self2.controlChildren();
            iterate$1(items, (item) => {
              self2.removeItem(item, true);
            });
            self2.inputState();
            if (!silent)
              self2.updateOriginalInput();
            self2.trigger("clear");
          }
          insertAtCaret(el) {
            const self2 = this;
            const caret = self2.caretPos;
            const target = self2.control;
            target.insertBefore(el, target.children[caret] || null);
            self2.setCaret(caret + 1);
          }
          deleteSelection(e) {
            var direction, selection, caret, tail;
            var self2 = this;
            direction = e && e.keyCode === KEY_BACKSPACE ? -1 : 1;
            selection = getSelection(self2.control_input);
            const rm_items = [];
            if (self2.activeItems.length) {
              tail = getTail(self2.activeItems, direction);
              caret = nodeIndex(tail);
              if (direction > 0) {
                caret++;
              }
              iterate$1(self2.activeItems, (item) => rm_items.push(item));
            } else if ((self2.isFocused || self2.settings.mode === "single") && self2.items.length) {
              const items = self2.controlChildren();
              let rm_item;
              if (direction < 0 && selection.start === 0 && selection.length === 0) {
                rm_item = items[self2.caretPos - 1];
              } else if (direction > 0 && selection.start === self2.inputValue().length) {
                rm_item = items[self2.caretPos];
              }
              if (rm_item !== void 0) {
                rm_items.push(rm_item);
              }
            }
            if (!self2.shouldDelete(rm_items, e)) {
              return false;
            }
            preventDefault(e, true);
            if (typeof caret !== "undefined") {
              self2.setCaret(caret);
            }
            while (rm_items.length) {
              self2.removeItem(rm_items.pop());
            }
            self2.inputState();
            self2.positionDropdown();
            self2.refreshOptions(false);
            return true;
          }
          shouldDelete(items, evt) {
            const values = items.map((item) => item.dataset.value);
            if (!values.length || typeof this.settings.onDelete === "function" && this.settings.onDelete(values, evt) === false) {
              return false;
            }
            return true;
          }
          advanceSelection(direction, e) {
            var last_active, adjacent, self2 = this;
            if (self2.rtl)
              direction *= -1;
            if (self2.inputValue().length)
              return;
            if (isKeyDown(KEY_SHORTCUT, e) || isKeyDown("shiftKey", e)) {
              last_active = self2.getLastActive(direction);
              if (last_active) {
                if (!last_active.classList.contains("active")) {
                  adjacent = last_active;
                } else {
                  adjacent = self2.getAdjacent(last_active, direction, "item");
                }
              } else if (direction > 0) {
                adjacent = self2.control_input.nextElementSibling;
              } else {
                adjacent = self2.control_input.previousElementSibling;
              }
              if (adjacent) {
                if (adjacent.classList.contains("active")) {
                  self2.removeActiveItem(last_active);
                }
                self2.setActiveItemClass(adjacent);
              }
            } else {
              self2.moveCaret(direction);
            }
          }
          moveCaret(direction) {
          }
          getLastActive(direction) {
            let last_active = this.control.querySelector(".last-active");
            if (last_active) {
              return last_active;
            }
            var result = this.control.querySelectorAll(".active");
            if (result) {
              return getTail(result, direction);
            }
          }
          setCaret(new_pos) {
            this.caretPos = this.items.length;
          }
          controlChildren() {
            return Array.from(this.control.querySelectorAll("[data-ts-item]"));
          }
          lock() {
            this.setLocked(true);
          }
          unlock() {
            this.setLocked(false);
          }
          setLocked(lock = this.isReadOnly || this.isDisabled) {
            this.isLocked = lock;
            this.refreshState();
          }
          disable() {
            this.setDisabled(true);
            this.close();
          }
          enable() {
            this.setDisabled(false);
          }
          setDisabled(disabled) {
            this.focus_node.tabIndex = disabled ? -1 : this.tabIndex;
            this.isDisabled = disabled;
            this.input.disabled = disabled;
            this.control_input.disabled = disabled;
            this.setLocked();
          }
          setReadOnly(isReadOnly) {
            this.isReadOnly = isReadOnly;
            this.input.readOnly = isReadOnly;
            this.control_input.readOnly = isReadOnly;
            this.setLocked();
          }
          destroy() {
            var self2 = this;
            var revertSettings = self2.revertSettings;
            self2.trigger("destroy");
            self2.off();
            self2.wrapper.remove();
            self2.dropdown.remove();
            self2.input.innerHTML = revertSettings.innerHTML;
            self2.input.tabIndex = revertSettings.tabIndex;
            removeClasses(self2.input, "tomselected", "ts-hidden-accessible");
            self2._destroy();
            delete self2.input.tomselect;
          }
          render(templateName, data) {
            var id, html;
            const self2 = this;
            if (typeof this.settings.render[templateName] !== "function") {
              return null;
            }
            html = self2.settings.render[templateName].call(this, data, escape_html);
            if (!html) {
              return null;
            }
            html = getDom(html);
            if (templateName === "option" || templateName === "option_create") {
              if (data[self2.settings.disabledField]) {
                setAttr(html, {
                  "aria-disabled": "true"
                });
              } else {
                setAttr(html, {
                  "data-selectable": ""
                });
              }
            } else if (templateName === "optgroup") {
              id = data.group[self2.settings.optgroupValueField];
              setAttr(html, {
                "data-group": id
              });
              if (data.group[self2.settings.disabledField]) {
                setAttr(html, {
                  "data-disabled": ""
                });
              }
            }
            if (templateName === "option" || templateName === "item") {
              const value = get_hash(data[self2.settings.valueField]);
              setAttr(html, {
                "data-value": value
              });
              if (templateName === "item") {
                addClasses(html, self2.settings.itemClass);
                setAttr(html, {
                  "data-ts-item": ""
                });
              } else {
                addClasses(html, self2.settings.optionClass);
                setAttr(html, {
                  role: "option",
                  id: data.$id
                });
                data.$div = html;
                self2.options[value] = data;
              }
            }
            return html;
          }
          _render(templateName, data) {
            const html = this.render(templateName, data);
            if (html == null) {
              throw "HTMLElement expected";
            }
            return html;
          }
          clearCache() {
            iterate$1(this.options, (option) => {
              if (option.$div) {
                option.$div.remove();
                delete option.$div;
              }
            });
          }
          uncacheValue(value) {
            const option_el = this.getOption(value);
            if (option_el)
              option_el.remove();
          }
          canCreate(input) {
            return this.settings.create && input.length > 0 && this.settings.createFilter.call(this, input);
          }
          hook(when, method, new_fn) {
            var self2 = this;
            var orig_method = self2[method];
            self2[method] = function() {
              var result, result_new;
              if (when === "after") {
                result = orig_method.apply(self2, arguments);
              }
              result_new = new_fn.apply(self2, arguments);
              if (when === "instead") {
                return result_new;
              }
              if (when === "before") {
                result = orig_method.apply(self2, arguments);
              }
              return result;
            };
          }
        }
        function change_listener() {
          addEvent(this.input, "change", () => {
            this.sync();
          });
        }
        function checkbox_options(userOptions) {
          var self2 = this;
          var orig_onOptionSelect = self2.onOptionSelect;
          self2.settings.hideSelected = false;
          const cbOptions = Object.assign({
            className: "tomselect-checkbox",
            checkedClassNames: void 0,
            uncheckedClassNames: void 0
          }, userOptions);
          var UpdateChecked = function UpdateChecked2(checkbox, toCheck) {
            if (toCheck) {
              checkbox.checked = true;
              if (cbOptions.uncheckedClassNames) {
                checkbox.classList.remove(...cbOptions.uncheckedClassNames);
              }
              if (cbOptions.checkedClassNames) {
                checkbox.classList.add(...cbOptions.checkedClassNames);
              }
            } else {
              checkbox.checked = false;
              if (cbOptions.checkedClassNames) {
                checkbox.classList.remove(...cbOptions.checkedClassNames);
              }
              if (cbOptions.uncheckedClassNames) {
                checkbox.classList.add(...cbOptions.uncheckedClassNames);
              }
            }
          };
          var UpdateCheckbox = function UpdateCheckbox2(option) {
            setTimeout(() => {
              var checkbox = option.querySelector("input." + cbOptions.className);
              if (checkbox instanceof HTMLInputElement) {
                UpdateChecked(checkbox, option.classList.contains("selected"));
              }
            }, 1);
          };
          self2.hook("after", "setupTemplates", () => {
            var orig_render_option = self2.settings.render.option;
            self2.settings.render.option = (data, escape_html2) => {
              var rendered = getDom(orig_render_option.call(self2, data, escape_html2));
              var checkbox = document.createElement("input");
              if (cbOptions.className) {
                checkbox.classList.add(cbOptions.className);
              }
              checkbox.addEventListener("click", function(evt) {
                preventDefault(evt);
              });
              checkbox.type = "checkbox";
              const hashed = hash_key(data[self2.settings.valueField]);
              UpdateChecked(checkbox, !!(hashed && self2.items.indexOf(hashed) > -1));
              rendered.prepend(checkbox);
              return rendered;
            };
          });
          self2.on("item_remove", (value) => {
            var option = self2.getOption(value);
            if (option) {
              option.classList.remove("selected");
              UpdateCheckbox(option);
            }
          });
          self2.on("item_add", (value) => {
            var option = self2.getOption(value);
            if (option) {
              UpdateCheckbox(option);
            }
          });
          self2.hook("instead", "onOptionSelect", (evt, option) => {
            if (option.classList.contains("selected")) {
              option.classList.remove("selected");
              self2.removeItem(option.dataset.value);
              self2.refreshOptions();
              preventDefault(evt, true);
              return;
            }
            orig_onOptionSelect.call(self2, evt, option);
            UpdateCheckbox(option);
          });
        }
        function clear_button(userOptions) {
          const self2 = this;
          const options = Object.assign({
            className: "clear-button",
            title: "Clear All",
            html: (data) => {
              return `<div class="${data.className}" title="${data.title}">&#10799;</div>`;
            }
          }, userOptions);
          self2.on("initialize", () => {
            var button = getDom(options.html(options));
            button.addEventListener("click", (evt) => {
              if (self2.isLocked)
                return;
              self2.clear();
              if (self2.settings.mode === "single" && self2.settings.allowEmptyOption) {
                self2.addItem("");
              }
              evt.preventDefault();
              evt.stopPropagation();
            });
            self2.control.appendChild(button);
          });
        }
        const insertAfter = (referenceNode, newNode) => {
          var _referenceNode$parent;
          (_referenceNode$parent = referenceNode.parentNode) == null || _referenceNode$parent.insertBefore(newNode, referenceNode.nextSibling);
        };
        const insertBefore = (referenceNode, newNode) => {
          var _referenceNode$parent2;
          (_referenceNode$parent2 = referenceNode.parentNode) == null || _referenceNode$parent2.insertBefore(newNode, referenceNode);
        };
        const isBefore = (referenceNode, newNode) => {
          do {
            var _newNode;
            newNode = (_newNode = newNode) == null ? void 0 : _newNode.previousElementSibling;
            if (referenceNode == newNode) {
              return true;
            }
          } while (newNode && newNode.previousElementSibling);
          return false;
        };
        function drag_drop() {
          var self2 = this;
          if (self2.settings.mode !== "multi")
            return;
          var orig_lock = self2.lock;
          var orig_unlock = self2.unlock;
          let sortable = true;
          let drag_item;
          self2.hook("after", "setupTemplates", () => {
            var orig_render_item = self2.settings.render.item;
            self2.settings.render.item = (data, escape) => {
              const item = getDom(orig_render_item.call(self2, data, escape));
              setAttr(item, {
                "draggable": "true"
              });
              const mousedown = (evt) => {
                if (!sortable)
                  preventDefault(evt);
                evt.stopPropagation();
              };
              const dragStart = (evt) => {
                drag_item = item;
                setTimeout(() => {
                  item.classList.add("ts-dragging");
                }, 0);
              };
              const dragOver = (evt) => {
                evt.preventDefault();
                item.classList.add("ts-drag-over");
                moveitem(item, drag_item);
              };
              const dragLeave = () => {
                item.classList.remove("ts-drag-over");
              };
              const moveitem = (targetitem, dragitem) => {
                if (dragitem === void 0)
                  return;
                if (isBefore(dragitem, item)) {
                  insertAfter(targetitem, dragitem);
                } else {
                  insertBefore(targetitem, dragitem);
                }
              };
              const dragend = () => {
                var _drag_item;
                document.querySelectorAll(".ts-drag-over").forEach((el) => el.classList.remove("ts-drag-over"));
                (_drag_item = drag_item) == null || _drag_item.classList.remove("ts-dragging");
                drag_item = void 0;
                var values = [];
                self2.control.querySelectorAll(`[data-value]`).forEach((el) => {
                  if (el.dataset.value) {
                    let value = el.dataset.value;
                    if (value) {
                      values.push(value);
                    }
                  }
                });
                self2.setValue(values);
              };
              addEvent(item, "mousedown", mousedown);
              addEvent(item, "dragstart", dragStart);
              addEvent(item, "dragenter", dragOver);
              addEvent(item, "dragover", dragOver);
              addEvent(item, "dragleave", dragLeave);
              addEvent(item, "dragend", dragend);
              return item;
            };
          });
          self2.hook("instead", "lock", () => {
            sortable = false;
            return orig_lock.call(self2);
          });
          self2.hook("instead", "unlock", () => {
            sortable = true;
            return orig_unlock.call(self2);
          });
        }
        function dropdown_header(userOptions) {
          const self2 = this;
          const options = Object.assign({
            title: "Untitled",
            headerClass: "dropdown-header",
            titleRowClass: "dropdown-header-title",
            labelClass: "dropdown-header-label",
            closeClass: "dropdown-header-close",
            html: (data) => {
              return '<div class="' + data.headerClass + '"><div class="' + data.titleRowClass + '"><span class="' + data.labelClass + '">' + data.title + '</span><a class="' + data.closeClass + '">&times;</a></div></div>';
            }
          }, userOptions);
          self2.on("initialize", () => {
            var header = getDom(options.html(options));
            var close_link = header.querySelector("." + options.closeClass);
            if (close_link) {
              close_link.addEventListener("click", (evt) => {
                preventDefault(evt, true);
                self2.close();
              });
            }
            self2.dropdown.insertBefore(header, self2.dropdown.firstChild);
          });
        }
        function caret_position() {
          var self2 = this;
          self2.hook("instead", "setCaret", (new_pos) => {
            if (self2.settings.mode === "single" || !self2.control.contains(self2.control_input)) {
              new_pos = self2.items.length;
            } else {
              new_pos = Math.max(0, Math.min(self2.items.length, new_pos));
              if (new_pos != self2.caretPos && !self2.isPending) {
                self2.controlChildren().forEach((child, j) => {
                  if (j < new_pos) {
                    self2.control_input.insertAdjacentElement("beforebegin", child);
                  } else {
                    self2.control.appendChild(child);
                  }
                });
              }
            }
            self2.caretPos = new_pos;
          });
          self2.hook("instead", "moveCaret", (direction) => {
            if (!self2.isFocused)
              return;
            const last_active = self2.getLastActive(direction);
            if (last_active) {
              const idx = nodeIndex(last_active);
              self2.setCaret(direction > 0 ? idx + 1 : idx);
              self2.setActiveItem();
              removeClasses(last_active, "last-active");
            } else {
              self2.setCaret(self2.caretPos + direction);
            }
          });
        }
        function dropdown_input() {
          const self2 = this;
          self2.settings.shouldOpen = true;
          self2.hook("before", "setup", () => {
            self2.focus_node = self2.control;
            addClasses(self2.control_input, "dropdown-input");
            const div = getDom('<div class="dropdown-input-wrap">');
            div.append(self2.control_input);
            self2.dropdown.insertBefore(div, self2.dropdown.firstChild);
            const placeholder = getDom('<input class="items-placeholder" tabindex="-1" />');
            placeholder.placeholder = self2.settings.placeholder || "";
            self2.control.append(placeholder);
          });
          self2.on("initialize", () => {
            self2.control_input.addEventListener("keydown", (evt) => {
              switch (evt.keyCode) {
                case KEY_ESC:
                  if (self2.isOpen) {
                    preventDefault(evt, true);
                    self2.close();
                  }
                  self2.clearActiveItems();
                  return;
                case KEY_TAB:
                  self2.focus_node.tabIndex = -1;
                  break;
              }
              return self2.onKeyDown.call(self2, evt);
            });
            self2.on("blur", () => {
              self2.focus_node.tabIndex = self2.isDisabled ? -1 : self2.tabIndex;
            });
            self2.on("dropdown_open", () => {
              self2.control_input.focus();
            });
            const orig_onBlur = self2.onBlur;
            self2.hook("instead", "onBlur", (evt) => {
              if (evt && evt.relatedTarget == self2.control_input)
                return;
              return orig_onBlur.call(self2);
            });
            addEvent(self2.control_input, "blur", () => self2.onBlur());
            self2.hook("before", "close", () => {
              if (!self2.isOpen)
                return;
              self2.focus_node.focus({
                preventScroll: true
              });
            });
          });
        }
        function input_autogrow() {
          var self2 = this;
          self2.on("initialize", () => {
            var test_input = document.createElement("span");
            var control = self2.control_input;
            test_input.style.cssText = "position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ";
            self2.wrapper.appendChild(test_input);
            var transfer_styles = ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"];
            for (const style_name of transfer_styles) {
              test_input.style[style_name] = control.style[style_name];
            }
            var resize = () => {
              test_input.textContent = control.value;
              control.style.width = test_input.clientWidth + "px";
            };
            resize();
            self2.on("update item_add item_remove", resize);
            addEvent(control, "input", resize);
            addEvent(control, "keyup", resize);
            addEvent(control, "blur", resize);
            addEvent(control, "update", resize);
          });
        }
        function no_backspace_delete() {
          var self2 = this;
          var orig_deleteSelection = self2.deleteSelection;
          this.hook("instead", "deleteSelection", (evt) => {
            if (self2.activeItems.length) {
              return orig_deleteSelection.call(self2, evt);
            }
            return false;
          });
        }
        function no_active_items() {
          this.hook("instead", "setActiveItem", () => {
          });
          this.hook("instead", "selectAll", () => {
          });
        }
        function optgroup_columns() {
          var self2 = this;
          var orig_keydown = self2.onKeyDown;
          self2.hook("instead", "onKeyDown", (evt) => {
            var index2, option, options, optgroup;
            if (!self2.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {
              return orig_keydown.call(self2, evt);
            }
            self2.ignoreHover = true;
            optgroup = parentMatch(self2.activeOption, "[data-group]");
            index2 = nodeIndex(self2.activeOption, "[data-selectable]");
            if (!optgroup) {
              return;
            }
            if (evt.keyCode === KEY_LEFT) {
              optgroup = optgroup.previousSibling;
            } else {
              optgroup = optgroup.nextSibling;
            }
            if (!optgroup) {
              return;
            }
            options = optgroup.querySelectorAll("[data-selectable]");
            option = options[Math.min(options.length - 1, index2)];
            if (option) {
              self2.setActiveOption(option);
            }
          });
        }
        function remove_button(userOptions) {
          const options = Object.assign({
            label: "&times;",
            title: "Remove",
            className: "remove",
            append: true
          }, userOptions);
          var self2 = this;
          if (!options.append) {
            return;
          }
          var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + "</a>";
          self2.hook("after", "setupTemplates", () => {
            var orig_render_item = self2.settings.render.item;
            self2.settings.render.item = (data, escape) => {
              var item = getDom(orig_render_item.call(self2, data, escape));
              var close_button = getDom(html);
              item.appendChild(close_button);
              addEvent(close_button, "mousedown", (evt) => {
                preventDefault(evt, true);
              });
              addEvent(close_button, "click", (evt) => {
                if (self2.isLocked)
                  return;
                preventDefault(evt, true);
                if (self2.isLocked)
                  return;
                if (!self2.shouldDelete([item], evt))
                  return;
                self2.removeItem(item);
                self2.refreshOptions(false);
                self2.inputState();
              });
              return item;
            };
          });
        }
        function restore_on_backspace(userOptions) {
          const self2 = this;
          const options = Object.assign({
            text: (option) => {
              return option[self2.settings.labelField];
            }
          }, userOptions);
          self2.on("item_remove", function(value) {
            if (!self2.isFocused) {
              return;
            }
            if (self2.control_input.value.trim() === "") {
              var option = self2.options[value];
              if (option) {
                self2.setTextboxValue(options.text.call(self2, option));
              }
            }
          });
        }
        function virtual_scroll() {
          const self2 = this;
          const orig_canLoad = self2.canLoad;
          const orig_clearActiveOption = self2.clearActiveOption;
          const orig_loadCallback = self2.loadCallback;
          var pagination = {};
          var dropdown_content;
          var loading_more = false;
          var load_more_opt;
          var default_values = [];
          if (!self2.settings.shouldLoadMore) {
            self2.settings.shouldLoadMore = () => {
              const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);
              if (scroll_percent > 0.9) {
                return true;
              }
              if (self2.activeOption) {
                var selectable = self2.selectable();
                var index2 = Array.from(selectable).indexOf(self2.activeOption);
                if (index2 >= selectable.length - 2) {
                  return true;
                }
              }
              return false;
            };
          }
          if (!self2.settings.firstUrl) {
            throw "virtual_scroll plugin requires a firstUrl() method";
          }
          self2.settings.sortField = [{
            field: "$order"
          }, {
            field: "$score"
          }];
          const canLoadMore = (query) => {
            if (typeof self2.settings.maxOptions === "number" && dropdown_content.children.length >= self2.settings.maxOptions) {
              return false;
            }
            if (query in pagination && pagination[query]) {
              return true;
            }
            return false;
          };
          const clearFilter = (option, value) => {
            if (self2.items.indexOf(value) >= 0 || default_values.indexOf(value) >= 0) {
              return true;
            }
            return false;
          };
          self2.setNextUrl = (value, next_url) => {
            pagination[value] = next_url;
          };
          self2.getUrl = (query) => {
            if (query in pagination) {
              const next_url = pagination[query];
              pagination[query] = false;
              return next_url;
            }
            self2.clearPagination();
            return self2.settings.firstUrl.call(self2, query);
          };
          self2.clearPagination = () => {
            pagination = {};
          };
          self2.hook("instead", "clearActiveOption", () => {
            if (loading_more) {
              return;
            }
            return orig_clearActiveOption.call(self2);
          });
          self2.hook("instead", "canLoad", (query) => {
            if (!(query in pagination)) {
              return orig_canLoad.call(self2, query);
            }
            return canLoadMore(query);
          });
          self2.hook("instead", "loadCallback", (options, optgroups) => {
            if (!loading_more) {
              self2.clearOptions(clearFilter);
            } else if (load_more_opt) {
              const first_option = options[0];
              if (first_option !== void 0) {
                load_more_opt.dataset.value = first_option[self2.settings.valueField];
              }
            }
            orig_loadCallback.call(self2, options, optgroups);
            loading_more = false;
          });
          self2.hook("after", "refreshOptions", () => {
            const query = self2.lastValue;
            var option;
            if (canLoadMore(query)) {
              option = self2.render("loading_more", {
                query
              });
              if (option) {
                option.setAttribute("data-selectable", "");
                load_more_opt = option;
              }
            } else if (query in pagination && !dropdown_content.querySelector(".no-results")) {
              option = self2.render("no_more_results", {
                query
              });
            }
            if (option) {
              addClasses(option, self2.settings.optionClass);
              dropdown_content.append(option);
            }
          });
          self2.on("initialize", () => {
            default_values = Object.keys(self2.options);
            dropdown_content = self2.dropdown_content;
            self2.settings.render = Object.assign({}, {
              loading_more: () => {
                return `<div class="loading-more-results">Loading more results ... </div>`;
              },
              no_more_results: () => {
                return `<div class="no-more-results">No more results</div>`;
              }
            }, self2.settings.render);
            dropdown_content.addEventListener("scroll", () => {
              if (!self2.settings.shouldLoadMore.call(self2)) {
                return;
              }
              if (!canLoadMore(self2.lastValue)) {
                return;
              }
              if (loading_more)
                return;
              loading_more = true;
              self2.load.call(self2, self2.lastValue);
            });
          });
        }
        TomSelect4.define("change_listener", change_listener);
        TomSelect4.define("checkbox_options", checkbox_options);
        TomSelect4.define("clear_button", clear_button);
        TomSelect4.define("drag_drop", drag_drop);
        TomSelect4.define("dropdown_header", dropdown_header);
        TomSelect4.define("caret_position", caret_position);
        TomSelect4.define("dropdown_input", dropdown_input);
        TomSelect4.define("input_autogrow", input_autogrow);
        TomSelect4.define("no_backspace_delete", no_backspace_delete);
        TomSelect4.define("no_active_items", no_active_items);
        TomSelect4.define("optgroup_columns", optgroup_columns);
        TomSelect4.define("remove_button", remove_button);
        TomSelect4.define("restore_on_backspace", restore_on_backspace);
        TomSelect4.define("virtual_scroll", virtual_scroll);
        return TomSelect4;
      });
    }
  });

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback, element) {
              var currTime = new Date().getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, progressTimerId, fadeTimerId, currentProgress, showing, addEvent = function(elem, type, handler) {
          if (elem.addEventListener)
            elem.addEventListener(type, handler, false);
          else if (elem.attachEvent)
            elem.attachEvent("on" + type, handler);
          else
            elem["on" + type] = handler;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop in options.barColors)
            lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(Math.ceil(currentProgress * canvas.width), options.barThickness / 2);
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document2.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className)
            canvas.classList.add(options.className);
          document2.body.appendChild(canvas);
          addEvent(window2, "resize", repaint);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts)
              if (options.hasOwnProperty(key))
                options[key] = opts[key];
          },
          show: function() {
            if (showing)
              return;
            showing = true;
            if (fadeTimerId !== null)
              window2.cancelAnimationFrame(fadeTimerId);
            if (!canvas)
              createCanvas();
            canvas.style.opacity = 1;
            canvas.style.display = "block";
            topbar2.progress(0);
            if (options.autoRun) {
              (function loop() {
                progressTimerId = window2.requestAnimationFrame(loop);
                topbar2.progress("+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2));
              })();
            }
          },
          progress: function(to) {
            if (typeof to === "undefined")
              return currentProgress;
            if (typeof to === "string") {
              to = (to.indexOf("+") >= 0 || to.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to);
            }
            currentProgress = to > 1 ? 1 : to;
            repaint();
            return currentProgress;
          },
          hide: function() {
            if (!showing)
              return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            (function loop() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // node_modules/chart.js/dist/chart.js
  var require_chart = __commonJS({
    "node_modules/chart.js/dist/chart.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Chart = factory());
      })(exports, function() {
        "use strict";
        function noop2() {
        }
        const uid = function() {
          let id = 0;
          return function() {
            return id++;
          };
        }();
        function isNullOrUndef(value) {
          return value === null || typeof value === "undefined";
        }
        function isArray(value) {
          if (Array.isArray && Array.isArray(value)) {
            return true;
          }
          const type = Object.prototype.toString.call(value);
          if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
            return true;
          }
          return false;
        }
        function isObject2(value) {
          return value !== null && Object.prototype.toString.call(value) === "[object Object]";
        }
        const isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
        function finiteOrDefault(value, defaultValue) {
          return isNumberFinite(value) ? value : defaultValue;
        }
        function valueOrDefault(value, defaultValue) {
          return typeof value === "undefined" ? defaultValue : value;
        }
        const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
        const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
        function callback(fn, args, thisArg) {
          if (fn && typeof fn.call === "function") {
            return fn.apply(thisArg, args);
          }
        }
        function each(loopable, fn, thisArg, reverse) {
          let i, len, keys;
          if (isArray(loopable)) {
            len = loopable.length;
            if (reverse) {
              for (i = len - 1; i >= 0; i--) {
                fn.call(thisArg, loopable[i], i);
              }
            } else {
              for (i = 0; i < len; i++) {
                fn.call(thisArg, loopable[i], i);
              }
            }
          } else if (isObject2(loopable)) {
            keys = Object.keys(loopable);
            len = keys.length;
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[keys[i]], keys[i]);
            }
          }
        }
        function _elementsEqual(a0, a1) {
          let i, ilen, v0, v1;
          if (!a0 || !a1 || a0.length !== a1.length) {
            return false;
          }
          for (i = 0, ilen = a0.length; i < ilen; ++i) {
            v0 = a0[i];
            v1 = a1[i];
            if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
              return false;
            }
          }
          return true;
        }
        function clone$1(source) {
          if (isArray(source)) {
            return source.map(clone$1);
          }
          if (isObject2(source)) {
            const target = Object.create(null);
            const keys = Object.keys(source);
            const klen = keys.length;
            let k = 0;
            for (; k < klen; ++k) {
              target[keys[k]] = clone$1(source[keys[k]]);
            }
            return target;
          }
          return source;
        }
        function isValidKey(key) {
          return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
        }
        function _merger(key, target, source, options) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject2(tval) && isObject2(sval)) {
            merge(tval, sval, options);
          } else {
            target[key] = clone$1(sval);
          }
        }
        function merge(target, source, options) {
          const sources = isArray(source) ? source : [source];
          const ilen = sources.length;
          if (!isObject2(target)) {
            return target;
          }
          options = options || {};
          const merger = options.merger || _merger;
          for (let i = 0; i < ilen; ++i) {
            source = sources[i];
            if (!isObject2(source)) {
              continue;
            }
            const keys = Object.keys(source);
            for (let k = 0, klen = keys.length; k < klen; ++k) {
              merger(keys[k], target, source, options);
            }
          }
          return target;
        }
        function mergeIf(target, source) {
          return merge(target, source, { merger: _mergerIf });
        }
        function _mergerIf(key, target, source) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject2(tval) && isObject2(sval)) {
            mergeIf(tval, sval);
          } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
            target[key] = clone$1(sval);
          }
        }
        function _deprecated(scope, value, previous, current) {
          if (value !== void 0) {
            console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
          }
        }
        const keyResolvers = {
          "": (v) => v,
          x: (o) => o.x,
          y: (o) => o.y
        };
        function resolveObjectKey(obj, key) {
          const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
          return resolver(obj);
        }
        function _getKeyResolver(key) {
          const keys = _splitKey(key);
          return (obj) => {
            for (const k of keys) {
              if (k === "") {
                break;
              }
              obj = obj && obj[k];
            }
            return obj;
          };
        }
        function _splitKey(key) {
          const parts = key.split(".");
          const keys = [];
          let tmp = "";
          for (const part of parts) {
            tmp += part;
            if (tmp.endsWith("\\")) {
              tmp = tmp.slice(0, -1) + ".";
            } else {
              keys.push(tmp);
              tmp = "";
            }
          }
          return keys;
        }
        function _capitalize(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        }
        const defined = (value) => typeof value !== "undefined";
        const isFunction2 = (value) => typeof value === "function";
        const setsEqual = (a, b) => {
          if (a.size !== b.size) {
            return false;
          }
          for (const item of a) {
            if (!b.has(item)) {
              return false;
            }
          }
          return true;
        };
        function _isClickEvent(e) {
          return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
        }
        const PI = Math.PI;
        const TAU = 2 * PI;
        const PITAU = TAU + PI;
        const INFINITY = Number.POSITIVE_INFINITY;
        const RAD_PER_DEG = PI / 180;
        const HALF_PI = PI / 2;
        const QUARTER_PI = PI / 4;
        const TWO_THIRDS_PI = PI * 2 / 3;
        const log10 = Math.log10;
        const sign = Math.sign;
        function niceNum(range2) {
          const roundedRange = Math.round(range2);
          range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
          const niceRange = Math.pow(10, Math.floor(log10(range2)));
          const fraction = range2 / niceRange;
          const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
          return niceFraction * niceRange;
        }
        function _factorize(value) {
          const result = [];
          const sqrt = Math.sqrt(value);
          let i;
          for (i = 1; i < sqrt; i++) {
            if (value % i === 0) {
              result.push(i);
              result.push(value / i);
            }
          }
          if (sqrt === (sqrt | 0)) {
            result.push(sqrt);
          }
          result.sort((a, b) => a - b).pop();
          return result;
        }
        function isNumber(n) {
          return !isNaN(parseFloat(n)) && isFinite(n);
        }
        function almostEquals(x, y, epsilon) {
          return Math.abs(x - y) < epsilon;
        }
        function almostWhole(x, epsilon) {
          const rounded = Math.round(x);
          return rounded - epsilon <= x && rounded + epsilon >= x;
        }
        function _setMinAndMaxByKey(array, target, property) {
          let i, ilen, value;
          for (i = 0, ilen = array.length; i < ilen; i++) {
            value = array[i][property];
            if (!isNaN(value)) {
              target.min = Math.min(target.min, value);
              target.max = Math.max(target.max, value);
            }
          }
        }
        function toRadians(degrees) {
          return degrees * (PI / 180);
        }
        function toDegrees(radians) {
          return radians * (180 / PI);
        }
        function _decimalPlaces(x) {
          if (!isNumberFinite(x)) {
            return;
          }
          let e = 1;
          let p = 0;
          while (Math.round(x * e) / e !== x) {
            e *= 10;
            p++;
          }
          return p;
        }
        function getAngleFromPoint(centrePoint, anglePoint) {
          const distanceFromXCenter = anglePoint.x - centrePoint.x;
          const distanceFromYCenter = anglePoint.y - centrePoint.y;
          const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
          let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
          if (angle < -0.5 * PI) {
            angle += TAU;
          }
          return {
            angle,
            distance: radialDistanceFromCenter
          };
        }
        function distanceBetweenPoints(pt1, pt2) {
          return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
        }
        function _angleDiff(a, b) {
          return (a - b + PITAU) % TAU - PI;
        }
        function _normalizeAngle(a) {
          return (a % TAU + TAU) % TAU;
        }
        function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
          const a = _normalizeAngle(angle);
          const s = _normalizeAngle(start);
          const e = _normalizeAngle(end);
          const angleToStart = _normalizeAngle(s - a);
          const angleToEnd = _normalizeAngle(e - a);
          const startToAngle = _normalizeAngle(a - s);
          const endToAngle = _normalizeAngle(a - e);
          return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
        }
        function _limitValue(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }
        function _int16Range(value) {
          return _limitValue(value, -32768, 32767);
        }
        function _isBetween(value, start, end, epsilon = 1e-6) {
          return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
        }
        function _lookup(table, value, cmp) {
          cmp = cmp || ((index3) => table[index3] < value);
          let hi = table.length - 1;
          let lo = 0;
          let mid;
          while (hi - lo > 1) {
            mid = lo + hi >> 1;
            if (cmp(mid)) {
              lo = mid;
            } else {
              hi = mid;
            }
          }
          return { lo, hi };
        }
        const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index3) => table[index3][key] <= value : (index3) => table[index3][key] < value);
        const _rlookupByKey = (table, key, value) => _lookup(table, value, (index3) => table[index3][key] >= value);
        function _filterBetween(values, min, max) {
          let start = 0;
          let end = values.length;
          while (start < end && values[start] < min) {
            start++;
          }
          while (end > start && values[end - 1] > max) {
            end--;
          }
          return start > 0 || end < values.length ? values.slice(start, end) : values;
        }
        const arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, "_chartjs", {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener]
            }
          });
          arrayEvents.forEach((key) => {
            const method = "_onData" + _capitalize(key);
            const base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value(...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object) => {
                  if (typeof object[method] === "function") {
                    object[method](...args);
                  }
                });
                return res;
              }
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          const stub = array._chartjs;
          if (!stub) {
            return;
          }
          const listeners = stub.listeners;
          const index3 = listeners.indexOf(listener);
          if (index3 !== -1) {
            listeners.splice(index3, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach((key) => {
            delete array[key];
          });
          delete array._chartjs;
        }
        function _arrayUnique(items) {
          const set2 = /* @__PURE__ */ new Set();
          let i, ilen;
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            set2.add(items[i]);
          }
          if (set2.size === ilen) {
            return items;
          }
          return Array.from(set2);
        }
        function fontString(pixelSize, fontStyle, fontFamily) {
          return fontStyle + " " + pixelSize + "px " + fontFamily;
        }
        const requestAnimFrame = function() {
          if (typeof window === "undefined") {
            return function(callback2) {
              return callback2();
            };
          }
          return window.requestAnimationFrame;
        }();
        function throttled(fn, thisArg, updateFn) {
          const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
          let ticking = false;
          let args = [];
          return function(...rest) {
            args = updateArgs(rest);
            if (!ticking) {
              ticking = true;
              requestAnimFrame.call(window, () => {
                ticking = false;
                fn.apply(thisArg, args);
              });
            }
          };
        }
        function debounce(fn, delay) {
          let timeout;
          return function(...args) {
            if (delay) {
              clearTimeout(timeout);
              timeout = setTimeout(fn, delay, args);
            } else {
              fn.apply(this, args);
            }
            return delay;
          };
        }
        const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
        const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
        const _textX = (align, left, right, rtl) => {
          const check = rtl ? "left" : "right";
          return align === check ? right : align === "center" ? (left + right) / 2 : left;
        };
        function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
          const pointCount = points.length;
          let start = 0;
          let count = pointCount;
          if (meta._sorted) {
            const { iScale, _parsed } = meta;
            const axis = iScale.axis;
            const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
            if (minDefined) {
              start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
            }
            if (maxDefined) {
              count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
            } else {
              count = pointCount - start;
            }
          }
          return { start, count };
        }
        function _scaleRangesChanged(meta) {
          const { xScale, yScale, _scaleRanges } = meta;
          const newRanges = {
            xmin: xScale.min,
            xmax: xScale.max,
            ymin: yScale.min,
            ymax: yScale.max
          };
          if (!_scaleRanges) {
            meta._scaleRanges = newRanges;
            return true;
          }
          const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
          Object.assign(_scaleRanges, newRanges);
          return changed;
        }
        class Animator {
          constructor() {
            this._request = null;
            this._charts = /* @__PURE__ */ new Map();
            this._running = false;
            this._lastDate = void 0;
          }
          _notify(chart2, anims, date, type) {
            const callbacks = anims.listeners[type];
            const numSteps = anims.duration;
            callbacks.forEach((fn) => fn({
              chart: chart2,
              initial: anims.initial,
              numSteps,
              currentStep: Math.min(date - anims.start, numSteps)
            }));
          }
          _refresh() {
            if (this._request) {
              return;
            }
            this._running = true;
            this._request = requestAnimFrame.call(window, () => {
              this._update();
              this._request = null;
              if (this._running) {
                this._refresh();
              }
            });
          }
          _update(date = Date.now()) {
            let remaining = 0;
            this._charts.forEach((anims, chart2) => {
              if (!anims.running || !anims.items.length) {
                return;
              }
              const items = anims.items;
              let i = items.length - 1;
              let draw2 = false;
              let item;
              for (; i >= 0; --i) {
                item = items[i];
                if (item._active) {
                  if (item._total > anims.duration) {
                    anims.duration = item._total;
                  }
                  item.tick(date);
                  draw2 = true;
                } else {
                  items[i] = items[items.length - 1];
                  items.pop();
                }
              }
              if (draw2) {
                chart2.draw();
                this._notify(chart2, anims, date, "progress");
              }
              if (!items.length) {
                anims.running = false;
                this._notify(chart2, anims, date, "complete");
                anims.initial = false;
              }
              remaining += items.length;
            });
            this._lastDate = date;
            if (remaining === 0) {
              this._running = false;
            }
          }
          _getAnims(chart2) {
            const charts = this._charts;
            let anims = charts.get(chart2);
            if (!anims) {
              anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                  complete: [],
                  progress: []
                }
              };
              charts.set(chart2, anims);
            }
            return anims;
          }
          listen(chart2, event, cb) {
            this._getAnims(chart2).listeners[event].push(cb);
          }
          add(chart2, items) {
            if (!items || !items.length) {
              return;
            }
            this._getAnims(chart2).items.push(...items);
          }
          has(chart2) {
            return this._getAnims(chart2).items.length > 0;
          }
          start(chart2) {
            const anims = this._charts.get(chart2);
            if (!anims) {
              return;
            }
            anims.running = true;
            anims.start = Date.now();
            anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
            this._refresh();
          }
          running(chart2) {
            if (!this._running) {
              return false;
            }
            const anims = this._charts.get(chart2);
            if (!anims || !anims.running || !anims.items.length) {
              return false;
            }
            return true;
          }
          stop(chart2) {
            const anims = this._charts.get(chart2);
            if (!anims || !anims.items.length) {
              return;
            }
            const items = anims.items;
            let i = items.length - 1;
            for (; i >= 0; --i) {
              items[i].cancel();
            }
            anims.items = [];
            this._notify(chart2, anims, Date.now(), "complete");
          }
          remove(chart2) {
            return this._charts.delete(chart2);
          }
        }
        var animator = new Animator();
        function round(v) {
          return v + 0.5 | 0;
        }
        const lim = (v, l, h) => Math.max(Math.min(v, h), l);
        function p2b(v) {
          return lim(round(v * 2.55), 0, 255);
        }
        function n2b(v) {
          return lim(round(v * 255), 0, 255);
        }
        function b2n(v) {
          return lim(round(v / 2.55) / 100, 0, 1);
        }
        function n2p(v) {
          return lim(round(v * 100), 0, 100);
        }
        const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
        const hex = [..."0123456789ABCDEF"];
        const h1 = (b) => hex[b & 15];
        const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
        const eq = (b) => (b & 240) >> 4 === (b & 15);
        const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
        function hexParse(str) {
          var len = str.length;
          var ret;
          if (str[0] === "#") {
            if (len === 4 || len === 5) {
              ret = {
                r: 255 & map$1[str[1]] * 17,
                g: 255 & map$1[str[2]] * 17,
                b: 255 & map$1[str[3]] * 17,
                a: len === 5 ? map$1[str[4]] * 17 : 255
              };
            } else if (len === 7 || len === 9) {
              ret = {
                r: map$1[str[1]] << 4 | map$1[str[2]],
                g: map$1[str[3]] << 4 | map$1[str[4]],
                b: map$1[str[5]] << 4 | map$1[str[6]],
                a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
              };
            }
          }
          return ret;
        }
        const alpha = (a, f) => a < 255 ? f(a) : "";
        function hexString(v) {
          var f = isShort(v) ? h1 : h2;
          return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
        }
        const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
        function hsl2rgbn(h, s, l) {
          const a = s * Math.min(l, 1 - l);
          const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return [f(0), f(8), f(4)];
        }
        function hsv2rgbn(h, s, v) {
          const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
          return [f(5), f(3), f(1)];
        }
        function hwb2rgbn(h, w, b) {
          const rgb = hsl2rgbn(h, 1, 0.5);
          let i;
          if (w + b > 1) {
            i = 1 / (w + b);
            w *= i;
            b *= i;
          }
          for (i = 0; i < 3; i++) {
            rgb[i] *= 1 - w - b;
            rgb[i] += w;
          }
          return rgb;
        }
        function hueValue(r, g, b, d, max) {
          if (r === max) {
            return (g - b) / d + (g < b ? 6 : 0);
          }
          if (g === max) {
            return (b - r) / d + 2;
          }
          return (r - g) / d + 4;
        }
        function rgb2hsl(v) {
          const range2 = 255;
          const r = v.r / range2;
          const g = v.g / range2;
          const b = v.b / range2;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const l = (max + min) / 2;
          let h, s, d;
          if (max !== min) {
            d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            h = hueValue(r, g, b, d, max);
            h = h * 60 + 0.5;
          }
          return [h | 0, s || 0, l];
        }
        function calln(f, a, b, c) {
          return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
        }
        function hsl2rgb(h, s, l) {
          return calln(hsl2rgbn, h, s, l);
        }
        function hwb2rgb(h, w, b) {
          return calln(hwb2rgbn, h, w, b);
        }
        function hsv2rgb(h, s, v) {
          return calln(hsv2rgbn, h, s, v);
        }
        function hue(h) {
          return (h % 360 + 360) % 360;
        }
        function hueParse(str) {
          const m = HUE_RE.exec(str);
          let a = 255;
          let v;
          if (!m) {
            return;
          }
          if (m[5] !== v) {
            a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
          }
          const h = hue(+m[2]);
          const p1 = +m[3] / 100;
          const p2 = +m[4] / 100;
          if (m[1] === "hwb") {
            v = hwb2rgb(h, p1, p2);
          } else if (m[1] === "hsv") {
            v = hsv2rgb(h, p1, p2);
          } else {
            v = hsl2rgb(h, p1, p2);
          }
          return {
            r: v[0],
            g: v[1],
            b: v[2],
            a
          };
        }
        function rotate(v, deg) {
          var h = rgb2hsl(v);
          h[0] = hue(h[0] + deg);
          h = hsl2rgb(h);
          v.r = h[0];
          v.g = h[1];
          v.b = h[2];
        }
        function hslString(v) {
          if (!v) {
            return;
          }
          const a = rgb2hsl(v);
          const h = a[0];
          const s = n2p(a[1]);
          const l = n2p(a[2]);
          return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
        }
        const map$2 = {
          x: "dark",
          Z: "light",
          Y: "re",
          X: "blu",
          W: "gr",
          V: "medium",
          U: "slate",
          A: "ee",
          T: "ol",
          S: "or",
          B: "ra",
          C: "lateg",
          D: "ights",
          R: "in",
          Q: "turquois",
          E: "hi",
          P: "ro",
          O: "al",
          N: "le",
          M: "de",
          L: "yello",
          F: "en",
          K: "ch",
          G: "arks",
          H: "ea",
          I: "ightg",
          J: "wh"
        };
        const names$1 = {
          OiceXe: "f0f8ff",
          antiquewEte: "faebd7",
          aqua: "ffff",
          aquamarRe: "7fffd4",
          azuY: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "0",
          blanKedOmond: "ffebcd",
          Xe: "ff",
          XeviTet: "8a2be2",
          bPwn: "a52a2a",
          burlywood: "deb887",
          caMtXe: "5f9ea0",
          KartYuse: "7fff00",
          KocTate: "d2691e",
          cSO: "ff7f50",
          cSnflowerXe: "6495ed",
          cSnsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "ffff",
          xXe: "8b",
          xcyan: "8b8b",
          xgTMnPd: "b8860b",
          xWay: "a9a9a9",
          xgYF: "6400",
          xgYy: "a9a9a9",
          xkhaki: "bdb76b",
          xmagFta: "8b008b",
          xTivegYF: "556b2f",
          xSange: "ff8c00",
          xScEd: "9932cc",
          xYd: "8b0000",
          xsOmon: "e9967a",
          xsHgYF: "8fbc8f",
          xUXe: "483d8b",
          xUWay: "2f4f4f",
          xUgYy: "2f4f4f",
          xQe: "ced1",
          xviTet: "9400d3",
          dAppRk: "ff1493",
          dApskyXe: "bfff",
          dimWay: "696969",
          dimgYy: "696969",
          dodgerXe: "1e90ff",
          fiYbrick: "b22222",
          flSOwEte: "fffaf0",
          foYstWAn: "228b22",
          fuKsia: "ff00ff",
          gaRsbSo: "dcdcdc",
          ghostwEte: "f8f8ff",
          gTd: "ffd700",
          gTMnPd: "daa520",
          Way: "808080",
          gYF: "8000",
          gYFLw: "adff2f",
          gYy: "808080",
          honeyMw: "f0fff0",
          hotpRk: "ff69b4",
          RdianYd: "cd5c5c",
          Rdigo: "4b0082",
          ivSy: "fffff0",
          khaki: "f0e68c",
          lavFMr: "e6e6fa",
          lavFMrXsh: "fff0f5",
          lawngYF: "7cfc00",
          NmoncEffon: "fffacd",
          ZXe: "add8e6",
          ZcSO: "f08080",
          Zcyan: "e0ffff",
          ZgTMnPdLw: "fafad2",
          ZWay: "d3d3d3",
          ZgYF: "90ee90",
          ZgYy: "d3d3d3",
          ZpRk: "ffb6c1",
          ZsOmon: "ffa07a",
          ZsHgYF: "20b2aa",
          ZskyXe: "87cefa",
          ZUWay: "778899",
          ZUgYy: "778899",
          ZstAlXe: "b0c4de",
          ZLw: "ffffe0",
          lime: "ff00",
          limegYF: "32cd32",
          lRF: "faf0e6",
          magFta: "ff00ff",
          maPon: "800000",
          VaquamarRe: "66cdaa",
          VXe: "cd",
          VScEd: "ba55d3",
          VpurpN: "9370db",
          VsHgYF: "3cb371",
          VUXe: "7b68ee",
          VsprRggYF: "fa9a",
          VQe: "48d1cc",
          VviTetYd: "c71585",
          midnightXe: "191970",
          mRtcYam: "f5fffa",
          mistyPse: "ffe4e1",
          moccasR: "ffe4b5",
          navajowEte: "ffdead",
          navy: "80",
          Tdlace: "fdf5e6",
          Tive: "808000",
          TivedBb: "6b8e23",
          Sange: "ffa500",
          SangeYd: "ff4500",
          ScEd: "da70d6",
          pOegTMnPd: "eee8aa",
          pOegYF: "98fb98",
          pOeQe: "afeeee",
          pOeviTetYd: "db7093",
          papayawEp: "ffefd5",
          pHKpuff: "ffdab9",
          peru: "cd853f",
          pRk: "ffc0cb",
          plum: "dda0dd",
          powMrXe: "b0e0e6",
          purpN: "800080",
          YbeccapurpN: "663399",
          Yd: "ff0000",
          Psybrown: "bc8f8f",
          PyOXe: "4169e1",
          saddNbPwn: "8b4513",
          sOmon: "fa8072",
          sandybPwn: "f4a460",
          sHgYF: "2e8b57",
          sHshell: "fff5ee",
          siFna: "a0522d",
          silver: "c0c0c0",
          skyXe: "87ceeb",
          UXe: "6a5acd",
          UWay: "708090",
          UgYy: "708090",
          snow: "fffafa",
          sprRggYF: "ff7f",
          stAlXe: "4682b4",
          tan: "d2b48c",
          teO: "8080",
          tEstN: "d8bfd8",
          tomato: "ff6347",
          Qe: "40e0d0",
          viTet: "ee82ee",
          JHt: "f5deb3",
          wEte: "ffffff",
          wEtesmoke: "f5f5f5",
          Lw: "ffff00",
          LwgYF: "9acd32"
        };
        function unpack() {
          const unpacked = {};
          const keys = Object.keys(names$1);
          const tkeys = Object.keys(map$2);
          let i, j, k, ok, nk;
          for (i = 0; i < keys.length; i++) {
            ok = nk = keys[i];
            for (j = 0; j < tkeys.length; j++) {
              k = tkeys[j];
              nk = nk.replace(k, map$2[k]);
            }
            k = parseInt(names$1[ok], 16);
            unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
          }
          return unpacked;
        }
        let names;
        function nameParse(str) {
          if (!names) {
            names = unpack();
            names.transparent = [0, 0, 0, 0];
          }
          const a = names[str.toLowerCase()];
          return a && {
            r: a[0],
            g: a[1],
            b: a[2],
            a: a.length === 4 ? a[3] : 255
          };
        }
        const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        function rgbParse(str) {
          const m = RGB_RE.exec(str);
          let a = 255;
          let r, g, b;
          if (!m) {
            return;
          }
          if (m[7] !== r) {
            const v = +m[7];
            a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
          }
          r = +m[1];
          g = +m[3];
          b = +m[5];
          r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
          g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
          b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
          return {
            r,
            g,
            b,
            a
          };
        }
        function rgbString(v) {
          return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
        }
        const to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
        const from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
        function interpolate$1(rgb1, rgb2, t) {
          const r = from(b2n(rgb1.r));
          const g = from(b2n(rgb1.g));
          const b = from(b2n(rgb1.b));
          return {
            r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
            g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
            b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
            a: rgb1.a + t * (rgb2.a - rgb1.a)
          };
        }
        function modHSL(v, i, ratio) {
          if (v) {
            let tmp = rgb2hsl(v);
            tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
            tmp = hsl2rgb(tmp);
            v.r = tmp[0];
            v.g = tmp[1];
            v.b = tmp[2];
          }
        }
        function clone2(v, proto) {
          return v ? Object.assign(proto || {}, v) : v;
        }
        function fromObject(input) {
          var v = { r: 0, g: 0, b: 0, a: 255 };
          if (Array.isArray(input)) {
            if (input.length >= 3) {
              v = { r: input[0], g: input[1], b: input[2], a: 255 };
              if (input.length > 3) {
                v.a = n2b(input[3]);
              }
            }
          } else {
            v = clone2(input, { r: 0, g: 0, b: 0, a: 1 });
            v.a = n2b(v.a);
          }
          return v;
        }
        function functionParse(str) {
          if (str.charAt(0) === "r") {
            return rgbParse(str);
          }
          return hueParse(str);
        }
        class Color {
          constructor(input) {
            if (input instanceof Color) {
              return input;
            }
            const type = typeof input;
            let v;
            if (type === "object") {
              v = fromObject(input);
            } else if (type === "string") {
              v = hexParse(input) || nameParse(input) || functionParse(input);
            }
            this._rgb = v;
            this._valid = !!v;
          }
          get valid() {
            return this._valid;
          }
          get rgb() {
            var v = clone2(this._rgb);
            if (v) {
              v.a = b2n(v.a);
            }
            return v;
          }
          set rgb(obj) {
            this._rgb = fromObject(obj);
          }
          rgbString() {
            return this._valid ? rgbString(this._rgb) : void 0;
          }
          hexString() {
            return this._valid ? hexString(this._rgb) : void 0;
          }
          hslString() {
            return this._valid ? hslString(this._rgb) : void 0;
          }
          mix(color2, weight) {
            if (color2) {
              const c1 = this.rgb;
              const c2 = color2.rgb;
              let w2;
              const p = weight === w2 ? 0.5 : weight;
              const w = 2 * p - 1;
              const a = c1.a - c2.a;
              const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
              w2 = 1 - w1;
              c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
              c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
              c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
              c1.a = p * c1.a + (1 - p) * c2.a;
              this.rgb = c1;
            }
            return this;
          }
          interpolate(color2, t) {
            if (color2) {
              this._rgb = interpolate$1(this._rgb, color2._rgb, t);
            }
            return this;
          }
          clone() {
            return new Color(this.rgb);
          }
          alpha(a) {
            this._rgb.a = n2b(a);
            return this;
          }
          clearer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 - ratio;
            return this;
          }
          greyscale() {
            const rgb = this._rgb;
            const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
            rgb.r = rgb.g = rgb.b = val;
            return this;
          }
          opaquer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 + ratio;
            return this;
          }
          negate() {
            const v = this._rgb;
            v.r = 255 - v.r;
            v.g = 255 - v.g;
            v.b = 255 - v.b;
            return this;
          }
          lighten(ratio) {
            modHSL(this._rgb, 2, ratio);
            return this;
          }
          darken(ratio) {
            modHSL(this._rgb, 2, -ratio);
            return this;
          }
          saturate(ratio) {
            modHSL(this._rgb, 1, ratio);
            return this;
          }
          desaturate(ratio) {
            modHSL(this._rgb, 1, -ratio);
            return this;
          }
          rotate(deg) {
            rotate(this._rgb, deg);
            return this;
          }
        }
        function index_esm(input) {
          return new Color(input);
        }
        function isPatternOrGradient(value) {
          if (value && typeof value === "object") {
            const type = value.toString();
            return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
          }
          return false;
        }
        function color(value) {
          return isPatternOrGradient(value) ? value : index_esm(value);
        }
        function getHoverColor(value) {
          return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
        }
        const overrides = Object.create(null);
        const descriptors = Object.create(null);
        function getScope$1(node, key) {
          if (!key) {
            return node;
          }
          const keys = key.split(".");
          for (let i = 0, n = keys.length; i < n; ++i) {
            const k = keys[i];
            node = node[k] || (node[k] = Object.create(null));
          }
          return node;
        }
        function set(root, scope, values) {
          if (typeof scope === "string") {
            return merge(getScope$1(root, scope), values);
          }
          return merge(getScope$1(root, ""), scope);
        }
        class Defaults {
          constructor(_descriptors2) {
            this.animation = void 0;
            this.backgroundColor = "rgba(0,0,0,0.1)";
            this.borderColor = "rgba(0,0,0,0.1)";
            this.color = "#666";
            this.datasets = {};
            this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
            this.elements = {};
            this.events = [
              "mousemove",
              "mouseout",
              "click",
              "touchstart",
              "touchmove"
            ];
            this.font = {
              family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
              size: 12,
              style: "normal",
              lineHeight: 1.2,
              weight: null
            };
            this.hover = {};
            this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
            this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
            this.hoverColor = (ctx, options) => getHoverColor(options.color);
            this.indexAxis = "x";
            this.interaction = {
              mode: "nearest",
              intersect: true,
              includeInvisible: false
            };
            this.maintainAspectRatio = true;
            this.onHover = null;
            this.onClick = null;
            this.parsing = true;
            this.plugins = {};
            this.responsive = true;
            this.scale = void 0;
            this.scales = {};
            this.showLine = true;
            this.drawActiveElementsOnTop = true;
            this.describe(_descriptors2);
          }
          set(scope, values) {
            return set(this, scope, values);
          }
          get(scope) {
            return getScope$1(this, scope);
          }
          describe(scope, values) {
            return set(descriptors, scope, values);
          }
          override(scope, values) {
            return set(overrides, scope, values);
          }
          route(scope, name, targetScope, targetName) {
            const scopeObject = getScope$1(this, scope);
            const targetScopeObject = getScope$1(this, targetScope);
            const privateName = "_" + name;
            Object.defineProperties(scopeObject, {
              [privateName]: {
                value: scopeObject[name],
                writable: true
              },
              [name]: {
                enumerable: true,
                get() {
                  const local = this[privateName];
                  const target = targetScopeObject[targetName];
                  if (isObject2(local)) {
                    return Object.assign({}, target, local);
                  }
                  return valueOrDefault(local, target);
                },
                set(value) {
                  this[privateName] = value;
                }
              }
            });
          }
        }
        var defaults = new Defaults({
          _scriptable: (name) => !name.startsWith("on"),
          _indexable: (name) => name !== "events",
          hover: {
            _fallback: "interaction"
          },
          interaction: {
            _scriptable: false,
            _indexable: false
          }
        });
        function _isDomSupported() {
          return typeof window !== "undefined" && typeof document !== "undefined";
        }
        function _getParentNode(domNode) {
          let parent = domNode.parentNode;
          if (parent && parent.toString() === "[object ShadowRoot]") {
            parent = parent.host;
          }
          return parent;
        }
        function parseMaxStyle(styleValue, node, parentProperty) {
          let valueInPixels;
          if (typeof styleValue === "string") {
            valueInPixels = parseInt(styleValue, 10);
            if (styleValue.indexOf("%") !== -1) {
              valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
            }
          } else {
            valueInPixels = styleValue;
          }
          return valueInPixels;
        }
        const getComputedStyle2 = (element) => window.getComputedStyle(element, null);
        function getStyle(el, property) {
          return getComputedStyle2(el).getPropertyValue(property);
        }
        const positions = ["top", "right", "bottom", "left"];
        function getPositionedStyle(styles, style, suffix) {
          const result = {};
          suffix = suffix ? "-" + suffix : "";
          for (let i = 0; i < 4; i++) {
            const pos = positions[i];
            result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
          }
          result.width = result.left + result.right;
          result.height = result.top + result.bottom;
          return result;
        }
        const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
        function getCanvasPosition(e, canvas) {
          const touches = e.touches;
          const source = touches && touches.length ? touches[0] : e;
          const { offsetX, offsetY } = source;
          let box = false;
          let x, y;
          if (useOffsetPos(offsetX, offsetY, e.target)) {
            x = offsetX;
            y = offsetY;
          } else {
            const rect = canvas.getBoundingClientRect();
            x = source.clientX - rect.left;
            y = source.clientY - rect.top;
            box = true;
          }
          return { x, y, box };
        }
        function getRelativePosition(evt, chart2) {
          if ("native" in evt) {
            return evt;
          }
          const { canvas, currentDevicePixelRatio } = chart2;
          const style = getComputedStyle2(canvas);
          const borderBox = style.boxSizing === "border-box";
          const paddings = getPositionedStyle(style, "padding");
          const borders = getPositionedStyle(style, "border", "width");
          const { x, y, box } = getCanvasPosition(evt, canvas);
          const xOffset = paddings.left + (box && borders.left);
          const yOffset = paddings.top + (box && borders.top);
          let { width, height } = chart2;
          if (borderBox) {
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          return {
            x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
            y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
          };
        }
        function getContainerSize(canvas, width, height) {
          let maxWidth, maxHeight;
          if (width === void 0 || height === void 0) {
            const container = _getParentNode(canvas);
            if (!container) {
              width = canvas.clientWidth;
              height = canvas.clientHeight;
            } else {
              const rect = container.getBoundingClientRect();
              const containerStyle = getComputedStyle2(container);
              const containerBorder = getPositionedStyle(containerStyle, "border", "width");
              const containerPadding = getPositionedStyle(containerStyle, "padding");
              width = rect.width - containerPadding.width - containerBorder.width;
              height = rect.height - containerPadding.height - containerBorder.height;
              maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
              maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
            }
          }
          return {
            width,
            height,
            maxWidth: maxWidth || INFINITY,
            maxHeight: maxHeight || INFINITY
          };
        }
        const round1 = (v) => Math.round(v * 10) / 10;
        function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
          const style = getComputedStyle2(canvas);
          const margins = getPositionedStyle(style, "margin");
          const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
          const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
          const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
          let { width, height } = containerSize;
          if (style.boxSizing === "content-box") {
            const borders = getPositionedStyle(style, "border", "width");
            const paddings = getPositionedStyle(style, "padding");
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          width = Math.max(0, width - margins.width);
          height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
          width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
          height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
          if (width && !height) {
            height = round1(width / 2);
          }
          return {
            width,
            height
          };
        }
        function retinaScale(chart2, forceRatio, forceStyle) {
          const pixelRatio = forceRatio || 1;
          const deviceHeight = Math.floor(chart2.height * pixelRatio);
          const deviceWidth = Math.floor(chart2.width * pixelRatio);
          chart2.height = deviceHeight / pixelRatio;
          chart2.width = deviceWidth / pixelRatio;
          const canvas = chart2.canvas;
          if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
            canvas.style.height = `${chart2.height}px`;
            canvas.style.width = `${chart2.width}px`;
          }
          if (chart2.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
            chart2.currentDevicePixelRatio = pixelRatio;
            canvas.height = deviceHeight;
            canvas.width = deviceWidth;
            chart2.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            return true;
          }
          return false;
        }
        const supportsEventListenerOptions = function() {
          let passiveSupported = false;
          try {
            const options = {
              get passive() {
                passiveSupported = true;
                return false;
              }
            };
            window.addEventListener("test", null, options);
            window.removeEventListener("test", null, options);
          } catch (e) {
          }
          return passiveSupported;
        }();
        function readUsedSize(element, property) {
          const value = getStyle(element, property);
          const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
          return matches ? +matches[1] : void 0;
        }
        function toFontString(font) {
          if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
            return null;
          }
          return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        function _measureText(ctx, data, gc, longest, string) {
          let textWidth = data[string];
          if (!textWidth) {
            textWidth = data[string] = ctx.measureText(string).width;
            gc.push(string);
          }
          if (textWidth > longest) {
            longest = textWidth;
          }
          return longest;
        }
        function _longestText(ctx, font, arrayOfThings, cache) {
          cache = cache || {};
          let data = cache.data = cache.data || {};
          let gc = cache.garbageCollect = cache.garbageCollect || [];
          if (cache.font !== font) {
            data = cache.data = {};
            gc = cache.garbageCollect = [];
            cache.font = font;
          }
          ctx.save();
          ctx.font = font;
          let longest = 0;
          const ilen = arrayOfThings.length;
          let i, j, jlen, thing, nestedThing;
          for (i = 0; i < ilen; i++) {
            thing = arrayOfThings[i];
            if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
              longest = _measureText(ctx, data, gc, longest, thing);
            } else if (isArray(thing)) {
              for (j = 0, jlen = thing.length; j < jlen; j++) {
                nestedThing = thing[j];
                if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
                  longest = _measureText(ctx, data, gc, longest, nestedThing);
                }
              }
            }
          }
          ctx.restore();
          const gcLen = gc.length / 2;
          if (gcLen > arrayOfThings.length) {
            for (i = 0; i < gcLen; i++) {
              delete data[gc[i]];
            }
            gc.splice(0, gcLen);
          }
          return longest;
        }
        function _alignPixel(chart2, pixel, width) {
          const devicePixelRatio = chart2.currentDevicePixelRatio;
          const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
          return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
        }
        function clearCanvas(canvas, ctx) {
          ctx = ctx || canvas.getContext("2d");
          ctx.save();
          ctx.resetTransform();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }
        function drawPoint(ctx, options, x, y) {
          drawPointLegend(ctx, options, x, y, null);
        }
        function drawPointLegend(ctx, options, x, y, w) {
          let type, xOffset, yOffset, size, cornerRadius, width;
          const style = options.pointStyle;
          const rotation = options.rotation;
          const radius = options.radius;
          let rad = (rotation || 0) * RAD_PER_DEG;
          if (style && typeof style === "object") {
            type = style.toString();
            if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate(rad);
              ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
              ctx.restore();
              return;
            }
          }
          if (isNaN(radius) || radius <= 0) {
            return;
          }
          ctx.beginPath();
          switch (style) {
            default:
              if (w) {
                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
              } else {
                ctx.arc(x, y, radius, 0, TAU);
              }
              ctx.closePath();
              break;
            case "triangle":
              ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              ctx.closePath();
              break;
            case "rectRounded":
              cornerRadius = radius * 0.516;
              size = radius - cornerRadius;
              xOffset = Math.cos(rad + QUARTER_PI) * size;
              yOffset = Math.sin(rad + QUARTER_PI) * size;
              ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
              ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
              ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
              ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
              ctx.closePath();
              break;
            case "rect":
              if (!rotation) {
                size = Math.SQRT1_2 * radius;
                width = w ? w / 2 : size;
                ctx.rect(x - width, y - size, 2 * width, 2 * size);
                break;
              }
              rad += QUARTER_PI;
            case "rectRot":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + yOffset, y - xOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              ctx.closePath();
              break;
            case "crossRot":
              rad += QUARTER_PI;
            case "cross":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              break;
            case "star":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              rad += QUARTER_PI;
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              break;
            case "line":
              xOffset = w ? w / 2 : Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              break;
            case "dash":
              ctx.moveTo(x, y);
              ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
              break;
          }
          ctx.fill();
          if (options.borderWidth > 0) {
            ctx.stroke();
          }
        }
        function _isPointInArea(point, area, margin) {
          margin = margin || 0.5;
          return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
        }
        function clipArea(ctx, area) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
          ctx.clip();
        }
        function unclipArea(ctx) {
          ctx.restore();
        }
        function _steppedLineTo(ctx, previous, target, flip, mode) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          if (mode === "middle") {
            const midpoint = (previous.x + target.x) / 2;
            ctx.lineTo(midpoint, previous.y);
            ctx.lineTo(midpoint, target.y);
          } else if (mode === "after" !== !!flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }
          ctx.lineTo(target.x, target.y);
        }
        function _bezierCurveTo(ctx, previous, target, flip) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
        }
        function renderText(ctx, text, x, y, font, opts = {}) {
          const lines = isArray(text) ? text : [text];
          const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
          let i, line;
          ctx.save();
          ctx.font = font.string;
          setRenderOpts(ctx, opts);
          for (i = 0; i < lines.length; ++i) {
            line = lines[i];
            if (stroke) {
              if (opts.strokeColor) {
                ctx.strokeStyle = opts.strokeColor;
              }
              if (!isNullOrUndef(opts.strokeWidth)) {
                ctx.lineWidth = opts.strokeWidth;
              }
              ctx.strokeText(line, x, y, opts.maxWidth);
            }
            ctx.fillText(line, x, y, opts.maxWidth);
            decorateText(ctx, x, y, line, opts);
            y += font.lineHeight;
          }
          ctx.restore();
        }
        function setRenderOpts(ctx, opts) {
          if (opts.translation) {
            ctx.translate(opts.translation[0], opts.translation[1]);
          }
          if (!isNullOrUndef(opts.rotation)) {
            ctx.rotate(opts.rotation);
          }
          if (opts.color) {
            ctx.fillStyle = opts.color;
          }
          if (opts.textAlign) {
            ctx.textAlign = opts.textAlign;
          }
          if (opts.textBaseline) {
            ctx.textBaseline = opts.textBaseline;
          }
        }
        function decorateText(ctx, x, y, line, opts) {
          if (opts.strikethrough || opts.underline) {
            const metrics = ctx.measureText(line);
            const left = x - metrics.actualBoundingBoxLeft;
            const right = x + metrics.actualBoundingBoxRight;
            const top = y - metrics.actualBoundingBoxAscent;
            const bottom = y + metrics.actualBoundingBoxDescent;
            const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.beginPath();
            ctx.lineWidth = opts.decorationWidth || 2;
            ctx.moveTo(left, yDecoration);
            ctx.lineTo(right, yDecoration);
            ctx.stroke();
          }
        }
        function addRoundedRectPath(ctx, rect) {
          const { x, y, w, h, radius } = rect;
          ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
          ctx.lineTo(x, y + h - radius.bottomLeft);
          ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
          ctx.lineTo(x + w - radius.bottomRight, y + h);
          ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
          ctx.lineTo(x + w, y + radius.topRight);
          ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
          ctx.lineTo(x + radius.topLeft, y);
        }
        function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
          if (!defined(fallback)) {
            fallback = _resolve("_fallback", scopes);
          }
          const cache = {
            [Symbol.toStringTag]: "Object",
            _cacheable: true,
            _scopes: scopes,
            _rootScopes: rootScopes,
            _fallback: fallback,
            _getTarget: getTarget,
            override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
          };
          return new Proxy(cache, {
            deleteProperty(target, prop) {
              delete target[prop];
              delete target._keys;
              delete scopes[0][prop];
              return true;
            },
            get(target, prop) {
              return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
            },
            getOwnPropertyDescriptor(target, prop) {
              return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
            },
            getPrototypeOf() {
              return Reflect.getPrototypeOf(scopes[0]);
            },
            has(target, prop) {
              return getKeysFromAllScopes(target).includes(prop);
            },
            ownKeys(target) {
              return getKeysFromAllScopes(target);
            },
            set(target, prop, value) {
              const storage = target._storage || (target._storage = getTarget());
              target[prop] = storage[prop] = value;
              delete target._keys;
              return true;
            }
          });
        }
        function _attachContext(proxy, context, subProxy, descriptorDefaults) {
          const cache = {
            _cacheable: false,
            _proxy: proxy,
            _context: context,
            _subProxy: subProxy,
            _stack: /* @__PURE__ */ new Set(),
            _descriptors: _descriptors(proxy, descriptorDefaults),
            setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
            override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
          };
          return new Proxy(cache, {
            deleteProperty(target, prop) {
              delete target[prop];
              delete proxy[prop];
              return true;
            },
            get(target, prop, receiver) {
              return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
            },
            getOwnPropertyDescriptor(target, prop) {
              return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
            },
            getPrototypeOf() {
              return Reflect.getPrototypeOf(proxy);
            },
            has(target, prop) {
              return Reflect.has(proxy, prop);
            },
            ownKeys() {
              return Reflect.ownKeys(proxy);
            },
            set(target, prop, value) {
              proxy[prop] = value;
              delete target[prop];
              return true;
            }
          });
        }
        function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
          const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
          return {
            allKeys: _allKeys,
            scriptable: _scriptable,
            indexable: _indexable,
            isScriptable: isFunction2(_scriptable) ? _scriptable : () => _scriptable,
            isIndexable: isFunction2(_indexable) ? _indexable : () => _indexable
          };
        }
        const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
        const needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
        function _cached(target, prop, resolve2) {
          if (Object.prototype.hasOwnProperty.call(target, prop)) {
            return target[prop];
          }
          const value = resolve2();
          target[prop] = value;
          return value;
        }
        function _resolveWithContext(target, prop, receiver) {
          const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
          let value = _proxy[prop];
          if (isFunction2(value) && descriptors2.isScriptable(prop)) {
            value = _resolveScriptable(prop, value, target, receiver);
          }
          if (isArray(value) && value.length) {
            value = _resolveArray(prop, value, target, descriptors2.isIndexable);
          }
          if (needsSubResolver(prop, value)) {
            value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
          }
          return value;
        }
        function _resolveScriptable(prop, value, target, receiver) {
          const { _proxy, _context, _subProxy, _stack } = target;
          if (_stack.has(prop)) {
            throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
          }
          _stack.add(prop);
          value = value(_context, _subProxy || receiver);
          _stack.delete(prop);
          if (needsSubResolver(prop, value)) {
            value = createSubResolver(_proxy._scopes, _proxy, prop, value);
          }
          return value;
        }
        function _resolveArray(prop, value, target, isIndexable) {
          const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
          if (defined(_context.index) && isIndexable(prop)) {
            value = value[_context.index % value.length];
          } else if (isObject2(value[0])) {
            const arr = value;
            const scopes = _proxy._scopes.filter((s) => s !== arr);
            value = [];
            for (const item of arr) {
              const resolver = createSubResolver(scopes, _proxy, prop, item);
              value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
            }
          }
          return value;
        }
        function resolveFallback(fallback, prop, value) {
          return isFunction2(fallback) ? fallback(prop, value) : fallback;
        }
        const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
        function addScopes(set2, parentScopes, key, parentFallback, value) {
          for (const parent of parentScopes) {
            const scope = getScope(key, parent);
            if (scope) {
              set2.add(scope);
              const fallback = resolveFallback(scope._fallback, key, value);
              if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
                return fallback;
              }
            } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
              return null;
            }
          }
          return false;
        }
        function createSubResolver(parentScopes, resolver, prop, value) {
          const rootScopes = resolver._rootScopes;
          const fallback = resolveFallback(resolver._fallback, prop, value);
          const allScopes = [...parentScopes, ...rootScopes];
          const set2 = /* @__PURE__ */ new Set();
          set2.add(value);
          let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
          if (key === null) {
            return false;
          }
          if (defined(fallback) && fallback !== prop) {
            key = addScopesFromKey(set2, allScopes, fallback, key, value);
            if (key === null) {
              return false;
            }
          }
          return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
        }
        function addScopesFromKey(set2, allScopes, key, fallback, item) {
          while (key) {
            key = addScopes(set2, allScopes, key, fallback, item);
          }
          return key;
        }
        function subGetTarget(resolver, prop, value) {
          const parent = resolver._getTarget();
          if (!(prop in parent)) {
            parent[prop] = {};
          }
          const target = parent[prop];
          if (isArray(target) && isObject2(value)) {
            return value;
          }
          return target;
        }
        function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
          let value;
          for (const prefix of prefixes) {
            value = _resolve(readKey(prefix, prop), scopes);
            if (defined(value)) {
              return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
            }
          }
        }
        function _resolve(key, scopes) {
          for (const scope of scopes) {
            if (!scope) {
              continue;
            }
            const value = scope[key];
            if (defined(value)) {
              return value;
            }
          }
        }
        function getKeysFromAllScopes(target) {
          let keys = target._keys;
          if (!keys) {
            keys = target._keys = resolveKeysFromAllScopes(target._scopes);
          }
          return keys;
        }
        function resolveKeysFromAllScopes(scopes) {
          const set2 = /* @__PURE__ */ new Set();
          for (const scope of scopes) {
            for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
              set2.add(key);
            }
          }
          return Array.from(set2);
        }
        function _parseObjectDataRadialScale(meta, data, start, count) {
          const { iScale } = meta;
          const { key = "r" } = this._parsing;
          const parsed = new Array(count);
          let i, ilen, index3, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index3 = i + start;
            item = data[index3];
            parsed[i] = {
              r: iScale.parse(resolveObjectKey(item, key), index3)
            };
          }
          return parsed;
        }
        const EPSILON = Number.EPSILON || 1e-14;
        const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
        const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
        function splineCurve(firstPoint, middlePoint, afterPoint, t) {
          const previous = firstPoint.skip ? middlePoint : firstPoint;
          const current = middlePoint;
          const next = afterPoint.skip ? middlePoint : afterPoint;
          const d01 = distanceBetweenPoints(current, previous);
          const d12 = distanceBetweenPoints(next, current);
          let s01 = d01 / (d01 + d12);
          let s12 = d12 / (d01 + d12);
          s01 = isNaN(s01) ? 0 : s01;
          s12 = isNaN(s12) ? 0 : s12;
          const fa = t * s01;
          const fb = t * s12;
          return {
            previous: {
              x: current.x - fa * (next.x - previous.x),
              y: current.y - fa * (next.y - previous.y)
            },
            next: {
              x: current.x + fb * (next.x - previous.x),
              y: current.y + fb * (next.y - previous.y)
            }
          };
        }
        function monotoneAdjust(points, deltaK, mK) {
          const pointsLen = points.length;
          let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen - 1; ++i) {
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent || !pointAfter) {
              continue;
            }
            if (almostEquals(deltaK[i], 0, EPSILON)) {
              mK[i] = mK[i + 1] = 0;
              continue;
            }
            alphaK = mK[i] / deltaK[i];
            betaK = mK[i + 1] / deltaK[i];
            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
            if (squaredMagnitude <= 9) {
              continue;
            }
            tauK = 3 / Math.sqrt(squaredMagnitude);
            mK[i] = alphaK * tauK * deltaK[i];
            mK[i + 1] = betaK * tauK * deltaK[i];
          }
        }
        function monotoneCompute(points, mK, indexAxis = "x") {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          let delta, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            const iPixel = pointCurrent[indexAxis];
            const vPixel = pointCurrent[valueAxis];
            if (pointBefore) {
              delta = (iPixel - pointBefore[indexAxis]) / 3;
              pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
              pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
            }
            if (pointAfter) {
              delta = (pointAfter[indexAxis] - iPixel) / 3;
              pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
              pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
            }
          }
        }
        function splineCurveMonotone(points, indexAxis = "x") {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          const deltaK = Array(pointsLen).fill(0);
          const mK = Array(pointsLen);
          let i, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            if (pointAfter) {
              const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
              deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
            }
            mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
          }
          monotoneAdjust(points, deltaK, mK);
          monotoneCompute(points, mK, indexAxis);
        }
        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }
        function capBezierPoints(points, area) {
          let i, ilen, point, inArea, inAreaPrev;
          let inAreaNext = _isPointInArea(points[0], area);
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            inAreaPrev = inArea;
            inArea = inAreaNext;
            inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
            if (!inArea) {
              continue;
            }
            point = points[i];
            if (inAreaPrev) {
              point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
              point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
            }
            if (inAreaNext) {
              point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
              point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
            }
          }
        }
        function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
          let i, ilen, point, controlPoints;
          if (options.spanGaps) {
            points = points.filter((pt) => !pt.skip);
          }
          if (options.cubicInterpolationMode === "monotone") {
            splineCurveMonotone(points, indexAxis);
          } else {
            let prev = loop ? points[points.length - 1] : points[0];
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              point = points[i];
              controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
              point.cp1x = controlPoints.previous.x;
              point.cp1y = controlPoints.previous.y;
              point.cp2x = controlPoints.next.x;
              point.cp2y = controlPoints.next.y;
              prev = point;
            }
          }
          if (options.capBezierPoints) {
            capBezierPoints(points, area);
          }
        }
        const atEdge = (t) => t === 0 || t === 1;
        const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
        const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
        const effects = {
          linear: (t) => t,
          easeInQuad: (t) => t * t,
          easeOutQuad: (t) => -t * (t - 2),
          easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
          easeInCubic: (t) => t * t * t,
          easeOutCubic: (t) => (t -= 1) * t * t + 1,
          easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
          easeInQuart: (t) => t * t * t * t,
          easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
          easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
          easeInQuint: (t) => t * t * t * t * t,
          easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
          easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
          easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
          easeOutSine: (t) => Math.sin(t * HALF_PI),
          easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
          easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
          easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
          easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
          easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
          easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
          easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
          easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
          easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
          easeInOutElastic(t) {
            const s = 0.1125;
            const p = 0.45;
            return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
          },
          easeInBack(t) {
            const s = 1.70158;
            return t * t * ((s + 1) * t - s);
          },
          easeOutBack(t) {
            const s = 1.70158;
            return (t -= 1) * t * ((s + 1) * t + s) + 1;
          },
          easeInOutBack(t) {
            let s = 1.70158;
            if ((t /= 0.5) < 1) {
              return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
            }
            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
          },
          easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
          easeOutBounce(t) {
            const m = 7.5625;
            const d = 2.75;
            if (t < 1 / d) {
              return m * t * t;
            }
            if (t < 2 / d) {
              return m * (t -= 1.5 / d) * t + 0.75;
            }
            if (t < 2.5 / d) {
              return m * (t -= 2.25 / d) * t + 0.9375;
            }
            return m * (t -= 2.625 / d) * t + 0.984375;
          },
          easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
        };
        function _pointInLine(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y: p1.y + t * (p2.y - p1.y)
          };
        }
        function _steppedInterpolation(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
          };
        }
        function _bezierInterpolation(p1, p2, t, mode) {
          const cp1 = { x: p1.cp2x, y: p1.cp2y };
          const cp2 = { x: p2.cp1x, y: p2.cp1y };
          const a = _pointInLine(p1, cp1, t);
          const b = _pointInLine(cp1, cp2, t);
          const c = _pointInLine(cp2, p2, t);
          const d = _pointInLine(a, b, t);
          const e = _pointInLine(b, c, t);
          return _pointInLine(d, e, t);
        }
        const intlCache = /* @__PURE__ */ new Map();
        function getNumberFormat(locale, options) {
          options = options || {};
          const cacheKey = locale + JSON.stringify(options);
          let formatter = intlCache.get(cacheKey);
          if (!formatter) {
            formatter = new Intl.NumberFormat(locale, options);
            intlCache.set(cacheKey, formatter);
          }
          return formatter;
        }
        function formatNumber(num, locale, options) {
          return getNumberFormat(locale, options).format(num);
        }
        const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
        const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
        function toLineHeight(value, size) {
          const matches = ("" + value).match(LINE_HEIGHT);
          if (!matches || matches[1] === "normal") {
            return size * 1.2;
          }
          value = +matches[2];
          switch (matches[3]) {
            case "px":
              return value;
            case "%":
              value /= 100;
              break;
          }
          return size * value;
        }
        const numberOrZero = (v) => +v || 0;
        function _readValueToProps(value, props) {
          const ret = {};
          const objProps = isObject2(props);
          const keys = objProps ? Object.keys(props) : props;
          const read = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
          for (const prop of keys) {
            ret[prop] = numberOrZero(read(prop));
          }
          return ret;
        }
        function toTRBL(value) {
          return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
        }
        function toTRBLCorners(value) {
          return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
        }
        function toPadding(value) {
          const obj = toTRBL(value);
          obj.width = obj.left + obj.right;
          obj.height = obj.top + obj.bottom;
          return obj;
        }
        function toFont(options, fallback) {
          options = options || {};
          fallback = fallback || defaults.font;
          let size = valueOrDefault(options.size, fallback.size);
          if (typeof size === "string") {
            size = parseInt(size, 10);
          }
          let style = valueOrDefault(options.style, fallback.style);
          if (style && !("" + style).match(FONT_STYLE)) {
            console.warn('Invalid font style specified: "' + style + '"');
            style = "";
          }
          const font = {
            family: valueOrDefault(options.family, fallback.family),
            lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
            size,
            style,
            weight: valueOrDefault(options.weight, fallback.weight),
            string: ""
          };
          font.string = toFontString(font);
          return font;
        }
        function resolve(inputs, context, index3, info) {
          let cacheable = true;
          let i, ilen, value;
          for (i = 0, ilen = inputs.length; i < ilen; ++i) {
            value = inputs[i];
            if (value === void 0) {
              continue;
            }
            if (context !== void 0 && typeof value === "function") {
              value = value(context);
              cacheable = false;
            }
            if (index3 !== void 0 && isArray(value)) {
              value = value[index3 % value.length];
              cacheable = false;
            }
            if (value !== void 0) {
              if (info && !cacheable) {
                info.cacheable = false;
              }
              return value;
            }
          }
        }
        function _addGrace(minmax, grace, beginAtZero) {
          const { min, max } = minmax;
          const change = toDimension(grace, (max - min) / 2);
          const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
          return {
            min: keepZero(min, -Math.abs(change)),
            max: keepZero(max, change)
          };
        }
        function createContext(parentContext, context) {
          return Object.assign(Object.create(parentContext), context);
        }
        const getRightToLeftAdapter = function(rectX, width) {
          return {
            x(x) {
              return rectX + rectX + width - x;
            },
            setWidth(w) {
              width = w;
            },
            textAlign(align) {
              if (align === "center") {
                return align;
              }
              return align === "right" ? "left" : "right";
            },
            xPlus(x, value) {
              return x - value;
            },
            leftForLtr(x, itemWidth) {
              return x - itemWidth;
            }
          };
        };
        const getLeftToRightAdapter = function() {
          return {
            x(x) {
              return x;
            },
            setWidth(w) {
            },
            textAlign(align) {
              return align;
            },
            xPlus(x, value) {
              return x + value;
            },
            leftForLtr(x, _itemWidth) {
              return x;
            }
          };
        };
        function getRtlAdapter(rtl, rectX, width) {
          return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
        }
        function overrideTextDirection(ctx, direction) {
          let style, original;
          if (direction === "ltr" || direction === "rtl") {
            style = ctx.canvas.style;
            original = [
              style.getPropertyValue("direction"),
              style.getPropertyPriority("direction")
            ];
            style.setProperty("direction", direction, "important");
            ctx.prevTextDirection = original;
          }
        }
        function restoreTextDirection(ctx, original) {
          if (original !== void 0) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty("direction", original[0], original[1]);
          }
        }
        function propertyFn(property) {
          if (property === "angle") {
            return {
              between: _angleBetween,
              compare: _angleDiff,
              normalize: _normalizeAngle
            };
          }
          return {
            between: _isBetween,
            compare: (a, b) => a - b,
            normalize: (x) => x
          };
        }
        function normalizeSegment({ start, end, count, loop, style }) {
          return {
            start: start % count,
            end: end % count,
            loop: loop && (end - start + 1) % count === 0,
            style
          };
        }
        function getSegment(segment, points, bounds) {
          const { property, start: startBound, end: endBound } = bounds;
          const { between, normalize } = propertyFn(property);
          const count = points.length;
          let { start, end, loop } = segment;
          let i, ilen;
          if (loop) {
            start += count;
            end += count;
            for (i = 0, ilen = count; i < ilen; ++i) {
              if (!between(normalize(points[start % count][property]), startBound, endBound)) {
                break;
              }
              start--;
              end--;
            }
            start %= count;
            end %= count;
          }
          if (end < start) {
            end += count;
          }
          return { start, end, loop, style: segment.style };
        }
        function _boundSegment(segment, points, bounds) {
          if (!bounds) {
            return [segment];
          }
          const { property, start: startBound, end: endBound } = bounds;
          const count = points.length;
          const { compare, between, normalize } = propertyFn(property);
          const { start, end, loop, style } = getSegment(segment, points, bounds);
          const result = [];
          let inside = false;
          let subStart = null;
          let value, point, prevValue;
          const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
          const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
          const shouldStart = () => inside || startIsBefore();
          const shouldStop = () => !inside || endIsBefore();
          for (let i = start, prev = start; i <= end; ++i) {
            point = points[i % count];
            if (point.skip) {
              continue;
            }
            value = normalize(point[property]);
            if (value === prevValue) {
              continue;
            }
            inside = between(value, startBound, endBound);
            if (subStart === null && shouldStart()) {
              subStart = compare(value, startBound) === 0 ? i : prev;
            }
            if (subStart !== null && shouldStop()) {
              result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
              subStart = null;
            }
            prev = i;
            prevValue = value;
          }
          if (subStart !== null) {
            result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
          }
          return result;
        }
        function _boundSegments(line, bounds) {
          const result = [];
          const segments = line.segments;
          for (let i = 0; i < segments.length; i++) {
            const sub = _boundSegment(segments[i], line.points, bounds);
            if (sub.length) {
              result.push(...sub);
            }
          }
          return result;
        }
        function findStartAndEnd(points, count, loop, spanGaps) {
          let start = 0;
          let end = count - 1;
          if (loop && !spanGaps) {
            while (start < count && !points[start].skip) {
              start++;
            }
          }
          while (start < count && points[start].skip) {
            start++;
          }
          start %= count;
          if (loop) {
            end += start;
          }
          while (end > start && points[end % count].skip) {
            end--;
          }
          end %= count;
          return { start, end };
        }
        function solidSegments(points, start, max, loop) {
          const count = points.length;
          const result = [];
          let last = start;
          let prev = points[start];
          let end;
          for (end = start + 1; end <= max; ++end) {
            const cur = points[end % count];
            if (cur.skip || cur.stop) {
              if (!prev.skip) {
                loop = false;
                result.push({ start: start % count, end: (end - 1) % count, loop });
                start = last = cur.stop ? end : null;
              }
            } else {
              last = end;
              if (prev.skip) {
                start = end;
              }
            }
            prev = cur;
          }
          if (last !== null) {
            result.push({ start: start % count, end: last % count, loop });
          }
          return result;
        }
        function _computeSegments(line, segmentOptions) {
          const points = line.points;
          const spanGaps = line.options.spanGaps;
          const count = points.length;
          if (!count) {
            return [];
          }
          const loop = !!line._loop;
          const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
          if (spanGaps === true) {
            return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
          }
          const max = end < start ? end + count : end;
          const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
          return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
        }
        function splitByStyles(line, segments, points, segmentOptions) {
          if (!segmentOptions || !segmentOptions.setContext || !points) {
            return segments;
          }
          return doSplitByStyles(line, segments, points, segmentOptions);
        }
        function doSplitByStyles(line, segments, points, segmentOptions) {
          const chartContext = line._chart.getContext();
          const baseStyle = readStyle(line.options);
          const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
          const count = points.length;
          const result = [];
          let prevStyle = baseStyle;
          let start = segments[0].start;
          let i = start;
          function addStyle(s, e, l, st) {
            const dir = spanGaps ? -1 : 1;
            if (s === e) {
              return;
            }
            s += count;
            while (points[s % count].skip) {
              s -= dir;
            }
            while (points[e % count].skip) {
              e += dir;
            }
            if (s % count !== e % count) {
              result.push({ start: s % count, end: e % count, loop: l, style: st });
              prevStyle = st;
              start = e % count;
            }
          }
          for (const segment of segments) {
            start = spanGaps ? start : segment.start;
            let prev = points[start % count];
            let style;
            for (i = start + 1; i <= segment.end; i++) {
              const pt = points[i % count];
              style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                type: "segment",
                p0: prev,
                p1: pt,
                p0DataIndex: (i - 1) % count,
                p1DataIndex: i % count,
                datasetIndex
              })));
              if (styleChanged(style, prevStyle)) {
                addStyle(start, i - 1, segment.loop, prevStyle);
              }
              prev = pt;
              prevStyle = style;
            }
            if (start < i - 1) {
              addStyle(start, i - 1, segment.loop, prevStyle);
            }
          }
          return result;
        }
        function readStyle(options) {
          return {
            backgroundColor: options.backgroundColor,
            borderCapStyle: options.borderCapStyle,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderJoinStyle: options.borderJoinStyle,
            borderWidth: options.borderWidth,
            borderColor: options.borderColor
          };
        }
        function styleChanged(style, prevStyle) {
          return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
        }
        var helpers = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          easingEffects: effects,
          isPatternOrGradient,
          color,
          getHoverColor,
          noop: noop2,
          uid,
          isNullOrUndef,
          isArray,
          isObject: isObject2,
          isFinite: isNumberFinite,
          finiteOrDefault,
          valueOrDefault,
          toPercentage,
          toDimension,
          callback,
          each,
          _elementsEqual,
          clone: clone$1,
          _merger,
          merge,
          mergeIf,
          _mergerIf,
          _deprecated,
          resolveObjectKey,
          _splitKey,
          _capitalize,
          defined,
          isFunction: isFunction2,
          setsEqual,
          _isClickEvent,
          toFontString,
          _measureText,
          _longestText,
          _alignPixel,
          clearCanvas,
          drawPoint,
          drawPointLegend,
          _isPointInArea,
          clipArea,
          unclipArea,
          _steppedLineTo,
          _bezierCurveTo,
          renderText,
          addRoundedRectPath,
          _lookup,
          _lookupByKey,
          _rlookupByKey,
          _filterBetween,
          listenArrayEvents,
          unlistenArrayEvents,
          _arrayUnique,
          _createResolver,
          _attachContext,
          _descriptors,
          _parseObjectDataRadialScale,
          splineCurve,
          splineCurveMonotone,
          _updateBezierControlPoints,
          _isDomSupported,
          _getParentNode,
          getStyle,
          getRelativePosition,
          getMaximumSize,
          retinaScale,
          supportsEventListenerOptions,
          readUsedSize,
          fontString,
          requestAnimFrame,
          throttled,
          debounce,
          _toLeftRightCenter,
          _alignStartEnd,
          _textX,
          _getStartAndCountOfVisiblePoints,
          _scaleRangesChanged,
          _pointInLine,
          _steppedInterpolation,
          _bezierInterpolation,
          formatNumber,
          toLineHeight,
          _readValueToProps,
          toTRBL,
          toTRBLCorners,
          toPadding,
          toFont,
          resolve,
          _addGrace,
          createContext,
          PI,
          TAU,
          PITAU,
          INFINITY,
          RAD_PER_DEG,
          HALF_PI,
          QUARTER_PI,
          TWO_THIRDS_PI,
          log10,
          sign,
          niceNum,
          _factorize,
          isNumber,
          almostEquals,
          almostWhole,
          _setMinAndMaxByKey,
          toRadians,
          toDegrees,
          _decimalPlaces,
          getAngleFromPoint,
          distanceBetweenPoints,
          _angleDiff,
          _normalizeAngle,
          _angleBetween,
          _limitValue,
          _int16Range,
          _isBetween,
          getRtlAdapter,
          overrideTextDirection,
          restoreTextDirection,
          _boundSegment,
          _boundSegments,
          _computeSegments
        });
        function binarySearch(metaset, axis, value, intersect) {
          const { controller, data, _sorted } = metaset;
          const iScale = controller._cachedMeta.iScale;
          if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
            const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
            if (!intersect) {
              return lookupMethod(data, axis, value);
            } else if (controller._sharedOptions) {
              const el = data[0];
              const range2 = typeof el.getRange === "function" && el.getRange(axis);
              if (range2) {
                const start = lookupMethod(data, axis, value - range2);
                const end = lookupMethod(data, axis, value + range2);
                return { lo: start.lo, hi: end.hi };
              }
            }
          }
          return { lo: 0, hi: data.length - 1 };
        }
        function evaluateInteractionItems(chart2, axis, position, handler, intersect) {
          const metasets = chart2.getSortedVisibleDatasetMetas();
          const value = position[axis];
          for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
            const { index: index3, data } = metasets[i];
            const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
            for (let j = lo; j <= hi; ++j) {
              const element = data[j];
              if (!element.skip) {
                handler(element, index3, j);
              }
            }
          }
        }
        function getDistanceMetricForAxis(axis) {
          const useX = axis.indexOf("x") !== -1;
          const useY = axis.indexOf("y") !== -1;
          return function(pt1, pt2) {
            const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        }
        function getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) {
          const items = [];
          if (!includeInvisible && !chart2.isPointInArea(position)) {
            return items;
          }
          const evaluationFunc = function(element, datasetIndex, index3) {
            if (!includeInvisible && !_isPointInArea(element, chart2.chartArea, 0)) {
              return;
            }
            if (element.inRange(position.x, position.y, useFinalPosition)) {
              items.push({ element, datasetIndex, index: index3 });
            }
          };
          evaluateInteractionItems(chart2, axis, position, evaluationFunc, true);
          return items;
        }
        function getNearestRadialItems(chart2, position, axis, useFinalPosition) {
          let items = [];
          function evaluationFunc(element, datasetIndex, index3) {
            const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
            const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
            if (_angleBetween(angle, startAngle, endAngle)) {
              items.push({ element, datasetIndex, index: index3 });
            }
          }
          evaluateInteractionItems(chart2, axis, position, evaluationFunc);
          return items;
        }
        function getNearestCartesianItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible) {
          let items = [];
          const distanceMetric = getDistanceMetricForAxis(axis);
          let minDistance = Number.POSITIVE_INFINITY;
          function evaluationFunc(element, datasetIndex, index3) {
            const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
            if (intersect && !inRange2) {
              return;
            }
            const center = element.getCenterPoint(useFinalPosition);
            const pointInArea = !!includeInvisible || chart2.isPointInArea(center);
            if (!pointInArea && !inRange2) {
              return;
            }
            const distance2 = distanceMetric(position, center);
            if (distance2 < minDistance) {
              items = [{ element, datasetIndex, index: index3 }];
              minDistance = distance2;
            } else if (distance2 === minDistance) {
              items.push({ element, datasetIndex, index: index3 });
            }
          }
          evaluateInteractionItems(chart2, axis, position, evaluationFunc);
          return items;
        }
        function getNearestItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible) {
          if (!includeInvisible && !chart2.isPointInArea(position)) {
            return [];
          }
          return axis === "r" && !intersect ? getNearestRadialItems(chart2, position, axis, useFinalPosition) : getNearestCartesianItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible);
        }
        function getAxisItems(chart2, position, axis, intersect, useFinalPosition) {
          const items = [];
          const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
          let intersectsItem = false;
          evaluateInteractionItems(chart2, axis, position, (element, datasetIndex, index3) => {
            if (element[rangeMethod](position[axis], useFinalPosition)) {
              items.push({ element, datasetIndex, index: index3 });
              intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
            }
          });
          if (intersect && !intersectsItem) {
            return [];
          }
          return items;
        }
        var Interaction = {
          evaluateInteractionItems,
          modes: {
            index(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "x";
              const includeInvisible = options.includeInvisible || false;
              const items = options.intersect ? getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart2, position, axis, false, useFinalPosition, includeInvisible);
              const elements2 = [];
              if (!items.length) {
                return [];
              }
              chart2.getSortedVisibleDatasetMetas().forEach((meta) => {
                const index3 = items[0].index;
                const element = meta.data[index3];
                if (element && !element.skip) {
                  elements2.push({ element, datasetIndex: meta.index, index: index3 });
                }
              });
              return elements2;
            },
            dataset(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              let items = options.intersect ? getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart2, position, axis, false, useFinalPosition, includeInvisible);
              if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart2.getDatasetMeta(datasetIndex).data;
                items = [];
                for (let i = 0; i < data.length; ++i) {
                  items.push({ element: data[i], datasetIndex, index: i });
                }
              }
              return items;
            },
            point(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              return getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible);
            },
            nearest(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              return getNearestItems(chart2, position, axis, options.intersect, useFinalPosition, includeInvisible);
            },
            x(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              return getAxisItems(chart2, position, "x", options.intersect, useFinalPosition);
            },
            y(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              return getAxisItems(chart2, position, "y", options.intersect, useFinalPosition);
            }
          }
        };
        const STATIC_POSITIONS = ["left", "top", "right", "bottom"];
        function filterByPosition(array, position) {
          return array.filter((v) => v.pos === position);
        }
        function filterDynamicPositionByAxis(array, axis) {
          return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
        }
        function sortByWeight(array, reverse) {
          return array.sort((a, b) => {
            const v0 = reverse ? b : a;
            const v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
          });
        }
        function wrapBoxes(boxes) {
          const layoutBoxes = [];
          let i, ilen, box, pos, stack, stackWeight;
          for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
            box = boxes[i];
            ({ position: pos, options: { stack, stackWeight = 1 } } = box);
            layoutBoxes.push({
              index: i,
              box,
              pos,
              horizontal: box.isHorizontal(),
              weight: box.weight,
              stack: stack && pos + stack,
              stackWeight
            });
          }
          return layoutBoxes;
        }
        function buildStacks(layouts2) {
          const stacks = {};
          for (const wrap of layouts2) {
            const { stack, pos, stackWeight } = wrap;
            if (!stack || !STATIC_POSITIONS.includes(pos)) {
              continue;
            }
            const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
            _stack.count++;
            _stack.weight += stackWeight;
          }
          return stacks;
        }
        function setLayoutDims(layouts2, params) {
          const stacks = buildStacks(layouts2);
          const { vBoxMaxWidth, hBoxMaxHeight } = params;
          let i, ilen, layout;
          for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
            layout = layouts2[i];
            const { fullSize } = layout.box;
            const stack = stacks[layout.stack];
            const factor = stack && layout.stackWeight / stack.weight;
            if (layout.horizontal) {
              layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
              layout.height = hBoxMaxHeight;
            } else {
              layout.width = vBoxMaxWidth;
              layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
            }
          }
          return stacks;
        }
        function buildLayoutBoxes(boxes) {
          const layoutBoxes = wrapBoxes(boxes);
          const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
          const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
          const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
          const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
          const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
          const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
          const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
          return {
            fullSize,
            leftAndTop: left.concat(top),
            rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
            chartArea: filterByPosition(layoutBoxes, "chartArea"),
            vertical: left.concat(right).concat(centerVertical),
            horizontal: top.concat(bottom).concat(centerHorizontal)
          };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
          return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateMaxPadding(maxPadding, boxPadding) {
          maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
          maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
          maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
          maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
        }
        function updateDims(chartArea, params, layout, stacks) {
          const { pos, box } = layout;
          const maxPadding = chartArea.maxPadding;
          if (!isObject2(pos)) {
            if (layout.size) {
              chartArea[pos] -= layout.size;
            }
            const stack = stacks[layout.stack] || { size: 0, count: 1 };
            stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
            layout.size = stack.size / stack.count;
            chartArea[pos] += layout.size;
          }
          if (box.getPadding) {
            updateMaxPadding(maxPadding, box.getPadding());
          }
          const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
          const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
          const widthChanged = newWidth !== chartArea.w;
          const heightChanged = newHeight !== chartArea.h;
          chartArea.w = newWidth;
          chartArea.h = newHeight;
          return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
        }
        function handleMaxPadding(chartArea) {
          const maxPadding = chartArea.maxPadding;
          function updatePos(pos) {
            const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
          }
          chartArea.y += updatePos("top");
          chartArea.x += updatePos("left");
          updatePos("right");
          updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
          const maxPadding = chartArea.maxPadding;
          function marginForPositions(positions2) {
            const margin = { left: 0, top: 0, right: 0, bottom: 0 };
            positions2.forEach((pos) => {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
          }
          return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
        }
        function fitBoxes(boxes, chartArea, params, stacks) {
          const refitBoxes = [];
          let i, ilen, layout, box, refit, changed;
          for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
            const { same, other } = updateDims(chartArea, params, layout, stacks);
            refit |= same && refitBoxes.length;
            changed = changed || other;
            if (!box.fullSize) {
              refitBoxes.push(layout);
            }
          }
          return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
        }
        function setBoxDims(box, left, top, width, height) {
          box.top = top;
          box.left = left;
          box.right = left + width;
          box.bottom = top + height;
          box.width = width;
          box.height = height;
        }
        function placeBoxes(boxes, chartArea, params, stacks) {
          const userPadding = params.padding;
          let { x, y } = chartArea;
          for (const layout of boxes) {
            const box = layout.box;
            const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
            const weight = layout.stackWeight / stack.weight || 1;
            if (layout.horizontal) {
              const width = chartArea.w * weight;
              const height = stack.size || box.height;
              if (defined(stack.start)) {
                y = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
              } else {
                setBoxDims(box, chartArea.left + stack.placed, y, width, height);
              }
              stack.start = y;
              stack.placed += width;
              y = box.bottom;
            } else {
              const height = chartArea.h * weight;
              const width = stack.size || box.width;
              if (defined(stack.start)) {
                x = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
              } else {
                setBoxDims(box, x, chartArea.top + stack.placed, width, height);
              }
              stack.start = x;
              stack.placed += height;
              x = box.right;
            }
          }
          chartArea.x = x;
          chartArea.y = y;
        }
        defaults.set("layout", {
          autoPadding: true,
          padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }
        });
        var layouts = {
          addBox(chart2, item) {
            if (!chart2.boxes) {
              chart2.boxes = [];
            }
            item.fullSize = item.fullSize || false;
            item.position = item.position || "top";
            item.weight = item.weight || 0;
            item._layers = item._layers || function() {
              return [{
                z: 0,
                draw(chartArea) {
                  item.draw(chartArea);
                }
              }];
            };
            chart2.boxes.push(item);
          },
          removeBox(chart2, layoutItem) {
            const index3 = chart2.boxes ? chart2.boxes.indexOf(layoutItem) : -1;
            if (index3 !== -1) {
              chart2.boxes.splice(index3, 1);
            }
          },
          configure(chart2, item, options) {
            item.fullSize = options.fullSize;
            item.position = options.position;
            item.weight = options.weight;
          },
          update(chart2, width, height, minPadding) {
            if (!chart2) {
              return;
            }
            const padding = toPadding(chart2.options.layout.padding);
            const availableWidth = Math.max(width - padding.width, 0);
            const availableHeight = Math.max(height - padding.height, 0);
            const boxes = buildLayoutBoxes(chart2.boxes);
            const verticalBoxes = boxes.vertical;
            const horizontalBoxes = boxes.horizontal;
            each(chart2.boxes, (box) => {
              if (typeof box.beforeLayout === "function") {
                box.beforeLayout();
              }
            });
            const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
            const params = Object.freeze({
              outerWidth: width,
              outerHeight: height,
              padding,
              availableWidth,
              availableHeight,
              vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
              hBoxMaxHeight: availableHeight / 2
            });
            const maxPadding = Object.assign({}, padding);
            updateMaxPadding(maxPadding, toPadding(minPadding));
            const chartArea = Object.assign({
              maxPadding,
              w: availableWidth,
              h: availableHeight,
              x: padding.left,
              y: padding.top
            }, padding);
            const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
            fitBoxes(boxes.fullSize, chartArea, params, stacks);
            fitBoxes(verticalBoxes, chartArea, params, stacks);
            if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
              fitBoxes(verticalBoxes, chartArea, params, stacks);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
            chart2.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h,
              height: chartArea.h,
              width: chartArea.w
            };
            each(boxes.chartArea, (layout) => {
              const box = layout.box;
              Object.assign(box, chart2.chartArea);
              box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
            });
          }
        };
        class BasePlatform {
          acquireContext(canvas, aspectRatio) {
          }
          releaseContext(context) {
            return false;
          }
          addEventListener(chart2, type, listener) {
          }
          removeEventListener(chart2, type, listener) {
          }
          getDevicePixelRatio() {
            return 1;
          }
          getMaximumSize(element, width, height, aspectRatio) {
            width = Math.max(0, width || element.width);
            height = height || element.height;
            return {
              width,
              height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
            };
          }
          isAttached(canvas) {
            return true;
          }
          updateConfig(config) {
          }
        }
        class BasicPlatform extends BasePlatform {
          acquireContext(item) {
            return item && item.getContext && item.getContext("2d") || null;
          }
          updateConfig(config) {
            config.options.animation = false;
          }
        }
        const EXPANDO_KEY = "$chartjs";
        const EVENT_TYPES = {
          touchstart: "mousedown",
          touchmove: "mousemove",
          touchend: "mouseup",
          pointerenter: "mouseenter",
          pointerdown: "mousedown",
          pointermove: "mousemove",
          pointerup: "mouseup",
          pointerleave: "mouseout",
          pointerout: "mouseout"
        };
        const isNullOrEmpty = (value) => value === null || value === "";
        function initCanvas(canvas, aspectRatio) {
          const style = canvas.style;
          const renderHeight = canvas.getAttribute("height");
          const renderWidth = canvas.getAttribute("width");
          canvas[EXPANDO_KEY] = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width
              }
            }
          };
          style.display = style.display || "block";
          style.boxSizing = style.boxSizing || "border-box";
          if (isNullOrEmpty(renderWidth)) {
            const displayWidth = readUsedSize(canvas, "width");
            if (displayWidth !== void 0) {
              canvas.width = displayWidth;
            }
          }
          if (isNullOrEmpty(renderHeight)) {
            if (canvas.style.height === "") {
              canvas.height = canvas.width / (aspectRatio || 2);
            } else {
              const displayHeight = readUsedSize(canvas, "height");
              if (displayHeight !== void 0) {
                canvas.height = displayHeight;
              }
            }
          }
          return canvas;
        }
        const eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
        function addListener(node, type, listener) {
          node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(chart2, type, listener) {
          chart2.canvas.removeEventListener(type, listener, eventListenerOptions);
        }
        function fromNativeEvent(event, chart2) {
          const type = EVENT_TYPES[event.type] || event.type;
          const { x, y } = getRelativePosition(event, chart2);
          return {
            type,
            chart: chart2,
            native: event,
            x: x !== void 0 ? x : null,
            y: y !== void 0 ? y : null
          };
        }
        function nodeListContains(nodeList, canvas) {
          for (const node of nodeList) {
            if (node === canvas || node.contains(canvas)) {
              return true;
            }
          }
        }
        function createAttachObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.addedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, { childList: true, subtree: true });
          return observer;
        }
        function createDetachObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.removedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, { childList: true, subtree: true });
          return observer;
        }
        const drpListeningCharts = /* @__PURE__ */ new Map();
        let oldDevicePixelRatio = 0;
        function onWindowResize() {
          const dpr = window.devicePixelRatio;
          if (dpr === oldDevicePixelRatio) {
            return;
          }
          oldDevicePixelRatio = dpr;
          drpListeningCharts.forEach((resize, chart2) => {
            if (chart2.currentDevicePixelRatio !== dpr) {
              resize();
            }
          });
        }
        function listenDevicePixelRatioChanges(chart2, resize) {
          if (!drpListeningCharts.size) {
            window.addEventListener("resize", onWindowResize);
          }
          drpListeningCharts.set(chart2, resize);
        }
        function unlistenDevicePixelRatioChanges(chart2) {
          drpListeningCharts.delete(chart2);
          if (!drpListeningCharts.size) {
            window.removeEventListener("resize", onWindowResize);
          }
        }
        function createResizeObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const container = canvas && _getParentNode(canvas);
          if (!container) {
            return;
          }
          const resize = throttled((width, height) => {
            const w = container.clientWidth;
            listener(width, height);
            if (w < container.clientWidth) {
              listener();
            }
          }, window);
          const observer = new ResizeObserver((entries) => {
            const entry = entries[0];
            const width = entry.contentRect.width;
            const height = entry.contentRect.height;
            if (width === 0 && height === 0) {
              return;
            }
            resize(width, height);
          });
          observer.observe(container);
          listenDevicePixelRatioChanges(chart2, resize);
          return observer;
        }
        function releaseObserver(chart2, type, observer) {
          if (observer) {
            observer.disconnect();
          }
          if (type === "resize") {
            unlistenDevicePixelRatioChanges(chart2);
          }
        }
        function createProxyAndListen(chart2, type, listener) {
          const canvas = chart2.canvas;
          const proxy = throttled((event) => {
            if (chart2.ctx !== null) {
              listener(fromNativeEvent(event, chart2));
            }
          }, chart2, (args) => {
            const event = args[0];
            return [event, event.offsetX, event.offsetY];
          });
          addListener(canvas, type, proxy);
          return proxy;
        }
        class DomPlatform extends BasePlatform {
          acquireContext(canvas, aspectRatio) {
            const context = canvas && canvas.getContext && canvas.getContext("2d");
            if (context && context.canvas === canvas) {
              initCanvas(canvas, aspectRatio);
              return context;
            }
            return null;
          }
          releaseContext(context) {
            const canvas = context.canvas;
            if (!canvas[EXPANDO_KEY]) {
              return false;
            }
            const initial = canvas[EXPANDO_KEY].initial;
            ["height", "width"].forEach((prop) => {
              const value = initial[prop];
              if (isNullOrUndef(value)) {
                canvas.removeAttribute(prop);
              } else {
                canvas.setAttribute(prop, value);
              }
            });
            const style = initial.style || {};
            Object.keys(style).forEach((key) => {
              canvas.style[key] = style[key];
            });
            canvas.width = canvas.width;
            delete canvas[EXPANDO_KEY];
            return true;
          }
          addEventListener(chart2, type, listener) {
            this.removeEventListener(chart2, type);
            const proxies = chart2.$proxies || (chart2.$proxies = {});
            const handlers = {
              attach: createAttachObserver,
              detach: createDetachObserver,
              resize: createResizeObserver
            };
            const handler = handlers[type] || createProxyAndListen;
            proxies[type] = handler(chart2, type, listener);
          }
          removeEventListener(chart2, type) {
            const proxies = chart2.$proxies || (chart2.$proxies = {});
            const proxy = proxies[type];
            if (!proxy) {
              return;
            }
            const handlers = {
              attach: releaseObserver,
              detach: releaseObserver,
              resize: releaseObserver
            };
            const handler = handlers[type] || removeListener;
            handler(chart2, type, proxy);
            proxies[type] = void 0;
          }
          getDevicePixelRatio() {
            return window.devicePixelRatio;
          }
          getMaximumSize(canvas, width, height, aspectRatio) {
            return getMaximumSize(canvas, width, height, aspectRatio);
          }
          isAttached(canvas) {
            const container = _getParentNode(canvas);
            return !!(container && container.isConnected);
          }
        }
        function _detectPlatform(canvas) {
          if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
            return BasicPlatform;
          }
          return DomPlatform;
        }
        var platforms = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          _detectPlatform,
          BasePlatform,
          BasicPlatform,
          DomPlatform
        });
        const transparent = "transparent";
        const interpolators = {
          boolean(from2, to2, factor) {
            return factor > 0.5 ? to2 : from2;
          },
          color(from2, to2, factor) {
            const c0 = color(from2 || transparent);
            const c1 = c0.valid && color(to2 || transparent);
            return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
          },
          number(from2, to2, factor) {
            return from2 + (to2 - from2) * factor;
          }
        };
        class Animation {
          constructor(cfg, target, prop, to2) {
            const currentValue = target[prop];
            to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
            const from2 = resolve([cfg.from, currentValue, to2]);
            this._active = true;
            this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
            this._easing = effects[cfg.easing] || effects.linear;
            this._start = Math.floor(Date.now() + (cfg.delay || 0));
            this._duration = this._total = Math.floor(cfg.duration);
            this._loop = !!cfg.loop;
            this._target = target;
            this._prop = prop;
            this._from = from2;
            this._to = to2;
            this._promises = void 0;
          }
          active() {
            return this._active;
          }
          update(cfg, to2, date) {
            if (this._active) {
              this._notify(false);
              const currentValue = this._target[this._prop];
              const elapsed = date - this._start;
              const remain = this._duration - elapsed;
              this._start = date;
              this._duration = Math.floor(Math.max(remain, cfg.duration));
              this._total += elapsed;
              this._loop = !!cfg.loop;
              this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
              this._from = resolve([cfg.from, currentValue, to2]);
            }
          }
          cancel() {
            if (this._active) {
              this.tick(Date.now());
              this._active = false;
              this._notify(false);
            }
          }
          tick(date) {
            const elapsed = date - this._start;
            const duration = this._duration;
            const prop = this._prop;
            const from2 = this._from;
            const loop = this._loop;
            const to2 = this._to;
            let factor;
            this._active = from2 !== to2 && (loop || elapsed < duration);
            if (!this._active) {
              this._target[prop] = to2;
              this._notify(true);
              return;
            }
            if (elapsed < 0) {
              this._target[prop] = from2;
              return;
            }
            factor = elapsed / duration % 2;
            factor = loop && factor > 1 ? 2 - factor : factor;
            factor = this._easing(Math.min(1, Math.max(0, factor)));
            this._target[prop] = this._fn(from2, to2, factor);
          }
          wait() {
            const promises = this._promises || (this._promises = []);
            return new Promise((res, rej) => {
              promises.push({ res, rej });
            });
          }
          _notify(resolved) {
            const method = resolved ? "res" : "rej";
            const promises = this._promises || [];
            for (let i = 0; i < promises.length; i++) {
              promises[i][method]();
            }
          }
        }
        const numbers = ["x", "y", "borderWidth", "radius", "tension"];
        const colors2 = ["color", "borderColor", "backgroundColor"];
        defaults.set("animation", {
          delay: void 0,
          duration: 1e3,
          easing: "easeOutQuart",
          fn: void 0,
          from: void 0,
          loop: void 0,
          to: void 0,
          type: void 0
        });
        const animationOptions = Object.keys(defaults.animation);
        defaults.describe("animation", {
          _fallback: false,
          _indexable: false,
          _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
        });
        defaults.set("animations", {
          colors: {
            type: "color",
            properties: colors2
          },
          numbers: {
            type: "number",
            properties: numbers
          }
        });
        defaults.describe("animations", {
          _fallback: "animation"
        });
        defaults.set("transitions", {
          active: {
            animation: {
              duration: 400
            }
          },
          resize: {
            animation: {
              duration: 0
            }
          },
          show: {
            animations: {
              colors: {
                from: "transparent"
              },
              visible: {
                type: "boolean",
                duration: 0
              }
            }
          },
          hide: {
            animations: {
              colors: {
                to: "transparent"
              },
              visible: {
                type: "boolean",
                easing: "linear",
                fn: (v) => v | 0
              }
            }
          }
        });
        class Animations {
          constructor(chart2, config) {
            this._chart = chart2;
            this._properties = /* @__PURE__ */ new Map();
            this.configure(config);
          }
          configure(config) {
            if (!isObject2(config)) {
              return;
            }
            const animatedProps = this._properties;
            Object.getOwnPropertyNames(config).forEach((key) => {
              const cfg = config[key];
              if (!isObject2(cfg)) {
                return;
              }
              const resolved = {};
              for (const option of animationOptions) {
                resolved[option] = cfg[option];
              }
              (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
                if (prop === key || !animatedProps.has(prop)) {
                  animatedProps.set(prop, resolved);
                }
              });
            });
          }
          _animateOptions(target, values) {
            const newOptions = values.options;
            const options = resolveTargetOptions(target, newOptions);
            if (!options) {
              return [];
            }
            const animations = this._createAnimations(options, newOptions);
            if (newOptions.$shared) {
              awaitAll(target.options.$animations, newOptions).then(() => {
                target.options = newOptions;
              }, () => {
              });
            }
            return animations;
          }
          _createAnimations(target, values) {
            const animatedProps = this._properties;
            const animations = [];
            const running = target.$animations || (target.$animations = {});
            const props = Object.keys(values);
            const date = Date.now();
            let i;
            for (i = props.length - 1; i >= 0; --i) {
              const prop = props[i];
              if (prop.charAt(0) === "$") {
                continue;
              }
              if (prop === "options") {
                animations.push(...this._animateOptions(target, values));
                continue;
              }
              const value = values[prop];
              let animation = running[prop];
              const cfg = animatedProps.get(prop);
              if (animation) {
                if (cfg && animation.active()) {
                  animation.update(cfg, value, date);
                  continue;
                } else {
                  animation.cancel();
                }
              }
              if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
              }
              running[prop] = animation = new Animation(cfg, target, prop, value);
              animations.push(animation);
            }
            return animations;
          }
          update(target, values) {
            if (this._properties.size === 0) {
              Object.assign(target, values);
              return;
            }
            const animations = this._createAnimations(target, values);
            if (animations.length) {
              animator.add(this._chart, animations);
              return true;
            }
          }
        }
        function awaitAll(animations, properties) {
          const running = [];
          const keys = Object.keys(properties);
          for (let i = 0; i < keys.length; i++) {
            const anim = animations[keys[i]];
            if (anim && anim.active()) {
              running.push(anim.wait());
            }
          }
          return Promise.all(running);
        }
        function resolveTargetOptions(target, newOptions) {
          if (!newOptions) {
            return;
          }
          let options = target.options;
          if (!options) {
            target.options = newOptions;
            return;
          }
          if (options.$shared) {
            target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
          }
          return options;
        }
        function scaleClip(scale, allowedOverflow) {
          const opts = scale && scale.options || {};
          const reverse = opts.reverse;
          const min = opts.min === void 0 ? allowedOverflow : 0;
          const max = opts.max === void 0 ? allowedOverflow : 0;
          return {
            start: reverse ? max : min,
            end: reverse ? min : max
          };
        }
        function defaultClip(xScale, yScale, allowedOverflow) {
          if (allowedOverflow === false) {
            return false;
          }
          const x = scaleClip(xScale, allowedOverflow);
          const y = scaleClip(yScale, allowedOverflow);
          return {
            top: y.end,
            right: x.end,
            bottom: y.start,
            left: x.start
          };
        }
        function toClip(value) {
          let t, r, b, l;
          if (isObject2(value)) {
            t = value.top;
            r = value.right;
            b = value.bottom;
            l = value.left;
          } else {
            t = r = b = l = value;
          }
          return {
            top: t,
            right: r,
            bottom: b,
            left: l,
            disabled: value === false
          };
        }
        function getSortedDatasetIndices(chart2, filterVisible) {
          const keys = [];
          const metasets = chart2._getSortedDatasetMetas(filterVisible);
          let i, ilen;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            keys.push(metasets[i].index);
          }
          return keys;
        }
        function applyStack(stack, value, dsIndex, options = {}) {
          const keys = stack.keys;
          const singleMode = options.mode === "single";
          let i, ilen, datasetIndex, otherValue;
          if (value === null) {
            return;
          }
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            datasetIndex = +keys[i];
            if (datasetIndex === dsIndex) {
              if (options.all) {
                continue;
              }
              break;
            }
            otherValue = stack.values[datasetIndex];
            if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
              value += otherValue;
            }
          }
          return value;
        }
        function convertObjectDataToArray(data) {
          const keys = Object.keys(data);
          const adata = new Array(keys.length);
          let i, ilen, key;
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            adata[i] = {
              x: key,
              y: data[key]
            };
          }
          return adata;
        }
        function isStacked(scale, meta) {
          const stacked = scale && scale.options.stacked;
          return stacked || stacked === void 0 && meta.stack !== void 0;
        }
        function getStackKey(indexScale, valueScale, meta) {
          return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
        }
        function getUserBounds(scale) {
          const { min, max, minDefined, maxDefined } = scale.getUserBounds();
          return {
            min: minDefined ? min : Number.NEGATIVE_INFINITY,
            max: maxDefined ? max : Number.POSITIVE_INFINITY
          };
        }
        function getOrCreateStack(stacks, stackKey, indexValue) {
          const subStack = stacks[stackKey] || (stacks[stackKey] = {});
          return subStack[indexValue] || (subStack[indexValue] = {});
        }
        function getLastIndexInStack(stack, vScale, positive, type) {
          for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
            const value = stack[meta.index];
            if (positive && value > 0 || !positive && value < 0) {
              return meta.index;
            }
          }
          return null;
        }
        function updateStacks(controller, parsed) {
          const { chart: chart2, _cachedMeta: meta } = controller;
          const stacks = chart2._stacks || (chart2._stacks = {});
          const { iScale, vScale, index: datasetIndex } = meta;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const key = getStackKey(iScale, vScale, meta);
          const ilen = parsed.length;
          let stack;
          for (let i = 0; i < ilen; ++i) {
            const item = parsed[i];
            const { [iAxis]: index3, [vAxis]: value } = item;
            const itemStacks = item._stacks || (item._stacks = {});
            stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index3);
            stack[datasetIndex] = value;
            stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
            stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
          }
        }
        function getFirstScaleId(chart2, axis) {
          const scales2 = chart2.scales;
          return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
        }
        function createDatasetContext(parent, index3) {
          return createContext(parent, {
            active: false,
            dataset: void 0,
            datasetIndex: index3,
            index: index3,
            mode: "default",
            type: "dataset"
          });
        }
        function createDataContext(parent, index3, element) {
          return createContext(parent, {
            active: false,
            dataIndex: index3,
            parsed: void 0,
            raw: void 0,
            element,
            index: index3,
            mode: "default",
            type: "data"
          });
        }
        function clearStacks(meta, items) {
          const datasetIndex = meta.controller.index;
          const axis = meta.vScale && meta.vScale.axis;
          if (!axis) {
            return;
          }
          items = items || meta._parsed;
          for (const parsed of items) {
            const stacks = parsed._stacks;
            if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
              return;
            }
            delete stacks[axis][datasetIndex];
          }
        }
        const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
        const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
        const createStack = (canStack, meta, chart2) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart2, true), values: null };
        class DatasetController {
          constructor(chart2, datasetIndex) {
            this.chart = chart2;
            this._ctx = chart2.ctx;
            this.index = datasetIndex;
            this._cachedDataOpts = {};
            this._cachedMeta = this.getMeta();
            this._type = this._cachedMeta.type;
            this.options = void 0;
            this._parsing = false;
            this._data = void 0;
            this._objectData = void 0;
            this._sharedOptions = void 0;
            this._drawStart = void 0;
            this._drawCount = void 0;
            this.enableOptionSharing = false;
            this.supportsDecimation = false;
            this.$context = void 0;
            this._syncList = [];
            this.initialize();
          }
          initialize() {
            const meta = this._cachedMeta;
            this.configure();
            this.linkScales();
            meta._stacked = isStacked(meta.vScale, meta);
            this.addElements();
          }
          updateIndex(datasetIndex) {
            if (this.index !== datasetIndex) {
              clearStacks(this._cachedMeta);
            }
            this.index = datasetIndex;
          }
          linkScales() {
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
            const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart2, "x"));
            const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart2, "y"));
            const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart2, "r"));
            const indexAxis = meta.indexAxis;
            const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
            const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
            meta.xScale = this.getScaleForId(xid);
            meta.yScale = this.getScaleForId(yid);
            meta.rScale = this.getScaleForId(rid);
            meta.iScale = this.getScaleForId(iid);
            meta.vScale = this.getScaleForId(vid);
          }
          getDataset() {
            return this.chart.data.datasets[this.index];
          }
          getMeta() {
            return this.chart.getDatasetMeta(this.index);
          }
          getScaleForId(scaleID) {
            return this.chart.scales[scaleID];
          }
          _getOtherScale(scale) {
            const meta = this._cachedMeta;
            return scale === meta.iScale ? meta.vScale : meta.iScale;
          }
          reset() {
            this._update("reset");
          }
          _destroy() {
            const meta = this._cachedMeta;
            if (this._data) {
              unlistenArrayEvents(this._data, this);
            }
            if (meta._stacked) {
              clearStacks(meta);
            }
          }
          _dataCheck() {
            const dataset = this.getDataset();
            const data = dataset.data || (dataset.data = []);
            const _data = this._data;
            if (isObject2(data)) {
              this._data = convertObjectDataToArray(data);
            } else if (_data !== data) {
              if (_data) {
                unlistenArrayEvents(_data, this);
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
              }
              if (data && Object.isExtensible(data)) {
                listenArrayEvents(data, this);
              }
              this._syncList = [];
              this._data = data;
            }
          }
          addElements() {
            const meta = this._cachedMeta;
            this._dataCheck();
            if (this.datasetElementType) {
              meta.dataset = new this.datasetElementType();
            }
          }
          buildOrUpdateElements(resetNewElements) {
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            let stackChanged = false;
            this._dataCheck();
            const oldStacked = meta._stacked;
            meta._stacked = isStacked(meta.vScale, meta);
            if (meta.stack !== dataset.stack) {
              stackChanged = true;
              clearStacks(meta);
              meta.stack = dataset.stack;
            }
            this._resyncElements(resetNewElements);
            if (stackChanged || oldStacked !== meta._stacked) {
              updateStacks(this, meta._parsed);
            }
          }
          configure() {
            const config = this.chart.config;
            const scopeKeys = config.datasetScopeKeys(this._type);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
            this.options = config.createResolver(scopes, this.getContext());
            this._parsing = this.options.parsing;
            this._cachedDataOpts = {};
          }
          parse(start, count) {
            const { _cachedMeta: meta, _data: data } = this;
            const { iScale, _stacked } = meta;
            const iAxis = iScale.axis;
            let sorted = start === 0 && count === data.length ? true : meta._sorted;
            let prev = start > 0 && meta._parsed[start - 1];
            let i, cur, parsed;
            if (this._parsing === false) {
              meta._parsed = data;
              meta._sorted = true;
              parsed = data;
            } else {
              if (isArray(data[start])) {
                parsed = this.parseArrayData(meta, data, start, count);
              } else if (isObject2(data[start])) {
                parsed = this.parseObjectData(meta, data, start, count);
              } else {
                parsed = this.parsePrimitiveData(meta, data, start, count);
              }
              const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
              for (i = 0; i < count; ++i) {
                meta._parsed[i + start] = cur = parsed[i];
                if (sorted) {
                  if (isNotInOrderComparedToPrev()) {
                    sorted = false;
                  }
                  prev = cur;
                }
              }
              meta._sorted = sorted;
            }
            if (_stacked) {
              updateStacks(this, parsed);
            }
          }
          parsePrimitiveData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const labels = iScale.getLabels();
            const singleScale = iScale === vScale;
            const parsed = new Array(count);
            let i, ilen, index3;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index3 = i + start;
              parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index3], index3),
                [vAxis]: vScale.parse(data[index3], index3)
              };
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const parsed = new Array(count);
            let i, ilen, index3, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index3 = i + start;
              item = data[index3];
              parsed[i] = {
                x: xScale.parse(item[0], index3),
                y: yScale.parse(item[1], index3)
              };
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
            const parsed = new Array(count);
            let i, ilen, index3, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index3 = i + start;
              item = data[index3];
              parsed[i] = {
                x: xScale.parse(resolveObjectKey(item, xAxisKey), index3),
                y: yScale.parse(resolveObjectKey(item, yAxisKey), index3)
              };
            }
            return parsed;
          }
          getParsed(index3) {
            return this._cachedMeta._parsed[index3];
          }
          getDataElement(index3) {
            return this._cachedMeta.data[index3];
          }
          applyStack(scale, parsed, mode) {
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const value = parsed[scale.axis];
            const stack = {
              keys: getSortedDatasetIndices(chart2, true),
              values: parsed._stacks[scale.axis]
            };
            return applyStack(stack, value, meta.index, { mode });
          }
          updateRangeFromParsed(range2, scale, parsed, stack) {
            const parsedValue = parsed[scale.axis];
            let value = parsedValue === null ? NaN : parsedValue;
            const values = stack && parsed._stacks[scale.axis];
            if (stack && values) {
              stack.values = values;
              value = applyStack(stack, parsedValue, this._cachedMeta.index);
            }
            range2.min = Math.min(range2.min, value);
            range2.max = Math.max(range2.max, value);
          }
          getMinMax(scale, canStack) {
            const meta = this._cachedMeta;
            const _parsed = meta._parsed;
            const sorted = meta._sorted && scale === meta.iScale;
            const ilen = _parsed.length;
            const otherScale = this._getOtherScale(scale);
            const stack = createStack(canStack, meta, this.chart);
            const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
            const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
            let i, parsed;
            function _skip() {
              parsed = _parsed[i];
              const otherValue = parsed[otherScale.axis];
              return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
            }
            for (i = 0; i < ilen; ++i) {
              if (_skip()) {
                continue;
              }
              this.updateRangeFromParsed(range2, scale, parsed, stack);
              if (sorted) {
                break;
              }
            }
            if (sorted) {
              for (i = ilen - 1; i >= 0; --i) {
                if (_skip()) {
                  continue;
                }
                this.updateRangeFromParsed(range2, scale, parsed, stack);
                break;
              }
            }
            return range2;
          }
          getAllParsedValues(scale) {
            const parsed = this._cachedMeta._parsed;
            const values = [];
            let i, ilen, value;
            for (i = 0, ilen = parsed.length; i < ilen; ++i) {
              value = parsed[i][scale.axis];
              if (isNumberFinite(value)) {
                values.push(value);
              }
            }
            return values;
          }
          getMaxOverflow() {
            return false;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const vScale = meta.vScale;
            const parsed = this.getParsed(index3);
            return {
              label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
              value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
            };
          }
          _update(mode) {
            const meta = this._cachedMeta;
            this.update(mode || "default");
            meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
          }
          update(mode) {
          }
          draw() {
            const ctx = this._ctx;
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const elements2 = meta.data || [];
            const area = chart2.chartArea;
            const active = [];
            const start = this._drawStart || 0;
            const count = this._drawCount || elements2.length - start;
            const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
            let i;
            if (meta.dataset) {
              meta.dataset.draw(ctx, area, start, count);
            }
            for (i = start; i < start + count; ++i) {
              const element = elements2[i];
              if (element.hidden) {
                continue;
              }
              if (element.active && drawActiveElementsOnTop) {
                active.push(element);
              } else {
                element.draw(ctx, area);
              }
            }
            for (i = 0; i < active.length; ++i) {
              active[i].draw(ctx, area);
            }
          }
          getStyle(index3, active) {
            const mode = active ? "active" : "default";
            return index3 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index3 || 0, mode);
          }
          getContext(index3, active, mode) {
            const dataset = this.getDataset();
            let context;
            if (index3 >= 0 && index3 < this._cachedMeta.data.length) {
              const element = this._cachedMeta.data[index3];
              context = element.$context || (element.$context = createDataContext(this.getContext(), index3, element));
              context.parsed = this.getParsed(index3);
              context.raw = dataset.data[index3];
              context.index = context.dataIndex = index3;
            } else {
              context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
              context.dataset = dataset;
              context.index = context.datasetIndex = this.index;
            }
            context.active = !!active;
            context.mode = mode;
            return context;
          }
          resolveDatasetElementOptions(mode) {
            return this._resolveElementOptions(this.datasetElementType.id, mode);
          }
          resolveDataElementOptions(index3, mode) {
            return this._resolveElementOptions(this.dataElementType.id, mode, index3);
          }
          _resolveElementOptions(elementType, mode = "default", index3) {
            const active = mode === "active";
            const cache = this._cachedDataOpts;
            const cacheKey = elementType + "-" + mode;
            const cached = cache[cacheKey];
            const sharing = this.enableOptionSharing && defined(index3);
            if (cached) {
              return cloneIfNotShared(cached, sharing);
            }
            const config = this.chart.config;
            const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
            const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            const names2 = Object.keys(defaults.elements[elementType]);
            const context = () => this.getContext(index3, active);
            const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
            if (values.$shared) {
              values.$shared = sharing;
              cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
            }
            return values;
          }
          _resolveAnimations(index3, transition, active) {
            const chart2 = this.chart;
            const cache = this._cachedDataOpts;
            const cacheKey = `animation-${transition}`;
            const cached = cache[cacheKey];
            if (cached) {
              return cached;
            }
            let options;
            if (chart2.options.animation !== false) {
              const config = this.chart.config;
              const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
              const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
              options = config.createResolver(scopes, this.getContext(index3, active, transition));
            }
            const animations = new Animations(chart2, options && options.animations);
            if (options && options._cacheable) {
              cache[cacheKey] = Object.freeze(animations);
            }
            return animations;
          }
          getSharedOptions(options) {
            if (!options.$shared) {
              return;
            }
            return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
          }
          includeOptions(mode, sharedOptions) {
            return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
          }
          _getSharedOptions(start, mode) {
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const previouslySharedOptions = this._sharedOptions;
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
            return { sharedOptions, includeOptions };
          }
          updateElement(element, index3, properties, mode) {
            if (isDirectUpdateMode(mode)) {
              Object.assign(element, properties);
            } else {
              this._resolveAnimations(index3, mode).update(element, properties);
            }
          }
          updateSharedOptions(sharedOptions, mode, newOptions) {
            if (sharedOptions && !isDirectUpdateMode(mode)) {
              this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
            }
          }
          _setStyle(element, index3, mode, active) {
            element.active = active;
            const options = this.getStyle(index3, active);
            this._resolveAnimations(index3, mode, active).update(element, {
              options: !active && this.getSharedOptions(options) || options
            });
          }
          removeHoverStyle(element, datasetIndex, index3) {
            this._setStyle(element, index3, "active", false);
          }
          setHoverStyle(element, datasetIndex, index3) {
            this._setStyle(element, index3, "active", true);
          }
          _removeDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, void 0, "active", false);
            }
          }
          _setDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, void 0, "active", true);
            }
          }
          _resyncElements(resetNewElements) {
            const data = this._data;
            const elements2 = this._cachedMeta.data;
            for (const [method, arg1, arg2] of this._syncList) {
              this[method](arg1, arg2);
            }
            this._syncList = [];
            const numMeta = elements2.length;
            const numData = data.length;
            const count = Math.min(numData, numMeta);
            if (count) {
              this.parse(0, count);
            }
            if (numData > numMeta) {
              this._insertElements(numMeta, numData - numMeta, resetNewElements);
            } else if (numData < numMeta) {
              this._removeElements(numData, numMeta - numData);
            }
          }
          _insertElements(start, count, resetNewElements = true) {
            const meta = this._cachedMeta;
            const data = meta.data;
            const end = start + count;
            let i;
            const move2 = (arr) => {
              arr.length += count;
              for (i = arr.length - 1; i >= end; i--) {
                arr[i] = arr[i - count];
              }
            };
            move2(data);
            for (i = start; i < end; ++i) {
              data[i] = new this.dataElementType();
            }
            if (this._parsing) {
              move2(meta._parsed);
            }
            this.parse(start, count);
            if (resetNewElements) {
              this.updateElements(data, start, count, "reset");
            }
          }
          updateElements(element, start, count, mode) {
          }
          _removeElements(start, count) {
            const meta = this._cachedMeta;
            if (this._parsing) {
              const removed = meta._parsed.splice(start, count);
              if (meta._stacked) {
                clearStacks(meta, removed);
              }
            }
            meta.data.splice(start, count);
          }
          _sync(args) {
            if (this._parsing) {
              this._syncList.push(args);
            } else {
              const [method, arg1, arg2] = args;
              this[method](arg1, arg2);
            }
            this.chart._dataChanges.push([this.index, ...args]);
          }
          _onDataPush() {
            const count = arguments.length;
            this._sync(["_insertElements", this.getDataset().data.length - count, count]);
          }
          _onDataPop() {
            this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
          }
          _onDataShift() {
            this._sync(["_removeElements", 0, 1]);
          }
          _onDataSplice(start, count) {
            if (count) {
              this._sync(["_removeElements", start, count]);
            }
            const newCount = arguments.length - 2;
            if (newCount) {
              this._sync(["_insertElements", start, newCount]);
            }
          }
          _onDataUnshift() {
            this._sync(["_insertElements", 0, arguments.length]);
          }
        }
        DatasetController.defaults = {};
        DatasetController.prototype.datasetElementType = null;
        DatasetController.prototype.dataElementType = null;
        class Element2 {
          constructor() {
            this.x = void 0;
            this.y = void 0;
            this.active = false;
            this.options = void 0;
            this.$animations = void 0;
          }
          tooltipPosition(useFinalPosition) {
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return { x, y };
          }
          hasValue() {
            return isNumber(this.x) && isNumber(this.y);
          }
          getProps(props, final) {
            const anims = this.$animations;
            if (!final || !anims) {
              return this;
            }
            const ret = {};
            props.forEach((prop) => {
              ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
            });
            return ret;
          }
        }
        Element2.defaults = {};
        Element2.defaultRoutes = void 0;
        const formatters = {
          values(value) {
            return isArray(value) ? value : "" + value;
          },
          numeric(tickValue, index3, ticks) {
            if (tickValue === 0) {
              return "0";
            }
            const locale = this.chart.options.locale;
            let notation;
            let delta = tickValue;
            if (ticks.length > 1) {
              const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
              if (maxTick < 1e-4 || maxTick > 1e15) {
                notation = "scientific";
              }
              delta = calculateDelta(tickValue, ticks);
            }
            const logDelta = log10(Math.abs(delta));
            const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
            const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
            Object.assign(options, this.options.ticks.format);
            return formatNumber(tickValue, locale, options);
          },
          logarithmic(tickValue, index3, ticks) {
            if (tickValue === 0) {
              return "0";
            }
            const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
            if (remain === 1 || remain === 2 || remain === 5) {
              return formatters.numeric.call(this, tickValue, index3, ticks);
            }
            return "";
          }
        };
        function calculateDelta(tickValue, ticks) {
          let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
          if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
            delta = tickValue - Math.floor(tickValue);
          }
          return delta;
        }
        var Ticks = { formatters };
        defaults.set("scale", {
          display: true,
          offset: false,
          reverse: false,
          beginAtZero: false,
          bounds: "ticks",
          grace: 0,
          grid: {
            display: true,
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options) => options.lineWidth,
            tickColor: (_ctx, options) => options.color,
            offset: false,
            borderDash: [],
            borderDashOffset: 0,
            borderWidth: 1
          },
          title: {
            display: false,
            text: "",
            padding: {
              top: 4,
              bottom: 4
            }
          },
          ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: false,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
          }
        });
        defaults.route("scale.ticks", "color", "", "color");
        defaults.route("scale.grid", "color", "", "borderColor");
        defaults.route("scale.grid", "borderColor", "", "borderColor");
        defaults.route("scale.title", "color", "", "color");
        defaults.describe("scale", {
          _fallback: false,
          _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
          _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
        });
        defaults.describe("scales", {
          _fallback: "scale"
        });
        defaults.describe("scale.ticks", {
          _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
          _indexable: (name) => name !== "backdropPadding"
        });
        function autoSkip(scale, ticks) {
          const tickOpts = scale.options.ticks;
          const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
          const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
          const numMajorIndices = majorIndices.length;
          const first = majorIndices[0];
          const last = majorIndices[numMajorIndices - 1];
          const newTicks = [];
          if (numMajorIndices > ticksLimit) {
            skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
            return newTicks;
          }
          const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
          if (numMajorIndices > 0) {
            let i, ilen;
            const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
            skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
            for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
              skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
            }
            skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
            return newTicks;
          }
          skip(ticks, newTicks, spacing);
          return newTicks;
        }
        function determineMaxTicks(scale) {
          const offset = scale.options.offset;
          const tickLength = scale._tickSize();
          const maxScale = scale._length / tickLength + (offset ? 0 : 1);
          const maxChart = scale._maxLength / tickLength;
          return Math.floor(Math.min(maxScale, maxChart));
        }
        function calculateSpacing(majorIndices, ticks, ticksLimit) {
          const evenMajorSpacing = getEvenSpacing(majorIndices);
          const spacing = ticks.length / ticksLimit;
          if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
          }
          const factors = _factorize(evenMajorSpacing);
          for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
            const factor = factors[i];
            if (factor > spacing) {
              return factor;
            }
          }
          return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
          const result = [];
          let i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (ticks[i].major) {
              result.push(i);
            }
          }
          return result;
        }
        function skipMajors(ticks, newTicks, majorIndices, spacing) {
          let count = 0;
          let next = majorIndices[0];
          let i;
          spacing = Math.ceil(spacing);
          for (i = 0; i < ticks.length; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = majorIndices[count * spacing];
            }
          }
        }
        function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
          const start = valueOrDefault(majorStart, 0);
          const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
          let count = 0;
          let length, i, next;
          spacing = Math.ceil(spacing);
          if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
          }
          next = start;
          while (next < 0) {
            count++;
            next = Math.round(start + count * spacing);
          }
          for (i = Math.max(start, 0); i < end; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = Math.round(start + count * spacing);
            }
          }
        }
        function getEvenSpacing(arr) {
          const len = arr.length;
          let i, diff;
          if (len < 2) {
            return false;
          }
          for (diff = arr[0], i = 1; i < len; ++i) {
            if (arr[i] - arr[i - 1] !== diff) {
              return false;
            }
          }
          return diff;
        }
        const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
        const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
        function sample(arr, numItems) {
          const result = [];
          const increment = arr.length / numItems;
          const len = arr.length;
          let i = 0;
          for (; i < len; i += increment) {
            result.push(arr[Math.floor(i)]);
          }
          return result;
        }
        function getPixelForGridLine(scale, index3, offsetGridLines) {
          const length = scale.ticks.length;
          const validIndex2 = Math.min(index3, length - 1);
          const start = scale._startPixel;
          const end = scale._endPixel;
          const epsilon = 1e-6;
          let lineValue = scale.getPixelForTick(validIndex2);
          let offset;
          if (offsetGridLines) {
            if (length === 1) {
              offset = Math.max(lineValue - start, end - lineValue);
            } else if (index3 === 0) {
              offset = (scale.getPixelForTick(1) - lineValue) / 2;
            } else {
              offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
            }
            lineValue += validIndex2 < index3 ? offset : -offset;
            if (lineValue < start - epsilon || lineValue > end + epsilon) {
              return;
            }
          }
          return lineValue;
        }
        function garbageCollect(caches, length) {
          each(caches, (cache) => {
            const gc = cache.gc;
            const gcLen = gc.length / 2;
            let i;
            if (gcLen > length) {
              for (i = 0; i < gcLen; ++i) {
                delete cache.data[gc[i]];
              }
              gc.splice(0, gcLen);
            }
          });
        }
        function getTickMarkLength(options) {
          return options.drawTicks ? options.tickLength : 0;
        }
        function getTitleHeight(options, fallback) {
          if (!options.display) {
            return 0;
          }
          const font = toFont(options.font, fallback);
          const padding = toPadding(options.padding);
          const lines = isArray(options.text) ? options.text.length : 1;
          return lines * font.lineHeight + padding.height;
        }
        function createScaleContext(parent, scale) {
          return createContext(parent, {
            scale,
            type: "scale"
          });
        }
        function createTickContext(parent, index3, tick) {
          return createContext(parent, {
            tick,
            index: index3,
            type: "tick"
          });
        }
        function titleAlign(align, position, reverse) {
          let ret = _toLeftRightCenter(align);
          if (reverse && position !== "right" || !reverse && position === "right") {
            ret = reverseAlign(ret);
          }
          return ret;
        }
        function titleArgs(scale, offset, position, align) {
          const { top, left, bottom, right, chart: chart2 } = scale;
          const { chartArea, scales: scales2 } = chart2;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          const height = bottom - top;
          const width = right - left;
          if (scale.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
            } else if (position === "center") {
              titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
            } else {
              titleY = offsetFromEdge(scale, position, offset);
            }
            maxWidth = right - left;
          } else {
            if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
            } else if (position === "center") {
              titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
            } else {
              titleX = offsetFromEdge(scale, position, offset);
            }
            titleY = _alignStartEnd(align, bottom, top);
            rotation = position === "left" ? -HALF_PI : HALF_PI;
          }
          return { titleX, titleY, maxWidth, rotation };
        }
        class Scale extends Element2 {
          constructor(cfg) {
            super();
            this.id = cfg.id;
            this.type = cfg.type;
            this.options = void 0;
            this.ctx = cfg.ctx;
            this.chart = cfg.chart;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this._margins = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            };
            this.maxWidth = void 0;
            this.maxHeight = void 0;
            this.paddingTop = void 0;
            this.paddingBottom = void 0;
            this.paddingLeft = void 0;
            this.paddingRight = void 0;
            this.axis = void 0;
            this.labelRotation = void 0;
            this.min = void 0;
            this.max = void 0;
            this._range = void 0;
            this.ticks = [];
            this._gridLineItems = null;
            this._labelItems = null;
            this._labelSizes = null;
            this._length = 0;
            this._maxLength = 0;
            this._longestTextCache = {};
            this._startPixel = void 0;
            this._endPixel = void 0;
            this._reversePixels = false;
            this._userMax = void 0;
            this._userMin = void 0;
            this._suggestedMax = void 0;
            this._suggestedMin = void 0;
            this._ticksLength = 0;
            this._borderValue = 0;
            this._cache = {};
            this._dataLimitsCached = false;
            this.$context = void 0;
          }
          init(options) {
            this.options = options.setContext(this.getContext());
            this.axis = options.axis;
            this._userMin = this.parse(options.min);
            this._userMax = this.parse(options.max);
            this._suggestedMin = this.parse(options.suggestedMin);
            this._suggestedMax = this.parse(options.suggestedMax);
          }
          parse(raw, index3) {
            return raw;
          }
          getUserBounds() {
            let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
            _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
            _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
            _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
            _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
            return {
              min: finiteOrDefault(_userMin, _suggestedMin),
              max: finiteOrDefault(_userMax, _suggestedMax),
              minDefined: isNumberFinite(_userMin),
              maxDefined: isNumberFinite(_userMax)
            };
          }
          getMinMax(canStack) {
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            let range2;
            if (minDefined && maxDefined) {
              return { min, max };
            }
            const metas = this.getMatchingVisibleMetas();
            for (let i = 0, ilen = metas.length; i < ilen; ++i) {
              range2 = metas[i].controller.getMinMax(this, canStack);
              if (!minDefined) {
                min = Math.min(min, range2.min);
              }
              if (!maxDefined) {
                max = Math.max(max, range2.max);
              }
            }
            min = maxDefined && min > max ? max : min;
            max = minDefined && min > max ? min : max;
            return {
              min: finiteOrDefault(min, finiteOrDefault(max, min)),
              max: finiteOrDefault(max, finiteOrDefault(min, max))
            };
          }
          getPadding() {
            return {
              left: this.paddingLeft || 0,
              top: this.paddingTop || 0,
              right: this.paddingRight || 0,
              bottom: this.paddingBottom || 0
            };
          }
          getTicks() {
            return this.ticks;
          }
          getLabels() {
            const data = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
          }
          beforeLayout() {
            this._cache = {};
            this._dataLimitsCached = false;
          }
          beforeUpdate() {
            callback(this.options.beforeUpdate, [this]);
          }
          update(maxWidth, maxHeight, margins) {
            const { beginAtZero, grace, ticks: tickOpts } = this.options;
            const sampleSize = tickOpts.sampleSize;
            this.beforeUpdate();
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins = Object.assign({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }, margins);
            this.ticks = null;
            this._labelSizes = null;
            this._gridLineItems = null;
            this._labelItems = null;
            this.beforeSetDimensions();
            this.setDimensions();
            this.afterSetDimensions();
            this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
            if (!this._dataLimitsCached) {
              this.beforeDataLimits();
              this.determineDataLimits();
              this.afterDataLimits();
              this._range = _addGrace(this, grace, beginAtZero);
              this._dataLimitsCached = true;
            }
            this.beforeBuildTicks();
            this.ticks = this.buildTicks() || [];
            this.afterBuildTicks();
            const samplingEnabled = sampleSize < this.ticks.length;
            this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
            this.configure();
            this.beforeCalculateLabelRotation();
            this.calculateLabelRotation();
            this.afterCalculateLabelRotation();
            if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
              this.ticks = autoSkip(this, this.ticks);
              this._labelSizes = null;
              this.afterAutoSkip();
            }
            if (samplingEnabled) {
              this._convertTicksToLabels(this.ticks);
            }
            this.beforeFit();
            this.fit();
            this.afterFit();
            this.afterUpdate();
          }
          configure() {
            let reversePixels = this.options.reverse;
            let startPixel, endPixel;
            if (this.isHorizontal()) {
              startPixel = this.left;
              endPixel = this.right;
            } else {
              startPixel = this.top;
              endPixel = this.bottom;
              reversePixels = !reversePixels;
            }
            this._startPixel = startPixel;
            this._endPixel = endPixel;
            this._reversePixels = reversePixels;
            this._length = endPixel - startPixel;
            this._alignToPixels = this.options.alignToPixels;
          }
          afterUpdate() {
            callback(this.options.afterUpdate, [this]);
          }
          beforeSetDimensions() {
            callback(this.options.beforeSetDimensions, [this]);
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = 0;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = 0;
              this.bottom = this.height;
            }
            this.paddingLeft = 0;
            this.paddingTop = 0;
            this.paddingRight = 0;
            this.paddingBottom = 0;
          }
          afterSetDimensions() {
            callback(this.options.afterSetDimensions, [this]);
          }
          _callHooks(name) {
            this.chart.notifyPlugins(name, this.getContext());
            callback(this.options[name], [this]);
          }
          beforeDataLimits() {
            this._callHooks("beforeDataLimits");
          }
          determineDataLimits() {
          }
          afterDataLimits() {
            this._callHooks("afterDataLimits");
          }
          beforeBuildTicks() {
            this._callHooks("beforeBuildTicks");
          }
          buildTicks() {
            return [];
          }
          afterBuildTicks() {
            this._callHooks("afterBuildTicks");
          }
          beforeTickToLabelConversion() {
            callback(this.options.beforeTickToLabelConversion, [this]);
          }
          generateTickLabels(ticks) {
            const tickOpts = this.options.ticks;
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              tick = ticks[i];
              tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
            }
          }
          afterTickToLabelConversion() {
            callback(this.options.afterTickToLabelConversion, [this]);
          }
          beforeCalculateLabelRotation() {
            callback(this.options.beforeCalculateLabelRotation, [this]);
          }
          calculateLabelRotation() {
            const options = this.options;
            const tickOpts = options.ticks;
            const numTicks = this.ticks.length;
            const minRotation = tickOpts.minRotation || 0;
            const maxRotation = tickOpts.maxRotation;
            let labelRotation = minRotation;
            let tickWidth, maxHeight, maxLabelDiagonal;
            if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
              this.labelRotation = minRotation;
              return;
            }
            const labelSizes = this._getLabelSizes();
            const maxLabelWidth = labelSizes.widest.width;
            const maxLabelHeight = labelSizes.highest.height;
            const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
            tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
              maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
              maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
              labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
              labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
            }
            this.labelRotation = labelRotation;
          }
          afterCalculateLabelRotation() {
            callback(this.options.afterCalculateLabelRotation, [this]);
          }
          afterAutoSkip() {
          }
          beforeFit() {
            callback(this.options.beforeFit, [this]);
          }
          fit() {
            const minSize = {
              width: 0,
              height: 0
            };
            const { chart: chart2, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
            const display = this._isVisible();
            const isHorizontal = this.isHorizontal();
            if (display) {
              const titleHeight = getTitleHeight(titleOpts, chart2.options.font);
              if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
              } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
              }
              if (tickOpts.display && this.ticks.length) {
                const { first, last, widest, highest } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = toRadians(this.labelRotation);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                  const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                  minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                } else {
                  const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                  minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                }
                this._calculatePadding(first, last, sin, cos);
              }
            }
            this._handleMargins();
            if (isHorizontal) {
              this.width = this._length = chart2.width - this._margins.left - this._margins.right;
              this.height = minSize.height;
            } else {
              this.width = minSize.width;
              this.height = this._length = chart2.height - this._margins.top - this._margins.bottom;
            }
          }
          _calculatePadding(first, last, sin, cos) {
            const { ticks: { align, padding }, position } = this.options;
            const isRotated = this.labelRotation !== 0;
            const labelsBelowTicks = position !== "top" && this.axis === "x";
            if (this.isHorizontal()) {
              const offsetLeft = this.getPixelForTick(0) - this.left;
              const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
              let paddingLeft = 0;
              let paddingRight = 0;
              if (isRotated) {
                if (labelsBelowTicks) {
                  paddingLeft = cos * first.width;
                  paddingRight = sin * last.height;
                } else {
                  paddingLeft = sin * first.height;
                  paddingRight = cos * last.width;
                }
              } else if (align === "start") {
                paddingRight = last.width;
              } else if (align === "end") {
                paddingLeft = first.width;
              } else if (align !== "inner") {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
              }
              this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
              this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
            } else {
              let paddingTop = last.height / 2;
              let paddingBottom = first.height / 2;
              if (align === "start") {
                paddingTop = 0;
                paddingBottom = first.height;
              } else if (align === "end") {
                paddingTop = last.height;
                paddingBottom = 0;
              }
              this.paddingTop = paddingTop + padding;
              this.paddingBottom = paddingBottom + padding;
            }
          }
          _handleMargins() {
            if (this._margins) {
              this._margins.left = Math.max(this.paddingLeft, this._margins.left);
              this._margins.top = Math.max(this.paddingTop, this._margins.top);
              this._margins.right = Math.max(this.paddingRight, this._margins.right);
              this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
            }
          }
          afterFit() {
            callback(this.options.afterFit, [this]);
          }
          isHorizontal() {
            const { axis, position } = this.options;
            return position === "top" || position === "bottom" || axis === "x";
          }
          isFullSize() {
            return this.options.fullSize;
          }
          _convertTicksToLabels(ticks) {
            this.beforeTickToLabelConversion();
            this.generateTickLabels(ticks);
            let i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              if (isNullOrUndef(ticks[i].label)) {
                ticks.splice(i, 1);
                ilen--;
                i--;
              }
            }
            this.afterTickToLabelConversion();
          }
          _getLabelSizes() {
            let labelSizes = this._labelSizes;
            if (!labelSizes) {
              const sampleSize = this.options.ticks.sampleSize;
              let ticks = this.ticks;
              if (sampleSize < ticks.length) {
                ticks = sample(ticks, sampleSize);
              }
              this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
            }
            return labelSizes;
          }
          _computeLabelSizes(ticks, length) {
            const { ctx, _longestTextCache: caches } = this;
            const widths = [];
            const heights = [];
            let widestLabelSize = 0;
            let highestLabelSize = 0;
            let i, j, jlen, label, tickFont, fontString2, cache, lineHeight, width, height, nestedLabel;
            for (i = 0; i < length; ++i) {
              label = ticks[i].label;
              tickFont = this._resolveTickFontOptions(i);
              ctx.font = fontString2 = tickFont.string;
              cache = caches[fontString2] = caches[fontString2] || { data: {}, gc: [] };
              lineHeight = tickFont.lineHeight;
              width = height = 0;
              if (!isNullOrUndef(label) && !isArray(label)) {
                width = _measureText(ctx, cache.data, cache.gc, width, label);
                height = lineHeight;
              } else if (isArray(label)) {
                for (j = 0, jlen = label.length; j < jlen; ++j) {
                  nestedLabel = label[j];
                  if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                    width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                    height += lineHeight;
                  }
                }
              }
              widths.push(width);
              heights.push(height);
              widestLabelSize = Math.max(width, widestLabelSize);
              highestLabelSize = Math.max(height, highestLabelSize);
            }
            garbageCollect(caches, length);
            const widest = widths.indexOf(widestLabelSize);
            const highest = heights.indexOf(highestLabelSize);
            const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
            return {
              first: valueAt(0),
              last: valueAt(length - 1),
              widest: valueAt(widest),
              highest: valueAt(highest),
              widths,
              heights
            };
          }
          getLabelForValue(value) {
            return value;
          }
          getPixelForValue(value, index3) {
            return NaN;
          }
          getValueForPixel(pixel) {
          }
          getPixelForTick(index3) {
            const ticks = this.ticks;
            if (index3 < 0 || index3 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index3].value);
          }
          getPixelForDecimal(decimal) {
            if (this._reversePixels) {
              decimal = 1 - decimal;
            }
            const pixel = this._startPixel + decimal * this._length;
            return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
          }
          getDecimalForPixel(pixel) {
            const decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
          }
          getBasePixel() {
            return this.getPixelForValue(this.getBaseValue());
          }
          getBaseValue() {
            const { min, max } = this;
            return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
          }
          getContext(index3) {
            const ticks = this.ticks || [];
            if (index3 >= 0 && index3 < ticks.length) {
              const tick = ticks[index3];
              return tick.$context || (tick.$context = createTickContext(this.getContext(), index3, tick));
            }
            return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
          }
          _tickSize() {
            const optionTicks = this.options.ticks;
            const rot = toRadians(this.labelRotation);
            const cos = Math.abs(Math.cos(rot));
            const sin = Math.abs(Math.sin(rot));
            const labelSizes = this._getLabelSizes();
            const padding = optionTicks.autoSkipPadding || 0;
            const w = labelSizes ? labelSizes.widest.width + padding : 0;
            const h = labelSizes ? labelSizes.highest.height + padding : 0;
            return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
          }
          _isVisible() {
            const display = this.options.display;
            if (display !== "auto") {
              return !!display;
            }
            return this.getMatchingVisibleMetas().length > 0;
          }
          _computeGridLineItems(chartArea) {
            const axis = this.axis;
            const chart2 = this.chart;
            const options = this.options;
            const { grid, position } = options;
            const offset = grid.offset;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const ticksLength = ticks.length + (offset ? 1 : 0);
            const tl = getTickMarkLength(grid);
            const items = [];
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
            const axisHalfWidth = axisWidth / 2;
            const alignBorderValue = function(pixel) {
              return _alignPixel(chart2, pixel, axisWidth);
            };
            let borderValue, i, lineValue, alignedLineValue;
            let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
            if (position === "top") {
              borderValue = alignBorderValue(this.bottom);
              ty1 = this.bottom - tl;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
            } else if (position === "bottom") {
              borderValue = alignBorderValue(this.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = this.top + tl;
            } else if (position === "left") {
              borderValue = alignBorderValue(this.right);
              tx1 = this.right - tl;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
            } else if (position === "right") {
              borderValue = alignBorderValue(this.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = this.left + tl;
            } else if (axis === "x") {
              if (position === "center") {
                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              y1 = chartArea.top;
              y2 = chartArea.bottom;
              ty1 = borderValue + axisHalfWidth;
              ty2 = ty1 + tl;
            } else if (axis === "y") {
              if (position === "center") {
                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              tx1 = borderValue - axisHalfWidth;
              tx2 = tx1 - tl;
              x1 = chartArea.left;
              x2 = chartArea.right;
            }
            const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
            const step = Math.max(1, Math.ceil(ticksLength / limit));
            for (i = 0; i < ticksLength; i += step) {
              const optsAtIndex = grid.setContext(this.getContext(i));
              const lineWidth = optsAtIndex.lineWidth;
              const lineColor = optsAtIndex.color;
              const borderDash = optsAtIndex.borderDash || [];
              const borderDashOffset = optsAtIndex.borderDashOffset;
              const tickWidth = optsAtIndex.tickWidth;
              const tickColor = optsAtIndex.tickColor;
              const tickBorderDash = optsAtIndex.tickBorderDash || [];
              const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
              lineValue = getPixelForGridLine(this, i, offset);
              if (lineValue === void 0) {
                continue;
              }
              alignedLineValue = _alignPixel(chart2, lineValue, lineWidth);
              if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset
              });
            }
            this._ticksLength = ticksLength;
            this._borderValue = borderValue;
            return items;
          }
          _computeLabelItems(chartArea) {
            const axis = this.axis;
            const options = this.options;
            const { position, ticks: optionTicks } = options;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const { align, crossAlign, padding, mirror } = optionTicks;
            const tl = getTickMarkLength(options.grid);
            const tickAndPadding = tl + padding;
            const hTickAndPadding = mirror ? -padding : tickAndPadding;
            const rotation = -toRadians(this.labelRotation);
            const items = [];
            let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
            let textBaseline = "middle";
            if (position === "top") {
              y = this.bottom - hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === "bottom") {
              y = this.top + hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === "left") {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (position === "right") {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (axis === "x") {
              if (position === "center") {
                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
              }
              textAlign = this._getXAxisLabelAlignment();
            } else if (axis === "y") {
              if (position === "center") {
                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x = this.chart.scales[positionAxisID].getPixelForValue(value);
              }
              textAlign = this._getYAxisLabelAlignment(tl).textAlign;
            }
            if (axis === "y") {
              if (align === "start") {
                textBaseline = "top";
              } else if (align === "end") {
                textBaseline = "bottom";
              }
            }
            const labelSizes = this._getLabelSizes();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              label = tick.label;
              const optsAtIndex = optionTicks.setContext(this.getContext(i));
              pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
              font = this._resolveTickFontOptions(i);
              lineHeight = font.lineHeight;
              lineCount = isArray(label) ? label.length : 1;
              const halfCount = lineCount / 2;
              const color2 = optsAtIndex.color;
              const strokeColor = optsAtIndex.textStrokeColor;
              const strokeWidth = optsAtIndex.textStrokeWidth;
              let tickTextAlign = textAlign;
              if (isHorizontal) {
                x = pixel;
                if (textAlign === "inner") {
                  if (i === ilen - 1) {
                    tickTextAlign = !this.options.reverse ? "right" : "left";
                  } else if (i === 0) {
                    tickTextAlign = !this.options.reverse ? "left" : "right";
                  } else {
                    tickTextAlign = "center";
                  }
                }
                if (position === "top") {
                  if (crossAlign === "near" || rotation !== 0) {
                    textOffset = -lineCount * lineHeight + lineHeight / 2;
                  } else if (crossAlign === "center") {
                    textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                  } else {
                    textOffset = -labelSizes.highest.height + lineHeight / 2;
                  }
                } else {
                  if (crossAlign === "near" || rotation !== 0) {
                    textOffset = lineHeight / 2;
                  } else if (crossAlign === "center") {
                    textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                  } else {
                    textOffset = labelSizes.highest.height - lineCount * lineHeight;
                  }
                }
                if (mirror) {
                  textOffset *= -1;
                }
              } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
              }
              let backdrop;
              if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = toPadding(optsAtIndex.backdropPadding);
                const height = labelSizes.heights[i];
                const width = labelSizes.widths[i];
                let top = y + textOffset - labelPadding.top;
                let left = x - labelPadding.left;
                switch (textBaseline) {
                  case "middle":
                    top -= height / 2;
                    break;
                  case "bottom":
                    top -= height;
                    break;
                }
                switch (textAlign) {
                  case "center":
                    left -= width / 2;
                    break;
                  case "right":
                    left -= width;
                    break;
                }
                backdrop = {
                  left,
                  top,
                  width: width + labelPadding.width,
                  height: height + labelPadding.height,
                  color: optsAtIndex.backdropColor
                };
              }
              items.push({
                rotation,
                label,
                font,
                color: color2,
                strokeColor,
                strokeWidth,
                textOffset,
                textAlign: tickTextAlign,
                textBaseline,
                translation: [x, y],
                backdrop
              });
            }
            return items;
          }
          _getXAxisLabelAlignment() {
            const { position, ticks } = this.options;
            const rotation = -toRadians(this.labelRotation);
            if (rotation) {
              return position === "top" ? "left" : "right";
            }
            let align = "center";
            if (ticks.align === "start") {
              align = "left";
            } else if (ticks.align === "end") {
              align = "right";
            } else if (ticks.align === "inner") {
              align = "inner";
            }
            return align;
          }
          _getYAxisLabelAlignment(tl) {
            const { position, ticks: { crossAlign, mirror, padding } } = this.options;
            const labelSizes = this._getLabelSizes();
            const tickAndPadding = tl + padding;
            const widest = labelSizes.widest.width;
            let textAlign;
            let x;
            if (position === "left") {
              if (mirror) {
                x = this.right + padding;
                if (crossAlign === "near") {
                  textAlign = "left";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x += widest / 2;
                } else {
                  textAlign = "right";
                  x += widest;
                }
              } else {
                x = this.right - tickAndPadding;
                if (crossAlign === "near") {
                  textAlign = "right";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x -= widest / 2;
                } else {
                  textAlign = "left";
                  x = this.left;
                }
              }
            } else if (position === "right") {
              if (mirror) {
                x = this.left + padding;
                if (crossAlign === "near") {
                  textAlign = "right";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x -= widest / 2;
                } else {
                  textAlign = "left";
                  x -= widest;
                }
              } else {
                x = this.left + tickAndPadding;
                if (crossAlign === "near") {
                  textAlign = "left";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x += widest / 2;
                } else {
                  textAlign = "right";
                  x = this.right;
                }
              }
            } else {
              textAlign = "right";
            }
            return { textAlign, x };
          }
          _computeLabelArea() {
            if (this.options.ticks.mirror) {
              return;
            }
            const chart2 = this.chart;
            const position = this.options.position;
            if (position === "left" || position === "right") {
              return { top: 0, left: this.left, bottom: chart2.height, right: this.right };
            }
            if (position === "top" || position === "bottom") {
              return { top: this.top, left: 0, bottom: this.bottom, right: chart2.width };
            }
          }
          drawBackground() {
            const { ctx, options: { backgroundColor }, left, top, width, height } = this;
            if (backgroundColor) {
              ctx.save();
              ctx.fillStyle = backgroundColor;
              ctx.fillRect(left, top, width, height);
              ctx.restore();
            }
          }
          getLineWidthForValue(value) {
            const grid = this.options.grid;
            if (!this._isVisible() || !grid.display) {
              return 0;
            }
            const ticks = this.ticks;
            const index3 = ticks.findIndex((t) => t.value === value);
            if (index3 >= 0) {
              const opts = grid.setContext(this.getContext(index3));
              return opts.lineWidth;
            }
            return 0;
          }
          drawGrid(chartArea) {
            const grid = this.options.grid;
            const ctx = this.ctx;
            const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
            let i, ilen;
            const drawLine = (p1, p2, style) => {
              if (!style.width || !style.color) {
                return;
              }
              ctx.save();
              ctx.lineWidth = style.width;
              ctx.strokeStyle = style.color;
              ctx.setLineDash(style.borderDash || []);
              ctx.lineDashOffset = style.borderDashOffset;
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
              ctx.restore();
            };
            if (grid.display) {
              for (i = 0, ilen = items.length; i < ilen; ++i) {
                const item = items[i];
                if (grid.drawOnChartArea) {
                  drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
                }
                if (grid.drawTicks) {
                  drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
                    color: item.tickColor,
                    width: item.tickWidth,
                    borderDash: item.tickBorderDash,
                    borderDashOffset: item.tickBorderDashOffset
                  });
                }
              }
            }
          }
          drawBorder() {
            const { chart: chart2, ctx, options: { grid } } = this;
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
            if (!axisWidth) {
              return;
            }
            const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
            const borderValue = this._borderValue;
            let x1, x2, y1, y2;
            if (this.isHorizontal()) {
              x1 = _alignPixel(chart2, this.left, axisWidth) - axisWidth / 2;
              x2 = _alignPixel(chart2, this.right, lastLineWidth) + lastLineWidth / 2;
              y1 = y2 = borderValue;
            } else {
              y1 = _alignPixel(chart2, this.top, axisWidth) - axisWidth / 2;
              y2 = _alignPixel(chart2, this.bottom, lastLineWidth) + lastLineWidth / 2;
              x1 = x2 = borderValue;
            }
            ctx.save();
            ctx.lineWidth = borderOpts.borderWidth;
            ctx.strokeStyle = borderOpts.borderColor;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
          }
          drawLabels(chartArea) {
            const optionTicks = this.options.ticks;
            if (!optionTicks.display) {
              return;
            }
            const ctx = this.ctx;
            const area = this._computeLabelArea();
            if (area) {
              clipArea(ctx, area);
            }
            const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
            let i, ilen;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              const item = items[i];
              const tickFont = item.font;
              const label = item.label;
              if (item.backdrop) {
                ctx.fillStyle = item.backdrop.color;
                ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
              }
              let y = item.textOffset;
              renderText(ctx, label, 0, y, tickFont, item);
            }
            if (area) {
              unclipArea(ctx);
            }
          }
          drawTitle() {
            const { ctx, options: { position, title, reverse } } = this;
            if (!title.display) {
              return;
            }
            const font = toFont(title.font);
            const padding = toPadding(title.padding);
            const align = title.align;
            let offset = font.lineHeight / 2;
            if (position === "bottom" || position === "center" || isObject2(position)) {
              offset += padding.bottom;
              if (isArray(title.text)) {
                offset += font.lineHeight * (title.text.length - 1);
              }
            } else {
              offset += padding.top;
            }
            const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
            renderText(ctx, title.text, 0, 0, font, {
              color: title.color,
              maxWidth,
              rotation,
              textAlign: titleAlign(align, position, reverse),
              textBaseline: "middle",
              translation: [titleX, titleY]
            });
          }
          draw(chartArea) {
            if (!this._isVisible()) {
              return;
            }
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawBorder();
            this.drawTitle();
            this.drawLabels(chartArea);
          }
          _layers() {
            const opts = this.options;
            const tz = opts.ticks && opts.ticks.z || 0;
            const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
            if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
              return [{
                z: tz,
                draw: (chartArea) => {
                  this.draw(chartArea);
                }
              }];
            }
            return [{
              z: gz,
              draw: (chartArea) => {
                this.drawBackground();
                this.drawGrid(chartArea);
                this.drawTitle();
              }
            }, {
              z: gz + 1,
              draw: () => {
                this.drawBorder();
              }
            }, {
              z: tz,
              draw: (chartArea) => {
                this.drawLabels(chartArea);
              }
            }];
          }
          getMatchingVisibleMetas(type) {
            const metas = this.chart.getSortedVisibleDatasetMetas();
            const axisID = this.axis + "AxisID";
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              const meta = metas[i];
              if (meta[axisID] === this.id && (!type || meta.type === type)) {
                result.push(meta);
              }
            }
            return result;
          }
          _resolveTickFontOptions(index3) {
            const opts = this.options.ticks.setContext(this.getContext(index3));
            return toFont(opts.font);
          }
          _maxDigits() {
            const fontSize = this._resolveTickFontOptions(0).lineHeight;
            return (this.isHorizontal() ? this.width : this.height) / fontSize;
          }
        }
        class TypedRegistry {
          constructor(type, scope, override) {
            this.type = type;
            this.scope = scope;
            this.override = override;
            this.items = Object.create(null);
          }
          isForType(type) {
            return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
          }
          register(item) {
            const proto = Object.getPrototypeOf(item);
            let parentScope;
            if (isIChartComponent(proto)) {
              parentScope = this.register(proto);
            }
            const items = this.items;
            const id = item.id;
            const scope = this.scope + "." + id;
            if (!id) {
              throw new Error("class does not have id: " + item);
            }
            if (id in items) {
              return scope;
            }
            items[id] = item;
            registerDefaults(item, scope, parentScope);
            if (this.override) {
              defaults.override(item.id, item.overrides);
            }
            return scope;
          }
          get(id) {
            return this.items[id];
          }
          unregister(item) {
            const items = this.items;
            const id = item.id;
            const scope = this.scope;
            if (id in items) {
              delete items[id];
            }
            if (scope && id in defaults[scope]) {
              delete defaults[scope][id];
              if (this.override) {
                delete overrides[id];
              }
            }
          }
        }
        function registerDefaults(item, scope, parentScope) {
          const itemDefaults = merge(Object.create(null), [
            parentScope ? defaults.get(parentScope) : {},
            defaults.get(scope),
            item.defaults
          ]);
          defaults.set(scope, itemDefaults);
          if (item.defaultRoutes) {
            routeDefaults(scope, item.defaultRoutes);
          }
          if (item.descriptors) {
            defaults.describe(scope, item.descriptors);
          }
        }
        function routeDefaults(scope, routes) {
          Object.keys(routes).forEach((property) => {
            const propertyParts = property.split(".");
            const sourceName = propertyParts.pop();
            const sourceScope = [scope].concat(propertyParts).join(".");
            const parts = routes[property].split(".");
            const targetName = parts.pop();
            const targetScope = parts.join(".");
            defaults.route(sourceScope, sourceName, targetScope, targetName);
          });
        }
        function isIChartComponent(proto) {
          return "id" in proto && "defaults" in proto;
        }
        class Registry {
          constructor() {
            this.controllers = new TypedRegistry(DatasetController, "datasets", true);
            this.elements = new TypedRegistry(Element2, "elements");
            this.plugins = new TypedRegistry(Object, "plugins");
            this.scales = new TypedRegistry(Scale, "scales");
            this._typedRegistries = [this.controllers, this.scales, this.elements];
          }
          add(...args) {
            this._each("register", args);
          }
          remove(...args) {
            this._each("unregister", args);
          }
          addControllers(...args) {
            this._each("register", args, this.controllers);
          }
          addElements(...args) {
            this._each("register", args, this.elements);
          }
          addPlugins(...args) {
            this._each("register", args, this.plugins);
          }
          addScales(...args) {
            this._each("register", args, this.scales);
          }
          getController(id) {
            return this._get(id, this.controllers, "controller");
          }
          getElement(id) {
            return this._get(id, this.elements, "element");
          }
          getPlugin(id) {
            return this._get(id, this.plugins, "plugin");
          }
          getScale(id) {
            return this._get(id, this.scales, "scale");
          }
          removeControllers(...args) {
            this._each("unregister", args, this.controllers);
          }
          removeElements(...args) {
            this._each("unregister", args, this.elements);
          }
          removePlugins(...args) {
            this._each("unregister", args, this.plugins);
          }
          removeScales(...args) {
            this._each("unregister", args, this.scales);
          }
          _each(method, args, typedRegistry) {
            [...args].forEach((arg) => {
              const reg = typedRegistry || this._getRegistryForType(arg);
              if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
                this._exec(method, reg, arg);
              } else {
                each(arg, (item) => {
                  const itemReg = typedRegistry || this._getRegistryForType(item);
                  this._exec(method, itemReg, item);
                });
              }
            });
          }
          _exec(method, registry2, component) {
            const camelMethod = _capitalize(method);
            callback(component["before" + camelMethod], [], component);
            registry2[method](component);
            callback(component["after" + camelMethod], [], component);
          }
          _getRegistryForType(type) {
            for (let i = 0; i < this._typedRegistries.length; i++) {
              const reg = this._typedRegistries[i];
              if (reg.isForType(type)) {
                return reg;
              }
            }
            return this.plugins;
          }
          _get(id, typedRegistry, type) {
            const item = typedRegistry.get(id);
            if (item === void 0) {
              throw new Error('"' + id + '" is not a registered ' + type + ".");
            }
            return item;
          }
        }
        var registry = new Registry();
        class PluginService {
          constructor() {
            this._init = [];
          }
          notify(chart2, hook, args, filter) {
            if (hook === "beforeInit") {
              this._init = this._createDescriptors(chart2, true);
              this._notify(this._init, chart2, "install");
            }
            const descriptors2 = filter ? this._descriptors(chart2).filter(filter) : this._descriptors(chart2);
            const result = this._notify(descriptors2, chart2, hook, args);
            if (hook === "afterDestroy") {
              this._notify(descriptors2, chart2, "stop");
              this._notify(this._init, chart2, "uninstall");
            }
            return result;
          }
          _notify(descriptors2, chart2, hook, args) {
            args = args || {};
            for (const descriptor of descriptors2) {
              const plugin = descriptor.plugin;
              const method = plugin[hook];
              const params = [chart2, args, descriptor.options];
              if (callback(method, params, plugin) === false && args.cancelable) {
                return false;
              }
            }
            return true;
          }
          invalidate() {
            if (!isNullOrUndef(this._cache)) {
              this._oldCache = this._cache;
              this._cache = void 0;
            }
          }
          _descriptors(chart2) {
            if (this._cache) {
              return this._cache;
            }
            const descriptors2 = this._cache = this._createDescriptors(chart2);
            this._notifyStateChanges(chart2);
            return descriptors2;
          }
          _createDescriptors(chart2, all) {
            const config = chart2 && chart2.config;
            const options = valueOrDefault(config.options && config.options.plugins, {});
            const plugins2 = allPlugins(config);
            return options === false && !all ? [] : createDescriptors(chart2, plugins2, options, all);
          }
          _notifyStateChanges(chart2) {
            const previousDescriptors = this._oldCache || [];
            const descriptors2 = this._cache;
            const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
            this._notify(diff(previousDescriptors, descriptors2), chart2, "stop");
            this._notify(diff(descriptors2, previousDescriptors), chart2, "start");
          }
        }
        function allPlugins(config) {
          const localIds = {};
          const plugins2 = [];
          const keys = Object.keys(registry.plugins.items);
          for (let i = 0; i < keys.length; i++) {
            plugins2.push(registry.getPlugin(keys[i]));
          }
          const local = config.plugins || [];
          for (let i = 0; i < local.length; i++) {
            const plugin = local[i];
            if (plugins2.indexOf(plugin) === -1) {
              plugins2.push(plugin);
              localIds[plugin.id] = true;
            }
          }
          return { plugins: plugins2, localIds };
        }
        function getOpts(options, all) {
          if (!all && options === false) {
            return null;
          }
          if (options === true) {
            return {};
          }
          return options;
        }
        function createDescriptors(chart2, { plugins: plugins2, localIds }, options, all) {
          const result = [];
          const context = chart2.getContext();
          for (const plugin of plugins2) {
            const id = plugin.id;
            const opts = getOpts(options[id], all);
            if (opts === null) {
              continue;
            }
            result.push({
              plugin,
              options: pluginOpts(chart2.config, { plugin, local: localIds[id] }, opts, context)
            });
          }
          return result;
        }
        function pluginOpts(config, { plugin, local }, opts, context) {
          const keys = config.pluginScopeKeys(plugin);
          const scopes = config.getOptionScopes(opts, keys);
          if (local && plugin.defaults) {
            scopes.push(plugin.defaults);
          }
          return config.createResolver(scopes, context, [""], {
            scriptable: false,
            indexable: false,
            allKeys: true
          });
        }
        function getIndexAxis(type, options) {
          const datasetDefaults = defaults.datasets[type] || {};
          const datasetOptions = (options.datasets || {})[type] || {};
          return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
        }
        function getAxisFromDefaultScaleID(id, indexAxis) {
          let axis = id;
          if (id === "_index_") {
            axis = indexAxis;
          } else if (id === "_value_") {
            axis = indexAxis === "x" ? "y" : "x";
          }
          return axis;
        }
        function getDefaultScaleIDFromAxis(axis, indexAxis) {
          return axis === indexAxis ? "_index_" : "_value_";
        }
        function axisFromPosition(position) {
          if (position === "top" || position === "bottom") {
            return "x";
          }
          if (position === "left" || position === "right") {
            return "y";
          }
        }
        function determineAxis(id, scaleOptions) {
          if (id === "x" || id === "y") {
            return id;
          }
          return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
        }
        function mergeScaleConfig(config, options) {
          const chartDefaults = overrides[config.type] || { scales: {} };
          const configScales = options.scales || {};
          const chartIndexAxis = getIndexAxis(config.type, options);
          const firstIDs = Object.create(null);
          const scales2 = Object.create(null);
          Object.keys(configScales).forEach((id) => {
            const scaleConf = configScales[id];
            if (!isObject2(scaleConf)) {
              return console.error(`Invalid scale configuration for scale: ${id}`);
            }
            if (scaleConf._proxy) {
              return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
            }
            const axis = determineAxis(id, scaleConf);
            const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
            const defaultScaleOptions = chartDefaults.scales || {};
            firstIDs[axis] = firstIDs[axis] || id;
            scales2[id] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
          });
          config.data.datasets.forEach((dataset) => {
            const type = dataset.type || config.type;
            const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
            const datasetDefaults = overrides[type] || {};
            const defaultScaleOptions = datasetDefaults.scales || {};
            Object.keys(defaultScaleOptions).forEach((defaultID) => {
              const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
              const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
              scales2[id] = scales2[id] || Object.create(null);
              mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
            });
          });
          Object.keys(scales2).forEach((key) => {
            const scale = scales2[key];
            mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
          });
          return scales2;
        }
        function initOptions(config) {
          const options = config.options || (config.options = {});
          options.plugins = valueOrDefault(options.plugins, {});
          options.scales = mergeScaleConfig(config, options);
        }
        function initData(data) {
          data = data || {};
          data.datasets = data.datasets || [];
          data.labels = data.labels || [];
          return data;
        }
        function initConfig(config) {
          config = config || {};
          config.data = initData(config.data);
          initOptions(config);
          return config;
        }
        const keyCache = /* @__PURE__ */ new Map();
        const keysCached = /* @__PURE__ */ new Set();
        function cachedKeys(cacheKey, generate) {
          let keys = keyCache.get(cacheKey);
          if (!keys) {
            keys = generate();
            keyCache.set(cacheKey, keys);
            keysCached.add(keys);
          }
          return keys;
        }
        const addIfFound = (set2, obj, key) => {
          const opts = resolveObjectKey(obj, key);
          if (opts !== void 0) {
            set2.add(opts);
          }
        };
        class Config {
          constructor(config) {
            this._config = initConfig(config);
            this._scopeCache = /* @__PURE__ */ new Map();
            this._resolverCache = /* @__PURE__ */ new Map();
          }
          get platform() {
            return this._config.platform;
          }
          get type() {
            return this._config.type;
          }
          set type(type) {
            this._config.type = type;
          }
          get data() {
            return this._config.data;
          }
          set data(data) {
            this._config.data = initData(data);
          }
          get options() {
            return this._config.options;
          }
          set options(options) {
            this._config.options = options;
          }
          get plugins() {
            return this._config.plugins;
          }
          update() {
            const config = this._config;
            this.clearCache();
            initOptions(config);
          }
          clearCache() {
            this._scopeCache.clear();
            this._resolverCache.clear();
          }
          datasetScopeKeys(datasetType) {
            return cachedKeys(datasetType, () => [[
              `datasets.${datasetType}`,
              ""
            ]]);
          }
          datasetAnimationScopeKeys(datasetType, transition) {
            return cachedKeys(`${datasetType}.transition.${transition}`, () => [
              [
                `datasets.${datasetType}.transitions.${transition}`,
                `transitions.${transition}`
              ],
              [
                `datasets.${datasetType}`,
                ""
              ]
            ]);
          }
          datasetElementScopeKeys(datasetType, elementType) {
            return cachedKeys(`${datasetType}-${elementType}`, () => [[
              `datasets.${datasetType}.elements.${elementType}`,
              `datasets.${datasetType}`,
              `elements.${elementType}`,
              ""
            ]]);
          }
          pluginScopeKeys(plugin) {
            const id = plugin.id;
            const type = this.type;
            return cachedKeys(`${type}-plugin-${id}`, () => [[
              `plugins.${id}`,
              ...plugin.additionalOptionScopes || []
            ]]);
          }
          _cachedScopes(mainScope, resetCache) {
            const _scopeCache = this._scopeCache;
            let cache = _scopeCache.get(mainScope);
            if (!cache || resetCache) {
              cache = /* @__PURE__ */ new Map();
              _scopeCache.set(mainScope, cache);
            }
            return cache;
          }
          getOptionScopes(mainScope, keyLists, resetCache) {
            const { options, type } = this;
            const cache = this._cachedScopes(mainScope, resetCache);
            const cached = cache.get(keyLists);
            if (cached) {
              return cached;
            }
            const scopes = /* @__PURE__ */ new Set();
            keyLists.forEach((keys) => {
              if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key) => addIfFound(scopes, mainScope, key));
              }
              keys.forEach((key) => addIfFound(scopes, options, key));
              keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
              keys.forEach((key) => addIfFound(scopes, defaults, key));
              keys.forEach((key) => addIfFound(scopes, descriptors, key));
            });
            const array = Array.from(scopes);
            if (array.length === 0) {
              array.push(Object.create(null));
            }
            if (keysCached.has(keyLists)) {
              cache.set(keyLists, array);
            }
            return array;
          }
          chartOptionScopes() {
            const { options, type } = this;
            return [
              options,
              overrides[type] || {},
              defaults.datasets[type] || {},
              { type },
              defaults,
              descriptors
            ];
          }
          resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
            const result = { $shared: true };
            const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
            let options = resolver;
            if (needContext(resolver, names2)) {
              result.$shared = false;
              context = isFunction2(context) ? context() : context;
              const subResolver = this.createResolver(scopes, context, subPrefixes);
              options = _attachContext(resolver, context, subResolver);
            }
            for (const prop of names2) {
              result[prop] = options[prop];
            }
            return result;
          }
          createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
            const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
            return isObject2(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
          }
        }
        function getResolver(resolverCache, scopes, prefixes) {
          let cache = resolverCache.get(scopes);
          if (!cache) {
            cache = /* @__PURE__ */ new Map();
            resolverCache.set(scopes, cache);
          }
          const cacheKey = prefixes.join();
          let cached = cache.get(cacheKey);
          if (!cached) {
            const resolver = _createResolver(scopes, prefixes);
            cached = {
              resolver,
              subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
            };
            cache.set(cacheKey, cached);
          }
          return cached;
        }
        const hasFunction = (value) => isObject2(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction2(value[key]), false);
        function needContext(proxy, names2) {
          const { isScriptable, isIndexable } = _descriptors(proxy);
          for (const prop of names2) {
            const scriptable = isScriptable(prop);
            const indexable = isIndexable(prop);
            const value = (indexable || scriptable) && proxy[prop];
            if (scriptable && (isFunction2(value) || hasFunction(value)) || indexable && isArray(value)) {
              return true;
            }
          }
          return false;
        }
        var version = "3.9.1";
        const KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
        function positionIsHorizontal(position, axis) {
          return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
        }
        function compare2Level(l1, l2) {
          return function(a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
          };
        }
        function onAnimationsComplete(context) {
          const chart2 = context.chart;
          const animationOptions2 = chart2.options.animation;
          chart2.notifyPlugins("afterRender");
          callback(animationOptions2 && animationOptions2.onComplete, [context], chart2);
        }
        function onAnimationProgress(context) {
          const chart2 = context.chart;
          const animationOptions2 = chart2.options.animation;
          callback(animationOptions2 && animationOptions2.onProgress, [context], chart2);
        }
        function getCanvas(item) {
          if (_isDomSupported() && typeof item === "string") {
            item = document.getElementById(item);
          } else if (item && item.length) {
            item = item[0];
          }
          if (item && item.canvas) {
            item = item.canvas;
          }
          return item;
        }
        const instances = {};
        const getChart = (key) => {
          const canvas = getCanvas(key);
          return Object.values(instances).filter((c) => c.canvas === canvas).pop();
        };
        function moveNumericKeys(obj, start, move2) {
          const keys = Object.keys(obj);
          for (const key of keys) {
            const intKey = +key;
            if (intKey >= start) {
              const value = obj[key];
              delete obj[key];
              if (move2 > 0 || intKey > start) {
                obj[intKey + move2] = value;
              }
            }
          }
        }
        function determineLastEvent(e, lastEvent, inChartArea, isClick) {
          if (!inChartArea || e.type === "mouseout") {
            return null;
          }
          if (isClick) {
            return lastEvent;
          }
          return e;
        }
        class Chart3 {
          constructor(item, userConfig) {
            const config = this.config = new Config(userConfig);
            const initialCanvas = getCanvas(item);
            const existingChart = getChart(initialCanvas);
            if (existingChart) {
              throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
            }
            const options = config.createResolver(config.chartOptionScopes(), this.getContext());
            this.platform = new (config.platform || _detectPlatform(initialCanvas))();
            this.platform.updateConfig(config);
            const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
            const canvas = context && context.canvas;
            const height = canvas && canvas.height;
            const width = canvas && canvas.width;
            this.id = uid();
            this.ctx = context;
            this.canvas = canvas;
            this.width = width;
            this.height = height;
            this._options = options;
            this._aspectRatio = this.aspectRatio;
            this._layers = [];
            this._metasets = [];
            this._stacks = void 0;
            this.boxes = [];
            this.currentDevicePixelRatio = void 0;
            this.chartArea = void 0;
            this._active = [];
            this._lastEvent = void 0;
            this._listeners = {};
            this._responsiveListeners = void 0;
            this._sortedMetasets = [];
            this.scales = {};
            this._plugins = new PluginService();
            this.$proxies = {};
            this._hiddenIndices = {};
            this.attached = false;
            this._animationsDisabled = void 0;
            this.$context = void 0;
            this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
            this._dataChanges = [];
            instances[this.id] = this;
            if (!context || !canvas) {
              console.error("Failed to create chart: can't acquire context from the given item");
              return;
            }
            animator.listen(this, "complete", onAnimationsComplete);
            animator.listen(this, "progress", onAnimationProgress);
            this._initialize();
            if (this.attached) {
              this.update();
            }
          }
          get aspectRatio() {
            const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
            if (!isNullOrUndef(aspectRatio)) {
              return aspectRatio;
            }
            if (maintainAspectRatio && _aspectRatio) {
              return _aspectRatio;
            }
            return height ? width / height : null;
          }
          get data() {
            return this.config.data;
          }
          set data(data) {
            this.config.data = data;
          }
          get options() {
            return this._options;
          }
          set options(options) {
            this.config.options = options;
          }
          _initialize() {
            this.notifyPlugins("beforeInit");
            if (this.options.responsive) {
              this.resize();
            } else {
              retinaScale(this, this.options.devicePixelRatio);
            }
            this.bindEvents();
            this.notifyPlugins("afterInit");
            return this;
          }
          clear() {
            clearCanvas(this.canvas, this.ctx);
            return this;
          }
          stop() {
            animator.stop(this);
            return this;
          }
          resize(width, height) {
            if (!animator.running(this)) {
              this._resize(width, height);
            } else {
              this._resizeBeforeDraw = { width, height };
            }
          }
          _resize(width, height) {
            const options = this.options;
            const canvas = this.canvas;
            const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
            const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
            const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
            const mode = this.width ? "resize" : "attach";
            this.width = newSize.width;
            this.height = newSize.height;
            this._aspectRatio = this.aspectRatio;
            if (!retinaScale(this, newRatio, true)) {
              return;
            }
            this.notifyPlugins("resize", { size: newSize });
            callback(options.onResize, [this, newSize], this);
            if (this.attached) {
              if (this._doResize(mode)) {
                this.render();
              }
            }
          }
          ensureScalesHaveIDs() {
            const options = this.options;
            const scalesOptions = options.scales || {};
            each(scalesOptions, (axisOptions, axisID) => {
              axisOptions.id = axisID;
            });
          }
          buildOrUpdateScales() {
            const options = this.options;
            const scaleOpts = options.scales;
            const scales2 = this.scales;
            const updated = Object.keys(scales2).reduce((obj, id) => {
              obj[id] = false;
              return obj;
            }, {});
            let items = [];
            if (scaleOpts) {
              items = items.concat(Object.keys(scaleOpts).map((id) => {
                const scaleOptions = scaleOpts[id];
                const axis = determineAxis(id, scaleOptions);
                const isRadial = axis === "r";
                const isHorizontal = axis === "x";
                return {
                  options: scaleOptions,
                  dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                  dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
                };
              }));
            }
            each(items, (item) => {
              const scaleOptions = item.options;
              const id = scaleOptions.id;
              const axis = determineAxis(id, scaleOptions);
              const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
              if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
                scaleOptions.position = item.dposition;
              }
              updated[id] = true;
              let scale = null;
              if (id in scales2 && scales2[id].type === scaleType) {
                scale = scales2[id];
              } else {
                const scaleClass = registry.getScale(scaleType);
                scale = new scaleClass({
                  id,
                  type: scaleType,
                  ctx: this.ctx,
                  chart: this
                });
                scales2[scale.id] = scale;
              }
              scale.init(scaleOptions, options);
            });
            each(updated, (hasUpdated, id) => {
              if (!hasUpdated) {
                delete scales2[id];
              }
            });
            each(scales2, (scale) => {
              layouts.configure(this, scale, scale.options);
              layouts.addBox(this, scale);
            });
          }
          _updateMetasets() {
            const metasets = this._metasets;
            const numData = this.data.datasets.length;
            const numMeta = metasets.length;
            metasets.sort((a, b) => a.index - b.index);
            if (numMeta > numData) {
              for (let i = numData; i < numMeta; ++i) {
                this._destroyDatasetMeta(i);
              }
              metasets.splice(numData, numMeta - numData);
            }
            this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
          }
          _removeUnreferencedMetasets() {
            const { _metasets: metasets, data: { datasets } } = this;
            if (metasets.length > datasets.length) {
              delete this._stacks;
            }
            metasets.forEach((meta, index3) => {
              if (datasets.filter((x) => x === meta._dataset).length === 0) {
                this._destroyDatasetMeta(index3);
              }
            });
          }
          buildOrUpdateControllers() {
            const newControllers = [];
            const datasets = this.data.datasets;
            let i, ilen;
            this._removeUnreferencedMetasets();
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              const dataset = datasets[i];
              let meta = this.getDatasetMeta(i);
              const type = dataset.type || this.config.type;
              if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i);
                meta = this.getDatasetMeta(i);
              }
              meta.type = type;
              meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
              meta.order = dataset.order || 0;
              meta.index = i;
              meta.label = "" + dataset.label;
              meta.visible = this.isDatasetVisible(i);
              if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
              } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType, dataElementType } = defaults.datasets[type];
                Object.assign(ControllerClass.prototype, {
                  dataElementType: registry.getElement(dataElementType),
                  datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                });
                meta.controller = new ControllerClass(this, i);
                newControllers.push(meta.controller);
              }
            }
            this._updateMetasets();
            return newControllers;
          }
          _resetElements() {
            each(this.data.datasets, (dataset, datasetIndex) => {
              this.getDatasetMeta(datasetIndex).controller.reset();
            }, this);
          }
          reset() {
            this._resetElements();
            this.notifyPlugins("reset");
          }
          update(mode) {
            const config = this.config;
            config.update();
            const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
            const animsDisabled = this._animationsDisabled = !options.animation;
            this._updateScales();
            this._checkEventBindings();
            this._updateHiddenIndices();
            this._plugins.invalidate();
            if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
              return;
            }
            const newControllers = this.buildOrUpdateControllers();
            this.notifyPlugins("beforeElementsUpdate");
            let minPadding = 0;
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
              const { controller } = this.getDatasetMeta(i);
              const reset2 = !animsDisabled && newControllers.indexOf(controller) === -1;
              controller.buildOrUpdateElements(reset2);
              minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
            }
            minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
            this._updateLayout(minPadding);
            if (!animsDisabled) {
              each(newControllers, (controller) => {
                controller.reset();
              });
            }
            this._updateDatasets(mode);
            this.notifyPlugins("afterUpdate", { mode });
            this._layers.sort(compare2Level("z", "_idx"));
            const { _active, _lastEvent } = this;
            if (_lastEvent) {
              this._eventHandler(_lastEvent, true);
            } else if (_active.length) {
              this._updateHoverStyles(_active, _active, true);
            }
            this.render();
          }
          _updateScales() {
            each(this.scales, (scale) => {
              layouts.removeBox(this, scale);
            });
            this.ensureScalesHaveIDs();
            this.buildOrUpdateScales();
          }
          _checkEventBindings() {
            const options = this.options;
            const existingEvents = new Set(Object.keys(this._listeners));
            const newEvents = new Set(options.events);
            if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
              this.unbindEvents();
              this.bindEvents();
            }
          }
          _updateHiddenIndices() {
            const { _hiddenIndices } = this;
            const changes = this._getUniformDataChanges() || [];
            for (const { method, start, count } of changes) {
              const move2 = method === "_removeElements" ? -count : count;
              moveNumericKeys(_hiddenIndices, start, move2);
            }
          }
          _getUniformDataChanges() {
            const _dataChanges = this._dataChanges;
            if (!_dataChanges || !_dataChanges.length) {
              return;
            }
            this._dataChanges = [];
            const datasetCount = this.data.datasets.length;
            const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
            const changeSet = makeSet(0);
            for (let i = 1; i < datasetCount; i++) {
              if (!setsEqual(changeSet, makeSet(i))) {
                return;
              }
            }
            return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
          }
          _updateLayout(minPadding) {
            if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
              return;
            }
            layouts.update(this, this.width, this.height, minPadding);
            const area = this.chartArea;
            const noArea = area.width <= 0 || area.height <= 0;
            this._layers = [];
            each(this.boxes, (box) => {
              if (noArea && box.position === "chartArea") {
                return;
              }
              if (box.configure) {
                box.configure();
              }
              this._layers.push(...box._layers());
            }, this);
            this._layers.forEach((item, index3) => {
              item._idx = index3;
            });
            this.notifyPlugins("afterLayout");
          }
          _updateDatasets(mode) {
            if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
              return;
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this.getDatasetMeta(i).controller.configure();
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._updateDataset(i, isFunction2(mode) ? mode({ datasetIndex: i }) : mode);
            }
            this.notifyPlugins("afterDatasetsUpdate", { mode });
          }
          _updateDataset(index3, mode) {
            const meta = this.getDatasetMeta(index3);
            const args = { meta, index: index3, mode, cancelable: true };
            if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
              return;
            }
            meta.controller._update(mode);
            args.cancelable = false;
            this.notifyPlugins("afterDatasetUpdate", args);
          }
          render() {
            if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
              return;
            }
            if (animator.has(this)) {
              if (this.attached && !animator.running(this)) {
                animator.start(this);
              }
            } else {
              this.draw();
              onAnimationsComplete({ chart: this });
            }
          }
          draw() {
            let i;
            if (this._resizeBeforeDraw) {
              const { width, height } = this._resizeBeforeDraw;
              this._resize(width, height);
              this._resizeBeforeDraw = null;
            }
            this.clear();
            if (this.width <= 0 || this.height <= 0) {
              return;
            }
            if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
              return;
            }
            const layers = this._layers;
            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
              layers[i].draw(this.chartArea);
            }
            this._drawDatasets();
            for (; i < layers.length; ++i) {
              layers[i].draw(this.chartArea);
            }
            this.notifyPlugins("afterDraw");
          }
          _getSortedDatasetMetas(filterVisible) {
            const metasets = this._sortedMetasets;
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metasets.length; i < ilen; ++i) {
              const meta = metasets[i];
              if (!filterVisible || meta.visible) {
                result.push(meta);
              }
            }
            return result;
          }
          getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(true);
          }
          _drawDatasets() {
            if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
              return;
            }
            const metasets = this.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              this._drawDataset(metasets[i]);
            }
            this.notifyPlugins("afterDatasetsDraw");
          }
          _drawDataset(meta) {
            const ctx = this.ctx;
            const clip = meta._clip;
            const useClip = !clip.disabled;
            const area = this.chartArea;
            const args = {
              meta,
              index: meta.index,
              cancelable: true
            };
            if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
              return;
            }
            if (useClip) {
              clipArea(ctx, {
                left: clip.left === false ? 0 : area.left - clip.left,
                right: clip.right === false ? this.width : area.right + clip.right,
                top: clip.top === false ? 0 : area.top - clip.top,
                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
              });
            }
            meta.controller.draw();
            if (useClip) {
              unclipArea(ctx);
            }
            args.cancelable = false;
            this.notifyPlugins("afterDatasetDraw", args);
          }
          isPointInArea(point) {
            return _isPointInArea(point, this.chartArea, this._minPadding);
          }
          getElementsAtEventForMode(e, mode, options, useFinalPosition) {
            const method = Interaction.modes[mode];
            if (typeof method === "function") {
              return method(this, e, options, useFinalPosition);
            }
            return [];
          }
          getDatasetMeta(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            const metasets = this._metasets;
            let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
            if (!meta) {
              meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset && dataset.order || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false
              };
              metasets.push(meta);
            }
            return meta;
          }
          getContext() {
            return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
          }
          getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length;
          }
          isDatasetVisible(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            if (!dataset) {
              return false;
            }
            const meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
          }
          setDatasetVisibility(datasetIndex, visible) {
            const meta = this.getDatasetMeta(datasetIndex);
            meta.hidden = !visible;
          }
          toggleDataVisibility(index3) {
            this._hiddenIndices[index3] = !this._hiddenIndices[index3];
          }
          getDataVisibility(index3) {
            return !this._hiddenIndices[index3];
          }
          _updateVisibility(datasetIndex, dataIndex, visible) {
            const mode = visible ? "show" : "hide";
            const meta = this.getDatasetMeta(datasetIndex);
            const anims = meta.controller._resolveAnimations(void 0, mode);
            if (defined(dataIndex)) {
              meta.data[dataIndex].hidden = !visible;
              this.update();
            } else {
              this.setDatasetVisibility(datasetIndex, visible);
              anims.update(meta, { visible });
              this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
            }
          }
          hide(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, false);
          }
          show(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, true);
          }
          _destroyDatasetMeta(datasetIndex) {
            const meta = this._metasets[datasetIndex];
            if (meta && meta.controller) {
              meta.controller._destroy();
            }
            delete this._metasets[datasetIndex];
          }
          _stop() {
            let i, ilen;
            this.stop();
            animator.remove(this);
            for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._destroyDatasetMeta(i);
            }
          }
          destroy() {
            this.notifyPlugins("beforeDestroy");
            const { canvas, ctx } = this;
            this._stop();
            this.config.clearCache();
            if (canvas) {
              this.unbindEvents();
              clearCanvas(canvas, ctx);
              this.platform.releaseContext(ctx);
              this.canvas = null;
              this.ctx = null;
            }
            this.notifyPlugins("destroy");
            delete instances[this.id];
            this.notifyPlugins("afterDestroy");
          }
          toBase64Image(...args) {
            return this.canvas.toDataURL(...args);
          }
          bindEvents() {
            this.bindUserEvents();
            if (this.options.responsive) {
              this.bindResponsiveEvents();
            } else {
              this.attached = true;
            }
          }
          bindUserEvents() {
            const listeners = this._listeners;
            const platform = this.platform;
            const _add = (type, listener2) => {
              platform.addEventListener(this, type, listener2);
              listeners[type] = listener2;
            };
            const listener = (e, x, y) => {
              e.offsetX = x;
              e.offsetY = y;
              this._eventHandler(e);
            };
            each(this.options.events, (type) => _add(type, listener));
          }
          bindResponsiveEvents() {
            if (!this._responsiveListeners) {
              this._responsiveListeners = {};
            }
            const listeners = this._responsiveListeners;
            const platform = this.platform;
            const _add = (type, listener2) => {
              platform.addEventListener(this, type, listener2);
              listeners[type] = listener2;
            };
            const _remove = (type, listener2) => {
              if (listeners[type]) {
                platform.removeEventListener(this, type, listener2);
                delete listeners[type];
              }
            };
            const listener = (width, height) => {
              if (this.canvas) {
                this.resize(width, height);
              }
            };
            let detached;
            const attached = () => {
              _remove("attach", attached);
              this.attached = true;
              this.resize();
              _add("resize", listener);
              _add("detach", detached);
            };
            detached = () => {
              this.attached = false;
              _remove("resize", listener);
              this._stop();
              this._resize(0, 0);
              _add("attach", attached);
            };
            if (platform.isAttached(this.canvas)) {
              attached();
            } else {
              detached();
            }
          }
          unbindEvents() {
            each(this._listeners, (listener, type) => {
              this.platform.removeEventListener(this, type, listener);
            });
            this._listeners = {};
            each(this._responsiveListeners, (listener, type) => {
              this.platform.removeEventListener(this, type, listener);
            });
            this._responsiveListeners = void 0;
          }
          updateHoverStyle(items, mode, enabled) {
            const prefix = enabled ? "set" : "remove";
            let meta, item, i, ilen;
            if (mode === "dataset") {
              meta = this.getDatasetMeta(items[0].datasetIndex);
              meta.controller["_" + prefix + "DatasetHoverStyle"]();
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item = items[i];
              const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
              if (controller) {
                controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
              }
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements) {
            const lastActive = this._active || [];
            const active = activeElements.map(({ datasetIndex, index: index3 }) => {
              const meta = this.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error("No dataset found at index " + datasetIndex);
              }
              return {
                datasetIndex,
                element: meta.data[index3],
                index: index3
              };
            });
            const changed = !_elementsEqual(active, lastActive);
            if (changed) {
              this._active = active;
              this._lastEvent = null;
              this._updateHoverStyles(active, lastActive);
            }
          }
          notifyPlugins(hook, args, filter) {
            return this._plugins.notify(this, hook, args, filter);
          }
          _updateHoverStyles(active, lastActive, replay) {
            const hoverOptions = this.options.hover;
            const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
            const deactivated = diff(lastActive, active);
            const activated = replay ? active : diff(active, lastActive);
            if (deactivated.length) {
              this.updateHoverStyle(deactivated, hoverOptions.mode, false);
            }
            if (activated.length && hoverOptions.mode) {
              this.updateHoverStyle(activated, hoverOptions.mode, true);
            }
          }
          _eventHandler(e, replay) {
            const args = {
              event: e,
              replay,
              cancelable: true,
              inChartArea: this.isPointInArea(e)
            };
            const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
            if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
              return;
            }
            const changed = this._handleEvent(e, replay, args.inChartArea);
            args.cancelable = false;
            this.notifyPlugins("afterEvent", args, eventFilter);
            if (changed || args.changed) {
              this.render();
            }
            return this;
          }
          _handleEvent(e, replay, inChartArea) {
            const { _active: lastActive = [], options } = this;
            const useFinalPosition = replay;
            const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
            const isClick = _isClickEvent(e);
            const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
            if (inChartArea) {
              this._lastEvent = null;
              callback(options.onHover, [e, active, this], this);
              if (isClick) {
                callback(options.onClick, [e, active, this], this);
              }
            }
            const changed = !_elementsEqual(active, lastActive);
            if (changed || replay) {
              this._active = active;
              this._updateHoverStyles(active, lastActive, replay);
            }
            this._lastEvent = lastEvent;
            return changed;
          }
          _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
            if (e.type === "mouseout") {
              return [];
            }
            if (!inChartArea) {
              return lastActive;
            }
            const hoverOptions = this.options.hover;
            return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
          }
        }
        const invalidatePlugins = () => each(Chart3.instances, (chart2) => chart2._plugins.invalidate());
        const enumerable = true;
        Object.defineProperties(Chart3, {
          defaults: {
            enumerable,
            value: defaults
          },
          instances: {
            enumerable,
            value: instances
          },
          overrides: {
            enumerable,
            value: overrides
          },
          registry: {
            enumerable,
            value: registry
          },
          version: {
            enumerable,
            value: version
          },
          getChart: {
            enumerable,
            value: getChart
          },
          register: {
            enumerable,
            value: (...items) => {
              registry.add(...items);
              invalidatePlugins();
            }
          },
          unregister: {
            enumerable,
            value: (...items) => {
              registry.remove(...items);
              invalidatePlugins();
            }
          }
        });
        function abstract() {
          throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
        }
        class DateAdapter {
          constructor(options) {
            this.options = options || {};
          }
          init(chartOptions) {
          }
          formats() {
            return abstract();
          }
          parse(value, format) {
            return abstract();
          }
          format(timestamp, format) {
            return abstract();
          }
          add(timestamp, amount, unit) {
            return abstract();
          }
          diff(a, b, unit) {
            return abstract();
          }
          startOf(timestamp, unit, weekday) {
            return abstract();
          }
          endOf(timestamp, unit) {
            return abstract();
          }
        }
        DateAdapter.override = function(members) {
          Object.assign(DateAdapter.prototype, members);
        };
        var _adapters = {
          _date: DateAdapter
        };
        function getAllScaleValues(scale, type) {
          if (!scale._cache.$bar) {
            const visibleMetas = scale.getMatchingVisibleMetas(type);
            let values = [];
            for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
              values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
            }
            scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
          }
          return scale._cache.$bar;
        }
        function computeMinSampleSize(meta) {
          const scale = meta.iScale;
          const values = getAllScaleValues(scale, meta.type);
          let min = scale._length;
          let i, ilen, curr, prev;
          const updateMinAndPrev = () => {
            if (curr === 32767 || curr === -32768) {
              return;
            }
            if (defined(prev)) {
              min = Math.min(min, Math.abs(curr - prev) || min);
            }
            prev = curr;
          };
          for (i = 0, ilen = values.length; i < ilen; ++i) {
            curr = scale.getPixelForValue(values[i]);
            updateMinAndPrev();
          }
          prev = void 0;
          for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
            curr = scale.getPixelForTick(i);
            updateMinAndPrev();
          }
          return min;
        }
        function computeFitCategoryTraits(index3, ruler, options, stackCount) {
          const thickness = options.barThickness;
          let size, ratio;
          if (isNullOrUndef(thickness)) {
            size = ruler.min * options.categoryPercentage;
            ratio = options.barPercentage;
          } else {
            size = thickness * stackCount;
            ratio = 1;
          }
          return {
            chunk: size / stackCount,
            ratio,
            start: ruler.pixels[index3] - size / 2
          };
        }
        function computeFlexCategoryTraits(index3, ruler, options, stackCount) {
          const pixels = ruler.pixels;
          const curr = pixels[index3];
          let prev = index3 > 0 ? pixels[index3 - 1] : null;
          let next = index3 < pixels.length - 1 ? pixels[index3 + 1] : null;
          const percent = options.categoryPercentage;
          if (prev === null) {
            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
          }
          if (next === null) {
            next = curr + curr - prev;
          }
          const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
          const size = Math.abs(next - prev) / 2 * percent;
          return {
            chunk: size / stackCount,
            ratio: options.barPercentage,
            start
          };
        }
        function parseFloatBar(entry, item, vScale, i) {
          const startValue = vScale.parse(entry[0], i);
          const endValue = vScale.parse(entry[1], i);
          const min = Math.min(startValue, endValue);
          const max = Math.max(startValue, endValue);
          let barStart = min;
          let barEnd = max;
          if (Math.abs(min) > Math.abs(max)) {
            barStart = max;
            barEnd = min;
          }
          item[vScale.axis] = barEnd;
          item._custom = {
            barStart,
            barEnd,
            start: startValue,
            end: endValue,
            min,
            max
          };
        }
        function parseValue(entry, item, vScale, i) {
          if (isArray(entry)) {
            parseFloatBar(entry, item, vScale, i);
          } else {
            item[vScale.axis] = vScale.parse(entry, i);
          }
          return item;
        }
        function parseArrayOrPrimitive(meta, data, start, count) {
          const iScale = meta.iScale;
          const vScale = meta.vScale;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = [];
          let i, ilen, item, entry;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            entry = data[i];
            item = {};
            item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
            parsed.push(parseValue(entry, item, vScale, i));
          }
          return parsed;
        }
        function isFloatBar(custom) {
          return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
        }
        function barSign(size, vScale, actualBase) {
          if (size !== 0) {
            return sign(size);
          }
          return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
        }
        function borderProps(properties) {
          let reverse, start, end, top, bottom;
          if (properties.horizontal) {
            reverse = properties.base > properties.x;
            start = "left";
            end = "right";
          } else {
            reverse = properties.base < properties.y;
            start = "bottom";
            end = "top";
          }
          if (reverse) {
            top = "end";
            bottom = "start";
          } else {
            top = "start";
            bottom = "end";
          }
          return { start, end, reverse, top, bottom };
        }
        function setBorderSkipped(properties, options, stack, index3) {
          let edge = options.borderSkipped;
          const res = {};
          if (!edge) {
            properties.borderSkipped = res;
            return;
          }
          if (edge === true) {
            properties.borderSkipped = { top: true, right: true, bottom: true, left: true };
            return;
          }
          const { start, end, reverse, top, bottom } = borderProps(properties);
          if (edge === "middle" && stack) {
            properties.enableBorderRadius = true;
            if ((stack._top || 0) === index3) {
              edge = top;
            } else if ((stack._bottom || 0) === index3) {
              edge = bottom;
            } else {
              res[parseEdge(bottom, start, end, reverse)] = true;
              edge = top;
            }
          }
          res[parseEdge(edge, start, end, reverse)] = true;
          properties.borderSkipped = res;
        }
        function parseEdge(edge, a, b, reverse) {
          if (reverse) {
            edge = swap(edge, a, b);
            edge = startEnd(edge, b, a);
          } else {
            edge = startEnd(edge, a, b);
          }
          return edge;
        }
        function swap(orig, v1, v2) {
          return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function startEnd(v, start, end) {
          return v === "start" ? start : v === "end" ? end : v;
        }
        function setInflateAmount(properties, { inflateAmount }, ratio) {
          properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
        }
        class BarController extends DatasetController {
          parsePrimitiveData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseArrayData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseObjectData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
            const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
            const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
            const parsed = [];
            let i, ilen, item, obj;
            for (i = start, ilen = start + count; i < ilen; ++i) {
              obj = data[i];
              item = {};
              item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
              parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
            }
            return parsed;
          }
          updateRangeFromParsed(range2, scale, parsed, stack) {
            super.updateRangeFromParsed(range2, scale, parsed, stack);
            const custom = parsed._custom;
            if (custom && scale === this._cachedMeta.vScale) {
              range2.min = Math.min(range2.min, custom.min);
              range2.max = Math.max(range2.max, custom.max);
            }
          }
          getMaxOverflow() {
            return 0;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const { iScale, vScale } = meta;
            const parsed = this.getParsed(index3);
            const custom = parsed._custom;
            const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
            return {
              label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
              value
            };
          }
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
            const meta = this._cachedMeta;
            meta.stack = this.getDataset().stack;
          }
          update(mode) {
            const meta = this._cachedMeta;
            this.updateElements(meta.data, 0, meta.data.length, mode);
          }
          updateElements(bars, start, count, mode) {
            const reset2 = mode === "reset";
            const { index: index3, _cachedMeta: { vScale } } = this;
            const base = vScale.getBasePixel();
            const horizontal = vScale.isHorizontal();
            const ruler = this._getRuler();
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            for (let i = start; i < start + count; i++) {
              const parsed = this.getParsed(i);
              const vpixels = reset2 || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
              const ipixels = this._calculateBarIndexPixels(i, ruler);
              const stack = (parsed._stacks || {})[vScale.axis];
              const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index3 === stack._top || index3 === stack._bottom),
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size
              };
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
              }
              const options = properties.options || bars[i].options;
              setBorderSkipped(properties, options, stack, index3);
              setInflateAmount(properties, options, ruler.ratio);
              this.updateElement(bars[i], i, properties, mode);
            }
          }
          _getStacks(last, dataIndex) {
            const { iScale } = this._cachedMeta;
            const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
            const stacked = iScale.options.stacked;
            const stacks = [];
            const skipNull = (meta) => {
              const parsed = meta.controller.getParsed(dataIndex);
              const val = parsed && parsed[meta.vScale.axis];
              if (isNullOrUndef(val) || isNaN(val)) {
                return true;
              }
            };
            for (const meta of metasets) {
              if (dataIndex !== void 0 && skipNull(meta)) {
                continue;
              }
              if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
                stacks.push(meta.stack);
              }
              if (meta.index === last) {
                break;
              }
            }
            if (!stacks.length) {
              stacks.push(void 0);
            }
            return stacks;
          }
          _getStackCount(index3) {
            return this._getStacks(void 0, index3).length;
          }
          _getStackIndex(datasetIndex, name, dataIndex) {
            const stacks = this._getStacks(datasetIndex, dataIndex);
            const index3 = name !== void 0 ? stacks.indexOf(name) : -1;
            return index3 === -1 ? stacks.length - 1 : index3;
          }
          _getRuler() {
            const opts = this.options;
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const pixels = [];
            let i, ilen;
            for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
              pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
            }
            const barThickness = opts.barThickness;
            const min = barThickness || computeMinSampleSize(meta);
            return {
              min,
              pixels,
              start: iScale._startPixel,
              end: iScale._endPixel,
              stackCount: this._getStackCount(),
              scale: iScale,
              grouped: opts.grouped,
              ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
            };
          }
          _calculateBarValuePixels(index3) {
            const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
            const actualBase = baseValue || 0;
            const parsed = this.getParsed(index3);
            const custom = parsed._custom;
            const floating = isFloatBar(custom);
            let value = parsed[vScale.axis];
            let start = 0;
            let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
            let head, size;
            if (length !== value) {
              start = length - value;
              length = value;
            }
            if (floating) {
              value = custom.barStart;
              length = custom.barEnd - custom.barStart;
              if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
                start = 0;
              }
              start += value;
            }
            const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
            let base = vScale.getPixelForValue(startValue);
            if (this.chart.getDataVisibility(index3)) {
              head = vScale.getPixelForValue(start + length);
            } else {
              head = base;
            }
            size = head - base;
            if (Math.abs(size) < minBarLength) {
              size = barSign(size, vScale, actualBase) * minBarLength;
              if (value === actualBase) {
                base -= size / 2;
              }
              const startPixel = vScale.getPixelForDecimal(0);
              const endPixel = vScale.getPixelForDecimal(1);
              const min = Math.min(startPixel, endPixel);
              const max = Math.max(startPixel, endPixel);
              base = Math.max(Math.min(base, max), min);
              head = base + size;
            }
            if (base === vScale.getPixelForValue(actualBase)) {
              const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
              base += halfGrid;
              size -= halfGrid;
            }
            return {
              size,
              base,
              head,
              center: head + size / 2
            };
          }
          _calculateBarIndexPixels(index3, ruler) {
            const scale = ruler.scale;
            const options = this.options;
            const skipNull = options.skipNull;
            const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
            let center, size;
            if (ruler.grouped) {
              const stackCount = skipNull ? this._getStackCount(index3) : ruler.stackCount;
              const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index3, ruler, options, stackCount) : computeFitCategoryTraits(index3, ruler, options, stackCount);
              const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index3 : void 0);
              center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
              size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
            } else {
              center = scale.getPixelForValue(this.getParsed(index3)[scale.axis], index3);
              size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
            }
            return {
              base: center - size / 2,
              head: center + size / 2,
              center,
              size
            };
          }
          draw() {
            const meta = this._cachedMeta;
            const vScale = meta.vScale;
            const rects = meta.data;
            const ilen = rects.length;
            let i = 0;
            for (; i < ilen; ++i) {
              if (this.getParsed(i)[vScale.axis] !== null) {
                rects[i].draw(this._ctx);
              }
            }
          }
        }
        BarController.id = "bar";
        BarController.defaults = {
          datasetElementType: false,
          dataElementType: "bar",
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          grouped: true,
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "base", "width", "height"]
            }
          }
        };
        BarController.overrides = {
          scales: {
            _index_: {
              type: "category",
              offset: true,
              grid: {
                offset: true
              }
            },
            _value_: {
              type: "linear",
              beginAtZero: true
            }
          }
        };
        class BubbleController extends DatasetController {
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
          }
          parsePrimitiveData(meta, data, start, count) {
            const parsed = super.parsePrimitiveData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const parsed = super.parseArrayData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const parsed = super.parseObjectData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
          }
          getMaxOverflow() {
            const data = this._cachedMeta.data;
            let max = 0;
            for (let i = data.length - 1; i >= 0; --i) {
              max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            }
            return max > 0 && max;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const { xScale, yScale } = meta;
            const parsed = this.getParsed(index3);
            const x = xScale.getLabelForValue(parsed.x);
            const y = yScale.getLabelForValue(parsed.y);
            const r = parsed._custom;
            return {
              label: meta.label,
              value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
            };
          }
          update(mode) {
            const points = this._cachedMeta.data;
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const reset2 = mode === "reset";
            const { iScale, vScale } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const parsed = !reset2 && this.getParsed(i);
              const properties = {};
              const iPixel = properties[iAxis] = reset2 ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
              const vPixel = properties[vAxis] = reset2 ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
              properties.skip = isNaN(iPixel) || isNaN(vPixel);
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                if (reset2) {
                  properties.options.radius = 0;
                }
              }
              this.updateElement(point, i, properties, mode);
            }
          }
          resolveDataElementOptions(index3, mode) {
            const parsed = this.getParsed(index3);
            let values = super.resolveDataElementOptions(index3, mode);
            if (values.$shared) {
              values = Object.assign({}, values, { $shared: false });
            }
            const radius = values.radius;
            if (mode !== "active") {
              values.radius = 0;
            }
            values.radius += valueOrDefault(parsed && parsed._custom, radius);
            return values;
          }
        }
        BubbleController.id = "bubble";
        BubbleController.defaults = {
          datasetElementType: false,
          dataElementType: "point",
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "borderWidth", "radius"]
            }
          }
        };
        BubbleController.overrides = {
          scales: {
            x: {
              type: "linear"
            },
            y: {
              type: "linear"
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title() {
                  return "";
                }
              }
            }
          }
        };
        function getRatioAndOffset(rotation, circumference, cutout) {
          let ratioX = 1;
          let ratioY = 1;
          let offsetX = 0;
          let offsetY = 0;
          if (circumference < TAU) {
            const startAngle = rotation;
            const endAngle = startAngle + circumference;
            const startX = Math.cos(startAngle);
            const startY = Math.sin(startAngle);
            const endX = Math.cos(endAngle);
            const endY = Math.sin(endAngle);
            const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
            const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
            const maxX = calcMax(0, startX, endX);
            const maxY = calcMax(HALF_PI, startY, endY);
            const minX = calcMin(PI, startX, endX);
            const minY = calcMin(PI + HALF_PI, startY, endY);
            ratioX = (maxX - minX) / 2;
            ratioY = (maxY - minY) / 2;
            offsetX = -(maxX + minX) / 2;
            offsetY = -(maxY + minY) / 2;
          }
          return { ratioX, ratioY, offsetX, offsetY };
        }
        class DoughnutController extends DatasetController {
          constructor(chart2, datasetIndex) {
            super(chart2, datasetIndex);
            this.enableOptionSharing = true;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.offsetX = void 0;
            this.offsetY = void 0;
          }
          linkScales() {
          }
          parse(start, count) {
            const data = this.getDataset().data;
            const meta = this._cachedMeta;
            if (this._parsing === false) {
              meta._parsed = data;
            } else {
              let getter = (i2) => +data[i2];
              if (isObject2(data[start])) {
                const { key = "value" } = this._parsing;
                getter = (i2) => +resolveObjectKey(data[i2], key);
              }
              let i, ilen;
              for (i = start, ilen = start + count; i < ilen; ++i) {
                meta._parsed[i] = getter(i);
              }
            }
          }
          _getRotation() {
            return toRadians(this.options.rotation - 90);
          }
          _getCircumference() {
            return toRadians(this.options.circumference);
          }
          _getRotationExtents() {
            let min = TAU;
            let max = -TAU;
            for (let i = 0; i < this.chart.data.datasets.length; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                const controller = this.chart.getDatasetMeta(i).controller;
                const rotation = controller._getRotation();
                const circumference = controller._getCircumference();
                min = Math.min(min, rotation);
                max = Math.max(max, rotation + circumference);
              }
            }
            return {
              rotation: min,
              circumference: max - min
            };
          }
          update(mode) {
            const chart2 = this.chart;
            const { chartArea } = chart2;
            const meta = this._cachedMeta;
            const arcs = meta.data;
            const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
            const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
            const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
            const chartWeight = this._getRingWeight(this.index);
            const { circumference, rotation } = this._getRotationExtents();
            const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
            const maxWidth = (chartArea.width - spacing) / ratioX;
            const maxHeight = (chartArea.height - spacing) / ratioY;
            const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            const outerRadius = toDimension(this.options.radius, maxRadius);
            const innerRadius = Math.max(outerRadius * cutout, 0);
            const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
            this.offsetX = offsetX * outerRadius;
            this.offsetY = offsetY * outerRadius;
            meta.total = this.calculateTotal();
            this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
            this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          _circumference(i, reset2) {
            const opts = this.options;
            const meta = this._cachedMeta;
            const circumference = this._getCircumference();
            if (reset2 && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
              return 0;
            }
            return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
          }
          updateElements(arcs, start, count, mode) {
            const reset2 = mode === "reset";
            const chart2 = this.chart;
            const chartArea = chart2.chartArea;
            const opts = chart2.options;
            const animationOpts = opts.animation;
            const centerX = (chartArea.left + chartArea.right) / 2;
            const centerY = (chartArea.top + chartArea.bottom) / 2;
            const animateScale = reset2 && animationOpts.animateScale;
            const innerRadius = animateScale ? 0 : this.innerRadius;
            const outerRadius = animateScale ? 0 : this.outerRadius;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            let startAngle = this._getRotation();
            let i;
            for (i = 0; i < start; ++i) {
              startAngle += this._circumference(i, reset2);
            }
            for (i = start; i < start + count; ++i) {
              const circumference = this._circumference(i, reset2);
              const arc = arcs[i];
              const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius
              };
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
              }
              startAngle += circumference;
              this.updateElement(arc, i, properties, mode);
            }
          }
          calculateTotal() {
            const meta = this._cachedMeta;
            const metaData = meta.data;
            let total = 0;
            let i;
            for (i = 0; i < metaData.length; i++) {
              const value = meta._parsed[i];
              if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
                total += Math.abs(value);
              }
            }
            return total;
          }
          calculateCircumference(value) {
            const total = this._cachedMeta.total;
            if (total > 0 && !isNaN(value)) {
              return TAU * (Math.abs(value) / total);
            }
            return 0;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const chart2 = this.chart;
            const labels = chart2.data.labels || [];
            const value = formatNumber(meta._parsed[index3], chart2.options.locale);
            return {
              label: labels[index3] || "",
              value
            };
          }
          getMaxBorderWidth(arcs) {
            let max = 0;
            const chart2 = this.chart;
            let i, ilen, meta, controller, options;
            if (!arcs) {
              for (i = 0, ilen = chart2.data.datasets.length; i < ilen; ++i) {
                if (chart2.isDatasetVisible(i)) {
                  meta = chart2.getDatasetMeta(i);
                  arcs = meta.data;
                  controller = meta.controller;
                  break;
                }
              }
            }
            if (!arcs) {
              return 0;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              options = controller.resolveDataElementOptions(i);
              if (options.borderAlign !== "inner") {
                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
              }
            }
            return max;
          }
          getMaxOffset(arcs) {
            let max = 0;
            for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
              const options = this.resolveDataElementOptions(i);
              max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
            }
            return max;
          }
          _getRingWeightOffset(datasetIndex) {
            let ringWeightOffset = 0;
            for (let i = 0; i < datasetIndex; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
              }
            }
            return ringWeightOffset;
          }
          _getRingWeight(datasetIndex) {
            return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
          }
          _getVisibleDatasetWeightTotal() {
            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
          }
        }
        DoughnutController.id = "doughnut";
        DoughnutController.defaults = {
          datasetElementType: false,
          dataElementType: "arc",
          animation: {
            animateRotate: true,
            animateScale: false
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
            }
          },
          cutout: "50%",
          rotation: 0,
          circumference: 360,
          radius: "100%",
          spacing: 0,
          indexAxis: "r"
        };
        DoughnutController.descriptors = {
          _scriptable: (name) => name !== "spacing",
          _indexable: (name) => name !== "spacing"
        };
        DoughnutController.overrides = {
          aspectRatio: 1,
          plugins: {
            legend: {
              labels: {
                generateLabels(chart2) {
                  const data = chart2.data;
                  if (data.labels.length && data.datasets.length) {
                    const { labels: { pointStyle } } = chart2.legend.options;
                    return data.labels.map((label, i) => {
                      const meta = chart2.getDatasetMeta(0);
                      const style = meta.controller.getStyle(i);
                      return {
                        text: label,
                        fillStyle: style.backgroundColor,
                        strokeStyle: style.borderColor,
                        lineWidth: style.borderWidth,
                        pointStyle,
                        hidden: !chart2.getDataVisibility(i),
                        index: i
                      };
                    });
                  }
                  return [];
                }
              },
              onClick(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
              }
            },
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(tooltipItem) {
                  let dataLabel = tooltipItem.label;
                  const value = ": " + tooltipItem.formattedValue;
                  if (isArray(dataLabel)) {
                    dataLabel = dataLabel.slice();
                    dataLabel[0] += value;
                  } else {
                    dataLabel += value;
                  }
                  return dataLabel;
                }
              }
            }
          }
        };
        class LineController extends DatasetController {
          initialize() {
            this.enableOptionSharing = true;
            this.supportsDecimation = true;
            super.initialize();
          }
          update(mode) {
            const meta = this._cachedMeta;
            const { dataset: line, data: points = [], _dataset } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
            this._drawStart = start;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
              start = 0;
              count = points.length;
            }
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
              options.borderWidth = 0;
            }
            options.segment = this.options.segment;
            this.updateElement(line, void 0, {
              animated: !animationsDisabled,
              options
            }, mode);
            this.updateElements(points, start, count, mode);
          }
          updateElements(points, start, count, mode) {
            const reset2 = mode === "reset";
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
            const directUpdate = this.chart._animationsDisabled || reset2 || mode === "none";
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = start; i < start + count; ++i) {
              const point = points[i];
              const parsed = this.getParsed(i);
              const properties = directUpdate ? point : {};
              const nullData = isNullOrUndef(parsed[vAxis]);
              const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
              const vPixel = properties[vAxis] = reset2 || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
              }
              if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
            }
          }
          getMaxOverflow() {
            const meta = this._cachedMeta;
            const dataset = meta.dataset;
            const border = dataset.options && dataset.options.borderWidth || 0;
            const data = meta.data || [];
            if (!data.length) {
              return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2;
          }
          draw() {
            const meta = this._cachedMeta;
            meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
            super.draw();
          }
        }
        LineController.id = "line";
        LineController.defaults = {
          datasetElementType: "line",
          dataElementType: "point",
          showLine: true,
          spanGaps: false
        };
        LineController.overrides = {
          scales: {
            _index_: {
              type: "category"
            },
            _value_: {
              type: "linear"
            }
          }
        };
        class PolarAreaController extends DatasetController {
          constructor(chart2, datasetIndex) {
            super(chart2, datasetIndex);
            this.innerRadius = void 0;
            this.outerRadius = void 0;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const chart2 = this.chart;
            const labels = chart2.data.labels || [];
            const value = formatNumber(meta._parsed[index3].r, chart2.options.locale);
            return {
              label: labels[index3] || "",
              value
            };
          }
          parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
          }
          update(mode) {
            const arcs = this._cachedMeta.data;
            this._updateRadius();
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          getMinMax() {
            const meta = this._cachedMeta;
            const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
            meta.data.forEach((element, index3) => {
              const parsed = this.getParsed(index3).r;
              if (!isNaN(parsed) && this.chart.getDataVisibility(index3)) {
                if (parsed < range2.min) {
                  range2.min = parsed;
                }
                if (parsed > range2.max) {
                  range2.max = parsed;
                }
              }
            });
            return range2;
          }
          _updateRadius() {
            const chart2 = this.chart;
            const chartArea = chart2.chartArea;
            const opts = chart2.options;
            const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            const outerRadius = Math.max(minSize / 2, 0);
            const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            const radiusLength = (outerRadius - innerRadius) / chart2.getVisibleDatasetCount();
            this.outerRadius = outerRadius - radiusLength * this.index;
            this.innerRadius = this.outerRadius - radiusLength;
          }
          updateElements(arcs, start, count, mode) {
            const reset2 = mode === "reset";
            const chart2 = this.chart;
            const opts = chart2.options;
            const animationOpts = opts.animation;
            const scale = this._cachedMeta.rScale;
            const centerX = scale.xCenter;
            const centerY = scale.yCenter;
            const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
            let angle = datasetStartAngle;
            let i;
            const defaultAngle = 360 / this.countVisibleElements();
            for (i = 0; i < start; ++i) {
              angle += this._computeAngle(i, mode, defaultAngle);
            }
            for (i = start; i < start + count; i++) {
              const arc = arcs[i];
              let startAngle = angle;
              let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
              let outerRadius = chart2.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
              angle = endAngle;
              if (reset2) {
                if (animationOpts.animateScale) {
                  outerRadius = 0;
                }
                if (animationOpts.animateRotate) {
                  startAngle = endAngle = datasetStartAngle;
                }
              }
              const properties = {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle,
                options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
              };
              this.updateElement(arc, i, properties, mode);
            }
          }
          countVisibleElements() {
            const meta = this._cachedMeta;
            let count = 0;
            meta.data.forEach((element, index3) => {
              if (!isNaN(this.getParsed(index3).r) && this.chart.getDataVisibility(index3)) {
                count++;
              }
            });
            return count;
          }
          _computeAngle(index3, mode, defaultAngle) {
            return this.chart.getDataVisibility(index3) ? toRadians(this.resolveDataElementOptions(index3, mode).angle || defaultAngle) : 0;
          }
        }
        PolarAreaController.id = "polarArea";
        PolarAreaController.defaults = {
          dataElementType: "arc",
          animation: {
            animateRotate: true,
            animateScale: true
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
            }
          },
          indexAxis: "r",
          startAngle: 0
        };
        PolarAreaController.overrides = {
          aspectRatio: 1,
          plugins: {
            legend: {
              labels: {
                generateLabels(chart2) {
                  const data = chart2.data;
                  if (data.labels.length && data.datasets.length) {
                    const { labels: { pointStyle } } = chart2.legend.options;
                    return data.labels.map((label, i) => {
                      const meta = chart2.getDatasetMeta(0);
                      const style = meta.controller.getStyle(i);
                      return {
                        text: label,
                        fillStyle: style.backgroundColor,
                        strokeStyle: style.borderColor,
                        lineWidth: style.borderWidth,
                        pointStyle,
                        hidden: !chart2.getDataVisibility(i),
                        index: i
                      };
                    });
                  }
                  return [];
                }
              },
              onClick(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
              }
            },
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(context) {
                  return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
                }
              }
            }
          },
          scales: {
            r: {
              type: "radialLinear",
              angleLines: {
                display: false
              },
              beginAtZero: true,
              grid: {
                circular: true
              },
              pointLabels: {
                display: false
              },
              startAngle: 0
            }
          }
        };
        class PieController extends DoughnutController {
        }
        PieController.id = "pie";
        PieController.defaults = {
          cutout: 0,
          rotation: 0,
          circumference: 360,
          radius: "100%"
        };
        class RadarController extends DatasetController {
          getLabelAndValue(index3) {
            const vScale = this._cachedMeta.vScale;
            const parsed = this.getParsed(index3);
            return {
              label: vScale.getLabels()[index3],
              value: "" + vScale.getLabelForValue(parsed[vScale.axis])
            };
          }
          parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
          }
          update(mode) {
            const meta = this._cachedMeta;
            const line = meta.dataset;
            const points = meta.data || [];
            const labels = meta.iScale.getLabels();
            line.points = points;
            if (mode !== "resize") {
              const options = this.resolveDatasetElementOptions(mode);
              if (!this.options.showLine) {
                options.borderWidth = 0;
              }
              const properties = {
                _loop: true,
                _fullLoop: labels.length === points.length,
                options
              };
              this.updateElement(line, void 0, properties, mode);
            }
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const scale = this._cachedMeta.rScale;
            const reset2 = mode === "reset";
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
              const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
              const x = reset2 ? scale.xCenter : pointPosition.x;
              const y = reset2 ? scale.yCenter : pointPosition.y;
              const properties = {
                x,
                y,
                angle: pointPosition.angle,
                skip: isNaN(x) || isNaN(y),
                options
              };
              this.updateElement(point, i, properties, mode);
            }
          }
        }
        RadarController.id = "radar";
        RadarController.defaults = {
          datasetElementType: "line",
          dataElementType: "point",
          indexAxis: "r",
          showLine: true,
          elements: {
            line: {
              fill: "start"
            }
          }
        };
        RadarController.overrides = {
          aspectRatio: 1,
          scales: {
            r: {
              type: "radialLinear"
            }
          }
        };
        class ScatterController extends DatasetController {
          update(mode) {
            const meta = this._cachedMeta;
            const { data: points = [] } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
            this._drawStart = start;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
              start = 0;
              count = points.length;
            }
            if (this.options.showLine) {
              const { dataset: line, _dataset } = meta;
              line._chart = this.chart;
              line._datasetIndex = this.index;
              line._decimated = !!_dataset._decimated;
              line.points = points;
              const options = this.resolveDatasetElementOptions(mode);
              options.segment = this.options.segment;
              this.updateElement(line, void 0, {
                animated: !animationsDisabled,
                options
              }, mode);
            }
            this.updateElements(points, start, count, mode);
          }
          addElements() {
            const { showLine } = this.options;
            if (!this.datasetElementType && showLine) {
              this.datasetElementType = registry.getElement("line");
            }
            super.addElements();
          }
          updateElements(points, start, count, mode) {
            const reset2 = mode === "reset";
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
            const directUpdate = this.chart._animationsDisabled || reset2 || mode === "none";
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = start; i < start + count; ++i) {
              const point = points[i];
              const parsed = this.getParsed(i);
              const properties = directUpdate ? point : {};
              const nullData = isNullOrUndef(parsed[vAxis]);
              const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
              const vPixel = properties[vAxis] = reset2 || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
              }
              if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
          }
          getMaxOverflow() {
            const meta = this._cachedMeta;
            const data = meta.data || [];
            if (!this.options.showLine) {
              let max = 0;
              for (let i = data.length - 1; i >= 0; --i) {
                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
              }
              return max > 0 && max;
            }
            const dataset = meta.dataset;
            const border = dataset.options && dataset.options.borderWidth || 0;
            if (!data.length) {
              return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2;
          }
        }
        ScatterController.id = "scatter";
        ScatterController.defaults = {
          datasetElementType: false,
          dataElementType: "point",
          showLine: false,
          fill: false
        };
        ScatterController.overrides = {
          interaction: {
            mode: "point"
          },
          plugins: {
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(item) {
                  return "(" + item.label + ", " + item.formattedValue + ")";
                }
              }
            }
          },
          scales: {
            x: {
              type: "linear"
            },
            y: {
              type: "linear"
            }
          }
        };
        var controllers = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          BarController,
          BubbleController,
          DoughnutController,
          LineController,
          PolarAreaController,
          PieController,
          RadarController,
          ScatterController
        });
        function clipArc(ctx, element, endAngle) {
          const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
          let angleMargin = pixelMargin / outerRadius;
          ctx.beginPath();
          ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
          if (innerRadius > pixelMargin) {
            angleMargin = pixelMargin / innerRadius;
            ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
          } else {
            ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
          }
          ctx.closePath();
          ctx.clip();
        }
        function toRadiusCorners(value) {
          return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
        }
        function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
          const o = toRadiusCorners(arc.options.borderRadius);
          const halfThickness = (outerRadius - innerRadius) / 2;
          const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
          const computeOuterLimit = (val) => {
            const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
            return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
          };
          return {
            outerStart: computeOuterLimit(o.outerStart),
            outerEnd: computeOuterLimit(o.outerEnd),
            innerStart: _limitValue(o.innerStart, 0, innerLimit),
            innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
          };
        }
        function rThetaToXY(r, theta, x, y) {
          return {
            x: x + r * Math.cos(theta),
            y: y + r * Math.sin(theta)
          };
        }
        function pathArc(ctx, element, offset, spacing, end, circular) {
          const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
          const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
          const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
          let spacingOffset = 0;
          const alpha2 = end - start;
          if (spacing) {
            const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
            const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
            const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
            const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
            spacingOffset = (alpha2 - adjustedAngle) / 2;
          }
          const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
          const angleOffset = (alpha2 - beta) / 2;
          const startAngle = start + angleOffset + spacingOffset;
          const endAngle = end - angleOffset - spacingOffset;
          const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
          const outerStartAdjustedRadius = outerRadius - outerStart;
          const outerEndAdjustedRadius = outerRadius - outerEnd;
          const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
          const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
          const innerStartAdjustedRadius = innerRadius + innerStart;
          const innerEndAdjustedRadius = innerRadius + innerEnd;
          const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
          const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
          ctx.beginPath();
          if (circular) {
            ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
            if (outerEnd > 0) {
              const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
            }
            const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
            ctx.lineTo(p4.x, p4.y);
            if (innerEnd > 0) {
              const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
            }
            ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
            if (innerStart > 0) {
              const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
            }
            const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
            ctx.lineTo(p8.x, p8.y);
            if (outerStart > 0) {
              const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
            }
          } else {
            ctx.moveTo(x, y);
            const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
            const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerStartX, outerStartY);
            const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
            const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerEndX, outerEndY);
          }
          ctx.closePath();
        }
        function drawArc(ctx, element, offset, spacing, circular) {
          const { fullCircles, startAngle, circumference } = element;
          let endAngle = element.endAngle;
          if (fullCircles) {
            pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);
            for (let i = 0; i < fullCircles; ++i) {
              ctx.fill();
            }
            if (!isNaN(circumference)) {
              endAngle = startAngle + circumference % TAU;
              if (circumference % TAU === 0) {
                endAngle += TAU;
              }
            }
          }
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          ctx.fill();
          return endAngle;
        }
        function drawFullCircleBorders(ctx, element, inner) {
          const { x, y, startAngle, pixelMargin, fullCircles } = element;
          const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
          const innerRadius = element.innerRadius + pixelMargin;
          let i;
          if (inner) {
            clipArc(ctx, element, startAngle + TAU);
          }
          ctx.beginPath();
          ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
          for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
          for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
          }
        }
        function drawBorder(ctx, element, offset, spacing, endAngle, circular) {
          const { options } = element;
          const { borderWidth, borderJoinStyle } = options;
          const inner = options.borderAlign === "inner";
          if (!borderWidth) {
            return;
          }
          if (inner) {
            ctx.lineWidth = borderWidth * 2;
            ctx.lineJoin = borderJoinStyle || "round";
          } else {
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = borderJoinStyle || "bevel";
          }
          if (element.fullCircles) {
            drawFullCircleBorders(ctx, element, inner);
          }
          if (inner) {
            clipArc(ctx, element, endAngle);
          }
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          ctx.stroke();
        }
        class ArcElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.circumference = void 0;
            this.startAngle = void 0;
            this.endAngle = void 0;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.pixelMargin = 0;
            this.fullCircles = 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(chartX, chartY, useFinalPosition) {
            const point = this.getProps(["x", "y"], useFinalPosition);
            const { angle, distance: distance2 } = getAngleFromPoint(point, { x: chartX, y: chartY });
            const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "circumference"
            ], useFinalPosition);
            const rAdjust = this.options.spacing / 2;
            const _circumference = valueOrDefault(circumference, endAngle - startAngle);
            const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
            const withinRadius = _isBetween(distance2, innerRadius + rAdjust, outerRadius + rAdjust);
            return betweenAngles && withinRadius;
          }
          getCenterPoint(useFinalPosition) {
            const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
              "x",
              "y",
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "circumference"
            ], useFinalPosition);
            const { offset, spacing } = this.options;
            const halfAngle = (startAngle + endAngle) / 2;
            const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
            return {
              x: x + Math.cos(halfAngle) * halfRadius,
              y: y + Math.sin(halfAngle) * halfRadius
            };
          }
          tooltipPosition(useFinalPosition) {
            return this.getCenterPoint(useFinalPosition);
          }
          draw(ctx) {
            const { options, circumference } = this;
            const offset = (options.offset || 0) / 2;
            const spacing = (options.spacing || 0) / 2;
            const circular = options.circular;
            this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
            this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
            if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
              return;
            }
            ctx.save();
            let radiusOffset = 0;
            if (offset) {
              radiusOffset = offset / 2;
              const halfAngle = (this.startAngle + this.endAngle) / 2;
              ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
              if (this.circumference >= PI) {
                radiusOffset = offset;
              }
            }
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
            drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
            ctx.restore();
          }
        }
        ArcElement.id = "arc";
        ArcElement.defaults = {
          borderAlign: "center",
          borderColor: "#fff",
          borderJoinStyle: void 0,
          borderRadius: 0,
          borderWidth: 2,
          offset: 0,
          spacing: 0,
          angle: void 0,
          circular: true
        };
        ArcElement.defaultRoutes = {
          backgroundColor: "backgroundColor"
        };
        function setStyle(ctx, options, style = options) {
          ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
          ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
          ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
          ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
          ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
          ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
        }
        function lineTo(ctx, previous, target) {
          ctx.lineTo(target.x, target.y);
        }
        function getLineMethod(options) {
          if (options.stepped) {
            return _steppedLineTo;
          }
          if (options.tension || options.cubicInterpolationMode === "monotone") {
            return _bezierCurveTo;
          }
          return lineTo;
        }
        function pathVars(points, segment, params = {}) {
          const count = points.length;
          const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
          const { start: segmentStart, end: segmentEnd } = segment;
          const start = Math.max(paramsStart, segmentStart);
          const end = Math.min(paramsEnd, segmentEnd);
          const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
          return {
            count,
            start,
            loop: segment.loop,
            ilen: end < start && !outside ? count + end - start : end - start
          };
        }
        function pathSegment(ctx, line, segment, params) {
          const { points, options } = line;
          const { count, start, loop, ilen } = pathVars(points, segment, params);
          const lineMethod = getLineMethod(options);
          let { move: move2 = true, reverse } = params || {};
          let i, point, prev;
          for (i = 0; i <= ilen; ++i) {
            point = points[(start + (reverse ? ilen - i : i)) % count];
            if (point.skip) {
              continue;
            } else if (move2) {
              ctx.moveTo(point.x, point.y);
              move2 = false;
            } else {
              lineMethod(ctx, prev, point, reverse, options.stepped);
            }
            prev = point;
          }
          if (loop) {
            point = points[(start + (reverse ? ilen : 0)) % count];
            lineMethod(ctx, prev, point, reverse, options.stepped);
          }
          return !!loop;
        }
        function fastPathSegment(ctx, line, segment, params) {
          const points = line.points;
          const { count, start, ilen } = pathVars(points, segment, params);
          const { move: move2 = true, reverse } = params || {};
          let avgX = 0;
          let countX = 0;
          let i, point, prevX, minY, maxY, lastY;
          const pointIndex = (index3) => (start + (reverse ? ilen - index3 : index3)) % count;
          const drawX = () => {
            if (minY !== maxY) {
              ctx.lineTo(avgX, maxY);
              ctx.lineTo(avgX, minY);
              ctx.lineTo(avgX, lastY);
            }
          };
          if (move2) {
            point = points[pointIndex(0)];
            ctx.moveTo(point.x, point.y);
          }
          for (i = 0; i <= ilen; ++i) {
            point = points[pointIndex(i)];
            if (point.skip) {
              continue;
            }
            const x = point.x;
            const y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y < minY) {
                minY = y;
              } else if (y > maxY) {
                maxY = y;
              }
              avgX = (countX * avgX + x) / ++countX;
            } else {
              drawX();
              ctx.lineTo(x, y);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
            }
            lastY = y;
          }
          drawX();
        }
        function _getSegmentMethod(line) {
          const opts = line.options;
          const borderDash = opts.borderDash && opts.borderDash.length;
          const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
          return useFastPath ? fastPathSegment : pathSegment;
        }
        function _getInterpolationMethod(options) {
          if (options.stepped) {
            return _steppedInterpolation;
          }
          if (options.tension || options.cubicInterpolationMode === "monotone") {
            return _bezierInterpolation;
          }
          return _pointInLine;
        }
        function strokePathWithCache(ctx, line, start, count) {
          let path = line._path;
          if (!path) {
            path = line._path = new Path2D();
            if (line.path(path, start, count)) {
              path.closePath();
            }
          }
          setStyle(ctx, line.options);
          ctx.stroke(path);
        }
        function strokePathDirect(ctx, line, start, count) {
          const { segments, options } = line;
          const segmentMethod = _getSegmentMethod(line);
          for (const segment of segments) {
            setStyle(ctx, options, segment.style);
            ctx.beginPath();
            if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
              ctx.closePath();
            }
            ctx.stroke();
          }
        }
        const usePath2D = typeof Path2D === "function";
        function draw(ctx, line, start, count) {
          if (usePath2D && !line.options.segment) {
            strokePathWithCache(ctx, line, start, count);
          } else {
            strokePathDirect(ctx, line, start, count);
          }
        }
        class LineElement extends Element2 {
          constructor(cfg) {
            super();
            this.animated = true;
            this.options = void 0;
            this._chart = void 0;
            this._loop = void 0;
            this._fullLoop = void 0;
            this._path = void 0;
            this._points = void 0;
            this._segments = void 0;
            this._decimated = false;
            this._pointsUpdated = false;
            this._datasetIndex = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          updateControlPoints(chartArea, indexAxis) {
            const options = this.options;
            if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
              const loop = options.spanGaps ? this._loop : this._fullLoop;
              _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
              this._pointsUpdated = true;
            }
          }
          set points(points) {
            this._points = points;
            delete this._segments;
            delete this._path;
            this._pointsUpdated = false;
          }
          get points() {
            return this._points;
          }
          get segments() {
            return this._segments || (this._segments = _computeSegments(this, this.options.segment));
          }
          first() {
            const segments = this.segments;
            const points = this.points;
            return segments.length && points[segments[0].start];
          }
          last() {
            const segments = this.segments;
            const points = this.points;
            const count = segments.length;
            return count && points[segments[count - 1].end];
          }
          interpolate(point, property) {
            const options = this.options;
            const value = point[property];
            const points = this.points;
            const segments = _boundSegments(this, { property, start: value, end: value });
            if (!segments.length) {
              return;
            }
            const result = [];
            const _interpolate = _getInterpolationMethod(options);
            let i, ilen;
            for (i = 0, ilen = segments.length; i < ilen; ++i) {
              const { start, end } = segments[i];
              const p1 = points[start];
              const p2 = points[end];
              if (p1 === p2) {
                result.push(p1);
                continue;
              }
              const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
              const interpolated = _interpolate(p1, p2, t, options.stepped);
              interpolated[property] = point[property];
              result.push(interpolated);
            }
            return result.length === 1 ? result[0] : result;
          }
          pathSegment(ctx, segment, params) {
            const segmentMethod = _getSegmentMethod(this);
            return segmentMethod(ctx, this, segment, params);
          }
          path(ctx, start, count) {
            const segments = this.segments;
            const segmentMethod = _getSegmentMethod(this);
            let loop = this._loop;
            start = start || 0;
            count = count || this.points.length - start;
            for (const segment of segments) {
              loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
            }
            return !!loop;
          }
          draw(ctx, chartArea, start, count) {
            const options = this.options || {};
            const points = this.points || [];
            if (points.length && options.borderWidth) {
              ctx.save();
              draw(ctx, this, start, count);
              ctx.restore();
            }
            if (this.animated) {
              this._pointsUpdated = false;
              this._path = void 0;
            }
          }
        }
        LineElement.id = "line";
        LineElement.defaults = {
          borderCapStyle: "butt",
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: "miter",
          borderWidth: 3,
          capBezierPoints: true,
          cubicInterpolationMode: "default",
          fill: false,
          spanGaps: false,
          stepped: false,
          tension: 0
        };
        LineElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        LineElement.descriptors = {
          _scriptable: true,
          _indexable: (name) => name !== "borderDash" && name !== "fill"
        };
        function inRange$1(el, pos, axis, useFinalPosition) {
          const options = el.options;
          const { [axis]: value } = el.getProps([axis], useFinalPosition);
          return Math.abs(pos - value) < options.radius + options.hitRadius;
        }
        class PointElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.parsed = void 0;
            this.skip = void 0;
            this.stop = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            const options = this.options;
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange$1(this, mouseX, "x", useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange$1(this, mouseY, "y", useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return { x, y };
          }
          size(options) {
            options = options || this.options || {};
            let radius = options.radius || 0;
            radius = Math.max(radius, radius && options.hoverRadius || 0);
            const borderWidth = radius && options.borderWidth || 0;
            return (radius + borderWidth) * 2;
          }
          draw(ctx, area) {
            const options = this.options;
            if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
              return;
            }
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.fillStyle = options.backgroundColor;
            drawPoint(ctx, options, this.x, this.y);
          }
          getRange() {
            const options = this.options || {};
            return options.radius + options.hitRadius;
          }
        }
        PointElement.id = "point";
        PointElement.defaults = {
          borderWidth: 1,
          hitRadius: 1,
          hoverBorderWidth: 1,
          hoverRadius: 4,
          pointStyle: "circle",
          radius: 3,
          rotation: 0
        };
        PointElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        function getBarBounds(bar, useFinalPosition) {
          const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
          let left, right, top, bottom, half;
          if (bar.horizontal) {
            half = height / 2;
            left = Math.min(x, base);
            right = Math.max(x, base);
            top = y - half;
            bottom = y + half;
          } else {
            half = width / 2;
            left = x - half;
            right = x + half;
            top = Math.min(y, base);
            bottom = Math.max(y, base);
          }
          return { left, top, right, bottom };
        }
        function skipOrLimit(skip2, value, min, max) {
          return skip2 ? 0 : _limitValue(value, min, max);
        }
        function parseBorderWidth(bar, maxW, maxH) {
          const value = bar.options.borderWidth;
          const skip2 = bar.borderSkipped;
          const o = toTRBL(value);
          return {
            t: skipOrLimit(skip2.top, o.top, 0, maxH),
            r: skipOrLimit(skip2.right, o.right, 0, maxW),
            b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
            l: skipOrLimit(skip2.left, o.left, 0, maxW)
          };
        }
        function parseBorderRadius(bar, maxW, maxH) {
          const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
          const value = bar.options.borderRadius;
          const o = toTRBLCorners(value);
          const maxR = Math.min(maxW, maxH);
          const skip2 = bar.borderSkipped;
          const enableBorder = enableBorderRadius || isObject2(value);
          return {
            topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
            topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
            bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
            bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
          };
        }
        function boundingRects(bar) {
          const bounds = getBarBounds(bar);
          const width = bounds.right - bounds.left;
          const height = bounds.bottom - bounds.top;
          const border = parseBorderWidth(bar, width / 2, height / 2);
          const radius = parseBorderRadius(bar, width / 2, height / 2);
          return {
            outer: {
              x: bounds.left,
              y: bounds.top,
              w: width,
              h: height,
              radius
            },
            inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width - border.l - border.r,
              h: height - border.t - border.b,
              radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
              }
            }
          };
        }
        function inRange(bar, x, y, useFinalPosition) {
          const skipX = x === null;
          const skipY = y === null;
          const skipBoth = skipX && skipY;
          const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
          return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
        }
        function hasRadius(radius) {
          return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
        }
        function addNormalRectPath(ctx, rect) {
          ctx.rect(rect.x, rect.y, rect.w, rect.h);
        }
        function inflateRect(rect, amount, refRect = {}) {
          const x = rect.x !== refRect.x ? -amount : 0;
          const y = rect.y !== refRect.y ? -amount : 0;
          const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
          const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
          return {
            x: rect.x + x,
            y: rect.y + y,
            w: rect.w + w,
            h: rect.h + h,
            radius: rect.radius
          };
        }
        class BarElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.horizontal = void 0;
            this.base = void 0;
            this.width = void 0;
            this.height = void 0;
            this.inflateAmount = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          draw(ctx) {
            const { inflateAmount, options: { borderColor, backgroundColor } } = this;
            const { inner, outer } = boundingRects(this);
            const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
            ctx.save();
            if (outer.w !== inner.w || outer.h !== inner.h) {
              ctx.beginPath();
              addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
              ctx.clip();
              addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
              ctx.fillStyle = borderColor;
              ctx.fill("evenodd");
            }
            ctx.beginPath();
            addRectPath(ctx, inflateRect(inner, inflateAmount));
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            return inRange(this, mouseX, mouseY, useFinalPosition);
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange(this, mouseX, null, useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange(this, null, mouseY, useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
            return {
              x: horizontal ? (x + base) / 2 : x,
              y: horizontal ? y : (y + base) / 2
            };
          }
          getRange(axis) {
            return axis === "x" ? this.width / 2 : this.height / 2;
          }
        }
        BarElement.id = "bar";
        BarElement.defaults = {
          borderSkipped: "start",
          borderWidth: 0,
          borderRadius: 0,
          inflateAmount: "auto",
          pointStyle: void 0
        };
        BarElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        var elements = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          ArcElement,
          LineElement,
          PointElement,
          BarElement
        });
        function lttbDecimation(data, start, count, availableWidth, options) {
          const samples = options.samples || availableWidth;
          if (samples >= count) {
            return data.slice(start, start + count);
          }
          const decimated = [];
          const bucketWidth = (count - 2) / (samples - 2);
          let sampledIndex = 0;
          const endIndex = start + count - 1;
          let a = start;
          let i, maxAreaPoint, maxArea, area, nextA;
          decimated[sampledIndex++] = data[a];
          for (i = 0; i < samples - 2; i++) {
            let avgX = 0;
            let avgY = 0;
            let j;
            const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
            const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
            const avgRangeLength = avgRangeEnd - avgRangeStart;
            for (j = avgRangeStart; j < avgRangeEnd; j++) {
              avgX += data[j].x;
              avgY += data[j].y;
            }
            avgX /= avgRangeLength;
            avgY /= avgRangeLength;
            const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
            const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
            const { x: pointAx, y: pointAy } = data[a];
            maxArea = area = -1;
            for (j = rangeOffs; j < rangeTo; j++) {
              area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
              if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j];
                nextA = j;
              }
            }
            decimated[sampledIndex++] = maxAreaPoint;
            a = nextA;
          }
          decimated[sampledIndex++] = data[endIndex];
          return decimated;
        }
        function minMaxDecimation(data, start, count, availableWidth) {
          let avgX = 0;
          let countX = 0;
          let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
          const decimated = [];
          const endIndex = start + count - 1;
          const xMin = data[start].x;
          const xMax = data[endIndex].x;
          const dx = xMax - xMin;
          for (i = start; i < start + count; ++i) {
            point = data[i];
            x = (point.x - xMin) / dx * availableWidth;
            y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y < minY) {
                minY = y;
                minIndex = i;
              } else if (y > maxY) {
                maxY = y;
                maxIndex = i;
              }
              avgX = (countX * avgX + point.x) / ++countX;
            } else {
              const lastIndex = i - 1;
              if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
                const intermediateIndex1 = Math.min(minIndex, maxIndex);
                const intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                  decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
                    x: avgX
                  }));
                }
                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                  decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
                    x: avgX
                  }));
                }
              }
              if (i > 0 && lastIndex !== startIndex) {
                decimated.push(data[lastIndex]);
              }
              decimated.push(point);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
              minIndex = maxIndex = startIndex = i;
            }
          }
          return decimated;
        }
        function cleanDecimatedDataset(dataset) {
          if (dataset._decimated) {
            const data = dataset._data;
            delete dataset._decimated;
            delete dataset._data;
            Object.defineProperty(dataset, "data", { value: data });
          }
        }
        function cleanDecimatedData(chart2) {
          chart2.data.datasets.forEach((dataset) => {
            cleanDecimatedDataset(dataset);
          });
        }
        function getStartAndCountOfVisiblePointsSimplified(meta, points) {
          const pointCount = points.length;
          let start = 0;
          let count;
          const { iScale } = meta;
          const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
          if (minDefined) {
            start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
          }
          if (maxDefined) {
            count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
          } else {
            count = pointCount - start;
          }
          return { start, count };
        }
        var plugin_decimation = {
          id: "decimation",
          defaults: {
            algorithm: "min-max",
            enabled: false
          },
          beforeElementsUpdate: (chart2, args, options) => {
            if (!options.enabled) {
              cleanDecimatedData(chart2);
              return;
            }
            const availableWidth = chart2.width;
            chart2.data.datasets.forEach((dataset, datasetIndex) => {
              const { _data, indexAxis } = dataset;
              const meta = chart2.getDatasetMeta(datasetIndex);
              const data = _data || dataset.data;
              if (resolve([indexAxis, chart2.options.indexAxis]) === "y") {
                return;
              }
              if (!meta.controller.supportsDecimation) {
                return;
              }
              const xAxis = chart2.scales[meta.xAxisID];
              if (xAxis.type !== "linear" && xAxis.type !== "time") {
                return;
              }
              if (chart2.options.parsing) {
                return;
              }
              let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
              const threshold = options.threshold || 4 * availableWidth;
              if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
              }
              if (isNullOrUndef(_data)) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, "data", {
                  configurable: true,
                  enumerable: true,
                  get: function() {
                    return this._decimated;
                  },
                  set: function(d) {
                    this._data = d;
                  }
                });
              }
              let decimated;
              switch (options.algorithm) {
                case "lttb":
                  decimated = lttbDecimation(data, start, count, availableWidth, options);
                  break;
                case "min-max":
                  decimated = minMaxDecimation(data, start, count, availableWidth);
                  break;
                default:
                  throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
              }
              dataset._decimated = decimated;
            });
          },
          destroy(chart2) {
            cleanDecimatedData(chart2);
          }
        };
        function _segments(line, target, property) {
          const segments = line.segments;
          const points = line.points;
          const tpoints = target.points;
          const parts = [];
          for (const segment of segments) {
            let { start, end } = segment;
            end = _findSegmentEnd(start, end, points);
            const bounds = _getBounds(property, points[start], points[end], segment.loop);
            if (!target.segments) {
              parts.push({
                source: segment,
                target: bounds,
                start: points[start],
                end: points[end]
              });
              continue;
            }
            const targetSegments = _boundSegments(target, bounds);
            for (const tgt of targetSegments) {
              const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
              const fillSources = _boundSegment(segment, points, subBounds);
              for (const fillSource of fillSources) {
                parts.push({
                  source: fillSource,
                  target: tgt,
                  start: {
                    [property]: _getEdge(bounds, subBounds, "start", Math.max)
                  },
                  end: {
                    [property]: _getEdge(bounds, subBounds, "end", Math.min)
                  }
                });
              }
            }
          }
          return parts;
        }
        function _getBounds(property, first, last, loop) {
          if (loop) {
            return;
          }
          let start = first[property];
          let end = last[property];
          if (property === "angle") {
            start = _normalizeAngle(start);
            end = _normalizeAngle(end);
          }
          return { property, start, end };
        }
        function _pointsFromSegments(boundary, line) {
          const { x = null, y = null } = boundary || {};
          const linePoints = line.points;
          const points = [];
          line.segments.forEach(({ start, end }) => {
            end = _findSegmentEnd(start, end, linePoints);
            const first = linePoints[start];
            const last = linePoints[end];
            if (y !== null) {
              points.push({ x: first.x, y });
              points.push({ x: last.x, y });
            } else if (x !== null) {
              points.push({ x, y: first.y });
              points.push({ x, y: last.y });
            }
          });
          return points;
        }
        function _findSegmentEnd(start, end, points) {
          for (; end > start; end--) {
            const point = points[end];
            if (!isNaN(point.x) && !isNaN(point.y)) {
              break;
            }
          }
          return end;
        }
        function _getEdge(a, b, prop, fn) {
          if (a && b) {
            return fn(a[prop], b[prop]);
          }
          return a ? a[prop] : b ? b[prop] : 0;
        }
        function _createBoundaryLine(boundary, line) {
          let points = [];
          let _loop = false;
          if (isArray(boundary)) {
            _loop = true;
            points = boundary;
          } else {
            points = _pointsFromSegments(boundary, line);
          }
          return points.length ? new LineElement({
            points,
            options: { tension: 0 },
            _loop,
            _fullLoop: _loop
          }) : null;
        }
        function _shouldApplyFill(source) {
          return source && source.fill !== false;
        }
        function _resolveTarget(sources, index3, propagate) {
          const source = sources[index3];
          let fill2 = source.fill;
          const visited = [index3];
          let target;
          if (!propagate) {
            return fill2;
          }
          while (fill2 !== false && visited.indexOf(fill2) === -1) {
            if (!isNumberFinite(fill2)) {
              return fill2;
            }
            target = sources[fill2];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill2;
            }
            visited.push(fill2);
            fill2 = target.fill;
          }
          return false;
        }
        function _decodeFill(line, index3, count) {
          const fill2 = parseFillOption(line);
          if (isObject2(fill2)) {
            return isNaN(fill2.value) ? false : fill2;
          }
          let target = parseFloat(fill2);
          if (isNumberFinite(target) && Math.floor(target) === target) {
            return decodeTargetIndex(fill2[0], index3, target, count);
          }
          return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
        }
        function decodeTargetIndex(firstCh, index3, target, count) {
          if (firstCh === "-" || firstCh === "+") {
            target = index3 + target;
          }
          if (target === index3 || target < 0 || target >= count) {
            return false;
          }
          return target;
        }
        function _getTargetPixel(fill2, scale) {
          let pixel = null;
          if (fill2 === "start") {
            pixel = scale.bottom;
          } else if (fill2 === "end") {
            pixel = scale.top;
          } else if (isObject2(fill2)) {
            pixel = scale.getPixelForValue(fill2.value);
          } else if (scale.getBasePixel) {
            pixel = scale.getBasePixel();
          }
          return pixel;
        }
        function _getTargetValue(fill2, scale, startValue) {
          let value;
          if (fill2 === "start") {
            value = startValue;
          } else if (fill2 === "end") {
            value = scale.options.reverse ? scale.min : scale.max;
          } else if (isObject2(fill2)) {
            value = fill2.value;
          } else {
            value = scale.getBaseValue();
          }
          return value;
        }
        function parseFillOption(line) {
          const options = line.options;
          const fillOption = options.fill;
          let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
          if (fill2 === void 0) {
            fill2 = !!options.backgroundColor;
          }
          if (fill2 === false || fill2 === null) {
            return false;
          }
          if (fill2 === true) {
            return "origin";
          }
          return fill2;
        }
        function _buildStackLine(source) {
          const { scale, index: index3, line } = source;
          const points = [];
          const segments = line.segments;
          const sourcePoints = line.points;
          const linesBelow = getLinesBelow(scale, index3);
          linesBelow.push(_createBoundaryLine({ x: null, y: scale.bottom }, line));
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            for (let j = segment.start; j <= segment.end; j++) {
              addPointsBelow(points, sourcePoints[j], linesBelow);
            }
          }
          return new LineElement({ points, options: {} });
        }
        function getLinesBelow(scale, index3) {
          const below = [];
          const metas = scale.getMatchingVisibleMetas("line");
          for (let i = 0; i < metas.length; i++) {
            const meta = metas[i];
            if (meta.index === index3) {
              break;
            }
            if (!meta.hidden) {
              below.unshift(meta.dataset);
            }
          }
          return below;
        }
        function addPointsBelow(points, sourcePoint, linesBelow) {
          const postponed = [];
          for (let j = 0; j < linesBelow.length; j++) {
            const line = linesBelow[j];
            const { first, last, point } = findPoint(line, sourcePoint, "x");
            if (!point || first && last) {
              continue;
            }
            if (first) {
              postponed.unshift(point);
            } else {
              points.push(point);
              if (!last) {
                break;
              }
            }
          }
          points.push(...postponed);
        }
        function findPoint(line, sourcePoint, property) {
          const point = line.interpolate(sourcePoint, property);
          if (!point) {
            return {};
          }
          const pointValue = point[property];
          const segments = line.segments;
          const linePoints = line.points;
          let first = false;
          let last = false;
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            const firstValue = linePoints[segment.start][property];
            const lastValue = linePoints[segment.end][property];
            if (_isBetween(pointValue, firstValue, lastValue)) {
              first = pointValue === firstValue;
              last = pointValue === lastValue;
              break;
            }
          }
          return { first, last, point };
        }
        class simpleArc {
          constructor(opts) {
            this.x = opts.x;
            this.y = opts.y;
            this.radius = opts.radius;
          }
          pathSegment(ctx, bounds, opts) {
            const { x, y, radius } = this;
            bounds = bounds || { start: 0, end: TAU };
            ctx.arc(x, y, radius, bounds.end, bounds.start, true);
            return !opts.bounds;
          }
          interpolate(point) {
            const { x, y, radius } = this;
            const angle = point.angle;
            return {
              x: x + Math.cos(angle) * radius,
              y: y + Math.sin(angle) * radius,
              angle
            };
          }
        }
        function _getTarget(source) {
          const { chart: chart2, fill: fill2, line } = source;
          if (isNumberFinite(fill2)) {
            return getLineByIndex(chart2, fill2);
          }
          if (fill2 === "stack") {
            return _buildStackLine(source);
          }
          if (fill2 === "shape") {
            return true;
          }
          const boundary = computeBoundary(source);
          if (boundary instanceof simpleArc) {
            return boundary;
          }
          return _createBoundaryLine(boundary, line);
        }
        function getLineByIndex(chart2, index3) {
          const meta = chart2.getDatasetMeta(index3);
          const visible = meta && chart2.isDatasetVisible(index3);
          return visible ? meta.dataset : null;
        }
        function computeBoundary(source) {
          const scale = source.scale || {};
          if (scale.getPointPositionForValue) {
            return computeCircularBoundary(source);
          }
          return computeLinearBoundary(source);
        }
        function computeLinearBoundary(source) {
          const { scale = {}, fill: fill2 } = source;
          const pixel = _getTargetPixel(fill2, scale);
          if (isNumberFinite(pixel)) {
            const horizontal = scale.isHorizontal();
            return {
              x: horizontal ? pixel : null,
              y: horizontal ? null : pixel
            };
          }
          return null;
        }
        function computeCircularBoundary(source) {
          const { scale, fill: fill2 } = source;
          const options = scale.options;
          const length = scale.getLabels().length;
          const start = options.reverse ? scale.max : scale.min;
          const value = _getTargetValue(fill2, scale, start);
          const target = [];
          if (options.grid.circular) {
            const center = scale.getPointPositionForValue(0, start);
            return new simpleArc({
              x: center.x,
              y: center.y,
              radius: scale.getDistanceFromCenterForValue(value)
            });
          }
          for (let i = 0; i < length; ++i) {
            target.push(scale.getPointPositionForValue(i, value));
          }
          return target;
        }
        function _drawfill(ctx, source, area) {
          const target = _getTarget(source);
          const { line, scale, axis } = source;
          const lineOpts = line.options;
          const fillOption = lineOpts.fill;
          const color2 = lineOpts.backgroundColor;
          const { above = color2, below = color2 } = fillOption || {};
          if (target && line.points.length) {
            clipArea(ctx, area);
            doFill(ctx, { line, target, above, below, area, scale, axis });
            unclipArea(ctx);
          }
        }
        function doFill(ctx, cfg) {
          const { line, target, above, below, area, scale } = cfg;
          const property = line._loop ? "angle" : cfg.axis;
          ctx.save();
          if (property === "x" && below !== above) {
            clipVertical(ctx, target, area.top);
            fill(ctx, { line, target, color: above, scale, property });
            ctx.restore();
            ctx.save();
            clipVertical(ctx, target, area.bottom);
          }
          fill(ctx, { line, target, color: below, scale, property });
          ctx.restore();
        }
        function clipVertical(ctx, target, clipY) {
          const { segments, points } = target;
          let first = true;
          let lineLoop = false;
          ctx.beginPath();
          for (const segment of segments) {
            const { start, end } = segment;
            const firstPoint = points[start];
            const lastPoint = points[_findSegmentEnd(start, end, points)];
            if (first) {
              ctx.moveTo(firstPoint.x, firstPoint.y);
              first = false;
            } else {
              ctx.lineTo(firstPoint.x, clipY);
              ctx.lineTo(firstPoint.x, firstPoint.y);
            }
            lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
            if (lineLoop) {
              ctx.closePath();
            } else {
              ctx.lineTo(lastPoint.x, clipY);
            }
          }
          ctx.lineTo(target.first().x, clipY);
          ctx.closePath();
          ctx.clip();
        }
        function fill(ctx, cfg) {
          const { line, target, property, color: color2, scale } = cfg;
          const segments = _segments(line, target, property);
          for (const { source: src, target: tgt, start, end } of segments) {
            const { style: { backgroundColor = color2 } = {} } = src;
            const notShape = target !== true;
            ctx.save();
            ctx.fillStyle = backgroundColor;
            clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
            ctx.beginPath();
            const lineLoop = !!line.pathSegment(ctx, src);
            let loop;
            if (notShape) {
              if (lineLoop) {
                ctx.closePath();
              } else {
                interpolatedLineTo(ctx, target, end, property);
              }
              const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
              loop = lineLoop && targetLoop;
              if (!loop) {
                interpolatedLineTo(ctx, target, start, property);
              }
            }
            ctx.closePath();
            ctx.fill(loop ? "evenodd" : "nonzero");
            ctx.restore();
          }
        }
        function clipBounds(ctx, scale, bounds) {
          const { top, bottom } = scale.chart.chartArea;
          const { property, start, end } = bounds || {};
          if (property === "x") {
            ctx.beginPath();
            ctx.rect(start, top, end - start, bottom - top);
            ctx.clip();
          }
        }
        function interpolatedLineTo(ctx, target, point, property) {
          const interpolatedPoint = target.interpolate(point, property);
          if (interpolatedPoint) {
            ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
          }
        }
        var index2 = {
          id: "filler",
          afterDatasetsUpdate(chart2, _args, options) {
            const count = (chart2.data.datasets || []).length;
            const sources = [];
            let meta, i, line, source;
            for (i = 0; i < count; ++i) {
              meta = chart2.getDatasetMeta(i);
              line = meta.dataset;
              source = null;
              if (line && line.options && line instanceof LineElement) {
                source = {
                  visible: chart2.isDatasetVisible(i),
                  index: i,
                  fill: _decodeFill(line, i, count),
                  chart: chart2,
                  axis: meta.controller.options.indexAxis,
                  scale: meta.vScale,
                  line
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i = 0; i < count; ++i) {
              source = sources[i];
              if (!source || source.fill === false) {
                continue;
              }
              source.fill = _resolveTarget(sources, i, options.propagate);
            }
          },
          beforeDraw(chart2, _args, options) {
            const draw2 = options.drawTime === "beforeDraw";
            const metasets = chart2.getSortedVisibleDatasetMetas();
            const area = chart2.chartArea;
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (!source) {
                continue;
              }
              source.line.updateControlPoints(area, source.axis);
              if (draw2 && source.fill) {
                _drawfill(chart2.ctx, source, area);
              }
            }
          },
          beforeDatasetsDraw(chart2, _args, options) {
            if (options.drawTime !== "beforeDatasetsDraw") {
              return;
            }
            const metasets = chart2.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (_shouldApplyFill(source)) {
                _drawfill(chart2.ctx, source, chart2.chartArea);
              }
            }
          },
          beforeDatasetDraw(chart2, args, options) {
            const source = args.meta.$filler;
            if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
              return;
            }
            _drawfill(chart2.ctx, source, chart2.chartArea);
          },
          defaults: {
            propagate: true,
            drawTime: "beforeDatasetDraw"
          }
        };
        const getBoxSize = (labelOpts, fontSize) => {
          let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
          if (labelOpts.usePointStyle) {
            boxHeight = Math.min(boxHeight, fontSize);
            boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
          }
          return {
            boxWidth,
            boxHeight,
            itemHeight: Math.max(fontSize, boxHeight)
          };
        };
        const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
        class Legend extends Element2 {
          constructor(config) {
            super();
            this._added = false;
            this.legendHitBoxes = [];
            this._hoveredItem = null;
            this.doughnutMode = false;
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this.legendItems = void 0;
            this.columnSizes = void 0;
            this.lineWidths = void 0;
            this.maxHeight = void 0;
            this.maxWidth = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.height = void 0;
            this.width = void 0;
            this._margins = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
          }
          update(maxWidth, maxHeight, margins) {
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins;
            this.setDimensions();
            this.buildLabels();
            this.fit();
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = this._margins.left;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = this._margins.top;
              this.bottom = this.height;
            }
          }
          buildLabels() {
            const labelOpts = this.options.labels || {};
            let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
            if (labelOpts.filter) {
              legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
            }
            if (labelOpts.sort) {
              legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
            }
            if (this.options.reverse) {
              legendItems.reverse();
            }
            this.legendItems = legendItems;
          }
          fit() {
            const { options, ctx } = this;
            if (!options.display) {
              this.width = this.height = 0;
              return;
            }
            const labelOpts = options.labels;
            const labelFont = toFont(labelOpts.font);
            const fontSize = labelFont.size;
            const titleHeight = this._computeTitleHeight();
            const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
            let width, height;
            ctx.font = labelFont.string;
            if (this.isHorizontal()) {
              width = this.maxWidth;
              height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            } else {
              height = this.maxHeight;
              width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            }
            this.width = Math.min(width, options.maxWidth || this.maxWidth);
            this.height = Math.min(height, options.maxHeight || this.maxHeight);
          }
          _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
            const { ctx, maxWidth, options: { labels: { padding } } } = this;
            const hitboxes = this.legendHitBoxes = [];
            const lineWidths = this.lineWidths = [0];
            const lineHeight = itemHeight + padding;
            let totalHeight = titleHeight;
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            let row = -1;
            let top = -lineHeight;
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
              if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
              }
              hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
              lineWidths[lineWidths.length - 1] += itemWidth + padding;
            });
            return totalHeight;
          }
          _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
            const { ctx, maxHeight, options: { labels: { padding } } } = this;
            const hitboxes = this.legendHitBoxes = [];
            const columnSizes = this.columnSizes = [];
            const heightLimit = maxHeight - titleHeight;
            let totalWidth = padding;
            let currentColWidth = 0;
            let currentColHeight = 0;
            let left = 0;
            let col = 0;
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
              if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({ width: currentColWidth, height: currentColHeight });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
              }
              hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight + padding;
            });
            totalWidth += currentColWidth;
            columnSizes.push({ width: currentColWidth, height: currentColHeight });
            return totalWidth;
          }
          adjustHitBoxes() {
            if (!this.options.display) {
              return;
            }
            const titleHeight = this._computeTitleHeight();
            const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
            const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
            if (this.isHorizontal()) {
              let row = 0;
              let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
              for (const hitbox of hitboxes) {
                if (row !== hitbox.row) {
                  row = hitbox.row;
                  left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                left += hitbox.width + padding;
              }
            } else {
              let col = 0;
              let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
              for (const hitbox of hitboxes) {
                if (hitbox.col !== col) {
                  col = hitbox.col;
                  top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                top += hitbox.height + padding;
              }
            }
          }
          isHorizontal() {
            return this.options.position === "top" || this.options.position === "bottom";
          }
          draw() {
            if (this.options.display) {
              const ctx = this.ctx;
              clipArea(ctx, this);
              this._draw();
              unclipArea(ctx);
            }
          }
          _draw() {
            const { options: opts, columnSizes, lineWidths, ctx } = this;
            const { align, labels: labelOpts } = opts;
            const defaultColor = defaults.color;
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const labelFont = toFont(labelOpts.font);
            const { color: fontColor, padding } = labelOpts;
            const fontSize = labelFont.size;
            const halfFontSize = fontSize / 2;
            let cursor;
            this.drawTitle();
            ctx.textAlign = rtlHelper.textAlign("left");
            ctx.textBaseline = "middle";
            ctx.lineWidth = 0.5;
            ctx.font = labelFont.string;
            const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
            const drawLegendBox = function(x, y, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
                return;
              }
              ctx.save();
              const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
              ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
              ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
              ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
              ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
              ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
              if (labelOpts.usePointStyle) {
                const drawOptions = {
                  radius: boxHeight * Math.SQRT2 / 2,
                  pointStyle: legendItem.pointStyle,
                  rotation: legendItem.rotation,
                  borderWidth: lineWidth
                };
                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                const centerY = y + halfFontSize;
                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
              } else {
                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                const borderRadius = toTRBLCorners(legendItem.borderRadius);
                ctx.beginPath();
                if (Object.values(borderRadius).some((v) => v !== 0)) {
                  addRoundedRectPath(ctx, {
                    x: xBoxLeft,
                    y: yBoxTop,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                  });
                } else {
                  ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                }
                ctx.fill();
                if (lineWidth !== 0) {
                  ctx.stroke();
                }
              }
              ctx.restore();
            };
            const fillText = function(x, y, legendItem) {
              renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                strikethrough: legendItem.hidden,
                textAlign: rtlHelper.textAlign(legendItem.textAlign)
              });
            };
            const isHorizontal = this.isHorizontal();
            const titleHeight = this._computeTitleHeight();
            if (isHorizontal) {
              cursor = {
                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                y: this.top + padding + titleHeight,
                line: 0
              };
            } else {
              cursor = {
                x: this.left + padding,
                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                line: 0
              };
            }
            overrideTextDirection(this.ctx, opts.textDirection);
            const lineHeight = itemHeight + padding;
            this.legendItems.forEach((legendItem, i) => {
              ctx.strokeStyle = legendItem.fontColor || fontColor;
              ctx.fillStyle = legendItem.fontColor || fontColor;
              const textWidth = ctx.measureText(legendItem.text).width;
              const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
              const width = boxWidth + halfFontSize + textWidth;
              let x = cursor.x;
              let y = cursor.y;
              rtlHelper.setWidth(this.width);
              if (isHorizontal) {
                if (i > 0 && x + width + padding > this.right) {
                  y = cursor.y += lineHeight;
                  cursor.line++;
                  x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
                }
              } else if (i > 0 && y + lineHeight > this.bottom) {
                x = cursor.x = x + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
              }
              const realX = rtlHelper.x(x);
              drawLegendBox(realX, y, legendItem);
              x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
              fillText(rtlHelper.x(x), y, legendItem);
              if (isHorizontal) {
                cursor.x += width + padding;
              } else {
                cursor.y += lineHeight;
              }
            });
            restoreTextDirection(this.ctx, opts.textDirection);
          }
          drawTitle() {
            const opts = this.options;
            const titleOpts = opts.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            if (!titleOpts.display) {
              return;
            }
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const ctx = this.ctx;
            const position = titleOpts.position;
            const halfFontSize = titleFont.size / 2;
            const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
            let y;
            let left = this.left;
            let maxWidth = this.width;
            if (this.isHorizontal()) {
              maxWidth = Math.max(...this.lineWidths);
              y = this.top + topPaddingPlusHalfFontSize;
              left = _alignStartEnd(opts.align, left, this.right - maxWidth);
            } else {
              const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
              y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
            }
            const x = _alignStartEnd(position, left, left + maxWidth);
            ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
            ctx.textBaseline = "middle";
            ctx.strokeStyle = titleOpts.color;
            ctx.fillStyle = titleOpts.color;
            ctx.font = titleFont.string;
            renderText(ctx, titleOpts.text, x, y, titleFont);
          }
          _computeTitleHeight() {
            const titleOpts = this.options.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
          }
          _getLegendItemAt(x, y) {
            let i, hitBox, lh;
            if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
              lh = this.legendHitBoxes;
              for (i = 0; i < lh.length; ++i) {
                hitBox = lh[i];
                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
                  return this.legendItems[i];
                }
              }
            }
            return null;
          }
          handleEvent(e) {
            const opts = this.options;
            if (!isListened(e.type, opts)) {
              return;
            }
            const hoveredItem = this._getLegendItemAt(e.x, e.y);
            if (e.type === "mousemove" || e.type === "mouseout") {
              const previous = this._hoveredItem;
              const sameItem = itemsEqual(previous, hoveredItem);
              if (previous && !sameItem) {
                callback(opts.onLeave, [e, previous, this], this);
              }
              this._hoveredItem = hoveredItem;
              if (hoveredItem && !sameItem) {
                callback(opts.onHover, [e, hoveredItem, this], this);
              }
            } else if (hoveredItem) {
              callback(opts.onClick, [e, hoveredItem, this], this);
            }
          }
        }
        function isListened(type, opts) {
          if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
            return true;
          }
          if (opts.onClick && (type === "click" || type === "mouseup")) {
            return true;
          }
          return false;
        }
        var plugin_legend = {
          id: "legend",
          _element: Legend,
          start(chart2, _args, options) {
            const legend = chart2.legend = new Legend({ ctx: chart2.ctx, options, chart: chart2 });
            layouts.configure(chart2, legend, options);
            layouts.addBox(chart2, legend);
          },
          stop(chart2) {
            layouts.removeBox(chart2, chart2.legend);
            delete chart2.legend;
          },
          beforeUpdate(chart2, _args, options) {
            const legend = chart2.legend;
            layouts.configure(chart2, legend, options);
            legend.options = options;
          },
          afterUpdate(chart2) {
            const legend = chart2.legend;
            legend.buildLabels();
            legend.adjustHitBoxes();
          },
          afterEvent(chart2, args) {
            if (!args.replay) {
              chart2.legend.handleEvent(args.event);
            }
          },
          defaults: {
            display: true,
            position: "top",
            align: "center",
            fullSize: true,
            reverse: false,
            weight: 1e3,
            onClick(e, legendItem, legend) {
              const index3 = legendItem.datasetIndex;
              const ci = legend.chart;
              if (ci.isDatasetVisible(index3)) {
                ci.hide(index3);
                legendItem.hidden = true;
              } else {
                ci.show(index3);
                legendItem.hidden = false;
              }
            },
            onHover: null,
            onLeave: null,
            labels: {
              color: (ctx) => ctx.chart.options.color,
              boxWidth: 40,
              padding: 10,
              generateLabels(chart2) {
                const datasets = chart2.data.datasets;
                const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart2.legend.options;
                return chart2._getSortedDatasetMetas().map((meta) => {
                  const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                  const borderWidth = toPadding(style.borderWidth);
                  return {
                    text: datasets[meta.index].label,
                    fillStyle: style.backgroundColor,
                    fontColor: color2,
                    hidden: !meta.visible,
                    lineCap: style.borderCapStyle,
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: (borderWidth.width + borderWidth.height) / 4,
                    strokeStyle: style.borderColor,
                    pointStyle: pointStyle || style.pointStyle,
                    rotation: style.rotation,
                    textAlign: textAlign || style.textAlign,
                    borderRadius: 0,
                    datasetIndex: meta.index
                  };
                }, this);
              }
            },
            title: {
              color: (ctx) => ctx.chart.options.color,
              display: false,
              position: "center",
              text: ""
            }
          },
          descriptors: {
            _scriptable: (name) => !name.startsWith("on"),
            labels: {
              _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
            }
          }
        };
        class Title extends Element2 {
          constructor(config) {
            super();
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this._padding = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
          }
          update(maxWidth, maxHeight) {
            const opts = this.options;
            this.left = 0;
            this.top = 0;
            if (!opts.display) {
              this.width = this.height = this.right = this.bottom = 0;
              return;
            }
            this.width = this.right = maxWidth;
            this.height = this.bottom = maxHeight;
            const lineCount = isArray(opts.text) ? opts.text.length : 1;
            this._padding = toPadding(opts.padding);
            const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
            if (this.isHorizontal()) {
              this.height = textSize;
            } else {
              this.width = textSize;
            }
          }
          isHorizontal() {
            const pos = this.options.position;
            return pos === "top" || pos === "bottom";
          }
          _drawArgs(offset) {
            const { top, left, bottom, right, options } = this;
            const align = options.align;
            let rotation = 0;
            let maxWidth, titleX, titleY;
            if (this.isHorizontal()) {
              titleX = _alignStartEnd(align, left, right);
              titleY = top + offset;
              maxWidth = right - left;
            } else {
              if (options.position === "left") {
                titleX = left + offset;
                titleY = _alignStartEnd(align, bottom, top);
                rotation = PI * -0.5;
              } else {
                titleX = right - offset;
                titleY = _alignStartEnd(align, top, bottom);
                rotation = PI * 0.5;
              }
              maxWidth = bottom - top;
            }
            return { titleX, titleY, maxWidth, rotation };
          }
          draw() {
            const ctx = this.ctx;
            const opts = this.options;
            if (!opts.display) {
              return;
            }
            const fontOpts = toFont(opts.font);
            const lineHeight = fontOpts.lineHeight;
            const offset = lineHeight / 2 + this._padding.top;
            const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
            renderText(ctx, opts.text, 0, 0, fontOpts, {
              color: opts.color,
              maxWidth,
              rotation,
              textAlign: _toLeftRightCenter(opts.align),
              textBaseline: "middle",
              translation: [titleX, titleY]
            });
          }
        }
        function createTitle(chart2, titleOpts) {
          const title = new Title({
            ctx: chart2.ctx,
            options: titleOpts,
            chart: chart2
          });
          layouts.configure(chart2, title, titleOpts);
          layouts.addBox(chart2, title);
          chart2.titleBlock = title;
        }
        var plugin_title = {
          id: "title",
          _element: Title,
          start(chart2, _args, options) {
            createTitle(chart2, options);
          },
          stop(chart2) {
            const titleBlock = chart2.titleBlock;
            layouts.removeBox(chart2, titleBlock);
            delete chart2.titleBlock;
          },
          beforeUpdate(chart2, _args, options) {
            const title = chart2.titleBlock;
            layouts.configure(chart2, title, options);
            title.options = options;
          },
          defaults: {
            align: "center",
            display: false,
            font: {
              weight: "bold"
            },
            fullSize: true,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
          },
          defaultRoutes: {
            color: "color"
          },
          descriptors: {
            _scriptable: true,
            _indexable: false
          }
        };
        const map = new WeakMap();
        var plugin_subtitle = {
          id: "subtitle",
          start(chart2, _args, options) {
            const title = new Title({
              ctx: chart2.ctx,
              options,
              chart: chart2
            });
            layouts.configure(chart2, title, options);
            layouts.addBox(chart2, title);
            map.set(chart2, title);
          },
          stop(chart2) {
            layouts.removeBox(chart2, map.get(chart2));
            map.delete(chart2);
          },
          beforeUpdate(chart2, _args, options) {
            const title = map.get(chart2);
            layouts.configure(chart2, title, options);
            title.options = options;
          },
          defaults: {
            align: "center",
            display: false,
            font: {
              weight: "normal"
            },
            fullSize: true,
            padding: 0,
            position: "top",
            text: "",
            weight: 1500
          },
          defaultRoutes: {
            color: "color"
          },
          descriptors: {
            _scriptable: true,
            _indexable: false
          }
        };
        const positioners = {
          average(items) {
            if (!items.length) {
              return false;
            }
            let i, len;
            let x = 0;
            let y = 0;
            let count = 0;
            for (i = 0, len = items.length; i < len; ++i) {
              const el = items[i].element;
              if (el && el.hasValue()) {
                const pos = el.tooltipPosition();
                x += pos.x;
                y += pos.y;
                ++count;
              }
            }
            return {
              x: x / count,
              y: y / count
            };
          },
          nearest(items, eventPosition) {
            if (!items.length) {
              return false;
            }
            let x = eventPosition.x;
            let y = eventPosition.y;
            let minDistance = Number.POSITIVE_INFINITY;
            let i, len, nearestElement;
            for (i = 0, len = items.length; i < len; ++i) {
              const el = items[i].element;
              if (el && el.hasValue()) {
                const center = el.getCenterPoint();
                const d = distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                  minDistance = d;
                  nearestElement = el;
                }
              }
            }
            if (nearestElement) {
              const tp = nearestElement.tooltipPosition();
              x = tp.x;
              y = tp.y;
            }
            return {
              x,
              y
            };
          }
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (isArray(toPush)) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function splitNewlines(str) {
          if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
            return str.split("\n");
          }
          return str;
        }
        function createTooltipItem(chart2, item) {
          const { element, datasetIndex, index: index3 } = item;
          const controller = chart2.getDatasetMeta(datasetIndex).controller;
          const { label, value } = controller.getLabelAndValue(index3);
          return {
            chart: chart2,
            label,
            parsed: controller.getParsed(index3),
            raw: chart2.data.datasets[datasetIndex].data[index3],
            formattedValue: value,
            dataset: controller.getDataset(),
            dataIndex: index3,
            datasetIndex,
            element
          };
        }
        function getTooltipSize(tooltip, options) {
          const ctx = tooltip.chart.ctx;
          const { body, footer, title } = tooltip;
          const { boxWidth, boxHeight } = options;
          const bodyFont = toFont(options.bodyFont);
          const titleFont = toFont(options.titleFont);
          const footerFont = toFont(options.footerFont);
          const titleLineCount = title.length;
          const footerLineCount = footer.length;
          const bodyLineItemCount = body.length;
          const padding = toPadding(options.padding);
          let height = padding.height;
          let width = 0;
          let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
          combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
          if (titleLineCount) {
            height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
          }
          if (combinedBodyLength) {
            const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
            height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
          }
          if (footerLineCount) {
            height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
          }
          let widthPadding = 0;
          const maxLineWidth = function(line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
          };
          ctx.save();
          ctx.font = titleFont.string;
          each(tooltip.title, maxLineWidth);
          ctx.font = bodyFont.string;
          each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
          widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
          each(body, (bodyItem) => {
            each(bodyItem.before, maxLineWidth);
            each(bodyItem.lines, maxLineWidth);
            each(bodyItem.after, maxLineWidth);
          });
          widthPadding = 0;
          ctx.font = footerFont.string;
          each(tooltip.footer, maxLineWidth);
          ctx.restore();
          width += padding.width;
          return { width, height };
        }
        function determineYAlign(chart2, size) {
          const { y, height } = size;
          if (y < height / 2) {
            return "top";
          } else if (y > chart2.height - height / 2) {
            return "bottom";
          }
          return "center";
        }
        function doesNotFitWithAlign(xAlign, chart2, options, size) {
          const { x, width } = size;
          const caret = options.caretSize + options.caretPadding;
          if (xAlign === "left" && x + width + caret > chart2.width) {
            return true;
          }
          if (xAlign === "right" && x - width - caret < 0) {
            return true;
          }
        }
        function determineXAlign(chart2, options, size, yAlign) {
          const { x, width } = size;
          const { width: chartWidth, chartArea: { left, right } } = chart2;
          let xAlign = "center";
          if (yAlign === "center") {
            xAlign = x <= (left + right) / 2 ? "left" : "right";
          } else if (x <= width / 2) {
            xAlign = "left";
          } else if (x >= chartWidth - width / 2) {
            xAlign = "right";
          }
          if (doesNotFitWithAlign(xAlign, chart2, options, size)) {
            xAlign = "center";
          }
          return xAlign;
        }
        function determineAlignment(chart2, options, size) {
          const yAlign = size.yAlign || options.yAlign || determineYAlign(chart2, size);
          return {
            xAlign: size.xAlign || options.xAlign || determineXAlign(chart2, options, size, yAlign),
            yAlign
          };
        }
        function alignX(size, xAlign) {
          let { x, width } = size;
          if (xAlign === "right") {
            x -= width;
          } else if (xAlign === "center") {
            x -= width / 2;
          }
          return x;
        }
        function alignY(size, yAlign, paddingAndSize) {
          let { y, height } = size;
          if (yAlign === "top") {
            y += paddingAndSize;
          } else if (yAlign === "bottom") {
            y -= height + paddingAndSize;
          } else {
            y -= height / 2;
          }
          return y;
        }
        function getBackgroundPoint(options, size, alignment, chart2) {
          const { caretSize, caretPadding, cornerRadius } = options;
          const { xAlign, yAlign } = alignment;
          const paddingAndSize = caretSize + caretPadding;
          const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
          let x = alignX(size, xAlign);
          const y = alignY(size, yAlign, paddingAndSize);
          if (yAlign === "center") {
            if (xAlign === "left") {
              x += paddingAndSize;
            } else if (xAlign === "right") {
              x -= paddingAndSize;
            }
          } else if (xAlign === "left") {
            x -= Math.max(topLeft, bottomLeft) + caretSize;
          } else if (xAlign === "right") {
            x += Math.max(topRight, bottomRight) + caretSize;
          }
          return {
            x: _limitValue(x, 0, chart2.width - size.width),
            y: _limitValue(y, 0, chart2.height - size.height)
          };
        }
        function getAlignedX(tooltip, align, options) {
          const padding = toPadding(options.padding);
          return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
        }
        function getBeforeAfterBodyLines(callback2) {
          return pushOrConcat([], splitNewlines(callback2));
        }
        function createTooltipContext(parent, tooltip, tooltipItems) {
          return createContext(parent, {
            tooltip,
            tooltipItems,
            type: "tooltip"
          });
        }
        function overrideCallbacks(callbacks, context) {
          const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
          return override ? callbacks.override(override) : callbacks;
        }
        class Tooltip extends Element2 {
          constructor(config) {
            super();
            this.opacity = 0;
            this._active = [];
            this._eventPosition = void 0;
            this._size = void 0;
            this._cachedAnimations = void 0;
            this._tooltipItems = [];
            this.$animations = void 0;
            this.$context = void 0;
            this.chart = config.chart || config._chart;
            this._chart = this.chart;
            this.options = config.options;
            this.dataPoints = void 0;
            this.title = void 0;
            this.beforeBody = void 0;
            this.body = void 0;
            this.afterBody = void 0;
            this.footer = void 0;
            this.xAlign = void 0;
            this.yAlign = void 0;
            this.x = void 0;
            this.y = void 0;
            this.height = void 0;
            this.width = void 0;
            this.caretX = void 0;
            this.caretY = void 0;
            this.labelColors = void 0;
            this.labelPointStyles = void 0;
            this.labelTextColors = void 0;
          }
          initialize(options) {
            this.options = options;
            this._cachedAnimations = void 0;
            this.$context = void 0;
          }
          _resolveAnimations() {
            const cached = this._cachedAnimations;
            if (cached) {
              return cached;
            }
            const chart2 = this.chart;
            const options = this.options.setContext(this.getContext());
            const opts = options.enabled && chart2.options.animation && options.animations;
            const animations = new Animations(this.chart, opts);
            if (opts._cacheable) {
              this._cachedAnimations = Object.freeze(animations);
            }
            return animations;
          }
          getContext() {
            return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
          }
          getTitle(context, options) {
            const { callbacks } = options;
            const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
            const title = callbacks.title.apply(this, [context]);
            const afterTitle = callbacks.afterTitle.apply(this, [context]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
          }
          getBeforeBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
          }
          getBody(tooltipItems, options) {
            const { callbacks } = options;
            const bodyItems = [];
            each(tooltipItems, (context) => {
              const bodyItem = {
                before: [],
                lines: [],
                after: []
              };
              const scoped = overrideCallbacks(callbacks, context);
              pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
              pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
              pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
              bodyItems.push(bodyItem);
            });
            return bodyItems;
          }
          getAfterBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
          }
          getFooter(tooltipItems, options) {
            const { callbacks } = options;
            const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
            const footer = callbacks.footer.apply(this, [tooltipItems]);
            const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
          }
          _createItems(options) {
            const active = this._active;
            const data = this.chart.data;
            const labelColors = [];
            const labelPointStyles = [];
            const labelTextColors = [];
            let tooltipItems = [];
            let i, len;
            for (i = 0, len = active.length; i < len; ++i) {
              tooltipItems.push(createTooltipItem(this.chart, active[i]));
            }
            if (options.filter) {
              tooltipItems = tooltipItems.filter((element, index3, array) => options.filter(element, index3, array, data));
            }
            if (options.itemSort) {
              tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
            }
            each(tooltipItems, (context) => {
              const scoped = overrideCallbacks(options.callbacks, context);
              labelColors.push(scoped.labelColor.call(this, context));
              labelPointStyles.push(scoped.labelPointStyle.call(this, context));
              labelTextColors.push(scoped.labelTextColor.call(this, context));
            });
            this.labelColors = labelColors;
            this.labelPointStyles = labelPointStyles;
            this.labelTextColors = labelTextColors;
            this.dataPoints = tooltipItems;
            return tooltipItems;
          }
          update(changed, replay) {
            const options = this.options.setContext(this.getContext());
            const active = this._active;
            let properties;
            let tooltipItems = [];
            if (!active.length) {
              if (this.opacity !== 0) {
                properties = {
                  opacity: 0
                };
              }
            } else {
              const position = positioners[options.position].call(this, active, this._eventPosition);
              tooltipItems = this._createItems(options);
              this.title = this.getTitle(tooltipItems, options);
              this.beforeBody = this.getBeforeBody(tooltipItems, options);
              this.body = this.getBody(tooltipItems, options);
              this.afterBody = this.getAfterBody(tooltipItems, options);
              this.footer = this.getFooter(tooltipItems, options);
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, size);
              const alignment = determineAlignment(this.chart, options, positionAndSize);
              const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
              this.xAlign = alignment.xAlign;
              this.yAlign = alignment.yAlign;
              properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y
              };
            }
            this._tooltipItems = tooltipItems;
            this.$context = void 0;
            if (properties) {
              this._resolveAnimations().update(this, properties);
            }
            if (changed && options.external) {
              options.external.call(this, { chart: this.chart, tooltip: this, replay });
            }
          }
          drawCaret(tooltipPoint, ctx, size, options) {
            const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          }
          getCaretPosition(tooltipPoint, size, options) {
            const { xAlign, yAlign } = this;
            const { caretSize, cornerRadius } = options;
            const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
            const { x: ptX, y: ptY } = tooltipPoint;
            const { width, height } = size;
            let x1, x2, x3, y1, y2, y3;
            if (yAlign === "center") {
              y2 = ptY + height / 2;
              if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
              x3 = x1;
            } else {
              if (xAlign === "left") {
                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
              } else if (xAlign === "right") {
                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
              } else {
                x2 = this.caretX;
              }
              if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
              }
              y3 = y1;
            }
            return { x1, x2, x3, y1, y2, y3 };
          }
          drawTitle(pt, ctx, options) {
            const title = this.title;
            const length = title.length;
            let titleFont, titleSpacing, i;
            if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt.x = getAlignedX(this, options.titleAlign, options);
              ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
              ctx.textBaseline = "middle";
              titleFont = toFont(options.titleFont);
              titleSpacing = options.titleSpacing;
              ctx.fillStyle = options.titleColor;
              ctx.font = titleFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                pt.y += titleFont.lineHeight + titleSpacing;
                if (i + 1 === length) {
                  pt.y += options.titleMarginBottom - titleSpacing;
                }
              }
            }
          }
          _drawColorBox(ctx, pt, i, rtlHelper, options) {
            const labelColors = this.labelColors[i];
            const labelPointStyle = this.labelPointStyles[i];
            const { boxHeight, boxWidth, boxPadding } = options;
            const bodyFont = toFont(options.bodyFont);
            const colorX = getAlignedX(this, "left", options);
            const rtlColorX = rtlHelper.x(colorX);
            const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
            const colorY = pt.y + yOffSet;
            if (options.usePointStyle) {
              const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1
              };
              const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
              const centerY = colorY + boxHeight / 2;
              ctx.strokeStyle = options.multiKeyBackground;
              ctx.fillStyle = options.multiKeyBackground;
              drawPoint(ctx, drawOptions, centerX, centerY);
              ctx.strokeStyle = labelColors.borderColor;
              ctx.fillStyle = labelColors.backgroundColor;
              drawPoint(ctx, drawOptions, centerX, centerY);
            } else {
              ctx.lineWidth = isObject2(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
              ctx.strokeStyle = labelColors.borderColor;
              ctx.setLineDash(labelColors.borderDash || []);
              ctx.lineDashOffset = labelColors.borderDashOffset || 0;
              const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
              const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
              const borderRadius = toTRBLCorners(labelColors.borderRadius);
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                addRoundedRectPath(ctx, {
                  x: outerX,
                  y: colorY,
                  w: boxWidth,
                  h: boxHeight,
                  radius: borderRadius
                });
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                  x: innerX,
                  y: colorY + 1,
                  w: boxWidth - 2,
                  h: boxHeight - 2,
                  radius: borderRadius
                });
                ctx.fill();
              } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
              }
            }
            ctx.fillStyle = this.labelTextColors[i];
          }
          drawBody(pt, ctx, options) {
            const { body } = this;
            const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
            const bodyFont = toFont(options.bodyFont);
            let bodyLineHeight = bodyFont.lineHeight;
            let xLinePadding = 0;
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            const fillLineOfText = function(line) {
              ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
              pt.y += bodyLineHeight + bodySpacing;
            };
            const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            let bodyItem, textColor, lines, i, j, ilen, jlen;
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = "middle";
            ctx.font = bodyFont.string;
            pt.x = getAlignedX(this, bodyAlignForCalculation, options);
            ctx.fillStyle = options.bodyColor;
            each(this.beforeBody, fillLineOfText);
            xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
            for (i = 0, ilen = body.length; i < ilen; ++i) {
              bodyItem = body[i];
              textColor = this.labelTextColors[i];
              ctx.fillStyle = textColor;
              each(bodyItem.before, fillLineOfText);
              lines = bodyItem.lines;
              if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt, i, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
              }
              for (j = 0, jlen = lines.length; j < jlen; ++j) {
                fillLineOfText(lines[j]);
                bodyLineHeight = bodyFont.lineHeight;
              }
              each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            bodyLineHeight = bodyFont.lineHeight;
            each(this.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
          }
          drawFooter(pt, ctx, options) {
            const footer = this.footer;
            const length = footer.length;
            let footerFont, i;
            if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt.x = getAlignedX(this, options.footerAlign, options);
              pt.y += options.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
              ctx.textBaseline = "middle";
              footerFont = toFont(options.footerFont);
              ctx.fillStyle = options.footerColor;
              ctx.font = footerFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                pt.y += footerFont.lineHeight + options.footerSpacing;
              }
            }
          }
          drawBackground(pt, ctx, tooltipSize, options) {
            const { xAlign, yAlign } = this;
            const { x, y } = pt;
            const { width, height } = tooltipSize;
            const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.beginPath();
            ctx.moveTo(x + topLeft, y);
            if (yAlign === "top") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width - topRight, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
            if (yAlign === "center" && xAlign === "right") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width, y + height - bottomRight);
            ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
            if (yAlign === "bottom") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + bottomLeft, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
            if (yAlign === "center" && xAlign === "left") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x, y + topLeft);
            ctx.quadraticCurveTo(x, y, x + topLeft, y);
            ctx.closePath();
            ctx.fill();
            if (options.borderWidth > 0) {
              ctx.stroke();
            }
          }
          _updateAnimationTarget(options) {
            const chart2 = this.chart;
            const anims = this.$animations;
            const animX = anims && anims.x;
            const animY = anims && anims.y;
            if (animX || animY) {
              const position = positioners[options.position].call(this, this._active, this._eventPosition);
              if (!position) {
                return;
              }
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, this._size);
              const alignment = determineAlignment(chart2, options, positionAndSize);
              const point = getBackgroundPoint(options, positionAndSize, alignment, chart2);
              if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
              }
            }
          }
          _willRender() {
            return !!this.opacity;
          }
          draw(ctx) {
            const options = this.options.setContext(this.getContext());
            let opacity = this.opacity;
            if (!opacity) {
              return;
            }
            this._updateAnimationTarget(options);
            const tooltipSize = {
              width: this.width,
              height: this.height
            };
            const pt = {
              x: this.x,
              y: this.y
            };
            opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
            const padding = toPadding(options.padding);
            const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
            if (options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt, ctx, tooltipSize, options);
              overrideTextDirection(ctx, options.textDirection);
              pt.y += padding.top;
              this.drawTitle(pt, ctx, options);
              this.drawBody(pt, ctx, options);
              this.drawFooter(pt, ctx, options);
              restoreTextDirection(ctx, options.textDirection);
              ctx.restore();
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements, eventPosition) {
            const lastActive = this._active;
            const active = activeElements.map(({ datasetIndex, index: index3 }) => {
              const meta = this.chart.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error("Cannot find a dataset at index " + datasetIndex);
              }
              return {
                datasetIndex,
                element: meta.data[index3],
                index: index3
              };
            });
            const changed = !_elementsEqual(lastActive, active);
            const positionChanged = this._positionChanged(active, eventPosition);
            if (changed || positionChanged) {
              this._active = active;
              this._eventPosition = eventPosition;
              this._ignoreReplayEvents = true;
              this.update(true);
            }
          }
          handleEvent(e, replay, inChartArea = true) {
            if (replay && this._ignoreReplayEvents) {
              return false;
            }
            this._ignoreReplayEvents = false;
            const options = this.options;
            const lastActive = this._active || [];
            const active = this._getActiveElements(e, lastActive, replay, inChartArea);
            const positionChanged = this._positionChanged(active, e);
            const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
            if (changed) {
              this._active = active;
              if (options.enabled || options.external) {
                this._eventPosition = {
                  x: e.x,
                  y: e.y
                };
                this.update(true, replay);
              }
            }
            return changed;
          }
          _getActiveElements(e, lastActive, replay, inChartArea) {
            const options = this.options;
            if (e.type === "mouseout") {
              return [];
            }
            if (!inChartArea) {
              return lastActive;
            }
            const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
            if (options.reverse) {
              active.reverse();
            }
            return active;
          }
          _positionChanged(active, e) {
            const { caretX, caretY, options } = this;
            const position = positioners[options.position].call(this, active, e);
            return position !== false && (caretX !== position.x || caretY !== position.y);
          }
        }
        Tooltip.positioners = positioners;
        var plugin_tooltip = {
          id: "tooltip",
          _element: Tooltip,
          positioners,
          afterInit(chart2, _args, options) {
            if (options) {
              chart2.tooltip = new Tooltip({ chart: chart2, options });
            }
          },
          beforeUpdate(chart2, _args, options) {
            if (chart2.tooltip) {
              chart2.tooltip.initialize(options);
            }
          },
          reset(chart2, _args, options) {
            if (chart2.tooltip) {
              chart2.tooltip.initialize(options);
            }
          },
          afterDraw(chart2) {
            const tooltip = chart2.tooltip;
            if (tooltip && tooltip._willRender()) {
              const args = {
                tooltip
              };
              if (chart2.notifyPlugins("beforeTooltipDraw", args) === false) {
                return;
              }
              tooltip.draw(chart2.ctx);
              chart2.notifyPlugins("afterTooltipDraw", args);
            }
          },
          afterEvent(chart2, args) {
            if (chart2.tooltip) {
              const useFinalPosition = args.replay;
              if (chart2.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
                args.changed = true;
              }
            }
          },
          defaults: {
            enabled: true,
            external: null,
            position: "average",
            backgroundColor: "rgba(0,0,0,0.8)",
            titleColor: "#fff",
            titleFont: {
              weight: "bold"
            },
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleAlign: "left",
            bodyColor: "#fff",
            bodySpacing: 2,
            bodyFont: {},
            bodyAlign: "left",
            footerColor: "#fff",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFont: {
              weight: "bold"
            },
            footerAlign: "left",
            padding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            boxHeight: (ctx, opts) => opts.bodyFont.size,
            boxWidth: (ctx, opts) => opts.bodyFont.size,
            multiKeyBackground: "#fff",
            displayColors: true,
            boxPadding: 0,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            animation: {
              duration: 400,
              easing: "easeOutQuart"
            },
            animations: {
              numbers: {
                type: "number",
                properties: ["x", "y", "width", "height", "caretX", "caretY"]
              },
              opacity: {
                easing: "linear",
                duration: 200
              }
            },
            callbacks: {
              beforeTitle: noop2,
              title(tooltipItems) {
                if (tooltipItems.length > 0) {
                  const item = tooltipItems[0];
                  const labels = item.chart.data.labels;
                  const labelCount = labels ? labels.length : 0;
                  if (this && this.options && this.options.mode === "dataset") {
                    return item.dataset.label || "";
                  } else if (item.label) {
                    return item.label;
                  } else if (labelCount > 0 && item.dataIndex < labelCount) {
                    return labels[item.dataIndex];
                  }
                }
                return "";
              },
              afterTitle: noop2,
              beforeBody: noop2,
              beforeLabel: noop2,
              label(tooltipItem) {
                if (this && this.options && this.options.mode === "dataset") {
                  return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
                }
                let label = tooltipItem.dataset.label || "";
                if (label) {
                  label += ": ";
                }
                const value = tooltipItem.formattedValue;
                if (!isNullOrUndef(value)) {
                  label += value;
                }
                return label;
              },
              labelColor(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                  borderColor: options.borderColor,
                  backgroundColor: options.backgroundColor,
                  borderWidth: options.borderWidth,
                  borderDash: options.borderDash,
                  borderDashOffset: options.borderDashOffset,
                  borderRadius: 0
                };
              },
              labelTextColor() {
                return this.options.bodyColor;
              },
              labelPointStyle(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                  pointStyle: options.pointStyle,
                  rotation: options.rotation
                };
              },
              afterLabel: noop2,
              afterBody: noop2,
              beforeFooter: noop2,
              footer: noop2,
              afterFooter: noop2
            }
          },
          defaultRoutes: {
            bodyFont: "font",
            footerFont: "font",
            titleFont: "font"
          },
          descriptors: {
            _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
            _indexable: false,
            callbacks: {
              _scriptable: false,
              _indexable: false
            },
            animation: {
              _fallback: false
            },
            animations: {
              _fallback: "animation"
            }
          },
          additionalOptionScopes: ["interaction"]
        };
        var plugins = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          Decimation: plugin_decimation,
          Filler: index2,
          Legend: plugin_legend,
          SubTitle: plugin_subtitle,
          Title: plugin_title,
          Tooltip: plugin_tooltip
        });
        const addIfString = (labels, raw, index3, addedLabels) => {
          if (typeof raw === "string") {
            index3 = labels.push(raw) - 1;
            addedLabels.unshift({ index: index3, label: raw });
          } else if (isNaN(raw)) {
            index3 = null;
          }
          return index3;
        };
        function findOrAddLabel(labels, raw, index3, addedLabels) {
          const first = labels.indexOf(raw);
          if (first === -1) {
            return addIfString(labels, raw, index3, addedLabels);
          }
          const last = labels.lastIndexOf(raw);
          return first !== last ? index3 : first;
        }
        const validIndex = (index3, max) => index3 === null ? null : _limitValue(Math.round(index3), 0, max);
        class CategoryScale extends Scale {
          constructor(cfg) {
            super(cfg);
            this._startValue = void 0;
            this._valueRange = 0;
            this._addedLabels = [];
          }
          init(scaleOptions) {
            const added = this._addedLabels;
            if (added.length) {
              const labels = this.getLabels();
              for (const { index: index3, label } of added) {
                if (labels[index3] === label) {
                  labels.splice(index3, 1);
                }
              }
              this._addedLabels = [];
            }
            super.init(scaleOptions);
          }
          parse(raw, index3) {
            if (isNullOrUndef(raw)) {
              return null;
            }
            const labels = this.getLabels();
            index3 = isFinite(index3) && labels[index3] === raw ? index3 : findOrAddLabel(labels, raw, valueOrDefault(index3, raw), this._addedLabels);
            return validIndex(index3, labels.length - 1);
          }
          determineDataLimits() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this.getMinMax(true);
            if (this.options.bounds === "ticks") {
              if (!minDefined) {
                min = 0;
              }
              if (!maxDefined) {
                max = this.getLabels().length - 1;
              }
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const min = this.min;
            const max = this.max;
            const offset = this.options.offset;
            const ticks = [];
            let labels = this.getLabels();
            labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
            this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
            this._startValue = this.min - (offset ? 0.5 : 0);
            for (let value = min; value <= max; value++) {
              ticks.push({ value });
            }
            return ticks;
          }
          getLabelForValue(value) {
            const labels = this.getLabels();
            if (value >= 0 && value < labels.length) {
              return labels[value];
            }
            return value;
          }
          configure() {
            super.configure();
            if (!this.isHorizontal()) {
              this._reversePixels = !this._reversePixels;
            }
          }
          getPixelForValue(value) {
            if (typeof value !== "number") {
              value = this.parse(value);
            }
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
          }
          getPixelForTick(index3) {
            const ticks = this.ticks;
            if (index3 < 0 || index3 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index3].value);
          }
          getValueForPixel(pixel) {
            return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
          }
          getBasePixel() {
            return this.bottom;
          }
        }
        CategoryScale.id = "category";
        CategoryScale.defaults = {
          ticks: {
            callback: CategoryScale.prototype.getLabelForValue
          }
        };
        function generateTicks$1(generationOptions, dataRange) {
          const ticks = [];
          const MIN_SPACING = 1e-14;
          const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
          const unit = step || 1;
          const maxSpaces = maxTicks - 1;
          const { min: rmin, max: rmax } = dataRange;
          const minDefined = !isNullOrUndef(min);
          const maxDefined = !isNullOrUndef(max);
          const countDefined = !isNullOrUndef(count);
          const minSpacing = (rmax - rmin) / (maxDigits + 1);
          let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
          let factor, niceMin, niceMax, numSpaces;
          if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
            return [{ value: rmin }, { value: rmax }];
          }
          numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
          if (numSpaces > maxSpaces) {
            spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
          }
          if (!isNullOrUndef(precision)) {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
          }
          if (bounds === "ticks") {
            niceMin = Math.floor(rmin / spacing) * spacing;
            niceMax = Math.ceil(rmax / spacing) * spacing;
          } else {
            niceMin = rmin;
            niceMax = rmax;
          }
          if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
            numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
            spacing = (max - min) / numSpaces;
            niceMin = min;
            niceMax = max;
          } else if (countDefined) {
            niceMin = minDefined ? min : niceMin;
            niceMax = maxDefined ? max : niceMax;
            numSpaces = count - 1;
            spacing = (niceMax - niceMin) / numSpaces;
          } else {
            numSpaces = (niceMax - niceMin) / spacing;
            if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
              numSpaces = Math.round(numSpaces);
            } else {
              numSpaces = Math.ceil(numSpaces);
            }
          }
          const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
          factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
          niceMin = Math.round(niceMin * factor) / factor;
          niceMax = Math.round(niceMax * factor) / factor;
          let j = 0;
          if (minDefined) {
            if (includeBounds && niceMin !== min) {
              ticks.push({ value: min });
              if (niceMin < min) {
                j++;
              }
              if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
                j++;
              }
            } else if (niceMin < min) {
              j++;
            }
          }
          for (; j < numSpaces; ++j) {
            ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
          }
          if (maxDefined && includeBounds && niceMax !== max) {
            if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
              ticks[ticks.length - 1].value = max;
            } else {
              ticks.push({ value: max });
            }
          } else if (!maxDefined || niceMax === max) {
            ticks.push({ value: niceMax });
          }
          return ticks;
        }
        function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
          const rad = toRadians(minRotation);
          const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
          const length = 0.75 * minSpacing * ("" + value).length;
          return Math.min(minSpacing / ratio, length);
        }
        class LinearScaleBase extends Scale {
          constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._endValue = void 0;
            this._valueRange = 0;
          }
          parse(raw, index3) {
            if (isNullOrUndef(raw)) {
              return null;
            }
            if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
              return null;
            }
            return +raw;
          }
          handleTickRangeOptions() {
            const { beginAtZero } = this.options;
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this;
            const setMin = (v) => min = minDefined ? min : v;
            const setMax = (v) => max = maxDefined ? max : v;
            if (beginAtZero) {
              const minSign = sign(min);
              const maxSign = sign(max);
              if (minSign < 0 && maxSign < 0) {
                setMax(0);
              } else if (minSign > 0 && maxSign > 0) {
                setMin(0);
              }
            }
            if (min === max) {
              let offset = 1;
              if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
                offset = Math.abs(max * 0.05);
              }
              setMax(max + offset);
              if (!beginAtZero) {
                setMin(min - offset);
              }
            }
            this.min = min;
            this.max = max;
          }
          getTickLimit() {
            const tickOpts = this.options.ticks;
            let { maxTicksLimit, stepSize } = tickOpts;
            let maxTicks;
            if (stepSize) {
              maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
              if (maxTicks > 1e3) {
                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                maxTicks = 1e3;
              }
            } else {
              maxTicks = this.computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
          }
          computeTickLimit() {
            return Number.POSITIVE_INFINITY;
          }
          buildTicks() {
            const opts = this.options;
            const tickOpts = opts.ticks;
            let maxTicks = this.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            const numericGeneratorOptions = {
              maxTicks,
              bounds: opts.bounds,
              min: opts.min,
              max: opts.max,
              precision: tickOpts.precision,
              step: tickOpts.stepSize,
              count: tickOpts.count,
              maxDigits: this._maxDigits(),
              horizontal: this.isHorizontal(),
              minRotation: tickOpts.minRotation || 0,
              includeBounds: tickOpts.includeBounds !== false
            };
            const dataRange = this._range || this;
            const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
            if (opts.bounds === "ticks") {
              _setMinAndMaxByKey(ticks, this, "value");
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          configure() {
            const ticks = this.ticks;
            let start = this.min;
            let end = this.max;
            super.configure();
            if (this.options.offset && ticks.length) {
              const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
              start -= offset;
              end += offset;
            }
            this._startValue = start;
            this._endValue = end;
            this._valueRange = end - start;
          }
          getLabelForValue(value) {
            return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
          }
        }
        class LinearScale extends LinearScaleBase {
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? min : 0;
            this.max = isNumberFinite(max) ? max : 1;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            const horizontal = this.isHorizontal();
            const length = horizontal ? this.width : this.height;
            const minRotation = toRadians(this.options.ticks.minRotation);
            const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
            const tickFont = this._resolveTickFontOptions(0);
            return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
          }
          getPixelForValue(value) {
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
          }
          getValueForPixel(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
          }
        }
        LinearScale.id = "linear";
        LinearScale.defaults = {
          ticks: {
            callback: Ticks.formatters.numeric
          }
        };
        function isMajor(tickVal) {
          const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
          return remain === 1;
        }
        function generateTicks(generationOptions, dataRange) {
          const endExp = Math.floor(log10(dataRange.max));
          const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
          const ticks = [];
          let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
          let exp = Math.floor(log10(tickVal));
          let significand = Math.floor(tickVal / Math.pow(10, exp));
          let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
          do {
            ticks.push({ value: tickVal, major: isMajor(tickVal) });
            ++significand;
            if (significand === 10) {
              significand = 1;
              ++exp;
              precision = exp >= 0 ? 1 : precision;
            }
            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
          } while (exp < endExp || exp === endExp && significand < endSignificand);
          const lastTick = finiteOrDefault(generationOptions.max, tickVal);
          ticks.push({ value: lastTick, major: isMajor(tickVal) });
          return ticks;
        }
        class LogarithmicScale extends Scale {
          constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._valueRange = 0;
          }
          parse(raw, index3) {
            const value = LinearScaleBase.prototype.parse.apply(this, [raw, index3]);
            if (value === 0) {
              this._zero = true;
              return void 0;
            }
            return isNumberFinite(value) && value > 0 ? value : null;
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? Math.max(0, min) : null;
            this.max = isNumberFinite(max) ? Math.max(0, max) : null;
            if (this.options.beginAtZero) {
              this._zero = true;
            }
            this.handleTickRangeOptions();
          }
          handleTickRangeOptions() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let min = this.min;
            let max = this.max;
            const setMin = (v) => min = minDefined ? min : v;
            const setMax = (v) => max = maxDefined ? max : v;
            const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
            if (min === max) {
              if (min <= 0) {
                setMin(1);
                setMax(10);
              } else {
                setMin(exp(min, -1));
                setMax(exp(max, 1));
              }
            }
            if (min <= 0) {
              setMin(exp(max, -1));
            }
            if (max <= 0) {
              setMax(exp(min, 1));
            }
            if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
              setMin(exp(min, -1));
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const opts = this.options;
            const generationOptions = {
              min: this._userMin,
              max: this._userMax
            };
            const ticks = generateTicks(generationOptions, this);
            if (opts.bounds === "ticks") {
              _setMinAndMaxByKey(ticks, this, "value");
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          getLabelForValue(value) {
            return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
          }
          configure() {
            const start = this.min;
            super.configure();
            this._startValue = log10(start);
            this._valueRange = log10(this.max) - log10(start);
          }
          getPixelForValue(value) {
            if (value === void 0 || value === 0) {
              value = this.min;
            }
            if (value === null || isNaN(value)) {
              return NaN;
            }
            return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
          }
          getValueForPixel(pixel) {
            const decimal = this.getDecimalForPixel(pixel);
            return Math.pow(10, this._startValue + decimal * this._valueRange);
          }
        }
        LogarithmicScale.id = "logarithmic";
        LogarithmicScale.defaults = {
          ticks: {
            callback: Ticks.formatters.logarithmic,
            major: {
              enabled: true
            }
          }
        };
        function getTickBackdropHeight(opts) {
          const tickOpts = opts.ticks;
          if (tickOpts.display && opts.display) {
            const padding = toPadding(tickOpts.backdropPadding);
            return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
          }
          return 0;
        }
        function measureLabelSize(ctx, font, label) {
          label = isArray(label) ? label : [label];
          return {
            w: _longestText(ctx, font.string, label),
            h: label.length * font.lineHeight
          };
        }
        function determineLimits(angle, pos, size, min, max) {
          if (angle === min || angle === max) {
            return {
              start: pos - size / 2,
              end: pos + size / 2
            };
          } else if (angle < min || angle > max) {
            return {
              start: pos - size,
              end: pos
            };
          }
          return {
            start: pos,
            end: pos + size
          };
        }
        function fitWithPointLabels(scale) {
          const orig = {
            l: scale.left + scale._padding.left,
            r: scale.right - scale._padding.right,
            t: scale.top + scale._padding.top,
            b: scale.bottom - scale._padding.bottom
          };
          const limits = Object.assign({}, orig);
          const labelSizes = [];
          const padding = [];
          const valueCount = scale._pointLabels.length;
          const pointLabelOpts = scale.options.pointLabels;
          const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
          for (let i = 0; i < valueCount; i++) {
            const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
            padding[i] = opts.padding;
            const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
            const plFont = toFont(opts.font);
            const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
            labelSizes[i] = textSize;
            const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
            const angle = Math.round(toDegrees(angleRadians));
            const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            updateLimits(limits, orig, angleRadians, hLimits, vLimits);
          }
          scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
          scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
        }
        function updateLimits(limits, orig, angle, hLimits, vLimits) {
          const sin = Math.abs(Math.sin(angle));
          const cos = Math.abs(Math.cos(angle));
          let x = 0;
          let y = 0;
          if (hLimits.start < orig.l) {
            x = (orig.l - hLimits.start) / sin;
            limits.l = Math.min(limits.l, orig.l - x);
          } else if (hLimits.end > orig.r) {
            x = (hLimits.end - orig.r) / sin;
            limits.r = Math.max(limits.r, orig.r + x);
          }
          if (vLimits.start < orig.t) {
            y = (orig.t - vLimits.start) / cos;
            limits.t = Math.min(limits.t, orig.t - y);
          } else if (vLimits.end > orig.b) {
            y = (vLimits.end - orig.b) / cos;
            limits.b = Math.max(limits.b, orig.b + y);
          }
        }
        function buildPointLabelItems(scale, labelSizes, padding) {
          const items = [];
          const valueCount = scale._pointLabels.length;
          const opts = scale.options;
          const extra = getTickBackdropHeight(opts) / 2;
          const outerDistance = scale.drawingArea;
          const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
          for (let i = 0; i < valueCount; i++) {
            const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
            const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
            const size = labelSizes[i];
            const y = yForAngle(pointLabelPosition.y, size.h, angle);
            const textAlign = getTextAlignForAngle(angle);
            const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
            items.push({
              x: pointLabelPosition.x,
              y,
              textAlign,
              left,
              top: y,
              right: left + size.w,
              bottom: y + size.h
            });
          }
          return items;
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return "center";
          } else if (angle < 180) {
            return "left";
          }
          return "right";
        }
        function leftForTextAlign(x, w, align) {
          if (align === "right") {
            x -= w;
          } else if (align === "center") {
            x -= w / 2;
          }
          return x;
        }
        function yForAngle(y, h, angle) {
          if (angle === 90 || angle === 270) {
            y -= h / 2;
          } else if (angle > 270 || angle < 90) {
            y -= h;
          }
          return y;
        }
        function drawPointLabels(scale, labelCount) {
          const { ctx, options: { pointLabels } } = scale;
          for (let i = labelCount - 1; i >= 0; i--) {
            const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
            const plFont = toFont(optsAtIndex.font);
            const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
            const { backdropColor } = optsAtIndex;
            if (!isNullOrUndef(backdropColor)) {
              const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
              const padding = toPadding(optsAtIndex.backdropPadding);
              ctx.fillStyle = backdropColor;
              const backdropLeft = left - padding.left;
              const backdropTop = top - padding.top;
              const backdropWidth = right - left + padding.width;
              const backdropHeight = bottom - top + padding.height;
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                  x: backdropLeft,
                  y: backdropTop,
                  w: backdropWidth,
                  h: backdropHeight,
                  radius: borderRadius
                });
                ctx.fill();
              } else {
                ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
              }
            }
            renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
              color: optsAtIndex.color,
              textAlign,
              textBaseline: "middle"
            });
          }
        }
        function pathRadiusLine(scale, radius, circular, labelCount) {
          const { ctx } = scale;
          if (circular) {
            ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
          } else {
            let pointPosition = scale.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (let i = 1; i < labelCount; i++) {
              pointPosition = scale.getPointPosition(i, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
          }
        }
        function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
          const ctx = scale.ctx;
          const circular = gridLineOpts.circular;
          const { color: color2, lineWidth } = gridLineOpts;
          if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
            return;
          }
          ctx.save();
          ctx.strokeStyle = color2;
          ctx.lineWidth = lineWidth;
          ctx.setLineDash(gridLineOpts.borderDash);
          ctx.lineDashOffset = gridLineOpts.borderDashOffset;
          ctx.beginPath();
          pathRadiusLine(scale, radius, circular, labelCount);
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        function createPointLabelContext(parent, index3, label) {
          return createContext(parent, {
            label,
            index: index3,
            type: "pointLabel"
          });
        }
        class RadialLinearScale extends LinearScaleBase {
          constructor(cfg) {
            super(cfg);
            this.xCenter = void 0;
            this.yCenter = void 0;
            this.drawingArea = void 0;
            this._pointLabels = [];
            this._pointLabelItems = [];
          }
          setDimensions() {
            const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
            const w = this.width = this.maxWidth - padding.width;
            const h = this.height = this.maxHeight - padding.height;
            this.xCenter = Math.floor(this.left + w / 2 + padding.left);
            this.yCenter = Math.floor(this.top + h / 2 + padding.top);
            this.drawingArea = Math.floor(Math.min(w, h) / 2);
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(false);
            this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
            this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
          }
          generateTickLabels(ticks) {
            LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
            this._pointLabels = this.getLabels().map((value, index3) => {
              const label = callback(this.options.pointLabels.callback, [value, index3], this);
              return label || label === 0 ? label : "";
            }).filter((v, i) => this.chart.getDataVisibility(i));
          }
          fit() {
            const opts = this.options;
            if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(this);
            } else {
              this.setCenterPoint(0, 0, 0, 0);
            }
          }
          setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
            this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
            this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
            this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
          }
          getIndexAngle(index3) {
            const angleMultiplier = TAU / (this._pointLabels.length || 1);
            const startAngle = this.options.startAngle || 0;
            return _normalizeAngle(index3 * angleMultiplier + toRadians(startAngle));
          }
          getDistanceFromCenterForValue(value) {
            if (isNullOrUndef(value)) {
              return NaN;
            }
            const scalingFactor = this.drawingArea / (this.max - this.min);
            if (this.options.reverse) {
              return (this.max - value) * scalingFactor;
            }
            return (value - this.min) * scalingFactor;
          }
          getValueForDistanceFromCenter(distance2) {
            if (isNullOrUndef(distance2)) {
              return NaN;
            }
            const scaledDistance = distance2 / (this.drawingArea / (this.max - this.min));
            return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
          }
          getPointLabelContext(index3) {
            const pointLabels = this._pointLabels || [];
            if (index3 >= 0 && index3 < pointLabels.length) {
              const pointLabel = pointLabels[index3];
              return createPointLabelContext(this.getContext(), index3, pointLabel);
            }
          }
          getPointPosition(index3, distanceFromCenter, additionalAngle = 0) {
            const angle = this.getIndexAngle(index3) - HALF_PI + additionalAngle;
            return {
              x: Math.cos(angle) * distanceFromCenter + this.xCenter,
              y: Math.sin(angle) * distanceFromCenter + this.yCenter,
              angle
            };
          }
          getPointPositionForValue(index3, value) {
            return this.getPointPosition(index3, this.getDistanceFromCenterForValue(value));
          }
          getBasePosition(index3) {
            return this.getPointPositionForValue(index3 || 0, this.getBaseValue());
          }
          getPointLabelPosition(index3) {
            const { left, top, right, bottom } = this._pointLabelItems[index3];
            return {
              left,
              top,
              right,
              bottom
            };
          }
          drawBackground() {
            const { backgroundColor, grid: { circular } } = this.options;
            if (backgroundColor) {
              const ctx = this.ctx;
              ctx.save();
              ctx.beginPath();
              pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
              ctx.closePath();
              ctx.fillStyle = backgroundColor;
              ctx.fill();
              ctx.restore();
            }
          }
          drawGrid() {
            const ctx = this.ctx;
            const opts = this.options;
            const { angleLines, grid } = opts;
            const labelCount = this._pointLabels.length;
            let i, offset, position;
            if (opts.pointLabels.display) {
              drawPointLabels(this, labelCount);
            }
            if (grid.display) {
              this.ticks.forEach((tick, index3) => {
                if (index3 !== 0) {
                  offset = this.getDistanceFromCenterForValue(tick.value);
                  const optsAtIndex = grid.setContext(this.getContext(index3 - 1));
                  drawRadiusLine(this, optsAtIndex, offset, labelCount);
                }
              });
            }
            if (angleLines.display) {
              ctx.save();
              for (i = labelCount - 1; i >= 0; i--) {
                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                const { color: color2, lineWidth } = optsAtIndex;
                if (!lineWidth || !color2) {
                  continue;
                }
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color2;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
                position = this.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
              }
              ctx.restore();
            }
          }
          drawBorder() {
          }
          drawLabels() {
            const ctx = this.ctx;
            const opts = this.options;
            const tickOpts = opts.ticks;
            if (!tickOpts.display) {
              return;
            }
            const startAngle = this.getIndexAngle(0);
            let offset, width;
            ctx.save();
            ctx.translate(this.xCenter, this.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            this.ticks.forEach((tick, index3) => {
              if (index3 === 0 && !opts.reverse) {
                return;
              }
              const optsAtIndex = tickOpts.setContext(this.getContext(index3));
              const tickFont = toFont(optsAtIndex.font);
              offset = this.getDistanceFromCenterForValue(this.ticks[index3].value);
              if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = toPadding(optsAtIndex.backdropPadding);
                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
              }
              renderText(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color
              });
            });
            ctx.restore();
          }
          drawTitle() {
          }
        }
        RadialLinearScale.id = "radialLinear";
        RadialLinearScale.defaults = {
          display: true,
          animate: true,
          position: "chartArea",
          angleLines: {
            display: true,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
          },
          grid: {
            circular: false
          },
          startAngle: 0,
          ticks: {
            showLabelBackdrop: true,
            callback: Ticks.formatters.numeric
          },
          pointLabels: {
            backdropColor: void 0,
            backdropPadding: 2,
            display: true,
            font: {
              size: 10
            },
            callback(label) {
              return label;
            },
            padding: 5,
            centerPointLabels: false
          }
        };
        RadialLinearScale.defaultRoutes = {
          "angleLines.color": "borderColor",
          "pointLabels.color": "color",
          "ticks.color": "color"
        };
        RadialLinearScale.descriptors = {
          angleLines: {
            _fallback: "grid"
          }
        };
        const INTERVALS = {
          millisecond: { common: true, size: 1, steps: 1e3 },
          second: { common: true, size: 1e3, steps: 60 },
          minute: { common: true, size: 6e4, steps: 60 },
          hour: { common: true, size: 36e5, steps: 24 },
          day: { common: true, size: 864e5, steps: 30 },
          week: { common: false, size: 6048e5, steps: 4 },
          month: { common: true, size: 2628e6, steps: 12 },
          quarter: { common: false, size: 7884e6, steps: 4 },
          year: { common: true, size: 3154e7 }
        };
        const UNITS = Object.keys(INTERVALS);
        function sorter(a, b) {
          return a - b;
        }
        function parse(scale, input) {
          if (isNullOrUndef(input)) {
            return null;
          }
          const adapter = scale._adapter;
          const { parser, round: round2, isoWeekday } = scale._parseOpts;
          let value = input;
          if (typeof parser === "function") {
            value = parser(value);
          }
          if (!isNumberFinite(value)) {
            value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
          }
          if (value === null) {
            return null;
          }
          if (round2) {
            value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
          }
          return +value;
        }
        function determineUnitForAutoTicks(minUnit, min, max, capacity) {
          const ilen = UNITS.length;
          for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            const interval = INTERVALS[UNITS[i]];
            const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
              return UNITS[i];
            }
          }
          return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
          for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
            const unit = UNITS[i];
            if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
              return unit;
            }
          }
          return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
          for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
            if (INTERVALS[UNITS[i]].common) {
              return UNITS[i];
            }
          }
        }
        function addTick(ticks, time, timestamps) {
          if (!timestamps) {
            ticks[time] = true;
          } else if (timestamps.length) {
            const { lo, hi } = _lookup(timestamps, time);
            const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
            ticks[timestamp] = true;
          }
        }
        function setMajorTicks(scale, ticks, map2, majorUnit) {
          const adapter = scale._adapter;
          const first = +adapter.startOf(ticks[0].value, majorUnit);
          const last = ticks[ticks.length - 1].value;
          let major, index3;
          for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
            index3 = map2[major];
            if (index3 >= 0) {
              ticks[index3].major = true;
            }
          }
          return ticks;
        }
        function ticksFromTimestamps(scale, values, majorUnit) {
          const ticks = [];
          const map2 = {};
          const ilen = values.length;
          let i, value;
          for (i = 0; i < ilen; ++i) {
            value = values[i];
            map2[value] = i;
            ticks.push({
              value,
              major: false
            });
          }
          return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
        }
        class TimeScale extends Scale {
          constructor(props) {
            super(props);
            this._cache = {
              data: [],
              labels: [],
              all: []
            };
            this._unit = "day";
            this._majorUnit = void 0;
            this._offsets = {};
            this._normalized = false;
            this._parseOpts = void 0;
          }
          init(scaleOpts, opts) {
            const time = scaleOpts.time || (scaleOpts.time = {});
            const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);
            adapter.init(opts);
            mergeIf(time.displayFormats, adapter.formats());
            this._parseOpts = {
              parser: time.parser,
              round: time.round,
              isoWeekday: time.isoWeekday
            };
            super.init(scaleOpts);
            this._normalized = opts.normalized;
          }
          parse(raw, index3) {
            if (raw === void 0) {
              return null;
            }
            return parse(this, raw);
          }
          beforeLayout() {
            super.beforeLayout();
            this._cache = {
              data: [],
              labels: [],
              all: []
            };
          }
          determineDataLimits() {
            const options = this.options;
            const adapter = this._adapter;
            const unit = options.time.unit || "day";
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            function _applyBounds(bounds) {
              if (!minDefined && !isNaN(bounds.min)) {
                min = Math.min(min, bounds.min);
              }
              if (!maxDefined && !isNaN(bounds.max)) {
                max = Math.max(max, bounds.max);
              }
            }
            if (!minDefined || !maxDefined) {
              _applyBounds(this._getLabelBounds());
              if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
                _applyBounds(this.getMinMax(false));
              }
            }
            min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
            max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
            this.min = Math.min(min, max - 1);
            this.max = Math.max(min + 1, max);
          }
          _getLabelBounds() {
            const arr = this.getLabelTimestamps();
            let min = Number.POSITIVE_INFINITY;
            let max = Number.NEGATIVE_INFINITY;
            if (arr.length) {
              min = arr[0];
              max = arr[arr.length - 1];
            }
            return { min, max };
          }
          buildTicks() {
            const options = this.options;
            const timeOpts = options.time;
            const tickOpts = options.ticks;
            const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
            if (options.bounds === "ticks" && timestamps.length) {
              this.min = this._userMin || timestamps[0];
              this.max = this._userMax || timestamps[timestamps.length - 1];
            }
            const min = this.min;
            const max = this.max;
            const ticks = _filterBetween(timestamps, min, max);
            this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
            this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
            this.initOffsets(timestamps);
            if (options.reverse) {
              ticks.reverse();
            }
            return ticksFromTimestamps(this, ticks, this._majorUnit);
          }
          afterAutoSkip() {
            if (this.options.offsetAfterAutoskip) {
              this.initOffsets(this.ticks.map((tick) => +tick.value));
            }
          }
          initOffsets(timestamps) {
            let start = 0;
            let end = 0;
            let first, last;
            if (this.options.offset && timestamps.length) {
              first = this.getDecimalForValue(timestamps[0]);
              if (timestamps.length === 1) {
                start = 1 - first;
              } else {
                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
              }
              last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
              if (timestamps.length === 1) {
                end = last;
              } else {
                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
              }
            }
            const limit = timestamps.length < 3 ? 0.5 : 0.25;
            start = _limitValue(start, 0, limit);
            end = _limitValue(end, 0, limit);
            this._offsets = { start, end, factor: 1 / (start + 1 + end) };
          }
          _generate() {
            const adapter = this._adapter;
            const min = this.min;
            const max = this.max;
            const options = this.options;
            const timeOpts = options.time;
            const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
            const stepSize = valueOrDefault(timeOpts.stepSize, 1);
            const weekday = minor === "week" ? timeOpts.isoWeekday : false;
            const hasWeekday = isNumber(weekday) || weekday === true;
            const ticks = {};
            let first = min;
            let time, count;
            if (hasWeekday) {
              first = +adapter.startOf(first, "isoWeek", weekday);
            }
            first = +adapter.startOf(first, hasWeekday ? "day" : minor);
            if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
              throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
            }
            const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
            for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
              addTick(ticks, time, timestamps);
            }
            if (time === max || options.bounds === "ticks" || count === 1) {
              addTick(ticks, time, timestamps);
            }
            return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
          }
          getLabelForValue(value) {
            const adapter = this._adapter;
            const timeOpts = this.options.time;
            if (timeOpts.tooltipFormat) {
              return adapter.format(value, timeOpts.tooltipFormat);
            }
            return adapter.format(value, timeOpts.displayFormats.datetime);
          }
          _tickFormatFunction(time, index3, ticks, format) {
            const options = this.options;
            const formats = options.time.displayFormats;
            const unit = this._unit;
            const majorUnit = this._majorUnit;
            const minorFormat = unit && formats[unit];
            const majorFormat = majorUnit && formats[majorUnit];
            const tick = ticks[index3];
            const major = majorUnit && majorFormat && tick && tick.major;
            const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
            const formatter = options.ticks.callback;
            return formatter ? callback(formatter, [label, index3, ticks], this) : label;
          }
          generateTickLabels(ticks) {
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              tick.label = this._tickFormatFunction(tick.value, i, ticks);
            }
          }
          getDecimalForValue(value) {
            return value === null ? NaN : (value - this.min) / (this.max - this.min);
          }
          getPixelForValue(value) {
            const offsets = this._offsets;
            const pos = this.getDecimalForValue(value);
            return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return this.min + pos * (this.max - this.min);
          }
          _getLabelSize(label) {
            const ticksOpts = this.options.ticks;
            const tickLabelWidth = this.ctx.measureText(label).width;
            const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
            const cosRotation = Math.cos(angle);
            const sinRotation = Math.sin(angle);
            const tickFontSize = this._resolveTickFontOptions(0).size;
            return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            };
          }
          _getLabelCapacity(exampleTime) {
            const timeOpts = this.options.time;
            const displayFormats = timeOpts.displayFormats;
            const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
            const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
            const size = this._getLabelSize(exampleLabel);
            const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
            return capacity > 0 ? capacity : 1;
          }
          getDataTimestamps() {
            let timestamps = this._cache.data || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const metas = this.getMatchingVisibleMetas();
            if (this._normalized && metas.length) {
              return this._cache.data = metas[0].controller.getAllParsedValues(this);
            }
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
            }
            return this._cache.data = this.normalize(timestamps);
          }
          getLabelTimestamps() {
            const timestamps = this._cache.labels || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const labels = this.getLabels();
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              timestamps.push(parse(this, labels[i]));
            }
            return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
          }
          normalize(values) {
            return _arrayUnique(values.sort(sorter));
          }
        }
        TimeScale.id = "time";
        TimeScale.defaults = {
          bounds: "data",
          adapters: {},
          time: {
            parser: false,
            unit: false,
            round: false,
            isoWeekday: false,
            minUnit: "millisecond",
            displayFormats: {}
          },
          ticks: {
            source: "auto",
            major: {
              enabled: false
            }
          }
        };
        function interpolate(table, val, reverse) {
          let lo = 0;
          let hi = table.length - 1;
          let prevSource, nextSource, prevTarget, nextTarget;
          if (reverse) {
            if (val >= table[lo].pos && val <= table[hi].pos) {
              ({ lo, hi } = _lookupByKey(table, "pos", val));
            }
            ({ pos: prevSource, time: prevTarget } = table[lo]);
            ({ pos: nextSource, time: nextTarget } = table[hi]);
          } else {
            if (val >= table[lo].time && val <= table[hi].time) {
              ({ lo, hi } = _lookupByKey(table, "time", val));
            }
            ({ time: prevSource, pos: prevTarget } = table[lo]);
            ({ time: nextSource, pos: nextTarget } = table[hi]);
          }
          const span = nextSource - prevSource;
          return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
        }
        class TimeSeriesScale extends TimeScale {
          constructor(props) {
            super(props);
            this._table = [];
            this._minPos = void 0;
            this._tableRange = void 0;
          }
          initOffsets() {
            const timestamps = this._getTimestampsForTable();
            const table = this._table = this.buildLookupTable(timestamps);
            this._minPos = interpolate(table, this.min);
            this._tableRange = interpolate(table, this.max) - this._minPos;
            super.initOffsets(timestamps);
          }
          buildLookupTable(timestamps) {
            const { min, max } = this;
            const items = [];
            const table = [];
            let i, ilen, prev, curr, next;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
              curr = timestamps[i];
              if (curr >= min && curr <= max) {
                items.push(curr);
              }
            }
            if (items.length < 2) {
              return [
                { time: min, pos: 0 },
                { time: max, pos: 1 }
              ];
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              next = items[i + 1];
              prev = items[i - 1];
              curr = items[i];
              if (Math.round((next + prev) / 2) !== curr) {
                table.push({ time: curr, pos: i / (ilen - 1) });
              }
            }
            return table;
          }
          _getTimestampsForTable() {
            let timestamps = this._cache.all || [];
            if (timestamps.length) {
              return timestamps;
            }
            const data = this.getDataTimestamps();
            const label = this.getLabelTimestamps();
            if (data.length && label.length) {
              timestamps = this.normalize(data.concat(label));
            } else {
              timestamps = data.length ? data : label;
            }
            timestamps = this._cache.all = timestamps;
            return timestamps;
          }
          getDecimalForValue(value) {
            return (interpolate(this._table, value) - this._minPos) / this._tableRange;
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
          }
        }
        TimeSeriesScale.id = "timeseries";
        TimeSeriesScale.defaults = TimeScale.defaults;
        var scales = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          CategoryScale,
          LinearScale,
          LogarithmicScale,
          RadialLinearScale,
          TimeScale,
          TimeSeriesScale
        });
        Chart3.register(controllers, scales, elements, plugins);
        Chart3.helpers = __spreadValues({}, helpers);
        Chart3._adapters = _adapters;
        Chart3.Animation = Animation;
        Chart3.Animations = Animations;
        Chart3.animator = animator;
        Chart3.controllers = registry.controllers.items;
        Chart3.DatasetController = DatasetController;
        Chart3.Element = Element2;
        Chart3.elements = elements;
        Chart3.Interaction = Interaction;
        Chart3.layouts = layouts;
        Chart3.platforms = platforms;
        Chart3.Scale = Scale;
        Chart3.Ticks = Ticks;
        Object.assign(Chart3, controllers, scales, elements, plugins, platforms);
        Chart3.Chart = Chart3;
        if (typeof window !== "undefined") {
          window.Chart = Chart3;
        }
        return Chart3;
      });
    }
  });

  // node_modules/chart.js/helpers/helpers.js
  var require_helpers = __commonJS({
    "node_modules/chart.js/helpers/helpers.js"(exports, module) {
      module.exports = require_chart().helpers;
    }
  });

  // node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.js
  var require_chartjs_plugin_datalabels = __commonJS({
    "node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_helpers(), require_chart()) : typeof define === "function" && define.amd ? define(["chart.js/helpers", "chart.js"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.ChartDataLabels = factory(global2.Chart.helpers, global2.Chart));
      })(exports, function(helpers, chart_js) {
        "use strict";
        var devicePixelRatio = function() {
          if (typeof window !== "undefined") {
            if (window.devicePixelRatio) {
              return window.devicePixelRatio;
            }
            var screen = window.screen;
            if (screen) {
              return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
            }
          }
          return 1;
        }();
        var utils = {
          toTextLines: function(inputs) {
            var lines = [];
            var input;
            inputs = [].concat(inputs);
            while (inputs.length) {
              input = inputs.pop();
              if (typeof input === "string") {
                lines.unshift.apply(lines, input.split("\n"));
              } else if (Array.isArray(input)) {
                inputs.push.apply(inputs, input);
              } else if (!helpers.isNullOrUndef(inputs)) {
                lines.unshift("" + input);
              }
            }
            return lines;
          },
          textSize: function(ctx, lines, font) {
            var items = [].concat(lines);
            var ilen = items.length;
            var prev = ctx.font;
            var width = 0;
            var i;
            ctx.font = font.string;
            for (i = 0; i < ilen; ++i) {
              width = Math.max(ctx.measureText(items[i]).width, width);
            }
            ctx.font = prev;
            return {
              height: ilen * font.lineHeight,
              width
            };
          },
          bound: function(min, value, max) {
            return Math.max(min, Math.min(value, max));
          },
          arrayDiff: function(a0, a1) {
            var prev = a0.slice();
            var updates = [];
            var i, j, ilen, v;
            for (i = 0, ilen = a1.length; i < ilen; ++i) {
              v = a1[i];
              j = prev.indexOf(v);
              if (j === -1) {
                updates.push([v, 1]);
              } else {
                prev.splice(j, 1);
              }
            }
            for (i = 0, ilen = prev.length; i < ilen; ++i) {
              updates.push([prev[i], -1]);
            }
            return updates;
          },
          rasterize: function(v) {
            return Math.round(v * devicePixelRatio) / devicePixelRatio;
          }
        };
        function orient(point, origin) {
          var x0 = origin.x;
          var y0 = origin.y;
          if (x0 === null) {
            return { x: 0, y: -1 };
          }
          if (y0 === null) {
            return { x: 1, y: 0 };
          }
          var dx = point.x - x0;
          var dy = point.y - y0;
          var ln = Math.sqrt(dx * dx + dy * dy);
          return {
            x: ln ? dx / ln : 0,
            y: ln ? dy / ln : -1
          };
        }
        function aligned(x, y, vx, vy, align) {
          switch (align) {
            case "center":
              vx = vy = 0;
              break;
            case "bottom":
              vx = 0;
              vy = 1;
              break;
            case "right":
              vx = 1;
              vy = 0;
              break;
            case "left":
              vx = -1;
              vy = 0;
              break;
            case "top":
              vx = 0;
              vy = -1;
              break;
            case "start":
              vx = -vx;
              vy = -vy;
              break;
            case "end":
              break;
            default:
              align *= Math.PI / 180;
              vx = Math.cos(align);
              vy = Math.sin(align);
              break;
          }
          return {
            x,
            y,
            vx,
            vy
          };
        }
        var R_INSIDE = 0;
        var R_LEFT = 1;
        var R_RIGHT = 2;
        var R_BOTTOM = 4;
        var R_TOP = 8;
        function region(x, y, rect) {
          var res = R_INSIDE;
          if (x < rect.left) {
            res |= R_LEFT;
          } else if (x > rect.right) {
            res |= R_RIGHT;
          }
          if (y < rect.top) {
            res |= R_TOP;
          } else if (y > rect.bottom) {
            res |= R_BOTTOM;
          }
          return res;
        }
        function clipped(segment, area) {
          var x0 = segment.x0;
          var y0 = segment.y0;
          var x1 = segment.x1;
          var y1 = segment.y1;
          var r0 = region(x0, y0, area);
          var r1 = region(x1, y1, area);
          var r, x, y;
          while (true) {
            if (!(r0 | r1) || r0 & r1) {
              break;
            }
            r = r0 || r1;
            if (r & R_TOP) {
              x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);
              y = area.top;
            } else if (r & R_BOTTOM) {
              x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);
              y = area.bottom;
            } else if (r & R_RIGHT) {
              y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);
              x = area.right;
            } else if (r & R_LEFT) {
              y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);
              x = area.left;
            }
            if (r === r0) {
              x0 = x;
              y0 = y;
              r0 = region(x0, y0, area);
            } else {
              x1 = x;
              y1 = y;
              r1 = region(x1, y1, area);
            }
          }
          return {
            x0,
            x1,
            y0,
            y1
          };
        }
        function compute$1(range2, config) {
          var anchor = config.anchor;
          var segment = range2;
          var x, y;
          if (config.clamp) {
            segment = clipped(segment, config.area);
          }
          if (anchor === "start") {
            x = segment.x0;
            y = segment.y0;
          } else if (anchor === "end") {
            x = segment.x1;
            y = segment.y1;
          } else {
            x = (segment.x0 + segment.x1) / 2;
            y = (segment.y0 + segment.y1) / 2;
          }
          return aligned(x, y, range2.vx, range2.vy, config.align);
        }
        var positioners = {
          arc: function(el, config) {
            var angle = (el.startAngle + el.endAngle) / 2;
            var vx = Math.cos(angle);
            var vy = Math.sin(angle);
            var r0 = el.innerRadius;
            var r1 = el.outerRadius;
            return compute$1({
              x0: el.x + vx * r0,
              y0: el.y + vy * r0,
              x1: el.x + vx * r1,
              y1: el.y + vy * r1,
              vx,
              vy
            }, config);
          },
          point: function(el, config) {
            var v = orient(el, config.origin);
            var rx = v.x * el.options.radius;
            var ry = v.y * el.options.radius;
            return compute$1({
              x0: el.x - rx,
              y0: el.y - ry,
              x1: el.x + rx,
              y1: el.y + ry,
              vx: v.x,
              vy: v.y
            }, config);
          },
          bar: function(el, config) {
            var v = orient(el, config.origin);
            var x = el.x;
            var y = el.y;
            var sx = 0;
            var sy = 0;
            if (el.horizontal) {
              x = Math.min(el.x, el.base);
              sx = Math.abs(el.base - el.x);
            } else {
              y = Math.min(el.y, el.base);
              sy = Math.abs(el.base - el.y);
            }
            return compute$1({
              x0: x,
              y0: y + sy,
              x1: x + sx,
              y1: y,
              vx: v.x,
              vy: v.y
            }, config);
          },
          fallback: function(el, config) {
            var v = orient(el, config.origin);
            return compute$1({
              x0: el.x,
              y0: el.y,
              x1: el.x + (el.width || 0),
              y1: el.y + (el.height || 0),
              vx: v.x,
              vy: v.y
            }, config);
          }
        };
        var rasterize = utils.rasterize;
        function boundingRects(model) {
          var borderWidth = model.borderWidth || 0;
          var padding = model.padding;
          var th = model.size.height;
          var tw = model.size.width;
          var tx = -tw / 2;
          var ty = -th / 2;
          return {
            frame: {
              x: tx - padding.left - borderWidth,
              y: ty - padding.top - borderWidth,
              w: tw + padding.width + borderWidth * 2,
              h: th + padding.height + borderWidth * 2
            },
            text: {
              x: tx,
              y: ty,
              w: tw,
              h: th
            }
          };
        }
        function getScaleOrigin(el, context) {
          var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;
          if (!scale) {
            return null;
          }
          if (scale.xCenter !== void 0 && scale.yCenter !== void 0) {
            return { x: scale.xCenter, y: scale.yCenter };
          }
          var pixel = scale.getBasePixel();
          return el.horizontal ? { x: pixel, y: null } : { x: null, y: pixel };
        }
        function getPositioner(el) {
          if (el instanceof chart_js.ArcElement) {
            return positioners.arc;
          }
          if (el instanceof chart_js.PointElement) {
            return positioners.point;
          }
          if (el instanceof chart_js.BarElement) {
            return positioners.bar;
          }
          return positioners.fallback;
        }
        function drawRoundedRect(ctx, x, y, w, h, radius) {
          var HALF_PI = Math.PI / 2;
          if (radius) {
            var r = Math.min(radius, h / 2, w / 2);
            var left = x + r;
            var top = y + r;
            var right = x + w - r;
            var bottom = y + h - r;
            ctx.moveTo(x, top);
            if (left < right && top < bottom) {
              ctx.arc(left, top, r, -Math.PI, -HALF_PI);
              ctx.arc(right, top, r, -HALF_PI, 0);
              ctx.arc(right, bottom, r, 0, HALF_PI);
              ctx.arc(left, bottom, r, HALF_PI, Math.PI);
            } else if (left < right) {
              ctx.moveTo(left, y);
              ctx.arc(right, top, r, -HALF_PI, HALF_PI);
              ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);
            } else if (top < bottom) {
              ctx.arc(left, top, r, -Math.PI, 0);
              ctx.arc(left, bottom, r, 0, Math.PI);
            } else {
              ctx.arc(left, top, r, -Math.PI, Math.PI);
            }
            ctx.closePath();
            ctx.moveTo(x, y);
          } else {
            ctx.rect(x, y, w, h);
          }
        }
        function drawFrame(ctx, rect, model) {
          var bgColor = model.backgroundColor;
          var borderColor = model.borderColor;
          var borderWidth = model.borderWidth;
          if (!bgColor && (!borderColor || !borderWidth)) {
            return;
          }
          ctx.beginPath();
          drawRoundedRect(ctx, rasterize(rect.x) + borderWidth / 2, rasterize(rect.y) + borderWidth / 2, rasterize(rect.w) - borderWidth, rasterize(rect.h) - borderWidth, model.borderRadius);
          ctx.closePath();
          if (bgColor) {
            ctx.fillStyle = bgColor;
            ctx.fill();
          }
          if (borderColor && borderWidth) {
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = "miter";
            ctx.stroke();
          }
        }
        function textGeometry(rect, align, font) {
          var h = font.lineHeight;
          var w = rect.w;
          var x = rect.x;
          var y = rect.y + h / 2;
          if (align === "center") {
            x += w / 2;
          } else if (align === "end" || align === "right") {
            x += w;
          }
          return {
            h,
            w,
            x,
            y
          };
        }
        function drawTextLine(ctx, text, cfg) {
          var shadow = ctx.shadowBlur;
          var stroked = cfg.stroked;
          var x = rasterize(cfg.x);
          var y = rasterize(cfg.y);
          var w = rasterize(cfg.w);
          if (stroked) {
            ctx.strokeText(text, x, y, w);
          }
          if (cfg.filled) {
            if (shadow && stroked) {
              ctx.shadowBlur = 0;
            }
            ctx.fillText(text, x, y, w);
            if (shadow && stroked) {
              ctx.shadowBlur = shadow;
            }
          }
        }
        function drawText(ctx, lines, rect, model) {
          var align = model.textAlign;
          var color = model.color;
          var filled = !!color;
          var font = model.font;
          var ilen = lines.length;
          var strokeColor = model.textStrokeColor;
          var strokeWidth = model.textStrokeWidth;
          var stroked = strokeColor && strokeWidth;
          var i;
          if (!ilen || !filled && !stroked) {
            return;
          }
          rect = textGeometry(rect, align, font);
          ctx.font = font.string;
          ctx.textAlign = align;
          ctx.textBaseline = "middle";
          ctx.shadowBlur = model.textShadowBlur;
          ctx.shadowColor = model.textShadowColor;
          if (filled) {
            ctx.fillStyle = color;
          }
          if (stroked) {
            ctx.lineJoin = "round";
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
          }
          for (i = 0, ilen = lines.length; i < ilen; ++i) {
            drawTextLine(ctx, lines[i], {
              stroked,
              filled,
              w: rect.w,
              x: rect.x,
              y: rect.y + rect.h * i
            });
          }
        }
        var Label = function(config, ctx, el, index2) {
          var me = this;
          me._config = config;
          me._index = index2;
          me._model = null;
          me._rects = null;
          me._ctx = ctx;
          me._el = el;
        };
        helpers.merge(Label.prototype, {
          _modelize: function(display, lines, config, context) {
            var me = this;
            var index2 = me._index;
            var font = helpers.toFont(helpers.resolve([config.font, {}], context, index2));
            var color = helpers.resolve([config.color, chart_js.defaults.color], context, index2);
            return {
              align: helpers.resolve([config.align, "center"], context, index2),
              anchor: helpers.resolve([config.anchor, "center"], context, index2),
              area: context.chart.chartArea,
              backgroundColor: helpers.resolve([config.backgroundColor, null], context, index2),
              borderColor: helpers.resolve([config.borderColor, null], context, index2),
              borderRadius: helpers.resolve([config.borderRadius, 0], context, index2),
              borderWidth: helpers.resolve([config.borderWidth, 0], context, index2),
              clamp: helpers.resolve([config.clamp, false], context, index2),
              clip: helpers.resolve([config.clip, false], context, index2),
              color,
              display,
              font,
              lines,
              offset: helpers.resolve([config.offset, 4], context, index2),
              opacity: helpers.resolve([config.opacity, 1], context, index2),
              origin: getScaleOrigin(me._el, context),
              padding: helpers.toPadding(helpers.resolve([config.padding, 4], context, index2)),
              positioner: getPositioner(me._el),
              rotation: helpers.resolve([config.rotation, 0], context, index2) * (Math.PI / 180),
              size: utils.textSize(me._ctx, lines, font),
              textAlign: helpers.resolve([config.textAlign, "start"], context, index2),
              textShadowBlur: helpers.resolve([config.textShadowBlur, 0], context, index2),
              textShadowColor: helpers.resolve([config.textShadowColor, color], context, index2),
              textStrokeColor: helpers.resolve([config.textStrokeColor, color], context, index2),
              textStrokeWidth: helpers.resolve([config.textStrokeWidth, 0], context, index2)
            };
          },
          update: function(context) {
            var me = this;
            var model = null;
            var rects = null;
            var index2 = me._index;
            var config = me._config;
            var value, label, lines;
            var display = helpers.resolve([config.display, true], context, index2);
            if (display) {
              value = context.dataset.data[index2];
              label = helpers.valueOrDefault(helpers.callback(config.formatter, [value, context]), value);
              lines = helpers.isNullOrUndef(label) ? [] : utils.toTextLines(label);
              if (lines.length) {
                model = me._modelize(display, lines, config, context);
                rects = boundingRects(model);
              }
            }
            me._model = model;
            me._rects = rects;
          },
          geometry: function() {
            return this._rects ? this._rects.frame : {};
          },
          rotation: function() {
            return this._model ? this._model.rotation : 0;
          },
          visible: function() {
            return this._model && this._model.opacity;
          },
          model: function() {
            return this._model;
          },
          draw: function(chart2, center) {
            var me = this;
            var ctx = chart2.ctx;
            var model = me._model;
            var rects = me._rects;
            var area;
            if (!this.visible()) {
              return;
            }
            ctx.save();
            if (model.clip) {
              area = model.area;
              ctx.beginPath();
              ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
              ctx.clip();
            }
            ctx.globalAlpha = utils.bound(0, model.opacity, 1);
            ctx.translate(rasterize(center.x), rasterize(center.y));
            ctx.rotate(model.rotation);
            drawFrame(ctx, rects.frame, model);
            drawText(ctx, model.lines, rects.text, model);
            ctx.restore();
          }
        });
        var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
        var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        function rotated(point, center, angle) {
          var cos = Math.cos(angle);
          var sin = Math.sin(angle);
          var cx = center.x;
          var cy = center.y;
          return {
            x: cx + cos * (point.x - cx) - sin * (point.y - cy),
            y: cy + sin * (point.x - cx) + cos * (point.y - cy)
          };
        }
        function projected(points, axis) {
          var min = MAX_INTEGER;
          var max = MIN_INTEGER;
          var origin = axis.origin;
          var i, pt, vx, vy, dp;
          for (i = 0; i < points.length; ++i) {
            pt = points[i];
            vx = pt.x - origin.x;
            vy = pt.y - origin.y;
            dp = axis.vx * vx + axis.vy * vy;
            min = Math.min(min, dp);
            max = Math.max(max, dp);
          }
          return {
            min,
            max
          };
        }
        function toAxis(p0, p1) {
          var vx = p1.x - p0.x;
          var vy = p1.y - p0.y;
          var ln = Math.sqrt(vx * vx + vy * vy);
          return {
            vx: (p1.x - p0.x) / ln,
            vy: (p1.y - p0.y) / ln,
            origin: p0,
            ln
          };
        }
        var HitBox = function() {
          this._rotation = 0;
          this._rect = {
            x: 0,
            y: 0,
            w: 0,
            h: 0
          };
        };
        helpers.merge(HitBox.prototype, {
          center: function() {
            var r = this._rect;
            return {
              x: r.x + r.w / 2,
              y: r.y + r.h / 2
            };
          },
          update: function(center, rect, rotation) {
            this._rotation = rotation;
            this._rect = {
              x: rect.x + center.x,
              y: rect.y + center.y,
              w: rect.w,
              h: rect.h
            };
          },
          contains: function(point) {
            var me = this;
            var margin = 1;
            var rect = me._rect;
            point = rotated(point, me.center(), -me._rotation);
            return !(point.x < rect.x - margin || point.y < rect.y - margin || point.x > rect.x + rect.w + margin * 2 || point.y > rect.y + rect.h + margin * 2);
          },
          intersects: function(other) {
            var r0 = this._points();
            var r1 = other._points();
            var axes = [
              toAxis(r0[0], r0[1]),
              toAxis(r0[0], r0[3])
            ];
            var i, pr0, pr1;
            if (this._rotation !== other._rotation) {
              axes.push(toAxis(r1[0], r1[1]), toAxis(r1[0], r1[3]));
            }
            for (i = 0; i < axes.length; ++i) {
              pr0 = projected(r0, axes[i]);
              pr1 = projected(r1, axes[i]);
              if (pr0.max < pr1.min || pr1.max < pr0.min) {
                return false;
              }
            }
            return true;
          },
          _points: function() {
            var me = this;
            var rect = me._rect;
            var angle = me._rotation;
            var center = me.center();
            return [
              rotated({ x: rect.x, y: rect.y }, center, angle),
              rotated({ x: rect.x + rect.w, y: rect.y }, center, angle),
              rotated({ x: rect.x + rect.w, y: rect.y + rect.h }, center, angle),
              rotated({ x: rect.x, y: rect.y + rect.h }, center, angle)
            ];
          }
        });
        function coordinates(el, model, geometry) {
          var point = model.positioner(el, model);
          var vx = point.vx;
          var vy = point.vy;
          if (!vx && !vy) {
            return { x: point.x, y: point.y };
          }
          var w = geometry.w;
          var h = geometry.h;
          var rotation = model.rotation;
          var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));
          var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));
          var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
          dx *= vx * vs;
          dy *= vy * vs;
          dx += model.offset * vx;
          dy += model.offset * vy;
          return {
            x: point.x + dx,
            y: point.y + dy
          };
        }
        function collide(labels, collider) {
          var i, j, s0, s1;
          for (i = labels.length - 1; i >= 0; --i) {
            s0 = labels[i].$layout;
            for (j = i - 1; j >= 0 && s0._visible; --j) {
              s1 = labels[j].$layout;
              if (s1._visible && s0._box.intersects(s1._box)) {
                collider(s0, s1);
              }
            }
          }
          return labels;
        }
        function compute(labels) {
          var i, ilen, label, state, geometry, center, proxy;
          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            label = labels[i];
            state = label.$layout;
            if (state._visible) {
              proxy = new Proxy(label._el, { get: (el, p) => el.getProps([p], true)[p] });
              geometry = label.geometry();
              center = coordinates(proxy, label.model(), geometry);
              state._box.update(center, geometry, label.rotation());
            }
          }
          return collide(labels, function(s0, s1) {
            var h0 = s0._hidable;
            var h1 = s1._hidable;
            if (h0 && h1 || h1) {
              s1._visible = false;
            } else if (h0) {
              s0._visible = false;
            }
          });
        }
        var layout = {
          prepare: function(datasets) {
            var labels = [];
            var i, j, ilen, jlen, label;
            for (i = 0, ilen = datasets.length; i < ilen; ++i) {
              for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {
                label = datasets[i][j];
                labels.push(label);
                label.$layout = {
                  _box: new HitBox(),
                  _hidable: false,
                  _visible: true,
                  _set: i,
                  _idx: label._index
                };
              }
            }
            labels.sort(function(a, b) {
              var sa = a.$layout;
              var sb = b.$layout;
              return sa._idx === sb._idx ? sb._set - sa._set : sb._idx - sa._idx;
            });
            this.update(labels);
            return labels;
          },
          update: function(labels) {
            var dirty = false;
            var i, ilen, label, model, state;
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              label = labels[i];
              model = label.model();
              state = label.$layout;
              state._hidable = model && model.display === "auto";
              state._visible = label.visible();
              dirty |= state._hidable;
            }
            if (dirty) {
              compute(labels);
            }
          },
          lookup: function(labels, point) {
            var i, state;
            for (i = labels.length - 1; i >= 0; --i) {
              state = labels[i].$layout;
              if (state && state._visible && state._box.contains(point)) {
                return labels[i];
              }
            }
            return null;
          },
          draw: function(chart2, labels) {
            var i, ilen, label, state, geometry, center;
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              label = labels[i];
              state = label.$layout;
              if (state._visible) {
                geometry = label.geometry();
                center = coordinates(label._el, label.model(), geometry);
                state._box.update(center, geometry, label.rotation());
                label.draw(chart2, center);
              }
            }
          }
        };
        var formatter = function(value) {
          if (helpers.isNullOrUndef(value)) {
            return null;
          }
          var label = value;
          var keys, klen, k;
          if (helpers.isObject(value)) {
            if (!helpers.isNullOrUndef(value.label)) {
              label = value.label;
            } else if (!helpers.isNullOrUndef(value.r)) {
              label = value.r;
            } else {
              label = "";
              keys = Object.keys(value);
              for (k = 0, klen = keys.length; k < klen; ++k) {
                label += (k !== 0 ? ", " : "") + keys[k] + ": " + value[keys[k]];
              }
            }
          }
          return "" + label;
        };
        var defaults = {
          align: "center",
          anchor: "center",
          backgroundColor: null,
          borderColor: null,
          borderRadius: 0,
          borderWidth: 0,
          clamp: false,
          clip: false,
          color: void 0,
          display: true,
          font: {
            family: void 0,
            lineHeight: 1.2,
            size: void 0,
            style: void 0,
            weight: null
          },
          formatter,
          labels: void 0,
          listeners: {},
          offset: 4,
          opacity: 1,
          padding: {
            top: 4,
            right: 4,
            bottom: 4,
            left: 4
          },
          rotation: 0,
          textAlign: "start",
          textStrokeColor: void 0,
          textStrokeWidth: 0,
          textShadowBlur: 0,
          textShadowColor: void 0
        };
        var EXPANDO_KEY = "$datalabels";
        var DEFAULT_KEY = "$default";
        function configure(dataset, options) {
          var override = dataset.datalabels;
          var listeners = {};
          var configs = [];
          var labels, keys;
          if (override === false) {
            return null;
          }
          if (override === true) {
            override = {};
          }
          options = helpers.merge({}, [options, override]);
          labels = options.labels || {};
          keys = Object.keys(labels);
          delete options.labels;
          if (keys.length) {
            keys.forEach(function(key) {
              if (labels[key]) {
                configs.push(helpers.merge({}, [
                  options,
                  labels[key],
                  { _key: key }
                ]));
              }
            });
          } else {
            configs.push(options);
          }
          listeners = configs.reduce(function(target, config) {
            helpers.each(config.listeners || {}, function(fn, event) {
              target[event] = target[event] || {};
              target[event][config._key || DEFAULT_KEY] = fn;
            });
            delete config.listeners;
            return target;
          }, {});
          return {
            labels: configs,
            listeners
          };
        }
        function dispatchEvent(chart2, listeners, label, event) {
          if (!listeners) {
            return;
          }
          var context = label.$context;
          var groups = label.$groups;
          var callback;
          if (!listeners[groups._set]) {
            return;
          }
          callback = listeners[groups._set][groups._key];
          if (!callback) {
            return;
          }
          if (helpers.callback(callback, [context, event]) === true) {
            chart2[EXPANDO_KEY]._dirty = true;
            label.update(context);
          }
        }
        function dispatchMoveEvents(chart2, listeners, previous, label, event) {
          var enter, leave;
          if (!previous && !label) {
            return;
          }
          if (!previous) {
            enter = true;
          } else if (!label) {
            leave = true;
          } else if (previous !== label) {
            leave = enter = true;
          }
          if (leave) {
            dispatchEvent(chart2, listeners.leave, previous, event);
          }
          if (enter) {
            dispatchEvent(chart2, listeners.enter, label, event);
          }
        }
        function handleMoveEvents(chart2, event) {
          var expando = chart2[EXPANDO_KEY];
          var listeners = expando._listeners;
          var previous, label;
          if (!listeners.enter && !listeners.leave) {
            return;
          }
          if (event.type === "mousemove") {
            label = layout.lookup(expando._labels, event);
          } else if (event.type !== "mouseout") {
            return;
          }
          previous = expando._hovered;
          expando._hovered = label;
          dispatchMoveEvents(chart2, listeners, previous, label, event);
        }
        function handleClickEvents(chart2, event) {
          var expando = chart2[EXPANDO_KEY];
          var handlers = expando._listeners.click;
          var label = handlers && layout.lookup(expando._labels, event);
          if (label) {
            dispatchEvent(chart2, handlers, label, event);
          }
        }
        var plugin = {
          id: "datalabels",
          defaults,
          beforeInit: function(chart2) {
            chart2[EXPANDO_KEY] = {
              _actives: []
            };
          },
          beforeUpdate: function(chart2) {
            var expando = chart2[EXPANDO_KEY];
            expando._listened = false;
            expando._listeners = {};
            expando._datasets = [];
            expando._labels = [];
          },
          afterDatasetUpdate: function(chart2, args, options) {
            var datasetIndex = args.index;
            var expando = chart2[EXPANDO_KEY];
            var labels = expando._datasets[datasetIndex] = [];
            var visible = chart2.isDatasetVisible(datasetIndex);
            var dataset = chart2.data.datasets[datasetIndex];
            var config = configure(dataset, options);
            var elements = args.meta.data || [];
            var ctx = chart2.ctx;
            var i, j, ilen, jlen, cfg, key, el, label;
            ctx.save();
            for (i = 0, ilen = elements.length; i < ilen; ++i) {
              el = elements[i];
              el[EXPANDO_KEY] = [];
              if (visible && el && chart2.getDataVisibility(i) && !el.skip) {
                for (j = 0, jlen = config.labels.length; j < jlen; ++j) {
                  cfg = config.labels[j];
                  key = cfg._key;
                  label = new Label(cfg, ctx, el, i);
                  label.$groups = {
                    _set: datasetIndex,
                    _key: key || DEFAULT_KEY
                  };
                  label.$context = {
                    active: false,
                    chart: chart2,
                    dataIndex: i,
                    dataset,
                    datasetIndex
                  };
                  label.update(label.$context);
                  el[EXPANDO_KEY].push(label);
                  labels.push(label);
                }
              }
            }
            ctx.restore();
            helpers.merge(expando._listeners, config.listeners, {
              merger: function(event, target, source) {
                target[event] = target[event] || {};
                target[event][args.index] = source[event];
                expando._listened = true;
              }
            });
          },
          afterUpdate: function(chart2) {
            chart2[EXPANDO_KEY]._labels = layout.prepare(chart2[EXPANDO_KEY]._datasets);
          },
          afterDatasetsDraw: function(chart2) {
            layout.draw(chart2, chart2[EXPANDO_KEY]._labels);
          },
          beforeEvent: function(chart2, args) {
            if (chart2[EXPANDO_KEY]._listened) {
              var event = args.event;
              switch (event.type) {
                case "mousemove":
                case "mouseout":
                  handleMoveEvents(chart2, event);
                  break;
                case "click":
                  handleClickEvents(chart2, event);
                  break;
              }
            }
          },
          afterEvent: function(chart2) {
            var expando = chart2[EXPANDO_KEY];
            var previous = expando._actives;
            var actives = expando._actives = chart2.getActiveElements();
            var updates = utils.arrayDiff(previous, actives);
            var i, ilen, j, jlen, update, label, labels;
            for (i = 0, ilen = updates.length; i < ilen; ++i) {
              update = updates[i];
              if (update[1]) {
                labels = update[0].element[EXPANDO_KEY] || [];
                for (j = 0, jlen = labels.length; j < jlen; ++j) {
                  label = labels[j];
                  label.$context.active = update[1] === 1;
                  label.update(label.$context);
                }
              }
            }
            if (expando._dirty || updates.length) {
              layout.update(expando._labels);
              chart2.render();
            }
            delete expando._dirty;
          }
        };
        return plugin;
      });
    }
  });

  // node_modules/bootstrap-icons/font/bootstrap-icons.css
  var require_ = __commonJS({
    "node_modules/bootstrap-icons/font/bootstrap-icons.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/material-icons/iconfont/material-icons.css
  var require_2 = __commonJS({
    "node_modules/material-icons/iconfont/material-icons.css"(exports, module) {
      module.exports = {};
    }
  });

  // js/app.js
  var import_tom_select2 = __toModule(require_tom_select_complete());

  // js/tom_select_saisie_page.js
  var import_tom_select = __toModule(require_tom_select_complete());
  function saveRow(icon) {
    const row = icon.closest("tr");
    const inputs = row.querySelectorAll("input, select");
    const rowData = {};
    inputs.forEach((input) => {
      rowData[input.name] = input.value;
    });
    console.log("Donn\xE9es \xE0 sauvegarder:", rowData);
    const csrfToken2 = document.querySelector('meta[name="csrf-token"]').getAttribute("content");
    fetch("/save_saisie", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRF-Token": csrfToken2
      },
      body: JSON.stringify(rowData)
    }).then((response) => {
      console.log(" response : ", response);
      if (!response.ok) {
        throw new Error("Erreur lors de la sauvegarde des donn\xE9es");
      }
      return response.json();
    }).then((data) => {
      console.log("Succ\xE8s:", data.message);
      window.location.reload();
    }).catch((error) => {
      console.error("Erreur :", error);
      alert("Une erreur est survenue lors de la sauvegarde. Veuillez v\xE9rifier que tous les champs sont bien remplis et au bon format");
    });
  }
  function removeRow(icon) {
    icon.closest("tr").remove();
  }
  function isDecimalValid(inputValue) {
    const numericValue = parseFloat(inputValue);
    return !isNaN(numericValue) && numericValue >= 0 && numericValue <= 20;
  }
  function isLabelValid(inputValue) {
    return inputValue.trim() !== "" && inputValue.length <= 255;
  }
  function isProjectIdValid(value) {
    return value.trim() !== "";
  }
  function isTaskValid(selectedTask) {
    return selectedTask !== "";
  }
  function handleDecimalInput(event) {
    if (this.value.includes("+") || this.value.includes("-")) {
      const formattedValue = stringFormat.replace(/[+-]/g, "");
      this.value = formattedValue;
    }
    if (!isDecimalValid(this.value)) {
      this.style.borderColor = "red";
    } else {
      const decimalLength = (this.value.split(".")[1] || "").length;
      console.log(decimalLength);
      if (decimalLength > 2) {
        valeur = parseFloat(this.value).toFixed(2);
        this.value = valeur;
      }
      this.style.borderColor = "green";
    }
  }
  function handleLabelInput(event) {
    if (!isLabelValid(this.value)) {
      this.style.borderColor = "red";
    } else {
      this.style.borderColor = "green";
    }
  }
  function handleProjectSelectChange(event, task_tom_select2) {
    const projectElement = document.querySelector(".project_id");
    const tsControlElement = projectElement.querySelector(".ts-control");
    const selectedProjectId = event.target.value;
    if (!isProjectIdValid(selectedProjectId)) {
      console.log("makato amin red");
      tsControlElement.style.borderColor = "red";
    } else {
      console.log("makato amin green");
      tsControlElement.style.borderColor = "green";
    }
    updateTaskOptions(selectedProjectId, task_tom_select2);
  }
  function handleTaskSelectChange(event) {
    const taskElement = document.querySelector(".task");
    const tsControlElement = taskElement.querySelector(".ts-control");
    const selectedTask = event.target.value;
    if (!isTaskValid(selectedTask)) {
      console.log("La t\xE2che s\xE9lectionn\xE9e est invalide");
      tsControlElement.style.borderColor = "red";
    } else {
      console.log("La t\xE2che s\xE9lectionn\xE9e est valide");
      tsControlElement.style.borderColor = "green";
    }
  }
  function applyFieldValidations(tableBody) {
    const taskElement = tableBody.querySelector(".task");
    const tsControlElement1 = taskElement.querySelector(".ts-control");
    tsControlElement1.style.borderColor = "red";
    const projectElement = tableBody.querySelector(".project_id");
    const tsControlElement = projectElement.querySelector(".ts-control");
    tsControlElement.style.borderColor = "red";
    const labelInput = tableBody.querySelector('tr:last-child input[name="labels"]');
    labelInput.style.borderColor = "red";
  }
  function lineValidation(tableBody) {
    const labelInput = tableBody.querySelector('tr:last-child input[name="labels"]');
    const taskSelect = tableBody.querySelector('tr:last-child select[name="task"]');
    const projectSelect = tableBody.querySelector('tr:last-child select[name="project_id"]');
    const decimalInput = tableBody.querySelector('tr:last-child input[name="hours"]');
    const isLabelValidResult = isLabelValid(labelInput.value);
    const isTaskValidResult = isTaskValid(taskSelect.value);
    const isProjectIdValidResult = isProjectIdValid(projectSelect.value);
    const isDecimalValidResult = isDecimalValid(decimalInput.value);
    return isLabelValidResult && isTaskValidResult && isProjectIdValidResult && isDecimalValidResult;
  }
  function haveLineNotSaved(tableBody) {
    const newTaskSelect = tableBody.querySelector('tr:last-child select[name="task"]');
    if (newTaskSelect != null)
      return true;
    else
      return false;
  }
  function addRow(tableBody, TomSelect4, userId, date, username, projects) {
    const newRow = `
        <tr>
            <input type="hidden" name="user_id" value="${userId}">
            <td class="date"><input type="date" name="date" value="${date}"></td>
            <td class="user"><input type="text" name="user" value="${username}" readonly></td>
            <td class="project_id">
                <select name="project_id" id="tom_select">
                    <option value="">S\xE9lectionner un projet</option>
                    ${projects.map((project) => `<option value="${project.id}">${project.title}</option>`).join("")}
                </select>
            </td>
            <td class="client">
                <input type="text" name="client_name" value="" readonly>
            </td>
            <td class="task">
                <select name="task" id="tasks_select" placeholder="S\xE9lectioner une t\xE2che"></select>
            </td>
            <td class="labels"><input type="text" name="labels" placeholder="Libell\xE9"></td>
            <td class="temps">
                <input type="number" id="decimal_input" name="hours" step="0.1" value="0.0">
            </td>
            <td class="actions">
                <i title="Sauvegarder" class="bi bi-save" style="cursor: pointer;"></i>
                <i title="Supprimer" id="suppr" class="bi bi-trash" style="cursor: pointer;" ></i>
            </td>
        </tr>
    `;
    tableBody.insertAdjacentHTML("beforeend", newRow);
    const newProjectSelect = tableBody.querySelector('tr:last-child select[name="project_id"]');
    new TomSelect4(newProjectSelect, {
      searchable: true,
      sortField: {
        field: "text",
        direction: "asc"
      }
    });
    const newTaskSelect = tableBody.querySelector('tr:last-child select[name="task"]');
    newTaskSelect.addEventListener("change", handleTaskSelectChange);
    task_tom_select = new TomSelect4(newTaskSelect, {
      searchable: true,
      sortField: {
        field: "text",
        direction: "asc"
      }
    });
    applyFieldValidations(tableBody);
    const projectSelect = document.querySelector('select[name="project_id"]');
    projectSelect.addEventListener("change", function(event) {
      handleProjectSelectChange(event, task_tom_select);
    });
    const decimalInput = tableBody.querySelector('tr:last-child input[name="hours"]');
    decimalInput.addEventListener("input", handleDecimalInput);
    const labelInput = tableBody.querySelector('tr:last-child input[name="labels"]');
    labelInput.addEventListener("input", handleLabelInput);
    const newSaveIcon = tableBody.querySelector(".bi-save");
    newSaveIcon.addEventListener("click", function() {
      const isValid = lineValidation(tableBody);
      if (isValid) {
        saveRow(newSaveIcon);
      } else {
        console.log("Les champs ne sont pas valides. Veuillez v\xE9rifier vos saisies.");
      }
    });
    const newRemoveIcon = tableBody.querySelector("#suppr");
    console.log(newRemoveIcon);
    newRemoveIcon.addEventListener("click", function() {
      removeRow(newRemoveIcon);
      resetAddRowIcon();
    });
  }
  function updateTaskOptions(selectedProjectId, taskTomSelect) {
    fetch(`/tasks/${selectedProjectId}`).then((response) => {
      console.log(response);
      if (!response.ok) {
        throw new Error("Erreur lors de la r\xE9cup\xE9ration des t\xE2ches");
      }
      return response.json();
    }).then((data) => {
      console.log(data);
      const tasks = data.tasks;
      taskTomSelect.clear();
      taskTomSelect.clearOptions();
      tasks.forEach((task) => {
        taskTomSelect.addOption({ value: task.id, text: task.title });
      });
      const clientDetails = data.client_details;
      const clientNameInput = document.querySelector('input[name="client_name"]');
      clientNameInput.value = clientDetails.clients_name;
    }).catch((error) => {
      const clientNameInput = document.querySelector('input[name="client_name"]');
      clientNameInput.value = "";
      taskTomSelect.clear();
      taskTomSelect.clearOptions();
      console.log(taskTomSelect);
      console.error("Erreur :", error);
    });
  }
  function resetAddRowIcon() {
    var addRowLink = document.getElementById("addRowIcon");
    var addRowIcon = document.querySelector("#addRowIcon i");
    addRowLink.classList.remove("non-cliquable");
    addRowIcon.style.cursor = "pointer";
  }

  // js/app.js
  var import_tom_select3 = __toModule(require_tom_select_complete());

  // ../deps/phoenix_html/priv/static/phoenix_html.js
  "use strict";
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent2(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent2.prototype = window.Event.prototype;
      return CustomEvent2;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), submit = document.createElement("input"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to;
      form.style.display = "none";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      submit.type = "submit";
      form.appendChild(submit);
      submit.click();
    }
    window.addEventListener("click", function(e) {
      var element = e.target;
      if (e.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method")) {
          handleClick(element, e.metaKey || e.shiftKey);
          e.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e) {
      var message = e.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e.preventDefault();
      }
    }, false);
  })();

  // ../deps/phoenix/priv/static/phoenix.mjs
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global = globalSelf || phxWindow || global;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event, payload, timeout) {
      this.channel = channel;
      this.event = event;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    receive(status, callback) {
      if (this.hasReceived(status)) {
        callback(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback });
      return this;
    }
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback, timerCalc) {
      this.callback = callback;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(this.socket.onOpen(() => {
        this.rejoinTimer.reset();
        if (this.isErrored()) {
          this.rejoin();
        }
      }));
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    onClose(callback) {
      this.on(CHANNEL_EVENTS.close, callback);
    }
    onError(callback) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
    }
    on(event, callback) {
      let ref = this.bindingRef++;
      this.bindings.push({ event, ref, callback });
      return ref;
    }
    off(event, ref) {
      this.bindings = this.bindings.filter((bind) => {
        return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
      });
    }
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    push(event, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    onMessage(_event, payload, _ref) {
      return payload;
    }
    isMember(topic, event, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    joinRef() {
      return this.joinPush.ref;
    }
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    trigger(event, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind) => bind.event === event);
      for (let i = 0; i < eventBindings.length; i++) {
        let bind = eventBindings[i];
        bind.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {
      if (global.XDomainRequest) {
        let req = new global.XDomainRequest();
        return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
      } else {
        let req = new global.XMLHttpRequest();
        return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback && callback(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
      return req;
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => callback && callback(null);
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback) {
          let response = this.parseJSON(req.responseText);
          callback(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
      return req;
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix}${this.serialize(params)}`;
    }
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.reqs = /* @__PURE__ */ new Set();
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      this.poll();
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry(code, reason, wasClean) {
      this.close(code, reason, wasClean);
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry(1005, "timeout", false);
    }
    isActive() {
      return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
    }
    poll() {
      this.ajax("GET", null, () => this.ontimeout(), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => this.onmessage({ data: msg }), 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen({});
            this.poll();
            break;
          case 403:
            this.onerror(403);
            this.close(1008, "forbidden", false);
            break;
          case 0:
          case 500:
            this.onerror(500);
            this.closeAndRetry(1011, "internal server error", 500);
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    send(body) {
      this.ajax("POST", body, () => this.onerror("timeout"), (resp) => {
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry(1011, "internal server error", false);
        }
      });
    }
    close(code, reason, wasClean) {
      for (let req of this.reqs) {
        req.abort();
      }
      this.readyState = SOCKET_STATES.closed;
      let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
      if (typeof CloseEvent !== "undefined") {
        this.onclose(new CloseEvent("close", opts));
      } else {
        this.onclose(opts);
      }
    }
    ajax(method, body, onCallerTimeout, callback) {
      let req;
      let ontimeout = () => {
        this.reqs.delete(req);
        onCallerTimeout();
      };
      req = Ajax.request(method, this.endpointURL(), "application/json", body, this.timeout, ontimeout, (resp) => {
        this.reqs.delete(req);
        if (this.isActive()) {
          callback(resp);
        }
      });
      this.reqs.add(req);
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
        return callback({ join_ref, ref, topic, event, payload });
      }
    },
    binaryEncode(message) {
      let { join_ref, ref, event, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.push);
      view.setUint8(offset++, join_ref.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, event.length);
      Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event, payload: data };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset, offset + refSize));
      offset = offset + refSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      let payload = { status: event, response: data };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event, payload: data };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global.WebSocket || LongPoll;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimeoutTimer = null;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    getLongPollTransport() {
      return LongPoll;
    }
    replaceTransport(newTransport) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.sendBuffer = [];
      if (this.conn) {
        this.conn.close();
        this.conn = null;
      }
      this.transport = newTransport;
    }
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    endPointURL() {
      let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    disconnect(callback, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.teardown(callback, code, reason);
    }
    connect(params) {
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      this.connectClock++;
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error) => this.onConnError(error);
      this.conn.onmessage = (event) => this.onConnMessage(event);
      this.conn.onclose = (event) => this.onConnClose(event);
    }
    log(kind, msg, data) {
      this.logger(kind, msg, data);
    }
    hasLogger() {
      return this.logger !== null;
    }
    onOpen(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback]);
      return ref;
    }
    onClose(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback]);
      return ref;
    }
    onError(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback]);
      return ref;
    }
    onMessage(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback]);
      return ref;
    }
    ping(callback) {
      if (!this.isConnected()) {
        return false;
      }
      let ref = this.makeRef();
      let startTime = Date.now();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
      let onMsgRef = this.onMessage((msg) => {
        if (msg.ref === ref) {
          this.off([onMsgRef]);
          callback(Date.now() - startTime);
        }
      });
      return true;
    }
    clearHeartbeats() {
      clearTimeout(this.heartbeatTimer);
      clearTimeout(this.heartbeatTimeoutTimer);
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
    }
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.triggerChanError();
        this.closeWasClean = false;
        this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      this.clearHeartbeats();
      this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback, code, reason) {
      if (!this.conn) {
        return callback && callback();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onopen = function() {
            };
            this.conn.onerror = function() {
            };
            this.conn.onmessage = function() {
            };
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback && callback();
        });
      });
    }
    waitForBufferDone(callback, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event) {
      let closeCode = event && event.code;
      if (this.hasLogger())
        this.log("transport", "close", event);
      this.triggerChanError();
      this.clearHeartbeats();
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));
    }
    onConnError(error) {
      if (this.hasLogger())
        this.log("transport", error);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback]) => {
        callback(error, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    isConnected() {
      return this.connectionState() === "open";
    }
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());
    }
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    push(data) {
      if (this.hasLogger()) {
        let { topic, event, payload, ref, join_ref } = data;
        this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
      }
    }
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback) => callback());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          this.clearHeartbeats();
          this.pendingHeartbeatRef = null;
          this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i = 0; i < this.channels.length; i++) {
          const channel = this.channels[i];
          if (!channel.isMember(topic, event, payload, join_ref)) {
            continue;
          }
          channel.trigger(event, payload, ref, join_ref);
        }
        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
          let [, callback] = this.stateChangeCallbacks.message[i];
          callback(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // ../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 5e3;
  var RELOAD_JITTER_MAX = 1e4;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF = "data-phx-ref";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_PAGE_LOADING = "page-loading";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_DISCONNECTED_CLASS = "phx-loading";
  var PHX_NO_FEEDBACK_CLASS = "phx-no-feedback";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_FEEDBACK_FOR = "feedback-for";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_PROGRESS = "progress";
  var LOADER_TIMEOUT = 1;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var DYNAMICS = "d";
  var STATIC = "s";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var EntryUploader = class {
    constructor(entry, chunkSize, liveSocket2) {
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunkSize;
      this.chunkTimer = null;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      clearTimeout(this.chunkTimer);
      this.uploadChannel.leave();
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e) => {
        if (e.target.error === null) {
          this.offset += e.target.result.byteLength;
          this.pushChunk(e.target.result);
        } else {
          return logError("Read error: " + e.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      });
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i = 0, len = elems.length; i < len; i++) {
      if (ids.has(elems[i].id)) {
        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i].id);
      }
    }
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val) => typeof val === "function" ? val : function() {
    return val;
  };
  var clone = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el, binding, borderEl) => {
    do {
      if (el.matches(`[${binding}]`)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el, callback) => el && callback(el);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage, namespace, subkey) {
      return localStorage.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage, namespace, subkey) {
      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to) {
      if (this.canPushState()) {
        if (to !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to || null);
          let hashEl = this.getHashTargetEl(window.location.hash);
          if (hashEl) {
            hashEl.scrollIntoView();
          } else if (meta.type === "redirect") {
            window.scroll(0, 0);
          }
        }
      } else {
        this.redirect(to);
      }
    },
    setCookie(name, value) {
      document.cookie = `${name}=${value}`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    redirect(toURL, flash) {
      if (flash) {
        Browser.setCookie("__phoenix_flash__", flash + "; max-age=60000; path=/");
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash = maybeHash.toString().substring(1);
      if (hash === "") {
        return;
      }
      return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
    }
  };
  var browser_default = Browser;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el, className) {
      el.classList.remove(className);
      if (el.classList.length === 0) {
        el.removeAttribute("class");
      }
    },
    all(node, query, callback) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query));
      return callback ? array.forEach(callback) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el) {
      return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    findUploadInputs(node) {
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    markPhxChildDestroyed(el) {
      if (this.isPhxChild(el)) {
        el.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el, phxUpdate) {
      return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el, phxUpdate, updateTypes) {
      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el) {
      return this.all(el, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el, parentId) {
      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findParentCIDs(node, cids) {
      let initial = new Set(cids);
      return cids.reduce((acc, cid) => {
        let selector = `[${PHX_COMPONENT}="${cid}"] [${PHX_COMPONENT}]`;
        this.filterWithinSameLiveView(this.all(node, selector), node).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => acc.delete(childCID));
        return acc;
      }, initial);
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el) => this.withinSameLiveView(el, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el, key) {
      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
    },
    deletePrivate(el, key) {
      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
    },
    putPrivate(el, key, value) {
      if (!el[PHX_PRIVATE]) {
        el[PHX_PRIVATE] = {};
      }
      el[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el, key, defaultVal, updateFunc) {
      let existing = this.private(el, key);
      if (existing === void 0) {
        this.putPrivate(el, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el, key, updateFunc(existing));
      }
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      let { prefix, suffix } = titleEl.dataset;
      document.title = `${prefix || ""}${str}${suffix || ""}`;
    },
    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback) {
      let debounce = el.getAttribute(phxDebounce);
      let throttle = el.getAttribute(phxThrottle);
      if (debounce === "") {
        debounce = defaultDebounce;
      }
      if (throttle === "") {
        throttle = defaultThrottle;
      }
      let value = debounce || throttle;
      switch (value) {
        case null:
          return callback();
        case "blur":
          if (this.once(el, "debounce-blur")) {
            el.addEventListener("blur", () => callback());
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();
          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle) {
            let newKeyDown = false;
            if (event.type === "keydown") {
              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);
              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);
              newKeyDown = prevKey !== event.key;
            }
            if (!newKeyDown && this.private(el, THROTTLED)) {
              return false;
            } else {
              callback();
              this.putPrivate(el, THROTTLED, true);
              setTimeout(() => {
                if (asyncFilter()) {
                  this.triggerCycle(el, DEBOUNCE_TRIGGER);
                }
              }, timeout);
            }
          } else {
            setTimeout(() => {
              if (asyncFilter()) {
                this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);
              }
            }, timeout);
          }
          let form = el.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el, "bind-debounce")) {
            el.addEventListener("blur", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));
          }
      }
    },
    triggerCycle(el, key, currentCycle) {
      let [cycle, trigger] = this.private(el, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el, key);
        trigger();
      }
    },
    once(el, key) {
      if (this.private(el, key) === true) {
        return false;
      }
      this.putPrivate(el, key, true);
      return true;
    },
    incCycle(el, key, trigger = function() {
    }) {
      let [currentCycle] = this.private(el, key) || [0, trigger];
      currentCycle++;
      this.putPrivate(el, key, [currentCycle, trigger]);
      return currentCycle;
    },
    discardError(container, el, phxFeedbackFor) {
      let field = el.getAttribute && el.getAttribute(phxFeedbackFor);
      let input = field && container.querySelector(`[id="${field}"], [name="${field}"]`);
      if (!input) {
        return;
      }
      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input.form, PHX_HAS_SUBMITTED))) {
        el.classList.add(PHX_NO_FEEDBACK_CLASS);
      }
    },
    showError(inputEl, phxFeedbackFor) {
      if (inputEl.id || inputEl.name) {
        this.all(inputEl.form, `[${phxFeedbackFor}="${inputEl.id}"], [${phxFeedbackFor}="${inputEl.name}"]`, (el) => {
          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);
        });
      }
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    firstPhxChild(el) {
      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, name, opts = {}) {
      let bubbles = opts.bubbles === void 0 ? true : !!opts.bubbles;
      let eventOpts = { bubbles, cancelable: true, detail: opts.detail || {} };
      let event = name === "click" ? new MouseEvent("click", eventOpts) : new CustomEvent(name, eventOpts);
      target.dispatchEvent(event);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    mergeAttrs(target, source, opts = {}) {
      let exclude = opts.exclude || [];
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i = sourceAttrs.length - 1; i >= 0; i--) {
        let name = sourceAttrs[i].name;
        if (exclude.indexOf(name) < 0) {
          target.setAttribute(name, source.getAttribute(name));
        }
      }
      let targetAttrs = target.attributes;
      for (let i = targetAttrs.length - 1; i >= 0; i--) {
        let name = targetAttrs[i].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { exclude: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el) {
      return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (focused.readOnly) {
        focused.blur();
      }
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el) {
      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
    },
    syncAttrsToProps(el) {
      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
        el.checked = el.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el) {
      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
    },
    isNowTriggerFormExternal(el, phxTriggerExternal) {
      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;
    },
    syncPendingRef(fromEl, toEl, disableWith) {
      let ref = fromEl.getAttribute(PHX_REF);
      if (ref === null) {
        return true;
      }
      let refSrc = fromEl.getAttribute(PHX_REF_SRC);
      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {
        if (DOM.isUploadInput(fromEl)) {
          DOM.mergeAttrs(fromEl, toEl, { isIgnored: true });
        }
        DOM.putPrivate(fromEl, PHX_REF, toEl);
        return false;
      } else {
        PHX_EVENT_CLASSES.forEach((className) => {
          fromEl.classList.contains(className) && toEl.classList.add(className);
        });
        toEl.setAttribute(PHX_REF, ref);
        toEl.setAttribute(PHX_REF_SRC, refSrc);
        return true;
      }
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el, name, defaultVal) {
      let op = (DOM.private(el, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el, name) {
      this.updatePrivate(el, "sticky", [], (ops) => {
        return ops.filter(([existingName, _]) => existingName !== name);
      });
    },
    putSticky(el, name, op) {
      let stashedResult = op(el);
      this.updatePrivate(el, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el) {
      let ops = DOM.private(el, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    constructor(fileEl, file, view) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    cancel() {
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      LiveUploader.clearFiles(this.fileEl);
    }
    onDone(callback) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.name = file.name || entry.ref;
        entry.type = file.type;
        entry.size = file.size;
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.putPrivate(inputEl, "files", this.activeFiles(inputEl).concat(newFiles));
        inputEl.value = null;
      } else {
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f));
    }
    constructor(inputEl, view, onComplete) {
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view));
      this.numEntriesInProgress = this._entries.length;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        entry.zipPostFlight(resp);
        entry.onDone(() => {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        });
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        let { name, callback } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback, entries } = groupedEntries[name];
        callback(entries, onError, resp, liveSocket2);
      }
    }
  };
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view.cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    }
  };
  var hooks_default = Hooks;
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(curFromNodeChild, fromEl, true);
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          if (onBeforeElUpdated(fromEl, toEl) === false) {
            return;
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(curFromNodeChild, fromEl, true);
                          }
                          curFromNodeChild = matchingFromEl;
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(curFromNodeChild, fromEl, true);
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              fromEl.appendChild(matchingFromEl);
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                fromEl.appendChild(curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    static patchEl(fromEl, toEl, activeElement) {
      morphdom_esm_default(fromEl, toEl, {
        childrenOnly: false,
        onBeforeElUpdated: (fromEl2, toEl2) => {
          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {
            dom_default.mergeFocusedInput(fromEl2, toEl2);
            return false;
          }
        }
      });
    }
    constructor(view, container, id, html, targetCID) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
    }
    before(kind, callback) {
      this.callbacks[`before${kind}`].push(callback);
    }
    after(kind, callback) {
      this.callbacks[`after${kind}`].push(callback);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback) => callback(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback) => callback(...args));
    }
    markPrunableContentForRemoval() {
      dom_default.all(this.container, "[phx-update=append] > *, [phx-update=prepend] > *", (el) => {
        el.setAttribute(PHX_PRUNE, "");
      });
    }
    perform() {
      let { view, liveSocket: liveSocket2, container, html } = this;
      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxFeedbackFor = liveSocket2.binding(PHX_FEEDBACK_FOR);
      let disableWith = liveSocket2.binding(PHX_DISABLE_WITH);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let phxRemove = liveSocket2.binding("remove");
      let added = [];
      let updates = [];
      let appendPrependUpdates = [];
      let pendingRemoves = [];
      let externalFormTriggered = null;
      let diffHTML = liveSocket2.time("premorph container prep", () => {
        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);
      });
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        morphdom_esm_default(targetContainer, diffHTML, {
          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,
          getNodeKey: (node) => {
            return dom_default.isPhxDestroyed(node) ? null : node.id;
          },
          onBeforeNodeAdded: (el) => {
            this.trackBefore("added", el);
            return el;
          },
          onNodeAdded: (el) => {
            if (el instanceof HTMLImageElement && el.srcset) {
              el.srcset = el.srcset;
            } else if (el instanceof HTMLVideoElement && el.autoplay) {
              el.play();
            }
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            dom_default.discardError(targetContainer, el, phxFeedbackFor);
            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
              this.trackAfter("phxChildAdded", el);
            }
            added.push(el);
          },
          onNodeDiscarded: (el) => {
            if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
              liveSocket2.destroyViewByEl(el);
            }
            this.trackAfter("discarded", el);
          },
          onBeforeNodeDiscarded: (el) => {
            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, ["append", "prepend"]) && el.id) {
              return false;
            }
            if (el.getAttribute && el.getAttribute(phxRemove)) {
              pendingRemoves.push(el);
              return false;
            }
            if (this.skipCIDSibling(el)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el) => {
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            updates.push(el);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {
              if (dom_default.isUploadInput(fromEl)) {
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            dom_default.copyPrivates(toEl, fromEl);
            dom_default.discardError(targetContainer, toEl, phxFeedbackFor);
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            if (isFocusedFormEl) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            } else {
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              this.trackBefore("updated", fromEl, toEl);
              return true;
            }
          }
        });
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update) => update.perform());
        });
      }
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el) => this.trackAfter("added", el));
      updates.forEach((el) => this.trackAfter("updated", el));
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves);
        liveSocket2.requestDOMUpdate(() => {
          pendingRemoves.forEach((el) => {
            let child = dom_default.firstPhxChild(el);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
      if (externalFormTriggered) {
        liveSocket2.disconnect();
        externalFormTriggered.submit();
      }
      return true;
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    buildDiffHTML(container, html, phxUpdate, targetContainer) {
      let isCIDPatch = this.isCIDPatch();
      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();
      if (!isCIDPatch || isCIDWithSingleRoot) {
        return html;
      } else {
        let diffContainer = null;
        let template = document.createElement("template");
        diffContainer = dom_default.cloneNode(targetContainer);
        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);
        template.innerHTML = html;
        rest.forEach((el) => el.remove());
        Array.from(diffContainer.childNodes).forEach((child) => {
          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
        });
        Array.from(template.content.childNodes).forEach((el) => diffContainer.insertBefore(el, firstComponent));
        firstComponent.remove();
        return diffContainer.outerHTML;
      }
    }
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids };
      this.toOutputBuffer(rendered, null, output);
      return output.buffer;
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val);
        } else {
          target[key] = val;
        }
      }
    }
    cloneMerge(target, source) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val);
        }
      }
      return merged;
    }
    componentToString(cid) {
      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    toOutputBuffer(rendered, templates, output) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      output.buffer += statics[0];
      for (let i = 1; i < statics.length; i++) {
        this.dynamicToBuffer(rendered[i - 1], templates, output);
        output.buffer += statics[i];
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d = 0; d < dynamics.length; d++) {
        let dynamic = dynamics[d];
        output.buffer += statics[0];
        for (let i = 1; i < statics.length; i++) {
          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output);
          output.buffer += statics[i];
        }
      }
    }
    dynamicToBuffer(rendered, templates, output) {
      if (typeof rendered === "number") {
        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output);
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let template = document.createElement("template");
      template.innerHTML = this.recursiveToString(component, components, onlyCids);
      let container = template.content;
      let skip = onlyCids && !onlyCids.has(cid);
      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {
        if (child.nodeType === Node.ELEMENT_NODE) {
          if (child.getAttribute(PHX_COMPONENT)) {
            return [hasNodes, true];
          }
          child.setAttribute(PHX_COMPONENT, cid);
          if (!child.id) {
            child.id = `${this.parentViewId()}-${cid}-${i}`;
          }
          if (skip) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
          return [true, hasComponents];
        } else {
          if (child.nodeValue.trim() !== "") {
            logError(`only HTML element tags are allowed at the root of components.

got: "${child.nodeValue.trim()}"

within:
`, template.innerHTML.trim());
            child.replaceWith(this.createSpan(child.nodeValue, cid));
            return [true, hasComponents];
          } else {
            child.remove();
            return [hasNodes, hasComponents];
          }
        }
      }, [false, false]);
      if (!hasChildNodes && !hasChildComponents) {
        logError("expected at least one HTML element tag inside a component, but the component is empty:\n", template.innerHTML.trim());
        return this.createSpan("", cid).outerHTML;
      } else if (!hasChildNodes && hasChildComponents) {
        logError("expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.", template.innerHTML.trim());
        return template.innerHTML;
      } else {
        return template.innerHTML;
      }
    }
    createSpan(text, cid) {
      let span = document.createElement("span");
      span.innerText = text;
      span.setAttribute(PHX_COMPONENT, cid);
      return span;
    }
  };
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el) {
      return el.phxHookId;
    }
    constructor(view, el, callbacks) {
      this.__view = view;
      this.liveSocket = view.liveSocket;
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      this.el = el;
      this.el.phxHookId = this.constructor.makeID();
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    pushEvent(event, payload = {}, onReply = function() {
    }) {
      return this.__view.pushHookEvent(null, event, payload, onReply);
    }
    pushEventTo(phxTarget, event, payload = {}, onReply = function() {
    }) {
      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(targetCtx, event, payload, onReply);
      });
    }
    handleEvent(event, callback) {
      let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);
      window.addEventListener(`phx:${event}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event = callbackRef(null, true);
      window.removeEventListener(`phx:${event}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view.dispatchUploads(name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view.withinTargets(phxTarget, (view) => view.dispatchUploads(name, files));
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var JS = {
    exec(eventType, phxEvent, view, sourceEl, defaults) {
      let [defaultKind, defaultArgs] = defaults || [null, {}];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind && defaultArgs.data) {
          args.data = Object.assign(args.data || {}, defaultArgs.data);
        }
        this.filterToEls(sourceEl, args).forEach((el) => {
          this[`exec_${kind}`](eventType, phxEvent, view, sourceEl, el, args);
        });
      });
    },
    isVisible(el) {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
    },
    exec_dispatch(eventType, phxEvent, view, sourceEl, el, { to, event, detail, bubbles }) {
      detail = detail || {};
      detail.dispatcher = sourceEl;
      dom_default.dispatchEvent(el, event, { detail, bubbles });
    },
    exec_push(eventType, phxEvent, view, sourceEl, el, args) {
      if (!view.isConnected()) {
        return;
      }
      let { event, data, target, page_loading, loading, value, dispatcher } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" && dispatcher ? dispatcher : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      view.withinTargets(phxTarget, (targetView, targetCtx) => {
        if (eventType === "change") {
          let { newCid, _target, callback } = args;
          _target = _target || (sourceEl instanceof HTMLInputElement ? sourceEl.name : void 0);
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback);
        } else if (eventType === "submit") {
          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, pushOpts);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts);
        }
      });
    },
    exec_add_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, names, [], transition, time, view);
    },
    exec_remove_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, [], names, transition, time, view);
    },
    exec_transition(eventType, phxEvent, view, sourceEl, el, { time, transition }) {
      let [transition_start, running, transition_end] = transition;
      let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(running), []);
      let onDone = () => this.addOrRemoveClasses(el, transition_end, transition_start.concat(running));
      view.transition(time, onStart, onDone);
    },
    exec_toggle(eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time }) {
      this.toggle(eventType, view, el, display, ins, outs, time);
    },
    exec_show(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.show(eventType, view, el, display, transition, time);
    },
    exec_hide(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.hide(eventType, view, el, display, transition, time);
    },
    exec_set_attr(eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {
      this.setOrRemoveAttrs(el, [[attr, val]], []);
    },
    exec_remove_attr(eventType, phxEvent, view, sourceEl, el, { attr }) {
      this.setOrRemoveAttrs(el, [], [attr]);
    },
    show(eventType, view, el, display, transition, time) {
      if (!this.isVisible(el)) {
        this.toggle(eventType, view, el, display, transition, null, time);
      }
    },
    hide(eventType, view, el, display, transition, time) {
      if (this.isVisible(el)) {
        this.toggle(eventType, view, el, display, null, transition, time);
      }
    },
    toggle(eventType, view, el, display, ins, outs, time) {
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el)) {
          let onStart = () => {
            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:hide-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, inClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:show-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      } else {
        if (this.isVisible(el)) {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:hide-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:show-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      }
    },
    addOrRemoveClasses(el, adds, removes, transition, time, view) {
      let [transition_run, transition_start, transition_end] = transition || [[], [], []];
      if (transition_run.length > 0) {
        let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(transition_run), []);
        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transition_end), removes.concat(transition_run).concat(transition_start));
        return view.transition(time, onStart, onDone);
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
      let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);
      let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);
      let newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);
      dom_default.putSticky(el, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));
        return [newSets, newRemoves];
      });
    },
    hasAllClasses(el, classes) {
      return classes.every((name) => el.classList.contains(name));
    },
    isToggledOut(el, outClasses) {
      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
    },
    filterToEls(sourceEl, { to }) {
      return to ? dom_default.all(document, to) : [sourceEl];
    }
  };
  var js_default = JS;
  var serializeForm = (form, meta, onlyNames = []) => {
    let formData = new FormData(form);
    let toRemove = [];
    formData.forEach((val, key, _index) => {
      if (val instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    let params = new URLSearchParams();
    for (let [key, val] of formData.entries()) {
      if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {
        params.append(key, val);
      }
    }
    for (let metaKey in meta) {
      params.append(metaKey, meta[metaKey]);
    }
    return params.toString();
  };
  var View = class {
    constructor(el, liveSocket2, parentView, flash) {
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el;
      this.id = this.el.id;
      this.ref = 0;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.pendingDiffs = [];
      this.pruningCIDs = [];
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.uploaders = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        return {
          redirect: this.redirect ? this.href : void 0,
          url: this.redirect ? void 0 : this.href || void 0,
          params: this.connectParams(),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.hasAttribute(PHX_MAIN);
    }
    connectParams() {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val = this.el.getAttribute(PHX_STATIC);
      return val === "" ? null : val;
    }
    destroy(callback = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes) {
      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
      this.el.classList.add(...classes);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_DISCONNECTED_CLASS);
      }
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    withinTargets(phxTarget, callback) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(document.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback) {
      this.log(type, () => ["", clone(rawDiff)]);
      let { diff, reply, events, title } = Rendered.extract(rawDiff);
      if (title) {
        dom_default.putTitle(title);
      }
      callback({ diff, reply, events });
      return reply;
    }
    onJoin(resp) {
      let { rendered, container } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events }) => {
        this.rendered = new Rendered(this.id, diff);
        let html = this.renderContainer(null, "join");
        this.dropPendingRefs();
        let forms = this.formsForRecovery(html);
        this.joinCount++;
        if (forms.length > 0) {
          forms.forEach(([form, newForm, newCid], i) => {
            this.pushFormRecovery(form, newCid, (resp2) => {
              if (i === forms.length - 1) {
                this.onJoinComplete(resp2, html, events);
              }
            });
          });
        } else {
          this.onJoinComplete(resp, html, events);
        }
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}]`, (el) => {
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
      });
    }
    onJoinComplete({ live_patch }, html, events) {
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, events);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, events);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    applyJoinPatch(live_patch, html, events) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false);
      this.joinNewChildren();
      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        let hook = this.addHook(hookEl);
        if (hook) {
          hook.__mounted();
        }
      });
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to } = live_patch;
        this.liveSocket.historyPatch(to, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    performPatch(patch, pruneCids) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      patch.after("added", (el) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el]);
        let newHook = this.addHook(el);
        if (newHook) {
          newHook.__mounted();
        }
      });
      patch.after("phxChildAdded", (el) => {
        if (dom_default.isPhxSticky(el)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el) => {
        if (updatedHookIds.has(el.id)) {
          this.getHook(el).__updated();
        }
      });
      patch.after("discarded", (el) => {
        if (el.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform();
      this.afterElementsRemoved(removedEls, pruneCids);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements, pruneCids) {
      let destroyedCIDs = [];
      elements.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        let hooks = dom_default.all(parent, `[${this.binding(PHX_HOOK)}]`);
        components.concat(parent).forEach((el) => {
          let cid = this.componentID(el);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
        });
        hooks.concat(parent).forEach((hookEl) => {
          let hook = this.getHook(hookEl);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el) {
      if (el.id === this.id) {
        return this;
      } else {
        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el) {
      let child = this.getChildById(el.id);
      if (!child) {
        let view = new View(el, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink() && !dom_default.isPhxSticky(this.el)) {
        return this.pendingDiffs.push({ diff, events });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let html = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;
        let html = this.rendered.toString(cids);
        return `<${tag}>${html}</${tag}>`;
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let html = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el) {
      return this.viewHooks[ViewHook.elementID(el)];
    }
    addHook(el) {
      if (ViewHook.elementID(el) || !el.getAttribute) {
        return;
      }
      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
      if (hookName && !this.ownsElement(el)) {
        return;
      }
      let callbacks = this.liveSocket.getHookCallbacks(hookName);
      if (callbacks) {
        if (!el.id) {
          logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el);
        }
        let hook = new ViewHook(this, el, callbacks);
        this.viewHooks[ViewHook.elementID(hook.el)] = hook;
        return hook;
      } else if (hookName !== null) {
        logError(`unknown hook found for "${hookName}"`, el);
      }
    }
    destroyHook(hook) {
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[ViewHook.elementID(hook.el)];
    }
    applyPendingUpdates() {
      this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));
      this.pendingDiffs = [];
    }
    onChannel(event, cb) {
      this.liveSocket.onChannel(this.channel, event, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events }) => this.update(diff, events));
        });
      });
      this.onChannel("redirect", ({ to, flash }) => this.onRedirect({ to, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      for (let id in this.root.children[this.id]) {
        this.getChildById(id).destroy();
      }
    }
    onLiveRedirect(redir) {
      let { to, kind, flash } = redir;
      let url = this.expandURL(to);
      this.liveSocket.historyRedirect(url, kind, flash);
    }
    onLivePatch(redir) {
      let { to, kind } = redir;
      this.href = this.expandURL(to);
      this.liveSocket.historyPatch(to, kind);
    }
    expandURL(to) {
      return to.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to}` : to;
    }
    onRedirect({ to, flash }) {
      this.liveSocket.redirect(to, flash);
    }
    isDestroyed() {
      return this.destroyed;
    }
    join(callback) {
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback ? callback(this.joinCount, onDone) : onDone();
      };
      this.liveSocket.wrapPush(this, { timeout: false }, () => {
        return this.channel.join().receive("ok", (data) => {
          if (!this.isDestroyed()) {
            this.liveSocket.requestDOMUpdate(() => this.onJoin(data));
          }
        }).receive("error", (resp) => !this.isDestroyed() && this.onJoinError(resp)).receive("timeout", () => !this.isDestroyed() && this.onJoinError({ reason: "timeout" }));
      });
    }
    onJoinError(resp) {
      if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        return this.onRedirect({ to: this.href });
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.log("error", () => ["unable to join", resp]);
      if (this.liveSocket.isConnected()) {
        this.liveSocket.reloadWithJitter(this);
      }
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      if (this.liveSocket.isConnected()) {
        this.log("error", () => ["view crashed", reason]);
      }
      if (!this.liveSocket.isUnloaded()) {
        this.displayError();
      }
    }
    displayError() {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: { to: this.href, kind: "error" } });
      }
      this.showLoader();
      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
    }
    pushWithReply(refGenerator, event, payload, onReply = function() {
    }) {
      if (!this.isConnected()) {
        return;
      }
      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let onLoadingDone = function() {
      };
      if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return this.liveSocket.wrapPush(this, { timeout: true }, () => {
        return this.channel.push(event, payload, PUSH_TIMEOUT).receive("ok", (resp) => {
          if (ref !== null) {
            this.undoRefs(ref);
          }
          let finish = (hookReply) => {
            if (resp.redirect) {
              this.onRedirect(resp.redirect);
            }
            if (resp.live_patch) {
              this.onLivePatch(resp.live_patch);
            }
            if (resp.live_redirect) {
              this.onLiveRedirect(resp.live_redirect);
            }
            onLoadingDone();
            onReply(resp, hookReply);
          };
          if (resp.diff) {
            this.liveSocket.requestDOMUpdate(() => {
              let hookReply = this.applyDiff("update", resp.diff, ({ diff, events }) => {
                this.update(diff, events);
              });
              finish(hookReply);
            });
          } else {
            finish(null);
          }
        });
      });
    }
    undoRefs(ref) {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}="${ref}"]`, (el) => {
        let disabledVal = el.getAttribute(PHX_DISABLED);
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
        if (el.getAttribute(PHX_READONLY) !== null) {
          el.readOnly = false;
          el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          el.disabled = disabledVal === "true" ? true : false;
          el.removeAttribute(PHX_DISABLED);
        }
        PHX_EVENT_CLASSES.forEach((className) => dom_default.removeClass(el, className));
        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          el.innerText = disableRestore;
          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let toEl = dom_default.private(el, PHX_REF);
        if (toEl) {
          let hook = this.triggerBeforeUpdateHook(el, toEl);
          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());
          if (hook) {
            hook.__updated();
          }
          dom_default.deletePrivate(el, PHX_REF);
        }
      });
    }
    putRef(elements, event, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        elements = elements.concat(dom_default.all(document, opts.loading));
      }
      elements.forEach((el) => {
        el.classList.add(`phx-${event}-loading`);
        el.setAttribute(PHX_REF, newRef);
        el.setAttribute(PHX_REF_SRC, this.el.id);
        let disableText = el.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);
          }
          if (disableText !== "") {
            el.innerText = disableText;
          }
          el.setAttribute("disabled", "");
        }
      });
      return [newRef, elements, opts];
    }
    componentID(el) {
      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));
      } else {
        return null;
      }
    }
    pushHookEvent(targetCtx, event, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([], "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }, (resp, reply) => onReply(reply, ref));
      return ref;
    }
    extractMeta(el, meta, value) {
      let prefix = this.binding("value-");
      for (let i = 0; i < el.attributes.length; i++) {
        if (!meta) {
          meta = {};
        }
        let name = el.attributes[i].name;
        if (name.startsWith(prefix)) {
          meta[name.replace(prefix, "")] = el.getAttribute(name);
        }
      }
      if (el.value !== void 0) {
        if (!meta) {
          meta = {};
        }
        meta.value = el.value;
        if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}) {
      this.pushWithReply(() => this.putRef([el], type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el, meta, opts.value),
        cid: this.targetComponentID(el, targetCtx, opts)
      });
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }, onReply);
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);
      let refGenerator = () => this.putRef([inputEl, inputEl.form], "change", opts);
      let formData;
      if (inputEl.getAttribute(this.binding("change"))) {
        formData = serializeForm(inputEl.form, { _target: opts._target }, [inputEl.name]);
      } else {
        formData = serializeForm(inputEl.form, { _target: opts._target });
      }
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event = {
        type: "form",
        event: phxEvent,
        value: formData,
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event, (resp) => {
        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));
        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute("data-phx-auto-upload") !== null) {
          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
            let [ref, _els] = refGenerator();
            this.uploadFiles(inputEl.form, targetCtx, ref, cid, (_uploads) => {
              callback && callback(resp);
              this.triggerAwaitingSubmit(inputEl.form);
            });
          }
        } else {
          callback && callback(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback] = awaitingSubmit;
        this.cancelSubmit(formEl);
        callback();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback]);
    }
    cancelSubmit(formEl) {
      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {
        if (el.isSameNode(formEl)) {
          this.undoRefs(ref);
          return false;
        } else {
          return true;
        }
      });
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply) {
      let filterIgnored = (el) => {
        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);
        return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
      };
      let filterDisables = (el) => {
        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el) => el.tagName == "BUTTON";
      let filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
      let refGenerator = () => {
        let formElements = Array.from(formEl.elements);
        let disables = formElements.filter(filterDisables);
        let buttons = formElements.filter(filterButton).filter(filterIgnored);
        let inputs = formElements.filter(filterInput).filter(filterIgnored);
        buttons.forEach((button) => {
          button.setAttribute(PHX_DISABLED, button.disabled);
          button.disabled = true;
        });
        inputs.forEach((input) => {
          input.setAttribute(PHX_READONLY, input.readOnly);
          input.readOnly = true;
          if (input.files) {
            input.setAttribute(PHX_DISABLED, input.disabled);
            input.disabled = true;
          }
        });
        formEl.setAttribute(this.binding(PHX_PAGE_LOADING), "");
        return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), "submit", opts);
      };
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, targetCtx, ref, cid, (_uploads) => {
          let formData = serializeForm(formEl, {});
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            cid
          }, onReply);
        });
      } else {
        let formData = serializeForm(formEl, {});
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          cid
        }, onReply);
      }
    }
    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        this.uploaders[inputEl] = uploader;
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload, (resp) => {
          this.log("upload", () => ["got preflight response", resp]);
          if (resp.error) {
            this.undoRefs(ref);
            let [entry_ref, reason] = resp.error;
            this.log("upload", () => [`error for entry ${entry_ref}`, reason]);
          } else {
            let onError = (callback) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    dispatchUploads(name, filesOrBlobs) {
      let inputs = dom_default.findUploadInputs(this.el).filter((el) => el.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { detail: { files: filesOrBlobs } });
      }
    }
    pushFormRecovery(form, newCid, callback) {
      this.liveSocket.withinOwners(form, (view, targetCtx) => {
        let input = form.elements[0];
        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding("change"));
        js_default.exec("change", phxEvent, view, input, ["push", { _target: input.name, newCid, callback }]);
      });
    }
    pushLinkPatch(href, targetEl, callback) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let refGen = targetEl ? () => this.putRef([targetEl], "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let push = this.pushWithReply(refGen, "live_patch", { url: href }, (resp) => {
        this.liveSocket.requestDOMUpdate(() => {
          if (resp.link_redirect) {
            this.liveSocket.replaceMain(href, null, callback, linkRef);
          } else {
            if (this.liveSocket.commitPendingLink(linkRef)) {
              this.href = href;
            }
            this.applyPendingUpdates();
            callback && callback(linkRef);
          }
        });
      });
      if (push) {
        push.receive("timeout", fallback);
      } else {
        fallback();
      }
    }
    formsForRecovery(html) {
      if (this.joinCount === 0) {
        return [];
      }
      let phxChange = this.binding("change");
      let template = document.createElement("template");
      template.innerHTML = html;
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id && this.ownsElement(form)).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => {
        let newForm = template.content.querySelector(`form[id="${form.id}"][${phxChange}="${form.getAttribute(phxChange)}"]`);
        if (newForm) {
          return [form, newForm, this.targetComponentID(newForm)];
        } else {
          return [form, null, null];
        }
      }).filter(([form, newForm, newCid]) => newForm);
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        this.pruningCIDs.push(...willDestroyCIDs);
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }, () => {
          this.pruningCIDs = this.pruningCIDs.filter((cid) => willDestroyCIDs.indexOf(cid) !== -1);
          let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
            return dom_default.findComponentNodeList(this.el, cid).length === 0;
          });
          if (completelyDestroyCIDs.length > 0) {
            this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }, (resp) => {
              this.rendered.pruneCIDs(resp.cids);
            });
          }
        });
      }
    }
    ownsElement(el) {
      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), (node) => node.id) === this.id;
    }
    submitForm(form, targetCtx, phxEvent, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      let phxFeedback = this.liveSocket.binding(PHX_FEEDBACK_FOR);
      let inputs = Array.from(form.elements);
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, opts, () => {
        inputs.forEach((input) => dom_default.showError(input, phxFeedback));
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.outgoingMainEl = null;
      this.clickStartedAtTarget = null;
      this.linkRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.reloadWithJitterTimer = null;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.domCallbacks = Object.assign({ onNodeAdded: closure2(), onBeforeElUpdated: closure2() }, opts.dom || {});
      this.transitions = new TransitionSet();
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    isDebugDisabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "false";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "false");
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      if (window.location.hostname === "localhost" && !this.isDebugDisabled()) {
        this.enableDebug();
      }
      let doConnect = () => {
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        } else if (this.main) {
          this.socket.connect();
        }
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.disconnect(callback);
    }
    replaceTransport(transport) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.replaceTransport(transport);
      this.connect();
    }
    execJS(el, encodedJS, eventType = null) {
      this.owner(el, (view) => js_default.exec(eventType, encodedJS, view, el));
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback) {
      this.transitions.after(callback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event, cb) {
      channel.on(event, (data) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data);
        } else {
          console.log(`simulating ${latency}ms of latency from server to client`);
          setTimeout(() => cb(data), latency);
        }
      });
    }
    wrapPush(view, opts, push) {
      let latency = this.getLatencySim();
      let oldJoinCount = view.joinCount;
      if (!latency) {
        if (this.isConnected() && opts.timeout) {
          return push().receive("timeout", () => {
            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {
              this.reloadWithJitter(view, () => {
                this.log(view, "timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          });
        } else {
          return push();
        }
      }
      console.log(`simulating ${latency}ms of latency from client to server`);
      let fakePush = {
        receives: [],
        receive(kind, cb) {
          this.receives.push([kind, cb]);
        }
      };
      setTimeout(() => {
        if (view.isDestroyed()) {
          return;
        }
        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());
      }, latency);
      return fakePush;
    }
    reloadWithJitter(view, log) {
      clearTimeout(this.reloadWithJitterTimer);
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      if (tries > this.maxReloads) {
        afterMs = this.failsafeJitter;
      }
      this.reloadWithJitterTimer = setTimeout(() => {
        if (view.isDestroyed() || view.isConnected()) {
          return;
        }
        view.destroy();
        log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
        if (tries > this.maxReloads) {
          this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        }
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {
        if (!this.getRootById(rootEl.id)) {
          let view = this.newRootView(rootEl);
          view.setHref(this.getHref());
          view.join();
          if (rootEl.hasAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to, flash) {
      this.disconnect();
      browser_default.redirect(to, flash);
    }
    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {
      this.outgoingMainEl = this.outgoingMainEl || this.main.el;
      let newMainEl = dom_default.cloneNode(this.outgoingMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash);
      this.main.setRedirect(href);
      this.transitionRemoves();
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            dom_default.findPhxSticky(document).forEach((el) => newMainEl.appendChild(el));
            this.outgoingMainEl.replaceWith(newMainEl);
            this.outgoingMainEl = null;
            callback && requestAnimationFrame(callback);
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements) {
      let removeAttr = this.binding("remove");
      elements = elements || dom_default.all(document, `[${removeAttr}]`);
      elements.forEach((el) => {
        if (document.body.contains(el)) {
          this.execJS(el, el.getAttribute(removeAttr), "remove");
        }
      });
    }
    isPhxView(el) {
      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el, flash) {
      let view = new View(el, this, null, flash);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;
      if (view) {
        callback(view);
      }
    }
    withinOwners(childEl, callback) {
      this.owner(childEl, (view) => callback(view, childEl));
    }
    getViewByEl(el) {
      let rootId = el.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
      this.main = null;
    }
    destroyViewByEl(el) {
      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el.id);
      }
    }
    setActiveElement(target) {
      if (this.activeElement === target) {
        return;
      }
      this.activeElement = target;
      let cancel = () => {
        if (target === this.activeElement) {
          this.activeElement = null;
        }
        target.removeEventListener("mouseup", this);
        target.removeEventListener("touchend", this);
      };
      target.addEventListener("mouseup", cancel);
      target.addEventListener("touchend", cancel);
    }
    getActiveElement() {
      if (document.activeElement === document.body) {
        return this.activeElement || document.activeElement;
      } else {
        return document.activeElement || document.body;
      }
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents() {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.socket.onClose((event) => {
        if (event && event.code === 1e3 && this.main) {
          this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      this.bindNav();
      this.bindClicks();
      this.bindForms();
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e.key && e.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
        js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        if (!eventTarget) {
          let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data = this.eventMeta(type, e, targetEl);
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      window.addEventListener("dragover", (e) => e.preventDefault());
      window.addEventListener("drop", (e) => {
        e.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e) => {
        let uploadTarget = e.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e, targetEl) {
      let callback = this.metadataCallbacks[eventName];
      return callback ? callback(e, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      return this.linkRef;
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events, callback) {
      for (let event in events) {
        let browserEventName = events[event];
        this.on(browserEventName, (e) => {
          let binding = this.binding(event);
          let windowBinding = this.binding(`window-${event}`);
          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e.target, e, browserEventName, () => {
              this.withinOwners(e.target, (view) => {
                callback(e, event, view, e.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el) => {
              let phxEvent = el.getAttribute(windowBinding);
              this.debounce(el, e, browserEventName, () => {
                this.withinOwners(el, (view) => {
                  callback(e, event, view, el, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      window.addEventListener("mousedown", (e) => this.clickStartedAtTarget = e.target);
      this.bindClick("click", "click", false);
      this.bindClick("mousedown", "capture-click", true);
    }
    bindClick(eventName, bindingName, capture) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e) => {
        let target = null;
        if (capture) {
          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);
        } else {
          let clickStartedAtTarget = this.clickStartedAtTarget || e.target;
          target = closestPhxBinding(clickStartedAtTarget, click);
          this.dispatchClickAway(e, clickStartedAtTarget);
          this.clickStartedAtTarget = null;
        }
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          return;
        }
        if (target.getAttribute("href") === "#") {
          e.preventDefault();
        }
        this.debounce(target, e, "click", () => {
          this.withinOwners(target, (view) => {
            js_default.exec("click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e, target) }]);
          });
        });
      }, capture);
    }
    dispatchClickAway(e, clickStartedAt) {
      let phxClickAway = this.binding("click-away");
      dom_default.all(document, `[${phxClickAway}]`, (el) => {
        if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {
          this.withinOwners(e.target, (view) => {
            let phxEvent = el.getAttribute(phxClickAway);
            if (js_default.isVisible(el)) {
              js_default.exec("click", phxEvent, view, el, ["push", { data: this.eventMeta("click", e, e.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, id, root, scroll: scroll2 } = event.state || {};
        let href = window.location.href;
        this.requestDOMUpdate(() => {
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(href, null);
          } else {
            this.replaceMain(href, null, () => {
              if (root) {
                this.replaceRootHistory();
              }
              if (typeof scroll2 === "number") {
                setTimeout(() => {
                  window.scrollTo(0, scroll2);
                }, 0);
              }
            });
          }
        });
      }, false);
      window.addEventListener("click", (e) => {
        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;
        if (!type || !this.isConnected() || !this.main || wantsNewTab) {
          return;
        }
        let href = target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e.preventDefault();
        e.stopImmediatePropagation();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(href, linkState);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
        });
      }, false);
    }
    dispatchEvent(event, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });
    }
    dispatchEvents(events) {
      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));
    }
    withPageLoading(info, callback) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: info });
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", { detail: info });
      return callback ? callback(done) : done;
    }
    pushHistoryPatch(href, linkState, targetEl) {
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      browser_default.pushState(linkState, { type: "patch", id: this.main.id }, href);
      this.registerNewLocation(window.location);
    }
    historyRedirect(href, linkState, flash) {
      let scroll2 = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, () => {
          browser_default.pushState(linkState, { type: "redirect", id: this.main.id, scroll: scroll2 }, href);
          this.registerNewLocation(window.location);
          done();
        });
      });
    }
    replaceRootHistory() {
      browser_default.pushState("replace", { root: true, type: "patch", id: this.main.id });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      this.on("submit", (e) => {
        let phxEvent = e.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          return;
        }
        e.preventDefault();
        e.target.disabled = true;
        this.withinOwners(e.target, (view) => {
          js_default.exec("submit", phxEvent, view, e.target, ["push", {}]);
        });
      }, false);
      for (let type of ["change", "input"]) {
        this.on(type, (e) => {
          let phxChange = this.binding("change");
          let input = e.target;
          let inputEvent = input.getAttribute(phxChange);
          let formEvent = input.form && input.form.getAttribute(phxChange);
          let phxEvent = inputEvent || formEvent;
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let dispatcher = inputEvent ? input : input.form;
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type !== lastType) {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e, type, () => {
            this.withinOwners(dispatcher, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              if (!dom_default.isTextualInput(input)) {
                this.setActiveElement(input);
              }
              js_default.exec("change", phxEvent, view, input, ["push", { _target: e.target.name, dispatcher }]);
            });
          });
        }, false);
      }
    }
    debounce(el, event, eventType, callback) {
      if (eventType === "blur" || eventType === "focusout") {
        return callback();
      }
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      this.withinOwners(el, (view) => {
        let asyncFilter = () => !view.isDestroyed() && document.body.contains(el);
        dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, () => {
          callback();
        });
      });
    }
    silenceEvents(callback) {
      this.silenced = true;
      callback();
      this.silenced = false;
    }
    on(event, callback) {
      window.addEventListener(event, (e) => {
        if (!this.silenced) {
          callback(e);
        }
      });
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
      this.reset();
    }
    reset() {
      this.transitions.forEach((timer) => {
        cancelTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback) {
      if (this.size() === 0) {
        callback();
      } else {
        this.pushPendingOp(callback);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        if (this.size() === 0) {
          this.flushPendingOps();
        }
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      this.pendingOps.forEach((op) => op());
      this.pendingOps = [];
    }
  };

  // node_modules/@shopify/draggable/build/esm/shared/AbstractEvent/AbstractEvent.mjs
  var AbstractEvent = class {
    constructor(data) {
      this._canceled = false;
      this.data = data;
    }
    get type() {
      return this.constructor.type;
    }
    get cancelable() {
      return this.constructor.cancelable;
    }
    cancel() {
      this._canceled = true;
    }
    canceled() {
      return this._canceled;
    }
    clone(data) {
      return new this.constructor(__spreadValues(__spreadValues({}, this.data), data));
    }
  };
  AbstractEvent.type = "event";
  AbstractEvent.cancelable = false;

  // node_modules/@shopify/draggable/build/esm/shared/AbstractPlugin/AbstractPlugin.mjs
  var AbstractPlugin = class {
    constructor(draggable) {
      this.draggable = draggable;
    }
    attach() {
      throw new Error("Not Implemented");
    }
    detach() {
      throw new Error("Not Implemented");
    }
  };

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/Sensor/Sensor.mjs
  var defaultDelay = {
    mouse: 0,
    drag: 0,
    touch: 100
  };
  var Sensor = class {
    constructor(containers = [], options = {}) {
      this.containers = [...containers];
      this.options = __spreadValues({}, options);
      this.dragging = false;
      this.currentContainer = null;
      this.originalSource = null;
      this.startEvent = null;
      this.delay = calcDelay(options.delay);
    }
    attach() {
      return this;
    }
    detach() {
      return this;
    }
    addContainer(...containers) {
      this.containers = [...this.containers, ...containers];
    }
    removeContainer(...containers) {
      this.containers = this.containers.filter((container) => !containers.includes(container));
    }
    trigger(element, sensorEvent) {
      const event = document.createEvent("Event");
      event.detail = sensorEvent;
      event.initEvent(sensorEvent.type, true, true);
      element.dispatchEvent(event);
      this.lastEvent = sensorEvent;
      return sensorEvent;
    }
  };
  function calcDelay(optionsDelay) {
    const delay = {};
    if (optionsDelay === void 0) {
      return __spreadValues({}, defaultDelay);
    }
    if (typeof optionsDelay === "number") {
      for (const key in defaultDelay) {
        if (Object.prototype.hasOwnProperty.call(defaultDelay, key)) {
          delay[key] = optionsDelay;
        }
      }
      return delay;
    }
    for (const key in defaultDelay) {
      if (Object.prototype.hasOwnProperty.call(defaultDelay, key)) {
        if (optionsDelay[key] === void 0) {
          delay[key] = defaultDelay[key];
        } else {
          delay[key] = optionsDelay[key];
        }
      }
    }
    return delay;
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/closest/closest.mjs
  function closest(node, value) {
    if (node == null) {
      return null;
    }
    function conditionFn(currentNode) {
      if (currentNode == null || value == null) {
        return false;
      } else if (isSelector(value)) {
        return Element.prototype.matches.call(currentNode, value);
      } else if (isNodeList(value)) {
        return [...value].includes(currentNode);
      } else if (isElement(value)) {
        return value === currentNode;
      } else if (isFunction(value)) {
        return value(currentNode);
      } else {
        return false;
      }
    }
    let current = node;
    do {
      current = current.correspondingUseElement || current.correspondingElement || current;
      if (conditionFn(current)) {
        return current;
      }
      current = (current == null ? void 0 : current.parentNode) || null;
    } while (current != null && current !== document.body && current !== document);
    return null;
  }
  function isSelector(value) {
    return Boolean(typeof value === "string");
  }
  function isNodeList(value) {
    return Boolean(value instanceof NodeList || value instanceof Array);
  }
  function isElement(value) {
    return Boolean(value instanceof Node);
  }
  function isFunction(value) {
    return Boolean(typeof value === "function");
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/distance/distance.mjs
  function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/SensorEvent/SensorEvent.mjs
  var SensorEvent = class extends AbstractEvent {
    get originalEvent() {
      return this.data.originalEvent;
    }
    get clientX() {
      return this.data.clientX;
    }
    get clientY() {
      return this.data.clientY;
    }
    get target() {
      return this.data.target;
    }
    get container() {
      return this.data.container;
    }
    get originalSource() {
      return this.data.originalSource;
    }
    get pressure() {
      return this.data.pressure;
    }
  };
  var DragStartSensorEvent = class extends SensorEvent {
  };
  DragStartSensorEvent.type = "drag:start";
  var DragMoveSensorEvent = class extends SensorEvent {
  };
  DragMoveSensorEvent.type = "drag:move";
  var DragStopSensorEvent = class extends SensorEvent {
  };
  DragStopSensorEvent.type = "drag:stop";
  var DragPressureSensorEvent = class extends SensorEvent {
  };
  DragPressureSensorEvent.type = "drag:pressure";

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/MouseSensor/MouseSensor.mjs
  var onContextMenuWhileDragging = Symbol("onContextMenuWhileDragging");
  var onMouseDown = Symbol("onMouseDown");
  var onMouseMove = Symbol("onMouseMove");
  var onMouseUp = Symbol("onMouseUp");
  var startDrag = Symbol("startDrag");
  var onDistanceChange = Symbol("onDistanceChange");
  var MouseSensor = class extends Sensor {
    constructor(containers = [], options = {}) {
      super(containers, options);
      this.mouseDownTimeout = null;
      this.pageX = null;
      this.pageY = null;
      this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);
      this[onMouseDown] = this[onMouseDown].bind(this);
      this[onMouseMove] = this[onMouseMove].bind(this);
      this[onMouseUp] = this[onMouseUp].bind(this);
      this[startDrag] = this[startDrag].bind(this);
      this[onDistanceChange] = this[onDistanceChange].bind(this);
    }
    attach() {
      document.addEventListener("mousedown", this[onMouseDown], true);
    }
    detach() {
      document.removeEventListener("mousedown", this[onMouseDown], true);
    }
    [onMouseDown](event) {
      if (event.button !== 0 || event.ctrlKey || event.metaKey) {
        return;
      }
      const container = closest(event.target, this.containers);
      if (!container) {
        return;
      }
      if (this.options.handle && event.target && !closest(event.target, this.options.handle)) {
        return;
      }
      const originalSource = closest(event.target, this.options.draggable);
      if (!originalSource) {
        return;
      }
      const {
        delay
      } = this;
      const {
        pageX,
        pageY
      } = event;
      Object.assign(this, {
        pageX,
        pageY
      });
      this.onMouseDownAt = Date.now();
      this.startEvent = event;
      this.currentContainer = container;
      this.originalSource = originalSource;
      document.addEventListener("mouseup", this[onMouseUp]);
      document.addEventListener("dragstart", preventNativeDragStart);
      document.addEventListener("mousemove", this[onDistanceChange]);
      this.mouseDownTimeout = window.setTimeout(() => {
        this[onDistanceChange]({
          pageX: this.pageX,
          pageY: this.pageY
        });
      }, delay.mouse);
    }
    [startDrag]() {
      const startEvent = this.startEvent;
      const container = this.currentContainer;
      const originalSource = this.originalSource;
      const dragStartEvent = new DragStartSensorEvent({
        clientX: startEvent.clientX,
        clientY: startEvent.clientY,
        target: startEvent.target,
        container,
        originalSource,
        originalEvent: startEvent
      });
      this.trigger(this.currentContainer, dragStartEvent);
      this.dragging = !dragStartEvent.canceled();
      if (this.dragging) {
        document.addEventListener("contextmenu", this[onContextMenuWhileDragging], true);
        document.addEventListener("mousemove", this[onMouseMove]);
      }
    }
    [onDistanceChange](event) {
      const {
        pageX,
        pageY
      } = event;
      const {
        distance: distance$1
      } = this.options;
      const {
        startEvent,
        delay
      } = this;
      Object.assign(this, {
        pageX,
        pageY
      });
      if (!this.currentContainer) {
        return;
      }
      const timeElapsed = Date.now() - this.onMouseDownAt;
      const distanceTravelled = distance(startEvent.pageX, startEvent.pageY, pageX, pageY) || 0;
      clearTimeout(this.mouseDownTimeout);
      if (timeElapsed < delay.mouse) {
        document.removeEventListener("mousemove", this[onDistanceChange]);
      } else if (distanceTravelled >= distance$1) {
        document.removeEventListener("mousemove", this[onDistanceChange]);
        this[startDrag]();
      }
    }
    [onMouseMove](event) {
      if (!this.dragging) {
        return;
      }
      const target = document.elementFromPoint(event.clientX, event.clientY);
      const dragMoveEvent = new DragMoveSensorEvent({
        clientX: event.clientX,
        clientY: event.clientY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragMoveEvent);
    }
    [onMouseUp](event) {
      clearTimeout(this.mouseDownTimeout);
      if (event.button !== 0) {
        return;
      }
      document.removeEventListener("mouseup", this[onMouseUp]);
      document.removeEventListener("dragstart", preventNativeDragStart);
      document.removeEventListener("mousemove", this[onDistanceChange]);
      if (!this.dragging) {
        return;
      }
      const target = document.elementFromPoint(event.clientX, event.clientY);
      const dragStopEvent = new DragStopSensorEvent({
        clientX: event.clientX,
        clientY: event.clientY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragStopEvent);
      document.removeEventListener("contextmenu", this[onContextMenuWhileDragging], true);
      document.removeEventListener("mousemove", this[onMouseMove]);
      this.currentContainer = null;
      this.dragging = false;
      this.startEvent = null;
    }
    [onContextMenuWhileDragging](event) {
      event.preventDefault();
    }
  };
  function preventNativeDragStart(event) {
    event.preventDefault();
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/touchCoords/touchCoords.mjs
  function touchCoords(event) {
    const {
      touches,
      changedTouches
    } = event;
    return touches && touches[0] || changedTouches && changedTouches[0];
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/TouchSensor/TouchSensor.mjs
  var onTouchStart = Symbol("onTouchStart");
  var onTouchEnd = Symbol("onTouchEnd");
  var onTouchMove = Symbol("onTouchMove");
  var startDrag2 = Symbol("startDrag");
  var onDistanceChange2 = Symbol("onDistanceChange");
  var preventScrolling = false;
  window.addEventListener("touchmove", (event) => {
    if (!preventScrolling) {
      return;
    }
    event.preventDefault();
  }, {
    passive: false
  });
  var TouchSensor = class extends Sensor {
    constructor(containers = [], options = {}) {
      super(containers, options);
      this.currentScrollableParent = null;
      this.tapTimeout = null;
      this.touchMoved = false;
      this.pageX = null;
      this.pageY = null;
      this[onTouchStart] = this[onTouchStart].bind(this);
      this[onTouchEnd] = this[onTouchEnd].bind(this);
      this[onTouchMove] = this[onTouchMove].bind(this);
      this[startDrag2] = this[startDrag2].bind(this);
      this[onDistanceChange2] = this[onDistanceChange2].bind(this);
    }
    attach() {
      document.addEventListener("touchstart", this[onTouchStart]);
    }
    detach() {
      document.removeEventListener("touchstart", this[onTouchStart]);
    }
    [onTouchStart](event) {
      const container = closest(event.target, this.containers);
      if (!container) {
        return;
      }
      if (this.options.handle && event.target && !closest(event.target, this.options.handle)) {
        return;
      }
      const originalSource = closest(event.target, this.options.draggable);
      if (!originalSource) {
        return;
      }
      const {
        distance: distance2 = 0
      } = this.options;
      const {
        delay
      } = this;
      const {
        pageX,
        pageY
      } = touchCoords(event);
      Object.assign(this, {
        pageX,
        pageY
      });
      this.onTouchStartAt = Date.now();
      this.startEvent = event;
      this.currentContainer = container;
      this.originalSource = originalSource;
      document.addEventListener("touchend", this[onTouchEnd]);
      document.addEventListener("touchcancel", this[onTouchEnd]);
      document.addEventListener("touchmove", this[onDistanceChange2]);
      container.addEventListener("contextmenu", onContextMenu);
      if (distance2) {
        preventScrolling = true;
      }
      this.tapTimeout = window.setTimeout(() => {
        this[onDistanceChange2]({
          touches: [{
            pageX: this.pageX,
            pageY: this.pageY
          }]
        });
      }, delay.touch);
    }
    [startDrag2]() {
      const startEvent = this.startEvent;
      const container = this.currentContainer;
      const touch = touchCoords(startEvent);
      const originalSource = this.originalSource;
      const dragStartEvent = new DragStartSensorEvent({
        clientX: touch.pageX,
        clientY: touch.pageY,
        target: startEvent.target,
        container,
        originalSource,
        originalEvent: startEvent
      });
      this.trigger(this.currentContainer, dragStartEvent);
      this.dragging = !dragStartEvent.canceled();
      if (this.dragging) {
        document.addEventListener("touchmove", this[onTouchMove]);
      }
      preventScrolling = this.dragging;
    }
    [onDistanceChange2](event) {
      const {
        distance: distance$1
      } = this.options;
      const {
        startEvent,
        delay
      } = this;
      const start = touchCoords(startEvent);
      const current = touchCoords(event);
      const timeElapsed = Date.now() - this.onTouchStartAt;
      const distanceTravelled = distance(start.pageX, start.pageY, current.pageX, current.pageY);
      Object.assign(this, current);
      clearTimeout(this.tapTimeout);
      if (timeElapsed < delay.touch) {
        document.removeEventListener("touchmove", this[onDistanceChange2]);
      } else if (distanceTravelled >= distance$1) {
        document.removeEventListener("touchmove", this[onDistanceChange2]);
        this[startDrag2]();
      }
    }
    [onTouchMove](event) {
      if (!this.dragging) {
        return;
      }
      const {
        pageX,
        pageY
      } = touchCoords(event);
      const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);
      const dragMoveEvent = new DragMoveSensorEvent({
        clientX: pageX,
        clientY: pageY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragMoveEvent);
    }
    [onTouchEnd](event) {
      clearTimeout(this.tapTimeout);
      preventScrolling = false;
      document.removeEventListener("touchend", this[onTouchEnd]);
      document.removeEventListener("touchcancel", this[onTouchEnd]);
      document.removeEventListener("touchmove", this[onDistanceChange2]);
      if (this.currentContainer) {
        this.currentContainer.removeEventListener("contextmenu", onContextMenu);
      }
      if (!this.dragging) {
        return;
      }
      document.removeEventListener("touchmove", this[onTouchMove]);
      const {
        pageX,
        pageY
      } = touchCoords(event);
      const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);
      event.preventDefault();
      const dragStopEvent = new DragStopSensorEvent({
        clientX: pageX,
        clientY: pageY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragStopEvent);
      this.currentContainer = null;
      this.dragging = false;
      this.startEvent = null;
    }
  };
  function onContextMenu(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/DragSensor/DragSensor.mjs
  var onMouseDown2 = Symbol("onMouseDown");
  var onMouseUp2 = Symbol("onMouseUp");
  var onDragStart = Symbol("onDragStart");
  var onDragOver = Symbol("onDragOver");
  var onDragEnd = Symbol("onDragEnd");
  var onDrop = Symbol("onDrop");
  var reset = Symbol("reset");

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/ForceTouchSensor/ForceTouchSensor.mjs
  var onMouseForceWillBegin = Symbol("onMouseForceWillBegin");
  var onMouseForceDown = Symbol("onMouseForceDown");
  var onMouseDown3 = Symbol("onMouseDown");
  var onMouseForceChange = Symbol("onMouseForceChange");
  var onMouseMove2 = Symbol("onMouseMove");
  var onMouseUp3 = Symbol("onMouseUp");
  var onMouseForceGlobalChange = Symbol("onMouseForceGlobalChange");

  // node_modules/@shopify/draggable/build/esm/Plugins/index.mjs
  var Plugins_exports = {};
  __export(Plugins_exports, {
    Collidable: () => Collidable,
    ResizeMirror: () => ResizeMirror,
    Snappable: () => Snappable,
    SortAnimation: () => SortAnimation,
    SwapAnimation: () => SwapAnimation,
    defaultResizeMirrorOptions: () => defaultOptions,
    defaultSortAnimationOptions: () => defaultOptions3,
    defaultSwapAnimationOptions: () => defaultOptions2
  });

  // node_modules/@shopify/draggable/build/esm/Plugins/Collidable/CollidableEvent/CollidableEvent.mjs
  var CollidableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  CollidableEvent.type = "collidable";
  var CollidableInEvent = class extends CollidableEvent {
    get collidingElement() {
      return this.data.collidingElement;
    }
  };
  CollidableInEvent.type = "collidable:in";
  var CollidableOutEvent = class extends CollidableEvent {
    get collidingElement() {
      return this.data.collidingElement;
    }
  };
  CollidableOutEvent.type = "collidable:out";

  // node_modules/@shopify/draggable/build/esm/Plugins/Collidable/Collidable.mjs
  var onDragMove = Symbol("onDragMove");
  var onDragStop = Symbol("onDragStop");
  var onRequestAnimationFrame = Symbol("onRequestAnimationFrame");
  var Collidable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.currentlyCollidingElement = null;
      this.lastCollidingElement = null;
      this.currentAnimationFrame = null;
      this[onDragMove] = this[onDragMove].bind(this);
      this[onDragStop] = this[onDragStop].bind(this);
      this[onRequestAnimationFrame] = this[onRequestAnimationFrame].bind(this);
    }
    attach() {
      this.draggable.on("drag:move", this[onDragMove]).on("drag:stop", this[onDragStop]);
    }
    detach() {
      this.draggable.off("drag:move", this[onDragMove]).off("drag:stop", this[onDragStop]);
    }
    getCollidables() {
      const collidables = this.draggable.options.collidables;
      if (typeof collidables === "string") {
        return Array.prototype.slice.call(document.querySelectorAll(collidables));
      } else if (collidables instanceof NodeList || collidables instanceof Array) {
        return Array.prototype.slice.call(collidables);
      } else if (collidables instanceof HTMLElement) {
        return [collidables];
      } else if (typeof collidables === "function") {
        return collidables();
      } else {
        return [];
      }
    }
    [onDragMove](event) {
      const target = event.sensorEvent.target;
      this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));
      if (this.currentlyCollidingElement) {
        event.cancel();
      }
      const collidableInEvent = new CollidableInEvent({
        dragEvent: event,
        collidingElement: this.currentlyCollidingElement
      });
      const collidableOutEvent = new CollidableOutEvent({
        dragEvent: event,
        collidingElement: this.lastCollidingElement
      });
      const enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);
      const leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);
      if (enteringCollidable) {
        if (this.lastCollidingElement) {
          this.draggable.trigger(collidableOutEvent);
        }
        this.draggable.trigger(collidableInEvent);
      } else if (leavingCollidable) {
        this.draggable.trigger(collidableOutEvent);
      }
      this.lastCollidingElement = this.currentlyCollidingElement;
    }
    [onDragStop](event) {
      const lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;
      const collidableOutEvent = new CollidableOutEvent({
        dragEvent: event,
        collidingElement: lastCollidingElement
      });
      if (lastCollidingElement) {
        this.draggable.trigger(collidableOutEvent);
      }
      this.lastCollidingElement = null;
      this.currentlyCollidingElement = null;
    }
    [onRequestAnimationFrame](target) {
      return () => {
        const collidables = this.getCollidables();
        this.currentlyCollidingElement = closest(target, (element) => collidables.includes(element));
      };
    }
  };

  // node_modules/@shopify/draggable/build/esm/_virtual/_rollupPluginBabelHelpers.mjs
  function createAddInitializerMethod(e, t) {
    return function(r) {
      assertNotFinished(t, "addInitializer"), assertCallable(r, "An initializer"), e.push(r);
    };
  }
  function assertInstanceIfPrivate(e, t) {
    if (!e(t))
      throw new TypeError("Attempted to access private element on non-instance");
  }
  function memberDec(e, t, r, a, n, i, s, o, c, l, u) {
    var f;
    switch (i) {
      case 1:
        f = "accessor";
        break;
      case 2:
        f = "method";
        break;
      case 3:
        f = "getter";
        break;
      case 4:
        f = "setter";
        break;
      default:
        f = "field";
    }
    var d, p, h = {
      kind: f,
      name: o ? "#" + r : r,
      static: s,
      private: o,
      metadata: u
    }, v = {
      v: false
    };
    if (i !== 0 && (h.addInitializer = createAddInitializerMethod(n, v)), o || i !== 0 && i !== 2) {
      if (i === 2)
        d = function(e2) {
          return assertInstanceIfPrivate(l, e2), a.value;
        };
      else {
        var y = i === 0 || i === 1;
        (y || i === 3) && (d = o ? function(e2) {
          return assertInstanceIfPrivate(l, e2), a.get.call(e2);
        } : function(e2) {
          return a.get.call(e2);
        }), (y || i === 4) && (p = o ? function(e2, t2) {
          assertInstanceIfPrivate(l, e2), a.set.call(e2, t2);
        } : function(e2, t2) {
          a.set.call(e2, t2);
        });
      }
    } else
      d = function(e2) {
        return e2[r];
      }, i === 0 && (p = function(e2, t2) {
        e2[r] = t2;
      });
    var m = o ? l.bind() : function(e2) {
      return r in e2;
    };
    h.access = d && p ? {
      get: d,
      set: p,
      has: m
    } : d ? {
      get: d,
      has: m
    } : {
      set: p,
      has: m
    };
    try {
      return e.call(t, c, h);
    } finally {
      v.v = true;
    }
  }
  function assertNotFinished(e, t) {
    if (e.v)
      throw new Error("attempted to call " + t + " after decoration was finished");
  }
  function assertCallable(e, t) {
    if (typeof e != "function")
      throw new TypeError(t + " must be a function");
  }
  function assertValidReturnValue(e, t) {
    var r = typeof t;
    if (e === 1) {
      if (r !== "object" || t === null)
        throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
      t.get !== void 0 && assertCallable(t.get, "accessor.get"), t.set !== void 0 && assertCallable(t.set, "accessor.set"), t.init !== void 0 && assertCallable(t.init, "accessor.init");
    } else if (r !== "function") {
      var a;
      throw a = e === 0 ? "field" : e === 5 ? "class" : "method", new TypeError(a + " decorators must return a function or void 0");
    }
  }
  function curryThis1(e) {
    return function() {
      return e(this);
    };
  }
  function curryThis2(e) {
    return function(t) {
      e(this, t);
    };
  }
  function applyMemberDec(e, t, r, a, n, i, s, o, c, l, u) {
    var f, d, p, h, v, y, m = r[0];
    a || Array.isArray(m) || (m = [m]), o ? f = i === 0 || i === 1 ? {
      get: curryThis1(r[3]),
      set: curryThis2(r[4])
    } : i === 3 ? {
      get: r[3]
    } : i === 4 ? {
      set: r[3]
    } : {
      value: r[3]
    } : i !== 0 && (f = Object.getOwnPropertyDescriptor(t, n)), i === 1 ? p = {
      get: f.get,
      set: f.set
    } : i === 2 ? p = f.value : i === 3 ? p = f.get : i === 4 && (p = f.set);
    for (var g = a ? 2 : 1, b = m.length - 1; b >= 0; b -= g) {
      var I;
      if ((h = memberDec(m[b], a ? m[b - 1] : void 0, n, f, c, i, s, o, p, l, u)) !== void 0)
        assertValidReturnValue(i, h), i === 0 ? I = h : i === 1 ? (I = h.init, v = h.get || p.get, y = h.set || p.set, p = {
          get: v,
          set: y
        }) : p = h, I !== void 0 && (d === void 0 ? d = I : typeof d == "function" ? d = [d, I] : d.push(I));
    }
    if (i === 0 || i === 1) {
      if (d === void 0)
        d = function(e2, t2) {
          return t2;
        };
      else if (typeof d != "function") {
        var w = d;
        d = function(e2, t2) {
          for (var r2 = t2, a2 = w.length - 1; a2 >= 0; a2--)
            r2 = w[a2].call(e2, r2);
          return r2;
        };
      } else {
        var M = d;
        d = function(e2, t2) {
          return M.call(e2, t2);
        };
      }
      e.push(d);
    }
    i !== 0 && (i === 1 ? (f.get = p.get, f.set = p.set) : i === 2 ? f.value = p : i === 3 ? f.get = p : i === 4 && (f.set = p), o ? i === 1 ? (e.push(function(e2, t2) {
      return p.get.call(e2, t2);
    }), e.push(function(e2, t2) {
      return p.set.call(e2, t2);
    })) : i === 2 ? e.push(p) : e.push(function(e2, t2) {
      return p.call(e2, t2);
    }) : Object.defineProperty(t, n, f));
  }
  function applyMemberDecs(e, t, r, a) {
    for (var n, i, s, o = [], c = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), u = 0; u < t.length; u++) {
      var f = t[u];
      if (Array.isArray(f)) {
        var d, p, h = f[1], v = f[2], y = f.length > 3, m = 16 & h, g = !!(8 & h), b = r;
        if (h &= 7, g ? (d = e, h !== 0 && (p = i = i || []), y && !s && (s = function(t2) {
          return _checkInRHS(t2) === e;
        }), b = s) : (d = e.prototype, h !== 0 && (p = n = n || [])), h !== 0 && !y) {
          var I = g ? l : c, w = I.get(v) || 0;
          if (w === true || w === 3 && h !== 4 || w === 4 && h !== 3)
            throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + v);
          I.set(v, !(!w && h > 2) || h);
        }
        applyMemberDec(o, d, f, m, v, h, g, y, p, b, a);
      }
    }
    return pushInitializers(o, n), pushInitializers(o, i), o;
  }
  function pushInitializers(e, t) {
    t && e.push(function(e2) {
      for (var r = 0; r < t.length; r++)
        t[r].call(e2);
      return e2;
    });
  }
  function applyClassDecs(e, t, r, a) {
    if (t.length) {
      for (var n = [], i = e, s = e.name, o = r ? 2 : 1, c = t.length - 1; c >= 0; c -= o) {
        var l = {
          v: false
        };
        try {
          var u = t[c].call(r ? t[c - 1] : void 0, i, {
            kind: "class",
            name: s,
            addInitializer: createAddInitializerMethod(n, l),
            metadata: a
          });
        } finally {
          l.v = true;
        }
        u !== void 0 && (assertValidReturnValue(5, u), i = u);
      }
      return [defineMetadata(i, a), function() {
        for (var e2 = 0; e2 < n.length; e2++)
          n[e2].call(i);
      }];
    }
  }
  function defineMetadata(e, t) {
    return Object.defineProperty(e, Symbol.metadata || Symbol.for("Symbol.metadata"), {
      configurable: true,
      enumerable: true,
      value: t
    });
  }
  function _applyDecs2305(e, t, r, a, n, i) {
    if (arguments.length >= 6)
      var s = i[Symbol.metadata || Symbol.for("Symbol.metadata")];
    var o = Object.create(s === void 0 ? null : s), c = applyMemberDecs(e, t, n, o);
    return r.length || defineMetadata(e, o), {
      e: c,
      get c() {
        return applyClassDecs(e, r, a, o);
      }
    };
  }
  function _checkInRHS(e) {
    if (Object(e) !== e)
      throw TypeError("right-hand side of 'in' should be an object, got " + (e !== null ? typeof e : "null"));
    return e;
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/decorators/AutoBind.mjs
  function AutoBind(originalMethod, {
    name,
    addInitializer
  }) {
    addInitializer(function() {
      this[name] = originalMethod.bind(this);
    });
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/requestNextAnimationFrame/requestNextAnimationFrame.mjs
  function requestNextAnimationFrame(callback) {
    return requestAnimationFrame(() => {
      requestAnimationFrame(callback);
    });
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/DragEvent/DragEvent.mjs
  var DragEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get source() {
      return this.data.source;
    }
    get originalSource() {
      return this.data.originalSource;
    }
    get mirror() {
      return this.data.mirror;
    }
    get sourceContainer() {
      return this.data.sourceContainer;
    }
    get sensorEvent() {
      return this.data.sensorEvent;
    }
    get originalEvent() {
      if (this.sensorEvent) {
        return this.sensorEvent.originalEvent;
      }
      return null;
    }
  };
  DragEvent.type = "drag";
  var DragStartEvent = class extends DragEvent {
  };
  DragStartEvent.type = "drag:start";
  DragStartEvent.cancelable = true;
  var DragMoveEvent = class extends DragEvent {
  };
  DragMoveEvent.type = "drag:move";
  var DragOverEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
    get over() {
      return this.data.over;
    }
  };
  DragOverEvent.type = "drag:over";
  DragOverEvent.cancelable = true;
  function isDragOverEvent(event) {
    return event.type === DragOverEvent.type;
  }
  var DragOutEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
    get over() {
      return this.data.over;
    }
  };
  DragOutEvent.type = "drag:out";
  var DragOverContainerEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
  };
  DragOverContainerEvent.type = "drag:over:container";
  var DragOutContainerEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
  };
  DragOutContainerEvent.type = "drag:out:container";
  var DragPressureEvent = class extends DragEvent {
    get pressure() {
      return this.data.pressure;
    }
  };
  DragPressureEvent.type = "drag:pressure";
  var DragStopEvent = class extends DragEvent {
  };
  DragStopEvent.type = "drag:stop";
  DragStopEvent.cancelable = true;
  var DragStoppedEvent = class extends DragEvent {
  };
  DragStoppedEvent.type = "drag:stopped";

  // node_modules/@shopify/draggable/build/esm/Plugins/ResizeMirror/ResizeMirror.mjs
  var _initProto;
  var _class;
  var defaultOptions = {};
  var ResizeMirror = class extends AbstractPlugin {
    constructor(draggable) {
      _initProto(super(draggable));
      this.lastWidth = 0;
      this.lastHeight = 0;
      this.mirror = null;
    }
    attach() {
      this.draggable.on("mirror:created", this.onMirrorCreated).on("drag:over", this.onDragOver).on("drag:over:container", this.onDragOver);
    }
    detach() {
      this.draggable.off("mirror:created", this.onMirrorCreated).off("mirror:destroy", this.onMirrorDestroy).off("drag:over", this.onDragOver).off("drag:over:container", this.onDragOver);
    }
    getOptions() {
      return this.draggable.options.resizeMirror || {};
    }
    onMirrorCreated({
      mirror
    }) {
      this.mirror = mirror;
    }
    onMirrorDestroy() {
      this.mirror = null;
    }
    onDragOver(dragEvent) {
      this.resize(dragEvent);
    }
    resize(dragEvent) {
      requestAnimationFrame(() => {
        let over = null;
        const {
          overContainer
        } = dragEvent;
        if (this.mirror == null || this.mirror.parentNode == null) {
          return;
        }
        if (this.mirror.parentNode !== overContainer) {
          overContainer.appendChild(this.mirror);
        }
        if (isDragOverEvent(dragEvent)) {
          over = dragEvent.over;
        }
        const overElement = over || this.draggable.getDraggableElementsForContainer(overContainer)[0];
        if (!overElement) {
          return;
        }
        requestNextAnimationFrame(() => {
          const overRect = overElement.getBoundingClientRect();
          if (this.mirror == null || this.lastHeight === overRect.height && this.lastWidth === overRect.width) {
            return;
          }
          this.mirror.style.width = `${overRect.width}px`;
          this.mirror.style.height = `${overRect.height}px`;
          this.lastWidth = overRect.width;
          this.lastHeight = overRect.height;
        });
      });
    }
  };
  _class = ResizeMirror;
  [_initProto] = _applyDecs2305(_class, [[AutoBind, 2, "onMirrorCreated"], [AutoBind, 2, "onMirrorDestroy"], [AutoBind, 2, "onDragOver"]], [], 0, void 0, AbstractPlugin).e;

  // node_modules/@shopify/draggable/build/esm/Plugins/Snappable/SnappableEvent/SnappableEvent.mjs
  var SnapEvent = class extends AbstractEvent {
    get dragEvent() {
      return this.data.dragEvent;
    }
    get snappable() {
      return this.data.snappable;
    }
  };
  SnapEvent.type = "snap";
  var SnapInEvent = class extends SnapEvent {
  };
  SnapInEvent.type = "snap:in";
  SnapInEvent.cancelable = true;
  var SnapOutEvent = class extends SnapEvent {
  };
  SnapOutEvent.type = "snap:out";
  SnapOutEvent.cancelable = true;

  // node_modules/@shopify/draggable/build/esm/Plugins/Snappable/Snappable.mjs
  var onDragStart2 = Symbol("onDragStart");
  var onDragStop2 = Symbol("onDragStop");
  var onDragOver2 = Symbol("onDragOver");
  var onDragOut = Symbol("onDragOut");
  var onMirrorCreated = Symbol("onMirrorCreated");
  var onMirrorDestroy = Symbol("onMirrorDestroy");
  var Snappable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.firstSource = null;
      this.mirror = null;
      this[onDragStart2] = this[onDragStart2].bind(this);
      this[onDragStop2] = this[onDragStop2].bind(this);
      this[onDragOver2] = this[onDragOver2].bind(this);
      this[onDragOut] = this[onDragOut].bind(this);
      this[onMirrorCreated] = this[onMirrorCreated].bind(this);
      this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);
    }
    attach() {
      this.draggable.on("drag:start", this[onDragStart2]).on("drag:stop", this[onDragStop2]).on("drag:over", this[onDragOver2]).on("drag:out", this[onDragOut]).on("droppable:over", this[onDragOver2]).on("droppable:out", this[onDragOut]).on("mirror:created", this[onMirrorCreated]).on("mirror:destroy", this[onMirrorDestroy]);
    }
    detach() {
      this.draggable.off("drag:start", this[onDragStart2]).off("drag:stop", this[onDragStop2]).off("drag:over", this[onDragOver2]).off("drag:out", this[onDragOut]).off("droppable:over", this[onDragOver2]).off("droppable:out", this[onDragOut]).off("mirror:created", this[onMirrorCreated]).off("mirror:destroy", this[onMirrorDestroy]);
    }
    [onDragStart2](event) {
      if (event.canceled()) {
        return;
      }
      this.firstSource = event.source;
    }
    [onDragStop2]() {
      this.firstSource = null;
    }
    [onDragOver2](event) {
      if (event.canceled()) {
        return;
      }
      const source = event.source || event.dragEvent.source;
      if (source === this.firstSource) {
        this.firstSource = null;
        return;
      }
      const snapInEvent = new SnapInEvent({
        dragEvent: event,
        snappable: event.over || event.droppable
      });
      this.draggable.trigger(snapInEvent);
      if (snapInEvent.canceled()) {
        return;
      }
      if (this.mirror) {
        this.mirror.style.display = "none";
      }
      source.classList.remove(...this.draggable.getClassNamesFor("source:dragging"));
      source.classList.add(...this.draggable.getClassNamesFor("source:placed"));
      setTimeout(() => {
        source.classList.remove(...this.draggable.getClassNamesFor("source:placed"));
      }, this.draggable.options.placedTimeout);
    }
    [onDragOut](event) {
      if (event.canceled()) {
        return;
      }
      const source = event.source || event.dragEvent.source;
      const snapOutEvent = new SnapOutEvent({
        dragEvent: event,
        snappable: event.over || event.droppable
      });
      this.draggable.trigger(snapOutEvent);
      if (snapOutEvent.canceled()) {
        return;
      }
      if (this.mirror) {
        this.mirror.style.display = "";
      }
      source.classList.add(...this.draggable.getClassNamesFor("source:dragging"));
    }
    [onMirrorCreated]({
      mirror
    }) {
      this.mirror = mirror;
    }
    [onMirrorDestroy]() {
      this.mirror = null;
    }
  };

  // node_modules/@shopify/draggable/build/esm/Plugins/SwapAnimation/SwapAnimation.mjs
  var _initProto2;
  var _class2;
  var defaultOptions2 = {
    duration: 150,
    easingFunction: "ease-in-out",
    horizontal: false
  };
  var SwapAnimation = class extends AbstractPlugin {
    constructor(draggable) {
      _initProto2(super(draggable));
      this.options = __spreadValues(__spreadValues({}, defaultOptions2), this.getOptions());
      this.lastAnimationFrame = null;
    }
    attach() {
      this.draggable.on("sortable:sorted", this.onSortableSorted);
    }
    detach() {
      this.draggable.off("sortable:sorted", this.onSortableSorted);
    }
    getOptions() {
      return this.draggable.options.swapAnimation || {};
    }
    onSortableSorted({
      oldIndex,
      newIndex,
      dragEvent
    }) {
      const {
        source,
        over
      } = dragEvent;
      if (this.lastAnimationFrame) {
        cancelAnimationFrame(this.lastAnimationFrame);
      }
      this.lastAnimationFrame = requestAnimationFrame(() => {
        if (oldIndex >= newIndex) {
          animate(source, over, this.options);
        } else {
          animate(over, source, this.options);
        }
      });
    }
  };
  _class2 = SwapAnimation;
  [_initProto2] = _applyDecs2305(_class2, [[AutoBind, 2, "onSortableSorted"]], [], 0, void 0, AbstractPlugin).e;
  function animate(from, to, {
    duration,
    easingFunction,
    horizontal
  }) {
    for (const element of [from, to]) {
      element.style.pointerEvents = "none";
    }
    if (horizontal) {
      const width = from.offsetWidth;
      from.style.transform = `translate3d(${width}px, 0, 0)`;
      to.style.transform = `translate3d(-${width}px, 0, 0)`;
    } else {
      const height = from.offsetHeight;
      from.style.transform = `translate3d(0, ${height}px, 0)`;
      to.style.transform = `translate3d(0, -${height}px, 0)`;
    }
    requestAnimationFrame(() => {
      for (const element of [from, to]) {
        element.addEventListener("transitionend", resetElementOnTransitionEnd);
        element.style.transition = `transform ${duration}ms ${easingFunction}`;
        element.style.transform = "";
      }
    });
  }
  function resetElementOnTransitionEnd(event) {
    if (event.target == null || !isHTMLElement(event.target)) {
      return;
    }
    event.target.style.transition = "";
    event.target.style.pointerEvents = "";
    event.target.removeEventListener("transitionend", resetElementOnTransitionEnd);
  }
  function isHTMLElement(eventTarget) {
    return Boolean("style" in eventTarget);
  }

  // node_modules/@shopify/draggable/build/esm/Plugins/SortAnimation/SortAnimation.mjs
  var onSortableSorted = Symbol("onSortableSorted");
  var onSortableSort = Symbol("onSortableSort");
  var defaultOptions3 = {
    duration: 150,
    easingFunction: "ease-in-out"
  };
  var SortAnimation = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions3), this.getOptions());
      this.lastAnimationFrame = null;
      this.lastElements = [];
      this[onSortableSorted] = this[onSortableSorted].bind(this);
      this[onSortableSort] = this[onSortableSort].bind(this);
    }
    attach() {
      this.draggable.on("sortable:sort", this[onSortableSort]);
      this.draggable.on("sortable:sorted", this[onSortableSorted]);
    }
    detach() {
      this.draggable.off("sortable:sort", this[onSortableSort]);
      this.draggable.off("sortable:sorted", this[onSortableSorted]);
    }
    getOptions() {
      return this.draggable.options.sortAnimation || {};
    }
    [onSortableSort]({
      dragEvent
    }) {
      const {
        sourceContainer
      } = dragEvent;
      const elements = this.draggable.getDraggableElementsForContainer(sourceContainer);
      this.lastElements = Array.from(elements).map((el) => {
        return {
          domEl: el,
          offsetTop: el.offsetTop,
          offsetLeft: el.offsetLeft
        };
      });
    }
    [onSortableSorted]({
      oldIndex,
      newIndex
    }) {
      if (oldIndex === newIndex) {
        return;
      }
      const effectedElements = [];
      let start;
      let end;
      let num;
      if (oldIndex > newIndex) {
        start = newIndex;
        end = oldIndex - 1;
        num = 1;
      } else {
        start = oldIndex + 1;
        end = newIndex;
        num = -1;
      }
      for (let i = start; i <= end; i++) {
        const from = this.lastElements[i];
        const to = this.lastElements[i + num];
        effectedElements.push({
          from,
          to
        });
      }
      cancelAnimationFrame(this.lastAnimationFrame);
      this.lastAnimationFrame = requestAnimationFrame(() => {
        effectedElements.forEach((element) => animate2(element, this.options));
      });
    }
  };
  function animate2({
    from,
    to
  }, {
    duration,
    easingFunction
  }) {
    const domEl = from.domEl;
    const x = from.offsetLeft - to.offsetLeft;
    const y = from.offsetTop - to.offsetTop;
    domEl.style.pointerEvents = "none";
    domEl.style.transform = `translate3d(${x}px, ${y}px, 0)`;
    requestAnimationFrame(() => {
      domEl.addEventListener("transitionend", resetElementOnTransitionEnd2);
      domEl.style.transition = `transform ${duration}ms ${easingFunction}`;
      domEl.style.transform = "";
    });
  }
  function resetElementOnTransitionEnd2(event) {
    event.target.style.transition = "";
    event.target.style.pointerEvents = "";
    event.target.removeEventListener("transitionend", resetElementOnTransitionEnd2);
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Announcement/Announcement.mjs
  var onInitialize = Symbol("onInitialize");
  var onDestroy = Symbol("onDestroy");
  var announceEvent = Symbol("announceEvent");
  var announceMessage = Symbol("announceMessage");
  var ARIA_RELEVANT = "aria-relevant";
  var ARIA_ATOMIC = "aria-atomic";
  var ARIA_LIVE = "aria-live";
  var ROLE = "role";
  var defaultOptions4 = {
    expire: 7e3
  };
  var Announcement = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions4), this.getOptions());
      this.originalTriggerMethod = this.draggable.trigger;
      this[onInitialize] = this[onInitialize].bind(this);
      this[onDestroy] = this[onDestroy].bind(this);
    }
    attach() {
      this.draggable.on("draggable:initialize", this[onInitialize]);
    }
    detach() {
      this.draggable.off("draggable:destroy", this[onDestroy]);
    }
    getOptions() {
      return this.draggable.options.announcements || {};
    }
    [announceEvent](event) {
      const message = this.options[event.type];
      if (message && typeof message === "string") {
        this[announceMessage](message);
      }
      if (message && typeof message === "function") {
        this[announceMessage](message(event));
      }
    }
    [announceMessage](message) {
      announce(message, {
        expire: this.options.expire
      });
    }
    [onInitialize]() {
      this.draggable.trigger = (event) => {
        try {
          this[announceEvent](event);
        } finally {
          this.originalTriggerMethod.call(this.draggable, event);
        }
      };
    }
    [onDestroy]() {
      this.draggable.trigger = this.originalTriggerMethod;
    }
  };
  var liveRegion = createRegion();
  function announce(message, {
    expire
  }) {
    const element = document.createElement("div");
    element.textContent = message;
    liveRegion.appendChild(element);
    return setTimeout(() => {
      liveRegion.removeChild(element);
    }, expire);
  }
  function createRegion() {
    const element = document.createElement("div");
    element.setAttribute("id", "draggable-live-region");
    element.setAttribute(ARIA_RELEVANT, "additions");
    element.setAttribute(ARIA_ATOMIC, "true");
    element.setAttribute(ARIA_LIVE, "assertive");
    element.setAttribute(ROLE, "log");
    element.style.position = "fixed";
    element.style.width = "1px";
    element.style.height = "1px";
    element.style.top = "-1px";
    element.style.overflow = "hidden";
    return element;
  }
  document.addEventListener("DOMContentLoaded", () => {
    document.body.appendChild(liveRegion);
  });

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Focusable/Focusable.mjs
  var onInitialize2 = Symbol("onInitialize");
  var onDestroy2 = Symbol("onDestroy");
  var defaultOptions5 = {};
  var Focusable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions5), this.getOptions());
      this[onInitialize2] = this[onInitialize2].bind(this);
      this[onDestroy2] = this[onDestroy2].bind(this);
    }
    attach() {
      this.draggable.on("draggable:initialize", this[onInitialize2]).on("draggable:destroy", this[onDestroy2]);
    }
    detach() {
      this.draggable.off("draggable:initialize", this[onInitialize2]).off("draggable:destroy", this[onDestroy2]);
      this[onDestroy2]();
    }
    getOptions() {
      return this.draggable.options.focusable || {};
    }
    getElements() {
      return [...this.draggable.containers, ...this.draggable.getDraggableElements()];
    }
    [onInitialize2]() {
      requestAnimationFrame(() => {
        this.getElements().forEach((element) => decorateElement(element));
      });
    }
    [onDestroy2]() {
      requestAnimationFrame(() => {
        this.getElements().forEach((element) => stripElement(element));
      });
    }
  };
  var elementsWithMissingTabIndex = [];
  function decorateElement(element) {
    const hasMissingTabIndex = Boolean(!element.getAttribute("tabindex") && element.tabIndex === -1);
    if (hasMissingTabIndex) {
      elementsWithMissingTabIndex.push(element);
      element.tabIndex = 0;
    }
  }
  function stripElement(element) {
    const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);
    if (tabIndexElementPosition !== -1) {
      element.tabIndex = -1;
      elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);
    }
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Mirror/MirrorEvent/MirrorEvent.mjs
  var MirrorEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get source() {
      return this.data.source;
    }
    get originalSource() {
      return this.data.originalSource;
    }
    get sourceContainer() {
      return this.data.sourceContainer;
    }
    get sensorEvent() {
      return this.data.sensorEvent;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
    get originalEvent() {
      if (this.sensorEvent) {
        return this.sensorEvent.originalEvent;
      }
      return null;
    }
  };
  var MirrorCreateEvent = class extends MirrorEvent {
  };
  MirrorCreateEvent.type = "mirror:create";
  var MirrorCreatedEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
  };
  MirrorCreatedEvent.type = "mirror:created";
  var MirrorAttachedEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
  };
  MirrorAttachedEvent.type = "mirror:attached";
  var MirrorMoveEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
    get passedThreshX() {
      return this.data.passedThreshX;
    }
    get passedThreshY() {
      return this.data.passedThreshY;
    }
  };
  MirrorMoveEvent.type = "mirror:move";
  MirrorMoveEvent.cancelable = true;
  var MirrorMovedEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
    get passedThreshX() {
      return this.data.passedThreshX;
    }
    get passedThreshY() {
      return this.data.passedThreshY;
    }
  };
  MirrorMovedEvent.type = "mirror:moved";
  var MirrorDestroyEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
  };
  MirrorDestroyEvent.type = "mirror:destroy";
  MirrorDestroyEvent.cancelable = true;

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Mirror/Mirror.mjs
  var onDragStart3 = Symbol("onDragStart");
  var onDragMove2 = Symbol("onDragMove");
  var onDragStop3 = Symbol("onDragStop");
  var onMirrorCreated2 = Symbol("onMirrorCreated");
  var onMirrorMove = Symbol("onMirrorMove");
  var onScroll = Symbol("onScroll");
  var getAppendableContainer = Symbol("getAppendableContainer");
  var defaultOptions6 = {
    constrainDimensions: false,
    xAxis: true,
    yAxis: true,
    cursorOffsetX: null,
    cursorOffsetY: null,
    thresholdX: null,
    thresholdY: null
  };
  var Mirror = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions6), this.getOptions());
      this.scrollOffset = {
        x: 0,
        y: 0
      };
      this.initialScrollOffset = {
        x: window.scrollX,
        y: window.scrollY
      };
      this[onDragStart3] = this[onDragStart3].bind(this);
      this[onDragMove2] = this[onDragMove2].bind(this);
      this[onDragStop3] = this[onDragStop3].bind(this);
      this[onMirrorCreated2] = this[onMirrorCreated2].bind(this);
      this[onMirrorMove] = this[onMirrorMove].bind(this);
      this[onScroll] = this[onScroll].bind(this);
    }
    attach() {
      this.draggable.on("drag:start", this[onDragStart3]).on("drag:move", this[onDragMove2]).on("drag:stop", this[onDragStop3]).on("mirror:created", this[onMirrorCreated2]).on("mirror:move", this[onMirrorMove]);
    }
    detach() {
      this.draggable.off("drag:start", this[onDragStart3]).off("drag:move", this[onDragMove2]).off("drag:stop", this[onDragStop3]).off("mirror:created", this[onMirrorCreated2]).off("mirror:move", this[onMirrorMove]);
    }
    getOptions() {
      return this.draggable.options.mirror || {};
    }
    [onDragStart3](dragEvent) {
      if (dragEvent.canceled()) {
        return;
      }
      if ("ontouchstart" in window) {
        document.addEventListener("scroll", this[onScroll], true);
      }
      this.initialScrollOffset = {
        x: window.scrollX,
        y: window.scrollY
      };
      const {
        source,
        originalSource,
        sourceContainer,
        sensorEvent
      } = dragEvent;
      this.lastMirrorMovedClient = {
        x: sensorEvent.clientX,
        y: sensorEvent.clientY
      };
      const mirrorCreateEvent = new MirrorCreateEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent
      });
      this.draggable.trigger(mirrorCreateEvent);
      if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {
        return;
      }
      const appendableContainer = this[getAppendableContainer](source) || sourceContainer;
      this.mirror = source.cloneNode(true);
      const mirrorCreatedEvent = new MirrorCreatedEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent,
        mirror: this.mirror
      });
      const mirrorAttachedEvent = new MirrorAttachedEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent,
        mirror: this.mirror
      });
      this.draggable.trigger(mirrorCreatedEvent);
      appendableContainer.appendChild(this.mirror);
      this.draggable.trigger(mirrorAttachedEvent);
    }
    [onDragMove2](dragEvent) {
      if (!this.mirror || dragEvent.canceled()) {
        return;
      }
      const {
        source,
        originalSource,
        sourceContainer,
        sensorEvent
      } = dragEvent;
      let passedThreshX = true;
      let passedThreshY = true;
      if (this.options.thresholdX || this.options.thresholdY) {
        const {
          x: lastX,
          y: lastY
        } = this.lastMirrorMovedClient;
        if (Math.abs(lastX - sensorEvent.clientX) < this.options.thresholdX) {
          passedThreshX = false;
        } else {
          this.lastMirrorMovedClient.x = sensorEvent.clientX;
        }
        if (Math.abs(lastY - sensorEvent.clientY) < this.options.thresholdY) {
          passedThreshY = false;
        } else {
          this.lastMirrorMovedClient.y = sensorEvent.clientY;
        }
        if (!passedThreshX && !passedThreshY) {
          return;
        }
      }
      const mirrorMoveEvent = new MirrorMoveEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent,
        mirror: this.mirror,
        passedThreshX,
        passedThreshY
      });
      this.draggable.trigger(mirrorMoveEvent);
    }
    [onDragStop3](dragEvent) {
      if ("ontouchstart" in window) {
        document.removeEventListener("scroll", this[onScroll], true);
      }
      this.initialScrollOffset = {
        x: 0,
        y: 0
      };
      this.scrollOffset = {
        x: 0,
        y: 0
      };
      if (!this.mirror) {
        return;
      }
      const {
        source,
        sourceContainer,
        sensorEvent
      } = dragEvent;
      const mirrorDestroyEvent = new MirrorDestroyEvent({
        source,
        mirror: this.mirror,
        sourceContainer,
        sensorEvent,
        dragEvent
      });
      this.draggable.trigger(mirrorDestroyEvent);
      if (!mirrorDestroyEvent.canceled()) {
        this.mirror.remove();
      }
    }
    [onScroll]() {
      this.scrollOffset = {
        x: window.scrollX - this.initialScrollOffset.x,
        y: window.scrollY - this.initialScrollOffset.y
      };
    }
    [onMirrorCreated2]({
      mirror,
      source,
      sensorEvent
    }) {
      const mirrorClasses = this.draggable.getClassNamesFor("mirror");
      const setState = (_a) => {
        var _b = _a, {
          mirrorOffset,
          initialX,
          initialY
        } = _b, args = __objRest(_b, [
          "mirrorOffset",
          "initialX",
          "initialY"
        ]);
        this.mirrorOffset = mirrorOffset;
        this.initialX = initialX;
        this.initialY = initialY;
        this.lastMovedX = initialX;
        this.lastMovedY = initialY;
        return __spreadValues({
          mirrorOffset,
          initialX,
          initialY
        }, args);
      };
      mirror.style.display = "none";
      const initialState = {
        mirror,
        source,
        sensorEvent,
        mirrorClasses,
        scrollOffset: this.scrollOffset,
        options: this.options,
        passedThreshX: true,
        passedThreshY: true
      };
      return Promise.resolve(initialState).then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({
        initial: true
      })).then(removeMirrorID).then(setState);
    }
    [onMirrorMove](mirrorEvent) {
      if (mirrorEvent.canceled()) {
        return null;
      }
      const setState = (_a) => {
        var _b = _a, {
          lastMovedX,
          lastMovedY
        } = _b, args = __objRest(_b, [
          "lastMovedX",
          "lastMovedY"
        ]);
        this.lastMovedX = lastMovedX;
        this.lastMovedY = lastMovedY;
        return __spreadValues({
          lastMovedX,
          lastMovedY
        }, args);
      };
      const triggerMoved = (args) => {
        const mirrorMovedEvent = new MirrorMovedEvent({
          source: mirrorEvent.source,
          originalSource: mirrorEvent.originalSource,
          sourceContainer: mirrorEvent.sourceContainer,
          sensorEvent: mirrorEvent.sensorEvent,
          dragEvent: mirrorEvent.dragEvent,
          mirror: this.mirror,
          passedThreshX: mirrorEvent.passedThreshX,
          passedThreshY: mirrorEvent.passedThreshY
        });
        this.draggable.trigger(mirrorMovedEvent);
        return args;
      };
      const initialState = {
        mirror: mirrorEvent.mirror,
        sensorEvent: mirrorEvent.sensorEvent,
        mirrorOffset: this.mirrorOffset,
        options: this.options,
        initialX: this.initialX,
        initialY: this.initialY,
        scrollOffset: this.scrollOffset,
        passedThreshX: mirrorEvent.passedThreshX,
        passedThreshY: mirrorEvent.passedThreshY,
        lastMovedX: this.lastMovedX,
        lastMovedY: this.lastMovedY
      };
      return Promise.resolve(initialState).then(positionMirror({
        raf: true
      })).then(setState).then(triggerMoved);
    }
    [getAppendableContainer](source) {
      const appendTo = this.options.appendTo;
      if (typeof appendTo === "string") {
        return document.querySelector(appendTo);
      } else if (appendTo instanceof HTMLElement) {
        return appendTo;
      } else if (typeof appendTo === "function") {
        return appendTo(source);
      } else {
        return source.parentNode;
      }
    }
  };
  function computeMirrorDimensions(_a) {
    var _b = _a, {
      source
    } = _b, args = __objRest(_b, [
      "source"
    ]);
    return withPromise((resolve) => {
      const sourceRect = source.getBoundingClientRect();
      resolve(__spreadValues({
        source,
        sourceRect
      }, args));
    });
  }
  function calculateMirrorOffset(_a) {
    var _b = _a, {
      sensorEvent,
      sourceRect,
      options
    } = _b, args = __objRest(_b, [
      "sensorEvent",
      "sourceRect",
      "options"
    ]);
    return withPromise((resolve) => {
      const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;
      const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;
      const mirrorOffset = {
        top,
        left
      };
      resolve(__spreadValues({
        sensorEvent,
        sourceRect,
        mirrorOffset,
        options
      }, args));
    });
  }
  function resetMirror(_a) {
    var _b = _a, {
      mirror,
      source,
      options
    } = _b, args = __objRest(_b, [
      "mirror",
      "source",
      "options"
    ]);
    return withPromise((resolve) => {
      let offsetHeight;
      let offsetWidth;
      if (options.constrainDimensions) {
        const computedSourceStyles = getComputedStyle(source);
        offsetHeight = computedSourceStyles.getPropertyValue("height");
        offsetWidth = computedSourceStyles.getPropertyValue("width");
      }
      mirror.style.display = null;
      mirror.style.position = "fixed";
      mirror.style.pointerEvents = "none";
      mirror.style.top = 0;
      mirror.style.left = 0;
      mirror.style.margin = 0;
      if (options.constrainDimensions) {
        mirror.style.height = offsetHeight;
        mirror.style.width = offsetWidth;
      }
      resolve(__spreadValues({
        mirror,
        source,
        options
      }, args));
    });
  }
  function addMirrorClasses(_a) {
    var _b = _a, {
      mirror,
      mirrorClasses
    } = _b, args = __objRest(_b, [
      "mirror",
      "mirrorClasses"
    ]);
    return withPromise((resolve) => {
      mirror.classList.add(...mirrorClasses);
      resolve(__spreadValues({
        mirror,
        mirrorClasses
      }, args));
    });
  }
  function removeMirrorID(_a) {
    var _b = _a, {
      mirror
    } = _b, args = __objRest(_b, [
      "mirror"
    ]);
    return withPromise((resolve) => {
      mirror.removeAttribute("id");
      delete mirror.id;
      resolve(__spreadValues({
        mirror
      }, args));
    });
  }
  function positionMirror({
    withFrame = false,
    initial = false
  } = {}) {
    return (_a) => {
      var _b = _a, {
        mirror,
        sensorEvent,
        mirrorOffset,
        initialY,
        initialX,
        scrollOffset,
        options,
        passedThreshX,
        passedThreshY,
        lastMovedX,
        lastMovedY
      } = _b, args = __objRest(_b, [
        "mirror",
        "sensorEvent",
        "mirrorOffset",
        "initialY",
        "initialX",
        "scrollOffset",
        "options",
        "passedThreshX",
        "passedThreshY",
        "lastMovedX",
        "lastMovedY"
      ]);
      return withPromise((resolve) => {
        const result = __spreadValues({
          mirror,
          sensorEvent,
          mirrorOffset,
          options
        }, args);
        if (mirrorOffset) {
          const x = passedThreshX ? Math.round((sensorEvent.clientX - mirrorOffset.left - scrollOffset.x) / (options.thresholdX || 1)) * (options.thresholdX || 1) : Math.round(lastMovedX);
          const y = passedThreshY ? Math.round((sensorEvent.clientY - mirrorOffset.top - scrollOffset.y) / (options.thresholdY || 1)) * (options.thresholdY || 1) : Math.round(lastMovedY);
          if (options.xAxis && options.yAxis || initial) {
            mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;
          } else if (options.xAxis && !options.yAxis) {
            mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;
          } else if (options.yAxis && !options.xAxis) {
            mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;
          }
          if (initial) {
            result.initialX = x;
            result.initialY = y;
          }
          result.lastMovedX = x;
          result.lastMovedY = y;
        }
        resolve(result);
      }, {
        frame: withFrame
      });
    };
  }
  function withPromise(callback, {
    raf = false
  } = {}) {
    return new Promise((resolve, reject) => {
      if (raf) {
        requestAnimationFrame(() => {
          callback(resolve, reject);
        });
      } else {
        callback(resolve, reject);
      }
    });
  }
  function isNativeDragEvent(sensorEvent) {
    return /^drag/.test(sensorEvent.originalEvent.type);
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Scrollable/Scrollable.mjs
  var onDragStart4 = Symbol("onDragStart");
  var onDragMove3 = Symbol("onDragMove");
  var onDragStop4 = Symbol("onDragStop");
  var scroll = Symbol("scroll");
  var defaultOptions7 = {
    speed: 6,
    sensitivity: 50,
    scrollableElements: []
  };
  var Scrollable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions7), this.getOptions());
      this.currentMousePosition = null;
      this.scrollAnimationFrame = null;
      this.scrollableElement = null;
      this.findScrollableElementFrame = null;
      this[onDragStart4] = this[onDragStart4].bind(this);
      this[onDragMove3] = this[onDragMove3].bind(this);
      this[onDragStop4] = this[onDragStop4].bind(this);
      this[scroll] = this[scroll].bind(this);
    }
    attach() {
      this.draggable.on("drag:start", this[onDragStart4]).on("drag:move", this[onDragMove3]).on("drag:stop", this[onDragStop4]);
    }
    detach() {
      this.draggable.off("drag:start", this[onDragStart4]).off("drag:move", this[onDragMove3]).off("drag:stop", this[onDragStop4]);
    }
    getOptions() {
      return this.draggable.options.scrollable || {};
    }
    getScrollableElement(target) {
      if (this.hasDefinedScrollableElements()) {
        return closest(target, this.options.scrollableElements) || document.documentElement;
      } else {
        return closestScrollableElement(target);
      }
    }
    hasDefinedScrollableElements() {
      return Boolean(this.options.scrollableElements.length !== 0);
    }
    [onDragStart4](dragEvent) {
      this.findScrollableElementFrame = requestAnimationFrame(() => {
        this.scrollableElement = this.getScrollableElement(dragEvent.source);
      });
    }
    [onDragMove3](dragEvent) {
      this.findScrollableElementFrame = requestAnimationFrame(() => {
        this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);
      });
      if (!this.scrollableElement) {
        return;
      }
      const sensorEvent = dragEvent.sensorEvent;
      const scrollOffset = {
        x: 0,
        y: 0
      };
      if ("ontouchstart" in window) {
        scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
      }
      this.currentMousePosition = {
        clientX: sensorEvent.clientX - scrollOffset.x,
        clientY: sensorEvent.clientY - scrollOffset.y
      };
      this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
    }
    [onDragStop4]() {
      cancelAnimationFrame(this.scrollAnimationFrame);
      cancelAnimationFrame(this.findScrollableElementFrame);
      this.scrollableElement = null;
      this.scrollAnimationFrame = null;
      this.findScrollableElementFrame = null;
      this.currentMousePosition = null;
    }
    [scroll]() {
      if (!this.scrollableElement || !this.currentMousePosition) {
        return;
      }
      cancelAnimationFrame(this.scrollAnimationFrame);
      const {
        speed,
        sensitivity
      } = this.options;
      const rect = this.scrollableElement.getBoundingClientRect();
      const bottomCutOff = rect.bottom > window.innerHeight;
      const topCutOff = rect.top < 0;
      const cutOff = topCutOff || bottomCutOff;
      const documentScrollingElement = getDocumentScrollingElement();
      const scrollableElement = this.scrollableElement;
      const clientX = this.currentMousePosition.clientX;
      const clientY = this.currentMousePosition.clientY;
      if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {
        const {
          offsetHeight,
          offsetWidth
        } = scrollableElement;
        if (rect.top + offsetHeight - clientY < sensitivity) {
          scrollableElement.scrollTop += speed;
        } else if (clientY - rect.top < sensitivity) {
          scrollableElement.scrollTop -= speed;
        }
        if (rect.left + offsetWidth - clientX < sensitivity) {
          scrollableElement.scrollLeft += speed;
        } else if (clientX - rect.left < sensitivity) {
          scrollableElement.scrollLeft -= speed;
        }
      } else {
        const {
          innerHeight,
          innerWidth
        } = window;
        if (clientY < sensitivity) {
          documentScrollingElement.scrollTop -= speed;
        } else if (innerHeight - clientY < sensitivity) {
          documentScrollingElement.scrollTop += speed;
        }
        if (clientX < sensitivity) {
          documentScrollingElement.scrollLeft -= speed;
        } else if (innerWidth - clientX < sensitivity) {
          documentScrollingElement.scrollLeft += speed;
        }
      }
      this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
    }
  };
  function hasOverflow(element) {
    const overflowRegex = /(auto|scroll)/;
    const computedStyles = getComputedStyle(element, null);
    const overflow = computedStyles.getPropertyValue("overflow") + computedStyles.getPropertyValue("overflow-y") + computedStyles.getPropertyValue("overflow-x");
    return overflowRegex.test(overflow);
  }
  function isStaticallyPositioned(element) {
    const position = getComputedStyle(element).getPropertyValue("position");
    return position === "static";
  }
  function closestScrollableElement(element) {
    if (!element) {
      return getDocumentScrollingElement();
    }
    const position = getComputedStyle(element).getPropertyValue("position");
    const excludeStaticParents = position === "absolute";
    const scrollableElement = closest(element, (parent) => {
      if (excludeStaticParents && isStaticallyPositioned(parent)) {
        return false;
      }
      return hasOverflow(parent);
    });
    if (position === "fixed" || !scrollableElement) {
      return getDocumentScrollingElement();
    } else {
      return scrollableElement;
    }
  }
  function getDocumentScrollingElement() {
    return document.scrollingElement || document.documentElement;
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Emitter/Emitter.mjs
  var Emitter = class {
    constructor() {
      this.callbacks = {};
    }
    on(type, ...callbacks) {
      if (!this.callbacks[type]) {
        this.callbacks[type] = [];
      }
      this.callbacks[type].push(...callbacks);
      return this;
    }
    off(type, callback) {
      if (!this.callbacks[type]) {
        return null;
      }
      const copy = this.callbacks[type].slice(0);
      for (let i = 0; i < copy.length; i++) {
        if (callback === copy[i]) {
          this.callbacks[type].splice(i, 1);
        }
      }
      return this;
    }
    trigger(event) {
      if (!this.callbacks[event.type]) {
        return null;
      }
      const callbacks = [...this.callbacks[event.type]];
      const caughtErrors = [];
      for (let i = callbacks.length - 1; i >= 0; i--) {
        const callback = callbacks[i];
        try {
          callback(event);
        } catch (error) {
          caughtErrors.push(error);
        }
      }
      if (caughtErrors.length) {
        console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);
      }
      return this;
    }
  };

  // node_modules/@shopify/draggable/build/esm/Draggable/DraggableEvent/DraggableEvent.mjs
  var DraggableEvent = class extends AbstractEvent {
    get draggable() {
      return this.data.draggable;
    }
  };
  DraggableEvent.type = "draggable";
  var DraggableInitializedEvent = class extends DraggableEvent {
  };
  DraggableInitializedEvent.type = "draggable:initialize";
  var DraggableDestroyEvent = class extends DraggableEvent {
  };
  DraggableDestroyEvent.type = "draggable:destroy";

  // node_modules/@shopify/draggable/build/esm/Draggable/Draggable.mjs
  var onDragStart5 = Symbol("onDragStart");
  var onDragMove4 = Symbol("onDragMove");
  var onDragStop5 = Symbol("onDragStop");
  var onDragPressure = Symbol("onDragPressure");
  var dragStop = Symbol("dragStop");
  var defaultAnnouncements = {
    "drag:start": (event) => `Picked up ${event.source.textContent.trim() || event.source.id || "draggable element"}`,
    "drag:stop": (event) => `Released ${event.source.textContent.trim() || event.source.id || "draggable element"}`
  };
  var defaultClasses = {
    "container:dragging": "draggable-container--is-dragging",
    "source:dragging": "draggable-source--is-dragging",
    "source:placed": "draggable-source--placed",
    "container:placed": "draggable-container--placed",
    "body:dragging": "draggable--is-dragging",
    "draggable:over": "draggable--over",
    "container:over": "draggable-container--over",
    "source:original": "draggable--original",
    mirror: "draggable-mirror"
  };
  var defaultOptions8 = {
    draggable: ".draggable-source",
    handle: null,
    delay: {},
    distance: 0,
    placedTimeout: 800,
    plugins: [],
    sensors: [],
    exclude: {
      plugins: [],
      sensors: []
    }
  };
  var Draggable = class {
    constructor(containers = [document.body], options = {}) {
      if (containers instanceof NodeList || containers instanceof Array) {
        this.containers = [...containers];
      } else if (containers instanceof HTMLElement) {
        this.containers = [containers];
      } else {
        throw new Error("Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`");
      }
      this.options = __spreadProps(__spreadValues(__spreadValues({}, defaultOptions8), options), {
        classes: __spreadValues(__spreadValues({}, defaultClasses), options.classes || {}),
        announcements: __spreadValues(__spreadValues({}, defaultAnnouncements), options.announcements || {}),
        exclude: {
          plugins: options.exclude && options.exclude.plugins || [],
          sensors: options.exclude && options.exclude.sensors || []
        }
      });
      this.emitter = new Emitter();
      this.dragging = false;
      this.plugins = [];
      this.sensors = [];
      this[onDragStart5] = this[onDragStart5].bind(this);
      this[onDragMove4] = this[onDragMove4].bind(this);
      this[onDragStop5] = this[onDragStop5].bind(this);
      this[onDragPressure] = this[onDragPressure].bind(this);
      this[dragStop] = this[dragStop].bind(this);
      document.addEventListener("drag:start", this[onDragStart5], true);
      document.addEventListener("drag:move", this[onDragMove4], true);
      document.addEventListener("drag:stop", this[onDragStop5], true);
      document.addEventListener("drag:pressure", this[onDragPressure], true);
      const defaultPlugins = Object.values(Draggable.Plugins).filter((Plugin) => !this.options.exclude.plugins.includes(Plugin));
      const defaultSensors = Object.values(Draggable.Sensors).filter((sensor) => !this.options.exclude.sensors.includes(sensor));
      this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);
      this.addSensor(...[...defaultSensors, ...this.options.sensors]);
      const draggableInitializedEvent = new DraggableInitializedEvent({
        draggable: this
      });
      this.on("mirror:created", ({
        mirror
      }) => this.mirror = mirror);
      this.on("mirror:destroy", () => this.mirror = null);
      this.trigger(draggableInitializedEvent);
    }
    destroy() {
      document.removeEventListener("drag:start", this[onDragStart5], true);
      document.removeEventListener("drag:move", this[onDragMove4], true);
      document.removeEventListener("drag:stop", this[onDragStop5], true);
      document.removeEventListener("drag:pressure", this[onDragPressure], true);
      const draggableDestroyEvent = new DraggableDestroyEvent({
        draggable: this
      });
      this.trigger(draggableDestroyEvent);
      this.removePlugin(...this.plugins.map((plugin) => plugin.constructor));
      this.removeSensor(...this.sensors.map((sensor) => sensor.constructor));
    }
    addPlugin(...plugins) {
      const activePlugins = plugins.map((Plugin) => new Plugin(this));
      activePlugins.forEach((plugin) => plugin.attach());
      this.plugins = [...this.plugins, ...activePlugins];
      return this;
    }
    removePlugin(...plugins) {
      const removedPlugins = this.plugins.filter((plugin) => plugins.includes(plugin.constructor));
      removedPlugins.forEach((plugin) => plugin.detach());
      this.plugins = this.plugins.filter((plugin) => !plugins.includes(plugin.constructor));
      return this;
    }
    addSensor(...sensors) {
      const activeSensors = sensors.map((Sensor2) => new Sensor2(this.containers, this.options));
      activeSensors.forEach((sensor) => sensor.attach());
      this.sensors = [...this.sensors, ...activeSensors];
      return this;
    }
    removeSensor(...sensors) {
      const removedSensors = this.sensors.filter((sensor) => sensors.includes(sensor.constructor));
      removedSensors.forEach((sensor) => sensor.detach());
      this.sensors = this.sensors.filter((sensor) => !sensors.includes(sensor.constructor));
      return this;
    }
    addContainer(...containers) {
      this.containers = [...this.containers, ...containers];
      this.sensors.forEach((sensor) => sensor.addContainer(...containers));
      return this;
    }
    removeContainer(...containers) {
      this.containers = this.containers.filter((container) => !containers.includes(container));
      this.sensors.forEach((sensor) => sensor.removeContainer(...containers));
      return this;
    }
    on(type, ...callbacks) {
      this.emitter.on(type, ...callbacks);
      return this;
    }
    off(type, callback) {
      this.emitter.off(type, callback);
      return this;
    }
    trigger(event) {
      this.emitter.trigger(event);
      return this;
    }
    getClassNameFor(name) {
      return this.getClassNamesFor(name)[0];
    }
    getClassNamesFor(name) {
      const classNames = this.options.classes[name];
      if (classNames instanceof Array) {
        return classNames;
      } else if (typeof classNames === "string" || classNames instanceof String) {
        return [classNames];
      } else {
        return [];
      }
    }
    isDragging() {
      return Boolean(this.dragging);
    }
    getDraggableElements() {
      return this.containers.reduce((current, container) => {
        return [...current, ...this.getDraggableElementsForContainer(container)];
      }, []);
    }
    getDraggableElementsForContainer(container) {
      const allDraggableElements = container.querySelectorAll(this.options.draggable);
      return [...allDraggableElements].filter((childElement) => {
        return childElement !== this.originalSource && childElement !== this.mirror;
      });
    }
    cancel() {
      this[dragStop]();
    }
    [onDragStart5](event) {
      const sensorEvent = getSensorEvent(event);
      const {
        target,
        container,
        originalSource
      } = sensorEvent;
      if (!this.containers.includes(container)) {
        return;
      }
      if (this.options.handle && target && !closest(target, this.options.handle)) {
        sensorEvent.cancel();
        return;
      }
      this.originalSource = originalSource;
      this.sourceContainer = container;
      if (this.lastPlacedSource && this.lastPlacedContainer) {
        clearTimeout(this.placedTimeoutID);
        this.lastPlacedSource.classList.remove(...this.getClassNamesFor("source:placed"));
        this.lastPlacedContainer.classList.remove(...this.getClassNamesFor("container:placed"));
      }
      this.source = this.originalSource.cloneNode(true);
      this.originalSource.parentNode.insertBefore(this.source, this.originalSource);
      this.originalSource.style.display = "none";
      const dragStartEvent = new DragStartEvent({
        source: this.source,
        originalSource: this.originalSource,
        sourceContainer: container,
        sensorEvent
      });
      this.trigger(dragStartEvent);
      this.dragging = !dragStartEvent.canceled();
      if (dragStartEvent.canceled()) {
        this.source.remove();
        this.originalSource.style.display = null;
        return;
      }
      this.originalSource.classList.add(...this.getClassNamesFor("source:original"));
      this.source.classList.add(...this.getClassNamesFor("source:dragging"));
      this.sourceContainer.classList.add(...this.getClassNamesFor("container:dragging"));
      document.body.classList.add(...this.getClassNamesFor("body:dragging"));
      applyUserSelect(document.body, "none");
      requestAnimationFrame(() => {
        const oldSensorEvent = getSensorEvent(event);
        const newSensorEvent = oldSensorEvent.clone({
          target: this.source
        });
        this[onDragMove4](__spreadProps(__spreadValues({}, event), {
          detail: newSensorEvent
        }));
      });
    }
    [onDragMove4](event) {
      if (!this.dragging) {
        return;
      }
      const sensorEvent = getSensorEvent(event);
      const {
        container
      } = sensorEvent;
      let target = sensorEvent.target;
      const dragMoveEvent = new DragMoveEvent({
        source: this.source,
        originalSource: this.originalSource,
        sourceContainer: container,
        sensorEvent
      });
      this.trigger(dragMoveEvent);
      if (dragMoveEvent.canceled()) {
        sensorEvent.cancel();
      }
      target = closest(target, this.options.draggable);
      const withinCorrectContainer = closest(sensorEvent.target, this.containers);
      const overContainer = sensorEvent.overContainer || withinCorrectContainer;
      const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;
      const isLeavingDraggable = this.currentOver && target !== this.currentOver;
      const isOverContainer = overContainer && this.currentOverContainer !== overContainer;
      const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;
      if (isLeavingDraggable) {
        const dragOutEvent = new DragOutEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          over: this.currentOver,
          overContainer: this.currentOverContainer
        });
        this.currentOver.classList.remove(...this.getClassNamesFor("draggable:over"));
        this.currentOver = null;
        this.trigger(dragOutEvent);
      }
      if (isLeavingContainer) {
        const dragOutContainerEvent = new DragOutContainerEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          overContainer: this.currentOverContainer
        });
        this.currentOverContainer.classList.remove(...this.getClassNamesFor("container:over"));
        this.currentOverContainer = null;
        this.trigger(dragOutContainerEvent);
      }
      if (isOverContainer) {
        overContainer.classList.add(...this.getClassNamesFor("container:over"));
        const dragOverContainerEvent = new DragOverContainerEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          overContainer
        });
        this.currentOverContainer = overContainer;
        this.trigger(dragOverContainerEvent);
      }
      if (isOverDraggable) {
        target.classList.add(...this.getClassNamesFor("draggable:over"));
        const dragOverEvent = new DragOverEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          overContainer,
          over: target
        });
        this.currentOver = target;
        this.trigger(dragOverEvent);
      }
    }
    [dragStop](event) {
      if (!this.dragging) {
        return;
      }
      this.dragging = false;
      const dragStopEvent = new DragStopEvent({
        source: this.source,
        originalSource: this.originalSource,
        sensorEvent: event ? event.sensorEvent : null,
        sourceContainer: this.sourceContainer
      });
      this.trigger(dragStopEvent);
      if (!dragStopEvent.canceled())
        this.source.parentNode.insertBefore(this.originalSource, this.source);
      this.source.remove();
      this.originalSource.style.display = "";
      this.source.classList.remove(...this.getClassNamesFor("source:dragging"));
      this.originalSource.classList.remove(...this.getClassNamesFor("source:original"));
      this.originalSource.classList.add(...this.getClassNamesFor("source:placed"));
      this.sourceContainer.classList.add(...this.getClassNamesFor("container:placed"));
      this.sourceContainer.classList.remove(...this.getClassNamesFor("container:dragging"));
      document.body.classList.remove(...this.getClassNamesFor("body:dragging"));
      applyUserSelect(document.body, "");
      if (this.currentOver) {
        this.currentOver.classList.remove(...this.getClassNamesFor("draggable:over"));
      }
      if (this.currentOverContainer) {
        this.currentOverContainer.classList.remove(...this.getClassNamesFor("container:over"));
      }
      this.lastPlacedSource = this.originalSource;
      this.lastPlacedContainer = this.sourceContainer;
      this.placedTimeoutID = setTimeout(() => {
        if (this.lastPlacedSource) {
          this.lastPlacedSource.classList.remove(...this.getClassNamesFor("source:placed"));
        }
        if (this.lastPlacedContainer) {
          this.lastPlacedContainer.classList.remove(...this.getClassNamesFor("container:placed"));
        }
        this.lastPlacedSource = null;
        this.lastPlacedContainer = null;
      }, this.options.placedTimeout);
      const dragStoppedEvent = new DragStoppedEvent({
        source: this.source,
        originalSource: this.originalSource,
        sensorEvent: event ? event.sensorEvent : null,
        sourceContainer: this.sourceContainer
      });
      this.trigger(dragStoppedEvent);
      this.source = null;
      this.originalSource = null;
      this.currentOverContainer = null;
      this.currentOver = null;
      this.sourceContainer = null;
    }
    [onDragStop5](event) {
      this[dragStop](event);
    }
    [onDragPressure](event) {
      if (!this.dragging) {
        return;
      }
      const sensorEvent = getSensorEvent(event);
      const source = this.source || closest(sensorEvent.originalEvent.target, this.options.draggable);
      const dragPressureEvent = new DragPressureEvent({
        sensorEvent,
        source,
        pressure: sensorEvent.pressure
      });
      this.trigger(dragPressureEvent);
    }
  };
  Draggable.Plugins = {
    Announcement,
    Focusable,
    Mirror,
    Scrollable
  };
  Draggable.Sensors = {
    MouseSensor,
    TouchSensor
  };
  function getSensorEvent(event) {
    return event.detail;
  }
  function applyUserSelect(element, value) {
    element.style.webkitUserSelect = value;
    element.style.mozUserSelect = value;
    element.style.msUserSelect = value;
    element.style.oUserSelect = value;
    element.style.userSelect = value;
  }

  // node_modules/@shopify/draggable/build/esm/Droppable/DroppableEvent/DroppableEvent.mjs
  var DroppableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  DroppableEvent.type = "droppable";
  var DroppableStartEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableStartEvent.type = "droppable:start";
  DroppableStartEvent.cancelable = true;
  var DroppableDroppedEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableDroppedEvent.type = "droppable:dropped";
  DroppableDroppedEvent.cancelable = true;
  var DroppableReturnedEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableReturnedEvent.type = "droppable:returned";
  DroppableReturnedEvent.cancelable = true;
  var DroppableStopEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableStopEvent.type = "droppable:stop";
  DroppableStopEvent.cancelable = true;

  // node_modules/@shopify/draggable/build/esm/Droppable/Droppable.mjs
  var onDragStart6 = Symbol("onDragStart");
  var onDragMove5 = Symbol("onDragMove");
  var onDragStop6 = Symbol("onDragStop");
  var dropInDropzone = Symbol("dropInDropZone");
  var returnToOriginalDropzone = Symbol("returnToOriginalDropzone");
  var closestDropzone = Symbol("closestDropzone");
  var getDropzones = Symbol("getDropzones");

  // node_modules/@shopify/draggable/build/esm/Swappable/SwappableEvent/SwappableEvent.mjs
  var SwappableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  SwappableEvent.type = "swappable";
  var SwappableStartEvent = class extends SwappableEvent {
  };
  SwappableStartEvent.type = "swappable:start";
  SwappableStartEvent.cancelable = true;
  var SwappableSwapEvent = class extends SwappableEvent {
    get over() {
      return this.data.over;
    }
    get overContainer() {
      return this.data.overContainer;
    }
  };
  SwappableSwapEvent.type = "swappable:swap";
  SwappableSwapEvent.cancelable = true;
  var SwappableSwappedEvent = class extends SwappableEvent {
    get swappedElement() {
      return this.data.swappedElement;
    }
  };
  SwappableSwappedEvent.type = "swappable:swapped";
  var SwappableStopEvent = class extends SwappableEvent {
  };
  SwappableStopEvent.type = "swappable:stop";

  // node_modules/@shopify/draggable/build/esm/Swappable/Swappable.mjs
  var onDragStart7 = Symbol("onDragStart");
  var onDragOver3 = Symbol("onDragOver");
  var onDragStop7 = Symbol("onDragStop");

  // node_modules/@shopify/draggable/build/esm/Sortable/SortableEvent/SortableEvent.mjs
  var SortableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  SortableEvent.type = "sortable";
  var SortableStartEvent = class extends SortableEvent {
    get startIndex() {
      return this.data.startIndex;
    }
    get startContainer() {
      return this.data.startContainer;
    }
  };
  SortableStartEvent.type = "sortable:start";
  SortableStartEvent.cancelable = true;
  var SortableSortEvent = class extends SortableEvent {
    get currentIndex() {
      return this.data.currentIndex;
    }
    get over() {
      return this.data.over;
    }
    get overContainer() {
      return this.data.dragEvent.overContainer;
    }
  };
  SortableSortEvent.type = "sortable:sort";
  SortableSortEvent.cancelable = true;
  var SortableSortedEvent = class extends SortableEvent {
    get oldIndex() {
      return this.data.oldIndex;
    }
    get newIndex() {
      return this.data.newIndex;
    }
    get oldContainer() {
      return this.data.oldContainer;
    }
    get newContainer() {
      return this.data.newContainer;
    }
  };
  SortableSortedEvent.type = "sortable:sorted";
  var SortableStopEvent = class extends SortableEvent {
    get oldIndex() {
      return this.data.oldIndex;
    }
    get newIndex() {
      return this.data.newIndex;
    }
    get oldContainer() {
      return this.data.oldContainer;
    }
    get newContainer() {
      return this.data.newContainer;
    }
  };
  SortableStopEvent.type = "sortable:stop";

  // node_modules/@shopify/draggable/build/esm/Sortable/Sortable.mjs
  var onDragStart8 = Symbol("onDragStart");
  var onDragOverContainer = Symbol("onDragOverContainer");
  var onDragOver4 = Symbol("onDragOver");
  var onDragStop8 = Symbol("onDragStop");
  function onSortableSortedDefaultAnnouncement({
    dragEvent
  }) {
    const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || "sortable element";
    if (dragEvent.over) {
      const overText = dragEvent.over.textContent.trim() || dragEvent.over.id || "sortable element";
      const isFollowing = dragEvent.source.compareDocumentPosition(dragEvent.over) & Node.DOCUMENT_POSITION_FOLLOWING;
      if (isFollowing) {
        return `Placed ${sourceText} after ${overText}`;
      } else {
        return `Placed ${sourceText} before ${overText}`;
      }
    } else {
      return `Placed ${sourceText} into a different container`;
    }
  }
  var defaultAnnouncements2 = {
    "sortable:sorted": onSortableSortedDefaultAnnouncement
  };
  var Sortable = class extends Draggable {
    constructor(containers = [], options = {}) {
      super(containers, __spreadProps(__spreadValues({}, options), {
        announcements: __spreadValues(__spreadValues({}, defaultAnnouncements2), options.announcements || {})
      }));
      this.startIndex = null;
      this.startContainer = null;
      this[onDragStart8] = this[onDragStart8].bind(this);
      this[onDragOverContainer] = this[onDragOverContainer].bind(this);
      this[onDragOver4] = this[onDragOver4].bind(this);
      this[onDragStop8] = this[onDragStop8].bind(this);
      this.on("drag:start", this[onDragStart8]).on("drag:over:container", this[onDragOverContainer]).on("drag:over", this[onDragOver4]).on("drag:stop", this[onDragStop8]);
    }
    destroy() {
      super.destroy();
      this.off("drag:start", this[onDragStart8]).off("drag:over:container", this[onDragOverContainer]).off("drag:over", this[onDragOver4]).off("drag:stop", this[onDragStop8]);
    }
    index(element) {
      return this.getSortableElementsForContainer(element.parentNode).indexOf(element);
    }
    getSortableElementsForContainer(container) {
      const allSortableElements = container.querySelectorAll(this.options.draggable);
      return [...allSortableElements].filter((childElement) => {
        return childElement !== this.originalSource && childElement !== this.mirror && childElement.parentNode === container;
      });
    }
    [onDragStart8](event) {
      this.startContainer = event.source.parentNode;
      this.startIndex = this.index(event.source);
      const sortableStartEvent = new SortableStartEvent({
        dragEvent: event,
        startIndex: this.startIndex,
        startContainer: this.startContainer
      });
      this.trigger(sortableStartEvent);
      if (sortableStartEvent.canceled()) {
        event.cancel();
      }
    }
    [onDragOverContainer](event) {
      if (event.canceled()) {
        return;
      }
      const {
        source,
        over,
        overContainer
      } = event;
      const oldIndex = this.index(source);
      const sortableSortEvent = new SortableSortEvent({
        dragEvent: event,
        currentIndex: oldIndex,
        source,
        over
      });
      this.trigger(sortableSortEvent);
      if (sortableSortEvent.canceled()) {
        return;
      }
      const children = this.getSortableElementsForContainer(overContainer);
      const moves = move({
        source,
        over,
        overContainer,
        children
      });
      if (!moves) {
        return;
      }
      const {
        oldContainer,
        newContainer
      } = moves;
      const newIndex = this.index(event.source);
      const sortableSortedEvent = new SortableSortedEvent({
        dragEvent: event,
        oldIndex,
        newIndex,
        oldContainer,
        newContainer
      });
      this.trigger(sortableSortedEvent);
    }
    [onDragOver4](event) {
      if (event.over === event.originalSource || event.over === event.source) {
        return;
      }
      const {
        source,
        over,
        overContainer
      } = event;
      const oldIndex = this.index(source);
      const sortableSortEvent = new SortableSortEvent({
        dragEvent: event,
        currentIndex: oldIndex,
        source,
        over
      });
      this.trigger(sortableSortEvent);
      if (sortableSortEvent.canceled()) {
        return;
      }
      const children = this.getDraggableElementsForContainer(overContainer);
      const moves = move({
        source,
        over,
        overContainer,
        children
      });
      if (!moves) {
        return;
      }
      const {
        oldContainer,
        newContainer
      } = moves;
      const newIndex = this.index(source);
      const sortableSortedEvent = new SortableSortedEvent({
        dragEvent: event,
        oldIndex,
        newIndex,
        oldContainer,
        newContainer
      });
      this.trigger(sortableSortedEvent);
    }
    [onDragStop8](event) {
      const sortableStopEvent = new SortableStopEvent({
        dragEvent: event,
        oldIndex: this.startIndex,
        newIndex: this.index(event.source),
        oldContainer: this.startContainer,
        newContainer: event.source.parentNode
      });
      this.trigger(sortableStopEvent);
      this.startIndex = null;
      this.startContainer = null;
    }
  };
  function index(element) {
    return Array.prototype.indexOf.call(element.parentNode.children, element);
  }
  function move({
    source,
    over,
    overContainer,
    children
  }) {
    const emptyOverContainer = !children.length;
    const differentContainer = source.parentNode !== overContainer;
    const sameContainer = over && source.parentNode === over.parentNode;
    if (emptyOverContainer) {
      return moveInsideEmptyContainer(source, overContainer);
    } else if (sameContainer) {
      return moveWithinContainer(source, over);
    } else if (differentContainer) {
      return moveOutsideContainer(source, over, overContainer);
    } else {
      return null;
    }
  }
  function moveInsideEmptyContainer(source, overContainer) {
    const oldContainer = source.parentNode;
    overContainer.appendChild(source);
    return {
      oldContainer,
      newContainer: overContainer
    };
  }
  function moveWithinContainer(source, over) {
    const oldIndex = index(source);
    const newIndex = index(over);
    if (oldIndex < newIndex) {
      source.parentNode.insertBefore(source, over.nextElementSibling);
    } else {
      source.parentNode.insertBefore(source, over);
    }
    return {
      oldContainer: source.parentNode,
      newContainer: source.parentNode
    };
  }
  function moveOutsideContainer(source, over, overContainer) {
    const oldContainer = source.parentNode;
    if (over) {
      over.parentNode.insertBefore(source, over);
    } else {
      overContainer.appendChild(source);
    }
    return {
      oldContainer,
      newContainer: source.parentNode
    };
  }

  // js/app.js
  var import_topbar = __toModule(require_topbar());

  // js/chart.js
  var import_chart = __toModule(require_chart());
  var import_chartjs_plugin_datalabels = __toModule(require_chartjs_plugin_datalabels());

  // node_modules/chart.js-plugin-labels-dv/dist/chartjs-plugin-labels.min.js
  !function(t) {
    typeof define == "function" && define.amd ? define(t) : t();
  }(function() {
    "use strict";
    !function() {
      if (typeof Chart == "undefined")
        return void console.error("Cannot find Chart object.");
      const t = Chart.helpers;
      typeof Object.assign != "function" && (Object.assign = function(t2) {
        if (!t2)
          throw new TypeError("Cannot convert undefined or null to object");
        const e2 = Object(t2);
        for (let t3 = 1; t3 < arguments.length; t3++) {
          const o2 = arguments[t3];
          if (o2)
            for (const t4 in o2)
              Object.prototype.hasOwnProperty.call(o2, t4) && (e2[t4] = o2[t4]);
        }
        return e2;
      });
      const e = {};
      function o() {
        this.renderToDataset = this.renderToDataset.bind(this);
      }
      function n(t2) {
        const e2 = t2._context.chart.config._config;
        return !(!e2.options || !e2.options.plugins) && !!e2.options.plugins.labels;
      }
      ["pie", "doughnut", "polarArea", "bar"].forEach(function(t2) {
        e[t2] = true;
      }), o.prototype.setup = function(t2, e2) {
        this.chart = t2, this.ctx = t2.ctx, this.args = {}, this.barTotal = {};
        const o2 = t2.config.options;
        this.options = Object.assign({ position: "default", precision: 0, fontSize: o2.font ? o2.font.size : 12, fontColor: o2.color || "#333333", fontStyle: o2.font ? o2.font.style : "normal", fontFamily: o2.font ? o2.font.family : "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", shadowOffsetX: 3, shadowOffsetY: 3, shadowColor: "rgba(0,0,0,0.3)", shadowBlur: 6, images: [], outsidePadding: 2, textMargin: 2, overlap: true }, e2), t2.config.type === "bar" && (this.options.position = "default", this.options.arc = false, this.options.overlap = true);
      }, o.prototype.render = function() {
        this.labelBounds = [], this.chart.data.datasets.forEach(this.renderToDataset);
      }, o.prototype.renderToDataset = function(t2, e2) {
        this.totalPercentage = 0, this.total = null;
        const o2 = this.args[e2];
        o2.meta.data.forEach(function(e3, n2) {
          this.renderToElement(t2, o2, e3, n2);
        }.bind(this));
      }, o.prototype.renderToElement = function(e2, o2, n2, i) {
        if (!this.shouldRenderToElement(o2.meta, n2))
          return;
        this.percentage = null;
        const s = this.getLabel(e2, n2, i);
        if (!s)
          return;
        const r = this.ctx;
        r.save(), r.font = t.fontString(this.options.fontSize, this.options.fontStyle, this.options.fontFamily);
        const a = this.getRenderInfo(n2, s);
        this.drawable(n2, s, a) ? (r.beginPath(), r.fillStyle = this.getFontColor(e2, n2, i), this.renderLabel(s, a), r.restore()) : r.restore();
      }, o.prototype.renderLabel = function(t2, e2) {
        return this.options.arc ? this.renderArcLabel(t2, e2) : this.renderBaseLabel(t2, e2);
      }, o.prototype.renderBaseLabel = function(t2, e2) {
        const o2 = this.ctx;
        if (typeof t2 == "object")
          o2.drawImage(t2, e2.x - t2.width / 2, e2.y - t2.height / 2, t2.width, t2.height);
        else {
          o2.save(), o2.textBaseline = "top", o2.textAlign = "center", this.options.textShadow && (o2.shadowOffsetX = this.options.shadowOffsetX, o2.shadowOffsetY = this.options.shadowOffsetY, o2.shadowColor = this.options.shadowColor, o2.shadowBlur = this.options.shadowBlur);
          const n2 = t2.split("\n");
          for (let t3 = 0; t3 < n2.length; t3++) {
            const i = e2.y - this.options.fontSize / 2 * n2.length + this.options.fontSize * t3;
            o2.fillText(n2[t3], e2.x, i);
          }
          o2.restore();
        }
      }, o.prototype.renderArcLabel = function(t2, e2) {
        const o2 = this.ctx, n2 = e2.radius, i = e2.view;
        if (o2.save(), o2.translate(i.x, i.y), typeof t2 == "string") {
          o2.rotate(e2.startAngle), o2.textBaseline = "middle", o2.textAlign = "left";
          const i2 = t2.split("\n");
          let s = 0;
          const r = [];
          let a, h = 0;
          this.options.position === "border" && (h = (i2.length - 1) * this.options.fontSize / 2);
          for (let t3 = 0; t3 < i2.length; ++t3)
            a = o2.measureText(i2[t3]), a.width > s && (s = a.width), r.push(a.width);
          for (let t3 = 0; t3 < i2.length; ++t3) {
            const e3 = i2[t3], l = (i2.length - 1 - t3) * -this.options.fontSize + h;
            o2.save();
            const c = (s - r[t3]) / 2;
            o2.rotate(c / n2);
            for (let t4 = 0; t4 < e3.length; t4++) {
              const i3 = e3.charAt(t4);
              a = o2.measureText(i3), o2.save(), o2.translate(0, -1 * n2), o2.fillText(i3, 0, l), o2.restore(), o2.rotate(a.width / n2);
            }
            o2.restore();
          }
        } else
          o2.rotate((i.startAngle + Math.PI / 2 + e2.endAngle) / 2), o2.translate(0, -1 * n2), this.renderLabel(t2, { x: 0, y: 0 });
        o2.restore();
      }, o.prototype.shouldRenderToElement = function(t2, e2) {
        return !t2.hidden && (this.options.showZero || this.chart.config.type === "polarArea" ? e2.outerRadius !== 0 : e2.circumference !== 0);
      }, o.prototype.getLabel = function(t2, e2, o2) {
        let n2;
        if (typeof this.options.render == "function")
          n2 = this.options.render({ label: this.chart.config.data.labels[o2], value: t2.data[o2], percentage: this.getPercentage(t2, e2, o2), dataset: t2, index: o2 });
        else
          switch (this.options.render) {
            case "value":
              n2 = t2.data[o2];
              break;
            case "label":
              n2 = this.chart.config.data.labels[o2];
              break;
            case "image":
              n2 = this.options.images[o2] ? this.loadImage(this.options.images[o2]) : "";
              break;
            default:
              n2 = this.getPercentage(t2, e2, o2) + "%";
          }
        return typeof n2 == "object" ? n2 = this.loadImage(n2) : n2 && (n2 = n2.toString()), n2;
      }, o.prototype.getFontColor = function(t2, e2, o2) {
        let n2 = this.options.fontColor;
        return typeof n2 == "function" ? n2 = n2({ label: this.chart.config.data.labels[o2], value: t2.data[o2], percentage: this.getPercentage(t2, e2, o2), backgroundColor: t2.backgroundColor[o2], dataset: t2, index: o2 }) : typeof n2 != "string" && (n2 = n2[o2] || this.chart.config.options.color), n2;
      }, o.prototype.getPercentage = function(t2, e2, o2) {
        if (this.percentage)
          return this.percentage;
        let n2;
        if (this.chart.config.type === "polarArea" || this.chart.config.type === "doughnut" || this.chart.config.type === "pie") {
          if (!this.total) {
            this.total = 0;
            for (let e3 = 0; e3 < t2.data.length; ++e3)
              this.total += t2.data[e3];
          }
          n2 = t2.data[o2] / this.total * 100;
        } else if (this.chart.config.type === "bar") {
          if (!this.barTotal[o2]) {
            this.barTotal[o2] = 0;
            for (let t3 = 0; t3 < this.chart.data.datasets.length; ++t3)
              this.barTotal[o2] += this.chart.data.datasets[t3].data[o2];
          }
          n2 = t2.data[o2] / this.barTotal[o2] * 100;
        } else
          n2 = e2.circumference / this.chart.config.options.circumference * 100;
        return n2 = parseFloat(n2.toFixed(this.options.precision)), this.options.showActualPercentages || (this.chart.config.type === "bar" && (this.totalPercentage = this.barTotalPercentage[o2] || 0), this.totalPercentage += n2, this.totalPercentage > 100 && (n2 -= this.totalPercentage - 100, n2 = parseFloat(n2.toFixed(this.options.precision))), this.chart.config.type === "bar" && (this.barTotalPercentage[o2] = this.totalPercentage)), this.percentage = n2, n2;
      }, o.prototype.getRenderInfo = function(t2, e2) {
        return this.chart.config.type === "bar" ? this.getBarRenderInfo(t2, e2) : this.options.arc ? this.getArcRenderInfo(t2, e2) : this.getBaseRenderInfo(t2, e2);
      }, o.prototype.getBaseRenderInfo = function(t2, e2) {
        if (this.options.position === "outside" || this.options.position === "border") {
          let o2, n2 = {};
          const i = t2, s = i.startAngle + (i.endAngle - i.startAngle) / 2, r = i.outerRadius / 2;
          if (this.options.position === "border" ? o2 = (i.outerRadius - r) / 2 + r : this.options.position === "outside" && (o2 = i.outerRadius - r + r + this.options.textMargin), n2 = { x: i.x + Math.cos(s) * o2, y: i.y + Math.sin(s) * o2 }, this.options.position === "outside") {
            const t3 = this.options.textMargin + this.measureLabel(e2).width / 2;
            n2.x += n2.x < i.x ? -t3 : t3;
          }
          return n2;
        }
        return t2.tooltipPosition();
      }, o.prototype.getArcRenderInfo = function(t2, e2) {
        let o2;
        const n2 = t2;
        o2 = this.options.position === "outside" ? n2.outerRadius + this.options.fontSize + this.options.textMargin : this.options.position === "border" ? (n2.outerRadius / 2 + n2.outerRadius) / 2 : (n2.innerRadius + n2.outerRadius) / 2;
        let i = n2.startAngle, s = n2.endAngle;
        const r = s - i;
        i += Math.PI / 2, s += Math.PI / 2;
        return i += (s - (this.measureLabel(e2).width / o2 + i)) / 2, { radius: o2, startAngle: i, endAngle: s, totalAngle: r, view: n2 };
      }, o.prototype.getBarRenderInfo = function(t2, e2) {
        const o2 = t2.tooltipPosition();
        return o2.y -= this.measureLabel(e2).height / 2 + this.options.textMargin, o2;
      }, o.prototype.drawable = function(t2, e2, o2) {
        if (this.options.overlap)
          return true;
        if (this.options.arc)
          return o2.endAngle - o2.startAngle <= o2.totalAngle;
        {
          const n2 = this.measureLabel(e2), i = o2.x - n2.width / 2, s = o2.x + n2.width / 2, r = o2.y - n2.height / 2, a = o2.y + n2.height / 2;
          return this.options.position === "outside" ? this.outsideInRange(i, s, r, a) : t2.inRange(i, r) && t2.inRange(i, a) && t2.inRange(s, r) && t2.inRange(s, a);
        }
      }, o.prototype.outsideInRange = function(t2, e2, o2, n2) {
        const i = this.labelBounds;
        for (let s = 0; s < i.length; ++s) {
          const r = i[s];
          let a = [[t2, o2], [t2, n2], [e2, o2], [e2, n2]];
          for (let t3 = 0; t3 < a.length; ++t3) {
            const e3 = a[t3][0], o3 = a[t3][1];
            if (e3 >= r.left && e3 <= r.right && o3 >= r.top && o3 <= r.bottom)
              return false;
          }
          a = [[r.left, r.top], [r.left, r.bottom], [r.right, r.top], [r.right, r.bottom]];
          for (let i2 = 0; i2 < a.length; ++i2) {
            const s2 = a[i2][0], r2 = a[i2][1];
            if (s2 >= t2 && s2 <= e2 && r2 >= o2 && r2 <= n2)
              return false;
          }
        }
        return i.push({ left: t2, right: e2, top: o2, bottom: n2 }), true;
      }, o.prototype.measureLabel = function(t2) {
        if (typeof t2 == "object")
          return { width: t2.width, height: t2.height };
        {
          let e2 = 0;
          const o2 = t2.split("\n");
          for (let t3 = 0; t3 < o2.length; ++t3) {
            const n2 = this.ctx.measureText(o2[t3]);
            n2.width > e2 && (e2 = n2.width);
          }
          return { width: e2, height: this.options.fontSize * o2.length };
        }
      }, o.prototype.loadImage = function(t2) {
        const e2 = new Image();
        return e2.src = t2.src, e2.width = t2.width, e2.height = t2.height, e2;
      }, Chart.register({ id: "labels", beforeDatasetsUpdate: function(t2, i, s) {
        if (!e[t2.config.type] || !n(s))
          return;
        s.length || (s = [s]);
        const r = s.length;
        t2._labels && r === t2._labels.length || (t2._labels = s.map(function() {
          return new o();
        }));
        let a = false, h = 0;
        for (let e2 = 0; e2 < r; ++e2) {
          const o2 = t2._labels[e2];
          if (o2.setup(t2, s[e2]), o2.options.position === "outside") {
            a = true;
            const t3 = 1.5 * o2.options.fontSize + o2.options.outsidePadding;
            t3 > h && (h = t3);
          }
        }
        a && (t2.chartArea.top += h, t2.chartArea.bottom -= h);
      }, afterDatasetUpdate: function(t2, o2, i) {
        var _a;
        e[t2.config.type] && n(i) && ((_a = t2._labels) == null ? void 0 : _a.forEach(function(t3) {
          t3.args[o2.index] = o2;
        }));
      }, beforeDraw: function(t2, o2, i) {
        var _a;
        e[t2.config.type] && n(i) && ((_a = t2._labels) == null ? void 0 : _a.forEach(function(t3) {
          t3.barTotalPercentage = {};
        }));
      }, afterDatasetsDraw: function(t2, o2, i) {
        var _a;
        e[t2.config.type] && n(i) && ((_a = t2._labels) == null ? void 0 : _a.forEach(function(t3) {
          t3.render();
        }));
      } });
    }();
  });

  // js/chart.js
  var colors = ["#36a2eb"];
  var month = [
    "Janvier",
    "F\xE9vrier",
    "Mars",
    "Avril",
    "Mai",
    "Juin",
    "Juillet",
    "Ao\xFBt",
    "Septembre",
    "Octobre",
    "Novembre",
    "D\xE9cembre"
  ];
  var SURVEY = [
    "Qualit\xE9 du travail effectu\xE9",
    "Gain de temps du client",
    "Respect du d\xE9lai de livraison",
    "Qualit\xE9 de la communication"
  ];
  var HorizontalBarChart = class {
    constructor(ctx, labels, values) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              axis: "x",
              label: "Liste des t\xE2ches",
              data: values,
              fill: false,
              borderColor: colors,
              backgroundColor: colors,
              borderWidth: 1,
              color: "#fff"
            }
          ]
        },
        options: {
          indexAxis: "x",
          responsive: true,
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "Liste des t\xE2ches par contributeurs"
            },
            datalabels: {
              color: "#fff"
            }
          }
        }
      });
    }
  };
  var StackedBarChart = class {
    constructor(ctx, todo_tasks, blocked_tasks, tasks_in_progress, tasks_in_control, achieved_tasks) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels: month,
          datasets: [
            {
              label: "T\xE2ches \xE0 faire",
              data: todo_tasks,
              backgroundColor: "#36a2eb"
            },
            {
              label: "T\xE2ches en blocage",
              data: blocked_tasks,
              backgroundColor: "#e67e22"
            },
            {
              label: "T\xE2ches en cours",
              data: tasks_in_progress,
              backgroundColor: "#27ae60"
            },
            {
              label: "T\xE2ches en contr\xF4le",
              data: tasks_in_control,
              backgroundColor: "#8e44ad"
            },
            {
              label: "T\xE2ches achev\xE9es",
              data: achieved_tasks,
              backgroundColor: "#ff6384"
            }
          ]
        },
        options: {
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "T\xE2ches par mois"
            }
          },
          responsive: true
        }
      });
    }
  };
  var SurveyChart = class {
    constructor(ctx, values) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels: SURVEY,
          datasets: [
            {
              axis: "x",
              label: "Pourcentage de satisfaction en %",
              data: values,
              fill: false,
              borderColor: colors,
              backgroundColor: colors,
              borderWidth: 2,
              color: "#fff"
            }
          ]
        },
        options: {
          maintainAspectRatio: false,
          indexAxis: "y",
          responsive: true,
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "Taux de satisfaction du client"
            },
            datalabels: {
              color: "#fff"
            }
          }
        }
      });
    }
  };

  // js/app.js
  var import_chart3 = __toModule(require_chart());
  document.addEventListener("DOMContentLoaded", function() {
    const tableBody = document.getElementById("record-table-body");
    const addRowLink = document.getElementById("addRowIcon");
    const dataContainer = document.getElementById("data-container");
    if (tableBody && addRowLink && dataContainer) {
      const userId = dataContainer.dataset.userId;
      const date = dataContainer.dataset.today;
      const username = dataContainer.dataset.username;
      const projects = JSON.parse(dataContainer.dataset.projects);
      addRowLink.addEventListener("click", function() {
        lineNotSaved = haveLineNotSaved(tableBody);
        console.log(lineNotSaved);
        if (!lineNotSaved) {
          addRow(tableBody, import_tom_select3.default, userId, date, username, projects);
        } else {
          var addRowIcon = document.querySelector("#addRowIcon i");
          console.log(addRowIcon);
          addRowLink.classList.add("non-cliquable");
          addRowIcon.style.cursor = "not-allowed";
        }
      });
    }
  });
  require_();
  require_2();
  var Hooks2 = {};
  Hooks2.tableHover = {
    mounted() {
      const table = this.el;
      table.querySelectorAll("tbody tr").forEach((row) => {
        let currentColor = "";
        row.addEventListener("mouseover", () => {
          currentColor = row.style.backgroundColor;
          row.style.backgroundColor = "#60b0f0";
        });
        row.addEventListener("mouseout", () => {
          row.style.backgroundColor = currentColor;
        });
      });
    }
  };
  Hooks2.CustomSampleSelect = {
    mounted() {
      console.log("CustomSampleSelect hook initialized");
      var selectElement = document.getElementById("mySelect");
      if (selectElement) {
        console.log("Element found:", selectElement);
        if (!selectElement.tomselect) {
          selectElement.tomselect = new import_tom_select3.default(selectElement, {
            create: false,
            sortField: {
              field: "text",
              direction: "asc"
            }
          });
          console.log("TomSelect options:", selectElement.tomselect.options);
        }
      } else {
        console.error("Select element not found");
      }
    },
    updated() {
      console.log("CustomSampleSelect hook updated");
      var selectElement = document.getElementById("mySelect");
      if (selectElement && selectElement.tomselect) {
        console.log("Element found:", selectElement);
        selectElement.tomselect.clearOptions();
        var selectOptions = selectElement.querySelectorAll("option");
        selectOptions.forEach(function(option) {
          selectElement.tomselect.addOption({
            value: option.value,
            text: option.textContent
          });
        });
        selectElement.tomselect.refreshOptions();
      } else {
        console.error("Select element or TomSelect instance not found");
      }
    }
  };
  Hooks2.CsvExportHook = {
    mounted() {
      this.handleExportClick = this.handleExportClick.bind(this);
      this.el.addEventListener("click", this.handleExportClick);
    },
    destroyed() {
      this.el.removeEventListener("click", this.handleExportClick);
    },
    handleExportClick(event) {
      let csvData = this.el.getAttribute("data-csv");
      console.log("avant :", csvData);
      csvData = csvData.replace(/\\r\\n/g, "\n");
      console.log("apres :", csvData);
      const blob = new Blob([csvData], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      link.href = window.URL.createObjectURL(blob);
      link.download = "exemple.csv";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };
  Hooks2.HorizontalBarChart = {
    mounted() {
      const { labels_tasks_by_contributors, values_tasks_by_contributors } = JSON.parse(this.el.dataset.chartData);
      this.chart = new HorizontalBarChart(this.el, labels_tasks_by_contributors, values_tasks_by_contributors);
    }
  };
  Hooks2.StackedBarChart = {
    mounted() {
      const {
        values_tasks_todo_by_month,
        values_blocking_tasks_by_month,
        values_tasks_in_progress_by_month,
        values_tasks_in_control_by_month,
        values_tasks_achieved_by_month
      } = JSON.parse(this.el.dataset.chartData);
      this.chart = new StackedBarChart(this.el, values_tasks_todo_by_month, values_blocking_tasks_by_month, values_tasks_in_progress_by_month, values_tasks_in_control_by_month, values_tasks_achieved_by_month);
    }
  };
  Hooks2.SurveyChart = {
    mounted() {
      console.log("is mounted");
      const { values } = JSON.parse(this.el.dataset.chartData);
      this.mychart = new SurveyChart(this.el, values);
    }
  };
  Hooks2.Board = {
    mounted() {
      this.initDraggables();
    },
    updated() {
      this.sortableCard.destroy();
      this.sortableStage.destroy();
      this.initDraggables();
    },
    initDraggables() {
      this.sortableCard = new Sortable(document.querySelectorAll(".stage__cards"), {
        draggable: ".card",
        mirror: {
          constrainDimensions: true
        },
        swapAnimation: {
          duration: 200,
          easingFunction: "ease-in-out"
        },
        plugins: [Plugins_exports.SwapAnimation]
      });
      this.sortableCard.on("sortable:stop", (event) => {
        const source = event.data.dragEvent.data.source;
        const cardId = parseInt(source.getAttribute("data-card-id"));
        const newStageId = parseInt(event.data.newContainer.getAttribute("data-stage-id"));
        const newIndex = parseInt(event.data.newIndex);
        const cardPayload = {
          card: {
            id: cardId,
            stage_id: newStageId,
            position: newIndex
          }
        };
        this.pushEvent("update_card", cardPayload);
      });
      this.sortableStage = new Sortable(document.querySelectorAll(".board"), {
        draggable: ".stage",
        handle: ".draggable-handle",
        mirror: {
          constrainDimensions: true,
          yAxis: false
        }
      });
      this.sortableStage.on("sortable:stop", (event) => {
        const source = event.data.dragEvent.data.source;
        const stageId = parseInt(source.getAttribute("data-stage-id"));
        const newIndex = parseInt(event.data.newIndex);
        const stagePayload = {
          stage: {
            id: stageId,
            position: newIndex
          }
        };
        this.pushEvent("update_stage", stagePayload);
      });
    }
  };
  Hooks2.AnimateAlert = {
    mounted() {
      this.handleEvent("AnimateAlert", ({}) => this.reset_opacity());
    },
    updated() {
    },
    reset_opacity() {
      var alert2 = document.querySelector("#alert_anim");
      alert2.style.opacity = 1;
      window.setTimeout(function() {
        alert2.style.display = "none";
      }, 2e3);
    },
    anim_onload() {
      var alerts2 = document.querySelectorAll(".alert");
      alerts2.forEach((item) => {
        item.style.opacity = 1;
        item.onload = window.setTimeout(function() {
          item.style.opacity = 0;
        }, 2e3);
      });
      for (var i = 0; i < alerts2.length; i++) {
        alerts2[i].style.opacity = 1;
        alerts2[i].onload = window.setTimeout(function() {
          alerts2[i].style.opacity = 0;
        }, 2e3);
      }
    }
  };
  Hooks2.blurHook = {
    mounted() {
      this.handleEvent("blurBody", ({ param1, param2 }) => this.blurBody());
    },
    blurBody() {
      var body = document.body;
      var request_form = document.querySelector("#the_request_form");
      body.style.opacity = 0.5;
      request_form.style.opacity = 1;
    }
  };
  Hooks2.MessageBody = {
    mounted() {
      var messageBody = document.querySelector("#messageBody");
      this.handleEvent("updateScroll", ({}) => messageBody.scrollTop = messageBody.scrollHeight - messageBody.clientHeight);
    }
  };
  Hooks2.urlProcess = {
    mounted() {
      let main = document.querySelector("#main");
      var url = window.location.href;
      url.includes("/logs") ? main.classList.remove("container") : main.classList.add("container");
    }
  };
  Hooks2.SpinTest = {
    mounted() {
      this.handleEvent("SpinTest", ({}) => this.spin_icon());
      this.handleEvent("SpinComment", ({}) => this.spin_comment_icon());
    },
    spin_icon() {
      var spins = document.querySelectorAll(".notif__load");
      spins.forEach((item) => {
        item.classList.add("new__rotate__icon");
      });
      spins.forEach((item) => {
        window.setTimeout(function() {
          item.classList.remove("new__rotate__icon");
        }, 500);
      });
    },
    spin_comment_icon() {
      var clock_comment = document.getElementById("clock_comment");
      clock_comment.classList.add("rotate__icon");
      window.setTimeout(function() {
        clock_comment.classList.remove("rotate__icon");
      }, 500);
    }
  };
  var navToggle = document.querySelector(".nav__toggle");
  var navWrapper = document.querySelector(".nav__wrapper");
  navToggle.addEventListener("click", function() {
    if (navWrapper.classList.contains("active")) {
      this.setAttribute("aria-expanded", "false");
      this.setAttribute("aria-label", "menu");
      navWrapper.classList.remove("active");
    } else {
      navWrapper.classList.add("active");
      this.setAttribute("aria-label", "close menu");
      this.setAttribute("aria-expanded", "true");
    }
  });
  var copyrightIcon = document.getElementById("copyright__icon");
  if (copyrightIcon) {
    copyrightIcon.innerHTML = "copyright PHIDIA / Project monitoring -2024";
  }
  var menuBtn = document.querySelector(".menu-btn");
  var menuOpen = false;
  menuBtn.addEventListener("click", () => {
    if (!menuOpen) {
      menuBtn.classList.add("open");
      menuOpen = true;
    } else {
      menuBtn.classList.remove("open");
      menuOpen = false;
    }
  });
  var alerts = document.querySelectorAll(".alert");
  alerts.forEach((item) => {
    item.style.opacity = 1;
    item.onload = window.setTimeout(function() {
      item.style.opacity = 0;
    }, 2e3);
  });
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var liveSocket = new LiveSocket("/live", Socket, {
    params: { _csrf_token: csrfToken },
    hooks: Hooks2
  });
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (info) => import_topbar.default.show());
  window.addEventListener("phx:page-loading-stop", (info) => import_topbar.default.hide());
  liveSocket.connect();
  window.liveSocket = liveSocket;
})();
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
/*!
 * chartjs-plugin-datalabels v2.2.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2022 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */
/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */
/*! sifter.js | https://github.com/orchidjs/sifter.js | Apache License (v2) */
/**
   * [chartjs-plugin-labels]{@link https://github.com/DavideViolante/chartjs-plugin-labels}
   *
   * @version 3.1.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com], Davide Violante, Yousef Altaher
   * @copyright Chen, Yi-Cyuan 2017-2018
   * @license MIT
   */
/**
 * @license MIT
 * topbar 1.0.0, 2021-01-06
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9jb250cmliL21pY3JvZXZlbnQudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9jb250cmliL21pY3JvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMvZGlzdC9lc20vcmVnZXguanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvdW5pY29kZS12YXJpYW50cy9kaXN0L2VzbS9zdHJpbmdzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMvZGlzdC9lc20vaW5kZXguanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvc2lmdGVyL2Rpc3QvZXNtL3V0aWxzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3NpZnRlci9kaXN0L2VzbS9zaWZ0ZXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvc2lmdGVyL2xpYi91dGlscy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3ZhbmlsbGEudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9jb250cmliL2hpZ2hsaWdodC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL2NvbnN0YW50cy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL2RlZmF1bHRzLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvdXRpbHMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9nZXRTZXR0aW5ncy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3RvbS1zZWxlY3QudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL2NoYW5nZV9saXN0ZW5lci9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL2NoZWNrYm94X29wdGlvbnMvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9jbGVhcl9idXR0b24vcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9kcmFnX2Ryb3AvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9kcm9wZG93bl9oZWFkZXIvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9jYXJldF9wb3NpdGlvbi9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL2Ryb3Bkb3duX2lucHV0L3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3BsdWdpbnMvaW5wdXRfYXV0b2dyb3cvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9ub19iYWNrc3BhY2VfZGVsZXRlL3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3BsdWdpbnMvbm9fYWN0aXZlX2l0ZW1zL3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3BsdWdpbnMvb3B0Z3JvdXBfY29sdW1ucy9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL3JlbW92ZV9idXR0b24vcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9yZXN0b3JlX29uX2JhY2tzcGFjZS9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL3ZpcnR1YWxfc2Nyb2xsL3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3RvbS1zZWxlY3QuY29tcGxldGUudHMiLCAiLi4vLi4vLi4vYXNzZXRzL3ZlbmRvci90b3BiYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NoYXJ0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvaGVscGVycy9oZWxwZXJzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9kaXN0L2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL2pzL2FwcC5qcyIsICIuLi8uLi8uLi9hc3NldHMvanMvdG9tX3NlbGVjdF9zYWlzaWVfcGFnZS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfaHRtbC9wcml2L3N0YXRpYy9waG9lbml4X2h0bWwuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3V0aWxzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9jb25zdGFudHMuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3B1c2guanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3RpbWVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9jaGFubmVsLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9hamF4LmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9sb25ncG9sbC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvcHJlc2VuY2UuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3NlcmlhbGl6ZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3NvY2tldC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9jb25zdGFudHMuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZW50cnlfdXBsb2FkZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdXRpbHMuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvYnJvd3Nlci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9kb20uanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdXBsb2FkX2VudHJ5LmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2xpdmVfdXBsb2FkZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvaG9va3MuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3Bvc3RfbW9ycGhfcmVzdG9yZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvbm9kZV9tb2R1bGVzL21vcnBoZG9tL2Rpc3QvbW9ycGhkb20tZXNtLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbV9wYXRjaC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9yZW5kZXJlZC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy92aWV3X2hvb2suanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvanMuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdmlldy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3NvY2tldC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vc2hhcmVkL0Fic3RyYWN0RXZlbnQvQWJzdHJhY3RFdmVudC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9TZW5zb3JzL1NlbnNvci9TZW5zb3IubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9zaGFyZWQvdXRpbHMvY2xvc2VzdC9jbG9zZXN0Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vc2hhcmVkL3V0aWxzL2Rpc3RhbmNlL2Rpc3RhbmNlLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1NlbnNvcnMvU2Vuc29yRXZlbnQvU2Vuc29yRXZlbnQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvU2Vuc29ycy9Nb3VzZVNlbnNvci9Nb3VzZVNlbnNvci5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL3NoYXJlZC91dGlscy90b3VjaENvb3Jkcy90b3VjaENvb3Jkcy5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9TZW5zb3JzL1RvdWNoU2Vuc29yL1RvdWNoU2Vuc29yLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1NlbnNvcnMvRHJhZ1NlbnNvci9EcmFnU2Vuc29yLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1NlbnNvcnMvRm9yY2VUb3VjaFNlbnNvci9Gb3JjZVRvdWNoU2Vuc29yLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vUGx1Z2lucy9pbmRleC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL1BsdWdpbnMvQ29sbGlkYWJsZS9Db2xsaWRhYmxlRXZlbnQvQ29sbGlkYWJsZUV2ZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vUGx1Z2lucy9Db2xsaWRhYmxlL0NvbGxpZGFibGUubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vc2hhcmVkL3V0aWxzL2RlY29yYXRvcnMvQXV0b0JpbmQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9zaGFyZWQvdXRpbHMvcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZS9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL0RyYWdFdmVudC9EcmFnRXZlbnQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9QbHVnaW5zL1Jlc2l6ZU1pcnJvci9SZXNpemVNaXJyb3IubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9QbHVnaW5zL1NuYXBwYWJsZS9TbmFwcGFibGVFdmVudC9TbmFwcGFibGVFdmVudC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL1BsdWdpbnMvU25hcHBhYmxlL1NuYXBwYWJsZS5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL1BsdWdpbnMvU3dhcEFuaW1hdGlvbi9Td2FwQW5pbWF0aW9uLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vUGx1Z2lucy9Tb3J0QW5pbWF0aW9uL1NvcnRBbmltYXRpb24ubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvUGx1Z2lucy9Bbm5vdW5jZW1lbnQvQW5ub3VuY2VtZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1BsdWdpbnMvRm9jdXNhYmxlL0ZvY3VzYWJsZS5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9QbHVnaW5zL01pcnJvci9NaXJyb3JFdmVudC9NaXJyb3JFdmVudC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9QbHVnaW5zL01pcnJvci9NaXJyb3IubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvUGx1Z2lucy9TY3JvbGxhYmxlL1Njcm9sbGFibGUubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvRW1pdHRlci9FbWl0dGVyLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL0RyYWdnYWJsZUV2ZW50L0RyYWdnYWJsZUV2ZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL0RyYWdnYWJsZS5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0Ryb3BwYWJsZS9Ecm9wcGFibGVFdmVudC9Ecm9wcGFibGVFdmVudC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0Ryb3BwYWJsZS9Ecm9wcGFibGUubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9Td2FwcGFibGUvU3dhcHBhYmxlRXZlbnQvU3dhcHBhYmxlRXZlbnQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9Td2FwcGFibGUvU3dhcHBhYmxlLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vU29ydGFibGUvU29ydGFibGVFdmVudC9Tb3J0YWJsZUV2ZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vU29ydGFibGUvU29ydGFibGUubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9qcy9jaGFydC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzLXBsdWdpbi1sYWJlbHMtZHYvZGlzdC9jaGFydGpzLXBsdWdpbi1sYWJlbHMubWluLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIE1pY3JvRXZlbnQgLSB0byBtYWtlIGFueSBqcyBvYmplY3QgYW4gZXZlbnQgZW1pdHRlclxuICpcbiAqIC0gcHVyZSBqYXZhc2NyaXB0IC0gc2VydmVyIGNvbXBhdGlibGUsIGJyb3dzZXIgY29tcGF0aWJsZVxuICogLSBkb250IHJlbHkgb24gdGhlIGJyb3dzZXIgZG9tc1xuICogLSBzdXBlciBzaW1wbGUgLSB5b3UgZ2V0IGl0IGltbWVkaWF0bHksIG5vIG1pc3RlcnksIG5vIG1hZ2ljIGludm9sdmVkXG4gKlxuICogQGF1dGhvciBKZXJvbWUgRXRpZW5uZSAoaHR0cHM6Ly9naXRodWIuY29tL2plcm9tZWV0aWVubmUpXG4gKi9cblxudHlwZSBUQ2FsbGJhY2sgPSAoLi4uYXJnczphbnkpID0+IGFueTtcblxuLyoqXG4gKiBFeGVjdXRlIGNhbGxiYWNrIGZvciBlYWNoIGV2ZW50IGluIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGV2ZW50IG5hbWVzXG4gKlxuICovXG5mdW5jdGlvbiBmb3JFdmVudHMoZXZlbnRzOnN0cmluZyxjYWxsYmFjazooZXZlbnQ6c3RyaW5nKT0+YW55KXtcblx0ZXZlbnRzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoZXZlbnQpID0+e1xuXHRcdGNhbGxiYWNrKGV2ZW50KTtcblx0fSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pY3JvRXZlbnR7XG5cblx0cHVibGljIF9ldmVudHM6IHtba2V5OnN0cmluZ106VENhbGxiYWNrW119O1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5fZXZlbnRzID0ge307XG5cdH1cblxuXHRvbihldmVudHM6c3RyaW5nLCBmY3Q6VENhbGxiYWNrKXtcblx0XHRmb3JFdmVudHMoZXZlbnRzLChldmVudCkgPT4ge1xuXHRcdFx0Y29uc3QgZXZlbnRfYXJyYXkgPSB0aGlzLl9ldmVudHNbZXZlbnRdIHx8IFtdO1xuXHRcdFx0ZXZlbnRfYXJyYXkucHVzaChmY3QpO1xuXHRcdFx0dGhpcy5fZXZlbnRzW2V2ZW50XSA9IGV2ZW50X2FycmF5O1xuXHRcdH0pO1xuXHR9XG5cblx0b2ZmKGV2ZW50czpzdHJpbmcsIGZjdDpUQ2FsbGJhY2spe1xuXHRcdHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiggbiA9PT0gMCApe1xuXHRcdFx0dGhpcy5fZXZlbnRzID0ge307XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yRXZlbnRzKGV2ZW50cywoZXZlbnQpID0+IHtcblxuXHRcdFx0aWYgKG4gPT09IDEpe1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW2V2ZW50XTtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGV2ZW50X2FycmF5ID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcblx0XHRcdGlmKCBldmVudF9hcnJheSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRldmVudF9hcnJheS5zcGxpY2UoZXZlbnRfYXJyYXkuaW5kZXhPZihmY3QpLCAxKTtcblx0XHRcdHRoaXMuX2V2ZW50c1tldmVudF0gPSBldmVudF9hcnJheTtcblx0XHR9KTtcblx0fVxuXG5cdHRyaWdnZXIoZXZlbnRzOnN0cmluZywgLi4uYXJnczphbnkpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGZvckV2ZW50cyhldmVudHMsKGV2ZW50KSA9PiB7XG5cdFx0XHRjb25zdCBldmVudF9hcnJheSA9IHNlbGYuX2V2ZW50c1tldmVudF07XG5cdFx0XHRpZiggZXZlbnRfYXJyYXkgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblx0XHRcdGV2ZW50X2FycmF5LmZvckVhY2goZmN0ID0+IHtcblx0XHRcdFx0ZmN0LmFwcGx5KHNlbGYsIGFyZ3MgKTtcblx0XHRcdH0pO1xuXG5cdFx0fSk7XG5cdH1cbn07XG4iLCAiLyoqXG4gKiBtaWNyb3BsdWdpbi5qc1xuICogQ29weXJpZ2h0IChjKSAyMDEzIEJyaWFuIFJlYXZpcyAmIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAYXV0aG9yIEJyaWFuIFJlYXZpcyA8YnJpYW5AdGhpcmRyb3V0ZS5jb20+XG4gKi9cblxudHlwZSBUU2V0dGluZ3MgPSB7XG5cdFtrZXk6c3RyaW5nXTphbnlcbn1cblxudHlwZSBUUGx1Z2lucyA9IHtcblx0bmFtZXM6IHN0cmluZ1tdLFxuXHRzZXR0aW5nczogVFNldHRpbmdzLFxuXHRyZXF1ZXN0ZWQ6IHtba2V5OnN0cmluZ106Ym9vbGVhbn0sXG5cdGxvYWRlZDoge1trZXk6c3RyaW5nXTphbnl9XG59O1xuXG5leHBvcnQgdHlwZSBUUGx1Z2luSXRlbSA9IHtuYW1lOnN0cmluZyxvcHRpb25zOnt9fTtcbmV4cG9ydCB0eXBlIFRQbHVnaW5IYXNoID0ge1trZXk6c3RyaW5nXTp7fX07XG5cblxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1pY3JvUGx1Z2luKEludGVyZmFjZTogYW55ICl7XG5cblx0SW50ZXJmYWNlLnBsdWdpbnMgPSB7fTtcblxuXHRyZXR1cm4gY2xhc3MgZXh0ZW5kcyBJbnRlcmZhY2V7XG5cblx0XHRwdWJsaWMgcGx1Z2luczpUUGx1Z2lucyA9IHtcblx0XHRcdG5hbWVzICAgICA6IFtdLFxuXHRcdFx0c2V0dGluZ3MgIDoge30sXG5cdFx0XHRyZXF1ZXN0ZWQgOiB7fSxcblx0XHRcdGxvYWRlZCAgICA6IHt9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVycyBhIHBsdWdpbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG5cdFx0ICovXG5cdFx0c3RhdGljIGRlZmluZShuYW1lOnN0cmluZywgZm46KHRoaXM6YW55LHNldHRpbmdzOlRTZXR0aW5ncyk9PmFueSl7XG5cdFx0XHRJbnRlcmZhY2UucGx1Z2luc1tuYW1lXSA9IHtcblx0XHRcdFx0J25hbWUnIDogbmFtZSxcblx0XHRcdFx0J2ZuJyAgIDogZm5cblx0XHRcdH07XG5cdFx0fVxuXG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplcyB0aGUgbGlzdGVkIHBsdWdpbnMgKHdpdGggb3B0aW9ucykuXG5cdFx0ICogQWNjZXB0YWJsZSBmb3JtYXRzOlxuXHRcdCAqXG5cdFx0ICogTGlzdCAod2l0aG91dCBvcHRpb25zKTpcblx0XHQgKiAgIFsnYScsICdiJywgJ2MnXVxuXHRcdCAqXG5cdFx0ICogTGlzdCAod2l0aCBvcHRpb25zKTpcblx0XHQgKiAgIFt7J25hbWUnOiAnYScsIG9wdGlvbnM6IHt9fSwgeyduYW1lJzogJ2InLCBvcHRpb25zOiB7fX1dXG5cdFx0ICpcblx0XHQgKiBIYXNoICh3aXRoIG9wdGlvbnMpOlxuXHRcdCAqICAgeydhJzogeyAuLi4gfSwgJ2InOiB7IC4uLiB9LCAnYyc6IHsgLi4uIH19XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2FycmF5fG9iamVjdH0gcGx1Z2luc1xuXHRcdCAqL1xuXHRcdGluaXRpYWxpemVQbHVnaW5zKHBsdWdpbnM6c3RyaW5nW118VFBsdWdpbkl0ZW1bXXxUUGx1Z2luSGFzaCkge1xuXHRcdFx0dmFyIGtleSwgbmFtZTtcblx0XHRcdGNvbnN0IHNlbGYgID0gdGhpcztcblx0XHRcdGNvbnN0IHF1ZXVlOnN0cmluZ1tdID0gW107XG5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHBsdWdpbnMpKSB7XG5cdFx0XHRcdHBsdWdpbnMuZm9yRWFjaCgocGx1Z2luOnN0cmluZ3xUUGx1Z2luSXRlbSk9Pntcblx0XHRcdFx0XHRpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2gocGx1Z2luKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5wbHVnaW5zLnNldHRpbmdzW3BsdWdpbi5uYW1lXSA9IHBsdWdpbi5vcHRpb25zO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaChwbHVnaW4ubmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAocGx1Z2lucykge1xuXHRcdFx0XHRmb3IgKGtleSBpbiBwbHVnaW5zKSB7XG5cdFx0XHRcdFx0aWYgKHBsdWdpbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0c2VsZi5wbHVnaW5zLnNldHRpbmdzW2tleV0gPSBwbHVnaW5zW2tleV07XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlKCBuYW1lID0gcXVldWUuc2hpZnQoKSApe1xuXHRcdFx0XHRzZWxmLnJlcXVpcmUobmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bG9hZFBsdWdpbihuYW1lOnN0cmluZykge1xuXHRcdFx0dmFyIHNlbGYgICAgPSB0aGlzO1xuXHRcdFx0dmFyIHBsdWdpbnMgPSBzZWxmLnBsdWdpbnM7XG5cdFx0XHR2YXIgcGx1Z2luICA9IEludGVyZmFjZS5wbHVnaW5zW25hbWVdO1xuXG5cdFx0XHRpZiAoIUludGVyZmFjZS5wbHVnaW5zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgXCInICsgIG5hbWUgKyAnXCIgcGx1Z2luJyk7XG5cdFx0XHR9XG5cblx0XHRcdHBsdWdpbnMucmVxdWVzdGVkW25hbWVdID0gdHJ1ZTtcblx0XHRcdHBsdWdpbnMubG9hZGVkW25hbWVdID0gcGx1Z2luLmZuLmFwcGx5KHNlbGYsIFtzZWxmLnBsdWdpbnMuc2V0dGluZ3NbbmFtZV0gfHwge31dKTtcblx0XHRcdHBsdWdpbnMubmFtZXMucHVzaChuYW1lKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplcyBhIHBsdWdpbi5cblx0XHQgKlxuXHRcdCAqL1xuXHRcdHJlcXVpcmUobmFtZTpzdHJpbmcpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBwbHVnaW5zID0gc2VsZi5wbHVnaW5zO1xuXG5cdFx0XHRpZiAoIXNlbGYucGx1Z2lucy5sb2FkZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0aWYgKHBsdWdpbnMucmVxdWVzdGVkW25hbWVdKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gaGFzIGNpcmN1bGFyIGRlcGVuZGVuY3kgKFwiJyArIG5hbWUgKyAnXCIpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5sb2FkUGx1Z2luKG5hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcGx1Z2lucy5sb2FkZWRbbmFtZV07XG5cdFx0fVxuXG5cdH07XG5cbn1cbiIsICIvKiEgQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMgfCBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyB8IEFwYWNoZSBMaWNlbnNlICh2MikgKi9cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiBzdHJpbmdzIHRvIGEgcmVndWxhciBleHByZXNzaW9uXG4gKlx0ZXggWydhYicsJ2EnXSA9PiAoPzphYnxhKVxuICogXHRleCBbJ2EnLCdiJ10gPT4gW2FiXVxuICogQHBhcmFtIHtzdHJpbmdbXX0gY2hhcnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgYXJyYXlUb1BhdHRlcm4gPSBjaGFycyA9PiB7XG4gIGNoYXJzID0gY2hhcnMuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIGlmIChjaGFycy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGNoYXJzWzBdIHx8ICcnO1xuICB9XG5cbiAgcmV0dXJuIG1heFZhbHVlTGVuZ3RoKGNoYXJzKSA9PSAxID8gJ1snICsgY2hhcnMuam9pbignJykgKyAnXScgOiAnKD86JyArIGNoYXJzLmpvaW4oJ3wnKSArICcpJztcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFycmF5XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuY29uc3Qgc2VxdWVuY2VQYXR0ZXJuID0gYXJyYXkgPT4ge1xuICBpZiAoIWhhc0R1cGxpY2F0ZXMoYXJyYXkpKSB7XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJycpO1xuICB9XG5cbiAgbGV0IHBhdHRlcm4gPSAnJztcbiAgbGV0IHByZXZfY2hhcl9jb3VudCA9IDA7XG5cbiAgY29uc3QgcHJldl9wYXR0ZXJuID0gKCkgPT4ge1xuICAgIGlmIChwcmV2X2NoYXJfY291bnQgPiAxKSB7XG4gICAgICBwYXR0ZXJuICs9ICd7JyArIHByZXZfY2hhcl9jb3VudCArICd9JztcbiAgICB9XG4gIH07XG5cbiAgYXJyYXkuZm9yRWFjaCgoY2hhciwgaSkgPT4ge1xuICAgIGlmIChjaGFyID09PSBhcnJheVtpIC0gMV0pIHtcbiAgICAgIHByZXZfY2hhcl9jb3VudCsrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByZXZfcGF0dGVybigpO1xuICAgIHBhdHRlcm4gKz0gY2hhcjtcbiAgICBwcmV2X2NoYXJfY291bnQgPSAxO1xuICB9KTtcbiAgcHJldl9wYXR0ZXJuKCk7XG4gIHJldHVybiBwYXR0ZXJuO1xufTtcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiBzdHJpbmdzIHRvIGEgcmVndWxhciBleHByZXNzaW9uXG4gKlx0ZXggWydhYicsJ2EnXSA9PiAoPzphYnxhKVxuICogXHRleCBbJ2EnLCdiJ10gPT4gW2FiXVxuICogQHBhcmFtIHtTZXQ8c3RyaW5nPn0gY2hhcnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5jb25zdCBzZXRUb1BhdHRlcm4gPSBjaGFycyA9PiB7XG4gIGxldCBhcnJheSA9IHRvQXJyYXkoY2hhcnMpO1xuICByZXR1cm4gYXJyYXlUb1BhdHRlcm4oYXJyYXkpO1xufTtcbi8qKlxuICpcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczNzY1OTgvaW4tamF2YXNjcmlwdC1ob3ctZG8taS1jaGVjay1pZi1hbi1hcnJheS1oYXMtZHVwbGljYXRlLXZhbHVlc1xuICogQHBhcmFtIHthbnlbXX0gYXJyYXlcbiAqL1xuXG5jb25zdCBoYXNEdXBsaWNhdGVzID0gYXJyYXkgPT4ge1xuICByZXR1cm4gbmV3IFNldChhcnJheSkuc2l6ZSAhPT0gYXJyYXkubGVuZ3RoO1xufTtcbi8qKlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjMwMDY2MDEvd2h5LWRvZXMtdS10aHJvdy1hbi1pbnZhbGlkLWVzY2FwZS1lcnJvclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmNvbnN0IGVzY2FwZV9yZWdleCA9IHN0ciA9PiB7XG4gIHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UoLyhbXFwkXFwoXFwpXFwqXFwrXFwuXFw/XFxbXFxdXFxeXFx7XFx8XFx9XFxcXF0pL2d1LCAnXFxcXCQxJyk7XG59O1xuLyoqXG4gKiBSZXR1cm4gdGhlIG1heCBsZW5ndGggb2YgYXJyYXkgdmFsdWVzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhcnJheVxuICpcbiAqL1xuXG5jb25zdCBtYXhWYWx1ZUxlbmd0aCA9IGFycmF5ID0+IHtcbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgobG9uZ2VzdCwgdmFsdWUpID0+IE1hdGgubWF4KGxvbmdlc3QsIHVuaWNvZGVMZW5ndGgodmFsdWUpKSwgMCk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cblxuY29uc3QgdW5pY29kZUxlbmd0aCA9IHN0ciA9PiB7XG4gIHJldHVybiB0b0FycmF5KHN0cikubGVuZ3RoO1xufTtcbi8qKlxuICogQHBhcmFtIHthbnl9IHBcbiAqIEByZXR1cm4ge2FueVtdfVxuICovXG5cbmNvbnN0IHRvQXJyYXkgPSBwID0+IEFycmF5LmZyb20ocCk7XG5cbmV4cG9ydCB7IGFycmF5VG9QYXR0ZXJuLCBlc2NhcGVfcmVnZXgsIGhhc0R1cGxpY2F0ZXMsIG1heFZhbHVlTGVuZ3RoLCBzZXF1ZW5jZVBhdHRlcm4sIHNldFRvUGF0dGVybiwgdG9BcnJheSwgdW5pY29kZUxlbmd0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnZXguanMubWFwXG4iLCAiLyohIEBvcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzIHwgaHR0cHM6Ly9naXRodWIuY29tL29yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMgfCBBcGFjaGUgTGljZW5zZSAodjIpICovXG4vKipcbiAqIEdldCBhbGwgcG9zc2libGUgY29tYmluYXRpb25zIG9mIHN1YnN0cmluZ3MgdGhhdCBhZGQgdXAgdG8gdGhlIGdpdmVuIHN0cmluZ1xuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAxNjk1ODcvZmluZC1hbGwtdGhlLWNvbWJpbmF0aW9uLW9mLXN1YnN0cmluZ3MtdGhhdC1hZGQtdXAtdG8tdGhlLWdpdmVuLXN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICovXG5jb25zdCBhbGxTdWJzdHJpbmdzID0gaW5wdXQgPT4ge1xuICBpZiAoaW5wdXQubGVuZ3RoID09PSAxKSByZXR1cm4gW1tpbnB1dF1dO1xuICAvKiogQHR5cGUge3N0cmluZ1tdW119ICovXG5cbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzdGFydCA9IGlucHV0LnN1YnN0cmluZygxKTtcbiAgY29uc3Qgc3ViYSA9IGFsbFN1YnN0cmluZ3Moc3RhcnQpO1xuICBzdWJhLmZvckVhY2goZnVuY3Rpb24gKHN1YnJlc3VsdCkge1xuICAgIGxldCB0bXAgPSBzdWJyZXN1bHQuc2xpY2UoMCk7XG4gICAgdG1wWzBdID0gaW5wdXQuY2hhckF0KDApICsgdG1wWzBdO1xuICAgIHJlc3VsdC5wdXNoKHRtcCk7XG4gICAgdG1wID0gc3VicmVzdWx0LnNsaWNlKDApO1xuICAgIHRtcC51bnNoaWZ0KGlucHV0LmNoYXJBdCgwKSk7XG4gICAgcmVzdWx0LnB1c2godG1wKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgeyBhbGxTdWJzdHJpbmdzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdzLmpzLm1hcFxuIiwgIi8qISBAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyB8IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzIHwgQXBhY2hlIExpY2Vuc2UgKHYyKSAqL1xuaW1wb3J0IHsgdG9BcnJheSwgc2V0VG9QYXR0ZXJuLCBlc2NhcGVfcmVnZXgsIGFycmF5VG9QYXR0ZXJuLCBzZXF1ZW5jZVBhdHRlcm4gfSBmcm9tICcuL3JlZ2V4LmpzJztcbmV4cG9ydCB7IGVzY2FwZV9yZWdleCB9IGZyb20gJy4vcmVnZXguanMnO1xuaW1wb3J0IHsgYWxsU3Vic3RyaW5ncyB9IGZyb20gJy4vc3RyaW5ncy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tba2V5OnN0cmluZ106c3RyaW5nfX0gVFVuaWNvZGVNYXBcbiAqIEB0eXBlZGVmIHt7W2tleTpzdHJpbmddOlNldDxzdHJpbmc+fX0gVFVuaWNvZGVTZXRzXG4gKiBAdHlwZWRlZiB7W1tudW1iZXIsbnVtYmVyXV19IFRDb2RlUG9pbnRzXG4gKiBAdHlwZWRlZiB7e2ZvbGRlZDpzdHJpbmcsY29tcG9zZWQ6c3RyaW5nLGNvZGVfcG9pbnQ6bnVtYmVyfX0gVENvZGVQb2ludE9ialxuICogQHR5cGVkZWYge3tzdGFydDpudW1iZXIsZW5kOm51bWJlcixsZW5ndGg6bnVtYmVyLHN1YnN0cjpzdHJpbmd9fSBUU2VxdWVuY2VQYXJ0XG4gKi9cbi8qKiBAdHlwZSB7VENvZGVQb2ludHN9ICovXG5cbmNvbnN0IGNvZGVfcG9pbnRzID0gW1swLCA2NTUzNV1dO1xuY29uc3QgYWNjZW50X3BhdCA9ICdbXFx1MDMwMC1cXHUwMzZGXFx1e2I3fVxcdXsyYmV9XFx1ezJiY31dJztcbi8qKiBAdHlwZSB7VFVuaWNvZGVNYXB9ICovXG5cbmxldCB1bmljb2RlX21hcDtcbi8qKiBAdHlwZSB7UmVnRXhwfSAqL1xuXG5sZXQgbXVsdGlfY2hhcl9yZWc7XG5jb25zdCBtYXhfY2hhcl9sZW5ndGggPSAzO1xuLyoqIEB0eXBlIHtUVW5pY29kZU1hcH0gKi9cblxuY29uc3QgbGF0aW5fY29udmVydCA9IHt9O1xuLyoqIEB0eXBlIHtUVW5pY29kZU1hcH0gKi9cblxuY29uc3QgbGF0aW5fY29uZGVuc2VkID0ge1xuICAnLyc6ICdcdTIwNDRcdTIyMTUnLFxuICAnMCc6ICdcdTA3QzAnLFxuICBcImFcIjogXCJcdTJDNjVcdTAyNTBcdTAyNTFcIixcbiAgXCJhYVwiOiBcIlx1QTczM1wiLFxuICBcImFlXCI6IFwiXHUwMEU2XHUwMUZEXHUwMUUzXCIsXG4gIFwiYW9cIjogXCJcdUE3MzVcIixcbiAgXCJhdVwiOiBcIlx1QTczN1wiLFxuICBcImF2XCI6IFwiXHVBNzM5XHVBNzNCXCIsXG4gIFwiYXlcIjogXCJcdUE3M0RcIixcbiAgXCJiXCI6IFwiXHUwMTgwXHUwMjUzXHUwMTgzXCIsXG4gIFwiY1wiOiBcIlx1QTczRlx1MDE4OFx1MDIzQ1x1MjE4NFwiLFxuICBcImRcIjogXCJcdTAxMTFcdTAyNTdcdTAyNTZcdTFEMDVcdTAxOENcdUFCQjdcdTA1MDFcdTAyNjZcIixcbiAgXCJlXCI6IFwiXHUwMjVCXHUwMUREXHUxRDA3XHUwMjQ3XCIsXG4gIFwiZlwiOiBcIlx1QTc3Q1x1MDE5MlwiLFxuICBcImdcIjogXCJcdTAxRTVcdTAyNjBcdUE3QTFcdTFENzlcdUE3N0ZcdTAyNjJcIixcbiAgXCJoXCI6IFwiXHUwMTI3XHUyQzY4XHUyQzc2XHUwMjY1XCIsXG4gIFwiaVwiOiBcIlx1MDI2OFx1MDEzMVwiLFxuICBcImpcIjogXCJcdTAyNDlcdTAyMzdcIixcbiAgXCJrXCI6IFwiXHUwMTk5XHUyQzZBXHVBNzQxXHVBNzQzXHVBNzQ1XHVBN0EzXCIsXG4gIFwibFwiOiBcIlx1MDE0Mlx1MDE5QVx1MDI2Qlx1MkM2MVx1QTc0OVx1QTc0N1x1QTc4MVx1MDI2RFwiLFxuICBcIm1cIjogXCJcdTAyNzFcdTAyNkZcdTAzRkJcIixcbiAgXCJuXCI6IFwiXHVBN0E1XHUwMTlFXHUwMjcyXHVBNzkxXHUxRDBFXHUwNDNCXHUwNTA5XCIsXG4gIFwib1wiOiBcIlx1MDBGOFx1MDFGRlx1MDI1NFx1MDI3NVx1QTc0Qlx1QTc0RFx1MUQxMVwiLFxuICBcIm9lXCI6IFwiXHUwMTUzXCIsXG4gIFwib2lcIjogXCJcdTAxQTNcIixcbiAgXCJvb1wiOiBcIlx1QTc0RlwiLFxuICBcIm91XCI6IFwiXHUwMjIzXCIsXG4gIFwicFwiOiBcIlx1MDFBNVx1MUQ3RFx1QTc1MVx1QTc1M1x1QTc1NVx1MDNDMVwiLFxuICBcInFcIjogXCJcdUE3NTdcdUE3NTlcdTAyNEJcIixcbiAgXCJyXCI6IFwiXHUwMjREXHUwMjdEXHVBNzVCXHVBN0E3XHVBNzgzXCIsXG4gIFwic1wiOiBcIlx1MDBERlx1MDIzRlx1QTdBOVx1QTc4NVx1MDI4MlwiLFxuICBcInRcIjogXCJcdTAxNjdcdTAxQURcdTAyODhcdTJDNjZcdUE3ODdcIixcbiAgXCJ0aFwiOiBcIlx1MDBGRVwiLFxuICBcInR6XCI6IFwiXHVBNzI5XCIsXG4gIFwidVwiOiBcIlx1MDI4OVwiLFxuICBcInZcIjogXCJcdTAyOEJcdUE3NUZcdTAyOENcIixcbiAgXCJ2eVwiOiBcIlx1QTc2MVwiLFxuICBcIndcIjogXCJcdTJDNzNcIixcbiAgXCJ5XCI6IFwiXHUwMUI0XHUwMjRGXHUxRUZGXCIsXG4gIFwielwiOiBcIlx1MDFCNlx1MDIyNVx1MDI0MFx1MkM2Q1x1QTc2M1wiLFxuICBcImh2XCI6IFwiXHUwMTk1XCJcbn07XG5cbmZvciAobGV0IGxhdGluIGluIGxhdGluX2NvbmRlbnNlZCkge1xuICBsZXQgdW5pY29kZSA9IGxhdGluX2NvbmRlbnNlZFtsYXRpbl0gfHwgJyc7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmljb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoYXIgPSB1bmljb2RlLnN1YnN0cmluZyhpLCBpICsgMSk7XG4gICAgbGF0aW5fY29udmVydFtjaGFyXSA9IGxhdGluO1xuICB9XG59XG5cbmNvbnN0IGNvbnZlcnRfcGF0ID0gbmV3IFJlZ0V4cChPYmplY3Qua2V5cyhsYXRpbl9jb252ZXJ0KS5qb2luKCd8JykgKyAnfCcgKyBhY2NlbnRfcGF0LCAnZ3UnKTtcbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgdW5pY29kZV9tYXAgZnJvbSB0aGUgZ2l2ZSBjb2RlIHBvaW50IHJhbmdlc1xuICpcbiAqIEBwYXJhbSB7VENvZGVQb2ludHM9fSBfY29kZV9wb2ludHNcbiAqL1xuXG5jb25zdCBpbml0aWFsaXplID0gX2NvZGVfcG9pbnRzID0+IHtcbiAgaWYgKHVuaWNvZGVfbWFwICE9PSB1bmRlZmluZWQpIHJldHVybjtcbiAgdW5pY29kZV9tYXAgPSBnZW5lcmF0ZU1hcChfY29kZV9wb2ludHMgfHwgY29kZV9wb2ludHMpO1xufTtcbi8qKlxuICogSGVscGVyIG1ldGhvZCBmb3Igbm9ybWFsaXplIGEgc3RyaW5nXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbm9ybWFsaXplXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybVxuICovXG5cbmNvbnN0IG5vcm1hbGl6ZSA9IChzdHIsIGZvcm0gPSAnTkZLRCcpID0+IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4vKipcbiAqIFJlbW92ZSBhY2NlbnRzIHdpdGhvdXQgcmVvcmRlcmluZyBzdHJpbmdcbiAqIGNhbGxpbmcgc3RyLm5vcm1hbGl6ZSgnTkZLRCcpIG9uIFxcdXs1OTR9XFx1ezU5NX1cXHV7NTk2fSBiZWNvbWVzIFxcdXs1OTZ9XFx1ezU5NH1cXHV7NTk1fVxuICogdmlhIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlzay9GdXNlL2lzc3Vlcy8xMzMjaXNzdWVjb21tZW50LTMxODY5MjcwM1xuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmNvbnN0IGFzY2lpZm9sZCA9IHN0ciA9PiB7XG4gIHJldHVybiB0b0FycmF5KHN0cikucmVkdWNlKFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3VsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICAgKi9cbiAgKHJlc3VsdCwgY2hhcikgPT4ge1xuICAgIHJldHVybiByZXN1bHQgKyBfYXNjaWlmb2xkKGNoYXIpO1xuICB9LCAnJyk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuY29uc3QgX2FzY2lpZm9sZCA9IHN0ciA9PiB7XG4gIHN0ciA9IG5vcm1hbGl6ZShzdHIpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShjb252ZXJ0X3BhdCwgKFxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgY2hhcikgPT4ge1xuICAgIHJldHVybiBsYXRpbl9jb252ZXJ0W2NoYXJdIHx8ICcnO1xuICB9KTsgLy9yZXR1cm4gc3RyO1xuXG4gIHJldHVybiBub3JtYWxpemUoc3RyLCAnTkZDJyk7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgdW5pY29kZSB2YXJpYW50cyBmcm9tIHRoZSBsaXN0IG9mIGNvZGUgcG9pbnRzXG4gKiBAcGFyYW0ge1RDb2RlUG9pbnRzfSBjb2RlX3BvaW50c1xuICogQHlpZWxkIHtUQ29kZVBvaW50T2JqfVxuICovXG5cbmZ1bmN0aW9uKiBnZW5lcmF0b3IoY29kZV9wb2ludHMpIHtcbiAgZm9yIChjb25zdCBbY29kZV9wb2ludF9taW4sIGNvZGVfcG9pbnRfbWF4XSBvZiBjb2RlX3BvaW50cykge1xuICAgIGZvciAobGV0IGkgPSBjb2RlX3BvaW50X21pbjsgaSA8PSBjb2RlX3BvaW50X21heDsgaSsrKSB7XG4gICAgICBsZXQgY29tcG9zZWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgbGV0IGZvbGRlZCA9IGFzY2lpZm9sZChjb21wb3NlZCk7XG5cbiAgICAgIGlmIChmb2xkZWQgPT0gY29tcG9zZWQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gc2tpcCB3aGVuIGZvbGRlZCBpcyBhIHN0cmluZyBsb25nZXIgdGhhbiAzIGNoYXJhY3RlcnMgbG9uZ1xuICAgICAgLy8gYmMgdGhlIHJlc3VsdGluZyByZWdleCBwYXR0ZXJucyB3aWxsIGJlIGxvbmdcbiAgICAgIC8vIGVnOlxuICAgICAgLy8gZm9sZGVkIFx1MDYzNVx1MDY0NFx1MDY0OSBcdTA2MjdcdTA2NDRcdTA2NDRcdTA2NDcgXHUwNjM5XHUwNjQ0XHUwNjRBXHUwNjQ3IFx1MDY0OFx1MDYzM1x1MDY0NFx1MDY0NSBsZW5ndGggMTggY29kZSBwb2ludCA2NTAxOFxuICAgICAgLy8gZm9sZGVkIFx1MDYyQ1x1MDY0NCBcdTA2MkNcdTA2NDRcdTA2MjdcdTA2NDRcdTA2NDcgbGVuZ3RoIDggY29kZSBwb2ludCA2NTAxOVxuXG5cbiAgICAgIGlmIChmb2xkZWQubGVuZ3RoID4gbWF4X2NoYXJfbGVuZ3RoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9sZGVkLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB5aWVsZCB7XG4gICAgICAgIGZvbGRlZDogZm9sZGVkLFxuICAgICAgICBjb21wb3NlZDogY29tcG9zZWQsXG4gICAgICAgIGNvZGVfcG9pbnQ6IGlcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pY29kZSBtYXAgZnJvbSB0aGUgbGlzdCBvZiBjb2RlIHBvaW50c1xuICogQHBhcmFtIHtUQ29kZVBvaW50c30gY29kZV9wb2ludHNcbiAqIEByZXR1cm4ge1RVbmljb2RlU2V0c31cbiAqL1xuXG5jb25zdCBnZW5lcmF0ZVNldHMgPSBjb2RlX3BvaW50cyA9PiB7XG4gIC8qKiBAdHlwZSB7e1trZXk6c3RyaW5nXTpTZXQ8c3RyaW5nPn19ICovXG4gIGNvbnN0IHVuaWNvZGVfc2V0cyA9IHt9O1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9fYWRkXG4gICAqL1xuXG4gIGNvbnN0IGFkZE1hdGNoaW5nID0gKGZvbGRlZCwgdG9fYWRkKSA9PiB7XG4gICAgLyoqIEB0eXBlIHtTZXQ8c3RyaW5nPn0gKi9cbiAgICBjb25zdCBmb2xkZWRfc2V0ID0gdW5pY29kZV9zZXRzW2ZvbGRlZF0gfHwgbmV3IFNldCgpO1xuICAgIGNvbnN0IHBhdHQgPSBuZXcgUmVnRXhwKCdeJyArIHNldFRvUGF0dGVybihmb2xkZWRfc2V0KSArICckJywgJ2l1Jyk7XG5cbiAgICBpZiAodG9fYWRkLm1hdGNoKHBhdHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9sZGVkX3NldC5hZGQoZXNjYXBlX3JlZ2V4KHRvX2FkZCkpO1xuICAgIHVuaWNvZGVfc2V0c1tmb2xkZWRdID0gZm9sZGVkX3NldDtcbiAgfTtcblxuICBmb3IgKGxldCB2YWx1ZSBvZiBnZW5lcmF0b3IoY29kZV9wb2ludHMpKSB7XG4gICAgYWRkTWF0Y2hpbmcodmFsdWUuZm9sZGVkLCB2YWx1ZS5mb2xkZWQpO1xuICAgIGFkZE1hdGNoaW5nKHZhbHVlLmZvbGRlZCwgdmFsdWUuY29tcG9zZWQpO1xuICB9XG5cbiAgcmV0dXJuIHVuaWNvZGVfc2V0cztcbn07XG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pY29kZSBtYXAgZnJvbSB0aGUgbGlzdCBvZiBjb2RlIHBvaW50c1xuICogYWUgPT4gKD86KD86YWV8XHUwMEM2fFx1MDFGQ3xcdTAxRTIpfCg/OkF8XHUyNEI2fFx1RkYyMS4uLikoPzpFfFx1MDI1QnxcdTI0QkEuLi4pKVxuICpcbiAqIEBwYXJhbSB7VENvZGVQb2ludHN9IGNvZGVfcG9pbnRzXG4gKiBAcmV0dXJuIHtUVW5pY29kZU1hcH1cbiAqL1xuXG5jb25zdCBnZW5lcmF0ZU1hcCA9IGNvZGVfcG9pbnRzID0+IHtcbiAgLyoqIEB0eXBlIHtUVW5pY29kZVNldHN9ICovXG4gIGNvbnN0IHVuaWNvZGVfc2V0cyA9IGdlbmVyYXRlU2V0cyhjb2RlX3BvaW50cyk7XG4gIC8qKiBAdHlwZSB7VFVuaWNvZGVNYXB9ICovXG5cbiAgY29uc3QgdW5pY29kZV9tYXAgPSB7fTtcbiAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cblxuICBsZXQgbXVsdGlfY2hhciA9IFtdO1xuXG4gIGZvciAobGV0IGZvbGRlZCBpbiB1bmljb2RlX3NldHMpIHtcbiAgICBsZXQgc2V0ID0gdW5pY29kZV9zZXRzW2ZvbGRlZF07XG5cbiAgICBpZiAoc2V0KSB7XG4gICAgICB1bmljb2RlX21hcFtmb2xkZWRdID0gc2V0VG9QYXR0ZXJuKHNldCk7XG4gICAgfVxuXG4gICAgaWYgKGZvbGRlZC5sZW5ndGggPiAxKSB7XG4gICAgICBtdWx0aV9jaGFyLnB1c2goZXNjYXBlX3JlZ2V4KGZvbGRlZCkpO1xuICAgIH1cbiAgfVxuXG4gIG11bHRpX2NoYXIuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XG4gIGNvbnN0IG11bHRpX2NoYXJfcGF0dCA9IGFycmF5VG9QYXR0ZXJuKG11bHRpX2NoYXIpO1xuICBtdWx0aV9jaGFyX3JlZyA9IG5ldyBSZWdFeHAoJ14nICsgbXVsdGlfY2hhcl9wYXR0LCAndScpO1xuICByZXR1cm4gdW5pY29kZV9tYXA7XG59O1xuLyoqXG4gKiBNYXAgZWFjaCBlbGVtZW50IG9mIGFuIGFycmF5IGZyb20gaXQncyBmb2xkZWQgdmFsdWUgdG8gYWxsIHBvc3NpYmxlIHVuaWNvZGUgbWF0Y2hlc1xuICogQHBhcmFtIHtzdHJpbmdbXX0gc3RyaW5nc1xuICogQHBhcmFtIHtudW1iZXJ9IG1pbl9yZXBsYWNlbWVudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmNvbnN0IG1hcFNlcXVlbmNlID0gKHN0cmluZ3MsIG1pbl9yZXBsYWNlbWVudCA9IDEpID0+IHtcbiAgbGV0IGNoYXJzX3JlcGxhY2VkID0gMDtcbiAgc3RyaW5ncyA9IHN0cmluZ3MubWFwKHN0ciA9PiB7XG4gICAgaWYgKHVuaWNvZGVfbWFwW3N0cl0pIHtcbiAgICAgIGNoYXJzX3JlcGxhY2VkICs9IHN0ci5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWNvZGVfbWFwW3N0cl0gfHwgc3RyO1xuICB9KTtcblxuICBpZiAoY2hhcnNfcmVwbGFjZWQgPj0gbWluX3JlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHNlcXVlbmNlUGF0dGVybihzdHJpbmdzKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG4vKipcbiAqIENvbnZlcnQgYSBzaG9ydCBzdHJpbmcgYW5kIHNwbGl0IGl0IGludG8gYWxsIHBvc3NpYmxlIHBhdHRlcm5zXG4gKiBLZWVwIGEgcGF0dGVybiBvbmx5IGlmIG1pbl9yZXBsYWNlbWVudCBpcyBtZXRcbiAqXG4gKiAnYWJjJ1xuICogXHRcdD0+IFtbJ2FiYyddLFsnYWInLCdjJ10sWydhJywnYmMnXSxbJ2EnLCdiJywnYyddXVxuICpcdFx0PT4gWydhYmMtcGF0dGVybicsJ2FiLWMtcGF0dGVybicuLi5dXG4gKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5fcmVwbGFjZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5jb25zdCBzdWJzdHJpbmdzVG9QYXR0ZXJuID0gKHN0ciwgbWluX3JlcGxhY2VtZW50ID0gMSkgPT4ge1xuICBtaW5fcmVwbGFjZW1lbnQgPSBNYXRoLm1heChtaW5fcmVwbGFjZW1lbnQsIHN0ci5sZW5ndGggLSAxKTtcbiAgcmV0dXJuIGFycmF5VG9QYXR0ZXJuKGFsbFN1YnN0cmluZ3Moc3RyKS5tYXAoc3ViX3BhdCA9PiB7XG4gICAgcmV0dXJuIG1hcFNlcXVlbmNlKHN1Yl9wYXQsIG1pbl9yZXBsYWNlbWVudCk7XG4gIH0pKTtcbn07XG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2Ygc2VxdWVuY2VzIGludG8gYSBwYXR0ZXJuXG4gKiBbe3N0YXJ0OjAsZW5kOjMsbGVuZ3RoOjMsc3Vic3RyOidpaWknfS4uLl0gPT4gKD86aWlpLi4uKVxuICpcbiAqIEBwYXJhbSB7U2VxdWVuY2VbXX0gc2VxdWVuY2VzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsbFxuICovXG5cbmNvbnN0IHNlcXVlbmNlc1RvUGF0dGVybiA9IChzZXF1ZW5jZXMsIGFsbCA9IHRydWUpID0+IHtcbiAgbGV0IG1pbl9yZXBsYWNlbWVudCA9IHNlcXVlbmNlcy5sZW5ndGggPiAxID8gMSA6IDA7XG4gIHJldHVybiBhcnJheVRvUGF0dGVybihzZXF1ZW5jZXMubWFwKHNlcXVlbmNlID0+IHtcbiAgICBsZXQgc2VxID0gW107XG4gICAgY29uc3QgbGVuID0gYWxsID8gc2VxdWVuY2UubGVuZ3RoKCkgOiBzZXF1ZW5jZS5sZW5ndGgoKSAtIDE7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBzZXEucHVzaChzdWJzdHJpbmdzVG9QYXR0ZXJuKHNlcXVlbmNlLnN1YnN0cnNbal0gfHwgJycsIG1pbl9yZXBsYWNlbWVudCkpO1xuICAgIH1cblxuICAgIHJldHVybiBzZXF1ZW5jZVBhdHRlcm4oc2VxKTtcbiAgfSkpO1xufTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHNlcXVlbmNlIGlzIGFscmVhZHkgaW4gdGhlIHNlcXVlbmNlc1xuICogQHBhcmFtIHtTZXF1ZW5jZX0gbmVlZGxlX3NlcVxuICogQHBhcmFtIHtTZXF1ZW5jZVtdfSBzZXF1ZW5jZXNcbiAqL1xuXG5cbmNvbnN0IGluU2VxdWVuY2VzID0gKG5lZWRsZV9zZXEsIHNlcXVlbmNlcykgPT4ge1xuICBmb3IgKGNvbnN0IHNlcSBvZiBzZXF1ZW5jZXMpIHtcbiAgICBpZiAoc2VxLnN0YXJ0ICE9IG5lZWRsZV9zZXEuc3RhcnQgfHwgc2VxLmVuZCAhPSBuZWVkbGVfc2VxLmVuZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNlcS5zdWJzdHJzLmpvaW4oJycpICE9PSBuZWVkbGVfc2VxLnN1YnN0cnMuam9pbignJykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBuZWVkbGVfcGFydHMgPSBuZWVkbGVfc2VxLnBhcnRzO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VFNlcXVlbmNlUGFydH0gcGFydFxuICAgICAqL1xuXG4gICAgY29uc3QgZmlsdGVyID0gcGFydCA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG5lZWRsZV9wYXJ0IG9mIG5lZWRsZV9wYXJ0cykge1xuICAgICAgICBpZiAobmVlZGxlX3BhcnQuc3RhcnQgPT09IHBhcnQuc3RhcnQgJiYgbmVlZGxlX3BhcnQuc3Vic3RyID09PSBwYXJ0LnN1YnN0cikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PSAxIHx8IG5lZWRsZV9wYXJ0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gY2hlY2sgZm9yIG92ZXJsYXBwaW5nIHBhcnRzXG4gICAgICAgIC8vIGEgPSBbJzo6PScsJz09J11cbiAgICAgICAgLy8gYiA9IFsnOjonLCc9PT0nXVxuICAgICAgICAvLyBhID0gWydyJywnc20nXVxuICAgICAgICAvLyBiID0gWydycycsJ20nXVxuXG5cbiAgICAgICAgaWYgKHBhcnQuc3RhcnQgPCBuZWVkbGVfcGFydC5zdGFydCAmJiBwYXJ0LmVuZCA+IG5lZWRsZV9wYXJ0LnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVlZGxlX3BhcnQuc3RhcnQgPCBwYXJ0LnN0YXJ0ICYmIG5lZWRsZV9wYXJ0LmVuZCA+IHBhcnQuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGxldCBmaWx0ZXJlZCA9IHNlcS5wYXJ0cy5maWx0ZXIoZmlsdGVyKTtcblxuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNsYXNzIFNlcXVlbmNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHtUU2VxdWVuY2VQYXJ0W119ICovXG4gICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cbiAgICB0aGlzLnN1YnN0cnMgPSBbXTtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmVuZCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7VFNlcXVlbmNlUGFydHx1bmRlZmluZWR9IHBhcnRcbiAgICovXG5cblxuICBhZGQocGFydCkge1xuICAgIGlmIChwYXJ0KSB7XG4gICAgICB0aGlzLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICB0aGlzLnN1YnN0cnMucHVzaChwYXJ0LnN1YnN0cik7XG4gICAgICB0aGlzLnN0YXJ0ID0gTWF0aC5taW4ocGFydC5zdGFydCwgdGhpcy5zdGFydCk7XG4gICAgICB0aGlzLmVuZCA9IE1hdGgubWF4KHBhcnQuZW5kLCB0aGlzLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgbGFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnRzLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7VFNlcXVlbmNlUGFydH0gbGFzdF9waWVjZVxuICAgKi9cblxuXG4gIGNsb25lKHBvc2l0aW9uLCBsYXN0X3BpZWNlKSB7XG4gICAgbGV0IGNsb25lID0gbmV3IFNlcXVlbmNlKCk7XG4gICAgbGV0IHBhcnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBhcnRzKSk7XG4gICAgbGV0IGxhc3RfcGFydCA9IHBhcnRzLnBvcCgpO1xuXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICBjbG9uZS5hZGQocGFydCk7XG4gICAgfVxuXG4gICAgbGV0IGxhc3Rfc3Vic3RyID0gbGFzdF9waWVjZS5zdWJzdHIuc3Vic3RyaW5nKDAsIHBvc2l0aW9uIC0gbGFzdF9wYXJ0LnN0YXJ0KTtcbiAgICBsZXQgY2xvbmVfbGFzdF9sZW4gPSBsYXN0X3N1YnN0ci5sZW5ndGg7XG4gICAgY2xvbmUuYWRkKHtcbiAgICAgIHN0YXJ0OiBsYXN0X3BhcnQuc3RhcnQsXG4gICAgICBlbmQ6IGxhc3RfcGFydC5zdGFydCArIGNsb25lX2xhc3RfbGVuLFxuICAgICAgbGVuZ3RoOiBjbG9uZV9sYXN0X2xlbixcbiAgICAgIHN1YnN0cjogbGFzdF9zdWJzdHJcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxufVxuLyoqXG4gKiBFeHBhbmQgYSByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB0byBpbmNsdWRlIHVuaWNvZGUgdmFyaWFudHNcbiAqIFx0ZWcgL2EvIGJlY29tZXMgL2FcdTI0RDBcdUZGNDFcdTFFOUFcdTAwRTBcdTAwRTFcdTAwRTJcdTFFQTdcdTFFQTVcdTFFQUJcdTFFQTlcdTAwRTNcdTAxMDFcdTAxMDNcdTFFQjFcdTFFQUZcdTFFQjVcdTFFQjNcdTAyMjdcdTAxRTFcdTAwRTRcdTAxREZcdTFFQTNcdTAwRTVcdTAxRkJcdTAxQ0VcdTAyMDFcdTAyMDNcdTFFQTFcdTFFQURcdTFFQjdcdTFFMDFcdTAxMDVcdTJDNjVcdTAyNTBcdTAyNTFBXHUyNEI2XHVGRjIxXHUwMEMwXHUwMEMxXHUwMEMyXHUxRUE2XHUxRUE0XHUxRUFBXHUxRUE4XHUwMEMzXHUwMTAwXHUwMTAyXHUxRUIwXHUxRUFFXHUxRUI0XHUxRUIyXHUwMjI2XHUwMUUwXHUwMEM0XHUwMURFXHUxRUEyXHUwMEM1XHUwMUZBXHUwMUNEXHUwMjAwXHUwMjAyXHUxRUEwXHUxRUFDXHUxRUI2XHUxRTAwXHUwMTA0XHUwMjNBXHUyQzZGL1xuICpcbiAqIElzc3VlOlxuICogIFx1RkU4QVx1RkU4QiBbICdcdUZFOEEgPSBcXFxcdXtmZThhfScsICdcdUZFOEIgPSBcXFxcdXtmZThifScgXVxuICpcdGJlY29tZXM6XHRcdTA2NEFcdTA2NTRcdTA2NEFcdTA2NTQgWyAnXHUwNjRBID0gXFxcXHV7NjRhfScsICdcdTA2NTQgPSBcXFxcdXs2NTR9JywgJ1x1MDY0QSA9IFxcXFx1ezY0YX0nLCAnXHUwNjU0ID0gXFxcXHV7NjU0fScgXVxuICpcbiAqXHRcdTAxMzBcdTAxMzIgPSBJSUogPSBcdTIxNjFKXG4gKlxuICogXHQxLzIvNFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cblxuXG5jb25zdCBnZXRQYXR0ZXJuID0gc3RyID0+IHtcbiAgaW5pdGlhbGl6ZSgpO1xuICBzdHIgPSBhc2NpaWZvbGQoc3RyKTtcbiAgbGV0IHBhdHRlcm4gPSAnJztcbiAgbGV0IHNlcXVlbmNlcyA9IFtuZXcgU2VxdWVuY2UoKV07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgc3Vic3RyID0gc3RyLnN1YnN0cmluZyhpKTtcbiAgICBsZXQgbWF0Y2ggPSBzdWJzdHIubWF0Y2gobXVsdGlfY2hhcl9yZWcpO1xuICAgIGNvbnN0IGNoYXIgPSBzdHIuc3Vic3RyaW5nKGksIGkgKyAxKTtcbiAgICBjb25zdCBtYXRjaF9zdHIgPSBtYXRjaCA/IG1hdGNoWzBdIDogbnVsbDsgLy8gbG9vcCB0aHJvdWdoIHNlcXVlbmNlc1xuICAgIC8vIGFkZCBlaXRoZXIgdGhlIGNoYXIgb3IgbXVsdGlfbWF0Y2hcblxuICAgIGxldCBvdmVybGFwcGluZyA9IFtdO1xuICAgIGxldCBhZGRlZF90eXBlcyA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3Qgc2VxdWVuY2Ugb2Ygc2VxdWVuY2VzKSB7XG4gICAgICBjb25zdCBsYXN0X3BpZWNlID0gc2VxdWVuY2UubGFzdCgpO1xuXG4gICAgICBpZiAoIWxhc3RfcGllY2UgfHwgbGFzdF9waWVjZS5sZW5ndGggPT0gMSB8fCBsYXN0X3BpZWNlLmVuZCA8PSBpKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtdWx0aSBtYXRjaFxuICAgICAgICBpZiAobWF0Y2hfc3RyKSB7XG4gICAgICAgICAgY29uc3QgbGVuID0gbWF0Y2hfc3RyLmxlbmd0aDtcbiAgICAgICAgICBzZXF1ZW5jZS5hZGQoe1xuICAgICAgICAgICAgc3RhcnQ6IGksXG4gICAgICAgICAgICBlbmQ6IGkgKyBsZW4sXG4gICAgICAgICAgICBsZW5ndGg6IGxlbixcbiAgICAgICAgICAgIHN1YnN0cjogbWF0Y2hfc3RyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkZWRfdHlwZXMuYWRkKCcxJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VxdWVuY2UuYWRkKHtcbiAgICAgICAgICAgIHN0YXJ0OiBpLFxuICAgICAgICAgICAgZW5kOiBpICsgMSxcbiAgICAgICAgICAgIGxlbmd0aDogMSxcbiAgICAgICAgICAgIHN1YnN0cjogY2hhclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFkZGVkX3R5cGVzLmFkZCgnMicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoX3N0cikge1xuICAgICAgICBsZXQgY2xvbmUgPSBzZXF1ZW5jZS5jbG9uZShpLCBsYXN0X3BpZWNlKTtcbiAgICAgICAgY29uc3QgbGVuID0gbWF0Y2hfc3RyLmxlbmd0aDtcbiAgICAgICAgY2xvbmUuYWRkKHtcbiAgICAgICAgICBzdGFydDogaSxcbiAgICAgICAgICBlbmQ6IGkgKyBsZW4sXG4gICAgICAgICAgbGVuZ3RoOiBsZW4sXG4gICAgICAgICAgc3Vic3RyOiBtYXRjaF9zdHJcbiAgICAgICAgfSk7XG4gICAgICAgIG92ZXJsYXBwaW5nLnB1c2goY2xvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9uJ3QgYWRkIGNoYXJcbiAgICAgICAgLy8gYWRkaW5nIHdvdWxkIGNyZWF0ZSBpbnZhbGlkIHBhdHRlcm5zOiAyMzQgPT4gWzIsMzQsNF1cbiAgICAgICAgYWRkZWRfdHlwZXMuYWRkKCczJyk7XG4gICAgICB9XG4gICAgfSAvLyBpZiB3ZSBoYXZlIG92ZXJsYXBwaW5nXG5cblxuICAgIGlmIChvdmVybGFwcGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBbJ2lpJywnaWlpJ10gYmVmb3JlIFsnaScsJ2knLCdpaWknXVxuICAgICAgb3ZlcmxhcHBpbmcgPSBvdmVybGFwcGluZy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCgpIC0gYi5sZW5ndGgoKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGxldCBjbG9uZSBvZiBvdmVybGFwcGluZykge1xuICAgICAgICAvLyBkb24ndCBhZGQgaWYgd2UgYWxyZWFkeSBoYXZlIGFuIGVxdWl2YWxlbnQgc2VxdWVuY2VcbiAgICAgICAgaWYgKGluU2VxdWVuY2VzKGNsb25lLCBzZXF1ZW5jZXMpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZXF1ZW5jZXMucHVzaChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gaWYgd2UgaGF2ZW4ndCBkb25lIGFueXRoaW5nIHVuaXF1ZVxuICAgIC8vIGNsZWFuIHVwIHRoZSBwYXR0ZXJuc1xuICAgIC8vIGhlbHBzIGtlZXAgcGF0dGVybnMgc21hbGxlclxuICAgIC8vIGlmIHN0ciA9ICdyXHUyMEE4XHUzM0E3YWFyc3MnLCBwYXR0ZXJuIHdpbGwgYmUgNDQ2IGluc3RlYWQgb2YgNjU1XG5cblxuICAgIGlmIChpID4gMCAmJiBhZGRlZF90eXBlcy5zaXplID09IDEgJiYgIWFkZGVkX3R5cGVzLmhhcygnMycpKSB7XG4gICAgICBwYXR0ZXJuICs9IHNlcXVlbmNlc1RvUGF0dGVybihzZXF1ZW5jZXMsIGZhbHNlKTtcbiAgICAgIGxldCBuZXdfc2VxID0gbmV3IFNlcXVlbmNlKCk7XG4gICAgICBjb25zdCBvbGRfc2VxID0gc2VxdWVuY2VzWzBdO1xuXG4gICAgICBpZiAob2xkX3NlcSkge1xuICAgICAgICBuZXdfc2VxLmFkZChvbGRfc2VxLmxhc3QoKSk7XG4gICAgICB9XG5cbiAgICAgIHNlcXVlbmNlcyA9IFtuZXdfc2VxXTtcbiAgICB9XG4gIH1cblxuICBwYXR0ZXJuICs9IHNlcXVlbmNlc1RvUGF0dGVybihzZXF1ZW5jZXMsIHRydWUpO1xuICByZXR1cm4gcGF0dGVybjtcbn07XG5cbmV4cG9ydCB7IF9hc2NpaWZvbGQsIGFzY2lpZm9sZCwgY29kZV9wb2ludHMsIGdlbmVyYXRlTWFwLCBnZW5lcmF0ZVNldHMsIGdlbmVyYXRvciwgZ2V0UGF0dGVybiwgaW5pdGlhbGl6ZSwgbWFwU2VxdWVuY2UsIG5vcm1hbGl6ZSwgc3Vic3RyaW5nc1RvUGF0dGVybiwgdW5pY29kZV9tYXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwgIi8qISBzaWZ0ZXIuanMgfCBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvc2lmdGVyLmpzIHwgQXBhY2hlIExpY2Vuc2UgKHYyKSAqL1xuaW1wb3J0IHsgYXNjaWlmb2xkIH0gZnJvbSAnQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMnO1xuXG4vKipcbiAqIEEgcHJvcGVydHkgZ2V0dGVyIHJlc29sdmluZyBkb3Qtbm90YXRpb25cbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiAgICAgVGhlIHJvb3Qgb2JqZWN0IHRvIGZldGNoIHByb3BlcnR5IG9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgIFRoZSBvcHRpb25hbGx5IGRvdHRlZCBwcm9wZXJ0eSBuYW1lIHRvIGZldGNoXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIFRoZSByZXNvbHZlZCBwcm9wZXJ0eSB2YWx1ZVxuICovXG5jb25zdCBnZXRBdHRyID0gKG9iaiwgbmFtZSkgPT4ge1xuICBpZiAoIW9iaikgcmV0dXJuO1xuICByZXR1cm4gb2JqW25hbWVdO1xufTtcbi8qKlxuICogQSBwcm9wZXJ0eSBnZXR0ZXIgcmVzb2x2aW5nIGRvdC1ub3RhdGlvblxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqICAgICBUaGUgcm9vdCBvYmplY3QgdG8gZmV0Y2ggcHJvcGVydHkgb25cbiAqIEBwYXJhbSAge1N0cmluZ30gIG5hbWUgICAgVGhlIG9wdGlvbmFsbHkgZG90dGVkIHByb3BlcnR5IG5hbWUgdG8gZmV0Y2hcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgVGhlIHJlc29sdmVkIHByb3BlcnR5IHZhbHVlXG4gKi9cblxuY29uc3QgZ2V0QXR0ck5lc3RpbmcgPSAob2JqLCBuYW1lKSA9PiB7XG4gIGlmICghb2JqKSByZXR1cm47XG4gIHZhciBwYXJ0LFxuICAgICAgbmFtZXMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcblxuICB3aGlsZSAoKHBhcnQgPSBuYW1lcy5zaGlmdCgpKSAmJiAob2JqID0gb2JqW3BhcnRdKSk7XG5cbiAgcmV0dXJuIG9iajtcbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgaG93IGNsb3NlIG9mIGEgbWF0Y2ggdGhlXG4gKiBnaXZlbiB2YWx1ZSBpcyBhZ2FpbnN0IGEgc2VhcmNoIHRva2VuLlxuICpcbiAqL1xuXG5jb25zdCBzY29yZVZhbHVlID0gKHZhbHVlLCB0b2tlbiwgd2VpZ2h0KSA9PiB7XG4gIHZhciBzY29yZSwgcG9zO1xuICBpZiAoIXZhbHVlKSByZXR1cm4gMDtcbiAgdmFsdWUgPSB2YWx1ZSArICcnO1xuICBpZiAodG9rZW4ucmVnZXggPT0gbnVsbCkgcmV0dXJuIDA7XG4gIHBvcyA9IHZhbHVlLnNlYXJjaCh0b2tlbi5yZWdleCk7XG4gIGlmIChwb3MgPT09IC0xKSByZXR1cm4gMDtcbiAgc2NvcmUgPSB0b2tlbi5zdHJpbmcubGVuZ3RoIC8gdmFsdWUubGVuZ3RoO1xuICBpZiAocG9zID09PSAwKSBzY29yZSArPSAwLjU7XG4gIHJldHVybiBzY29yZSAqIHdlaWdodDtcbn07XG4vKipcbiAqIENhc3Qgb2JqZWN0IHByb3BlcnR5IHRvIGFuIGFycmF5IGlmIGl0IGV4aXN0cyBhbmQgaGFzIGEgdmFsdWVcbiAqXG4gKi9cblxuY29uc3QgcHJvcFRvQXJyYXkgPSAob2JqLCBrZXkpID0+IHtcbiAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuXG4gIGlmICh2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBvYmpba2V5XSA9IFt2YWx1ZV07XG4gIH1cbn07XG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgYXJyYXlzIGFuZCBoYXNoZXMuXG4gKlxuICogYGBgXG4gKiBpdGVyYXRlKHRoaXMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGlkKSB7XG4gKiAgICAvLyBpbnZva2VkIGZvciBlYWNoIGl0ZW1cbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5cbmNvbnN0IGl0ZXJhdGUgPSAob2JqZWN0LCBjYWxsYmFjaykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgb2JqZWN0LmZvckVhY2goY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5jb25zdCBjbXAgPSAoYSwgYikgPT4ge1xuICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbiAgfVxuXG4gIGEgPSBhc2NpaWZvbGQoYSArICcnKS50b0xvd2VyQ2FzZSgpO1xuICBiID0gYXNjaWlmb2xkKGIgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgaWYgKGIgPiBhKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufTtcblxuZXhwb3J0IHsgY21wLCBnZXRBdHRyLCBnZXRBdHRyTmVzdGluZywgaXRlcmF0ZSwgcHJvcFRvQXJyYXksIHNjb3JlVmFsdWUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIiwgIi8qISBzaWZ0ZXIuanMgfCBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvc2lmdGVyLmpzIHwgQXBhY2hlIExpY2Vuc2UgKHYyKSAqL1xuaW1wb3J0IHsgaXRlcmF0ZSwgY21wLCBwcm9wVG9BcnJheSwgZ2V0QXR0ck5lc3RpbmcsIGdldEF0dHIsIHNjb3JlVmFsdWUgfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCB7IGNtcCwgZ2V0QXR0ciwgZ2V0QXR0ck5lc3RpbmcsIGl0ZXJhdGUsIHByb3BUb0FycmF5LCBzY29yZVZhbHVlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlc2NhcGVfcmVnZXgsIGdldFBhdHRlcm4gfSBmcm9tICdAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyc7XG5leHBvcnQgeyBnZXRQYXR0ZXJuIH0gZnJvbSAnQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMnO1xuXG4vKipcbiAqIHNpZnRlci5qc1xuICogQ29weXJpZ2h0IChjKSAyMDEzXHUyMDEzMjAyMCBCcmlhbiBSZWF2aXMgJiBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGF1dGhvciBCcmlhbiBSZWF2aXMgPGJyaWFuQHRoaXJkcm91dGUuY29tPlxuICovXG5cbmNsYXNzIFNpZnRlciB7XG4gIC8vIFtdfHt9O1xuXG4gIC8qKlxuICAgKiBUZXh0dWFsbHkgc2VhcmNoZXMgYXJyYXlzIGFuZCBoYXNoZXMgb2Ygb2JqZWN0c1xuICAgKiBieSBwcm9wZXJ0eSAob3IgbXVsdGlwbGUgcHJvcGVydGllcykuIERlc2lnbmVkXG4gICAqIHNwZWNpZmljYWxseSBmb3IgYXV0b2NvbXBsZXRlLlxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3IoaXRlbXMsIHNldHRpbmdzKSB7XG4gICAgdGhpcy5pdGVtcyA9IHZvaWQgMDtcbiAgICB0aGlzLnNldHRpbmdzID0gdm9pZCAwO1xuICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3MgfHwge1xuICAgICAgZGlhY3JpdGljczogdHJ1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgc2VhcmNoIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGluZGl2aWR1YWxcbiAgICogcmVnZXhwcyB0byBiZSB1c2VkIHRvIG1hdGNoIHJlc3VsdHMuXG4gICAqXG4gICAqL1xuICB0b2tlbml6ZShxdWVyeSwgcmVzcGVjdF93b3JkX2JvdW5kYXJpZXMsIHdlaWdodHMpIHtcbiAgICBpZiAoIXF1ZXJ5IHx8ICFxdWVyeS5sZW5ndGgpIHJldHVybiBbXTtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBjb25zdCB3b3JkcyA9IHF1ZXJ5LnNwbGl0KC9cXHMrLyk7XG4gICAgdmFyIGZpZWxkX3JlZ2V4O1xuXG4gICAgaWYgKHdlaWdodHMpIHtcbiAgICAgIGZpZWxkX3JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgT2JqZWN0LmtleXMod2VpZ2h0cykubWFwKGVzY2FwZV9yZWdleCkuam9pbignfCcpICsgJylcXDooLiopJCcpO1xuICAgIH1cblxuICAgIHdvcmRzLmZvckVhY2god29yZCA9PiB7XG4gICAgICBsZXQgZmllbGRfbWF0Y2g7XG4gICAgICBsZXQgZmllbGQgPSBudWxsO1xuICAgICAgbGV0IHJlZ2V4ID0gbnVsbDsgLy8gbG9vayBmb3IgXCJmaWVsZDpxdWVyeVwiIHRva2Vuc1xuXG4gICAgICBpZiAoZmllbGRfcmVnZXggJiYgKGZpZWxkX21hdGNoID0gd29yZC5tYXRjaChmaWVsZF9yZWdleCkpKSB7XG4gICAgICAgIGZpZWxkID0gZmllbGRfbWF0Y2hbMV07XG4gICAgICAgIHdvcmQgPSBmaWVsZF9tYXRjaFsyXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdvcmQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kaWFjcml0aWNzKSB7XG4gICAgICAgICAgcmVnZXggPSBnZXRQYXR0ZXJuKHdvcmQpIHx8IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnZXggPSBlc2NhcGVfcmVnZXgod29yZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVnZXggJiYgcmVzcGVjdF93b3JkX2JvdW5kYXJpZXMpIHJlZ2V4ID0gXCJcXFxcYlwiICsgcmVnZXg7XG4gICAgICB9XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgc3RyaW5nOiB3b3JkLFxuICAgICAgICByZWdleDogcmVnZXggPyBuZXcgUmVnRXhwKHJlZ2V4LCAnaXUnKSA6IG51bGwsXG4gICAgICAgIGZpZWxkOiBmaWVsZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCB0byBzY29yZSBpbmRpdmlkdWFsIHJlc3VsdHMuXG4gICAqXG4gICAqIEdvb2QgbWF0Y2hlcyB3aWxsIGhhdmUgYSBoaWdoZXIgc2NvcmUgdGhhbiBwb29yIG1hdGNoZXMuXG4gICAqIElmIGFuIGl0ZW0gaXMgbm90IGEgbWF0Y2gsIDAgd2lsbCBiZSByZXR1cm5lZCBieSB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtULlNjb3JlRm59XG4gICAqL1xuICBnZXRTY29yZUZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgdmFyIHNlYXJjaCA9IHRoaXMucHJlcGFyZVNlYXJjaChxdWVyeSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNjb3JlRnVuY3Rpb24oc2VhcmNoKTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge1QuU2NvcmVGbn1cbiAgICpcbiAgICovXG5cblxuICBfZ2V0U2NvcmVGdW5jdGlvbihzZWFyY2gpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBzZWFyY2gudG9rZW5zLFxuICAgICAgICAgIHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcblxuICAgIGlmICghdG9rZW5fY291bnQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWVsZHMgPSBzZWFyY2gub3B0aW9ucy5maWVsZHMsXG4gICAgICAgICAgd2VpZ2h0cyA9IHNlYXJjaC53ZWlnaHRzLFxuICAgICAgICAgIGZpZWxkX2NvdW50ID0gZmllbGRzLmxlbmd0aCxcbiAgICAgICAgICBnZXRBdHRyRm4gPSBzZWFyY2guZ2V0QXR0ckZuO1xuXG4gICAgaWYgKCFmaWVsZF9jb3VudCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBzY29yZSBvZiBhbiBvYmplY3RcbiAgICAgKiBhZ2FpbnN0IHRoZSBzZWFyY2ggcXVlcnkuXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgY29uc3Qgc2NvcmVPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZmllbGRfY291bnQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0b2tlbiwgZGF0YSkge1xuICAgICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzWzBdLmZpZWxkO1xuICAgICAgICAgIHJldHVybiBzY29yZVZhbHVlKGdldEF0dHJGbihkYXRhLCBmaWVsZCksIHRva2VuLCB3ZWlnaHRzW2ZpZWxkXSB8fCAxKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0b2tlbiwgZGF0YSkge1xuICAgICAgICB2YXIgc3VtID0gMDsgLy8gaXMgdGhlIHRva2VuIHNwZWNpZmljIHRvIGEgZmllbGQ/XG5cbiAgICAgICAgaWYgKHRva2VuLmZpZWxkKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRBdHRyRm4oZGF0YSwgdG9rZW4uZmllbGQpO1xuXG4gICAgICAgICAgaWYgKCF0b2tlbi5yZWdleCAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgc3VtICs9IDEgLyBmaWVsZF9jb3VudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VtICs9IHNjb3JlVmFsdWUodmFsdWUsIHRva2VuLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0ZSh3ZWlnaHRzLCAod2VpZ2h0LCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgc3VtICs9IHNjb3JlVmFsdWUoZ2V0QXR0ckZuKGRhdGEsIGZpZWxkKSwgdG9rZW4sIHdlaWdodCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtIC8gZmllbGRfY291bnQ7XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGlmICh0b2tlbl9jb3VudCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBzY29yZU9iamVjdCh0b2tlbnNbMF0sIGRhdGEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoc2VhcmNoLm9wdGlvbnMuY29uanVuY3Rpb24gPT09ICdhbmQnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHNjb3JlLFxuICAgICAgICAgICAgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICBzY29yZSA9IHNjb3JlT2JqZWN0KHRva2VuLCBkYXRhKTtcbiAgICAgICAgICBpZiAoc2NvcmUgPD0gMCkgcmV0dXJuIDA7XG4gICAgICAgICAgc3VtICs9IHNjb3JlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1bSAvIHRva2VuX2NvdW50O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBpdGVyYXRlKHRva2VucywgdG9rZW4gPT4ge1xuICAgICAgICAgIHN1bSArPSBzY29yZU9iamVjdCh0b2tlbiwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3VtIC8gdG9rZW5fY291bnQ7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wYXJlIHR3b1xuICAgKiByZXN1bHRzLCBmb3Igc29ydGluZyBwdXJwb3Nlcy4gSWYgbm8gc29ydGluZyBzaG91bGRcbiAgICogYmUgcGVyZm9ybWVkLCBgbnVsbGAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHJldHVybiBmdW5jdGlvbihhLGIpXG4gICAqL1xuICBnZXRTb3J0RnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VhcmNoID0gdGhpcy5wcmVwYXJlU2VhcmNoKHF1ZXJ5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydEZ1bmN0aW9uKHNlYXJjaCk7XG4gIH1cblxuICBfZ2V0U29ydEZ1bmN0aW9uKHNlYXJjaCkge1xuICAgIHZhciBpbXBsaWNpdF9zY29yZSxcbiAgICAgICAgc29ydF9mbGRzID0gW107XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgb3B0aW9ucyA9IHNlYXJjaC5vcHRpb25zLFxuICAgICAgICAgIHNvcnQgPSAhc2VhcmNoLnF1ZXJ5ICYmIG9wdGlvbnMuc29ydF9lbXB0eSA/IG9wdGlvbnMuc29ydF9lbXB0eSA6IG9wdGlvbnMuc29ydDtcblxuICAgIGlmICh0eXBlb2Ygc29ydCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc29ydC5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBzcGVjaWZpZWQgc29ydCBmaWVsZCB2YWx1ZVxuICAgICAqIGZyb20gYSBzZWFyY2ggcmVzdWx0IGl0ZW0uXG4gICAgICpcbiAgICAgKi9cblxuXG4gICAgY29uc3QgZ2V0X2ZpZWxkID0gZnVuY3Rpb24gZ2V0X2ZpZWxkKG5hbWUsIHJlc3VsdCkge1xuICAgICAgaWYgKG5hbWUgPT09ICckc2NvcmUnKSByZXR1cm4gcmVzdWx0LnNjb3JlO1xuICAgICAgcmV0dXJuIHNlYXJjaC5nZXRBdHRyRm4oc2VsZi5pdGVtc1tyZXN1bHQuaWRdLCBuYW1lKTtcbiAgICB9OyAvLyBwYXJzZSBvcHRpb25zXG5cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICBmb3IgKGxldCBzIG9mIHNvcnQpIHtcbiAgICAgICAgaWYgKHNlYXJjaC5xdWVyeSB8fCBzLmZpZWxkICE9PSAnJHNjb3JlJykge1xuICAgICAgICAgIHNvcnRfZmxkcy5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyB0aGUgXCIkc2NvcmVcIiBmaWVsZCBpcyBpbXBsaWVkIHRvIGJlIHRoZSBwcmltYXJ5XG4gICAgLy8gc29ydCBmaWVsZCwgdW5sZXNzIGl0J3MgbWFudWFsbHkgc3BlY2lmaWVkXG5cblxuICAgIGlmIChzZWFyY2gucXVlcnkpIHtcbiAgICAgIGltcGxpY2l0X3Njb3JlID0gdHJ1ZTtcblxuICAgICAgZm9yIChsZXQgZmxkIG9mIHNvcnRfZmxkcykge1xuICAgICAgICBpZiAoZmxkLmZpZWxkID09PSAnJHNjb3JlJykge1xuICAgICAgICAgIGltcGxpY2l0X3Njb3JlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGltcGxpY2l0X3Njb3JlKSB7XG4gICAgICAgIHNvcnRfZmxkcy51bnNoaWZ0KHtcbiAgICAgICAgICBmaWVsZDogJyRzY29yZScsXG4gICAgICAgICAgZGlyZWN0aW9uOiAnZGVzYydcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIHdpdGhvdXQgYSBzZWFyY2gucXVlcnksIGFsbCBpdGVtcyB3aWxsIGhhdmUgdGhlIHNhbWUgc2NvcmVcblxuICAgIH0gZWxzZSB7XG4gICAgICBzb3J0X2ZsZHMgPSBzb3J0X2ZsZHMuZmlsdGVyKGZsZCA9PiBmbGQuZmllbGQgIT09ICckc2NvcmUnKTtcbiAgICB9IC8vIGJ1aWxkIGZ1bmN0aW9uXG5cblxuICAgIGNvbnN0IHNvcnRfZmxkc19jb3VudCA9IHNvcnRfZmxkcy5sZW5ndGg7XG5cbiAgICBpZiAoIXNvcnRfZmxkc19jb3VudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgcmVzdWx0LCBmaWVsZDtcblxuICAgICAgZm9yIChsZXQgc29ydF9mbGQgb2Ygc29ydF9mbGRzKSB7XG4gICAgICAgIGZpZWxkID0gc29ydF9mbGQuZmllbGQ7XG4gICAgICAgIGxldCBtdWx0aXBsaWVyID0gc29ydF9mbGQuZGlyZWN0aW9uID09PSAnZGVzYycgPyAtMSA6IDE7XG4gICAgICAgIHJlc3VsdCA9IG11bHRpcGxpZXIgKiBjbXAoZ2V0X2ZpZWxkKGZpZWxkLCBhKSwgZ2V0X2ZpZWxkKGZpZWxkLCBiKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgc2VhcmNoIHF1ZXJ5IGFuZCByZXR1cm5zIGFuIG9iamVjdFxuICAgKiB3aXRoIHRva2VucyBhbmQgZmllbGRzIHJlYWR5IHRvIGJlIHBvcHVsYXRlZFxuICAgKiB3aXRoIHJlc3VsdHMuXG4gICAqXG4gICAqL1xuICBwcmVwYXJlU2VhcmNoKHF1ZXJ5LCBvcHRzVXNlcikge1xuICAgIGNvbnN0IHdlaWdodHMgPSB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHNVc2VyKTtcbiAgICBwcm9wVG9BcnJheShvcHRpb25zLCAnc29ydCcpO1xuICAgIHByb3BUb0FycmF5KG9wdGlvbnMsICdzb3J0X2VtcHR5Jyk7IC8vIGNvbnZlcnQgZmllbGRzIHRvIG5ldyBmb3JtYXRcblxuICAgIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgICAgcHJvcFRvQXJyYXkob3B0aW9ucywgJ2ZpZWxkcycpO1xuICAgICAgY29uc3QgZmllbGRzID0gW107XG4gICAgICBvcHRpb25zLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGZpZWxkID0ge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgd2VpZ2h0OiAxXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgd2VpZ2h0c1tmaWVsZC5maWVsZF0gPSAnd2VpZ2h0JyBpbiBmaWVsZCA/IGZpZWxkLndlaWdodCA6IDE7XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbnMuZmllbGRzID0gZmllbGRzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgcXVlcnk6IHF1ZXJ5LnRvTG93ZXJDYXNlKCkudHJpbSgpLFxuICAgICAgdG9rZW5zOiB0aGlzLnRva2VuaXplKHF1ZXJ5LCBvcHRpb25zLnJlc3BlY3Rfd29yZF9ib3VuZGFyaWVzLCB3ZWlnaHRzKSxcbiAgICAgIHRvdGFsOiAwLFxuICAgICAgaXRlbXM6IFtdLFxuICAgICAgd2VpZ2h0czogd2VpZ2h0cyxcbiAgICAgIGdldEF0dHJGbjogb3B0aW9ucy5uZXN0aW5nID8gZ2V0QXR0ck5lc3RpbmcgOiBnZXRBdHRyXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyB0aHJvdWdoIGFsbCBpdGVtcyBhbmQgcmV0dXJucyBhIHNvcnRlZCBhcnJheSBvZiBtYXRjaGVzLlxuICAgKlxuICAgKi9cbiAgc2VhcmNoKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBzY29yZSxcbiAgICAgICAgc2VhcmNoO1xuICAgIHNlYXJjaCA9IHRoaXMucHJlcGFyZVNlYXJjaChxdWVyeSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IHNlYXJjaC5vcHRpb25zO1xuICAgIHF1ZXJ5ID0gc2VhcmNoLnF1ZXJ5OyAvLyBnZW5lcmF0ZSByZXN1bHQgc2NvcmluZyBmdW5jdGlvblxuXG4gICAgY29uc3QgZm5fc2NvcmUgPSBvcHRpb25zLnNjb3JlIHx8IHNlbGYuX2dldFNjb3JlRnVuY3Rpb24oc2VhcmNoKTsgLy8gcGVyZm9ybSBzZWFyY2ggYW5kIHNvcnRcblxuXG4gICAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgaXRlcmF0ZShzZWxmLml0ZW1zLCAoaXRlbSwgaWQpID0+IHtcbiAgICAgICAgc2NvcmUgPSBmbl9zY29yZShpdGVtKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIgPT09IGZhbHNlIHx8IHNjb3JlID4gMCkge1xuICAgICAgICAgIHNlYXJjaC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICdzY29yZSc6IHNjb3JlLFxuICAgICAgICAgICAgJ2lkJzogaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGUoc2VsZi5pdGVtcywgKF8sIGlkKSA9PiB7XG4gICAgICAgIHNlYXJjaC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAnc2NvcmUnOiAxLFxuICAgICAgICAgICdpZCc6IGlkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZm5fc29ydCA9IHNlbGYuX2dldFNvcnRGdW5jdGlvbihzZWFyY2gpO1xuXG4gICAgaWYgKGZuX3NvcnQpIHNlYXJjaC5pdGVtcy5zb3J0KGZuX3NvcnQpOyAvLyBhcHBseSBsaW1pdHNcblxuICAgIHNlYXJjaC50b3RhbCA9IHNlYXJjaC5pdGVtcy5sZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubGltaXQgPT09ICdudW1iZXInKSB7XG4gICAgICBzZWFyY2guaXRlbXMgPSBzZWFyY2guaXRlbXMuc2xpY2UoMCwgb3B0aW9ucy5saW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlYXJjaDtcbiAgfVxuXG59XG5cbmV4cG9ydCB7IFNpZnRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lmdGVyLmpzLm1hcFxuIiwgIlxuaW1wb3J0IHsgYXNjaWlmb2xkIH0gZnJvbSAnQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMnO1xuaW1wb3J0ICogYXMgVCBmcm9tICcuL3R5cGVzJztcblxuXG4vKipcbiAqIEEgcHJvcGVydHkgZ2V0dGVyIHJlc29sdmluZyBkb3Qtbm90YXRpb25cbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiAgICAgVGhlIHJvb3Qgb2JqZWN0IHRvIGZldGNoIHByb3BlcnR5IG9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgIFRoZSBvcHRpb25hbGx5IGRvdHRlZCBwcm9wZXJ0eSBuYW1lIHRvIGZldGNoXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIFRoZSByZXNvbHZlZCBwcm9wZXJ0eSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0QXR0ciA9IChvYmo6e1trZXk6c3RyaW5nXTphbnl9LCBuYW1lOnN0cmluZyApID0+IHtcbiAgICBpZiAoIW9iaiApIHJldHVybjtcbiAgICByZXR1cm4gb2JqW25hbWVdO1xufTtcblxuLyoqXG4gKiBBIHByb3BlcnR5IGdldHRlciByZXNvbHZpbmcgZG90LW5vdGF0aW9uXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogICAgIFRoZSByb290IG9iamVjdCB0byBmZXRjaCBwcm9wZXJ0eSBvblxuICogQHBhcmFtICB7U3RyaW5nfSAgbmFtZSAgICBUaGUgb3B0aW9uYWxseSBkb3R0ZWQgcHJvcGVydHkgbmFtZSB0byBmZXRjaFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICBUaGUgcmVzb2x2ZWQgcHJvcGVydHkgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEF0dHJOZXN0aW5nID0gKG9iajp7W2tleTpzdHJpbmddOmFueX0sIG5hbWU6c3RyaW5nICkgPT4ge1xuICAgIGlmICghb2JqICkgcmV0dXJuO1xuICAgIHZhciBwYXJ0LCBuYW1lcyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuXHR3aGlsZSggKHBhcnQgPSBuYW1lcy5zaGlmdCgpKSAmJiAob2JqID0gb2JqW3BhcnRdKSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBob3cgY2xvc2Ugb2YgYSBtYXRjaCB0aGVcbiAqIGdpdmVuIHZhbHVlIGlzIGFnYWluc3QgYSBzZWFyY2ggdG9rZW4uXG4gKlxuICovXG5leHBvcnQgY29uc3Qgc2NvcmVWYWx1ZSA9ICh2YWx1ZTpzdHJpbmcsIHRva2VuOlQuVG9rZW4sIHdlaWdodDpudW1iZXIgKTpudW1iZXIgPT4ge1xuXHR2YXIgc2NvcmUsIHBvcztcblxuXHRpZiAoIXZhbHVlKSByZXR1cm4gMDtcblxuXHR2YWx1ZSA9IHZhbHVlICsgJyc7XG5cdGlmKCB0b2tlbi5yZWdleCA9PSBudWxsICkgcmV0dXJuIDA7XG5cdHBvcyA9IHZhbHVlLnNlYXJjaCh0b2tlbi5yZWdleCk7XG5cdGlmIChwb3MgPT09IC0xKSByZXR1cm4gMDtcblxuXHRzY29yZSA9IHRva2VuLnN0cmluZy5sZW5ndGggLyB2YWx1ZS5sZW5ndGg7XG5cdGlmIChwb3MgPT09IDApIHNjb3JlICs9IDAuNTtcblxuXHRyZXR1cm4gc2NvcmUgKiB3ZWlnaHQ7XG59O1xuXG5cbi8qKlxuICogQ2FzdCBvYmplY3QgcHJvcGVydHkgdG8gYW4gYXJyYXkgaWYgaXQgZXhpc3RzIGFuZCBoYXMgYSB2YWx1ZVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHByb3BUb0FycmF5ID0gKG9iajp7W2tleTpzdHJpbmddOmFueX0sIGtleTpzdHJpbmcpID0+IHtcblx0dmFyIHZhbHVlID0gb2JqW2tleV07XG5cblx0aWYoIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nICkgcmV0dXJuIHZhbHVlO1xuXG5cdGlmKCB2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgKXtcblx0XHRvYmpba2V5XSA9IFt2YWx1ZV07XG5cdH1cbn1cblxuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgYXJyYXlzIGFuZCBoYXNoZXMuXG4gKlxuICogYGBgXG4gKiBpdGVyYXRlKHRoaXMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGlkKSB7XG4gKiAgICAvLyBpbnZva2VkIGZvciBlYWNoIGl0ZW1cbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5leHBvcnQgY29uc3QgaXRlcmF0ZSA9IChvYmplY3Q6W118e1trZXk6c3RyaW5nXTphbnl9LCBjYWxsYmFjazoodmFsdWU6YW55LGtleTphbnkpPT5hbnkpID0+IHtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuXHRcdG9iamVjdC5mb3JFYWNoKGNhbGxiYWNrKTtcblxuXHR9ZWxzZXtcblxuXHRcdGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcblx0XHRcdGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cblxuXG5leHBvcnQgY29uc3QgY21wID0gKGE6bnVtYmVyfHN0cmluZywgYjpudW1iZXJ8c3RyaW5nKSA9PiB7XG5cdGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInKSB7XG5cdFx0cmV0dXJuIGEgPiBiID8gMSA6IChhIDwgYiA/IC0xIDogMCk7XG5cdH1cblx0YSA9IGFzY2lpZm9sZChhICsgJycpLnRvTG93ZXJDYXNlKCk7XG5cdGIgPSBhc2NpaWZvbGQoYiArICcnKS50b0xvd2VyQ2FzZSgpO1xuXHRpZiAoYSA+IGIpIHJldHVybiAxO1xuXHRpZiAoYiA+IGEpIHJldHVybiAtMTtcblx0cmV0dXJuIDA7XG59O1xuIiwgIlxuaW1wb3J0IHsgaXRlcmF0ZSB9IGZyb20gJ0BvcmNoaWRqcy9zaWZ0ZXIvbGliL3V0aWxzJztcblxuLyoqXG4gKiBSZXR1cm4gYSBkb20gZWxlbWVudCBmcm9tIGVpdGhlciBhIGRvbSBxdWVyeSBzdHJpbmcsIGpRdWVyeSBvYmplY3QsIGEgZG9tIGVsZW1lbnQgb3IgaHRtbCBzdHJpbmdcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5NDE0My9jcmVhdGluZy1hLW5ldy1kb20tZWxlbWVudC1mcm9tLWFuLWh0bWwtc3RyaW5nLXVzaW5nLWJ1aWx0LWluLWRvbS1tZXRob2RzLW9yLXByby8zNTM4NTUxOCMzNTM4NTUxOFxuICpcbiAqIHBhcmFtIHF1ZXJ5IHNob3VsZCBiZSB7fVxuICovXG5leHBvcnQgY29uc3QgZ2V0RG9tID0gKCBxdWVyeTphbnkgKTpIVE1MRWxlbWVudCA9PiB7XG5cblx0aWYoIHF1ZXJ5LmpxdWVyeSApe1xuXHRcdHJldHVybiBxdWVyeVswXTtcblx0fVxuXG5cdGlmKCBxdWVyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICl7XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9XG5cblx0aWYoIGlzSHRtbFN0cmluZyhxdWVyeSkgKXtcblx0XHR2YXIgdHBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcblx0XHR0cGwuaW5uZXJIVE1MID0gcXVlcnkudHJpbSgpOyAvLyBOZXZlciByZXR1cm4gYSB0ZXh0IG5vZGUgb2Ygd2hpdGVzcGFjZSBhcyB0aGUgcmVzdWx0XG5cdFx0cmV0dXJuIHRwbC5jb250ZW50LmZpcnN0Q2hpbGQgYXMgSFRNTEVsZW1lbnQ7XG5cdH1cblxuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNIdG1sU3RyaW5nID0gKGFyZzphbnkpOiBib29sZWFuID0+IHtcblx0aWYoIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy5pbmRleE9mKCc8JykgPiAtMSApe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGNvbnN0IGVzY2FwZVF1ZXJ5ID0gKHF1ZXJ5OnN0cmluZyk6c3RyaW5nID0+IHtcblx0cmV0dXJuIHF1ZXJ5LnJlcGxhY2UoL1snXCJcXFxcXS9nLCAnXFxcXCQmJyk7XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYW4gZXZlbnRcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCB0cmlnZ2VyRXZlbnQgPSAoIGRvbV9lbDpIVE1MRWxlbWVudCwgZXZlbnRfbmFtZTpzdHJpbmcgKTp2b2lkID0+IHtcblx0dmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcblx0ZXZlbnQuaW5pdEV2ZW50KGV2ZW50X25hbWUsIHRydWUsIGZhbHNlKTtcblx0ZG9tX2VsLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG59O1xuXG4vKipcbiAqIEFwcGx5IENTUyBydWxlcyB0byBhIGRvbSBlbGVtZW50XG4gKlxuICovXG5leHBvcnQgY29uc3QgYXBwbHlDU1MgPSAoIGRvbV9lbDpIVE1MRWxlbWVudCwgY3NzOnsgW2tleTogc3RyaW5nXTogc3RyaW5nfG51bWJlciB9KTp2b2lkID0+IHtcblx0T2JqZWN0LmFzc2lnbihkb21fZWwuc3R5bGUsIGNzcyk7XG59XG5cblxuLyoqXG4gKiBBZGQgY3NzIGNsYXNzZXNcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRDbGFzc2VzID0gKCBlbG10czpIVE1MRWxlbWVudHxIVE1MRWxlbWVudFtdLCAuLi5jbGFzc2VzOnN0cmluZ1tdfHN0cmluZ1tdW10gKSA9PiB7XG5cblx0dmFyIG5vcm1fY2xhc3NlcyBcdD0gY2xhc3Nlc0FycmF5KGNsYXNzZXMpO1xuXHRlbG10c1x0XHRcdFx0PSBjYXN0QXNBcnJheShlbG10cyk7XG5cblx0ZWxtdHMubWFwKCBlbCA9PiB7XG5cdFx0bm9ybV9jbGFzc2VzLm1hcCggY2xzID0+IHtcblx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoIGNscyApO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgY3NzIGNsYXNzZXNcbiAqXG4gKi9cbiBleHBvcnQgY29uc3QgcmVtb3ZlQ2xhc3NlcyA9ICggZWxtdHM6SFRNTEVsZW1lbnR8SFRNTEVsZW1lbnRbXSwgLi4uY2xhc3NlczpzdHJpbmdbXXxzdHJpbmdbXVtdICkgPT4ge1xuXG4gXHR2YXIgbm9ybV9jbGFzc2VzIFx0PSBjbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG5cdGVsbXRzXHRcdFx0XHQ9IGNhc3RBc0FycmF5KGVsbXRzKTtcblxuXHRlbG10cy5tYXAoIGVsID0+IHtcblx0XHRub3JtX2NsYXNzZXMubWFwKGNscyA9PiB7XG5cdCBcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZSggY2xzICk7XG5cdFx0fSk7XG4gXHR9KTtcbiB9XG5cblxuLyoqXG4gKiBSZXR1cm4gYXJndW1lbnRzXG4gKlxuICovXG5leHBvcnQgY29uc3QgY2xhc3Nlc0FycmF5ID0gKGFyZ3M6c3RyaW5nW118c3RyaW5nW11bXSk6c3RyaW5nW10gPT4ge1xuXHR2YXIgY2xhc3NlczpzdHJpbmdbXSA9IFtdO1xuXHRpdGVyYXRlKCBhcmdzLCAoX2NsYXNzZXMpID0+e1xuXHRcdGlmKCB0eXBlb2YgX2NsYXNzZXMgPT09ICdzdHJpbmcnICl7XG5cdFx0XHRfY2xhc3NlcyA9IF9jbGFzc2VzLnRyaW0oKS5zcGxpdCgvW1xcMTFcXDEyXFwxNFxcMTVcXDQwXS8pO1xuXHRcdH1cblx0XHRpZiggQXJyYXkuaXNBcnJheShfY2xhc3NlcykgKXtcblx0XHRcdGNsYXNzZXMgPSBjbGFzc2VzLmNvbmNhdChfY2xhc3Nlcyk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gY2xhc3Nlcy5maWx0ZXIoQm9vbGVhbik7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgZnJvbSBhcmcgaWYgaXQncyBub3QgYWxyZWFkeSBhbiBhcnJheVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGNhc3RBc0FycmF5ID0gKGFyZzphbnkpOkFycmF5PGFueT4gPT4ge1xuXHRpZiggIUFycmF5LmlzQXJyYXkoYXJnKSApe1xuIFx0XHRhcmcgPSBbYXJnXTtcbiBcdH1cblx0cmV0dXJuIGFyZztcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgY2xvc2VzdCBub2RlIHRvIHRoZSBldnQudGFyZ2V0IG1hdGNoaW5nIHRoZSBzZWxlY3RvclxuICogU3RvcHMgYXQgd3JhcHBlclxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcmVudE1hdGNoID0gKCB0YXJnZXQ6bnVsbHxIVE1MRWxlbWVudCwgc2VsZWN0b3I6c3RyaW5nLCB3cmFwcGVyPzpIVE1MRWxlbWVudCApOkhUTUxFbGVtZW50fHZvaWQgPT4ge1xuXG5cdGlmKCB3cmFwcGVyICYmICF3cmFwcGVyLmNvbnRhaW5zKHRhcmdldCkgKXtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR3aGlsZSggdGFyZ2V0ICYmIHRhcmdldC5tYXRjaGVzICl7XG5cblx0XHRpZiggdGFyZ2V0Lm1hdGNoZXMoc2VsZWN0b3IpICl7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50O1xuXHR9XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IG9yIGxhc3QgaXRlbSBmcm9tIGFuIGFycmF5XG4gKlxuICogPiAwIC0gcmlnaHQgKGxhc3QpXG4gKiA8PSAwIC0gbGVmdCAoZmlyc3QpXG4gKlxuICovXG5leHBvcnQgY29uc3QgZ2V0VGFpbCA9ICggbGlzdDpBcnJheTxhbnk+fE5vZGVMaXN0LCBkaXJlY3Rpb246bnVtYmVyPTAgKTphbnkgPT4ge1xuXG5cdGlmKCBkaXJlY3Rpb24gPiAwICl7XG5cdFx0cmV0dXJuIGxpc3RbbGlzdC5sZW5ndGgtMV07XG5cdH1cblxuXHRyZXR1cm4gbGlzdFswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBhbiBvYmplY3QgaXMgZW1wdHlcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBpc0VtcHR5T2JqZWN0ID0gKG9iajpvYmplY3QpOmJvb2xlYW4gPT4ge1xuXHRyZXR1cm4gKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwKTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCBhbW9uZ3N0IHNpYmxpbmcgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IG5vZGVJbmRleCA9ICggZWw6bnVsbHxFbGVtZW50LCBhbW9uZ3N0PzpzdHJpbmcgKTpudW1iZXIgPT4ge1xuXHRpZiAoIWVsKSByZXR1cm4gLTE7XG5cblx0YW1vbmdzdCA9IGFtb25nc3QgfHwgZWwubm9kZU5hbWU7XG5cblx0dmFyIGkgPSAwO1xuXHR3aGlsZSggZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICl7XG5cblx0XHRpZiggZWwubWF0Y2hlcyhhbW9uZ3N0KSApe1xuXHRcdFx0aSsrO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gaTtcbn1cblxuXG4vKipcbiAqIFNldCBhdHRyaWJ1dGVzIG9mIGFuIGVsZW1lbnRcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRBdHRyID0gKGVsOkVsZW1lbnQsYXR0cnM6eyBba2V5OiBzdHJpbmddOiBudWxsfHN0cmluZ3xudW1iZXIgfSkgPT4ge1xuXHRpdGVyYXRlKCBhdHRycywodmFsLGF0dHIpID0+IHtcblx0XHRpZiggdmFsID09IG51bGwgKXtcblx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyIGFzIHN0cmluZyk7XG5cdFx0fWVsc2V7XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGUoYXR0ciBhcyBzdHJpbmcsICcnK3ZhbCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuXG4vKipcbiAqIFJlcGxhY2UgYSBub2RlXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsYWNlTm9kZSA9ICggZXhpc3Rpbmc6Tm9kZSwgcmVwbGFjZW1lbnQ6Tm9kZSApID0+IHtcblx0aWYoIGV4aXN0aW5nLnBhcmVudE5vZGUgKSBleGlzdGluZy5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudCwgZXhpc3RpbmcpO1xufVxuIiwgIi8qKlxuICogaGlnaGxpZ2h0IHYzIHwgTUlUIGxpY2Vuc2UgfCBKb2hhbm4gQnVya2FyZCA8amJAZWFpby5jb20+XG4gKiBIaWdobGlnaHRzIGFyYml0cmFyeSB0ZXJtcyBpbiBhIG5vZGUuXG4gKlxuICogLSBNb2RpZmllZCBieSBNYXJzaGFsIDxiZWF0Z2F0ZXNAZ21haWwuY29tPiAyMDExLTYtMjQgKGFkZGVkIHJlZ2V4KVxuICogLSBNb2RpZmllZCBieSBCcmlhbiBSZWF2aXMgPGJyaWFuQHRoaXJkcm91dGUuY29tPiAyMDEyLTgtMjcgKGNsZWFudXApXG4gKi9cblxuaW1wb3J0IHtyZXBsYWNlTm9kZX0gZnJvbSAnLi4vdmFuaWxsYSc7XG5cblxuZXhwb3J0IGNvbnN0IGhpZ2hsaWdodCA9IChlbGVtZW50OkhUTUxFbGVtZW50LCByZWdleDpzdHJpbmd8UmVnRXhwKSA9PiB7XG5cblx0aWYoIHJlZ2V4ID09PSBudWxsICkgcmV0dXJuO1xuXG5cdC8vIGNvbnZldCBzdHJpbmcgdG8gcmVnZXhcblx0aWYoIHR5cGVvZiByZWdleCA9PT0gJ3N0cmluZycgKXtcblxuXHRcdGlmKCAhcmVnZXgubGVuZ3RoICkgcmV0dXJuO1xuXHRcdHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleCwgJ2knKTtcblx0fVxuXG5cblx0Ly8gV3JhcCBtYXRjaGluZyBwYXJ0IG9mIHRleHQgbm9kZSB3aXRoIGhpZ2hsaWdodGluZyA8c3Bhbj4sIGUuZy5cblx0Ly8gU29jY2VyICAtPiAgPHNwYW4gY2xhc3M9XCJoaWdobGlnaHRcIj5Tb2M8L3NwYW4+Y2VyICBmb3IgcmVnZXggPSAvc29jL2lcblx0Y29uc3QgaGlnaGxpZ2h0VGV4dCA9ICggbm9kZTpUZXh0ICk6bnVtYmVyID0+IHtcblxuXHRcdHZhciBtYXRjaCA9IG5vZGUuZGF0YS5tYXRjaChyZWdleCk7XG5cdFx0aWYoIG1hdGNoICYmIG5vZGUuZGF0YS5sZW5ndGggPiAwICl7XG5cdFx0XHR2YXIgc3Bhbm5vZGVcdFx0PSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdFx0XHRzcGFubm9kZS5jbGFzc05hbWVcdD0gJ2hpZ2hsaWdodCc7XG5cdFx0XHR2YXIgbWlkZGxlYml0XHRcdD0gbm9kZS5zcGxpdFRleHQobWF0Y2guaW5kZXggYXMgbnVtYmVyKTtcblxuXHRcdFx0bWlkZGxlYml0LnNwbGl0VGV4dChtYXRjaFswXSEubGVuZ3RoKTtcblx0XHRcdHZhciBtaWRkbGVjbG9uZVx0XHQ9IG1pZGRsZWJpdC5jbG9uZU5vZGUodHJ1ZSk7XG5cblx0XHRcdHNwYW5ub2RlLmFwcGVuZENoaWxkKG1pZGRsZWNsb25lKTtcblx0XHRcdHJlcGxhY2VOb2RlKG1pZGRsZWJpdCwgc3Bhbm5vZGUpO1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cblx0Ly8gUmVjdXJzZSBlbGVtZW50IG5vZGUsIGxvb2tpbmcgZm9yIGNoaWxkIHRleHQgbm9kZXMgdG8gaGlnaGxpZ2h0LCB1bmxlc3MgZWxlbWVudFxuXHQvLyBpcyBjaGlsZGxlc3MsIDxzY3JpcHQ+LCA8c3R5bGU+LCBvciBhbHJlYWR5IGhpZ2hsaWdodGVkOiA8c3BhbiBjbGFzcz1cImhpZ2h0bGlnaHRcIj5cblx0Y29uc3QgaGlnaGxpZ2h0Q2hpbGRyZW4gPSAoIG5vZGU6RWxlbWVudCApOnZvaWQgPT4ge1xuXHRcdGlmKCBub2RlLm5vZGVUeXBlID09PSAxICYmIG5vZGUuY2hpbGROb2RlcyAmJiAhLyhzY3JpcHR8c3R5bGUpL2kudGVzdChub2RlLnRhZ05hbWUpICYmICggbm9kZS5jbGFzc05hbWUgIT09ICdoaWdobGlnaHQnIHx8IG5vZGUudGFnTmFtZSAhPT0gJ1NQQU4nICkgKXtcblx0XHRcdEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0XHRoaWdobGlnaHRSZWN1cnNpdmUoZWxlbWVudCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblxuXHRjb25zdCBoaWdobGlnaHRSZWN1cnNpdmUgPSAoIG5vZGU6Tm9kZXxFbGVtZW50ICk6bnVtYmVyID0+IHtcblxuXHRcdGlmKCBub2RlLm5vZGVUeXBlID09PSAzICl7XG5cdFx0XHRyZXR1cm4gaGlnaGxpZ2h0VGV4dChub2RlIGFzIFRleHQpO1xuXHRcdH1cblxuXHRcdGhpZ2hsaWdodENoaWxkcmVuKG5vZGUgYXMgRWxlbWVudCk7XG5cblx0XHRyZXR1cm4gMDtcblx0fTtcblxuXHRoaWdobGlnaHRSZWN1cnNpdmUoIGVsZW1lbnQgKTtcbn07XG5cbi8qKlxuICogcmVtb3ZlSGlnaGxpZ2h0IGZuIGNvcGllZCBmcm9tIGhpZ2hsaWdodCB2NSBhbmRcbiAqIGVkaXRlZCB0byByZW1vdmUgd2l0aCgpLCBwYXNzIGpzIHN0cmljdCBtb2RlLCBhbmQgdXNlIHdpdGhvdXQganF1ZXJ5XG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVIaWdobGlnaHQgPSAoZWw6SFRNTEVsZW1lbnQpID0+IHtcblx0dmFyIGVsZW1lbnRzID0gZWwucXVlcnlTZWxlY3RvckFsbChcInNwYW4uaGlnaGxpZ2h0XCIpO1xuXHRBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsZW1lbnRzLCBmdW5jdGlvbihlbDpIVE1MRWxlbWVudCl7XG5cdFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGUgYXMgTm9kZTtcblx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKGVsLmZpcnN0Q2hpbGQgYXMgTm9kZSwgZWwpO1xuXHRcdHBhcmVudC5ub3JtYWxpemUoKTtcblx0fSk7XG59O1xuIiwgImV4cG9ydCBjb25zdCBLRVlfQVx0XHRcdFx0PSA2NTtcbmV4cG9ydCBjb25zdCBLRVlfUkVUVVJOXHRcdFx0PSAxMztcbmV4cG9ydCBjb25zdCBLRVlfRVNDXHRcdFx0PSAyNztcbmV4cG9ydCBjb25zdCBLRVlfTEVGVFx0XHRcdD0gMzc7XG5leHBvcnQgY29uc3QgS0VZX1VQXHRcdFx0XHQ9IDM4O1xuZXhwb3J0IGNvbnN0IEtFWV9SSUdIVFx0XHRcdD0gMzk7XG5leHBvcnQgY29uc3QgS0VZX0RPV05cdFx0XHQ9IDQwO1xuZXhwb3J0IGNvbnN0IEtFWV9CQUNLU1BBQ0VcdFx0PSA4O1xuZXhwb3J0IGNvbnN0IEtFWV9ERUxFVEVcdFx0XHQ9IDQ2O1xuZXhwb3J0IGNvbnN0IEtFWV9UQUJcdFx0XHQ9IDk7XG5cbmV4cG9ydCBjb25zdCBJU19NQUMgICAgICBcdFx0PSB0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogL01hYy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmV4cG9ydCBjb25zdCBLRVlfU0hPUlRDVVRcdFx0PSBJU19NQUMgPyAnbWV0YUtleScgOiAnY3RybEtleSc7IC8vIGN0cmwga2V5IG9yIGFwcGxlIGtleSBmb3IgbWFcbiIsICJcbmV4cG9ydCBkZWZhdWx0IHtcblx0b3B0aW9uczogW10sXG5cdG9wdGdyb3VwczogW10sXG5cblx0cGx1Z2luczogW10sXG5cdGRlbGltaXRlcjogJywnLFxuXHRzcGxpdE9uOiBudWxsLCAvLyByZWdleHAgb3Igc3RyaW5nIGZvciBzcGxpdHRpbmcgdXAgdmFsdWVzIGZyb20gYSBwYXN0ZSBjb21tYW5kXG5cdHBlcnNpc3Q6IHRydWUsXG5cdGRpYWNyaXRpY3M6IHRydWUsXG5cdGNyZWF0ZTogbnVsbCxcblx0Y3JlYXRlT25CbHVyOiBmYWxzZSxcblx0Y3JlYXRlRmlsdGVyOiBudWxsLFxuXHRoaWdobGlnaHQ6IHRydWUsXG5cdG9wZW5PbkZvY3VzOiB0cnVlLFxuXHRzaG91bGRPcGVuOiBudWxsLFxuXHRtYXhPcHRpb25zOiA1MCxcblx0bWF4SXRlbXM6IG51bGwsXG5cdGhpZGVTZWxlY3RlZDogbnVsbCxcblx0ZHVwbGljYXRlczogZmFsc2UsXG5cdGFkZFByZWNlZGVuY2U6IGZhbHNlLFxuXHRzZWxlY3RPblRhYjogZmFsc2UsXG5cdHByZWxvYWQ6IG51bGwsXG5cdGFsbG93RW1wdHlPcHRpb246IGZhbHNlLFxuXHQvL2Nsb3NlQWZ0ZXJTZWxlY3Q6IGZhbHNlLFxuXHRyZWZyZXNoVGhyb3R0bGU6IDMwMCxcblxuXG5cdGxvYWRUaHJvdHRsZTogMzAwLFxuXHRsb2FkaW5nQ2xhc3M6ICdsb2FkaW5nJyxcblxuXHRkYXRhQXR0cjogbnVsbCwgLy8nZGF0YS1kYXRhJyxcblx0b3B0Z3JvdXBGaWVsZDogJ29wdGdyb3VwJyxcblx0dmFsdWVGaWVsZDogJ3ZhbHVlJyxcblx0bGFiZWxGaWVsZDogJ3RleHQnLFxuXHRkaXNhYmxlZEZpZWxkOiAnZGlzYWJsZWQnLFxuXHRvcHRncm91cExhYmVsRmllbGQ6ICdsYWJlbCcsXG5cdG9wdGdyb3VwVmFsdWVGaWVsZDogJ3ZhbHVlJyxcblx0bG9ja09wdGdyb3VwT3JkZXI6IGZhbHNlLFxuXG5cdHNvcnRGaWVsZDogJyRvcmRlcicsXG5cdHNlYXJjaEZpZWxkOiBbJ3RleHQnXSxcblx0c2VhcmNoQ29uanVuY3Rpb246ICdhbmQnLFxuXG5cdG1vZGU6IG51bGwsXG5cdHdyYXBwZXJDbGFzczogJ3RzLXdyYXBwZXInLFxuXHRjb250cm9sQ2xhc3M6ICd0cy1jb250cm9sJyxcblx0ZHJvcGRvd25DbGFzczogJ3RzLWRyb3Bkb3duJyxcblx0ZHJvcGRvd25Db250ZW50Q2xhc3M6ICd0cy1kcm9wZG93bi1jb250ZW50Jyxcblx0aXRlbUNsYXNzOiAnaXRlbScsXG5cdG9wdGlvbkNsYXNzOiAnb3B0aW9uJyxcblxuXHRkcm9wZG93blBhcmVudDogbnVsbCxcblx0Y29udHJvbElucHV0OiAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgc2l6ZT1cIjFcIiAvPicsXG5cblx0Y29weUNsYXNzZXNUb0Ryb3Bkb3duOiBmYWxzZSxcblxuXHRwbGFjZWhvbGRlcjogbnVsbCxcblx0aGlkZVBsYWNlaG9sZGVyOiBudWxsLFxuXG5cdHNob3VsZExvYWQ6IGZ1bmN0aW9uKHF1ZXJ5OnN0cmluZyk6Ym9vbGVhbntcblx0XHRyZXR1cm4gcXVlcnkubGVuZ3RoID4gMDtcblx0fSxcblxuXHQvKlxuXHRsb2FkICAgICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjaykgeyAuLi4gfVxuXHRzY29yZSAgICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHNlYXJjaCkgeyAuLi4gfVxuXHRvbkluaXRpYWxpemUgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuXHRvbkNoYW5nZSAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlKSB7IC4uLiB9XG5cdG9uSXRlbUFkZCAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUsICRpdGVtKSB7IC4uLiB9XG5cdG9uSXRlbVJlbW92ZSAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUpIHsgLi4uIH1cblx0b25DbGVhciAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbigpIHsgLi4uIH1cblx0b25PcHRpb25BZGQgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSwgZGF0YSkgeyAuLi4gfVxuXHRvbk9wdGlvblJlbW92ZSAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlKSB7IC4uLiB9XG5cdG9uT3B0aW9uQ2xlYXIgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oKSB7IC4uLiB9XG5cdG9uT3B0aW9uR3JvdXBBZGQgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oaWQsIGRhdGEpIHsgLi4uIH1cblx0b25PcHRpb25Hcm91cFJlbW92ZSAgOiBudWxsLCAvLyBmdW5jdGlvbihpZCkgeyAuLi4gfVxuXHRvbk9wdGlvbkdyb3VwQ2xlYXIgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuXHRvbkRyb3Bkb3duT3BlbiAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKGRyb3Bkb3duKSB7IC4uLiB9XG5cdG9uRHJvcGRvd25DbG9zZSAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oZHJvcGRvd24pIHsgLi4uIH1cblx0b25UeXBlICAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihzdHIpIHsgLi4uIH1cblx0b25EZWxldGUgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZXMpIHsgLi4uIH1cblx0Ki9cblxuXHRyZW5kZXI6IHtcblx0XHQvKlxuXHRcdGl0ZW06IG51bGwsXG5cdFx0b3B0Z3JvdXA6IG51bGwsXG5cdFx0b3B0Z3JvdXBfaGVhZGVyOiBudWxsLFxuXHRcdG9wdGlvbjogbnVsbCxcblx0XHRvcHRpb25fY3JlYXRlOiBudWxsXG5cdFx0Ki9cblx0fVxufTtcbiIsICJcbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi90b20tc2VsZWN0JztcbmltcG9ydCB7IFRvbUxvYWRDYWxsYmFjayB9IGZyb20gJy4vdHlwZXMvaW5kZXgnO1xuXG5cbi8qKlxuICogQ29udmVydHMgYSBzY2FsYXIgdG8gaXRzIGJlc3Qgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBmb3IgaGFzaCBrZXlzIGFuZCBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gKlxuICogVHJhbnNmb3JtYXRpb25zOlxuICogICAnc3RyJyAgICAgLT4gJ3N0cidcbiAqICAgbnVsbCAgICAgIC0+ICcnXG4gKiAgIHVuZGVmaW5lZCAtPiAnJ1xuICogICB0cnVlICAgICAgLT4gJzEnXG4gKiAgIGZhbHNlICAgICAtPiAnMCdcbiAqICAgMCAgICAgICAgIC0+ICcwJ1xuICogICAxICAgICAgICAgLT4gJzEnXG4gKlxuICovXG5leHBvcnQgY29uc3QgaGFzaF9rZXkgPSAodmFsdWU6dW5kZWZpbmVkfG51bGx8Ym9vbGVhbnxzdHJpbmd8bnVtYmVyKTpzdHJpbmd8bnVsbCA9PiB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gbnVsbDtcblx0cmV0dXJuIGdldF9oYXNoKHZhbHVlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRfaGFzaCA9ICh2YWx1ZTpib29sZWFufHN0cmluZ3xudW1iZXIpOnN0cmluZyA9PiB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuIHZhbHVlID8gJzEnIDogJzAnO1xuXHRyZXR1cm4gdmFsdWUgKyAnJztcbn07XG5cbi8qKlxuICogRXNjYXBlcyBhIHN0cmluZyBmb3IgdXNlIHdpdGhpbiBIVE1MLlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGVzY2FwZV9odG1sID0gKHN0cjpzdHJpbmcpOnN0cmluZyA9PiB7XG5cdHJldHVybiAoc3RyICsgJycpXG5cdFx0LnJlcGxhY2UoLyYvZywgJyZhbXA7Jylcblx0XHQucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdFx0LnJlcGxhY2UoLz4vZywgJyZndDsnKVxuXHRcdC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59O1xuXG5cbi8qKlxuICogdXNlIHNldFRpbWVvdXQgaWYgdGltZW91dCA+IDAgXG4gKi9cbmV4cG9ydCBjb25zdCB0aW1lb3V0ID0gKGZuOigpPT52b2lkLHRpbWVvdXQ6bnVtYmVyKSA9PiB7XG5cdGlmKCB0aW1lb3V0ID4gMCApe1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KGZuLHRpbWVvdXQpO1xuXHR9XG5cblx0Zm4uY2FsbChudWxsKTtcblx0cmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVib3VuY2UgdGhlIHVzZXIgcHJvdmlkZWQgbG9hZCBmdW5jdGlvblxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWREZWJvdW5jZSA9IChmbjoodmFsdWU6c3RyaW5nLGNhbGxiYWNrOlRvbUxvYWRDYWxsYmFjaykgPT4gdm9pZCxkZWxheTpudW1iZXIpID0+IHtcblx0dmFyIHRpbWVvdXQ6IG51bGx8UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD47XG5cdHJldHVybiBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCwgdmFsdWU6c3RyaW5nLGNhbGxiYWNrOlRvbUxvYWRDYWxsYmFjaykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGlmKCB0aW1lb3V0ICl7XG5cdFx0XHRzZWxmLmxvYWRpbmcgPSBNYXRoLm1heChzZWxmLmxvYWRpbmcgLSAxLCAwKTtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR9XG5cdFx0dGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aW1lb3V0ID0gbnVsbDtcblx0XHRcdHNlbGYubG9hZGVkU2VhcmNoZXNbdmFsdWVdID0gdHJ1ZTtcblx0XHRcdGZuLmNhbGwoc2VsZiwgdmFsdWUsIGNhbGxiYWNrKTtcblxuXHRcdH0sIGRlbGF5KTtcblx0fTtcbn07XG5cblxuLyoqXG4gKiBEZWJvdW5jZSBhbGwgZmlyZWQgZXZlbnRzIHR5cGVzIGxpc3RlZCBpbiBgdHlwZXNgXG4gKiB3aGlsZSBleGVjdXRpbmcgdGhlIHByb3ZpZGVkIGBmbmAuXG4gKlxuICovXG5leHBvcnQgY29uc3QgZGVib3VuY2VfZXZlbnRzID0gKCBzZWxmOlRvbVNlbGVjdCwgdHlwZXM6c3RyaW5nW10sIGZuOigpID0+IHZvaWQgKSA9PiB7XG5cdHZhciB0eXBlOnN0cmluZztcblx0dmFyIHRyaWdnZXIgPSBzZWxmLnRyaWdnZXI7XG5cdHZhciBldmVudF9hcmdzOnsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcblxuXHQvLyBvdmVycmlkZSB0cmlnZ2VyIG1ldGhvZFxuXHRzZWxmLnRyaWdnZXIgPSBmdW5jdGlvbigpe1xuXHRcdHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuXHRcdGlmICh0eXBlcy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuXHRcdFx0ZXZlbnRfYXJnc1t0eXBlXSA9IGFyZ3VtZW50cztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRyaWdnZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gaW52b2tlIHByb3ZpZGVkIGZ1bmN0aW9uXG5cdGZuLmFwcGx5KHNlbGYsIFtdKTtcblx0c2VsZi50cmlnZ2VyID0gdHJpZ2dlcjtcblxuXHQvLyB0cmlnZ2VyIHF1ZXVlZCBldmVudHNcblx0Zm9yKCB0eXBlIG9mIHR5cGVzICl7XG5cdFx0aWYoIHR5cGUgaW4gZXZlbnRfYXJncyApe1xuXHRcdFx0dHJpZ2dlci5hcHBseShzZWxmLCBldmVudF9hcmdzW3R5cGVdKTtcblx0XHR9XG5cdH1cbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB3aXRoaW4gYSB0ZXh0IGlucHV0IGNvbnRyb2wuXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nOlxuICogICAtIHN0YXJ0XG4gKiAgIC0gbGVuZ3RoXG4gKlxuICogTm90ZTogXCJzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kIC4uLiBhcHBseSBvbmx5IHRvIGlucHV0cyBvZiB0eXBlcyB0ZXh0LCBzZWFyY2gsIFVSTCwgdGVsIGFuZCBwYXNzd29yZFwiXG4gKiBcdC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxJbnB1dEVsZW1lbnQvc2V0U2VsZWN0aW9uUmFuZ2VcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNlbGVjdGlvbiA9IChpbnB1dDpIVE1MSW5wdXRFbGVtZW50KTp7IHN0YXJ0OiBudW1iZXI7IGxlbmd0aDogbnVtYmVyIH0gPT4ge1xuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0XHQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0IHx8IDAsXG5cdFx0bGVuZ3RoXHQ6IChpbnB1dC5zZWxlY3Rpb25FbmR8fDApIC0gKGlucHV0LnNlbGVjdGlvblN0YXJ0fHwwKSxcblx0fTtcbn07XG5cblxuLyoqXG4gKiBQcmV2ZW50IGRlZmF1bHRcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBwcmV2ZW50RGVmYXVsdCA9IChldnQ/OkV2ZW50LCBzdG9wOmJvb2xlYW49ZmFsc2UpOnZvaWQgPT4ge1xuXHRpZiggZXZ0ICl7XG5cdFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0aWYoIHN0b3AgKXtcblx0XHRcdGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIEFkZCBldmVudCBoZWxwZXJcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRFdmVudCA9ICh0YXJnZXQ6RXZlbnRUYXJnZXQsIHR5cGU6c3RyaW5nLCBjYWxsYmFjazpFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0LCBvcHRpb25zPzpvYmplY3QpOnZvaWQgPT4ge1xuXHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLGNhbGxiYWNrLG9wdGlvbnMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSByZXF1ZXN0ZWQga2V5IGlzIGRvd25cbiAqIFdpbGwgcmV0dXJuIGZhbHNlIGlmIG1vcmUgdGhhbiBvbmUgY29udHJvbCBjaGFyYWN0ZXIgaXMgcHJlc3NlZCAoIHdoZW4gW2N0cmwrc2hpZnQrYV0gIT0gW2N0cmwrYV0gKVxuICogVGhlIGN1cnJlbnQgZXZ0IG1heSBub3QgYWx3YXlzIHNldCAoIGVnIGNhbGxpbmcgYWR2YW5jZVNlbGVjdGlvbigpIClcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBpc0tleURvd24gPSAoIGtleV9uYW1lOmtleW9mIChLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnQpLCBldnQ/OktleWJvYXJkRXZlbnR8TW91c2VFdmVudCApID0+IHtcblxuXHRpZiggIWV2dCApe1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmKCAhZXZ0W2tleV9uYW1lXSApe1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBjb3VudCA9IChldnQuYWx0S2V5PzE6MCkgKyAoZXZ0LmN0cmxLZXk/MTowKSArIChldnQuc2hpZnRLZXk/MTowKSArIChldnQubWV0YUtleT8xOjApO1xuXG5cdGlmKCBjb3VudCA9PT0gMSApe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgaWQgb2YgYW4gZWxlbWVudFxuICogSWYgdGhlIGlkIGF0dHJpYnV0ZSBpcyBub3Qgc2V0LCBzZXQgdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBpZFxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGdldElkID0gKGVsOkVsZW1lbnQsaWQ6c3RyaW5nKSA9PiB7XG5cdGNvbnN0IGV4aXN0aW5nX2lkID0gZWwuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXHRpZiggZXhpc3RpbmdfaWQgKXtcblx0XHRyZXR1cm4gZXhpc3RpbmdfaWQ7XG5cdH1cblxuXHRlbC5zZXRBdHRyaWJ1dGUoJ2lkJyxpZCk7XG5cdHJldHVybiBpZDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYmFja3NsYXNoZXMgYWRkZWQgYmVmb3JlIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVzY2FwZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRTbGFzaGVzID0gKHN0cjpzdHJpbmcpOnN0cmluZyA9PiB7XG5cdHJldHVybiBzdHIucmVwbGFjZSgvW1xcXFxcIiddL2csICdcXFxcJCYnKTtcbn07XG5cbi8qKlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZCA9ICggcGFyZW50OkVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudCwgbm9kZTogc3RyaW5nfE5vZGV8bnVsbHx1bmRlZmluZWQgKTp2b2lkID0+e1xuXHRpZiggbm9kZSApIHBhcmVudC5hcHBlbmQobm9kZSk7XG59O1xuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzJztcbmltcG9ydCB7IGhhc2hfa2V5IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBUb21PcHRpb24sIFRvbVNldHRpbmdzLCBSZWN1cnNpdmVQYXJ0aWFsIH0gZnJvbSAnLi90eXBlcy9pbmRleCc7XG5pbXBvcnQgeyBpdGVyYXRlIH0gZnJvbSAnQG9yY2hpZGpzL3NpZnRlci9saWIvdXRpbHMnO1xuaW1wb3J0IHsgVG9tSW5wdXQgfSBmcm9tICcuL3R5cGVzL2luZGV4JztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTZXR0aW5ncyggaW5wdXQ6VG9tSW5wdXQsIHNldHRpbmdzX3VzZXI6UmVjdXJzaXZlUGFydGlhbDxUb21TZXR0aW5ncz4pOlRvbVNldHRpbmdze1xuXHR2YXIgc2V0dGluZ3M6VG9tU2V0dGluZ3NcdD0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHNldHRpbmdzX3VzZXIpO1xuXG5cdHZhciBhdHRyX2RhdGFcdFx0XHRcdD0gc2V0dGluZ3MuZGF0YUF0dHI7XG5cdHZhciBmaWVsZF9sYWJlbFx0XHRcdFx0PSBzZXR0aW5ncy5sYWJlbEZpZWxkO1xuXHR2YXIgZmllbGRfdmFsdWVcdFx0XHRcdD0gc2V0dGluZ3MudmFsdWVGaWVsZDtcblx0dmFyIGZpZWxkX2Rpc2FibGVkXHRcdFx0PSBzZXR0aW5ncy5kaXNhYmxlZEZpZWxkO1xuXHR2YXIgZmllbGRfb3B0Z3JvdXBcdFx0XHQ9IHNldHRpbmdzLm9wdGdyb3VwRmllbGQ7XG5cdHZhciBmaWVsZF9vcHRncm91cF9sYWJlbFx0PSBzZXR0aW5ncy5vcHRncm91cExhYmVsRmllbGQ7XG5cdHZhciBmaWVsZF9vcHRncm91cF92YWx1ZVx0PSBzZXR0aW5ncy5vcHRncm91cFZhbHVlRmllbGQ7XG5cblx0dmFyIHRhZ19uYW1lXHRcdFx0XHQ9IGlucHV0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0dmFyIHBsYWNlaG9sZGVyXHRcdFx0XHQ9IGlucHV0LmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSB8fCBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2Vob2xkZXInKTtcblxuXHRpZiAoIXBsYWNlaG9sZGVyICYmICFzZXR0aW5ncy5hbGxvd0VtcHR5T3B0aW9uKSB7XG5cdFx0bGV0IG9wdGlvblx0XHQ9IGlucHV0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvblt2YWx1ZT1cIlwiXScpO1xuXHRcdGlmKCBvcHRpb24gKXtcblx0XHRcdHBsYWNlaG9sZGVyID0gb3B0aW9uLnRleHRDb250ZW50O1xuXHRcdH1cblxuXHR9XG5cblx0dmFyIHNldHRpbmdzX2VsZW1lbnQ6e1xuXHRcdHBsYWNlaG9sZGVyXHQ6IG51bGx8c3RyaW5nLFxuXHRcdG9wdGlvbnNcdFx0OiBUb21PcHRpb25bXSxcblx0XHRvcHRncm91cHNcdDogVG9tT3B0aW9uW10sXG5cdFx0aXRlbXNcdFx0OiBzdHJpbmdbXSxcblx0XHRtYXhJdGVtc1x0OiBudWxsfG51bWJlcixcblx0fSA9IHtcblx0XHRwbGFjZWhvbGRlclx0OiBwbGFjZWhvbGRlcixcblx0XHRvcHRpb25zXHRcdDogW10sXG5cdFx0b3B0Z3JvdXBzXHQ6IFtdLFxuXHRcdGl0ZW1zXHRcdDogW10sXG5cdFx0bWF4SXRlbXNcdDogbnVsbCxcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGZyb20gYSA8c2VsZWN0PiBlbGVtZW50LlxuXHQgKlxuXHQgKi9cblx0dmFyIGluaXRfc2VsZWN0ID0gKCkgPT4ge1xuXHRcdHZhciB0YWdOYW1lO1xuXHRcdHZhciBvcHRpb25zID0gc2V0dGluZ3NfZWxlbWVudC5vcHRpb25zO1xuXHRcdHZhciBvcHRpb25zTWFwOntba2V5OnN0cmluZ106YW55fSA9IHt9O1xuXHRcdHZhciBncm91cF9jb3VudCA9IDE7XG5cdFx0bGV0ICRvcmRlciA9IDA7XG5cblx0XHR2YXIgcmVhZERhdGEgPSAoZWw6SFRNTEVsZW1lbnQpOlRvbU9wdGlvbiA9PiB7XG5cblx0XHRcdHZhciBkYXRhXHQ9IE9iamVjdC5hc3NpZ24oe30sZWwuZGF0YXNldCk7IC8vIGdldCBwbGFpbiBvYmplY3QgZnJvbSBET01TdHJpbmdNYXBcblx0XHRcdHZhciBqc29uXHQ9IGF0dHJfZGF0YSAmJiBkYXRhW2F0dHJfZGF0YV07XG5cblx0XHRcdGlmKCB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgJiYganNvbi5sZW5ndGggKXtcblx0XHRcdFx0ZGF0YSA9IE9iamVjdC5hc3NpZ24oZGF0YSxKU09OLnBhcnNlKGpzb24pKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fTtcblxuXHRcdHZhciBhZGRPcHRpb24gPSAob3B0aW9uOkhUTUxPcHRpb25FbGVtZW50LCBncm91cD86c3RyaW5nKSA9PiB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IGhhc2hfa2V5KG9wdGlvbi52YWx1ZSk7XG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgKSByZXR1cm47XG5cdFx0XHRpZiAoICF2YWx1ZSAmJiAhc2V0dGluZ3MuYWxsb3dFbXB0eU9wdGlvbikgcmV0dXJuO1xuXG5cdFx0XHQvLyBpZiB0aGUgb3B0aW9uIGFscmVhZHkgZXhpc3RzLCBpdCdzIHByb2JhYmx5IGJlZW5cblx0XHRcdC8vIGR1cGxpY2F0ZWQgaW4gYW5vdGhlciBvcHRncm91cC4gaW4gdGhpcyBjYXNlLCBwdXNoXG5cdFx0XHQvLyB0aGUgY3VycmVudCBncm91cCB0byB0aGUgXCJvcHRncm91cFwiIHByb3BlcnR5IG9uIHRoZVxuXHRcdFx0Ly8gZXhpc3Rpbmcgb3B0aW9uIHNvIHRoYXQgaXQncyByZW5kZXJlZCBpbiBib3RoIHBsYWNlcy5cblx0XHRcdGlmIChvcHRpb25zTWFwLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoZ3JvdXApIHtcblx0XHRcdFx0XHR2YXIgYXJyID0gb3B0aW9uc01hcFt2YWx1ZV1bZmllbGRfb3B0Z3JvdXBdO1xuXHRcdFx0XHRcdGlmICghYXJyKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zTWFwW3ZhbHVlXVtmaWVsZF9vcHRncm91cF0gPSBncm91cDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnNNYXBbdmFsdWVdW2ZpZWxkX29wdGdyb3VwXSA9IFthcnIsIGdyb3VwXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YXJyLnB1c2goZ3JvdXApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9ZWxzZXtcblxuXHRcdFx0XHR2YXIgb3B0aW9uX2RhdGEgICAgICAgICAgICAgPSByZWFkRGF0YShvcHRpb24pO1xuXHRcdFx0XHRvcHRpb25fZGF0YVtmaWVsZF9sYWJlbF0gICAgPSBvcHRpb25fZGF0YVtmaWVsZF9sYWJlbF0gfHwgb3B0aW9uLnRleHRDb250ZW50O1xuXHRcdFx0XHRvcHRpb25fZGF0YVtmaWVsZF92YWx1ZV0gICAgPSBvcHRpb25fZGF0YVtmaWVsZF92YWx1ZV0gfHwgdmFsdWU7XG5cdFx0XHRcdG9wdGlvbl9kYXRhW2ZpZWxkX2Rpc2FibGVkXSA9IG9wdGlvbl9kYXRhW2ZpZWxkX2Rpc2FibGVkXSB8fCBvcHRpb24uZGlzYWJsZWQ7XG5cdFx0XHRcdG9wdGlvbl9kYXRhW2ZpZWxkX29wdGdyb3VwXSA9IG9wdGlvbl9kYXRhW2ZpZWxkX29wdGdyb3VwXSB8fCBncm91cDtcblx0XHRcdFx0b3B0aW9uX2RhdGEuJG9wdGlvblx0XHRcdD0gb3B0aW9uO1xuXHRcdFx0XHRvcHRpb25fZGF0YS4kb3JkZXJcdFx0XHQ9IG9wdGlvbl9kYXRhLiRvcmRlciB8fCArKyRvcmRlcjtcblxuXHRcdFx0XHRvcHRpb25zTWFwW3ZhbHVlXSA9IG9wdGlvbl9kYXRhO1xuXHRcdFx0XHRvcHRpb25zLnB1c2gob3B0aW9uX2RhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggb3B0aW9uLnNlbGVjdGVkICl7XG5cdFx0XHRcdHNldHRpbmdzX2VsZW1lbnQuaXRlbXMucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBhZGRHcm91cCA9ICggb3B0Z3JvdXA6SFRNTE9wdEdyb3VwRWxlbWVudCApID0+IHtcblx0XHRcdHZhciBpZDpzdHJpbmcsIG9wdGdyb3VwX2RhdGFcblxuXHRcdFx0b3B0Z3JvdXBfZGF0YVx0XHRcdFx0XHRcdFx0PSByZWFkRGF0YShvcHRncm91cCk7XG5cdFx0XHRvcHRncm91cF9kYXRhW2ZpZWxkX29wdGdyb3VwX2xhYmVsXVx0XHQ9IG9wdGdyb3VwX2RhdGFbZmllbGRfb3B0Z3JvdXBfbGFiZWxdIHx8IG9wdGdyb3VwLmdldEF0dHJpYnV0ZSgnbGFiZWwnKSB8fCAnJztcblx0XHRcdG9wdGdyb3VwX2RhdGFbZmllbGRfb3B0Z3JvdXBfdmFsdWVdXHRcdD0gb3B0Z3JvdXBfZGF0YVtmaWVsZF9vcHRncm91cF92YWx1ZV0gfHwgZ3JvdXBfY291bnQrKztcblx0XHRcdG9wdGdyb3VwX2RhdGFbZmllbGRfZGlzYWJsZWRdXHRcdFx0PSBvcHRncm91cF9kYXRhW2ZpZWxkX2Rpc2FibGVkXSB8fCBvcHRncm91cC5kaXNhYmxlZDtcblx0XHRcdG9wdGdyb3VwX2RhdGEuJG9yZGVyXHRcdFx0XHRcdD0gb3B0Z3JvdXBfZGF0YS4kb3JkZXIgfHwgKyskb3JkZXI7XG5cblx0XHRcdHNldHRpbmdzX2VsZW1lbnQub3B0Z3JvdXBzLnB1c2gob3B0Z3JvdXBfZGF0YSk7XG5cblx0XHRcdGlkID0gb3B0Z3JvdXBfZGF0YVtmaWVsZF9vcHRncm91cF92YWx1ZV07XG5cblx0XHRcdGl0ZXJhdGUob3B0Z3JvdXAuY2hpbGRyZW4sIChvcHRpb24pPT57XG5cdFx0XHRcdGFkZE9wdGlvbihvcHRpb24gYXMgSFRNTE9wdGlvbkVsZW1lbnQsIGlkKTtcblx0XHRcdH0pO1xuXG5cdFx0fTtcblxuXHRcdHNldHRpbmdzX2VsZW1lbnQubWF4SXRlbXMgPSBpbnB1dC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykgPyBudWxsIDogMTtcblxuXHRcdGl0ZXJhdGUoaW5wdXQuY2hpbGRyZW4sKGNoaWxkKT0+e1xuXHRcdFx0dGFnTmFtZSA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmICh0YWdOYW1lID09PSAnb3B0Z3JvdXAnKSB7XG5cdFx0XHRcdGFkZEdyb3VwKGNoaWxkIGFzIEhUTUxPcHRHcm91cEVsZW1lbnQpO1xuXHRcdFx0fSBlbHNlIGlmICh0YWdOYW1lID09PSAnb3B0aW9uJykge1xuXHRcdFx0XHRhZGRPcHRpb24oY2hpbGQgYXMgSFRNTE9wdGlvbkVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH07XG5cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBmcm9tIGEgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+IGVsZW1lbnQuXG5cdCAqXG5cdCAqL1xuXHR2YXIgaW5pdF90ZXh0Ym94ID0gKCkgPT4ge1xuXHRcdGNvbnN0IGRhdGFfcmF3ID0gaW5wdXQuZ2V0QXR0cmlidXRlKGF0dHJfZGF0YSk7XG5cblx0XHRpZiAoIWRhdGFfcmF3KSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBpbnB1dC52YWx1ZS50cmltKCkgfHwgJyc7XG5cdFx0XHRpZiAoIXNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24gJiYgIXZhbHVlLmxlbmd0aCkgcmV0dXJuO1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gdmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVsaW1pdGVyKTtcblxuXHRcdFx0aXRlcmF0ZSggdmFsdWVzLCAodmFsdWUpID0+IHtcblx0XHRcdFx0Y29uc3Qgb3B0aW9uOlRvbU9wdGlvbiA9IHt9O1xuXHRcdFx0XHRvcHRpb25bZmllbGRfbGFiZWxdID0gdmFsdWU7XG5cdFx0XHRcdG9wdGlvbltmaWVsZF92YWx1ZV0gPSB2YWx1ZTtcblx0XHRcdFx0c2V0dGluZ3NfZWxlbWVudC5vcHRpb25zLnB1c2gob3B0aW9uKTtcblx0XHRcdH0pO1xuXHRcdFx0c2V0dGluZ3NfZWxlbWVudC5pdGVtcyA9IHZhbHVlcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2V0dGluZ3NfZWxlbWVudC5vcHRpb25zID0gSlNPTi5wYXJzZShkYXRhX3Jhdyk7XG5cdFx0XHRpdGVyYXRlKCBzZXR0aW5nc19lbGVtZW50Lm9wdGlvbnMsIChvcHQpID0+IHtcblx0XHRcdFx0c2V0dGluZ3NfZWxlbWVudC5pdGVtcy5wdXNoKG9wdFtmaWVsZF92YWx1ZV0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cblx0aWYgKHRhZ19uYW1lID09PSAnc2VsZWN0Jykge1xuXHRcdGluaXRfc2VsZWN0KCk7XG5cdH0gZWxzZSB7XG5cdFx0aW5pdF90ZXh0Ym94KCk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHRzLCBzZXR0aW5nc19lbGVtZW50LCBzZXR0aW5nc191c2VyKSBhcyBUb21TZXR0aW5ncztcbn07XG4iLCAiXG5pbXBvcnQgTWljcm9FdmVudCBmcm9tICcuL2NvbnRyaWIvbWljcm9ldmVudCc7XG5pbXBvcnQgTWljcm9QbHVnaW4gZnJvbSAnLi9jb250cmliL21pY3JvcGx1Z2luJztcbmltcG9ydCB7IFNpZnRlciwgaXRlcmF0ZSB9IGZyb20gJ0BvcmNoaWRqcy9zaWZ0ZXInO1xuaW1wb3J0IHsgZXNjYXBlX3JlZ2V4IH0gZnJvbSAnQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMnO1xuaW1wb3J0IHsgVG9tSW5wdXQsIFRvbUFyZ09iamVjdCwgVG9tT3B0aW9uLCBUb21PcHRpb25zLCBUb21DcmVhdGVGaWx0ZXIsIFRvbUNyZWF0ZUNhbGxiYWNrLCBUb21JdGVtLCBUb21TZXR0aW5ncywgVG9tVGVtcGxhdGVOYW1lcywgVG9tQ2xlYXJGaWx0ZXIsIFJlY3Vyc2l2ZVBhcnRpYWwgfSBmcm9tICcuL3R5cGVzL2luZGV4JztcbmltcG9ydCB7aGlnaGxpZ2h0LCByZW1vdmVIaWdobGlnaHR9IGZyb20gJy4vY29udHJpYi9oaWdobGlnaHQnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBnZXRTZXR0aW5ncyBmcm9tICcuL2dldFNldHRpbmdzJztcbmltcG9ydCB7XG5cdGhhc2hfa2V5LFxuXHRnZXRfaGFzaCxcblx0ZXNjYXBlX2h0bWwsXG5cdGRlYm91bmNlX2V2ZW50cyxcblx0Z2V0U2VsZWN0aW9uLFxuXHRwcmV2ZW50RGVmYXVsdCxcblx0YWRkRXZlbnQsXG5cdGxvYWREZWJvdW5jZSxcblx0dGltZW91dCxcblx0aXNLZXlEb3duLFxuXHRnZXRJZCxcblx0YWRkU2xhc2hlcyxcblx0YXBwZW5kXG59IGZyb20gJy4vdXRpbHMnO1xuXG5pbXBvcnQge1xuXHRnZXREb20sXG5cdGlzSHRtbFN0cmluZyxcblx0ZXNjYXBlUXVlcnksXG5cdHRyaWdnZXJFdmVudCxcblx0YXBwbHlDU1MsXG5cdGFkZENsYXNzZXMsXG5cdHJlbW92ZUNsYXNzZXMsXG5cdHBhcmVudE1hdGNoLFxuXHRnZXRUYWlsLFxuXHRpc0VtcHR5T2JqZWN0LFxuXHRub2RlSW5kZXgsXG5cdHNldEF0dHIsXG5cdHJlcGxhY2VOb2RlXG59IGZyb20gJy4vdmFuaWxsYSc7XG5cbnZhciBpbnN0YW5jZV9pID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9tU2VsZWN0IGV4dGVuZHMgTWljcm9QbHVnaW4oTWljcm9FdmVudCl7XG5cblx0cHVibGljIGNvbnRyb2xfaW5wdXRcdFx0XHQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cdHB1YmxpYyB3cmFwcGVyXHRcdFx0XHRcdDogSFRNTEVsZW1lbnQ7XG5cdHB1YmxpYyBkcm9wZG93blx0XHRcdFx0XHQ6IEhUTUxFbGVtZW50O1xuXHRwdWJsaWMgY29udHJvbFx0XHRcdFx0XHQ6IEhUTUxFbGVtZW50O1xuXHRwdWJsaWMgZHJvcGRvd25fY29udGVudFx0XHRcdDogSFRNTEVsZW1lbnQ7XG5cdHB1YmxpYyBmb2N1c19ub2RlXHRcdFx0XHQ6IEhUTUxFbGVtZW50O1xuXG5cdHB1YmxpYyBvcmRlclx0XHRcdFx0XHQ6IG51bWJlciA9IDA7XG5cdHB1YmxpYyBzZXR0aW5nc1x0XHRcdFx0XHQ6IFRvbVNldHRpbmdzO1xuXHRwdWJsaWMgaW5wdXRcdFx0XHRcdFx0OiBUb21JbnB1dDtcblx0cHVibGljIHRhYkluZGV4XHRcdFx0XHRcdDogbnVtYmVyO1xuXHRwdWJsaWMgaXNfc2VsZWN0X3RhZ1x0XHRcdDogYm9vbGVhbjtcblx0cHVibGljIHJ0bFx0XHRcdFx0XHRcdDogYm9vbGVhbjtcblx0cHJpdmF0ZSBpbnB1dElkXHRcdFx0XHRcdDogc3RyaW5nO1xuXG5cdHByaXZhdGUgX2Rlc3Ryb3lcdFx0XHRcdCE6ICgpID0+IHZvaWQ7XG5cdHB1YmxpYyBzaWZ0ZXJcdFx0XHRcdFx0OiBTaWZ0ZXI7XG5cblxuXHRwdWJsaWMgaXNPcGVuXHRcdFx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgaXNEaXNhYmxlZFx0XHRcdFx0OiBib29sZWFuID0gZmFsc2U7XG5cdHB1YmxpYyBpc1JlYWRPbmx5XHRcdFx0XHQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHVibGljIGlzUmVxdWlyZWRcdFx0XHRcdDogYm9vbGVhbjtcblx0cHVibGljIGlzSW52YWxpZFx0XHRcdFx0OiBib29sZWFuID0gZmFsc2U7IC8vIEBkZXByZWNhdGVkIDEuOFxuXHRwdWJsaWMgaXNWYWxpZFx0XHRcdFx0XHQ6IGJvb2xlYW4gPSB0cnVlO1xuXHRwdWJsaWMgaXNMb2NrZWRcdFx0XHRcdFx0OiBib29sZWFuID0gZmFsc2U7XG5cdHB1YmxpYyBpc0ZvY3VzZWRcdFx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgaXNJbnB1dEhpZGRlblx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgaXNTZXR1cFx0XHRcdFx0XHQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHVibGljIGlnbm9yZUZvY3VzXHRcdFx0XHQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHVibGljIGlnbm9yZUhvdmVyXHRcdFx0XHQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHVibGljIGhhc09wdGlvbnNcdFx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgY3VycmVudFJlc3VsdHNcdFx0XHQ/OiBSZXR1cm5UeXBlPFNpZnRlclsnc2VhcmNoJ10+O1xuXHRwdWJsaWMgbGFzdFZhbHVlXHRcdFx0XHQ6IHN0cmluZyA9ICcnO1xuXHRwdWJsaWMgY2FyZXRQb3NcdFx0XHRcdFx0OiBudW1iZXIgPSAwO1xuXHRwdWJsaWMgbG9hZGluZ1x0XHRcdFx0XHQ6IG51bWJlciA9IDA7XG5cdHB1YmxpYyBsb2FkZWRTZWFyY2hlc1x0XHRcdDogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fTtcblxuXHRwdWJsaWMgYWN0aXZlT3B0aW9uXHRcdFx0XHQ6IG51bGx8SFRNTEVsZW1lbnQgPSBudWxsO1xuXHRwdWJsaWMgYWN0aXZlSXRlbXNcdFx0XHRcdDogVG9tSXRlbVtdID0gW107XG5cblx0cHVibGljIG9wdGdyb3Vwc1x0XHRcdFx0OiBUb21PcHRpb25zID0ge307XG5cdHB1YmxpYyBvcHRpb25zXHRcdFx0XHRcdDogVG9tT3B0aW9ucyA9IHt9O1xuXHRwdWJsaWMgdXNlck9wdGlvbnNcdFx0XHRcdDoge1trZXk6c3RyaW5nXTpib29sZWFufSA9IHt9O1xuXHRwdWJsaWMgaXRlbXNcdFx0XHRcdFx0OiBzdHJpbmdbXSA9IFtdO1xuXG5cdHByaXZhdGUgcmVmcmVzaFRpbWVvdXRcdFx0XHQ6IG51bGx8UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4gPSBudWxsO1xuXG5cblx0Y29uc3RydWN0b3IoIGlucHV0X2FyZzogc3RyaW5nfFRvbUlucHV0LCB1c2VyX3NldHRpbmdzOlJlY3Vyc2l2ZVBhcnRpYWw8VG9tU2V0dGluZ3M+ICl7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGluc3RhbmNlX2krKztcblxuXHRcdHZhciBkaXI7XG5cdFx0dmFyIGlucHV0XHRcdFx0XHQ9IGdldERvbSggaW5wdXRfYXJnICkgYXMgVG9tSW5wdXQ7XG5cblx0XHRpZiggaW5wdXQudG9tc2VsZWN0ICl7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RvbSBTZWxlY3QgYWxyZWFkeSBpbml0aWFsaXplZCBvbiB0aGlzIGVsZW1lbnQnKTtcblx0XHR9XG5cblxuXHRcdGlucHV0LnRvbXNlbGVjdFx0XHRcdD0gdGhpcztcblxuXG5cdFx0Ly8gZGV0ZWN0IHJ0bCBlbnZpcm9ubWVudFxuXHRcdHZhciBjb21wdXRlZFN0eWxlXHRcdD0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5wdXQsIG51bGwpO1xuXHRcdGRpclx0XHRcdFx0XHRcdD0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKTtcblxuXHRcdC8vIHNldHVwIGRlZmF1bHQgc3RhdGVcblx0XHRjb25zdCBzZXR0aW5nc1x0XHRcdD0gZ2V0U2V0dGluZ3MoIGlucHV0LCB1c2VyX3NldHRpbmdzICk7XG5cdFx0dGhpcy5zZXR0aW5nc1x0XHRcdD0gc2V0dGluZ3M7XG5cdFx0dGhpcy5pbnB1dFx0XHRcdFx0PSBpbnB1dDtcblx0XHR0aGlzLnRhYkluZGV4XHRcdFx0PSBpbnB1dC50YWJJbmRleCB8fCAwO1xuXHRcdHRoaXMuaXNfc2VsZWN0X3RhZ1x0XHQ9IGlucHV0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdCc7XG5cdFx0dGhpcy5ydGxcdFx0XHRcdD0gL3J0bC9pLnRlc3QoZGlyKTtcblx0XHR0aGlzLmlucHV0SWRcdFx0XHQ9IGdldElkKGlucHV0LCAndG9tc2VsZWN0LScraW5zdGFuY2VfaSk7XG5cdFx0dGhpcy5pc1JlcXVpcmVkXHRcdFx0PSBpbnB1dC5yZXF1aXJlZDtcblxuXG5cdFx0Ly8gc2VhcmNoIHN5c3RlbVxuXHRcdHRoaXMuc2lmdGVyID0gbmV3IFNpZnRlcih0aGlzLm9wdGlvbnMsIHtkaWFjcml0aWNzOiBzZXR0aW5ncy5kaWFjcml0aWNzfSk7XG5cblx0XHQvLyBvcHRpb24tZGVwZW5kZW50IGRlZmF1bHRzXG5cdFx0c2V0dGluZ3MubW9kZSA9IHNldHRpbmdzLm1vZGUgfHwgKHNldHRpbmdzLm1heEl0ZW1zID09PSAxID8gJ3NpbmdsZScgOiAnbXVsdGknKTtcblx0XHRpZiAodHlwZW9mIHNldHRpbmdzLmhpZGVTZWxlY3RlZCAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRzZXR0aW5ncy5oaWRlU2VsZWN0ZWQgPSBzZXR0aW5ncy5tb2RlID09PSAnbXVsdGknO1xuXHRcdH1cblxuXHRcdGlmKCB0eXBlb2Ygc2V0dGluZ3MuaGlkZVBsYWNlaG9sZGVyICE9PSAnYm9vbGVhbicgKXtcblx0XHRcdHNldHRpbmdzLmhpZGVQbGFjZWhvbGRlciA9IHNldHRpbmdzLm1vZGUgIT09ICdtdWx0aSc7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IHVwIGNyZWF0ZUZpbHRlciBjYWxsYmFja1xuXHRcdHZhciBmaWx0ZXIgPSBzZXR0aW5ncy5jcmVhdGVGaWx0ZXI7XG5cdFx0aWYoIHR5cGVvZiBmaWx0ZXIgIT09ICdmdW5jdGlvbicgKXtcblxuXHRcdFx0aWYoIHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnICl7XG5cdFx0XHRcdGZpbHRlciA9IG5ldyBSZWdFeHAoZmlsdGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIGZpbHRlciBpbnN0YW5jZW9mIFJlZ0V4cCApe1xuXHRcdFx0XHRzZXR0aW5ncy5jcmVhdGVGaWx0ZXIgPSAoaW5wdXQpID0+IChmaWx0ZXIgYXMgUmVnRXhwKS50ZXN0KGlucHV0KTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRzZXR0aW5ncy5jcmVhdGVGaWx0ZXIgPSAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncy5kdXBsaWNhdGVzIHx8ICF0aGlzLm9wdGlvbnNbdmFsdWVdO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0dGhpcy5pbml0aWFsaXplUGx1Z2lucyhzZXR0aW5ncy5wbHVnaW5zKTtcblx0XHR0aGlzLnNldHVwQ2FsbGJhY2tzKCk7XG5cdFx0dGhpcy5zZXR1cFRlbXBsYXRlcygpO1xuXG5cblx0XHQvLyBDcmVhdGUgYWxsIGVsZW1lbnRzXG5cdFx0Y29uc3Qgd3JhcHBlclx0XHRcdD0gZ2V0RG9tKCc8ZGl2PicpO1xuXHRcdGNvbnN0IGNvbnRyb2xcdFx0XHQ9IGdldERvbSgnPGRpdj4nKTtcblx0XHRjb25zdCBkcm9wZG93blx0XHRcdD0gdGhpcy5fcmVuZGVyKCdkcm9wZG93bicpO1xuXHRcdGNvbnN0IGRyb3Bkb3duX2NvbnRlbnRcdD0gZ2V0RG9tKGA8ZGl2IHJvbGU9XCJsaXN0Ym94XCIgdGFiaW5kZXg9XCItMVwiPmApO1xuXG5cdFx0Y29uc3QgY2xhc3Nlc1x0XHRcdD0gdGhpcy5pbnB1dC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG5cdFx0Y29uc3QgaW5wdXRNb2RlXHRcdFx0PSBzZXR0aW5ncy5tb2RlO1xuXG5cdFx0dmFyIGNvbnRyb2xfaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cblxuXHRcdGFkZENsYXNzZXMoIHdyYXBwZXIsIHNldHRpbmdzLndyYXBwZXJDbGFzcywgY2xhc3NlcywgaW5wdXRNb2RlKTtcblxuXG5cdFx0YWRkQ2xhc3Nlcyhjb250cm9sLHNldHRpbmdzLmNvbnRyb2xDbGFzcyk7XG5cdFx0YXBwZW5kKCB3cmFwcGVyLCBjb250cm9sICk7XG5cblxuXHRcdGFkZENsYXNzZXMoZHJvcGRvd24sIHNldHRpbmdzLmRyb3Bkb3duQ2xhc3MsIGlucHV0TW9kZSk7XG5cdFx0aWYoIHNldHRpbmdzLmNvcHlDbGFzc2VzVG9Ecm9wZG93biApe1xuXHRcdFx0YWRkQ2xhc3NlcyggZHJvcGRvd24sIGNsYXNzZXMpO1xuXHRcdH1cblxuXG5cdFx0YWRkQ2xhc3Nlcyhkcm9wZG93bl9jb250ZW50LCBzZXR0aW5ncy5kcm9wZG93bkNvbnRlbnRDbGFzcyk7XG5cdFx0YXBwZW5kKCBkcm9wZG93biwgZHJvcGRvd25fY29udGVudCApO1xuXG5cdFx0Z2V0RG9tKCBzZXR0aW5ncy5kcm9wZG93blBhcmVudCB8fCB3cmFwcGVyICkuYXBwZW5kQ2hpbGQoIGRyb3Bkb3duICk7XG5cblxuXHRcdC8vIGRlZmF1bHQgY29udHJvbElucHV0XG5cdFx0aWYoIGlzSHRtbFN0cmluZyhzZXR0aW5ncy5jb250cm9sSW5wdXQpICl7XG5cdFx0XHRjb250cm9sX2lucHV0XHRcdD0gZ2V0RG9tKHNldHRpbmdzLmNvbnRyb2xJbnB1dCApIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cblx0XHRcdC8vIHNldCBhdHRyaWJ1dGVzXG5cdFx0XHR2YXIgYXR0cnMgPSBbJ2F1dG9jb3JyZWN0JywnYXV0b2NhcGl0YWxpemUnLCdhdXRvY29tcGxldGUnLCdzcGVsbGNoZWNrJ107XG5cdFx0XHRpdGVyYXRlKGF0dHJzLChhdHRyOnN0cmluZykgPT4ge1xuXHRcdFx0XHRpZiggaW5wdXQuZ2V0QXR0cmlidXRlKGF0dHIpICl7XG5cdFx0XHRcdFx0c2V0QXR0cihjb250cm9sX2lucHV0LHtbYXR0cl06aW5wdXQuZ2V0QXR0cmlidXRlKGF0dHIpfSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRjb250cm9sX2lucHV0LnRhYkluZGV4ID0gLTE7XG5cdFx0XHRjb250cm9sLmFwcGVuZENoaWxkKCBjb250cm9sX2lucHV0ICk7XG5cdFx0XHR0aGlzLmZvY3VzX25vZGVcdFx0PSBjb250cm9sX2lucHV0O1xuXG5cdFx0Ly8gZG9tIGVsZW1lbnRcblx0XHR9ZWxzZSBpZiggc2V0dGluZ3MuY29udHJvbElucHV0ICl7XG5cdFx0XHRjb250cm9sX2lucHV0XHRcdD0gZ2V0RG9tKCBzZXR0aW5ncy5jb250cm9sSW5wdXQgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXHRcdFx0dGhpcy5mb2N1c19ub2RlXHRcdD0gY29udHJvbF9pbnB1dDtcblxuXHRcdH1lbHNle1xuXHRcdFx0Y29udHJvbF9pbnB1dFx0XHQ9IGdldERvbSgnPGlucHV0Lz4nKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXHRcdFx0dGhpcy5mb2N1c19ub2RlXHRcdD0gY29udHJvbDtcblx0XHR9XG5cblx0XHR0aGlzLndyYXBwZXJcdFx0XHQ9IHdyYXBwZXI7XG5cdFx0dGhpcy5kcm9wZG93blx0XHRcdD0gZHJvcGRvd247XG5cdFx0dGhpcy5kcm9wZG93bl9jb250ZW50XHQ9IGRyb3Bkb3duX2NvbnRlbnQ7XG5cdFx0dGhpcy5jb250cm9sIFx0XHRcdD0gY29udHJvbDtcblx0XHR0aGlzLmNvbnRyb2xfaW5wdXRcdFx0PSBjb250cm9sX2lucHV0O1xuXG5cdFx0dGhpcy5zZXR1cCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIHNldCB1cCBldmVudCBiaW5kaW5ncy5cblx0ICpcblx0ICovXG5cdHNldHVwKCl7XG5cblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRjb25zdCBzZXR0aW5nc1x0XHRcdFx0PSBzZWxmLnNldHRpbmdzO1xuXHRcdGNvbnN0IGNvbnRyb2xfaW5wdXRcdFx0XHQ9IHNlbGYuY29udHJvbF9pbnB1dDtcblx0XHRjb25zdCBkcm9wZG93blx0XHRcdFx0PSBzZWxmLmRyb3Bkb3duO1xuXHRcdGNvbnN0IGRyb3Bkb3duX2NvbnRlbnRcdFx0PSBzZWxmLmRyb3Bkb3duX2NvbnRlbnQ7XG5cdFx0Y29uc3Qgd3JhcHBlclx0XHRcdFx0PSBzZWxmLndyYXBwZXI7XG5cdFx0Y29uc3QgY29udHJvbFx0XHRcdFx0PSBzZWxmLmNvbnRyb2w7XG5cdFx0Y29uc3QgaW5wdXRcdFx0XHRcdFx0PSBzZWxmLmlucHV0O1xuXHRcdGNvbnN0IGZvY3VzX25vZGVcdFx0XHQ9IHNlbGYuZm9jdXNfbm9kZTtcblx0XHRjb25zdCBwYXNzaXZlX2V2ZW50XHRcdFx0PSB7IHBhc3NpdmU6IHRydWUgfTtcblx0XHRjb25zdCBsaXN0Ym94SWRcdFx0XHRcdD0gc2VsZi5pbnB1dElkICsnLXRzLWRyb3Bkb3duJztcblxuXG5cdFx0c2V0QXR0cihkcm9wZG93bl9jb250ZW50LHtcblx0XHRcdGlkOiBsaXN0Ym94SWRcblx0XHR9KTtcblxuXHRcdHNldEF0dHIoZm9jdXNfbm9kZSx7XG5cdFx0XHRyb2xlOidjb21ib2JveCcsXG5cdFx0XHQnYXJpYS1oYXNwb3B1cCc6J2xpc3Rib3gnLFxuXHRcdFx0J2FyaWEtZXhwYW5kZWQnOidmYWxzZScsXG5cdFx0XHQnYXJpYS1jb250cm9scyc6bGlzdGJveElkXG5cdFx0fSk7XG5cblx0XHRjb25zdCBjb250cm9sX2lkXHQ9IGdldElkKGZvY3VzX25vZGUsc2VsZi5pbnB1dElkICsgJy10cy1jb250cm9sJyk7XG5cdFx0Y29uc3QgcXVlcnlcdFx0XHQ9IFwibGFiZWxbZm9yPSdcIitlc2NhcGVRdWVyeShzZWxmLmlucHV0SWQpK1wiJ11cIjtcblx0XHRjb25zdCBsYWJlbFx0XHRcdD0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG5cdFx0Y29uc3QgbGFiZWxfY2xpY2tcdD0gc2VsZi5mb2N1cy5iaW5kKHNlbGYpO1xuXHRcdGlmKCBsYWJlbCApe1xuXHRcdFx0YWRkRXZlbnQobGFiZWwsJ2NsaWNrJywgbGFiZWxfY2xpY2sgKTtcblx0XHRcdHNldEF0dHIobGFiZWwse2Zvcjpjb250cm9sX2lkfSk7XG5cdFx0XHRjb25zdCBsYWJlbF9pZCA9IGdldElkKGxhYmVsLHNlbGYuaW5wdXRJZCsnLXRzLWxhYmVsJyk7XG5cdFx0XHRzZXRBdHRyKGZvY3VzX25vZGUseydhcmlhLWxhYmVsbGVkYnknOmxhYmVsX2lkfSk7XG5cdFx0XHRzZXRBdHRyKGRyb3Bkb3duX2NvbnRlbnQseydhcmlhLWxhYmVsbGVkYnknOmxhYmVsX2lkfSk7XG5cdFx0fVxuXG5cdFx0d3JhcHBlci5zdHlsZS53aWR0aCA9IGlucHV0LnN0eWxlLndpZHRoO1xuXG5cdFx0aWYgKHNlbGYucGx1Z2lucy5uYW1lcy5sZW5ndGgpIHtcblx0XHRcdGNvbnN0IGNsYXNzZXNfcGx1Z2lucyA9ICdwbHVnaW4tJyArIHNlbGYucGx1Z2lucy5uYW1lcy5qb2luKCcgcGx1Z2luLScpO1xuXHRcdFx0YWRkQ2xhc3NlcyggW3dyYXBwZXIsZHJvcGRvd25dLCBjbGFzc2VzX3BsdWdpbnMpO1xuXHRcdH1cblxuXHRcdGlmICgoc2V0dGluZ3MubWF4SXRlbXMgPT09IG51bGwgfHwgc2V0dGluZ3MubWF4SXRlbXMgPiAxKSAmJiBzZWxmLmlzX3NlbGVjdF90YWcgKXtcblx0XHRcdHNldEF0dHIoaW5wdXQse211bHRpcGxlOidtdWx0aXBsZSd9KTtcblx0XHR9XG5cblx0XHRpZiAoc2V0dGluZ3MucGxhY2Vob2xkZXIpIHtcblx0XHRcdHNldEF0dHIoY29udHJvbF9pbnB1dCx7cGxhY2Vob2xkZXI6c2V0dGluZ3MucGxhY2Vob2xkZXJ9KTtcblx0XHR9XG5cblx0XHQvLyBpZiBzcGxpdE9uIHdhcyBub3QgcGFzc2VkIGluLCBjb25zdHJ1Y3QgaXQgZnJvbSB0aGUgZGVsaW1pdGVyIHRvIGFsbG93IHBhc3RpbmcgdW5pdmVyc2FsbHlcblx0XHRpZiAoIXNldHRpbmdzLnNwbGl0T24gJiYgc2V0dGluZ3MuZGVsaW1pdGVyKSB7XG5cdFx0XHRzZXR0aW5ncy5zcGxpdE9uID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZV9yZWdleChzZXR0aW5ncy5kZWxpbWl0ZXIpICsgJytcXFxccyonKTtcblx0XHR9XG5cblx0XHQvLyBkZWJvdW5jZSB1c2VyIGRlZmluZWQgbG9hZCgpIGlmIGxvYWRUaHJvdHRsZSA+IDBcblx0XHQvLyBhZnRlciBpbml0aWFsaXplUGx1Z2lucygpIHNvIHBsdWdpbnMgY2FuIGNyZWF0ZS9tb2RpZnkgdXNlciBkZWZpbmVkIGxvYWRlcnNcblx0XHRpZiggc2V0dGluZ3MubG9hZCAmJiBzZXR0aW5ncy5sb2FkVGhyb3R0bGUgKXtcblx0XHRcdHNldHRpbmdzLmxvYWQgPSBsb2FkRGVib3VuY2Uoc2V0dGluZ3MubG9hZCxzZXR0aW5ncy5sb2FkVGhyb3R0bGUpXG5cdFx0fVxuXG5cdFx0YWRkRXZlbnQoZHJvcGRvd24sJ21vdXNlbW92ZScsICgpID0+IHtcblx0XHRcdHNlbGYuaWdub3JlSG92ZXIgPSBmYWxzZTtcblx0XHR9KTtcblxuXHRcdGFkZEV2ZW50KGRyb3Bkb3duLCdtb3VzZWVudGVyJywgKGUpID0+IHtcblxuXHRcdFx0dmFyIHRhcmdldF9tYXRjaCA9IHBhcmVudE1hdGNoKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCAnW2RhdGEtc2VsZWN0YWJsZV0nLCBkcm9wZG93bik7XG5cdFx0XHRpZiggdGFyZ2V0X21hdGNoICkgc2VsZi5vbk9wdGlvbkhvdmVyKCBlIGFzIE1vdXNlRXZlbnQsIHRhcmdldF9tYXRjaCApO1xuXG5cdFx0fSwge2NhcHR1cmU6dHJ1ZX0pO1xuXG5cdFx0Ly8gY2xpY2tpbmcgb24gYW4gb3B0aW9uIHNob3VsZCBzZWxlY3QgaXRcblx0XHRhZGRFdmVudChkcm9wZG93biwnY2xpY2snLChldnQpID0+IHtcblx0XHRcdGNvbnN0IG9wdGlvbiA9IHBhcmVudE1hdGNoKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsICdbZGF0YS1zZWxlY3RhYmxlXScpO1xuXHRcdFx0aWYoIG9wdGlvbiApe1xuXHRcdFx0XHRzZWxmLm9uT3B0aW9uU2VsZWN0KCBldnQgYXMgTW91c2VFdmVudCwgb3B0aW9uICk7XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCx0cnVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFkZEV2ZW50KGNvbnRyb2wsJ2NsaWNrJywgKGV2dCkgPT4ge1xuXG5cdFx0XHR2YXIgdGFyZ2V0X21hdGNoID0gcGFyZW50TWF0Y2goIGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsICdbZGF0YS10cy1pdGVtXScsIGNvbnRyb2wpO1xuXHRcdFx0aWYoIHRhcmdldF9tYXRjaCAmJiBzZWxmLm9uSXRlbVNlbGVjdChldnQgYXMgTW91c2VFdmVudCwgdGFyZ2V0X21hdGNoIGFzIFRvbUl0ZW0pICl7XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCx0cnVlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXRhaW4gZm9jdXMgKHNlZSBjb250cm9sX2lucHV0IG1vdXNlZG93bilcblx0XHRcdGlmKCBjb250cm9sX2lucHV0LnZhbHVlICE9ICcnICl7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0c2VsZi5vbkNsaWNrKCk7XG5cdFx0XHRwcmV2ZW50RGVmYXVsdChldnQsdHJ1ZSk7XG5cdFx0fSk7XG5cblxuXHRcdC8vIGtleWRvd24gb24gZm9jdXNfbm9kZSBmb3IgYXJyb3dfZG93bi9hcnJvd191cFxuXHRcdGFkZEV2ZW50KGZvY3VzX25vZGUsJ2tleWRvd24nLFx0XHQoZSkgPT4gc2VsZi5vbktleURvd24oZSBhcyBLZXlib2FyZEV2ZW50KSApO1xuXG5cdFx0Ly8ga2V5cHJlc3MgYW5kIGlucHV0L2tleXVwXG5cdFx0YWRkRXZlbnQoY29udHJvbF9pbnB1dCwna2V5cHJlc3MnLFx0KGUpID0+IHNlbGYub25LZXlQcmVzcyhlIGFzIEtleWJvYXJkRXZlbnQpICk7XG5cdFx0YWRkRXZlbnQoY29udHJvbF9pbnB1dCwnaW5wdXQnLFx0XHQoZSkgPT4gc2VsZi5vbklucHV0KGUgYXMgS2V5Ym9hcmRFdmVudCkgKTtcblx0XHRhZGRFdmVudChmb2N1c19ub2RlLCdibHVyJywgXHRcdChlKSA9PiBzZWxmLm9uQmx1cihlIGFzIEZvY3VzRXZlbnQpICk7XG5cdFx0YWRkRXZlbnQoZm9jdXNfbm9kZSwnZm9jdXMnLFx0XHQoZSkgPT4gc2VsZi5vbkZvY3VzKGUgYXMgTW91c2VFdmVudCkgKTtcblx0XHRhZGRFdmVudChjb250cm9sX2lucHV0LCdwYXN0ZScsXHRcdChlKSA9PiBzZWxmLm9uUGFzdGUoZSBhcyBNb3VzZUV2ZW50KSApO1xuXG5cblx0XHRjb25zdCBkb2NfbW91c2Vkb3duID0gKGV2dDpFdmVudCkgPT4ge1xuXG5cdFx0XHQvLyBibHVyIGlmIHRhcmdldCBpcyBvdXRzaWRlIG9mIHRoaXMgaW5zdGFuY2Vcblx0XHRcdC8vIGRyb3Bkb3duIGlzIG5vdCBhbHdheXMgaW5zaWRlIHdyYXBwZXJcblx0XHRcdGNvbnN0IHRhcmdldCA9IGV2dC5jb21wb3NlZFBhdGgoKVswXTtcblx0XHRcdGlmKCAhd3JhcHBlci5jb250YWlucyh0YXJnZXQgYXMgSFRNTEVsZW1lbnQpICYmICFkcm9wZG93bi5jb250YWlucyh0YXJnZXQgYXMgSFRNTEVsZW1lbnQpICl7XG5cdFx0XHRcdGlmIChzZWxmLmlzRm9jdXNlZCkge1xuXHRcdFx0XHRcdHNlbGYuYmx1cigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gcmV0YWluIGZvY3VzIGJ5IHByZXZlbnRpbmcgbmF0aXZlIGhhbmRsaW5nLiBpZiB0aGVcblx0XHRcdC8vIGV2ZW50IHRhcmdldCBpcyB0aGUgaW5wdXQgaXQgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC5cblx0XHRcdC8vIG90aGVyd2lzZSwgdGV4dCBzZWxlY3Rpb24gd2l0aGluIHRoZSBpbnB1dCB3b24ndCB3b3JrLlxuXHRcdFx0Ly8gRml4ZXMgYnVnICMyMTIgd2hpY2ggaXMgbm8gY292ZXJlZCBieSB0ZXN0c1xuXHRcdFx0aWYoIHRhcmdldCA9PSBjb250cm9sX2lucHV0ICYmIHNlbGYuaXNPcGVuICl7XG5cdFx0XHRcdGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0Ly8gY2xpY2tpbmcgYW55d2hlcmUgaW4gdGhlIGNvbnRyb2wgc2hvdWxkIG5vdCBibHVyIHRoZSBjb250cm9sX2lucHV0ICh3aGljaCB3b3VsZCBjbG9zZSB0aGUgZHJvcGRvd24pXG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0cHJldmVudERlZmF1bHQoZXZ0LHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGNvbnN0IHdpbl9zY3JvbGwgPSAoKSA9PiB7XG5cdFx0XHRpZiAoc2VsZi5pc09wZW4pIHtcblx0XHRcdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXG5cdFx0YWRkRXZlbnQoZG9jdW1lbnQsJ21vdXNlZG93bicsIGRvY19tb3VzZWRvd24pO1xuXHRcdGFkZEV2ZW50KHdpbmRvdywnc2Nyb2xsJywgd2luX3Njcm9sbCwgcGFzc2l2ZV9ldmVudCk7XG5cdFx0YWRkRXZlbnQod2luZG93LCdyZXNpemUnLCB3aW5fc2Nyb2xsLCBwYXNzaXZlX2V2ZW50KTtcblxuXHRcdHRoaXMuX2Rlc3Ryb3kgPSAoKSA9PiB7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLGRvY19tb3VzZWRvd24pO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsd2luX3Njcm9sbCk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJyx3aW5fc2Nyb2xsKTtcblx0XHRcdGlmKCBsYWJlbCApIGxhYmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxsYWJlbF9jbGljayk7XG5cdFx0fTtcblxuXHRcdC8vIHN0b3JlIG9yaWdpbmFsIGh0bWwgYW5kIHRhYiBpbmRleCBzbyB0aGF0IHRoZXkgY2FuIGJlXG5cdFx0Ly8gcmVzdG9yZWQgd2hlbiB0aGUgZGVzdHJveSgpIG1ldGhvZCBpcyBjYWxsZWQuXG5cdFx0dGhpcy5yZXZlcnRTZXR0aW5ncyA9IHtcblx0XHRcdGlubmVySFRNTCA6IGlucHV0LmlubmVySFRNTCxcblx0XHRcdHRhYkluZGV4IDogaW5wdXQudGFiSW5kZXhcblx0XHR9O1xuXG5cblx0XHRpbnB1dC50YWJJbmRleCA9IC0xO1xuXHRcdGlucHV0Lmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBzZWxmLndyYXBwZXIpO1xuXG5cdFx0c2VsZi5zeW5jKGZhbHNlKTtcblx0XHRzZXR0aW5ncy5pdGVtcyA9IFtdO1xuXHRcdGRlbGV0ZSBzZXR0aW5ncy5vcHRncm91cHM7XG5cdFx0ZGVsZXRlIHNldHRpbmdzLm9wdGlvbnM7XG5cblx0XHRhZGRFdmVudChpbnB1dCwnaW52YWxpZCcsICgpID0+IHtcblx0XHRcdGlmKCBzZWxmLmlzVmFsaWQgKXtcblx0XHRcdFx0c2VsZi5pc1ZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdHNlbGYuaXNJbnZhbGlkID0gdHJ1ZTtcblx0XHRcdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHNlbGYudXBkYXRlT3JpZ2luYWxJbnB1dCgpO1xuXHRcdHNlbGYucmVmcmVzaEl0ZW1zKCk7XG5cdFx0c2VsZi5jbG9zZShmYWxzZSk7XG5cdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0c2VsZi5pc1NldHVwID0gdHJ1ZTtcblxuXHRcdGlmKCBpbnB1dC5kaXNhYmxlZCApe1xuXHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0fWVsc2UgaWYoIGlucHV0LnJlYWRPbmx5ICl7XG5cdFx0XHRzZWxmLnNldFJlYWRPbmx5KHRydWUpO1xuXHRcdH1lbHNle1xuXHRcdFx0c2VsZi5lbmFibGUoKTsgLy9zZXRzIHRhYkluZGV4XG5cdFx0fVxuXG5cdFx0c2VsZi5vbignY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XG5cblx0XHRhZGRDbGFzc2VzKGlucHV0LCd0b21zZWxlY3RlZCcsJ3RzLWhpZGRlbi1hY2Nlc3NpYmxlJyk7XG5cdFx0c2VsZi50cmlnZ2VyKCdpbml0aWFsaXplJyk7XG5cblx0XHQvLyBwcmVsb2FkIG9wdGlvbnNcblx0XHRpZiAoc2V0dGluZ3MucHJlbG9hZCA9PT0gdHJ1ZSkge1xuXHRcdFx0c2VsZi5wcmVsb2FkKCk7XG5cdFx0fVxuXG5cdH1cblxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBvcHRpb25zIGFuZCBvcHRncm91cHNcblx0ICpcblx0ICovXG5cdHNldHVwT3B0aW9ucyhvcHRpb25zOlRvbU9wdGlvbltdID0gW10sIG9wdGdyb3VwczpUb21PcHRpb25bXSA9IFtdKXtcblxuXHRcdC8vIGJ1aWxkIG9wdGlvbnMgdGFibGVcblx0XHR0aGlzLmFkZE9wdGlvbnMob3B0aW9ucyk7XG5cblxuXHRcdC8vIGJ1aWxkIG9wdGdyb3VwIHRhYmxlXG5cdFx0aXRlcmF0ZSggb3B0Z3JvdXBzLCAob3B0Z3JvdXA6VG9tT3B0aW9uKSA9PiB7XG5cdFx0XHR0aGlzLnJlZ2lzdGVyT3B0aW9uR3JvdXAob3B0Z3JvdXApO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdXAgZGVmYXVsdCByZW5kZXJpbmcgZnVuY3Rpb25zLlxuXHQgKi9cblx0c2V0dXBUZW1wbGF0ZXMoKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBmaWVsZF9sYWJlbCA9IHNlbGYuc2V0dGluZ3MubGFiZWxGaWVsZDtcblx0XHR2YXIgZmllbGRfb3B0Z3JvdXAgPSBzZWxmLnNldHRpbmdzLm9wdGdyb3VwTGFiZWxGaWVsZDtcblxuXHRcdHZhciB0ZW1wbGF0ZXMgPSB7XG5cdFx0XHQnb3B0Z3JvdXAnOiAoZGF0YTpUb21PcHRpb24pID0+IHtcblx0XHRcdFx0bGV0IG9wdGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdG9wdGdyb3VwLmNsYXNzTmFtZSA9ICdvcHRncm91cCc7XG5cdFx0XHRcdG9wdGdyb3VwLmFwcGVuZENoaWxkKGRhdGEub3B0aW9ucyk7XG5cdFx0XHRcdHJldHVybiBvcHRncm91cDtcblxuXHRcdFx0fSxcblx0XHRcdCdvcHRncm91cF9oZWFkZXInOiAoZGF0YTpUb21PcHRpb24sIGVzY2FwZTp0eXBlb2YgZXNjYXBlX2h0bWwpID0+IHtcblx0XHRcdFx0cmV0dXJuICc8ZGl2IGNsYXNzPVwib3B0Z3JvdXAtaGVhZGVyXCI+JyArIGVzY2FwZShkYXRhW2ZpZWxkX29wdGdyb3VwXSkgKyAnPC9kaXY+Jztcblx0XHRcdH0sXG5cdFx0XHQnb3B0aW9uJzogKGRhdGE6VG9tT3B0aW9uLCBlc2NhcGU6dHlwZW9mIGVzY2FwZV9odG1sKSA9PiB7XG5cdFx0XHRcdHJldHVybiAnPGRpdj4nICsgZXNjYXBlKGRhdGFbZmllbGRfbGFiZWxdKSArICc8L2Rpdj4nO1xuXHRcdFx0fSxcblx0XHRcdCdpdGVtJzogKGRhdGE6VG9tT3B0aW9uLCBlc2NhcGU6dHlwZW9mIGVzY2FwZV9odG1sKSA9PiB7XG5cdFx0XHRcdHJldHVybiAnPGRpdj4nICsgZXNjYXBlKGRhdGFbZmllbGRfbGFiZWxdKSArICc8L2Rpdj4nO1xuXHRcdFx0fSxcblx0XHRcdCdvcHRpb25fY3JlYXRlJzogKGRhdGE6VG9tT3B0aW9uLCBlc2NhcGU6dHlwZW9mIGVzY2FwZV9odG1sKSA9PiB7XG5cdFx0XHRcdHJldHVybiAnPGRpdiBjbGFzcz1cImNyZWF0ZVwiPkFkZCA8c3Ryb25nPicgKyBlc2NhcGUoZGF0YS5pbnB1dCkgKyAnPC9zdHJvbmc+JmhlbGxpcDs8L2Rpdj4nO1xuXHRcdFx0fSxcblx0XHRcdCdub19yZXN1bHRzJzooKSA9PiB7XG5cdFx0XHRcdHJldHVybiAnPGRpdiBjbGFzcz1cIm5vLXJlc3VsdHNcIj5ObyByZXN1bHRzIGZvdW5kPC9kaXY+Jztcblx0XHRcdH0sXG5cdFx0XHQnbG9hZGluZyc6KCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gJzxkaXYgY2xhc3M9XCJzcGlubmVyXCI+PC9kaXY+Jztcblx0XHRcdH0sXG5cdFx0XHQnbm90X2xvYWRpbmcnOigpID0+IHt9LFxuXHRcdFx0J2Ryb3Bkb3duJzooKSA9PiB7XG5cdFx0XHRcdHJldHVybiAnPGRpdj48L2Rpdj4nO1xuXHRcdFx0fVxuXHRcdH07XG5cblxuXHRcdHNlbGYuc2V0dGluZ3MucmVuZGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVzLCBzZWxmLnNldHRpbmdzLnJlbmRlcik7XG5cdH1cblxuXHQvKipcblx0ICogTWFwcyBmaXJlZCBldmVudHMgdG8gY2FsbGJhY2tzIHByb3ZpZGVkXG5cdCAqIGluIHRoZSBzZXR0aW5ncyB1c2VkIHdoZW4gY3JlYXRpbmcgdGhlIGNvbnRyb2wuXG5cdCAqL1xuXHRzZXR1cENhbGxiYWNrcygpIHtcblx0XHR2YXIga2V5LCBmbjtcblx0XHR2YXIgY2FsbGJhY2tzOntba2V5OnN0cmluZ106c3RyaW5nfSA9IHtcblx0XHRcdCdpbml0aWFsaXplJyAgICAgIDogJ29uSW5pdGlhbGl6ZScsXG5cdFx0XHQnY2hhbmdlJyAgICAgICAgICA6ICdvbkNoYW5nZScsXG5cdFx0XHQnaXRlbV9hZGQnICAgICAgICA6ICdvbkl0ZW1BZGQnLFxuXHRcdFx0J2l0ZW1fcmVtb3ZlJyAgICAgOiAnb25JdGVtUmVtb3ZlJyxcblx0XHRcdCdpdGVtX3NlbGVjdCcgICAgIDogJ29uSXRlbVNlbGVjdCcsXG5cdFx0XHQnY2xlYXInICAgICAgICAgICA6ICdvbkNsZWFyJyxcblx0XHRcdCdvcHRpb25fYWRkJyAgICAgIDogJ29uT3B0aW9uQWRkJyxcblx0XHRcdCdvcHRpb25fcmVtb3ZlJyAgIDogJ29uT3B0aW9uUmVtb3ZlJyxcblx0XHRcdCdvcHRpb25fY2xlYXInICAgIDogJ29uT3B0aW9uQ2xlYXInLFxuXHRcdFx0J29wdGdyb3VwX2FkZCcgICAgOiAnb25PcHRpb25Hcm91cEFkZCcsXG5cdFx0XHQnb3B0Z3JvdXBfcmVtb3ZlJyA6ICdvbk9wdGlvbkdyb3VwUmVtb3ZlJyxcblx0XHRcdCdvcHRncm91cF9jbGVhcicgIDogJ29uT3B0aW9uR3JvdXBDbGVhcicsXG5cdFx0XHQnZHJvcGRvd25fb3BlbicgICA6ICdvbkRyb3Bkb3duT3BlbicsXG5cdFx0XHQnZHJvcGRvd25fY2xvc2UnICA6ICdvbkRyb3Bkb3duQ2xvc2UnLFxuXHRcdFx0J3R5cGUnICAgICAgICAgICAgOiAnb25UeXBlJyxcblx0XHRcdCdsb2FkJyAgICAgICAgICAgIDogJ29uTG9hZCcsXG5cdFx0XHQnZm9jdXMnICAgICAgICAgICA6ICdvbkZvY3VzJyxcblx0XHRcdCdibHVyJyAgICAgICAgICAgIDogJ29uQmx1cidcblx0XHR9O1xuXG5cdFx0Zm9yIChrZXkgaW4gY2FsbGJhY2tzKSB7XG5cblx0XHRcdGZuID0gdGhpcy5zZXR0aW5nc1tjYWxsYmFja3Nba2V5XSBhcyAoa2V5b2YgVG9tU2V0dGluZ3MpXTtcblx0XHRcdGlmIChmbikgdGhpcy5vbihrZXksIGZuKTtcblxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTeW5jIHRoZSBUb20gU2VsZWN0IGluc3RhbmNlIHdpdGggdGhlIG9yaWdpbmFsIGlucHV0IG9yIHNlbGVjdFxuXHQgKlxuXHQgKi9cblx0c3luYyhnZXRfc2V0dGluZ3M6Ym9vbGVhbj10cnVlKTp2b2lke1xuXHRcdGNvbnN0IHNlbGZcdFx0PSB0aGlzO1xuXHRcdGNvbnN0IHNldHRpbmdzXHQ9IGdldF9zZXR0aW5ncyA/IGdldFNldHRpbmdzKCBzZWxmLmlucHV0LCB7ZGVsaW1pdGVyOnNlbGYuc2V0dGluZ3MuZGVsaW1pdGVyfSBhcyBSZWN1cnNpdmVQYXJ0aWFsPFRvbVNldHRpbmdzPiApIDogc2VsZi5zZXR0aW5ncztcblxuXHRcdHNlbGYuc2V0dXBPcHRpb25zKHNldHRpbmdzLm9wdGlvbnMsc2V0dGluZ3Mub3B0Z3JvdXBzKTtcblxuXHRcdHNlbGYuc2V0VmFsdWUoc2V0dGluZ3MuaXRlbXN8fFtdLHRydWUpOyAvLyBzaWxlbnQgcHJldmVudHMgcmVjdXJzaW9uXG5cblx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7IC8vIHNvIHVwZGF0ZWQgb3B0aW9ucyB3aWxsIGJlIGRpc3BsYXllZCBpbiBkcm9wZG93blxuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCB3aGVuIHRoZSBtYWluIGNvbnRyb2wgZWxlbWVudFxuXHQgKiBoYXMgYSBjbGljayBldmVudC5cblx0ICpcblx0ICovXG5cdG9uQ2xpY2soKTp2b2lkIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiggc2VsZi5hY3RpdmVJdGVtcy5sZW5ndGggPiAwICl7XG5cdFx0XHRzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcblx0XHRcdHNlbGYuZm9jdXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiggc2VsZi5pc0ZvY3VzZWQgJiYgc2VsZi5pc09wZW4gKXtcblx0XHRcdHNlbGYuYmx1cigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWxmLmZvY3VzKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXByZWNhdGVkIHYxLjdcblx0ICpcblx0ICovXG5cdG9uTW91c2VEb3duKCk6dm9pZCB7fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wgaGFzIGJlZW4gY2hhbmdlZC5cblx0ICogVGhpcyBzaG91bGQgcHJvcGFnYXRlIHRoZSBldmVudCB0byB0aGUgb3JpZ2luYWwgRE9NXG5cdCAqIGlucHV0IC8gc2VsZWN0IGVsZW1lbnQuXG5cdCAqL1xuXHRvbkNoYW5nZSgpIHtcblx0XHR0cmlnZ2VyRXZlbnQodGhpcy5pbnB1dCwgJ2lucHV0Jyk7XG5cdFx0dHJpZ2dlckV2ZW50KHRoaXMuaW5wdXQsICdjaGFuZ2UnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBwYXN0ZS5cblx0ICpcblx0ICovXG5cdG9uUGFzdGUoZTpNb3VzZUV2ZW50fEtleWJvYXJkRXZlbnQpOnZvaWQge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGlmKCBzZWxmLmlzSW5wdXRIaWRkZW4gfHwgc2VsZi5pc0xvY2tlZCApe1xuXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgYSByZWdleCBvciBzdHJpbmcgaXMgaW5jbHVkZWQsIHRoaXMgd2lsbCBzcGxpdCB0aGUgcGFzdGVkXG5cdFx0Ly8gaW5wdXQgYW5kIGNyZWF0ZSBJdGVtcyBmb3IgZWFjaCBzZXBhcmF0ZSB2YWx1ZVxuXHRcdGlmKCAhc2VsZi5zZXR0aW5ncy5zcGxpdE9uICl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gV2FpdCBmb3IgcGFzdGVkIHRleHQgdG8gYmUgcmVjb2duaXplZCBpbiB2YWx1ZVxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dmFyIHBhc3RlZFRleHQgPSBzZWxmLmlucHV0VmFsdWUoKTtcblx0XHRcdGlmKCAhcGFzdGVkVGV4dC5tYXRjaChzZWxmLnNldHRpbmdzLnNwbGl0T24pKXtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBzcGxpdElucHV0ID0gcGFzdGVkVGV4dC50cmltKCkuc3BsaXQoc2VsZi5zZXR0aW5ncy5zcGxpdE9uKTtcblx0XHRcdGl0ZXJhdGUoIHNwbGl0SW5wdXQsIChwaWVjZTpzdHJpbmcpID0+IHtcblxuXHRcdFx0XHRjb25zdCBoYXNoID0gaGFzaF9rZXkocGllY2UpO1xuXHRcdFx0XHRpZiggaGFzaCApe1xuXHRcdFx0XHRcdGlmKCB0aGlzLm9wdGlvbnNbcGllY2VdICl7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZEl0ZW0ocGllY2UpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0c2VsZi5jcmVhdGVJdGVtKHBpZWNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sIDApO1xuXG5cdH1cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4ga2V5cHJlc3MuXG5cdCAqXG5cdCAqL1xuXHRvbktleVByZXNzKGU6S2V5Ym9hcmRFdmVudCk6dm9pZCB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKHNlbGYuaXNMb2NrZWQpe1xuXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSB8fCBlLndoaWNoKTtcblx0XHRpZiAoc2VsZi5zZXR0aW5ncy5jcmVhdGUgJiYgc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnbXVsdGknICYmIGNoYXJhY3RlciA9PT0gc2VsZi5zZXR0aW5ncy5kZWxpbWl0ZXIpIHtcblx0XHRcdHNlbGYuY3JlYXRlSXRlbSgpO1xuXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGtleWRvd24uXG5cdCAqXG5cdCAqL1xuXHRvbktleURvd24oZTpLZXlib2FyZEV2ZW50KTp2b2lkIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRzZWxmLmlnbm9yZUhvdmVyID0gdHJ1ZTtcblxuXHRcdGlmIChzZWxmLmlzTG9ja2VkKSB7XG5cdFx0XHRpZiAoZS5rZXlDb2RlICE9PSBjb25zdGFudHMuS0VZX1RBQikge1xuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGUua2V5Q29kZSkge1xuXG5cdFx0XHQvLyBjdHJsK0E6IHNlbGVjdCBhbGxcblx0XHRcdGNhc2UgY29uc3RhbnRzLktFWV9BOlxuXHRcdFx0XHRpZiggaXNLZXlEb3duKGNvbnN0YW50cy5LRVlfU0hPUlRDVVQsZSkgKXtcblx0XHRcdFx0XHRpZiggc2VsZi5jb250cm9sX2lucHV0LnZhbHVlID09ICcnICl7XG5cdFx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0XHRcdHNlbGYuc2VsZWN0QWxsKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBlc2M6IGNsb3NlIGRyb3Bkb3duXG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfRVNDOlxuXHRcdFx0XHRpZiAoc2VsZi5pc09wZW4pIHtcblx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlLHRydWUpO1xuXHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyBkb3duOiBvcGVuIGRyb3Bkb3duIG9yIG1vdmUgc2VsZWN0aW9uIGRvd25cblx0XHRcdGNhc2UgY29uc3RhbnRzLktFWV9ET1dOOlxuXHRcdFx0XHRpZiAoIXNlbGYuaXNPcGVuICYmIHNlbGYuaGFzT3B0aW9ucykge1xuXHRcdFx0XHRcdHNlbGYub3BlbigpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuYWN0aXZlT3B0aW9uKSB7XG5cdFx0XHRcdFx0bGV0IG5leHQgPSBzZWxmLmdldEFkamFjZW50KHNlbGYuYWN0aXZlT3B0aW9uLCAxKTtcblx0XHRcdFx0XHRpZiAobmV4dCkgc2VsZi5zZXRBY3RpdmVPcHRpb24obmV4dCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gdXA6IG1vdmUgc2VsZWN0aW9uIHVwXG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfVVA6XG5cdFx0XHRcdGlmIChzZWxmLmFjdGl2ZU9wdGlvbikge1xuXHRcdFx0XHRcdGxldCBwcmV2ID0gc2VsZi5nZXRBZGphY2VudChzZWxmLmFjdGl2ZU9wdGlvbiwgLTEpO1xuXHRcdFx0XHRcdGlmIChwcmV2KSBzZWxmLnNldEFjdGl2ZU9wdGlvbihwcmV2KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyByZXR1cm46IHNlbGVjdCBhY3RpdmUgb3B0aW9uXG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfUkVUVVJOOlxuXHRcdFx0XHRpZiggc2VsZi5jYW5TZWxlY3Qoc2VsZi5hY3RpdmVPcHRpb24pICl7XG5cdFx0XHRcdFx0c2VsZi5vbk9wdGlvblNlbGVjdChlLHNlbGYuYWN0aXZlT3B0aW9uISk7XG5cdFx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cblx0XHRcdFx0Ly8gaWYgdGhlIG9wdGlvbl9jcmVhdGU9bnVsbCwgdGhlIGRyb3Bkb3duIG1pZ2h0IGJlIGNsb3NlZFxuXHRcdFx0XHR9ZWxzZSBpZiAoc2VsZi5zZXR0aW5ncy5jcmVhdGUgJiYgc2VsZi5jcmVhdGVJdGVtKCkpIHtcblx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdFx0XHQvLyBkb24ndCBzdWJtaXQgZm9ybSB3aGVuIHNlYXJjaGluZyBmb3IgYSB2YWx1ZVxuXHRcdFx0XHR9ZWxzZSBpZiggZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSBzZWxmLmNvbnRyb2xfaW5wdXQgJiYgc2VsZi5pc09wZW4gKXtcblx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gbGVmdDogbW9kaWZpeSBpdGVtIHNlbGVjdGlvbiB0byB0aGUgbGVmdFxuXHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX0xFRlQ6XG5cdFx0XHRcdHNlbGYuYWR2YW5jZVNlbGVjdGlvbigtMSwgZSk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gcmlnaHQ6IG1vZGlmaXkgaXRlbSBzZWxlY3Rpb24gdG8gdGhlIHJpZ2h0XG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfUklHSFQ6XG5cdFx0XHRcdHNlbGYuYWR2YW5jZVNlbGVjdGlvbigxLCBlKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyB0YWI6IHNlbGVjdCBhY3RpdmUgb3B0aW9uIGFuZC9vciBjcmVhdGUgaXRlbVxuXHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX1RBQjpcblxuXHRcdFx0XHRpZiggc2VsZi5zZXR0aW5ncy5zZWxlY3RPblRhYiApe1xuXHRcdFx0XHRcdGlmKCBzZWxmLmNhblNlbGVjdChzZWxmLmFjdGl2ZU9wdGlvbikgKXtcblx0XHRcdFx0XHRcdHNlbGYub25PcHRpb25TZWxlY3QoZSxzZWxmLmFjdGl2ZU9wdGlvbiEpO1xuXG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IGRlZmF1bHQgW3RhYl0gYmVoYXZpb3VyIG9mIGp1bXAgdG8gdGhlIG5leHQgZmllbGRcblx0XHRcdFx0XHRcdC8vIGlmIHNlbGVjdCBpc0Z1bGwsIHRoZW4gdGhlIGRyb3Bkb3duIHdvbid0IGJlIG9wZW4gYW5kIFt0YWJdIHdpbGwgd29yayBub3JtYWxseVxuXHRcdFx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLmNyZWF0ZUl0ZW0oKSkge1xuXHRcdFx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gZGVsZXRlfGJhY2tzcGFjZTogZGVsZXRlIGl0ZW1zXG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfQkFDS1NQQUNFOlxuXHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX0RFTEVURTpcblx0XHRcdFx0c2VsZi5kZWxldGVTZWxlY3Rpb24oZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBkb24ndCBlbnRlciB0ZXh0IGluIHRoZSBjb250cm9sX2lucHV0IHdoZW4gYWN0aXZlIGl0ZW1zIGFyZSBzZWxlY3RlZFxuXHRcdGlmKCBzZWxmLmlzSW5wdXRIaWRkZW4gJiYgIWlzS2V5RG93bihjb25zdGFudHMuS0VZX1NIT1JUQ1VULGUpICl7XG5cdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4ga2V5dXAuXG5cdCAqXG5cdCAqL1xuXHRvbklucHV0KGU6TW91c2VFdmVudHxLZXlib2FyZEV2ZW50KTp2b2lkIHtcblx0XHRcblx0XHRpZiggdGhpcy5pc0xvY2tlZCApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHZhbHVlID0gdGhpcy5pbnB1dFZhbHVlKCk7XG5cdFx0aWYoIHRoaXMubGFzdFZhbHVlID09PSB2YWx1ZSApIHJldHVybjtcblx0XHR0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuXHRcdFxuXHRcdGlmKCB2YWx1ZSA9PSAnJyApe1xuXHRcdFx0dGhpcy5fb25JbnB1dCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCB0aGlzLnJlZnJlc2hUaW1lb3V0ICl7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5yZWZyZXNoVGltZW91dCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5yZWZyZXNoVGltZW91dCA9IHRpbWVvdXQoKCk9PiB7XG5cdFx0XHR0aGlzLnJlZnJlc2hUaW1lb3V0ID0gbnVsbDtcblx0XHRcdHRoaXMuX29uSW5wdXQoKTtcblx0XHR9LCB0aGlzLnNldHRpbmdzLnJlZnJlc2hUaHJvdHRsZSk7XG5cdH1cblxuXHRfb25JbnB1dCgpOnZvaWQge1xuXHRcdGNvbnN0IHZhbHVlID0gdGhpcy5sYXN0VmFsdWU7XG5cblx0XHRpZiggdGhpcy5zZXR0aW5ncy5zaG91bGRMb2FkLmNhbGwodGhpcyx2YWx1ZSkgKXtcblx0XHRcdHRoaXMubG9hZCh2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5yZWZyZXNoT3B0aW9ucygpO1xuXHRcdHRoaXMudHJpZ2dlcigndHlwZScsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciByb2xscyBvdmVyXG5cdCAqIGFuIG9wdGlvbiBpbiB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG5cdCAqXG5cdCAqL1xuXHRvbk9wdGlvbkhvdmVyKCBldnQ6TW91c2VFdmVudHxLZXlib2FyZEV2ZW50LCBvcHRpb246SFRNTEVsZW1lbnQgKTp2b2lke1xuXHRcdGlmKCB0aGlzLmlnbm9yZUhvdmVyICkgcmV0dXJuO1xuXHRcdHRoaXMuc2V0QWN0aXZlT3B0aW9uKG9wdGlvbiwgZmFsc2UpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGZvY3VzLlxuXHQgKlxuXHQgKi9cblx0b25Gb2N1cyhlPzpNb3VzZUV2ZW50fEtleWJvYXJkRXZlbnQpOnZvaWQge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgd2FzRm9jdXNlZCA9IHNlbGYuaXNGb2N1c2VkO1xuXG5cdFx0aWYoIHNlbGYuaXNEaXNhYmxlZCB8fCBzZWxmLmlzUmVhZE9ubHkgKXtcblx0XHRcdHNlbGYuYmx1cigpO1xuXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHNlbGYuaWdub3JlRm9jdXMpIHJldHVybjtcblx0XHRzZWxmLmlzRm9jdXNlZCA9IHRydWU7XG5cdFx0aWYoIHNlbGYuc2V0dGluZ3MucHJlbG9hZCA9PT0gJ2ZvY3VzJyApIHNlbGYucHJlbG9hZCgpO1xuXG5cdFx0aWYgKCF3YXNGb2N1c2VkKSBzZWxmLnRyaWdnZXIoJ2ZvY3VzJyk7XG5cblx0XHRpZiAoIXNlbGYuYWN0aXZlSXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRzZWxmLmlucHV0U3RhdGUoKTtcblx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoISFzZWxmLnNldHRpbmdzLm9wZW5PbkZvY3VzKTtcblx0XHR9XG5cblx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGJsdXIuXG5cdCAqXG5cdCAqL1xuXHRvbkJsdXIoZT86Rm9jdXNFdmVudCk6dm9pZCB7XG5cblx0XHRpZiggZG9jdW1lbnQuaGFzRm9jdXMoKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYgKCFzZWxmLmlzRm9jdXNlZCkgcmV0dXJuO1xuXHRcdHNlbGYuaXNGb2N1c2VkID0gZmFsc2U7XG5cdFx0c2VsZi5pZ25vcmVGb2N1cyA9IGZhbHNlO1xuXG5cdFx0dmFyIGRlYWN0aXZhdGUgPSAoKSA9PiB7XG5cdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0oKTtcblx0XHRcdHNlbGYuc2V0Q2FyZXQoc2VsZi5pdGVtcy5sZW5ndGgpO1xuXHRcdFx0c2VsZi50cmlnZ2VyKCdibHVyJyk7XG5cdFx0fTtcblxuXHRcdGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLnNldHRpbmdzLmNyZWF0ZU9uQmx1cikge1xuXHRcdFx0c2VsZi5jcmVhdGVJdGVtKG51bGwsIGRlYWN0aXZhdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWFjdGl2YXRlKCk7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFuIG9wdGlvblxuXHQgKiBpbiB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG5cdCAqXG5cdCAqL1xuXHRvbk9wdGlvblNlbGVjdCggZXZ0Ok1vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudCwgb3B0aW9uOkhUTUxFbGVtZW50ICl7XG5cdFx0dmFyIHZhbHVlLCBzZWxmID0gdGhpcztcblxuXG5cdFx0Ly8gc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byB0cmlnZ2VyIGEgb3B0aW9uIHVuZGVyIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRpZiggb3B0aW9uLnBhcmVudEVsZW1lbnQgJiYgb3B0aW9uLnBhcmVudEVsZW1lbnQubWF0Y2hlcygnW2RhdGEtZGlzYWJsZWRdJykgKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblxuXHRcdGlmKCBvcHRpb24uY2xhc3NMaXN0LmNvbnRhaW5zKCdjcmVhdGUnKSApe1xuXHRcdFx0c2VsZi5jcmVhdGVJdGVtKG51bGwsICgpID0+IHtcblx0XHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCkge1xuXHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlID0gb3B0aW9uLmRhdGFzZXQudmFsdWU7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdFx0XHRcdHNlbGYuYWRkSXRlbSh2YWx1ZSk7XG5cdFx0XHRcdGlmIChzZWxmLnNldHRpbmdzLmNsb3NlQWZ0ZXJTZWxlY3QpIHtcblx0XHRcdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiggIXNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkICYmIGV2dC50eXBlICYmIC9jbGljay8udGVzdChldnQudHlwZSkgKXtcblx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihvcHRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBvcHRpb24gY2FuIGJlIHNlbGVjdGVkXG5cdCAqXG5cdCAqL1xuXHRjYW5TZWxlY3Qob3B0aW9uOkhUTUxFbGVtZW50fG51bGwpOmJvb2xlYW57XG5cblx0XHRpZiggdGhpcy5pc09wZW4gJiYgb3B0aW9uICYmIHRoaXMuZHJvcGRvd25fY29udGVudC5jb250YWlucyhvcHRpb24pICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gaXRlbVxuXHQgKiB0aGF0IGhhcyBiZWVuIHNlbGVjdGVkLlxuXHQgKlxuXHQgKi9cblx0b25JdGVtU2VsZWN0KCBldnQ/Ok1vdXNlRXZlbnQsIGl0ZW0/OlRvbUl0ZW0gKTpib29sZWFue1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGlmKCAhc2VsZi5pc0xvY2tlZCAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aScgKXtcblx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCk7XG5cdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0oaXRlbSwgZXZ0KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBpbnZva2Vcblx0ICogdGhlIHVzZXItcHJvdmlkZWQgb3B0aW9uIHByb3ZpZGVyIC8gbG9hZGVyXG5cdCAqXG5cdCAqIE5vdGUsIHRoZXJlIGlzIGEgc3VidGxlIGRpZmZlcmVuY2UgYmV0d2VlblxuXHQgKiB0aGlzLmNhbkxvYWQoKSBhbmQgdGhpcy5zZXR0aW5ncy5zaG91bGRMb2FkKCk7XG5cdCAqXG5cdCAqXHQtIHNldHRpbmdzLnNob3VsZExvYWQoKSBpcyBhIHVzZXItaW5wdXQgdmFsaWRhdG9yLlxuXHQgKlx0V2hlbiBmYWxzZSBpcyByZXR1cm5lZCwgdGhlIG5vdF9sb2FkaW5nIHRlbXBsYXRlXG5cdCAqXHR3aWxsIGJlIGFkZGVkIHRvIHRoZSBkcm9wZG93blxuXHQgKlxuXHQgKlx0LSBjYW5Mb2FkKCkgaXMgbG93ZXIgbGV2ZWwgdmFsaWRhdG9yIHRoYXQgY2hlY2tzXG5cdCAqIFx0dGhlIFRvbSBTZWxlY3QgaW5zdGFuY2UuIFRoZXJlIGlzIG5vIGluaGVyZW50IHVzZXJcblx0ICpcdGZlZWRiYWNrIHdoZW4gY2FuTG9hZCByZXR1cm5zIGZhbHNlXG5cdCAqXG5cdCAqL1xuXHRjYW5Mb2FkKHZhbHVlOnN0cmluZyk6Ym9vbGVhbntcblxuXHRcdGlmKCAhdGhpcy5zZXR0aW5ncy5sb2FkICkgcmV0dXJuIGZhbHNlO1xuXHRcdGlmKCB0aGlzLmxvYWRlZFNlYXJjaGVzLmhhc093blByb3BlcnR5KHZhbHVlKSApIHJldHVybiBmYWxzZTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludm9rZXMgdGhlIHVzZXItcHJvdmlkZWQgb3B0aW9uIHByb3ZpZGVyIC8gbG9hZGVyLlxuXHQgKlxuXHQgKi9cblx0bG9hZCh2YWx1ZTpzdHJpbmcpOnZvaWQge1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYoICFzZWxmLmNhbkxvYWQodmFsdWUpICkgcmV0dXJuO1xuXG5cdFx0YWRkQ2xhc3NlcyhzZWxmLndyYXBwZXIsc2VsZi5zZXR0aW5ncy5sb2FkaW5nQ2xhc3MpO1xuXHRcdHNlbGYubG9hZGluZysrO1xuXG5cdFx0Y29uc3QgY2FsbGJhY2sgPSBzZWxmLmxvYWRDYWxsYmFjay5iaW5kKHNlbGYpO1xuXHRcdHNlbGYuc2V0dGluZ3MubG9hZC5jYWxsKHNlbGYsIHZhbHVlLCBjYWxsYmFjayk7XG5cdH1cblxuXHQvKipcblx0ICogSW52b2tlZCBieSB0aGUgdXNlci1wcm92aWRlZCBvcHRpb24gcHJvdmlkZXJcblx0ICpcblx0ICovXG5cdGxvYWRDYWxsYmFjayggb3B0aW9uczpUb21PcHRpb25bXSwgb3B0Z3JvdXBzOlRvbU9wdGlvbltdICk6dm9pZHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRzZWxmLmxvYWRpbmcgPSBNYXRoLm1heChzZWxmLmxvYWRpbmcgLSAxLCAwKTtcblx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cblx0XHRzZWxmLmNsZWFyQWN0aXZlT3B0aW9uKCk7IC8vIHdoZW4gbmV3IHJlc3VsdHMgbG9hZCwgZm9jdXMgc2hvdWxkIGJlIG9uIGZpcnN0IG9wdGlvblxuXHRcdHNlbGYuc2V0dXBPcHRpb25zKG9wdGlvbnMsb3B0Z3JvdXBzKTtcblxuXHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoc2VsZi5pc0ZvY3VzZWQgJiYgIXNlbGYuaXNJbnB1dEhpZGRlbik7XG5cblx0XHRpZiAoIXNlbGYubG9hZGluZykge1xuXHRcdFx0cmVtb3ZlQ2xhc3NlcyhzZWxmLndyYXBwZXIsc2VsZi5zZXR0aW5ncy5sb2FkaW5nQ2xhc3MpO1xuXHRcdH1cblxuXHRcdHNlbGYudHJpZ2dlcignbG9hZCcsIG9wdGlvbnMsIG9wdGdyb3Vwcyk7XG5cdH1cblxuXHRwcmVsb2FkKCk6dm9pZHtcblx0XHR2YXIgY2xhc3NMaXN0ID0gdGhpcy53cmFwcGVyLmNsYXNzTGlzdDtcblx0XHRpZiggY2xhc3NMaXN0LmNvbnRhaW5zKCdwcmVsb2FkZWQnKSApIHJldHVybjtcblx0XHRjbGFzc0xpc3QuYWRkKCdwcmVsb2FkZWQnKTtcblx0XHR0aGlzLmxvYWQoJycpO1xuXHR9XG5cblxuXHQvKipcblx0ICogU2V0cyB0aGUgaW5wdXQgZmllbGQgb2YgdGhlIGNvbnRyb2wgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cblx0ICpcblx0ICovXG5cdHNldFRleHRib3hWYWx1ZSh2YWx1ZTpzdHJpbmcgPSAnJykge1xuXHRcdHZhciBpbnB1dCA9IHRoaXMuY29udHJvbF9pbnB1dDtcblx0XHR2YXIgY2hhbmdlZCA9IGlucHV0LnZhbHVlICE9PSB2YWx1ZTtcblx0XHRpZiAoY2hhbmdlZCkge1xuXHRcdFx0aW5wdXQudmFsdWUgPSB2YWx1ZTtcblx0XHRcdHRyaWdnZXJFdmVudChpbnB1dCwndXBkYXRlJyk7XG5cdFx0XHR0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbC4gSWYgbXVsdGlwbGUgaXRlbXNcblx0ICogY2FuIGJlIHNlbGVjdGVkIChlLmcuIDxzZWxlY3QgbXVsdGlwbGU+KSwgdGhpcyByZXR1cm5zXG5cdCAqIGFuIGFycmF5LiBJZiBvbmx5IG9uZSBpdGVtIGNhbiBiZSBzZWxlY3RlZCwgdGhpc1xuXHQgKiByZXR1cm5zIGEgc3RyaW5nLlxuXHQgKlxuXHQgKi9cblx0Z2V0VmFsdWUoKTpzdHJpbmd8c3RyaW5nW10ge1xuXG5cdFx0aWYoIHRoaXMuaXNfc2VsZWN0X3RhZyAmJiB0aGlzLmlucHV0Lmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlbXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuaXRlbXMuam9pbih0aGlzLnNldHRpbmdzLmRlbGltaXRlcik7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBzZWxlY3RlZCBpdGVtcyB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdCAqXG5cdCAqL1xuXHRzZXRWYWx1ZSggdmFsdWU6c3RyaW5nfHN0cmluZ1tdLCBzaWxlbnQ/OmJvb2xlYW4gKTp2b2lke1xuXHRcdHZhciBldmVudHMgPSBzaWxlbnQgPyBbXSA6IFsnY2hhbmdlJ107XG5cblx0XHRkZWJvdW5jZV9ldmVudHModGhpcywgZXZlbnRzLCgpID0+IHtcblx0XHRcdHRoaXMuY2xlYXIoc2lsZW50KTtcblx0XHRcdHRoaXMuYWRkSXRlbXModmFsdWUsIHNpbGVudCk7XG5cdFx0fSk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIG51bWJlciBvZiBtYXggaXRlbXMgdG8gdGhlIGdpdmVuIHZhbHVlXG5cdCAqXG5cdCAqL1xuXHRzZXRNYXhJdGVtcyh2YWx1ZTpudWxsfG51bWJlcil7XG5cdFx0aWYodmFsdWUgPT09IDApIHZhbHVlID0gbnVsbDsgLy9yZXNldCB0byB1bmxpbWl0ZWQgaXRlbXMuXG5cdFx0dGhpcy5zZXR0aW5ncy5tYXhJdGVtcyA9IHZhbHVlO1xuXHRcdHRoaXMucmVmcmVzaFN0YXRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgc2VsZWN0ZWQgaXRlbS5cblx0ICpcblx0ICovXG5cdHNldEFjdGl2ZUl0ZW0oIGl0ZW0/OlRvbUl0ZW0sIGU/Ok1vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudCApe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgZXZlbnROYW1lO1xuXHRcdHZhciBpLCBiZWdpbiwgZW5kLCBzd2FwO1xuXHRcdHZhciBsYXN0O1xuXG5cdFx0aWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScpIHJldHVybjtcblxuXHRcdC8vIGNsZWFyIHRoZSBhY3RpdmUgc2VsZWN0aW9uXG5cdFx0aWYoICFpdGVtICl7XG5cdFx0XHRzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcblx0XHRcdGlmIChzZWxmLmlzRm9jdXNlZCkge1xuXHRcdFx0XHRzZWxmLmlucHV0U3RhdGUoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBtb2RpZnkgc2VsZWN0aW9uXG5cdFx0ZXZlbnROYW1lID0gZSAmJiBlLnR5cGUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmIChldmVudE5hbWUgPT09ICdjbGljaycgJiYgaXNLZXlEb3duKCdzaGlmdEtleScsZSkgJiYgc2VsZi5hY3RpdmVJdGVtcy5sZW5ndGgpIHtcblx0XHRcdGxhc3RcdD0gc2VsZi5nZXRMYXN0QWN0aXZlKCk7XG5cdFx0XHRiZWdpblx0PSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHNlbGYuY29udHJvbC5jaGlsZHJlbiwgbGFzdCk7XG5cdFx0XHRlbmRcdFx0PSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHNlbGYuY29udHJvbC5jaGlsZHJlbiwgaXRlbSk7XG5cblx0XHRcdGlmIChiZWdpbiA+IGVuZCkge1xuXHRcdFx0XHRzd2FwICA9IGJlZ2luO1xuXHRcdFx0XHRiZWdpbiA9IGVuZDtcblx0XHRcdFx0ZW5kICAgPSBzd2FwO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChpID0gYmVnaW47IGkgPD0gZW5kOyBpKyspIHtcblx0XHRcdFx0aXRlbSA9IHNlbGYuY29udHJvbC5jaGlsZHJlbltpXSBhcyBUb21JdGVtO1xuXHRcdFx0XHRpZiAoc2VsZi5hY3RpdmVJdGVtcy5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuXHRcdFx0XHRcdHNlbGYuc2V0QWN0aXZlSXRlbUNsYXNzKGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHR9IGVsc2UgaWYgKChldmVudE5hbWUgPT09ICdjbGljaycgJiYgaXNLZXlEb3duKGNvbnN0YW50cy5LRVlfU0hPUlRDVVQsZSkgKSB8fCAoZXZlbnROYW1lID09PSAna2V5ZG93bicgJiYgaXNLZXlEb3duKCdzaGlmdEtleScsZSkpKSB7XG5cdFx0XHRpZiggaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICl7XG5cdFx0XHRcdHNlbGYucmVtb3ZlQWN0aXZlSXRlbSggaXRlbSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYuY2xlYXJBY3RpdmVJdGVtcygpO1xuXHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoaXRlbSk7XG5cdFx0fVxuXG5cdFx0Ly8gZW5zdXJlIGNvbnRyb2wgaGFzIGZvY3VzXG5cdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0aWYgKCFzZWxmLmlzRm9jdXNlZCkge1xuXHRcdFx0c2VsZi5mb2N1cygpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGFjdGl2ZSBhbmQgbGFzdC1hY3RpdmUgY2xhc3Nlc1xuXHQgKlxuXHQgKi9cblx0c2V0QWN0aXZlSXRlbUNsYXNzKCBpdGVtOlRvbUl0ZW0gKXtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRjb25zdCBsYXN0X2FjdGl2ZSA9IHNlbGYuY29udHJvbC5xdWVyeVNlbGVjdG9yKCcubGFzdC1hY3RpdmUnKTtcblx0XHRpZiggbGFzdF9hY3RpdmUgKSByZW1vdmVDbGFzc2VzKGxhc3RfYWN0aXZlIGFzIEhUTUxFbGVtZW50LCdsYXN0LWFjdGl2ZScpO1xuXG5cdFx0YWRkQ2xhc3NlcyhpdGVtLCdhY3RpdmUgbGFzdC1hY3RpdmUnKTtcblx0XHRzZWxmLnRyaWdnZXIoJ2l0ZW1fc2VsZWN0JywgaXRlbSk7XG5cdFx0aWYoIHNlbGYuYWN0aXZlSXRlbXMuaW5kZXhPZihpdGVtKSA9PSAtMSApe1xuXHRcdFx0c2VsZi5hY3RpdmVJdGVtcy5wdXNoKCBpdGVtICk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhY3RpdmUgaXRlbVxuXHQgKlxuXHQgKi9cblx0cmVtb3ZlQWN0aXZlSXRlbSggaXRlbTpUb21JdGVtICl7XG5cdFx0dmFyIGlkeCA9IHRoaXMuYWN0aXZlSXRlbXMuaW5kZXhPZihpdGVtKTtcblx0XHR0aGlzLmFjdGl2ZUl0ZW1zLnNwbGljZShpZHgsIDEpO1xuXHRcdHJlbW92ZUNsYXNzZXMoaXRlbSwnYWN0aXZlJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCB0aGUgYWN0aXZlIGl0ZW1zXG5cdCAqXG5cdCAqL1xuXHRjbGVhckFjdGl2ZUl0ZW1zKCl7XG5cdFx0cmVtb3ZlQ2xhc3Nlcyh0aGlzLmFjdGl2ZUl0ZW1zLCdhY3RpdmUnKTtcblx0XHR0aGlzLmFjdGl2ZUl0ZW1zID0gW107XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgc2VsZWN0ZWQgaXRlbSBpbiB0aGUgZHJvcGRvd24gbWVudVxuXHQgKiBvZiBhdmFpbGFibGUgb3B0aW9ucy5cblx0ICpcblx0ICovXG5cdHNldEFjdGl2ZU9wdGlvbiggb3B0aW9uOm51bGx8SFRNTEVsZW1lbnQsc2Nyb2xsOmJvb2xlYW49dHJ1ZSApOnZvaWR7XG5cblx0XHRpZiggb3B0aW9uID09PSB0aGlzLmFjdGl2ZU9wdGlvbiApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuY2xlYXJBY3RpdmVPcHRpb24oKTtcblx0XHRpZiggIW9wdGlvbiApIHJldHVybjtcblxuXHRcdHRoaXMuYWN0aXZlT3B0aW9uID0gb3B0aW9uO1xuXHRcdHNldEF0dHIodGhpcy5mb2N1c19ub2RlLHsnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzpvcHRpb24uZ2V0QXR0cmlidXRlKCdpZCcpfSk7XG5cdFx0c2V0QXR0cihvcHRpb24seydhcmlhLXNlbGVjdGVkJzondHJ1ZSd9KTtcblx0XHRhZGRDbGFzc2VzKG9wdGlvbiwnYWN0aXZlJyk7XG5cdFx0aWYoIHNjcm9sbCApIHRoaXMuc2Nyb2xsVG9PcHRpb24ob3B0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkcm9wZG93bl9jb250ZW50IHNjcm9sbFRvcCB0byBkaXNwbGF5IHRoZSBvcHRpb25cblx0ICpcblx0ICovXG5cdHNjcm9sbFRvT3B0aW9uKCBvcHRpb246bnVsbHxIVE1MRWxlbWVudCwgYmVoYXZpb3I/OnN0cmluZyApOnZvaWR7XG5cblx0XHRpZiggIW9wdGlvbiApIHJldHVybjtcblxuXHRcdGNvbnN0IGNvbnRlbnRcdFx0PSB0aGlzLmRyb3Bkb3duX2NvbnRlbnQ7XG5cdFx0Y29uc3QgaGVpZ2h0X21lbnVcdD0gY29udGVudC5jbGllbnRIZWlnaHQ7XG5cdFx0Y29uc3Qgc2Nyb2xsVG9wXHRcdD0gY29udGVudC5zY3JvbGxUb3AgfHwgMDtcblx0XHRjb25zdCBoZWlnaHRfaXRlbVx0PSBvcHRpb24ub2Zmc2V0SGVpZ2h0O1xuXHRcdGNvbnN0IHlcdFx0XHRcdD0gb3B0aW9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgc2Nyb2xsVG9wO1xuXG5cdFx0aWYgKHkgKyBoZWlnaHRfaXRlbSA+IGhlaWdodF9tZW51ICsgc2Nyb2xsVG9wKSB7XG5cdFx0XHR0aGlzLnNjcm9sbCh5IC0gaGVpZ2h0X21lbnUgKyBoZWlnaHRfaXRlbSwgYmVoYXZpb3IpO1xuXG5cdFx0fSBlbHNlIGlmICh5IDwgc2Nyb2xsVG9wKSB7XG5cdFx0XHR0aGlzLnNjcm9sbCh5LCBiZWhhdmlvcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNjcm9sbCB0aGUgZHJvcGRvd24gdG8gdGhlIGdpdmVuIHBvc2l0aW9uXG5cdCAqXG5cdCAqL1xuXHRzY3JvbGwoIHNjcm9sbFRvcDpudW1iZXIsIGJlaGF2aW9yPzpzdHJpbmcgKTp2b2lke1xuXHRcdGNvbnN0IGNvbnRlbnQgPSB0aGlzLmRyb3Bkb3duX2NvbnRlbnQ7XG5cdFx0aWYoIGJlaGF2aW9yICl7XG5cdFx0XHRjb250ZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gYmVoYXZpb3I7XG5cdFx0fVxuXHRcdGNvbnRlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuXHRcdGNvbnRlbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnJztcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIGFjdGl2ZSBvcHRpb25cblx0ICpcblx0ICovXG5cdGNsZWFyQWN0aXZlT3B0aW9uKCl7XG5cdFx0aWYoIHRoaXMuYWN0aXZlT3B0aW9uICl7XG5cdFx0XHRyZW1vdmVDbGFzc2VzKHRoaXMuYWN0aXZlT3B0aW9uLCdhY3RpdmUnKTtcblx0XHRcdHNldEF0dHIodGhpcy5hY3RpdmVPcHRpb24seydhcmlhLXNlbGVjdGVkJzpudWxsfSk7XG5cdFx0fVxuXHRcdHRoaXMuYWN0aXZlT3B0aW9uID0gbnVsbDtcblx0XHRzZXRBdHRyKHRoaXMuZm9jdXNfbm9kZSx7J2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6bnVsbH0pO1xuXHR9XG5cblxuXHQvKipcblx0ICogU2VsZWN0cyBhbGwgaXRlbXMgKENUUkwgKyBBKS5cblx0ICovXG5cdHNlbGVjdEFsbCgpIHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRcdGlmIChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnKSByZXR1cm47XG5cblx0XHRjb25zdCBhY3RpdmVJdGVtcyA9IHNlbGYuY29udHJvbENoaWxkcmVuKCk7XG5cblx0XHRpZiggIWFjdGl2ZUl0ZW1zLmxlbmd0aCApIHJldHVybjtcblxuXHRcdHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHRcdHNlbGYuY2xvc2UoKTtcblxuXHRcdHNlbGYuYWN0aXZlSXRlbXMgPSBhY3RpdmVJdGVtcztcblx0XHRpdGVyYXRlKCBhY3RpdmVJdGVtcywgKGl0ZW06VG9tSXRlbSkgPT4ge1xuXHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoaXRlbSk7XG5cdFx0fSk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBjb250cm9sX2lucHV0IHNob3VsZCBiZSBpbiBhIGhpZGRlbiBvciB2aXNpYmxlIHN0YXRlXG5cdCAqXG5cdCAqL1xuXHRpbnB1dFN0YXRlKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYoICFzZWxmLmNvbnRyb2wuY29udGFpbnMoc2VsZi5jb250cm9sX2lucHV0KSApIHJldHVybjtcblxuXHRcdHNldEF0dHIoc2VsZi5jb250cm9sX2lucHV0LHtwbGFjZWhvbGRlcjpzZWxmLnNldHRpbmdzLnBsYWNlaG9sZGVyfSk7XG5cblx0XHRpZiggc2VsZi5hY3RpdmVJdGVtcy5sZW5ndGggPiAwIHx8ICghc2VsZi5pc0ZvY3VzZWQgJiYgc2VsZi5zZXR0aW5ncy5oaWRlUGxhY2Vob2xkZXIgJiYgc2VsZi5pdGVtcy5sZW5ndGggPiAwKSApe1xuXHRcdFx0c2VsZi5zZXRUZXh0Ym94VmFsdWUoKTtcblx0XHRcdHNlbGYuaXNJbnB1dEhpZGRlbiA9IHRydWU7XG5cblx0XHR9ZWxzZXtcblxuXHRcdFx0aWYoIHNlbGYuc2V0dGluZ3MuaGlkZVBsYWNlaG9sZGVyICYmIHNlbGYuaXRlbXMubGVuZ3RoID4gMCApe1xuXHRcdFx0XHRzZXRBdHRyKHNlbGYuY29udHJvbF9pbnB1dCx7cGxhY2Vob2xkZXI6Jyd9KTtcblx0XHRcdH1cblx0XHRcdHNlbGYuaXNJbnB1dEhpZGRlbiA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHNlbGYud3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKCdpbnB1dC1oaWRkZW4nLCBzZWxmLmlzSW5wdXRIaWRkZW4gKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGlucHV0IHZhbHVlXG5cdCAqL1xuXHRpbnB1dFZhbHVlKCl7XG5cdFx0cmV0dXJuIHRoaXMuY29udHJvbF9pbnB1dC52YWx1ZS50cmltKCk7XG5cdH1cblxuXHQvKipcblx0ICogR2l2ZXMgdGhlIGNvbnRyb2wgZm9jdXMuXG5cdCAqL1xuXHRmb2N1cygpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYoIHNlbGYuaXNEaXNhYmxlZCB8fCBzZWxmLmlzUmVhZE9ubHkpIHJldHVybjtcblxuXHRcdHNlbGYuaWdub3JlRm9jdXMgPSB0cnVlO1xuXG5cdFx0aWYoIHNlbGYuY29udHJvbF9pbnB1dC5vZmZzZXRXaWR0aCApe1xuXHRcdFx0c2VsZi5jb250cm9sX2lucHV0LmZvY3VzKCk7XG5cdFx0fWVsc2V7XG5cdFx0XHRzZWxmLmZvY3VzX25vZGUuZm9jdXMoKTtcblx0XHR9XG5cblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHNlbGYuaWdub3JlRm9jdXMgPSBmYWxzZTtcblx0XHRcdHNlbGYub25Gb2N1cygpO1xuXHRcdH0sIDApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZvcmNlcyB0aGUgY29udHJvbCBvdXQgb2YgZm9jdXMuXG5cdCAqXG5cdCAqL1xuXHRibHVyKCk6dm9pZCB7XG5cdFx0dGhpcy5mb2N1c19ub2RlLmJsdXIoKTtcblx0XHR0aGlzLm9uQmx1cigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHNjb3JlcyBhbiBvYmplY3Rcblx0ICogdG8gc2hvdyBob3cgZ29vZCBvZiBhIG1hdGNoIGl0IGlzIHRvIHRoZVxuXHQgKiBwcm92aWRlZCBxdWVyeS5cblx0ICpcblx0ICogQHJldHVybiB7ZnVuY3Rpb259XG5cdCAqL1xuXHRnZXRTY29yZUZ1bmN0aW9uKHF1ZXJ5OnN0cmluZykge1xuXHRcdHJldHVybiB0aGlzLnNpZnRlci5nZXRTY29yZUZ1bmN0aW9uKHF1ZXJ5LCB0aGlzLmdldFNlYXJjaE9wdGlvbnMoKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBzZWFyY2ggb3B0aW9ucyBmb3Igc2lmdGVyICh0aGUgc3lzdGVtXG5cdCAqIGZvciBzY29yaW5nIGFuZCBzb3J0aW5nIHJlc3VsdHMpLlxuXHQgKlxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmNoaWRqcy9zaWZ0ZXIuanNcblx0ICogQHJldHVybiB7b2JqZWN0fVxuXHQgKi9cblx0Z2V0U2VhcmNoT3B0aW9ucygpIHtcblx0XHR2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuXHRcdHZhciBzb3J0ID0gc2V0dGluZ3Muc29ydEZpZWxkO1xuXHRcdGlmICh0eXBlb2Ygc2V0dGluZ3Muc29ydEZpZWxkID09PSAnc3RyaW5nJykge1xuXHRcdFx0c29ydCA9IFt7ZmllbGQ6IHNldHRpbmdzLnNvcnRGaWVsZH1dO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRmaWVsZHMgICAgICA6IHNldHRpbmdzLnNlYXJjaEZpZWxkLFxuXHRcdFx0Y29uanVuY3Rpb24gOiBzZXR0aW5ncy5zZWFyY2hDb25qdW5jdGlvbixcblx0XHRcdHNvcnQgICAgICAgIDogc29ydCxcblx0XHRcdG5lc3RpbmcgICAgIDogc2V0dGluZ3MubmVzdGluZ1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogU2VhcmNoZXMgdGhyb3VnaCBhdmFpbGFibGUgb3B0aW9ucyBhbmQgcmV0dXJuc1xuXHQgKiBhIHNvcnRlZCBhcnJheSBvZiBtYXRjaGVzLlxuXHQgKlxuXHQgKi9cblx0c2VhcmNoKHF1ZXJ5OnN0cmluZykgOiBSZXR1cm5UeXBlPFNpZnRlclsnc2VhcmNoJ10+e1xuXHRcdHZhciByZXN1bHQsIGNhbGN1bGF0ZVNjb3JlO1xuXHRcdHZhciBzZWxmICAgICA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgID0gdGhpcy5nZXRTZWFyY2hPcHRpb25zKCk7XG5cblx0XHQvLyB2YWxpZGF0ZSB1c2VyLXByb3ZpZGVkIHJlc3VsdCBzY29yaW5nIGZ1bmN0aW9uXG5cdFx0aWYgKCBzZWxmLnNldHRpbmdzLnNjb3JlICl7XG5cdFx0XHRjYWxjdWxhdGVTY29yZSA9IHNlbGYuc2V0dGluZ3Muc2NvcmUuY2FsbChzZWxmLHF1ZXJ5KTtcblx0XHRcdGlmICh0eXBlb2YgY2FsY3VsYXRlU2NvcmUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUb20gU2VsZWN0IFwic2NvcmVcIiBzZXR0aW5nIG11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHBlcmZvcm0gc2VhcmNoXG5cdFx0aWYgKHF1ZXJ5ICE9PSBzZWxmLmxhc3RRdWVyeSkge1xuXHRcdFx0c2VsZi5sYXN0UXVlcnlcdFx0XHQ9IHF1ZXJ5O1xuXHRcdFx0cmVzdWx0XHRcdFx0XHRcdD0gc2VsZi5zaWZ0ZXIuc2VhcmNoKHF1ZXJ5LCBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtzY29yZTogY2FsY3VsYXRlU2NvcmV9KSk7XG5cdFx0XHRzZWxmLmN1cnJlbnRSZXN1bHRzXHRcdD0gcmVzdWx0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHRcdFx0XHRcdFx0PSBPYmplY3QuYXNzaWduKCB7fSwgc2VsZi5jdXJyZW50UmVzdWx0cyk7XG5cdFx0fVxuXG5cdFx0Ly8gZmlsdGVyIG91dCBzZWxlY3RlZCBpdGVtc1xuXHRcdGlmKCBzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCApe1xuXHRcdFx0cmVzdWx0Lml0ZW1zID0gcmVzdWx0Lml0ZW1zLmZpbHRlcigoaXRlbSkgPT4ge1xuXHRcdFx0XHRsZXQgaGFzaGVkID0gaGFzaF9rZXkoaXRlbS5pZCk7XG5cdFx0XHRcdHJldHVybiAhKGhhc2hlZCAmJiBzZWxmLml0ZW1zLmluZGV4T2YoaGFzaGVkKSAhPT0gLTEgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogUmVmcmVzaGVzIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zIHNob3duXG5cdCAqIGluIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gbWVudS5cblx0ICpcblx0ICovXG5cdHJlZnJlc2hPcHRpb25zKCB0cmlnZ2VyRHJvcGRvd246Ym9vbGVhbiA9IHRydWUgKXtcblx0XHR2YXIgaSwgaiwgaywgbiwgb3B0Z3JvdXAsIG9wdGdyb3VwcywgaHRtbDpEb2N1bWVudEZyYWdtZW50LCBoYXNfY3JlYXRlX29wdGlvbiwgYWN0aXZlX2dyb3VwO1xuXHRcdHZhciBjcmVhdGU7XG5cblx0XHR0eXBlIEdyb3VwID0ge2ZyYWdtZW50OkRvY3VtZW50RnJhZ21lbnQsb3JkZXI6bnVtYmVyLG9wdGdyb3VwOnN0cmluZ31cblx0XHRjb25zdCBncm91cHM6IHtba2V5OnN0cmluZ106bnVtYmVyfSA9IHt9O1xuXHRcdGNvbnN0IGdyb3Vwc19vcmRlcjpHcm91cFtdXHQ9IFtdO1xuXG5cdFx0dmFyIHNlbGZcdFx0XHRcdFx0PSB0aGlzO1xuXHRcdHZhciBxdWVyeVx0XHRcdFx0XHQ9IHNlbGYuaW5wdXRWYWx1ZSgpO1xuXHRcdGNvbnN0IHNhbWVfcXVlcnlcdFx0XHQ9IHF1ZXJ5ID09PSBzZWxmLmxhc3RRdWVyeSB8fCAocXVlcnkgPT0gJycgJiYgc2VsZi5sYXN0UXVlcnkgPT0gbnVsbCk7XG5cdFx0dmFyIHJlc3VsdHNcdFx0XHRcdFx0PSBzZWxmLnNlYXJjaChxdWVyeSk7XG5cdFx0dmFyIGFjdGl2ZV9vcHRpb246SFRNTEVsZW1lbnR8bnVsbCA9IG51bGw7XG5cdFx0dmFyIHNob3dfZHJvcGRvd25cdFx0XHQ9IHNlbGYuc2V0dGluZ3Muc2hvdWxkT3BlbiB8fCBmYWxzZTtcblx0XHR2YXIgZHJvcGRvd25fY29udGVudFx0XHQ9IHNlbGYuZHJvcGRvd25fY29udGVudDtcblxuXG5cdFx0aWYoIHNhbWVfcXVlcnkgKXtcblx0XHRcdGFjdGl2ZV9vcHRpb25cdFx0XHQ9IHNlbGYuYWN0aXZlT3B0aW9uO1xuXG5cdFx0XHRpZiggYWN0aXZlX29wdGlvbiApe1xuXHRcdFx0XHRhY3RpdmVfZ3JvdXAgPSBhY3RpdmVfb3B0aW9uLmNsb3Nlc3QoJ1tkYXRhLWdyb3VwXScpIGFzIEhUTUxFbGVtZW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIG1hcmt1cFxuXHRcdG4gPSByZXN1bHRzLml0ZW1zLmxlbmd0aDtcblx0XHRpZiAodHlwZW9mIHNlbGYuc2V0dGluZ3MubWF4T3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdG4gPSBNYXRoLm1pbihuLCBzZWxmLnNldHRpbmdzLm1heE9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGlmKCBuID4gMCApe1xuXHRcdFx0c2hvd19kcm9wZG93biA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gZ2V0IGZyYWdtZW50IGZvciBncm91cCBhbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBncm91cCBpbiBncm91cF9vcmRlclxuXHRcdGNvbnN0IGdldEdyb3VwRnJhZ21lbnQgPSAob3B0Z3JvdXA6c3RyaW5nLG9yZGVyOm51bWJlcik6W251bWJlcixEb2N1bWVudEZyYWdtZW50XSA9PiB7XG5cblx0XHRcdGxldCBncm91cF9vcmRlcl9pID0gZ3JvdXBzW29wdGdyb3VwXTtcblxuXHRcdFx0aWYoIGdyb3VwX29yZGVyX2kgIT09IHVuZGVmaW5lZCApe1xuXHRcdFx0XHRsZXQgb3JkZXJfZ3JvdXAgPSBncm91cHNfb3JkZXJbZ3JvdXBfb3JkZXJfaV07XG5cdFx0XHRcdGlmKCBvcmRlcl9ncm91cCAhPT0gdW5kZWZpbmVkICl7XG5cdFx0XHRcdFx0cmV0dXJuIFtncm91cF9vcmRlcl9pLG9yZGVyX2dyb3VwLmZyYWdtZW50XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgZ3JvdXBfZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRncm91cF9vcmRlcl9pID0gZ3JvdXBzX29yZGVyLmxlbmd0aDtcblx0XHRcdGdyb3Vwc19vcmRlci5wdXNoKHtmcmFnbWVudDpncm91cF9mcmFnbWVudCxvcmRlcixvcHRncm91cH0pO1xuXG5cdFx0XHRyZXR1cm4gW2dyb3VwX29yZGVyX2ksZ3JvdXBfZnJhZ21lbnRdXG5cdFx0fVxuXG5cdFx0Ly8gcmVuZGVyIGFuZCBncm91cCBhdmFpbGFibGUgb3B0aW9ucyBpbmRpdmlkdWFsbHlcblx0XHRmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cblx0XHRcdC8vIGdldCBvcHRpb24gZG9tIGVsZW1lbnRcblx0XHRcdGxldCBpdGVtXHRcdFx0PSByZXN1bHRzLml0ZW1zW2ldO1xuXHRcdFx0aWYoICFpdGVtICkgY29udGludWU7XG5cblx0XHRcdGxldCBvcHRfdmFsdWVcdFx0PSBpdGVtLmlkO1xuXHRcdFx0bGV0IG9wdGlvblx0XHRcdD0gc2VsZi5vcHRpb25zW29wdF92YWx1ZV07XG5cblx0XHRcdGlmKCBvcHRpb24gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRsZXQgb3B0X2hhc2hcdFx0PSBnZXRfaGFzaChvcHRfdmFsdWUpO1xuXHRcdFx0bGV0IG9wdGlvbl9lbFx0XHQ9IHNlbGYuZ2V0T3B0aW9uKG9wdF9oYXNoLHRydWUpIGFzIEhUTUxFbGVtZW50O1xuXG5cdFx0XHQvLyB0b2dnbGUgJ3NlbGVjdGVkJyBjbGFzc1xuXHRcdFx0aWYoICFzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCApe1xuXHRcdFx0XHRvcHRpb25fZWwuY2xhc3NMaXN0LnRvZ2dsZSgnc2VsZWN0ZWQnLCBzZWxmLml0ZW1zLmluY2x1ZGVzKG9wdF9oYXNoKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRncm91cCAgICA9IG9wdGlvbltzZWxmLnNldHRpbmdzLm9wdGdyb3VwRmllbGRdIHx8ICcnO1xuXHRcdFx0b3B0Z3JvdXBzICAgPSBBcnJheS5pc0FycmF5KG9wdGdyb3VwKSA/IG9wdGdyb3VwIDogW29wdGdyb3VwXTtcblx0XHRcdFxuXG5cdFx0XHRmb3IgKGogPSAwLCBrID0gb3B0Z3JvdXBzICYmIG9wdGdyb3Vwcy5sZW5ndGg7IGogPCBrOyBqKyspIHtcblx0XHRcdFx0b3B0Z3JvdXAgPSBvcHRncm91cHNbal07XG5cblx0XHRcdFx0bGV0IG9yZGVyID0gb3B0aW9uLiRvcmRlcjtcblx0XHRcdFx0bGV0IHNlbGZfb3B0Z3JvdXAgPSBzZWxmLm9wdGdyb3Vwc1tvcHRncm91cF07XG5cdFx0XHRcdGlmKCBzZWxmX29wdGdyb3VwID09PSB1bmRlZmluZWQgKXtcdFx0XHRcdFx0XG5cdFx0XHRcdFx0b3B0Z3JvdXAgPSAnJztcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0b3JkZXIgPSBzZWxmX29wdGdyb3VwLiRvcmRlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IFtncm91cF9vcmRlcl9pLGdyb3VwX2ZyYWdtZW50XSA9IGdldEdyb3VwRnJhZ21lbnQob3B0Z3JvdXAsb3JkZXIpO1xuXG5cblx0XHRcdFx0Ly8gbm9kZXMgY2FuIG9ubHkgaGF2ZSBvbmUgcGFyZW50LCBzbyBpZiB0aGUgb3B0aW9uIGlzIGluIG11dHBsZSBncm91cHMsIHdlIG5lZWQgYSBjbG9uZVxuXHRcdFx0XHRpZiggaiA+IDAgKXtcblx0XHRcdFx0XHRvcHRpb25fZWwgPSBvcHRpb25fZWwuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50O1xuXHRcdFx0XHRcdHNldEF0dHIob3B0aW9uX2VsLHtpZDogb3B0aW9uLiRpZCsnLWNsb25lLScraiwnYXJpYS1zZWxlY3RlZCc6bnVsbH0pO1xuXHRcdFx0XHRcdG9wdGlvbl9lbC5jbGFzc0xpc3QuYWRkKCd0cy1jbG9uZWQnKTtcblx0XHRcdFx0XHRyZW1vdmVDbGFzc2VzKG9wdGlvbl9lbCwnYWN0aXZlJyk7XG5cblxuXHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB3ZSBrZWVwIHRoZSBhY3RpdmVPcHRpb24gaW4gdGhlIHNhbWUgZ3JvdXBcblx0XHRcdFx0XHRpZiggc2VsZi5hY3RpdmVPcHRpb24gJiYgc2VsZi5hY3RpdmVPcHRpb24uZGF0YXNldC52YWx1ZSA9PSBvcHRfdmFsdWUgKXtcblx0XHRcdFx0XHRcdGlmKCBhY3RpdmVfZ3JvdXAgJiYgYWN0aXZlX2dyb3VwLmRhdGFzZXQuZ3JvdXAgPT09IG9wdGdyb3VwLnRvU3RyaW5nKCkgKXtcblx0XHRcdFx0XHRcdFx0YWN0aXZlX29wdGlvbiA9IG9wdGlvbl9lbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cdFxuXHRcdFx0XHRcblx0XHRcdFx0Z3JvdXBfZnJhZ21lbnQuYXBwZW5kQ2hpbGQob3B0aW9uX2VsKTtcblx0XHRcdFx0aWYoIG9wdGdyb3VwICE9ICcnICl7XG5cdFx0XHRcdFx0Z3JvdXBzW29wdGdyb3VwXSA9IGdyb3VwX29yZGVyX2k7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IG9wdGdyb3Vwc1xuXHRcdGlmKCBzZWxmLnNldHRpbmdzLmxvY2tPcHRncm91cE9yZGVyICl7XG5cdFx0XHRncm91cHNfb3JkZXIuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRyZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyByZW5kZXIgb3B0Z3JvdXAgaGVhZGVycyAmIGpvaW4gZ3JvdXBzXG5cdFx0aHRtbCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRpdGVyYXRlKCBncm91cHNfb3JkZXIsIChncm91cF9vcmRlcjpHcm91cCkgPT4ge1xuXG5cdFx0XHRsZXQgZ3JvdXBfZnJhZ21lbnQgPSBncm91cF9vcmRlci5mcmFnbWVudDtcblx0XHRcdGxldCBvcHRncm91cCA9IGdyb3VwX29yZGVyLm9wdGdyb3VwXG5cblx0XHRcdGlmKCAhZ3JvdXBfZnJhZ21lbnQgfHwgIWdyb3VwX2ZyYWdtZW50LmNoaWxkcmVuLmxlbmd0aCApIHJldHVybjtcblxuXHRcdFx0bGV0IGdyb3VwX2hlYWRpbmcgPSBzZWxmLm9wdGdyb3Vwc1tvcHRncm91cF07XG5cblx0XHRcdGlmKCBncm91cF9oZWFkaW5nICE9PSB1bmRlZmluZWQgKXtcblxuXHRcdFx0XHRsZXQgZ3JvdXBfb3B0aW9ucyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0bGV0IGhlYWRlciA9IHNlbGYucmVuZGVyKCdvcHRncm91cF9oZWFkZXInLCBncm91cF9oZWFkaW5nKTtcblx0XHRcdFx0YXBwZW5kKCBncm91cF9vcHRpb25zLCBoZWFkZXIgKTtcblx0XHRcdFx0YXBwZW5kKCBncm91cF9vcHRpb25zLCBncm91cF9mcmFnbWVudCApO1xuXG5cdFx0XHRcdGxldCBncm91cF9odG1sID0gc2VsZi5yZW5kZXIoJ29wdGdyb3VwJywge2dyb3VwOmdyb3VwX2hlYWRpbmcsb3B0aW9uczpncm91cF9vcHRpb25zfSApO1xuXG5cdFx0XHRcdGFwcGVuZCggaHRtbCwgZ3JvdXBfaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhcHBlbmQoIGh0bWwsIGdyb3VwX2ZyYWdtZW50ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRkcm9wZG93bl9jb250ZW50LmlubmVySFRNTCA9ICcnO1xuXHRcdGFwcGVuZCggZHJvcGRvd25fY29udGVudCwgaHRtbCApO1xuXG5cdFx0Ly8gaGlnaGxpZ2h0IG1hdGNoaW5nIHRlcm1zIGlubGluZVxuXHRcdGlmIChzZWxmLnNldHRpbmdzLmhpZ2hsaWdodCkge1xuXHRcdFx0cmVtb3ZlSGlnaGxpZ2h0KCBkcm9wZG93bl9jb250ZW50ICk7XG5cdFx0XHRpZiAocmVzdWx0cy5xdWVyeS5sZW5ndGggJiYgcmVzdWx0cy50b2tlbnMubGVuZ3RoKSB7XG5cdFx0XHRcdGl0ZXJhdGUoIHJlc3VsdHMudG9rZW5zLCAodG9rKSA9PiB7XG5cdFx0XHRcdFx0aGlnaGxpZ2h0KCBkcm9wZG93bl9jb250ZW50LCB0b2sucmVnZXgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBoZWxwZXIgbWV0aG9kIGZvciBhZGRpbmcgdGVtcGxhdGVzIHRvIGRyb3Bkb3duXG5cdFx0dmFyIGFkZF90ZW1wbGF0ZSA9ICh0ZW1wbGF0ZTpUb21UZW1wbGF0ZU5hbWVzKSA9PiB7XG5cdFx0XHRsZXQgY29udGVudCA9IHNlbGYucmVuZGVyKHRlbXBsYXRlLHtpbnB1dDpxdWVyeX0pO1xuXHRcdFx0aWYoIGNvbnRlbnQgKXtcblx0XHRcdFx0c2hvd19kcm9wZG93biA9IHRydWU7XG5cdFx0XHRcdGRyb3Bkb3duX2NvbnRlbnQuaW5zZXJ0QmVmb3JlKGNvbnRlbnQsIGRyb3Bkb3duX2NvbnRlbnQuZmlyc3RDaGlsZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHR9O1xuXG5cblx0XHQvLyBhZGQgbG9hZGluZyBtZXNzYWdlXG5cdFx0aWYoIHNlbGYubG9hZGluZyApe1xuXHRcdFx0YWRkX3RlbXBsYXRlKCdsb2FkaW5nJyk7XG5cblx0XHQvLyBpbnZhbGlkIHF1ZXJ5XG5cdFx0fWVsc2UgaWYoICFzZWxmLnNldHRpbmdzLnNob3VsZExvYWQuY2FsbChzZWxmLHF1ZXJ5KSApe1xuXHRcdFx0YWRkX3RlbXBsYXRlKCdub3RfbG9hZGluZycpO1xuXG5cdFx0Ly8gYWRkIG5vX3Jlc3VsdHMgbWVzc2FnZVxuXHRcdH1lbHNlIGlmKCByZXN1bHRzLml0ZW1zLmxlbmd0aCA9PT0gMCApe1xuXHRcdFx0YWRkX3RlbXBsYXRlKCdub19yZXN1bHRzJyk7XG5cblx0XHR9XG5cblxuXG5cdFx0Ly8gYWRkIGNyZWF0ZSBvcHRpb25cblx0XHRoYXNfY3JlYXRlX29wdGlvbiA9IHNlbGYuY2FuQ3JlYXRlKHF1ZXJ5KTtcblx0XHRpZiAoaGFzX2NyZWF0ZV9vcHRpb24pIHtcblx0XHRcdGNyZWF0ZSA9IGFkZF90ZW1wbGF0ZSgnb3B0aW9uX2NyZWF0ZScpO1xuXHRcdH1cblxuXG5cdFx0Ly8gYWN0aXZhdGVcblx0XHRzZWxmLmhhc09wdGlvbnMgPSByZXN1bHRzLml0ZW1zLmxlbmd0aCA+IDAgfHwgaGFzX2NyZWF0ZV9vcHRpb247XG5cdFx0aWYoIHNob3dfZHJvcGRvd24gKXtcblxuXHRcdFx0aWYgKHJlc3VsdHMuaXRlbXMubGVuZ3RoID4gMCkge1xuXG5cdFx0XHRcdGlmKCAhYWN0aXZlX29wdGlvbiAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnICYmIHNlbGYuaXRlbXNbMF0gIT0gdW5kZWZpbmVkICl7XG5cdFx0XHRcdFx0YWN0aXZlX29wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKHNlbGYuaXRlbXNbMF0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoICFkcm9wZG93bl9jb250ZW50LmNvbnRhaW5zKGFjdGl2ZV9vcHRpb24pICApe1xuXG5cdFx0XHRcdFx0bGV0IGFjdGl2ZV9pbmRleCA9IDA7XG5cdFx0XHRcdFx0aWYoIGNyZWF0ZSAmJiAhc2VsZi5zZXR0aW5ncy5hZGRQcmVjZWRlbmNlICl7XG5cdFx0XHRcdFx0XHRhY3RpdmVfaW5kZXggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhY3RpdmVfb3B0aW9uID0gc2VsZi5zZWxlY3RhYmxlKClbYWN0aXZlX2luZGV4XSBhcyBIVE1MRWxlbWVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHR9ZWxzZSBpZiggY3JlYXRlICl7XG5cdFx0XHRcdGFjdGl2ZV9vcHRpb24gPSBjcmVhdGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCB0cmlnZ2VyRHJvcGRvd24gJiYgIXNlbGYuaXNPcGVuICl7XG5cdFx0XHRcdHNlbGYub3BlbigpO1xuXHRcdFx0XHRzZWxmLnNjcm9sbFRvT3B0aW9uKGFjdGl2ZV9vcHRpb24sJ2F1dG8nKTtcblx0XHRcdH1cblx0XHRcdHNlbGYuc2V0QWN0aXZlT3B0aW9uKGFjdGl2ZV9vcHRpb24pO1xuXG5cdFx0fWVsc2V7XG5cdFx0XHRzZWxmLmNsZWFyQWN0aXZlT3B0aW9uKCk7XG5cdFx0XHRpZiggdHJpZ2dlckRyb3Bkb3duICYmIHNlbGYuaXNPcGVuICl7XG5cdFx0XHRcdHNlbGYuY2xvc2UoZmFsc2UpOyAvLyBpZiBjcmVhdGVfb3B0aW9uPW51bGwsIHdlIHdhbnQgdGhlIGRyb3Bkb3duIHRvIGNsb3NlIGJ1dCBub3QgcmVzZXQgdGhlIHRleHRib3ggdmFsdWVcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGxpc3Qgb2Ygc2VsZWN0YWJsZSBvcHRpb25zXG5cdCAqXG5cdCAqL1xuXHRzZWxlY3RhYmxlKCk6Tm9kZUxpc3R7XG5cdFx0cmV0dXJuIHRoaXMuZHJvcGRvd25fY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zZWxlY3RhYmxlXScpO1xuXHR9XG5cblxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGF2YWlsYWJsZSBvcHRpb24uIElmIGl0IGFscmVhZHkgZXhpc3RzLFxuXHQgKiBub3RoaW5nIHdpbGwgaGFwcGVuLiBOb3RlOiB0aGlzIGRvZXMgbm90IHJlZnJlc2hcblx0ICogdGhlIG9wdGlvbnMgbGlzdCBkcm9wZG93biAodXNlIGByZWZyZXNoT3B0aW9uc2Bcblx0ICogZm9yIHRoYXQpLlxuXHQgKlxuXHQgKiBVc2FnZTpcblx0ICpcblx0ICogICB0aGlzLmFkZE9wdGlvbihkYXRhKVxuXHQgKlxuXHQgKi9cblx0YWRkT3B0aW9uKCBkYXRhOlRvbU9wdGlvbiwgdXNlcl9jcmVhdGVkID0gZmFsc2UgKTpmYWxzZXxzdHJpbmcge1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdFx0Ly8gQGRlcHJlY2F0ZWQgMS43Ljdcblx0XHQvLyB1c2UgYWRkT3B0aW9ucyggYXJyYXksIHVzZXJfY3JlYXRlZCApIGZvciBhZGRpbmcgbXVsdGlwbGUgb3B0aW9uc1xuXHRcdGlmKCBBcnJheS5pc0FycmF5KGRhdGEpICl7XG5cdFx0XHRzZWxmLmFkZE9wdGlvbnMoIGRhdGEsIHVzZXJfY3JlYXRlZCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3Qga2V5ID0gaGFzaF9rZXkoZGF0YVtzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdKTtcblx0XHRpZigga2V5ID09PSBudWxsIHx8IHNlbGYub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpICl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZGF0YS4kb3JkZXJcdFx0XHQ9IGRhdGEuJG9yZGVyIHx8ICsrc2VsZi5vcmRlcjtcblx0XHRkYXRhLiRpZFx0XHRcdD0gc2VsZi5pbnB1dElkICsgJy1vcHQtJyArIGRhdGEuJG9yZGVyO1xuXHRcdHNlbGYub3B0aW9uc1trZXldXHQ9IGRhdGE7XG5cdFx0c2VsZi5sYXN0UXVlcnlcdFx0PSBudWxsO1xuXG5cdFx0aWYoIHVzZXJfY3JlYXRlZCApe1xuXHRcdFx0c2VsZi51c2VyT3B0aW9uc1trZXldID0gdXNlcl9jcmVhdGVkO1xuXHRcdFx0c2VsZi50cmlnZ2VyKCdvcHRpb25fYWRkJywga2V5LCBkYXRhKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ga2V5O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBtdWx0aXBsZSBvcHRpb25zXG5cdCAqXG5cdCAqL1xuXHRhZGRPcHRpb25zKCBkYXRhOlRvbU9wdGlvbltdLCB1c2VyX2NyZWF0ZWQgPSBmYWxzZSApOnZvaWR7XG5cdFx0aXRlcmF0ZSggZGF0YSwgKGRhdDpUb21PcHRpb24pID0+IHtcblx0XHRcdHRoaXMuYWRkT3B0aW9uKGRhdCwgdXNlcl9jcmVhdGVkKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAZGVwcmVjYXRlZCAxLjcuN1xuXHQgKi9cblx0cmVnaXN0ZXJPcHRpb24oIGRhdGE6VG9tT3B0aW9uICk6ZmFsc2V8c3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5hZGRPcHRpb24oZGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGFuIG9wdGlvbiBncm91cCB0byB0aGUgcG9vbCBvZiBvcHRpb24gZ3JvdXBzLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cblx0ICovXG5cdHJlZ2lzdGVyT3B0aW9uR3JvdXAoZGF0YTpUb21PcHRpb24pIHtcblx0XHR2YXIga2V5ID0gaGFzaF9rZXkoZGF0YVt0aGlzLnNldHRpbmdzLm9wdGdyb3VwVmFsdWVGaWVsZF0pO1xuXG5cdFx0aWYgKCBrZXkgPT09IG51bGwgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRkYXRhLiRvcmRlciA9IGRhdGEuJG9yZGVyIHx8ICsrdGhpcy5vcmRlcjtcblx0XHR0aGlzLm9wdGdyb3Vwc1trZXldID0gZGF0YTtcblx0XHRyZXR1cm4ga2V5O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIG5ldyBvcHRncm91cCBmb3Igb3B0aW9uc1xuXHQgKiB0byBiZSBidWNrZXRlZCBpbnRvLlxuXHQgKlxuXHQgKi9cblx0YWRkT3B0aW9uR3JvdXAoaWQ6c3RyaW5nLCBkYXRhOlRvbU9wdGlvbikge1xuXHRcdHZhciBoYXNoZWRfaWQ7XG5cdFx0ZGF0YVt0aGlzLnNldHRpbmdzLm9wdGdyb3VwVmFsdWVGaWVsZF0gPSBpZDtcblxuXHRcdGlmKCBoYXNoZWRfaWQgPSB0aGlzLnJlZ2lzdGVyT3B0aW9uR3JvdXAoZGF0YSkgKXtcblx0XHRcdHRoaXMudHJpZ2dlcignb3B0Z3JvdXBfYWRkJywgaGFzaGVkX2lkLCBkYXRhKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbiBleGlzdGluZyBvcHRpb24gZ3JvdXAuXG5cdCAqXG5cdCAqL1xuXHRyZW1vdmVPcHRpb25Hcm91cChpZDpzdHJpbmcpIHtcblx0XHRpZiAodGhpcy5vcHRncm91cHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5vcHRncm91cHNbaWRdO1xuXHRcdFx0dGhpcy5jbGVhckNhY2hlKCk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ29wdGdyb3VwX3JlbW92ZScsIGlkKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBleGlzdGluZyBvcHRpb24gZ3JvdXBzLlxuXHQgKi9cblx0Y2xlYXJPcHRpb25Hcm91cHMoKSB7XG5cdFx0dGhpcy5vcHRncm91cHMgPSB7fTtcblx0XHR0aGlzLmNsZWFyQ2FjaGUoKTtcblx0XHR0aGlzLnRyaWdnZXIoJ29wdGdyb3VwX2NsZWFyJyk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyBhbiBvcHRpb24gYXZhaWxhYmxlIGZvciBzZWxlY3Rpb24uIElmXG5cdCAqIGl0IGlzIHZpc2libGUgaW4gdGhlIHNlbGVjdGVkIGl0ZW1zIG9yIG9wdGlvbnNcblx0ICogZHJvcGRvd24sIGl0IHdpbGwgYmUgcmUtcmVuZGVyZWQgYXV0b21hdGljYWxseS5cblx0ICpcblx0ICovXG5cdHVwZGF0ZU9wdGlvbih2YWx1ZTpzdHJpbmcsIGRhdGE6VG9tT3B0aW9uKSB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGl0ZW1fbmV3O1xuXHRcdHZhciBpbmRleF9pdGVtO1xuXG5cdFx0Y29uc3QgdmFsdWVfb2xkXHRcdD0gaGFzaF9rZXkodmFsdWUpO1xuXHRcdGNvbnN0IHZhbHVlX25ld1x0XHQ9IGhhc2hfa2V5KGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG5cblx0XHQvLyBzYW5pdHkgY2hlY2tzXG5cdFx0aWYoIHZhbHVlX29sZCA9PT0gbnVsbCApIHJldHVybjtcblxuXHRcdGNvbnN0IGRhdGFfb2xkXHRcdD0gc2VsZi5vcHRpb25zW3ZhbHVlX29sZF07XG5cblx0XHRpZiggZGF0YV9vbGQgPT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXHRcdGlmKCB0eXBlb2YgdmFsdWVfbmV3ICE9PSAnc3RyaW5nJyApIHRocm93IG5ldyBFcnJvcignVmFsdWUgbXVzdCBiZSBzZXQgaW4gb3B0aW9uIGRhdGEnKTtcblxuXG5cdFx0Y29uc3Qgb3B0aW9uXHRcdD0gc2VsZi5nZXRPcHRpb24odmFsdWVfb2xkKTtcblx0XHRjb25zdCBpdGVtXHRcdFx0PSBzZWxmLmdldEl0ZW0odmFsdWVfb2xkKTtcblxuXG5cdFx0ZGF0YS4kb3JkZXIgPSBkYXRhLiRvcmRlciB8fCBkYXRhX29sZC4kb3JkZXI7XG5cdFx0ZGVsZXRlIHNlbGYub3B0aW9uc1t2YWx1ZV9vbGRdO1xuXG5cdFx0Ly8gaW52YWxpZGF0ZSByZW5kZXIgY2FjaGVcblx0XHQvLyBkb24ndCByZW1vdmUgZXhpc3Rpbmcgbm9kZSB5ZXQsIHdlJ2xsIHJlbW92ZSBpdCBhZnRlciByZXBsYWNpbmcgaXRcblx0XHRzZWxmLnVuY2FjaGVWYWx1ZSh2YWx1ZV9uZXcpO1xuXG5cdFx0c2VsZi5vcHRpb25zW3ZhbHVlX25ld10gPSBkYXRhO1xuXG5cdFx0Ly8gdXBkYXRlIHRoZSBvcHRpb24gaWYgaXQncyBpbiB0aGUgZHJvcGRvd25cblx0XHRpZiggb3B0aW9uICl7XG5cdFx0XHRpZiggc2VsZi5kcm9wZG93bl9jb250ZW50LmNvbnRhaW5zKG9wdGlvbikgKXtcblxuXHRcdFx0XHRjb25zdCBvcHRpb25fbmV3XHQ9IHNlbGYuX3JlbmRlcignb3B0aW9uJywgZGF0YSk7XG5cdFx0XHRcdHJlcGxhY2VOb2RlKG9wdGlvbiwgb3B0aW9uX25ldyk7XG5cblx0XHRcdFx0aWYoIHNlbGYuYWN0aXZlT3B0aW9uID09PSBvcHRpb24gKXtcblx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihvcHRpb25fbmV3KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3B0aW9uLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSB0aGUgaXRlbSBpZiB3ZSBoYXZlIG9uZVxuXHRcdGlmKCBpdGVtICl7XG5cdFx0XHRpbmRleF9pdGVtID0gc2VsZi5pdGVtcy5pbmRleE9mKHZhbHVlX29sZCk7XG5cdFx0XHRpZiAoaW5kZXhfaXRlbSAhPT0gLTEpIHtcblx0XHRcdFx0c2VsZi5pdGVtcy5zcGxpY2UoaW5kZXhfaXRlbSwgMSwgdmFsdWVfbmV3KTtcblx0XHRcdH1cblxuXHRcdFx0aXRlbV9uZXdcdD0gc2VsZi5fcmVuZGVyKCdpdGVtJywgZGF0YSk7XG5cblx0XHRcdGlmKCBpdGVtLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgKSBhZGRDbGFzc2VzKGl0ZW1fbmV3LCdhY3RpdmUnKTtcblxuXHRcdFx0cmVwbGFjZU5vZGUoIGl0ZW0sIGl0ZW1fbmV3KTtcblx0XHR9XG5cblx0XHQvLyBpbnZhbGlkYXRlIGxhc3QgcXVlcnkgYmVjYXVzZSB3ZSBtaWdodCBoYXZlIHVwZGF0ZWQgdGhlIHNvcnRGaWVsZFxuXHRcdHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGEgc2luZ2xlIG9wdGlvbi5cblx0ICpcblx0ICovXG5cdHJlbW92ZU9wdGlvbih2YWx1ZTpzdHJpbmcsIHNpbGVudD86Ym9vbGVhbik6dm9pZCB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0dmFsdWUgPSBnZXRfaGFzaCh2YWx1ZSk7XG5cblx0XHRzZWxmLnVuY2FjaGVWYWx1ZSh2YWx1ZSk7XG5cblx0XHRkZWxldGUgc2VsZi51c2VyT3B0aW9uc1t2YWx1ZV07XG5cdFx0ZGVsZXRlIHNlbGYub3B0aW9uc1t2YWx1ZV07XG5cdFx0c2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXHRcdHNlbGYudHJpZ2dlcignb3B0aW9uX3JlbW92ZScsIHZhbHVlKTtcblx0XHRzZWxmLnJlbW92ZUl0ZW0odmFsdWUsIHNpbGVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBvcHRpb25zLlxuXHQgKi9cblx0Y2xlYXJPcHRpb25zKGZpbHRlcj86VG9tQ2xlYXJGaWx0ZXIgKSB7XG5cblx0XHRjb25zdCBib3VuZEZpbHRlciA9IChmaWx0ZXIgfHwgdGhpcy5jbGVhckZpbHRlcikuYmluZCh0aGlzKTtcblxuXHRcdHRoaXMubG9hZGVkU2VhcmNoZXNcdFx0PSB7fTtcblx0XHR0aGlzLnVzZXJPcHRpb25zXHRcdD0ge307XG5cdFx0dGhpcy5jbGVhckNhY2hlKCk7XG5cblx0XHRjb25zdCBzZWxlY3RlZDpUb21PcHRpb25zXHQ9IHt9O1xuXHRcdGl0ZXJhdGUodGhpcy5vcHRpb25zLChvcHRpb246VG9tT3B0aW9uLGtleTpzdHJpbmcpPT57XG5cdFx0XHRpZiggYm91bmRGaWx0ZXIob3B0aW9uLGtleSBhcyBzdHJpbmcpICl7XG5cdFx0XHRcdHNlbGVjdGVkW2tleV0gPSBvcHRpb247XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLm9wdGlvbnMgPSB0aGlzLnNpZnRlci5pdGVtcyA9IHNlbGVjdGVkO1xuXHRcdHRoaXMubGFzdFF1ZXJ5ID0gbnVsbDtcblx0XHR0aGlzLnRyaWdnZXIoJ29wdGlvbl9jbGVhcicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzZWQgYnkgY2xlYXJPcHRpb25zKCkgdG8gZGVjaWRlIHdoZXRoZXIgb3Igbm90IGFuIG9wdGlvbiBzaG91bGQgYmUgcmVtb3ZlZFxuXHQgKiBSZXR1cm4gdHJ1ZSB0byBrZWVwIGFuIG9wdGlvbiwgZmFsc2UgdG8gcmVtb3ZlXG5cdCAqXG5cdCAqL1xuXHRjbGVhckZpbHRlcihvcHRpb246VG9tT3B0aW9uLHZhbHVlOnN0cmluZyl7XG5cdFx0aWYoIHRoaXMuaXRlbXMuaW5kZXhPZih2YWx1ZSkgPj0gMCApe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkb20gZWxlbWVudCBvZiB0aGUgb3B0aW9uXG5cdCAqIG1hdGNoaW5nIHRoZSBnaXZlbiB2YWx1ZS5cblx0ICpcblx0ICovXG5cdGdldE9wdGlvbih2YWx1ZTp1bmRlZmluZWR8bnVsbHxib29sZWFufHN0cmluZ3xudW1iZXIsIGNyZWF0ZTpib29sZWFuPWZhbHNlKTpudWxsfEhUTUxFbGVtZW50IHtcblxuXHRcdGNvbnN0IGhhc2hlZCA9IGhhc2hfa2V5KHZhbHVlKTtcblx0XHRpZiggaGFzaGVkID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0XHRjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvbnNbaGFzaGVkXTtcblx0XHRpZiggb3B0aW9uICE9IHVuZGVmaW5lZCApe1xuXG5cdFx0XHRpZiggb3B0aW9uLiRkaXYgKXtcblx0XHRcdFx0cmV0dXJuIG9wdGlvbi4kZGl2O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggY3JlYXRlICl7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZW5kZXIoJ29wdGlvbicsIG9wdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZG9tIGVsZW1lbnQgb2YgdGhlIG5leHQgb3IgcHJldmlvdXMgZG9tIGVsZW1lbnQgb2YgdGhlIHNhbWUgdHlwZVxuXHQgKiBOb3RlOiBhZGphY2VudCBvcHRpb25zIG1heSBub3QgYmUgYWRqYWNlbnQgRE9NIGVsZW1lbnRzIChvcHRncm91cHMpXG5cdCAqXG5cdCAqL1xuXHRnZXRBZGphY2VudCggb3B0aW9uOm51bGx8SFRNTEVsZW1lbnQsIGRpcmVjdGlvbjpudW1iZXIsIHR5cGU6c3RyaW5nID0gJ29wdGlvbicgKSA6IEhUTUxFbGVtZW50fG51bGx7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBhbGw7XG5cblx0XHRpZiggIW9wdGlvbiApe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aWYoIHR5cGUgPT0gJ2l0ZW0nICl7XG5cdFx0XHRhbGxcdFx0XHQ9IHNlbGYuY29udHJvbENoaWxkcmVuKCk7XG5cdFx0fWVsc2V7XG5cdFx0XHRhbGxcdFx0XHQ9IHNlbGYuZHJvcGRvd25fY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zZWxlY3RhYmxlXScpO1xuXHRcdH1cblxuXHRcdGZvciggbGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG5cdFx0XHRpZiggYWxsW2ldICE9IG9wdGlvbiApe1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIGRpcmVjdGlvbiA+IDAgKXtcblx0XHRcdFx0cmV0dXJuIGFsbFtpKzFdIGFzIEhUTUxFbGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYWxsW2ktMV0gYXMgSFRNTEVsZW1lbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZG9tIGVsZW1lbnQgb2YgdGhlIGl0ZW1cblx0ICogbWF0Y2hpbmcgdGhlIGdpdmVuIHZhbHVlLlxuXHQgKlxuXHQgKi9cblx0Z2V0SXRlbShpdGVtOnN0cmluZ3xUb21JdGVtfG51bGwpOm51bGx8VG9tSXRlbSB7XG5cblx0XHRpZiggdHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcgKXtcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH1cblxuXHRcdHZhciB2YWx1ZSA9IGhhc2hfa2V5KGl0ZW0pO1xuXHRcdHJldHVybiB2YWx1ZSAhPT0gbnVsbFxuXHRcdFx0PyB0aGlzLmNvbnRyb2wucXVlcnlTZWxlY3RvcihgW2RhdGEtdmFsdWU9XCIke2FkZFNsYXNoZXModmFsdWUpfVwiXWApXG5cdFx0XHQ6IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogXCJTZWxlY3RzXCIgbXVsdGlwbGUgaXRlbXMgYXQgb25jZS4gQWRkcyB0aGVtIHRvIHRoZSBsaXN0XG5cdCAqIGF0IHRoZSBjdXJyZW50IGNhcmV0IHBvc2l0aW9uLlxuXHQgKlxuXHQgKi9cblx0YWRkSXRlbXMoIHZhbHVlczpzdHJpbmd8c3RyaW5nW10sIHNpbGVudD86Ym9vbGVhbiApOnZvaWR7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0dmFyIGl0ZW1zID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzIDogW3ZhbHVlc107XG5cdFx0aXRlbXMgPSBpdGVtcy5maWx0ZXIoeCA9PiBzZWxmLml0ZW1zLmluZGV4T2YoeCkgPT09IC0xKTtcblx0XHRjb25zdCBsYXN0X2l0ZW0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcblx0XHRpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0c2VsZi5pc1BlbmRpbmcgPSAoaXRlbSAhPT0gbGFzdF9pdGVtKTtcblx0XHRcdHNlbGYuYWRkSXRlbShpdGVtLCBzaWxlbnQpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFwiU2VsZWN0c1wiIGFuIGl0ZW0uIEFkZHMgaXQgdG8gdGhlIGxpc3Rcblx0ICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG5cdCAqXG5cdCAqL1xuXHRhZGRJdGVtKCB2YWx1ZTpzdHJpbmcsIHNpbGVudD86Ym9vbGVhbiApOnZvaWR7XG5cdFx0dmFyIGV2ZW50cyA9IHNpbGVudCA/IFtdIDogWydjaGFuZ2UnLCdkcm9wZG93bl9jbG9zZSddO1xuXG5cdFx0ZGVib3VuY2VfZXZlbnRzKHRoaXMsIGV2ZW50cywgKCkgPT4ge1xuXHRcdFx0dmFyIGl0ZW0sIHdhc0Z1bGw7XG5cdFx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHQgXHRjb25zdCBpbnB1dE1vZGUgPSBzZWxmLnNldHRpbmdzLm1vZGU7XG5cdFx0XHRjb25zdCBoYXNoZWQgPSBoYXNoX2tleSh2YWx1ZSk7XG5cblx0XHRcdGlmKCBoYXNoZWQgJiYgc2VsZi5pdGVtcy5pbmRleE9mKGhhc2hlZCkgIT09IC0xICl7XG5cblx0XHRcdFx0aWYoIGlucHV0TW9kZSA9PT0gJ3NpbmdsZScgKXtcblx0XHRcdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiggaW5wdXRNb2RlID09PSAnc2luZ2xlJyB8fCAhc2VsZi5zZXR0aW5ncy5kdXBsaWNhdGVzICl7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoYXNoZWQgPT09IG51bGwgfHwgIXNlbGYub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShoYXNoZWQpKSByZXR1cm47XG5cdFx0XHRpZiAoaW5wdXRNb2RlID09PSAnc2luZ2xlJykgc2VsZi5jbGVhcihzaWxlbnQpO1xuXHRcdFx0aWYgKGlucHV0TW9kZSA9PT0gJ211bHRpJyAmJiBzZWxmLmlzRnVsbCgpKSByZXR1cm47XG5cblx0XHRcdGl0ZW0gPSBzZWxmLl9yZW5kZXIoJ2l0ZW0nLCBzZWxmLm9wdGlvbnNbaGFzaGVkXSk7XG5cblx0XHRcdGlmKCBzZWxmLmNvbnRyb2wuY29udGFpbnMoaXRlbSkgKXsgLy8gZHVwbGljYXRlc1xuXHRcdFx0XHRpdGVtID0gaXRlbS5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHdhc0Z1bGwgPSBzZWxmLmlzRnVsbCgpO1xuXHRcdFx0c2VsZi5pdGVtcy5zcGxpY2Uoc2VsZi5jYXJldFBvcywgMCwgaGFzaGVkKTtcblx0XHRcdHNlbGYuaW5zZXJ0QXRDYXJldChpdGVtKTtcblxuXHRcdFx0aWYgKHNlbGYuaXNTZXR1cCkge1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBtZW51IC8gcmVtb3ZlIHRoZSBvcHRpb24gKGlmIHRoaXMgaXMgbm90IG9uZSBpdGVtIGJlaW5nIGFkZGVkIGFzIHBhcnQgb2Ygc2VyaWVzKVxuXHRcdFx0XHRpZiggIXNlbGYuaXNQZW5kaW5nICYmIHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkICl7XG5cdFx0XHRcdFx0bGV0IG9wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKGhhc2hlZCk7XG5cdFx0XHRcdFx0bGV0IG5leHQgPSBzZWxmLmdldEFkamFjZW50KG9wdGlvbiwgMSk7XG5cdFx0XHRcdFx0aWYoIG5leHQgKXtcblx0XHRcdFx0XHRcdHNlbGYuc2V0QWN0aXZlT3B0aW9uKG5leHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlZnJlc2hPcHRpb25zIGFmdGVyIHNldEFjdGl2ZU9wdGlvbigpLFxuXHRcdFx0XHQvLyBvdGhlcndpc2Ugc2V0QWN0aXZlT3B0aW9uKCkgd2lsbCBiZSBjYWxsZWQgYnkgcmVmcmVzaE9wdGlvbnMoKSB3aXRoIHRoZSB3cm9uZyB2YWx1ZVxuXHRcdFx0XHRpZiggIXNlbGYuaXNQZW5kaW5nICYmICFzZWxmLnNldHRpbmdzLmNsb3NlQWZ0ZXJTZWxlY3QgKXtcblx0XHRcdFx0XHRzZWxmLnJlZnJlc2hPcHRpb25zKHNlbGYuaXNGb2N1c2VkICYmIGlucHV0TW9kZSAhPT0gJ3NpbmdsZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaGlkZSB0aGUgbWVudSBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgaGF2ZSBiZWVuIHNlbGVjdGVkIG9yIG5vIG9wdGlvbnMgYXJlIGxlZnRcblx0XHRcdFx0aWYoIHNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCAhPSBmYWxzZSAmJiBzZWxmLmlzRnVsbCgpICl7XG5cdFx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFzZWxmLmlzUGVuZGluZykge1xuXHRcdFx0XHRcdHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdpdGVtX2FkZCcsIGhhc2hlZCwgaXRlbSk7XG5cblx0XHRcdFx0aWYgKCFzZWxmLmlzUGVuZGluZykge1xuXHRcdFx0XHRcdHNlbGYudXBkYXRlT3JpZ2luYWxJbnB1dCh7c2lsZW50OiBzaWxlbnR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNlbGYuaXNQZW5kaW5nIHx8ICghd2FzRnVsbCAmJiBzZWxmLmlzRnVsbCgpKSkge1xuXHRcdFx0XHRzZWxmLmlucHV0U3RhdGUoKTtcblx0XHRcdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0XHRcdH1cblxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNlbGVjdGVkIGl0ZW0gbWF0Y2hpbmdcblx0ICogdGhlIHByb3ZpZGVkIHZhbHVlLlxuXHQgKlxuXHQgKi9cblx0cmVtb3ZlSXRlbSggaXRlbTpzdHJpbmd8VG9tSXRlbXxudWxsPW51bGwsIHNpbGVudD86Ym9vbGVhbiApe1xuXHRcdGNvbnN0IHNlbGZcdFx0PSB0aGlzO1xuXHRcdGl0ZW1cdFx0XHQ9IHNlbGYuZ2V0SXRlbShpdGVtKTtcblxuXHRcdGlmKCAhaXRlbSApIHJldHVybjtcblxuXHRcdHZhciBpLGlkeDtcblx0XHRjb25zdCB2YWx1ZVx0PSBpdGVtLmRhdGFzZXQudmFsdWU7XG5cdFx0aSA9IG5vZGVJbmRleChpdGVtKTtcblxuXHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0aWYoIGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSApe1xuXHRcdFx0aWR4ID0gc2VsZi5hY3RpdmVJdGVtcy5pbmRleE9mKGl0ZW0pO1xuXHRcdFx0c2VsZi5hY3RpdmVJdGVtcy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdHJlbW92ZUNsYXNzZXMoaXRlbSwnYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0c2VsZi5pdGVtcy5zcGxpY2UoaSwgMSk7XG5cdFx0c2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXHRcdGlmICghc2VsZi5zZXR0aW5ncy5wZXJzaXN0ICYmIHNlbGYudXNlck9wdGlvbnMuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XG5cdFx0XHRzZWxmLnJlbW92ZU9wdGlvbih2YWx1ZSwgc2lsZW50KTtcblx0XHR9XG5cblx0XHRpZiAoaSA8IHNlbGYuY2FyZXRQb3MpIHtcblx0XHRcdHNlbGYuc2V0Q2FyZXQoc2VsZi5jYXJldFBvcyAtIDEpO1xuXHRcdH1cblxuXHRcdHNlbGYudXBkYXRlT3JpZ2luYWxJbnB1dCh7c2lsZW50OiBzaWxlbnR9KTtcblx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuXHRcdHNlbGYudHJpZ2dlcignaXRlbV9yZW1vdmUnLCB2YWx1ZSwgaXRlbSk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZva2VzIHRoZSBgY3JlYXRlYCBtZXRob2QgcHJvdmlkZWQgaW4gdGhlXG5cdCAqIFRvbVNlbGVjdCBvcHRpb25zIHRoYXQgc2hvdWxkIHByb3ZpZGUgdGhlIGRhdGFcblx0ICogZm9yIHRoZSBuZXcgaXRlbSwgZ2l2ZW4gdGhlIHVzZXIgaW5wdXQuXG5cdCAqXG5cdCAqIE9uY2UgdGhpcyBjb21wbGV0ZXMsIGl0IHdpbGwgYmUgYWRkZWRcblx0ICogdG8gdGhlIGl0ZW0gbGlzdC5cblx0ICpcblx0ICovXG5cdGNyZWF0ZUl0ZW0oIGlucHV0Om51bGx8c3RyaW5nPW51bGwsIGNhbGxiYWNrOlRvbUNyZWF0ZUNhbGxiYWNrID0gKCk9Pnt9ICk6Ym9vbGVhbntcblxuXHRcdC8vIHRyaWdnZXJEcm9wZG93biBwYXJhbWV0ZXIgQGRlcHJlY2F0ZWQgMi4xLjFcblx0XHRpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMyApe1xuXHRcdFx0Y2FsbGJhY2sgPSBhcmd1bWVudHNbMl07XG5cdFx0fVxuXHRcdGlmKCB0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJyApe1xuXHRcdFx0Y2FsbGJhY2sgPSAoKSA9PiB7fTtcblx0XHR9XG5cblx0XHR2YXIgc2VsZiAgPSB0aGlzO1xuXHRcdHZhciBjYXJldCA9IHNlbGYuY2FyZXRQb3M7XG5cdFx0dmFyIG91dHB1dDtcblx0XHRpbnB1dCA9IGlucHV0IHx8IHNlbGYuaW5wdXRWYWx1ZSgpO1xuXG5cdFx0aWYgKCFzZWxmLmNhbkNyZWF0ZShpbnB1dCkpIHtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0c2VsZi5sb2NrKCk7XG5cblx0XHR2YXIgY3JlYXRlZCA9IGZhbHNlO1xuXHRcdHZhciBjcmVhdGUgPSAoZGF0YT86Ym9vbGVhbnxUb21PcHRpb24pID0+IHtcblx0XHRcdHNlbGYudW5sb2NrKCk7XG5cblx0XHRcdGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHJldHVybiBjYWxsYmFjaygpO1xuXHRcdFx0dmFyIHZhbHVlID0gaGFzaF9rZXkoZGF0YVtzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdKTtcblx0XHRcdGlmKCB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICl7XG5cdFx0XHRcdHJldHVybiBjYWxsYmFjaygpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxmLnNldFRleHRib3hWYWx1ZSgpO1xuXHRcdFx0c2VsZi5hZGRPcHRpb24oZGF0YSx0cnVlKTtcblx0XHRcdHNlbGYuc2V0Q2FyZXQoY2FyZXQpO1xuXHRcdFx0c2VsZi5hZGRJdGVtKHZhbHVlKTtcblx0XHRcdGNhbGxiYWNrKGRhdGEpO1xuXHRcdFx0Y3JlYXRlZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdGlmKCB0eXBlb2Ygc2VsZi5zZXR0aW5ncy5jcmVhdGUgPT09ICdmdW5jdGlvbicgKXtcblx0XHRcdG91dHB1dCA9IHNlbGYuc2V0dGluZ3MuY3JlYXRlLmNhbGwodGhpcywgaW5wdXQsIGNyZWF0ZSk7XG5cdFx0fWVsc2V7XG5cdFx0XHRvdXRwdXQgPSB7XG5cdFx0XHRcdFtzZWxmLnNldHRpbmdzLmxhYmVsRmllbGRdOiBpbnB1dCxcblx0XHRcdFx0W3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF06IGlucHV0LFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiggIWNyZWF0ZWQgKXtcblx0XHRcdGNyZWF0ZShvdXRwdXQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlLXJlbmRlcnMgdGhlIHNlbGVjdGVkIGl0ZW0gbGlzdHMuXG5cdCAqL1xuXHRyZWZyZXNoSXRlbXMoKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblxuXHRcdGlmIChzZWxmLmlzU2V0dXApIHtcblx0XHRcdHNlbGYuYWRkSXRlbXMoc2VsZi5pdGVtcyk7XG5cdFx0fVxuXG5cdFx0c2VsZi51cGRhdGVPcmlnaW5hbElucHV0KCk7XG5cdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIGFsbCBzdGF0ZS1kZXBlbmRlbnQgYXR0cmlidXRlc1xuXHQgKiBhbmQgQ1NTIGNsYXNzZXMuXG5cdCAqL1xuXHRyZWZyZXNoU3RhdGUoKSB7XG5cdFx0Y29uc3Qgc2VsZiAgICAgPSB0aGlzO1xuXG5cdFx0c2VsZi5yZWZyZXNoVmFsaWRpdHlTdGF0ZSgpO1xuXG5cdFx0Y29uc3QgaXNGdWxsXHQ9IHNlbGYuaXNGdWxsKCk7XG5cdFx0Y29uc3QgaXNMb2NrZWRcdD0gc2VsZi5pc0xvY2tlZDtcblxuXHRcdHNlbGYud3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKCdydGwnLHNlbGYucnRsKTtcblxuXG5cdFx0Y29uc3Qgd3JhcF9jbGFzc0xpc3QgPSBzZWxmLndyYXBwZXIuY2xhc3NMaXN0O1xuXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdmb2N1cycsIHNlbGYuaXNGb2N1c2VkKVxuXHRcdHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnZGlzYWJsZWQnLCBzZWxmLmlzRGlzYWJsZWQpXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdyZWFkb25seScsIHNlbGYuaXNSZWFkT25seSlcblx0XHR3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ3JlcXVpcmVkJywgc2VsZi5pc1JlcXVpcmVkKVxuXHRcdHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnaW52YWxpZCcsICFzZWxmLmlzVmFsaWQpXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdsb2NrZWQnLCBpc0xvY2tlZClcblx0XHR3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2Z1bGwnLCBpc0Z1bGwpXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdpbnB1dC1hY3RpdmUnLCBzZWxmLmlzRm9jdXNlZCAmJiAhc2VsZi5pc0lucHV0SGlkZGVuKVxuXHRcdHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnZHJvcGRvd24tYWN0aXZlJywgc2VsZi5pc09wZW4pXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdoYXMtb3B0aW9ucycsIGlzRW1wdHlPYmplY3Qoc2VsZi5vcHRpb25zKSApXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdoYXMtaXRlbXMnLCBzZWxmLml0ZW1zLmxlbmd0aCA+IDApO1xuXG5cdH1cblxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlIG9mIGJvdGggaW5wdXQgYW5kIGNvbnRyb2wgaW5wdXQuXG5cdCAqXG5cdCAqIFRoZSBgcmVxdWlyZWRgIHByb3BlcnR5IG5lZWRzIHRvIGJlIGFjdGl2YXRlZCBvbiB0aGUgY29udHJvbCBpbnB1dFxuXHQgKiBmb3IgdGhlIGVycm9yIHRvIGJlIGRpc3BsYXllZCBhdCB0aGUgcmlnaHQgcGxhY2UuIGByZXF1aXJlZGAgYWxzb1xuXHQgKiBuZWVkcyB0byBiZSB0ZW1wb3JhcmlseSBkZWFjdGl2YXRlZCBvbiB0aGUgaW5wdXQgc2luY2UgdGhlIGlucHV0IGlzXG5cdCAqIGhpZGRlbiBhbmQgY2FuJ3Qgc2hvdyBlcnJvcnMuXG5cdCAqL1xuXHRyZWZyZXNoVmFsaWRpdHlTdGF0ZSgpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiggIXNlbGYuaW5wdXQudmFsaWRpdHkgKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzZWxmLmlzVmFsaWQgPSBzZWxmLmlucHV0LnZhbGlkaXR5LnZhbGlkO1xuXHRcdHNlbGYuaXNJbnZhbGlkID0gIXNlbGYuaXNWYWxpZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IG1vcmUgaXRlbXMgY2FuIGJlIGFkZGVkXG5cdCAqIHRvIHRoZSBjb250cm9sIHdpdGhvdXQgZXhjZWVkaW5nIHRoZSB1c2VyLWRlZmluZWQgbWF4aW11bS5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Z1bGwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0dGluZ3MubWF4SXRlbXMgIT09IG51bGwgJiYgdGhpcy5pdGVtcy5sZW5ndGggPj0gdGhpcy5zZXR0aW5ncy5tYXhJdGVtcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWZyZXNoZXMgdGhlIG9yaWdpbmFsIDxzZWxlY3Q+IG9yIDxpbnB1dD5cblx0ICogZWxlbWVudCB0byByZWZsZWN0IHRoZSBjdXJyZW50IHN0YXRlLlxuXHQgKlxuXHQgKi9cblx0dXBkYXRlT3JpZ2luYWxJbnB1dCggb3B0czpUb21BcmdPYmplY3QgPSB7fSApe1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdHZhciBvcHRpb24sIGxhYmVsO1xuXG5cdFx0Y29uc3QgZW1wdHlfb3B0aW9uID0gc2VsZi5pbnB1dC5xdWVyeVNlbGVjdG9yKCdvcHRpb25bdmFsdWU9XCJcIl0nKSBhcyBIVE1MT3B0aW9uRWxlbWVudDtcblxuXHRcdGlmKCBzZWxmLmlzX3NlbGVjdF90YWcgKXtcblxuXHRcdFx0Y29uc3Qgc2VsZWN0ZWQ6SFRNTE9wdGlvbkVsZW1lbnRbXVx0XHQ9IFtdO1xuXHRcdFx0Y29uc3QgaGFzX3NlbGVjdGVkOm51bWJlclx0XHRcdFx0PSBzZWxmLmlucHV0LnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbjpjaGVja2VkJykubGVuZ3RoO1xuXG5cdFx0XHRmdW5jdGlvbiBBZGRTZWxlY3RlZChvcHRpb25fZWw6SFRNTE9wdGlvbkVsZW1lbnR8bnVsbCwgdmFsdWU6c3RyaW5nLCBsYWJlbDpzdHJpbmcpOkhUTUxPcHRpb25FbGVtZW50e1xuXG5cdFx0XHRcdGlmKCAhb3B0aW9uX2VsICl7XG5cdFx0XHRcdFx0b3B0aW9uX2VsID0gZ2V0RG9tKCc8b3B0aW9uIHZhbHVlPVwiJyArIGVzY2FwZV9odG1sKHZhbHVlKSArICdcIj4nICsgZXNjYXBlX2h0bWwobGFiZWwpICsgJzwvb3B0aW9uPicpIGFzIEhUTUxPcHRpb25FbGVtZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZG9uJ3QgbW92ZSBlbXB0eSBvcHRpb24gZnJvbSB0b3Agb2YgbGlzdFxuXHRcdFx0XHQvLyBmaXhlcyBidWcgaW4gZmlyZWZveCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzI1MjkzXG5cdFx0XHRcdGlmKCBvcHRpb25fZWwgIT0gZW1wdHlfb3B0aW9uICl7XG5cdFx0XHRcdFx0c2VsZi5pbnB1dC5hcHBlbmQob3B0aW9uX2VsKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNlbGVjdGVkLnB1c2gob3B0aW9uX2VsKTtcblxuXHRcdFx0XHQvLyBtYXJraW5nIGVtcHR5IG9wdGlvbiBhcyBzZWxlY3RlZCBjYW4gYnJlYWsgdmFsaWRhdGlvblxuXHRcdFx0XHQvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvdG9tLXNlbGVjdC9pc3N1ZXMvMzAzXG5cdFx0XHRcdGlmKCBvcHRpb25fZWwgIT0gZW1wdHlfb3B0aW9uIHx8IGhhc19zZWxlY3RlZCA+IDAgKXtcblx0XHRcdFx0XHRvcHRpb25fZWwuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9wdGlvbl9lbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdW5zZWxlY3QgYWxsIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdHNlbGYuaW5wdXQucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uOmNoZWNrZWQnKS5mb3JFYWNoKChvcHRpb25fZWw6RWxlbWVudCkgPT4ge1xuXHRcdFx0XHQoPEhUTUxPcHRpb25FbGVtZW50Pm9wdGlvbl9lbCkuc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdH0pO1xuXG5cblx0XHRcdC8vIG5vdGhpbmcgc2VsZWN0ZWQ/XG5cdFx0XHRpZiggc2VsZi5pdGVtcy5sZW5ndGggPT0gMCAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT0gJ3NpbmdsZScgKXtcblxuXHRcdFx0XHRBZGRTZWxlY3RlZChlbXB0eV9vcHRpb24sIFwiXCIsIFwiXCIpO1xuXG5cdFx0XHQvLyBvcmRlciBzZWxlY3RlZCA8b3B0aW9uPiB0YWdzIGZvciB2YWx1ZXMgaW4gc2VsZi5pdGVtc1xuXHRcdFx0fWVsc2V7XG5cblx0XHRcdFx0c2VsZi5pdGVtcy5mb3JFYWNoKCh2YWx1ZSk9Pntcblx0XHRcdFx0XHRvcHRpb25cdFx0XHQ9IHNlbGYub3B0aW9uc1t2YWx1ZV0hO1xuXHRcdFx0XHRcdGxhYmVsXHRcdFx0PSBvcHRpb25bc2VsZi5zZXR0aW5ncy5sYWJlbEZpZWxkXSB8fCAnJztcblxuXHRcdFx0XHRcdGlmKCBzZWxlY3RlZC5pbmNsdWRlcyhvcHRpb24uJG9wdGlvbikgKXtcblx0XHRcdFx0XHRcdGNvbnN0IHJldXNlX29wdCA9IHNlbGYuaW5wdXQucXVlcnlTZWxlY3Rvcihgb3B0aW9uW3ZhbHVlPVwiJHthZGRTbGFzaGVzKHZhbHVlKX1cIl06bm90KDpjaGVja2VkKWApIGFzIEhUTUxPcHRpb25FbGVtZW50O1xuXHRcdFx0XHRcdFx0QWRkU2VsZWN0ZWQocmV1c2Vfb3B0LCB2YWx1ZSwgbGFiZWwpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0b3B0aW9uLiRvcHRpb25cdD0gQWRkU2VsZWN0ZWQob3B0aW9uLiRvcHRpb24sIHZhbHVlLCBsYWJlbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYuaW5wdXQudmFsdWUgPSBzZWxmLmdldFZhbHVlKCkgYXMgc3RyaW5nO1xuXHRcdH1cblxuXHRcdGlmIChzZWxmLmlzU2V0dXApIHtcblx0XHRcdGlmICghb3B0cy5zaWxlbnQpIHtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdjaGFuZ2UnLCBzZWxmLmdldFZhbHVlKCkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2hvd3MgdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBjb250YWluaW5nXG5cdCAqIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cblx0ICovXG5cdG9wZW4oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKHNlbGYuaXNMb2NrZWQgfHwgc2VsZi5pc09wZW4gfHwgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ211bHRpJyAmJiBzZWxmLmlzRnVsbCgpKSkgcmV0dXJuO1xuXHRcdHNlbGYuaXNPcGVuID0gdHJ1ZTtcblx0XHRzZXRBdHRyKHNlbGYuZm9jdXNfbm9kZSx7J2FyaWEtZXhwYW5kZWQnOiAndHJ1ZSd9KTtcblx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdGFwcGx5Q1NTKHNlbGYuZHJvcGRvd24se3Zpc2liaWxpdHk6ICdoaWRkZW4nLCBkaXNwbGF5OiAnYmxvY2snfSk7XG5cdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0YXBwbHlDU1Moc2VsZi5kcm9wZG93bix7dmlzaWJpbGl0eTogJ3Zpc2libGUnLCBkaXNwbGF5OiAnYmxvY2snfSk7XG5cdFx0c2VsZi5mb2N1cygpO1xuXHRcdHNlbGYudHJpZ2dlcignZHJvcGRvd25fb3BlbicsIHNlbGYuZHJvcGRvd24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsb3NlcyB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG5cdCAqL1xuXHRjbG9zZShzZXRUZXh0Ym94VmFsdWU9dHJ1ZSkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgdHJpZ2dlciA9IHNlbGYuaXNPcGVuO1xuXG5cdFx0aWYoIHNldFRleHRib3hWYWx1ZSApe1xuXG5cdFx0XHQvLyBiZWZvcmUgYmx1cigpIHRvIHByZXZlbnQgZm9ybSBvbmNoYW5nZSBldmVudFxuXHRcdFx0c2VsZi5zZXRUZXh0Ym94VmFsdWUoKTtcblxuXHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScgJiYgc2VsZi5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VsZi5pc09wZW4gPSBmYWxzZTtcblx0XHRzZXRBdHRyKHNlbGYuZm9jdXNfbm9kZSx7J2FyaWEtZXhwYW5kZWQnOiAnZmFsc2UnfSk7XG5cdFx0YXBwbHlDU1Moc2VsZi5kcm9wZG93bix7ZGlzcGxheTogJ25vbmUnfSk7XG5cdFx0aWYoIHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkICl7XG5cdFx0XHRzZWxmLmNsZWFyQWN0aXZlT3B0aW9uKCk7XG5cdFx0fVxuXHRcdHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cblx0XHRpZiAodHJpZ2dlcikgc2VsZi50cmlnZ2VyKCdkcm9wZG93bl9jbG9zZScsIHNlbGYuZHJvcGRvd24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgYW5kIGFwcGxpZXMgdGhlIGFwcHJvcHJpYXRlXG5cdCAqIHBvc2l0aW9uIG9mIHRoZSBkcm9wZG93biBpZiBkcm9wZG93blBhcmVudCA9ICdib2R5Jy5cblx0ICogT3RoZXJ3aXNlLCBwb3NpdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IGNzc1xuXHQgKi9cblx0cG9zaXRpb25Ecm9wZG93bigpe1xuXG5cdFx0aWYoIHRoaXMuc2V0dGluZ3MuZHJvcGRvd25QYXJlbnQgIT09ICdib2R5JyApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjb250ZXh0XHRcdFx0PSB0aGlzLmNvbnRyb2w7XG5cdFx0dmFyIHJlY3RcdFx0XHQ9IGNvbnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0dmFyIHRvcFx0XHRcdFx0PSBjb250ZXh0Lm9mZnNldEhlaWdodCArIHJlY3QudG9wICArIHdpbmRvdy5zY3JvbGxZO1xuXHRcdHZhciBsZWZ0XHRcdFx0PSByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWDtcblxuXG5cdFx0YXBwbHlDU1ModGhpcy5kcm9wZG93bix7XG5cdFx0XHR3aWR0aCA6IHJlY3Qud2lkdGggKyAncHgnLFxuXHRcdFx0dG9wICAgOiB0b3AgKyAncHgnLFxuXHRcdFx0bGVmdCAgOiBsZWZ0ICsgJ3B4J1xuXHRcdH0pO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIC8gY2xlYXJzIGFsbCBzZWxlY3RlZCBpdGVtc1xuXHQgKiBmcm9tIHRoZSBjb250cm9sLlxuXHQgKlxuXHQgKi9cblx0Y2xlYXIoc2lsZW50Pzpib29sZWFuKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCFzZWxmLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXG5cdFx0dmFyIGl0ZW1zID0gc2VsZi5jb250cm9sQ2hpbGRyZW4oKTtcblx0XHRpdGVyYXRlKGl0ZW1zLChpdGVtOlRvbUl0ZW0pPT57XG5cdFx0XHRzZWxmLnJlbW92ZUl0ZW0oaXRlbSx0cnVlKTtcblx0XHR9KTtcblxuXHRcdHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHRcdGlmKCAhc2lsZW50ICkgc2VsZi51cGRhdGVPcmlnaW5hbElucHV0KCk7XG5cdFx0c2VsZi50cmlnZ2VyKCdjbGVhcicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgaGVscGVyIG1ldGhvZCBmb3IgaW5zZXJ0aW5nIGFuIGVsZW1lbnRcblx0ICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG5cdCAqXG5cdCAqL1xuXHRpbnNlcnRBdENhcmV0KGVsOkhUTUxFbGVtZW50KSB7XG5cdFx0Y29uc3Qgc2VsZlx0XHQ9IHRoaXM7XG5cdFx0Y29uc3QgY2FyZXRcdFx0PSBzZWxmLmNhcmV0UG9zO1xuXHRcdGNvbnN0IHRhcmdldFx0PSBzZWxmLmNvbnRyb2w7XG5cblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKGVsLCB0YXJnZXQuY2hpbGRyZW5bY2FyZXRdIHx8IG51bGwpO1xuXHRcdHNlbGYuc2V0Q2FyZXQoY2FyZXQgKyAxKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBjdXJyZW50IHNlbGVjdGVkIGl0ZW0ocykuXG5cdCAqXG5cdCAqL1xuXHRkZWxldGVTZWxlY3Rpb24oZTpLZXlib2FyZEV2ZW50KTpib29sZWFuIHtcblx0XHR2YXIgZGlyZWN0aW9uLCBzZWxlY3Rpb24sIGNhcmV0LCB0YWlsO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGRpcmVjdGlvbiA9IChlICYmIGUua2V5Q29kZSA9PT0gY29uc3RhbnRzLktFWV9CQUNLU1BBQ0UpID8gLTEgOiAxO1xuXHRcdHNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihzZWxmLmNvbnRyb2xfaW5wdXQpO1xuXG5cblx0XHQvLyBkZXRlcm1pbmUgaXRlbXMgdGhhdCB3aWxsIGJlIHJlbW92ZWRcblx0XHRjb25zdCBybV9pdGVtczpUb21JdGVtW11cdD0gW107XG5cblx0XHRpZiAoc2VsZi5hY3RpdmVJdGVtcy5sZW5ndGgpIHtcblxuXHRcdFx0dGFpbCA9IGdldFRhaWwoc2VsZi5hY3RpdmVJdGVtcywgZGlyZWN0aW9uKTtcblx0XHRcdGNhcmV0ID0gbm9kZUluZGV4KHRhaWwpO1xuXG5cdFx0XHRpZiAoZGlyZWN0aW9uID4gMCkgeyBjYXJldCsrOyB9XG5cblx0XHRcdGl0ZXJhdGUoc2VsZi5hY3RpdmVJdGVtcywgKGl0ZW06VG9tSXRlbSkgPT4gcm1faXRlbXMucHVzaChpdGVtKSApO1xuXG5cdFx0fSBlbHNlIGlmICgoc2VsZi5pc0ZvY3VzZWQgfHwgc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJykgJiYgc2VsZi5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdGNvbnN0IGl0ZW1zID0gc2VsZi5jb250cm9sQ2hpbGRyZW4oKTtcblx0XHRcdGxldCBybV9pdGVtO1xuXHRcdFx0aWYoIGRpcmVjdGlvbiA8IDAgJiYgc2VsZWN0aW9uLnN0YXJ0ID09PSAwICYmIHNlbGVjdGlvbi5sZW5ndGggPT09IDAgKXtcblx0XHRcdFx0cm1faXRlbSA9IGl0ZW1zW3NlbGYuY2FyZXRQb3MgLSAxXTtcblxuXHRcdFx0fWVsc2UgaWYoIGRpcmVjdGlvbiA+IDAgJiYgc2VsZWN0aW9uLnN0YXJ0ID09PSBzZWxmLmlucHV0VmFsdWUoKS5sZW5ndGggKXtcblx0XHRcdFx0cm1faXRlbSA9IGl0ZW1zW3NlbGYuY2FyZXRQb3NdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggcm1faXRlbSAhPT0gdW5kZWZpbmVkICl7XG5cdFx0XHRcdHJtX2l0ZW1zLnB1c2goIHJtX2l0ZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiggIXNlbGYuc2hvdWxkRGVsZXRlKHJtX2l0ZW1zLGUpICl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJldmVudERlZmF1bHQoZSx0cnVlKTtcblxuXHRcdC8vIHBlcmZvcm0gcmVtb3ZhbFxuXHRcdGlmICh0eXBlb2YgY2FyZXQgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRzZWxmLnNldENhcmV0KGNhcmV0KTtcblx0XHR9XG5cblx0XHR3aGlsZSggcm1faXRlbXMubGVuZ3RoICl7XG5cdFx0XHRzZWxmLnJlbW92ZUl0ZW0ocm1faXRlbXMucG9wKCkpO1xuXHRcdH1cblxuXHRcdHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHRcdHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuXHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRydWUgaWYgdGhlIGl0ZW1zIHNob3VsZCBiZSBkZWxldGVkXG5cdCAqL1xuXHRzaG91bGREZWxldGUoaXRlbXM6VG9tSXRlbVtdLGV2dDpNb3VzZUV2ZW50fEtleWJvYXJkRXZlbnQpe1xuXG5cdFx0Y29uc3QgdmFsdWVzID0gaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5kYXRhc2V0LnZhbHVlKTtcblxuXHRcdC8vIGFsbG93IHRoZSBjYWxsYmFjayB0byBhYm9ydFxuXHRcdGlmKCAhdmFsdWVzLmxlbmd0aCB8fCAodHlwZW9mIHRoaXMuc2V0dGluZ3Mub25EZWxldGUgPT09ICdmdW5jdGlvbicgJiYgdGhpcy5zZXR0aW5ncy5vbkRlbGV0ZSh2YWx1ZXMsZXZ0KSA9PT0gZmFsc2UpICl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogU2VsZWN0cyB0aGUgcHJldmlvdXMgLyBuZXh0IGl0ZW0gKGRlcGVuZGluZyBvbiB0aGUgYGRpcmVjdGlvbmAgYXJndW1lbnQpLlxuXHQgKlxuXHQgKiA+IDAgLSByaWdodFxuXHQgKiA8IDAgLSBsZWZ0XG5cdCAqXG5cdCAqL1xuXHRhZHZhbmNlU2VsZWN0aW9uKGRpcmVjdGlvbjpudW1iZXIsIGU/Ok1vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudCkge1xuXHRcdHZhciBsYXN0X2FjdGl2ZSwgYWRqYWNlbnQsIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKHNlbGYucnRsKSBkaXJlY3Rpb24gKj0gLTE7XG5cdFx0aWYoIHNlbGYuaW5wdXRWYWx1ZSgpLmxlbmd0aCApIHJldHVybjtcblxuXG5cdFx0Ly8gYWRkIG9yIHJlbW92ZSB0byBhY3RpdmUgaXRlbXNcblx0XHRpZiggaXNLZXlEb3duKGNvbnN0YW50cy5LRVlfU0hPUlRDVVQsZSkgfHwgaXNLZXlEb3duKCdzaGlmdEtleScsZSkgKXtcblxuXHRcdFx0bGFzdF9hY3RpdmVcdFx0XHQ9IHNlbGYuZ2V0TGFzdEFjdGl2ZShkaXJlY3Rpb24pO1xuXHRcdFx0aWYoIGxhc3RfYWN0aXZlICl7XG5cblx0XHRcdFx0aWYoICFsYXN0X2FjdGl2ZS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICl7XG5cdFx0XHRcdFx0YWRqYWNlbnRcdFx0XHQ9IGxhc3RfYWN0aXZlO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRhZGphY2VudFx0XHRcdD0gc2VsZi5nZXRBZGphY2VudChsYXN0X2FjdGl2ZSxkaXJlY3Rpb24sJ2l0ZW0nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBpZiBubyBhY3RpdmUgaXRlbSwgZ2V0IGl0ZW1zIGFkamFjZW50IHRvIHRoZSBjb250cm9sIGlucHV0XG5cdFx0XHR9ZWxzZSBpZiggZGlyZWN0aW9uID4gMCApe1xuXHRcdFx0XHRhZGphY2VudFx0XHRcdD0gc2VsZi5jb250cm9sX2lucHV0Lm5leHRFbGVtZW50U2libGluZztcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRhZGphY2VudFx0XHRcdD0gc2VsZi5jb250cm9sX2lucHV0LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYoIGFkamFjZW50ICl7XG5cdFx0XHRcdGlmKCBhZGphY2VudC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICl7XG5cdFx0XHRcdFx0c2VsZi5yZW1vdmVBY3RpdmVJdGVtKGxhc3RfYWN0aXZlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhhZGphY2VudCk7IC8vIG1hcmsgYXMgbGFzdF9hY3RpdmUgISEgYWZ0ZXIgcmVtb3ZlQWN0aXZlSXRlbSgpIG9uIGxhc3RfYWN0aXZlXG5cdFx0XHR9XG5cblx0XHQvLyBtb3ZlIGNhcmV0IHRvIHRoZSBsZWZ0IG9yIHJpZ2h0XG5cdFx0fWVsc2V7XG5cdFx0XHRzZWxmLm1vdmVDYXJldChkaXJlY3Rpb24pO1xuXHRcdH1cblx0fVxuXG5cdG1vdmVDYXJldChkaXJlY3Rpb246bnVtYmVyKXt9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbGFzdCBhY3RpdmUgaXRlbVxuXHQgKlxuXHQgKi9cblx0Z2V0TGFzdEFjdGl2ZShkaXJlY3Rpb24/Om51bWJlcil7XG5cblx0XHRsZXQgbGFzdF9hY3RpdmUgPSB0aGlzLmNvbnRyb2wucXVlcnlTZWxlY3RvcignLmxhc3QtYWN0aXZlJyk7XG5cdFx0aWYoIGxhc3RfYWN0aXZlICl7XG5cdFx0XHRyZXR1cm4gbGFzdF9hY3RpdmU7XG5cdFx0fVxuXG5cblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5jb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hY3RpdmUnKTtcblx0XHRpZiggcmVzdWx0ICl7XG5cdFx0XHRyZXR1cm4gZ2V0VGFpbChyZXN1bHQsZGlyZWN0aW9uKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBNb3ZlcyB0aGUgY2FyZXQgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cblx0ICpcblx0ICogVGhlIGlucHV0IG11c3QgYmUgbW92ZWQgYnkgbGVhdmluZyBpdCBpbiBwbGFjZSBhbmQgbW92aW5nIHRoZVxuXHQgKiBzaWJsaW5ncywgZHVlIHRvIHRoZSBmYWN0IHRoYXQgZm9jdXMgY2Fubm90IGJlIHJlc3RvcmVkIG9uY2UgbG9zdFxuXHQgKiBvbiBtb2JpbGUgd2Via2l0IGRldmljZXNcblx0ICpcblx0ICovXG5cdHNldENhcmV0KG5ld19wb3M6bnVtYmVyKSB7XG5cdFx0dGhpcy5jYXJldFBvcyA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBsaXN0IG9mIGl0ZW0gZG9tIGVsZW1lbnRzXG5cdCAqXG5cdCAqL1xuXHRjb250cm9sQ2hpbGRyZW4oKTpUb21JdGVtW117XG5cdFx0cmV0dXJuIEFycmF5LmZyb20oIHRoaXMuY29udHJvbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10cy1pdGVtXScpICkgYXMgVG9tSXRlbVtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc2FibGVzIHVzZXIgaW5wdXQgb24gdGhlIGNvbnRyb2wuIFVzZWQgd2hpbGVcblx0ICogaXRlbXMgYXJlIGJlaW5nIGFzeW5jaHJvbm91c2x5IGNyZWF0ZWQuXG5cdCAqL1xuXHRsb2NrKCkge1xuXHRcdHRoaXMuc2V0TG9ja2VkKHRydWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlLWVuYWJsZXMgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbC5cblx0ICovXG5cdHVubG9jaygpIHtcblx0XHR0aGlzLnNldExvY2tlZChmYWxzZSk7XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZSBvciBlbmFibGUgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbFxuXHQgKi9cblx0c2V0TG9ja2VkKCBsb2NrOmJvb2xlYW4gPSB0aGlzLmlzUmVhZE9ubHkgfHwgdGhpcy5pc0Rpc2FibGVkICl7XG5cdFx0dGhpcy5pc0xvY2tlZCA9IGxvY2s7XG5cdFx0dGhpcy5yZWZyZXNoU3RhdGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyB1c2VyIGlucHV0IG9uIHRoZSBjb250cm9sIGNvbXBsZXRlbHkuXG5cdCAqIFdoaWxlIGRpc2FibGVkLCBpdCBjYW5ub3QgcmVjZWl2ZSBmb2N1cy5cblx0ICovXG5cdGRpc2FibGUoKSB7XG5cdFx0dGhpcy5zZXREaXNhYmxlZCh0cnVlKTtcblx0XHR0aGlzLmNsb3NlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlcyB0aGUgY29udHJvbCBzbyB0aGF0IGl0IGNhbiByZXNwb25kXG5cdCAqIHRvIGZvY3VzIGFuZCB1c2VyIGlucHV0LlxuXHQgKi9cblx0ZW5hYmxlKCkge1xuXHRcdHRoaXMuc2V0RGlzYWJsZWQoZmFsc2UpO1xuXHR9XG5cblx0c2V0RGlzYWJsZWQoZGlzYWJsZWQ6Ym9vbGVhbil7XG5cdFx0dGhpcy5mb2N1c19ub2RlLnRhYkluZGV4XHRcdD0gZGlzYWJsZWQgPyAtMSA6IHRoaXMudGFiSW5kZXg7XG5cdFx0dGhpcy5pc0Rpc2FibGVkXHRcdFx0XHRcdD0gZGlzYWJsZWQ7XG5cdFx0dGhpcy5pbnB1dC5kaXNhYmxlZFx0XHRcdFx0PSBkaXNhYmxlZDtcblx0XHR0aGlzLmNvbnRyb2xfaW5wdXQuZGlzYWJsZWRcdFx0PSBkaXNhYmxlZDtcblx0XHR0aGlzLnNldExvY2tlZCgpO1xuXHR9XG5cblx0c2V0UmVhZE9ubHkoaXNSZWFkT25seTpib29sZWFuKXtcblx0XHR0aGlzLmlzUmVhZE9ubHlcdFx0XHRcdFx0PSBpc1JlYWRPbmx5O1xuXHRcdHRoaXMuaW5wdXQucmVhZE9ubHlcdFx0XHRcdD0gaXNSZWFkT25seTtcblx0XHR0aGlzLmNvbnRyb2xfaW5wdXQucmVhZE9ubHlcdFx0PSBpc1JlYWRPbmx5O1xuXHRcdHRoaXMuc2V0TG9ja2VkKCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29tcGxldGVseSBkZXN0cm95cyB0aGUgY29udHJvbCBhbmRcblx0ICogdW5iaW5kcyBhbGwgZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXQgaXQgY2FuXG5cdCAqIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuXHQgKi9cblx0ZGVzdHJveSgpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHJldmVydFNldHRpbmdzID0gc2VsZi5yZXZlcnRTZXR0aW5ncztcblxuXHRcdHNlbGYudHJpZ2dlcignZGVzdHJveScpO1xuXHRcdHNlbGYub2ZmKCk7XG5cdFx0c2VsZi53cmFwcGVyLnJlbW92ZSgpO1xuXHRcdHNlbGYuZHJvcGRvd24ucmVtb3ZlKCk7XG5cblx0XHRzZWxmLmlucHV0LmlubmVySFRNTCA9IHJldmVydFNldHRpbmdzLmlubmVySFRNTDtcblx0XHRzZWxmLmlucHV0LnRhYkluZGV4ID0gcmV2ZXJ0U2V0dGluZ3MudGFiSW5kZXg7XG5cblx0XHRyZW1vdmVDbGFzc2VzKHNlbGYuaW5wdXQsJ3RvbXNlbGVjdGVkJywndHMtaGlkZGVuLWFjY2Vzc2libGUnKTtcblxuXHRcdHNlbGYuX2Rlc3Ryb3koKTtcblxuXHRcdGRlbGV0ZSBzZWxmLmlucHV0LnRvbXNlbGVjdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGhlbHBlciBtZXRob2QgZm9yIHJlbmRlcmluZyBcIml0ZW1cIiBhbmRcblx0ICogXCJvcHRpb25cIiB0ZW1wbGF0ZXMsIGdpdmVuIHRoZSBkYXRhLlxuXHQgKlxuXHQgKi9cblx0cmVuZGVyKCB0ZW1wbGF0ZU5hbWU6VG9tVGVtcGxhdGVOYW1lcywgZGF0YT86YW55ICk6bnVsbHxIVE1MRWxlbWVudHtcblx0XHR2YXIgaWQsIGh0bWw7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiggdHlwZW9mIHRoaXMuc2V0dGluZ3MucmVuZGVyW3RlbXBsYXRlTmFtZV0gIT09ICdmdW5jdGlvbicgKXtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIHJlbmRlciBtYXJrdXBcblx0XHRodG1sID0gc2VsZi5zZXR0aW5ncy5yZW5kZXJbdGVtcGxhdGVOYW1lXS5jYWxsKHRoaXMsIGRhdGEsIGVzY2FwZV9odG1sKTtcblxuXHRcdGlmKCAhaHRtbCApe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aHRtbCA9IGdldERvbSggaHRtbCApO1xuXG5cdFx0Ly8gYWRkIG1hbmRhdG9yeSBhdHRyaWJ1dGVzXG5cdFx0aWYgKHRlbXBsYXRlTmFtZSA9PT0gJ29wdGlvbicgfHwgdGVtcGxhdGVOYW1lID09PSAnb3B0aW9uX2NyZWF0ZScpIHtcblxuXHRcdFx0aWYoIGRhdGFbc2VsZi5zZXR0aW5ncy5kaXNhYmxlZEZpZWxkXSApe1xuXHRcdFx0XHRzZXRBdHRyKGh0bWwseydhcmlhLWRpc2FibGVkJzondHJ1ZSd9KTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRzZXRBdHRyKGh0bWwseydkYXRhLXNlbGVjdGFibGUnOiAnJ30pO1xuXHRcdFx0fVxuXG5cdFx0fWVsc2UgaWYgKHRlbXBsYXRlTmFtZSA9PT0gJ29wdGdyb3VwJykge1xuXHRcdFx0aWQgPSBkYXRhLmdyb3VwW3NlbGYuc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkXTtcblx0XHRcdHNldEF0dHIoaHRtbCx7J2RhdGEtZ3JvdXAnOiBpZH0pO1xuXHRcdFx0aWYoZGF0YS5ncm91cFtzZWxmLnNldHRpbmdzLmRpc2FibGVkRmllbGRdKSB7XG5cdFx0XHRcdHNldEF0dHIoaHRtbCx7J2RhdGEtZGlzYWJsZWQnOiAnJ30pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0ZW1wbGF0ZU5hbWUgPT09ICdvcHRpb24nIHx8IHRlbXBsYXRlTmFtZSA9PT0gJ2l0ZW0nKSB7XG5cdFx0XHRjb25zdCB2YWx1ZVx0PSBnZXRfaGFzaChkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuXHRcdFx0c2V0QXR0cihodG1sLHsnZGF0YS12YWx1ZSc6IHZhbHVlIH0pO1xuXG5cblx0XHRcdC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHNvbWUgY2xhc3NlcyBpZiBhIHRlbXBsYXRlIGlzIG92ZXJ3cml0dGVuXG5cdFx0XHRpZiggdGVtcGxhdGVOYW1lID09PSAnaXRlbScgKXtcblx0XHRcdFx0YWRkQ2xhc3NlcyhodG1sLHNlbGYuc2V0dGluZ3MuaXRlbUNsYXNzKTtcblx0XHRcdFx0c2V0QXR0cihodG1sLHsnZGF0YS10cy1pdGVtJzonJ30pO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGFkZENsYXNzZXMoaHRtbCxzZWxmLnNldHRpbmdzLm9wdGlvbkNsYXNzKTtcblx0XHRcdFx0c2V0QXR0cihodG1sLHtcblx0XHRcdFx0XHRyb2xlOidvcHRpb24nLFxuXHRcdFx0XHRcdGlkOmRhdGEuJGlkXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBjYWNoZVxuXHRcdFx0XHRkYXRhLiRkaXYgPSBodG1sO1xuXHRcdFx0XHRzZWxmLm9wdGlvbnNbdmFsdWVdID0gZGF0YTtcblx0XHRcdH1cblxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh0bWw7XG5cblx0fVxuXG5cblx0LyoqXG5cdCAqIFR5cGUgZ3VhcmRlZCByZW5kZXJpbmdcblx0ICpcblx0ICovXG5cdF9yZW5kZXIoIHRlbXBsYXRlTmFtZTpUb21UZW1wbGF0ZU5hbWVzLCBkYXRhPzphbnkgKTpIVE1MRWxlbWVudHtcblx0XHRjb25zdCBodG1sID0gdGhpcy5yZW5kZXIodGVtcGxhdGVOYW1lLCBkYXRhKTtcblxuXHRcdGlmKCBodG1sID09IG51bGwgKXtcblx0XHRcdHRocm93ICdIVE1MRWxlbWVudCBleHBlY3RlZCc7XG5cdFx0fVxuXHRcdHJldHVybiBodG1sO1xuXHR9XG5cblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSByZW5kZXIgY2FjaGUgZm9yIGEgdGVtcGxhdGUuIElmXG5cdCAqIG5vIHRlbXBsYXRlIGlzIGdpdmVuLCBjbGVhcnMgYWxsIHJlbmRlclxuXHQgKiBjYWNoZXMuXG5cdCAqXG5cdCAqL1xuXHRjbGVhckNhY2hlKCk6dm9pZHtcblxuXHRcdGl0ZXJhdGUodGhpcy5vcHRpb25zLCAob3B0aW9uOlRvbU9wdGlvbik9Pntcblx0XHRcdGlmKCBvcHRpb24uJGRpdiApe1xuXHRcdFx0XHRvcHRpb24uJGRpdi5yZW1vdmUoKTtcblx0XHRcdFx0ZGVsZXRlIG9wdGlvbi4kZGl2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gaXRlbSBhbmQgb3B0aW9uIGNhY2hlc1xuXHQgKlxuXHQgKi9cblx0dW5jYWNoZVZhbHVlKHZhbHVlOnN0cmluZyl7XG5cblx0XHRjb25zdCBvcHRpb25fZWxcdFx0XHQ9IHRoaXMuZ2V0T3B0aW9uKHZhbHVlKTtcblx0XHRpZiggb3B0aW9uX2VsICkgb3B0aW9uX2VsLnJlbW92ZSgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBkaXNwbGF5IHRoZVxuXHQgKiBjcmVhdGUgaXRlbSBwcm9tcHQsIGdpdmVuIGEgdXNlciBpbnB1dC5cblx0ICpcblx0ICovXG5cdGNhbkNyZWF0ZSggaW5wdXQ6c3RyaW5nICk6Ym9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0dGluZ3MuY3JlYXRlICYmIChpbnB1dC5sZW5ndGggPiAwKSAmJiAodGhpcy5zZXR0aW5ncy5jcmVhdGVGaWx0ZXIgYXMgVG9tQ3JlYXRlRmlsdGVyICkuY2FsbCh0aGlzLCBpbnB1dCk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBXcmFwcyB0aGlzLmBtZXRob2RgIHNvIHRoYXQgYG5ld19mbmAgY2FuIGJlIGludm9rZWQgJ2JlZm9yZScsICdhZnRlcicsIG9yICdpbnN0ZWFkJyBvZiB0aGUgb3JpZ2luYWwgbWV0aG9kXG5cdCAqXG5cdCAqIHRoaXMuaG9vaygnaW5zdGVhZCcsJ29uS2V5RG93bicsZnVuY3Rpb24oIGFyZzEsIGFyZzIgLi4uKXtcblx0ICpcblx0ICogfSk7XG5cdCAqL1xuXHRob29rKCB3aGVuOnN0cmluZywgbWV0aG9kOnN0cmluZywgbmV3X2ZuOmFueSApe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgb3JpZ19tZXRob2QgPSBzZWxmW21ldGhvZF07XG5cblxuXHRcdHNlbGZbbWV0aG9kXSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgcmVzdWx0LCByZXN1bHRfbmV3O1xuXG5cdFx0XHRpZiggd2hlbiA9PT0gJ2FmdGVyJyApe1xuXHRcdFx0XHRyZXN1bHQgPSBvcmlnX21ldGhvZC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXN1bHRfbmV3ID0gbmV3X2ZuLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRpZiggd2hlbiA9PT0gJ2luc3RlYWQnICl7XG5cdFx0XHRcdHJldHVybiByZXN1bHRfbmV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggd2hlbiA9PT0gJ2JlZm9yZScgKXtcblx0XHRcdFx0cmVzdWx0ID0gb3JpZ19tZXRob2QuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdH1cblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJjaGFuZ2VfbGlzdGVuZXJcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgYWRkRXZlbnQgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0KSB7XG5cdGFkZEV2ZW50KHRoaXMuaW5wdXQsJ2NoYW5nZScsKCk9Pntcblx0XHR0aGlzLnN5bmMoKTtcblx0fSk7XG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcImNoZWNrYm94X29wdGlvbnNcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgcHJldmVudERlZmF1bHQsIGhhc2hfa2V5IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0RG9tIH0gZnJvbSAnLi4vLi4vdmFuaWxsYSc7XG5pbXBvcnQgeyBDQk9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCwgdXNlck9wdGlvbnM6Q0JPcHRpb25zKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dmFyIG9yaWdfb25PcHRpb25TZWxlY3QgPSBzZWxmLm9uT3B0aW9uU2VsZWN0O1xuXG5cdHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkID0gZmFsc2U7XG5cblx0Y29uc3QgY2JPcHRpb25zIDogQ0JPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Ly8gc28gdGhhdCB0aGUgdXNlciBtYXkgYWRkIGRpZmZlcmVudCBvbmVzIGFzIHdlbGxcblx0XHRjbGFzc05hbWUgICAgICAgICAgICAgOiBcInRvbXNlbGVjdC1jaGVja2JveFwiLFxuXG5cdFx0Ly8gdGhlIGZvbGxvd2luZyBkZWZhdWx0IHRvIHRoZSBoaXN0b3JpYyBwbHVnaW4ncyB2YWx1ZXNcblx0XHRjaGVja2VkQ2xhc3NOYW1lcyAgICAgOiB1bmRlZmluZWQsXG5cdFx0dW5jaGVja2VkQ2xhc3NOYW1lcyAgIDogdW5kZWZpbmVkLFxuXHR9LCB1c2VyT3B0aW9ucyk7XG5cblxuXHR2YXIgVXBkYXRlQ2hlY2tlZCA9IGZ1bmN0aW9uKGNoZWNrYm94OkhUTUxJbnB1dEVsZW1lbnQsIHRvQ2hlY2sgOiBib29sZWFuKSB7XG5cdFx0aWYoIHRvQ2hlY2sgKXtcblx0XHRcdGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuXHRcdFx0aWYgKGNiT3B0aW9ucy51bmNoZWNrZWRDbGFzc05hbWVzKSB7XG5cdFx0XHRcdGNoZWNrYm94LmNsYXNzTGlzdC5yZW1vdmUoLi4uY2JPcHRpb25zLnVuY2hlY2tlZENsYXNzTmFtZXMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNiT3B0aW9ucy5jaGVja2VkQ2xhc3NOYW1lcykge1xuXHRcdFx0XHRjaGVja2JveC5jbGFzc0xpc3QuYWRkKC4uLmNiT3B0aW9ucy5jaGVja2VkQ2xhc3NOYW1lcyk7XG5cdFx0XHR9XG5cdFx0fWVsc2V7XG5cdFx0XHRjaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG5cdFx0XHRpZiAoY2JPcHRpb25zLmNoZWNrZWRDbGFzc05hbWVzKSB7XG5cdFx0XHRcdGNoZWNrYm94LmNsYXNzTGlzdC5yZW1vdmUoLi4uY2JPcHRpb25zLmNoZWNrZWRDbGFzc05hbWVzKTtcblx0XHRcdH1cblx0XHRcdGlmIChjYk9wdGlvbnMudW5jaGVja2VkQ2xhc3NOYW1lcykge1xuXHRcdFx0XHRjaGVja2JveC5jbGFzc0xpc3QuYWRkKC4uLmNiT3B0aW9ucy51bmNoZWNrZWRDbGFzc05hbWVzKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyB1cGRhdGUgdGhlIGNoZWNrYm94IGZvciBhbiBvcHRpb25cblx0dmFyIFVwZGF0ZUNoZWNrYm94ID0gZnVuY3Rpb24ob3B0aW9uOkhUTUxFbGVtZW50KXtcblx0XHRzZXRUaW1lb3V0KCgpPT57XG5cdFx0XHR2YXIgY2hlY2tib3ggPSBvcHRpb24ucXVlcnlTZWxlY3RvcignaW5wdXQuJyArIGNiT3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdFx0aWYoIGNoZWNrYm94IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCApe1xuXHRcdFx0XHRVcGRhdGVDaGVja2VkKGNoZWNrYm94LCBvcHRpb24uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKTtcblx0XHRcdH1cblx0XHR9LDEpO1xuXHR9O1xuXG5cdC8vIGFkZCBjaGVja2JveCB0byBvcHRpb24gdGVtcGxhdGVcblx0c2VsZi5ob29rKCdhZnRlcicsJ3NldHVwVGVtcGxhdGVzJywoKSA9PiB7XG5cblx0XHR2YXIgb3JpZ19yZW5kZXJfb3B0aW9uID0gc2VsZi5zZXR0aW5ncy5yZW5kZXIub3B0aW9uO1xuXG5cdFx0c2VsZi5zZXR0aW5ncy5yZW5kZXIub3B0aW9uID0gKGRhdGEsIGVzY2FwZV9odG1sKSA9PiB7XG5cdFx0XHR2YXIgcmVuZGVyZWQgPSBnZXREb20ob3JpZ19yZW5kZXJfb3B0aW9uLmNhbGwoc2VsZiwgZGF0YSwgZXNjYXBlX2h0bWwpKTtcblx0XHRcdHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG5cdFx0XHRpZiAoY2JPcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRjaGVja2JveC5jbGFzc0xpc3QuYWRkKGNiT3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdFx0fVxuXHRcdFx0Y2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Y2hlY2tib3gudHlwZSA9ICdjaGVja2JveCc7XG5cdFx0XHRjb25zdCBoYXNoZWQgPSBoYXNoX2tleShkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuXG5cdFx0XHRVcGRhdGVDaGVja2VkKGNoZWNrYm94LCAhIShoYXNoZWQgJiYgc2VsZi5pdGVtcy5pbmRleE9mKGhhc2hlZCkgPiAtMSkgKTtcblxuXHRcdFx0cmVuZGVyZWQucHJlcGVuZChjaGVja2JveCk7XG5cdFx0XHRyZXR1cm4gcmVuZGVyZWQ7XG5cdFx0fTtcblx0fSk7XG5cblx0Ly8gdW5jaGVjayB3aGVuIGl0ZW0gcmVtb3ZlZFxuXHRzZWxmLm9uKCdpdGVtX3JlbW92ZScsKHZhbHVlOnN0cmluZykgPT4ge1xuXHRcdHZhciBvcHRpb24gPSBzZWxmLmdldE9wdGlvbih2YWx1ZSk7XG5cblx0XHRpZiggb3B0aW9uICl7IC8vIGlmIGRyb3Bkb3duIGhhc24ndCBiZWVuIG9wZW5lZCB5ZXQsIHRoZSBvcHRpb24gd29uJ3QgZXhpc3Rcblx0XHRcdG9wdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpOyAvLyBzZWxlY3RlZCBjbGFzcyB3b24ndCBiZSByZW1vdmVkIHlldFxuXHRcdFx0VXBkYXRlQ2hlY2tib3gob3B0aW9uKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIGNoZWNrIHdoZW4gaXRlbSBhZGRlZFxuXHRzZWxmLm9uKCdpdGVtX2FkZCcsKHZhbHVlOnN0cmluZykgPT4ge1xuXHRcdHZhciBvcHRpb24gPSBzZWxmLmdldE9wdGlvbih2YWx1ZSk7XG5cblx0XHRpZiggb3B0aW9uICl7IC8vIGlmIGRyb3Bkb3duIGhhc24ndCBiZWVuIG9wZW5lZCB5ZXQsIHRoZSBvcHRpb24gd29uJ3QgZXhpc3Rcblx0XHRcdFVwZGF0ZUNoZWNrYm94KG9wdGlvbik7XG5cdFx0fVxuXHR9KTtcblxuXG5cdC8vIHJlbW92ZSBpdGVtcyB3aGVuIHNlbGVjdGVkIG9wdGlvbiBpcyBjbGlja2VkXG5cdHNlbGYuaG9vaygnaW5zdGVhZCcsJ29uT3B0aW9uU2VsZWN0JywoIGV2dDpLZXlib2FyZEV2ZW50LCBvcHRpb246SFRNTEVsZW1lbnQgKT0+e1xuXG5cdFx0aWYoIG9wdGlvbi5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykgKXtcblx0XHRcdG9wdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpXG5cdFx0XHRzZWxmLnJlbW92ZUl0ZW0ob3B0aW9uLmRhdGFzZXQudmFsdWUpO1xuXHRcdFx0c2VsZi5yZWZyZXNoT3B0aW9ucygpO1xuXHRcdFx0cHJldmVudERlZmF1bHQoZXZ0LHRydWUpO1xuXHRcdFx0cmV0dXJuO1xuICAgICAgICB9XG5cblx0XHRvcmlnX29uT3B0aW9uU2VsZWN0LmNhbGwoc2VsZiwgZXZ0LCBvcHRpb24pO1xuXG5cdFx0VXBkYXRlQ2hlY2tib3gob3B0aW9uKTtcblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwiZHJvcGRvd25faGVhZGVyXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCB7IGdldERvbSB9IGZyb20gJy4uLy4uL3ZhbmlsbGEnO1xuaW1wb3J0IHsgQ0JPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0LCB1c2VyT3B0aW9uczpDQk9wdGlvbnMpIHtcblx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0Y29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGNsYXNzTmFtZTogJ2NsZWFyLWJ1dHRvbicsXG5cdFx0dGl0bGU6ICdDbGVhciBBbGwnLFxuXHRcdGh0bWw6IChkYXRhOkNCT3B0aW9ucykgPT4ge1xuXHRcdFx0cmV0dXJuIGA8ZGl2IGNsYXNzPVwiJHtkYXRhLmNsYXNzTmFtZX1cIiB0aXRsZT1cIiR7ZGF0YS50aXRsZX1cIj4mIzEwNzk5OzwvZGl2PmA7XG5cdFx0fVxuXHR9LCB1c2VyT3B0aW9ucyk7XG5cblx0c2VsZi5vbignaW5pdGlhbGl6ZScsKCk9Pntcblx0XHR2YXIgYnV0dG9uID0gZ2V0RG9tKG9wdGlvbnMuaHRtbChvcHRpb25zKSk7XG5cdFx0YnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywoZXZ0KT0+e1xuXG5cdFx0XHRpZiggc2VsZi5pc0xvY2tlZCApIHJldHVybjtcblxuXHRcdFx0c2VsZi5jbGVhcigpO1xuXG5cdFx0XHRpZiggc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJyAmJiBzZWxmLnNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24gKXtcblx0XHRcdFx0c2VsZi5hZGRJdGVtKCcnKTtcblx0XHRcdH1cblxuXHRcdFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fSk7XG5cdFx0c2VsZi5jb250cm9sLmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cdH0pO1xuXG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcImRyYWdfZHJvcFwiIChUb20gU2VsZWN0KVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgeyBUb21PcHRpb24sIFRvbUl0ZW0gfSBmcm9tICcuLi8uLi90eXBlcy9pbmRleCc7XG5pbXBvcnQgeyBlc2NhcGVfaHRtbCwgcHJldmVudERlZmF1bHQsIGFkZEV2ZW50IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0RG9tLCBzZXRBdHRyIH0gZnJvbSAnLi4vLi4vdmFuaWxsYSc7XG5cblxuY29uc3QgaW5zZXJ0QWZ0ZXIgPSAocmVmZXJlbmNlTm9kZTpFbGVtZW50LCBuZXdOb2RlOkVsZW1lbnQpID0+IHtcblx0cmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlPy5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZS5uZXh0U2libGluZyk7XG59XG5cbmNvbnN0IGluc2VydEJlZm9yZSA9IChyZWZlcmVuY2VOb2RlOkVsZW1lbnQsIG5ld05vZGU6RWxlbWVudCkgPT4ge1xuXHRyZWZlcmVuY2VOb2RlLnBhcmVudE5vZGU/Lmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuY29uc3QgaXNCZWZvcmUgPSAocmVmZXJlbmNlTm9kZTpFbGVtZW50fHVuZGVmaW5lZHxudWxsLCBuZXdOb2RlOkVsZW1lbnR8dW5kZWZpbmVkfG51bGwpID0+e1xuXHRcblx0ZG97XG5cdFx0bmV3Tm9kZSA9IG5ld05vZGU/LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG5cblx0XHRpZiggcmVmZXJlbmNlTm9kZSA9PSBuZXdOb2RlICl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0fXdoaWxlKCBuZXdOb2RlICYmIG5ld05vZGUucHJldmlvdXNFbGVtZW50U2libGluZyApO1xuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRpZiAoc2VsZi5zZXR0aW5ncy5tb2RlICE9PSAnbXVsdGknKSByZXR1cm47XG5cblx0dmFyIG9yaWdfbG9ja1x0XHQ9IHNlbGYubG9jaztcblx0dmFyIG9yaWdfdW5sb2NrXHRcdD0gc2VsZi51bmxvY2s7XG5cdGxldCBzb3J0YWJsZSA9IHRydWU7XG5cdFx0bGV0IGRyYWdfaXRlbTpUb21JdGVtfHVuZGVmaW5lZDtcblxuXG5cdC8qKlxuXHQgKiBBZGQgZHJhZ2dhYmxlIGF0dHJpYnV0ZSB0byBpdGVtXG5cdCAqL1xuXHRzZWxmLmhvb2soJ2FmdGVyJywnc2V0dXBUZW1wbGF0ZXMnLCgpID0+IHtcblxuXHRcdHZhciBvcmlnX3JlbmRlcl9pdGVtID0gc2VsZi5zZXR0aW5ncy5yZW5kZXIuaXRlbTtcblxuXHRcdHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW0gPSAoZGF0YTpUb21PcHRpb24sIGVzY2FwZTp0eXBlb2YgZXNjYXBlX2h0bWwpID0+IHtcblx0XHRcdGNvbnN0IGl0ZW0gPSBnZXREb20ob3JpZ19yZW5kZXJfaXRlbS5jYWxsKHNlbGYsIGRhdGEsIGVzY2FwZSkpIGFzIFRvbUl0ZW07XG5cdFx0XHRzZXRBdHRyKGl0ZW0seydkcmFnZ2FibGUnOid0cnVlJ30pO1xuXG5cblx0XHRcdC8vIHByZXZlbnQgZG9jX21vdXNlZG93biAoc2VlIHRvbS1zZWxlY3QudHMpXG5cdFx0XHRjb25zdCBtb3VzZWRvd24gPSAoZXZ0OkV2ZW50KSA9PiB7XG5cdFx0XHRcdGlmKCAhc29ydGFibGUgKSBwcmV2ZW50RGVmYXVsdChldnQpO1xuXHRcdFx0XHRldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRyYWdTdGFydCA9IChldnQ6RXZlbnQpID0+IHtcblx0XHRcdFx0ZHJhZ19pdGVtID0gaXRlbTtcblx0XHRcdFx0XG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdGl0ZW0uY2xhc3NMaXN0LmFkZCgndHMtZHJhZ2dpbmcnKTtcblx0XHRcdFx0fSwgMCk7XG5cdFx0XHRcdFxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkcmFnT3ZlciA9IChldnQ6RXZlbnQpID0+e1xuXHRcdFx0XHRldnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0aXRlbS5jbGFzc0xpc3QuYWRkKCd0cy1kcmFnLW92ZXInKTtcblx0XHRcdFx0bW92ZWl0ZW0oaXRlbSxkcmFnX2l0ZW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkcmFnTGVhdmUgPSAoKSA9PiB7XG5cdFx0XHRcdGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgndHMtZHJhZy1vdmVyJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG1vdmVpdGVtID0gKHRhcmdldGl0ZW06VG9tSXRlbSwgZHJhZ2l0ZW06VG9tSXRlbXx1bmRlZmluZWQpID0+IHtcblx0XHRcdFx0aWYoIGRyYWdpdGVtID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiggaXNCZWZvcmUoZHJhZ2l0ZW0saXRlbSkgKXtcblx0XHRcdFx0XHRpbnNlcnRBZnRlcih0YXJnZXRpdGVtLGRyYWdpdGVtKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0aW5zZXJ0QmVmb3JlKHRhcmdldGl0ZW0sZHJhZ2l0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRyYWdlbmQgPSAoKSA9PiB7XG5cdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50cy1kcmFnLW92ZXInKS5mb3JFYWNoKGVsPT4gZWwuY2xhc3NMaXN0LnJlbW92ZSgndHMtZHJhZy1vdmVyJykpO1xuXHRcdFx0XHRkcmFnX2l0ZW0/LmNsYXNzTGlzdC5yZW1vdmUoJ3RzLWRyYWdnaW5nJyk7XG5cdFx0XHRcdGRyYWdfaXRlbSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHR2YXIgdmFsdWVzOnN0cmluZ1tdID0gW107XG5cdFx0XHRcdHNlbGYuY29udHJvbC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS12YWx1ZV1gKS5mb3JFYWNoKChlbDpFbGVtZW50KT0+IHtcblx0XHRcdFx0XHRpZiggKDxIVE1MT3B0aW9uRWxlbWVudD5lbCkuZGF0YXNldC52YWx1ZSApe1xuXHRcdFx0XHRcdFx0bGV0IHZhbHVlID0gKDxIVE1MT3B0aW9uRWxlbWVudD5lbCkuZGF0YXNldC52YWx1ZTtcblx0XHRcdFx0XHRcdGlmKCB2YWx1ZSApe1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzZWxmLnNldFZhbHVlKHZhbHVlcyk7XG5cdFx0XHR9XHRcblxuXG5cdFx0XHRhZGRFdmVudChpdGVtLCdtb3VzZWRvd24nLCBtb3VzZWRvd24pO1xuXHRcdFx0YWRkRXZlbnQoaXRlbSwnZHJhZ3N0YXJ0JywgZHJhZ1N0YXJ0KTtcblx0XHRcdGFkZEV2ZW50KGl0ZW0sJ2RyYWdlbnRlcicsIGRyYWdPdmVyKVxuXHRcdFx0YWRkRXZlbnQoaXRlbSwnZHJhZ292ZXInLCBkcmFnT3Zlcik7XG5cdFx0XHRhZGRFdmVudChpdGVtLCdkcmFnbGVhdmUnLCBkcmFnTGVhdmUpO1xuXHRcdFx0YWRkRXZlbnQoaXRlbSwnZHJhZ2VuZCcsIGRyYWdlbmQpO1xuXHRcdFx0XHRcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH1cdFxuXHR9KTtcblxuXG5cblx0c2VsZi5ob29rKCdpbnN0ZWFkJywnbG9jaycsKCk9Pntcblx0XHRzb3J0YWJsZSA9IGZhbHNlO1xuXHRcdHJldHVybiBvcmlnX2xvY2suY2FsbChzZWxmKTtcblx0fSk7XG5cblx0c2VsZi5ob29rKCdpbnN0ZWFkJywndW5sb2NrJywoKT0+e1xuXHRcdHNvcnRhYmxlID0gdHJ1ZTtcblx0XHRyZXR1cm4gb3JpZ191bmxvY2suY2FsbChzZWxmKTtcblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwiZHJvcGRvd25faGVhZGVyXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCB7IGdldERvbSB9IGZyb20gJy4uLy4uL3ZhbmlsbGEnO1xuaW1wb3J0IHsgcHJldmVudERlZmF1bHQgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBESE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QsIHVzZXJPcHRpb25zOkRIT3B0aW9ucykge1xuXHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0dGl0bGUgICAgICAgICA6ICdVbnRpdGxlZCcsXG5cdFx0aGVhZGVyQ2xhc3MgICA6ICdkcm9wZG93bi1oZWFkZXInLFxuXHRcdHRpdGxlUm93Q2xhc3MgOiAnZHJvcGRvd24taGVhZGVyLXRpdGxlJyxcblx0XHRsYWJlbENsYXNzICAgIDogJ2Ryb3Bkb3duLWhlYWRlci1sYWJlbCcsXG5cdFx0Y2xvc2VDbGFzcyAgICA6ICdkcm9wZG93bi1oZWFkZXItY2xvc2UnLFxuXG5cdFx0aHRtbDogKGRhdGE6REhPcHRpb25zKSA9PiB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQnPGRpdiBjbGFzcz1cIicgKyBkYXRhLmhlYWRlckNsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiJyArIGRhdGEudGl0bGVSb3dDbGFzcyArICdcIj4nICtcblx0XHRcdFx0XHRcdCc8c3BhbiBjbGFzcz1cIicgKyBkYXRhLmxhYmVsQ2xhc3MgKyAnXCI+JyArIGRhdGEudGl0bGUgKyAnPC9zcGFuPicgK1xuXHRcdFx0XHRcdFx0JzxhIGNsYXNzPVwiJyArIGRhdGEuY2xvc2VDbGFzcyArICdcIj4mdGltZXM7PC9hPicgK1xuXHRcdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0JzwvZGl2Pidcblx0XHRcdCk7XG5cdFx0fVxuXHR9LCB1c2VyT3B0aW9ucyk7XG5cblx0c2VsZi5vbignaW5pdGlhbGl6ZScsKCk9Pntcblx0XHR2YXIgaGVhZGVyID0gZ2V0RG9tKG9wdGlvbnMuaHRtbChvcHRpb25zKSk7XG5cblx0XHR2YXIgY2xvc2VfbGluayA9IGhlYWRlci5xdWVyeVNlbGVjdG9yKCcuJytvcHRpb25zLmNsb3NlQ2xhc3MpO1xuXHRcdGlmKCBjbG9zZV9saW5rICl7XG5cdFx0XHRjbG9zZV9saW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywoZXZ0KT0+e1xuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChldnQsdHJ1ZSk7XG5cdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHNlbGYuZHJvcGRvd24uaW5zZXJ0QmVmb3JlKGhlYWRlciwgc2VsZi5kcm9wZG93bi5maXJzdENoaWxkKTtcblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwiZHJvcGRvd25faW5wdXRcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgbm9kZUluZGV4LCByZW1vdmVDbGFzc2VzIH0gZnJvbSAnLi4vLi4vdmFuaWxsYSc7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdC8qKlxuXHQgKiBNb3ZlcyB0aGUgY2FyZXQgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cblx0ICpcblx0ICogVGhlIGlucHV0IG11c3QgYmUgbW92ZWQgYnkgbGVhdmluZyBpdCBpbiBwbGFjZSBhbmQgbW92aW5nIHRoZVxuXHQgKiBzaWJsaW5ncywgZHVlIHRvIHRoZSBmYWN0IHRoYXQgZm9jdXMgY2Fubm90IGJlIHJlc3RvcmVkIG9uY2UgbG9zdFxuXHQgKiBvbiBtb2JpbGUgd2Via2l0IGRldmljZXNcblx0ICpcblx0ICovXG5cdHNlbGYuaG9vaygnaW5zdGVhZCcsJ3NldENhcmV0JywobmV3X3BvczpudW1iZXIpID0+IHtcblxuXHRcdGlmKCBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnIHx8ICFzZWxmLmNvbnRyb2wuY29udGFpbnMoc2VsZi5jb250cm9sX2lucHV0KSApIHtcblx0XHRcdG5ld19wb3MgPSBzZWxmLml0ZW1zLmxlbmd0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3X3BvcyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNlbGYuaXRlbXMubGVuZ3RoLCBuZXdfcG9zKSk7XG5cblx0XHRcdGlmKCBuZXdfcG9zICE9IHNlbGYuY2FyZXRQb3MgJiYgIXNlbGYuaXNQZW5kaW5nICl7XG5cblx0XHRcdFx0c2VsZi5jb250cm9sQ2hpbGRyZW4oKS5mb3JFYWNoKChjaGlsZCxqKSA9PiB7XG5cdFx0XHRcdFx0aWYoIGogPCBuZXdfcG9zICl7XG5cdFx0XHRcdFx0XHRzZWxmLmNvbnRyb2xfaW5wdXQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdiZWZvcmViZWdpbicsIGNoaWxkICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuY29udHJvbC5hcHBlbmRDaGlsZCggY2hpbGQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlbGYuY2FyZXRQb3MgPSBuZXdfcG9zO1xuXHR9KTtcblxuXHRzZWxmLmhvb2soJ2luc3RlYWQnLCdtb3ZlQ2FyZXQnLChkaXJlY3Rpb246bnVtYmVyKSA9PiB7XG5cblx0XHRpZiggIXNlbGYuaXNGb2N1c2VkICkgcmV0dXJuO1xuXG5cdFx0Ly8gbW92ZSBjYXJldCBiZWZvcmUgb3IgYWZ0ZXIgc2VsZWN0ZWQgaXRlbXNcblx0XHRjb25zdCBsYXN0X2FjdGl2ZVx0XHQ9IHNlbGYuZ2V0TGFzdEFjdGl2ZShkaXJlY3Rpb24pO1xuXHRcdGlmKCBsYXN0X2FjdGl2ZSApe1xuXHRcdFx0Y29uc3QgaWR4ID0gbm9kZUluZGV4KGxhc3RfYWN0aXZlKTtcblx0XHRcdHNlbGYuc2V0Q2FyZXQoZGlyZWN0aW9uID4gMCA/IGlkeCArIDE6IGlkeCk7XG5cdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0oKTtcblx0XHRcdHJlbW92ZUNsYXNzZXMobGFzdF9hY3RpdmUgYXMgSFRNTEVsZW1lbnQsJ2xhc3QtYWN0aXZlJyk7XG5cblx0XHQvLyBtb3ZlIGNhcmV0IGxlZnQgb3IgcmlnaHQgb2YgY3VycmVudCBwb3NpdGlvblxuXHRcdH1lbHNle1xuXHRcdFx0c2VsZi5zZXRDYXJldChzZWxmLmNhcmV0UG9zICsgZGlyZWN0aW9uKTtcblxuXHRcdH1cblxuXHR9KTtcblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJkcm9wZG93bl9pbnB1dFwiIChUb20gU2VsZWN0KVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldERvbSwgYWRkQ2xhc3NlcyB9IGZyb20gJy4uLy4uL3ZhbmlsbGEnO1xuaW1wb3J0IHsgYWRkRXZlbnQsIHByZXZlbnREZWZhdWx0IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0KSB7XG5cdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdHNlbGYuc2V0dGluZ3Muc2hvdWxkT3BlbiA9IHRydWU7IC8vIG1ha2Ugc3VyZSB0aGUgaW5wdXQgaXMgc2hvd24gZXZlbiBpZiB0aGVyZSBhcmUgbm8gb3B0aW9ucyB0byBkaXNwbGF5IGluIHRoZSBkcm9wZG93blxuXG5cdHNlbGYuaG9vaygnYmVmb3JlJywnc2V0dXAnLCgpPT57XG5cdFx0c2VsZi5mb2N1c19ub2RlXHRcdD0gc2VsZi5jb250cm9sO1xuXG5cdFx0YWRkQ2xhc3Nlcyggc2VsZi5jb250cm9sX2lucHV0LCAnZHJvcGRvd24taW5wdXQnKTtcblxuXHQgXHRjb25zdCBkaXYgPSBnZXREb20oJzxkaXYgY2xhc3M9XCJkcm9wZG93bi1pbnB1dC13cmFwXCI+Jyk7XG5cdFx0ZGl2LmFwcGVuZChzZWxmLmNvbnRyb2xfaW5wdXQpO1xuXHRcdHNlbGYuZHJvcGRvd24uaW5zZXJ0QmVmb3JlKGRpdiwgc2VsZi5kcm9wZG93bi5maXJzdENoaWxkKTtcblxuXHRcdC8vIHNldCBhIHBsYWNlaG9sZGVyIGluIHRoZSBzZWxlY3QgY29udHJvbFxuXHRcdGNvbnN0IHBsYWNlaG9sZGVyID0gZ2V0RG9tKCc8aW5wdXQgY2xhc3M9XCJpdGVtcy1wbGFjZWhvbGRlclwiIHRhYmluZGV4PVwiLTFcIiAvPicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cdFx0cGxhY2Vob2xkZXIucGxhY2Vob2xkZXIgPSBzZWxmLnNldHRpbmdzLnBsYWNlaG9sZGVyIHx8Jyc7XG5cdFx0c2VsZi5jb250cm9sLmFwcGVuZChwbGFjZWhvbGRlcik7XG5cblx0fSk7XG5cblxuXHRzZWxmLm9uKCdpbml0aWFsaXplJywoKT0+e1xuXG5cdFx0Ly8gc2V0IHRhYkluZGV4IG9uIGNvbnRyb2wgdG8gLTEsIG90aGVyd2lzZSBbc2hpZnQrdGFiXSB3aWxsIHB1dCBmb2N1cyByaWdodCBiYWNrIG9uIGNvbnRyb2xfaW5wdXRcblx0XHRzZWxmLmNvbnRyb2xfaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsKGV2dDpLZXlib2FyZEV2ZW50KSA9Pntcblx0XHQvL2FkZEV2ZW50KHNlbGYuY29udHJvbF9pbnB1dCwna2V5ZG93bicgYXMgY29uc3QsKGV2dDpLZXlib2FyZEV2ZW50KSA9Pntcblx0XHRcdHN3aXRjaCggZXZ0LmtleUNvZGUgKXtcblx0XHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX0VTQzpcblx0XHRcdFx0XHRpZiAoc2VsZi5pc09wZW4pIHtcblx0XHRcdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCx0cnVlKTtcblx0XHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5jbGVhckFjdGl2ZUl0ZW1zKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX1RBQjpcblx0XHRcdFx0XHRzZWxmLmZvY3VzX25vZGUudGFiSW5kZXggPSAtMTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2VsZi5vbktleURvd24uY2FsbChzZWxmLGV2dCk7XG5cdFx0fSk7XG5cblx0XHRzZWxmLm9uKCdibHVyJywoKT0+e1xuXHRcdFx0c2VsZi5mb2N1c19ub2RlLnRhYkluZGV4ID0gc2VsZi5pc0Rpc2FibGVkID8gLTEgOiBzZWxmLnRhYkluZGV4O1xuXHRcdH0pO1xuXG5cblx0XHQvLyBnaXZlIHRoZSBjb250cm9sX2lucHV0IGZvY3VzIHdoZW4gdGhlIGRyb3Bkb3duIGlzIG9wZW5cblx0XHRzZWxmLm9uKCdkcm9wZG93bl9vcGVuJywoKSA9Pntcblx0XHRcdHNlbGYuY29udHJvbF9pbnB1dC5mb2N1cygpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gcHJldmVudCBvbkJsdXIgZnJvbSBjbG9zaW5nIHdoZW4gZm9jdXMgaXMgb24gdGhlIGNvbnRyb2xfaW5wdXRcblx0XHRjb25zdCBvcmlnX29uQmx1ciA9IHNlbGYub25CbHVyO1xuXHRcdHNlbGYuaG9vaygnaW5zdGVhZCcsJ29uQmx1cicsKGV2dD86Rm9jdXNFdmVudCk9Pntcblx0XHRcdGlmKCBldnQgJiYgZXZ0LnJlbGF0ZWRUYXJnZXQgPT0gc2VsZi5jb250cm9sX2lucHV0ICkgcmV0dXJuO1xuXHRcdFx0cmV0dXJuIG9yaWdfb25CbHVyLmNhbGwoc2VsZik7XG5cdFx0fSk7XG5cblx0XHRhZGRFdmVudChzZWxmLmNvbnRyb2xfaW5wdXQsJ2JsdXInLCAoKSA9PiBzZWxmLm9uQmx1cigpICk7XG5cblx0XHQvLyByZXR1cm4gZm9jdXMgdG8gY29udHJvbCB0byBhbGxvdyBmdXJ0aGVyIGtleWJvYXJkIGlucHV0XG5cdFx0c2VsZi5ob29rKCdiZWZvcmUnLCdjbG9zZScsKCkgPT57XG5cblx0XHRcdGlmKCAhc2VsZi5pc09wZW4gKSByZXR1cm47XG5cdFx0XHRzZWxmLmZvY3VzX25vZGUuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KTtcblx0XHR9KTtcblxuXHR9KTtcblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJpbnB1dF9hdXRvZ3Jvd1wiIChUb20gU2VsZWN0KVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCB7IGFkZEV2ZW50IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCkge1xuXHR2YXIgc2VsZlx0XHRcdFx0XHQ9IHRoaXM7XG5cblx0c2VsZi5vbignaW5pdGlhbGl6ZScsKCk9PntcblxuXG5cdFx0dmFyIHRlc3RfaW5wdXRcdFx0XHRcdD0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXHRcdHZhciBjb250cm9sXHRcdFx0XHRcdD0gc2VsZi5jb250cm9sX2lucHV0O1xuXHRcdHRlc3RfaW5wdXQuc3R5bGUuY3NzVGV4dFx0PSAncG9zaXRpb246YWJzb2x1dGU7IHRvcDotOTk5OTlweDsgbGVmdDotOTk5OTlweDsgd2lkdGg6YXV0bzsgcGFkZGluZzowOyB3aGl0ZS1zcGFjZTpwcmU7ICc7XG5cblx0XHRzZWxmLndyYXBwZXIuYXBwZW5kQ2hpbGQodGVzdF9pbnB1dCk7XG5cblxuXHRcdHZhciB0cmFuc2Zlcl9zdHlsZXNcdFx0XHQ9IFsgJ2xldHRlclNwYWNpbmcnLCAnZm9udFNpemUnLCAnZm9udEZhbWlseScsICdmb250V2VpZ2h0JywgJ3RleHRUcmFuc2Zvcm0nIF07XG5cblx0XHRmb3IoIGNvbnN0IHN0eWxlX25hbWUgb2YgdHJhbnNmZXJfc3R5bGVzICl7XG5cdFx0XHQvLyBAdHMtaWdub3JlIFRTNzAxNSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTA1MDYxNTQvNjk3NTc2XG5cdFx0XHR0ZXN0X2lucHV0LnN0eWxlW3N0eWxlX25hbWVdID0gY29udHJvbC5zdHlsZVtzdHlsZV9uYW1lXTtcblx0XHR9XG5cblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgY29udHJvbCB3aWR0aFxuXHRcdCAqXG5cdFx0ICovXG5cdFx0dmFyIHJlc2l6ZSA9ICgpPT57XG5cdFx0XHR0ZXN0X2lucHV0LnRleHRDb250ZW50XHQ9IGNvbnRyb2wudmFsdWU7XG5cdFx0XHRjb250cm9sLnN0eWxlLndpZHRoXHRcdD0gdGVzdF9pbnB1dC5jbGllbnRXaWR0aCsncHgnO1xuXHRcdH07XG5cblx0XHRyZXNpemUoKTtcblx0XHRzZWxmLm9uKCd1cGRhdGUgaXRlbV9hZGQgaXRlbV9yZW1vdmUnLHJlc2l6ZSk7XG5cdFx0YWRkRXZlbnQoY29udHJvbCwnaW5wdXQnLCByZXNpemUgKTtcblx0XHRhZGRFdmVudChjb250cm9sLCdrZXl1cCcsIHJlc2l6ZSApO1xuXHRcdGFkZEV2ZW50KGNvbnRyb2wsJ2JsdXInLCByZXNpemUgKTtcblx0XHRhZGRFdmVudChjb250cm9sLCd1cGRhdGUnLCByZXNpemUgKTtcblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwiaW5wdXRfYXV0b2dyb3dcIiAoVG9tIFNlbGVjdClcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0KSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dmFyIG9yaWdfZGVsZXRlU2VsZWN0aW9uID0gc2VsZi5kZWxldGVTZWxlY3Rpb247XG5cblx0dGhpcy5ob29rKCdpbnN0ZWFkJywnZGVsZXRlU2VsZWN0aW9uJywoZXZ0OktleWJvYXJkRXZlbnQpID0+IHtcblxuXHRcdGlmKCBzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCApe1xuXHRcdFx0cmV0dXJuIG9yaWdfZGVsZXRlU2VsZWN0aW9uLmNhbGwoc2VsZiwgZXZ0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pO1xuXG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcIm5vX2FjdGl2ZV9pdGVtc1wiIChUb20gU2VsZWN0KVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QpIHtcblx0dGhpcy5ob29rKCdpbnN0ZWFkJywnc2V0QWN0aXZlSXRlbScsKCkgPT4ge30pO1xuXHR0aGlzLmhvb2soJ2luc3RlYWQnLCdzZWxlY3RBbGwnLCgpID0+IHt9KTtcbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwib3B0Z3JvdXBfY29sdW1uc1wiIChUb20gU2VsZWN0LmpzKVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IHBhcmVudE1hdGNoLCBub2RlSW5kZXggfSBmcm9tICcuLi8uLi92YW5pbGxhJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdHZhciBvcmlnX2tleWRvd24gPSBzZWxmLm9uS2V5RG93bjtcblxuXHRzZWxmLmhvb2soJ2luc3RlYWQnLCdvbktleURvd24nLChldnQ6S2V5Ym9hcmRFdmVudCk9Pntcblx0XHR2YXIgaW5kZXgsIG9wdGlvbiwgb3B0aW9ucywgb3B0Z3JvdXA7XG5cblx0XHRpZiggIXNlbGYuaXNPcGVuIHx8ICEoZXZ0LmtleUNvZGUgPT09IGNvbnN0YW50cy5LRVlfTEVGVCB8fCBldnQua2V5Q29kZSA9PT0gY29uc3RhbnRzLktFWV9SSUdIVCkpIHtcblx0XHRcdHJldHVybiBvcmlnX2tleWRvd24uY2FsbChzZWxmLGV2dCk7XG5cdFx0fVxuXG5cdFx0c2VsZi5pZ25vcmVIb3Zlclx0PSB0cnVlO1xuXHRcdG9wdGdyb3VwXHRcdFx0PSBwYXJlbnRNYXRjaChzZWxmLmFjdGl2ZU9wdGlvbiwnW2RhdGEtZ3JvdXBdJyk7XG5cdFx0aW5kZXhcdFx0XHRcdD0gbm9kZUluZGV4KHNlbGYuYWN0aXZlT3B0aW9uLCdbZGF0YS1zZWxlY3RhYmxlXScpO1xuXG5cdFx0aWYoICFvcHRncm91cCApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCBldnQua2V5Q29kZSA9PT0gY29uc3RhbnRzLktFWV9MRUZUICl7XG5cdFx0XHRvcHRncm91cCA9IG9wdGdyb3VwLnByZXZpb3VzU2libGluZztcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3B0Z3JvdXAgPSBvcHRncm91cC5uZXh0U2libGluZztcblx0XHR9XG5cblx0XHRpZiggIW9wdGdyb3VwICl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0b3B0aW9uc1x0XHRcdFx0PSAoPEhUTUxPcHRHcm91cEVsZW1lbnQ+b3B0Z3JvdXApLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG5cdFx0b3B0aW9uXHRcdFx0XHQ9IG9wdGlvbnNbIE1hdGgubWluKG9wdGlvbnMubGVuZ3RoIC0gMSwgaW5kZXgpIF0gYXMgSFRNTEVsZW1lbnQ7XG5cblx0XHRpZiggb3B0aW9uICl7XG5cdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihvcHRpb24pO1xuXHRcdH1cblxuXHR9KTtcblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJyZW1vdmVfYnV0dG9uXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCB7IGdldERvbSB9IGZyb20gJy4uLy4uL3ZhbmlsbGEnO1xuaW1wb3J0IHsgZXNjYXBlX2h0bWwsIHByZXZlbnREZWZhdWx0LCBhZGRFdmVudCB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IFRvbU9wdGlvbiwgVG9tSXRlbSB9IGZyb20gJy4uLy4uL3R5cGVzL2luZGV4JztcbmltcG9ydCB7IFJCT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCwgdXNlck9wdGlvbnM6UkJPcHRpb25zKSB7XG5cblx0Y29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0bGFiZWwgICAgIDogJyZ0aW1lczsnLFxuXHRcdFx0dGl0bGUgICAgIDogJ1JlbW92ZScsXG5cdFx0XHRjbGFzc05hbWUgOiAncmVtb3ZlJyxcblx0XHRcdGFwcGVuZCAgICA6IHRydWVcblx0XHR9LCB1c2VyT3B0aW9ucyk7XG5cblxuXHQvL29wdGlvbnMuY2xhc3NOYW1lID0gJ3JlbW92ZS1zaW5nbGUnO1xuXHR2YXIgc2VsZlx0XHRcdD0gdGhpcztcblxuXHQvLyBvdmVycmlkZSB0aGUgcmVuZGVyIG1ldGhvZCB0byBhZGQgcmVtb3ZlIGJ1dHRvbiB0byBlYWNoIGl0ZW1cblx0aWYoICFvcHRpb25zLmFwcGVuZCApe1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBodG1sID0gJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cIicgKyBvcHRpb25zLmNsYXNzTmFtZSArICdcIiB0YWJpbmRleD1cIi0xXCIgdGl0bGU9XCInICsgZXNjYXBlX2h0bWwob3B0aW9ucy50aXRsZSkgKyAnXCI+JyArIG9wdGlvbnMubGFiZWwgKyAnPC9hPic7XG5cblx0c2VsZi5ob29rKCdhZnRlcicsJ3NldHVwVGVtcGxhdGVzJywoKSA9PiB7XG5cblx0XHR2YXIgb3JpZ19yZW5kZXJfaXRlbSA9IHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW07XG5cblx0XHRzZWxmLnNldHRpbmdzLnJlbmRlci5pdGVtID0gKGRhdGE6VG9tT3B0aW9uLCBlc2NhcGU6dHlwZW9mIGVzY2FwZV9odG1sKSA9PiB7XG5cblx0XHRcdHZhciBpdGVtID0gZ2V0RG9tKG9yaWdfcmVuZGVyX2l0ZW0uY2FsbChzZWxmLCBkYXRhLCBlc2NhcGUpKSBhcyBUb21JdGVtO1xuXG5cdFx0XHR2YXIgY2xvc2VfYnV0dG9uID0gZ2V0RG9tKGh0bWwpO1xuXHRcdFx0aXRlbS5hcHBlbmRDaGlsZChjbG9zZV9idXR0b24pO1xuXG5cdFx0XHRhZGRFdmVudChjbG9zZV9idXR0b24sJ21vdXNlZG93bicsKGV2dCkgPT4ge1xuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChldnQsdHJ1ZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0YWRkRXZlbnQoY2xvc2VfYnV0dG9uLCdjbGljaycsKGV2dCkgPT4ge1xuXG5cdFx0XHRcdGlmKCBzZWxmLmlzTG9ja2VkICkgcmV0dXJuO1xuXG5cdFx0XHRcdC8vIHByb3BhZ2F0aW5nIHdpbGwgdHJpZ2dlciB0aGUgZHJvcGRvd24gdG8gc2hvdyBmb3Igc2luZ2xlIG1vZGVcblx0XHRcdFx0cHJldmVudERlZmF1bHQoZXZ0LHRydWUpO1xuXG5cdFx0XHRcdGlmKCBzZWxmLmlzTG9ja2VkICkgcmV0dXJuO1xuXHRcdFx0XHRpZiggIXNlbGYuc2hvdWxkRGVsZXRlKFtpdGVtXSxldnQgYXMgTW91c2VFdmVudCkgKSByZXR1cm47XG5cblx0XHRcdFx0c2VsZi5yZW1vdmVJdGVtKGl0ZW0pO1xuXHRcdFx0XHRzZWxmLnJlZnJlc2hPcHRpb25zKGZhbHNlKTtcblx0XHRcdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fTtcblxuXHR9KTtcblxuXG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcInJlc3RvcmVfb25fYmFja3NwYWNlXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgeyBUb21PcHRpb24gfSBmcm9tICcuLi8uLi90eXBlcy9pbmRleCc7XG5cbnR5cGUgVFBsdWdpbk9wdGlvbnMgPSB7XG5cdHRleHQ/OihvcHRpb246VG9tT3B0aW9uKT0+c3RyaW5nLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QsIHVzZXJPcHRpb25zOlRQbHVnaW5PcHRpb25zKSB7XG5cdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHR0ZXh0OiAob3B0aW9uOlRvbU9wdGlvbikgPT4ge1xuXHRcdFx0cmV0dXJuIG9wdGlvbltzZWxmLnNldHRpbmdzLmxhYmVsRmllbGRdO1xuXHRcdH1cblx0fSx1c2VyT3B0aW9ucyk7XG5cblx0c2VsZi5vbignaXRlbV9yZW1vdmUnLGZ1bmN0aW9uKHZhbHVlOnN0cmluZyl7XG5cdFx0aWYoICFzZWxmLmlzRm9jdXNlZCApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCBzZWxmLmNvbnRyb2xfaW5wdXQudmFsdWUudHJpbSgpID09PSAnJyApe1xuXHRcdFx0dmFyIG9wdGlvbiA9IHNlbGYub3B0aW9uc1t2YWx1ZV07XG5cdFx0XHRpZiggb3B0aW9uICl7XG5cdFx0XHRcdHNlbGYuc2V0VGV4dGJveFZhbHVlKG9wdGlvbnMudGV4dC5jYWxsKHNlbGYsIG9wdGlvbikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwicmVzdG9yZV9vbl9iYWNrc3BhY2VcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgVG9tT3B0aW9uIH0gZnJvbSAnLi4vLi4vdHlwZXMvaW5kZXgnO1xuaW1wb3J0IHsgYWRkQ2xhc3NlcyB9IGZyb20gJy4uLy4uL3ZhbmlsbGEnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCkge1xuXHRjb25zdCBzZWxmXHRcdFx0XHRcdFx0XHQ9IHRoaXM7XG5cdGNvbnN0IG9yaWdfY2FuTG9hZFx0XHRcdFx0XHQ9IHNlbGYuY2FuTG9hZDtcblx0Y29uc3Qgb3JpZ19jbGVhckFjdGl2ZU9wdGlvblx0XHQ9IHNlbGYuY2xlYXJBY3RpdmVPcHRpb247XG5cdGNvbnN0IG9yaWdfbG9hZENhbGxiYWNrXHRcdFx0XHQ9IHNlbGYubG9hZENhbGxiYWNrO1xuXG5cdHZhciBwYWdpbmF0aW9uOntba2V5OnN0cmluZ106YW55fVx0PSB7fTtcblx0dmFyIGRyb3Bkb3duX2NvbnRlbnQ6SFRNTEVsZW1lbnQ7XG5cdHZhciBsb2FkaW5nX21vcmVcdFx0XHRcdFx0PSBmYWxzZTtcblx0dmFyIGxvYWRfbW9yZV9vcHQ6SFRNTEVsZW1lbnQ7XG5cdHZhciBkZWZhdWx0X3ZhbHVlczogc3RyaW5nW11cdFx0PSBbXTtcblxuXHRpZiggIXNlbGYuc2V0dGluZ3Muc2hvdWxkTG9hZE1vcmUgKXtcblxuXHRcdC8vIHJldHVybiB0cnVlIGlmIGFkZGl0aW9uYWwgcmVzdWx0cyBzaG91bGQgYmUgbG9hZGVkXG5cdFx0c2VsZi5zZXR0aW5ncy5zaG91bGRMb2FkTW9yZSA9ICgpOmJvb2xlYW49PntcblxuXHRcdFx0Y29uc3Qgc2Nyb2xsX3BlcmNlbnQgPSBkcm9wZG93bl9jb250ZW50LmNsaWVudEhlaWdodCAvIChkcm9wZG93bl9jb250ZW50LnNjcm9sbEhlaWdodCAtIGRyb3Bkb3duX2NvbnRlbnQuc2Nyb2xsVG9wKTtcblx0XHRcdGlmKCBzY3JvbGxfcGVyY2VudCA+IDAuOSApe1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIHNlbGYuYWN0aXZlT3B0aW9uICl7XG5cdFx0XHRcdHZhciBzZWxlY3RhYmxlXHQ9IHNlbGYuc2VsZWN0YWJsZSgpO1xuXHRcdFx0XHR2YXIgaW5kZXhcdFx0PSBBcnJheS5mcm9tKHNlbGVjdGFibGUpLmluZGV4T2Yoc2VsZi5hY3RpdmVPcHRpb24pO1xuXHRcdFx0XHRpZiggaW5kZXggPj0gKHNlbGVjdGFibGUubGVuZ3RoLTIpICl7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cblx0aWYoICFzZWxmLnNldHRpbmdzLmZpcnN0VXJsICl7XG5cdFx0dGhyb3cgJ3ZpcnR1YWxfc2Nyb2xsIHBsdWdpbiByZXF1aXJlcyBhIGZpcnN0VXJsKCkgbWV0aG9kJztcblx0fVxuXG5cblx0Ly8gaW4gb3JkZXIgZm9yIHZpcnR1YWwgc2Nyb2xsaW5nIHRvIHdvcmssXG5cdC8vIG9wdGlvbnMgbmVlZCB0byBiZSBvcmRlcmVkIHRoZSBzYW1lIHdheSB0aGV5J3JlIHJldHVybmVkIGZyb20gdGhlIHJlbW90ZSBkYXRhIHNvdXJjZVxuXHRzZWxmLnNldHRpbmdzLnNvcnRGaWVsZFx0XHRcdD0gW3tmaWVsZDonJG9yZGVyJ30se2ZpZWxkOickc2NvcmUnfV07XG5cblxuXHQvLyBjYW4gd2UgbG9hZCBtb3JlIHJlc3VsdHMgZm9yIGdpdmVuIHF1ZXJ5P1xuXHRjb25zdCBjYW5Mb2FkTW9yZSA9IChxdWVyeTpzdHJpbmcpOmJvb2xlYW4gPT4ge1xuXG5cdFx0aWYoIHR5cGVvZiBzZWxmLnNldHRpbmdzLm1heE9wdGlvbnMgPT09ICdudW1iZXInICYmIGRyb3Bkb3duX2NvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoID49IHNlbGYuc2V0dGluZ3MubWF4T3B0aW9ucyApe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmKCAocXVlcnkgaW4gcGFnaW5hdGlvbikgJiYgcGFnaW5hdGlvbltxdWVyeV0gKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRjb25zdCBjbGVhckZpbHRlciA9IChvcHRpb246VG9tT3B0aW9uLCB2YWx1ZTpzdHJpbmcpOmJvb2xlYW4gPT4ge1xuXHRcdGlmKCBzZWxmLml0ZW1zLmluZGV4T2YodmFsdWUpID49IDAgfHwgZGVmYXVsdF92YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPj0gMCApe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8vIHNldCB0aGUgbmV4dCB1cmwgdGhhdCB3aWxsIGJlXG5cdHNlbGYuc2V0TmV4dFVybCA9ICh2YWx1ZTpzdHJpbmcsbmV4dF91cmw6YW55KTp2b2lkID0+IHtcblx0XHRwYWdpbmF0aW9uW3ZhbHVlXSA9IG5leHRfdXJsO1xuXHR9O1xuXG5cdC8vIGdldFVybCgpIHRvIGJlIHVzZWQgaW4gc2V0dGluZ3MubG9hZCgpXG5cdHNlbGYuZ2V0VXJsID0gKHF1ZXJ5OnN0cmluZyk6YW55ID0+e1xuXG5cdFx0aWYoIHF1ZXJ5IGluIHBhZ2luYXRpb24gKXtcblx0XHRcdGNvbnN0IG5leHRfdXJsID0gcGFnaW5hdGlvbltxdWVyeV07XG5cdFx0XHRwYWdpbmF0aW9uW3F1ZXJ5XSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIG5leHRfdXJsO1xuXHRcdH1cblxuXHRcdC8vIGlmIHRoZSB1c2VyIGdvZXMgYmFjayB0byBhIHByZXZpb3VzIHF1ZXJ5XG5cdFx0Ly8gd2UgbmVlZCB0byBsb2FkIHRoZSBmaXJzdCBwYWdlIGFnYWluXG5cdFx0c2VsZi5jbGVhclBhZ2luYXRpb24oKTtcblxuXHRcdHJldHVybiBzZWxmLnNldHRpbmdzLmZpcnN0VXJsLmNhbGwoc2VsZixxdWVyeSk7XG5cdH07XG5cblx0Ly8gY2xlYXIgcGFnaW5hdGlvblxuXHRzZWxmLmNsZWFyUGFnaW5hdGlvbiA9ICgpOnZvaWQgPT57XG5cdFx0cGFnaW5hdGlvbiA9IHt9O1xuXHR9O1xuXG5cdC8vIGRvbid0IGNsZWFyIHRoZSBhY3RpdmUgb3B0aW9uIChhbmQgY2F1c2UgdW53YW50ZWQgZHJvcGRvd24gc2Nyb2xsKVxuXHQvLyB3aGlsZSBsb2FkaW5nIG1vcmUgcmVzdWx0c1xuXHRzZWxmLmhvb2soJ2luc3RlYWQnLCdjbGVhckFjdGl2ZU9wdGlvbicsKCk9PntcblxuXHRcdGlmKCBsb2FkaW5nX21vcmUgKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3JpZ19jbGVhckFjdGl2ZU9wdGlvbi5jYWxsKHNlbGYpO1xuXHR9KTtcblxuXHQvLyBvdmVycmlkZSB0aGUgY2FuTG9hZCBtZXRob2Rcblx0c2VsZi5ob29rKCdpbnN0ZWFkJywnY2FuTG9hZCcsKHF1ZXJ5OnN0cmluZyk9PntcblxuXHRcdC8vIGZpcnN0IHRpbWUgdGhlIHF1ZXJ5IGhhcyBiZWVuIHNlZW5cblx0XHRpZiggIShxdWVyeSBpbiBwYWdpbmF0aW9uKSApe1xuXHRcdFx0cmV0dXJuIG9yaWdfY2FuTG9hZC5jYWxsKHNlbGYscXVlcnkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjYW5Mb2FkTW9yZShxdWVyeSk7XG5cdH0pO1xuXG5cblx0Ly8gd3JhcCB0aGUgbG9hZFxuXHRzZWxmLmhvb2soJ2luc3RlYWQnLCdsb2FkQ2FsbGJhY2snLCggb3B0aW9uczpUb21PcHRpb25bXSwgb3B0Z3JvdXBzOlRvbU9wdGlvbltdKT0+e1xuXG5cdFx0aWYoICFsb2FkaW5nX21vcmUgKXtcblx0XHRcdHNlbGYuY2xlYXJPcHRpb25zKGNsZWFyRmlsdGVyKTtcblx0XHR9ZWxzZSBpZiggbG9hZF9tb3JlX29wdCApe1xuXHRcdFx0Y29uc3QgZmlyc3Rfb3B0aW9uID0gb3B0aW9uc1swXTtcblx0XHRcdGlmKCBmaXJzdF9vcHRpb24gIT09IHVuZGVmaW5lZCApe1xuXHRcdFx0XHRsb2FkX21vcmVfb3B0LmRhdGFzZXQudmFsdWVcdFx0PSBmaXJzdF9vcHRpb25bc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvcmlnX2xvYWRDYWxsYmFjay5jYWxsKCBzZWxmLCBvcHRpb25zLCBvcHRncm91cHMpO1xuXG5cdFx0bG9hZGluZ19tb3JlID0gZmFsc2U7XG5cdH0pO1xuXG5cblx0Ly8gYWRkIHRlbXBsYXRlcyB0byBkcm9wZG93blxuXHQvL1x0bG9hZGluZ19tb3JlIGlmIHdlIGhhdmUgYW5vdGhlciB1cmwgaW4gdGhlIHF1ZXVlXG5cdC8vXHRub19tb3JlX3Jlc3VsdHMgaWYgd2UgZG9uJ3QgaGF2ZSBhbm90aGVyIHVybCBpbiB0aGUgcXVldWVcblx0c2VsZi5ob29rKCdhZnRlcicsJ3JlZnJlc2hPcHRpb25zJywoKT0+e1xuXG5cdFx0Y29uc3QgcXVlcnlcdFx0PSBzZWxmLmxhc3RWYWx1ZTtcblx0XHR2YXIgb3B0aW9uO1xuXG5cdFx0aWYoIGNhbkxvYWRNb3JlKHF1ZXJ5KSApe1xuXG5cdFx0XHRvcHRpb24gPSBzZWxmLnJlbmRlcignbG9hZGluZ19tb3JlJyx7cXVlcnk6cXVlcnl9KTtcblx0XHRcdGlmKCBvcHRpb24gKXtcblx0XHRcdFx0b3B0aW9uLnNldEF0dHJpYnV0ZSgnZGF0YS1zZWxlY3RhYmxlJywnJyk7IC8vIHNvIHRoYXQgbmF2aWdhdGluZyBkcm9wZG93biB3aXRoIFtkb3duXSBrZXlwcmVzc2VzIGNhbiBuYXZpZ2F0ZSB0byB0aGlzIG5vZGVcblx0XHRcdFx0bG9hZF9tb3JlX29wdCA9IG9wdGlvbjtcblx0XHRcdH1cblxuXHRcdH1lbHNlIGlmKCAocXVlcnkgaW4gcGFnaW5hdGlvbikgJiYgIWRyb3Bkb3duX2NvbnRlbnQucXVlcnlTZWxlY3RvcignLm5vLXJlc3VsdHMnKSApe1xuXHRcdFx0b3B0aW9uID0gc2VsZi5yZW5kZXIoJ25vX21vcmVfcmVzdWx0cycse3F1ZXJ5OnF1ZXJ5fSk7XG5cdFx0fVxuXG5cdFx0aWYoIG9wdGlvbiApe1xuXHRcdFx0YWRkQ2xhc3NlcyhvcHRpb24sc2VsZi5zZXR0aW5ncy5vcHRpb25DbGFzcyk7XG5cdFx0XHRkcm9wZG93bl9jb250ZW50LmFwcGVuZCggb3B0aW9uICk7XG5cdFx0fVxuXG5cdH0pO1xuXG5cblx0Ly8gYWRkIHNjcm9sbCBsaXN0ZW5lciBhbmQgZGVmYXVsdCB0ZW1wbGF0ZXNcblx0c2VsZi5vbignaW5pdGlhbGl6ZScsKCk9Pntcblx0XHRkZWZhdWx0X3ZhbHVlcyA9IE9iamVjdC5rZXlzKHNlbGYub3B0aW9ucyk7XG5cdFx0ZHJvcGRvd25fY29udGVudCA9IHNlbGYuZHJvcGRvd25fY29udGVudDtcblxuXHRcdC8vIGRlZmF1bHQgdGVtcGxhdGVzXG5cdFx0c2VsZi5zZXR0aW5ncy5yZW5kZXIgPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdFx0XHRsb2FkaW5nX21vcmU6KCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gYDxkaXYgY2xhc3M9XCJsb2FkaW5nLW1vcmUtcmVzdWx0c1wiPkxvYWRpbmcgbW9yZSByZXN1bHRzIC4uLiA8L2Rpdj5gO1xuXHRcdFx0fSxcblx0XHRcdG5vX21vcmVfcmVzdWx0czooKSA9Pntcblx0XHRcdFx0cmV0dXJuIGA8ZGl2IGNsYXNzPVwibm8tbW9yZS1yZXN1bHRzXCI+Tm8gbW9yZSByZXN1bHRzPC9kaXY+YDtcblx0XHRcdH1cblx0XHR9LHNlbGYuc2V0dGluZ3MucmVuZGVyKTtcblxuXG5cdFx0Ly8gd2F0Y2ggZHJvcGRvd24gY29udGVudCBzY3JvbGwgcG9zaXRpb25cblx0XHRkcm9wZG93bl9jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsKCk9PntcblxuXHRcdFx0aWYoICFzZWxmLnNldHRpbmdzLnNob3VsZExvYWRNb3JlLmNhbGwoc2VsZikgKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAhaW1wb3J0YW50OiB0aGlzIHdpbGwgZ2V0IGNoZWNrZWQgYWdhaW4gaW4gbG9hZCgpIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIGhlcmUgb3RoZXJ3aXNlIGxvYWRpbmdfbW9yZSB3aWxsIGJlIHNldCB0byB0cnVlXG5cdFx0XHRpZiggIWNhbkxvYWRNb3JlKHNlbGYubGFzdFZhbHVlKSApe1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRvbid0IGNhbGwgbG9hZCgpIHRvbyBtdWNoXG5cdFx0XHRpZiggbG9hZGluZ19tb3JlICkgcmV0dXJuO1xuXG5cblx0XHRcdGxvYWRpbmdfbW9yZSA9IHRydWU7XG5cdFx0XHRzZWxmLmxvYWQuY2FsbChzZWxmLHNlbGYubGFzdFZhbHVlKTtcblx0XHR9KTtcblx0fSk7XG5cbn07XG4iLCAiaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuL3RvbS1zZWxlY3QnO1xuXG5pbXBvcnQgY2hhbmdlX2xpc3RlbmVyIGZyb20gJy4vcGx1Z2lucy9jaGFuZ2VfbGlzdGVuZXIvcGx1Z2luJztcbmltcG9ydCBjaGVja2JveF9vcHRpb25zIGZyb20gJy4vcGx1Z2lucy9jaGVja2JveF9vcHRpb25zL3BsdWdpbic7XG5pbXBvcnQgY2xlYXJfYnV0dG9uIGZyb20gJy4vcGx1Z2lucy9jbGVhcl9idXR0b24vcGx1Z2luJztcbmltcG9ydCBkcmFnX2Ryb3AgZnJvbSAnLi9wbHVnaW5zL2RyYWdfZHJvcC9wbHVnaW4nO1xuaW1wb3J0IGRyb3Bkb3duX2hlYWRlciBmcm9tICcuL3BsdWdpbnMvZHJvcGRvd25faGVhZGVyL3BsdWdpbic7XG5pbXBvcnQgY2FyZXRfcG9zaXRpb24gZnJvbSAnLi9wbHVnaW5zL2NhcmV0X3Bvc2l0aW9uL3BsdWdpbic7XG5pbXBvcnQgZHJvcGRvd25faW5wdXQgZnJvbSAnLi9wbHVnaW5zL2Ryb3Bkb3duX2lucHV0L3BsdWdpbic7XG5pbXBvcnQgaW5wdXRfYXV0b2dyb3cgZnJvbSAnLi9wbHVnaW5zL2lucHV0X2F1dG9ncm93L3BsdWdpbic7XG5pbXBvcnQgbm9fYmFja3NwYWNlX2RlbGV0ZSBmcm9tICcuL3BsdWdpbnMvbm9fYmFja3NwYWNlX2RlbGV0ZS9wbHVnaW4nO1xuaW1wb3J0IG5vX2FjdGl2ZV9pdGVtcyBmcm9tICcuL3BsdWdpbnMvbm9fYWN0aXZlX2l0ZW1zL3BsdWdpbic7XG5pbXBvcnQgb3B0Z3JvdXBfY29sdW1ucyBmcm9tICcuL3BsdWdpbnMvb3B0Z3JvdXBfY29sdW1ucy9wbHVnaW4nO1xuaW1wb3J0IHJlbW92ZV9idXR0b24gZnJvbSAnLi9wbHVnaW5zL3JlbW92ZV9idXR0b24vcGx1Z2luJztcbmltcG9ydCByZXN0b3JlX29uX2JhY2tzcGFjZSBmcm9tICcuL3BsdWdpbnMvcmVzdG9yZV9vbl9iYWNrc3BhY2UvcGx1Z2luJztcbmltcG9ydCB2aXJ0dWFsX3Njcm9sbCBmcm9tICcuL3BsdWdpbnMvdmlydHVhbF9zY3JvbGwvcGx1Z2luJztcblxuVG9tU2VsZWN0LmRlZmluZSgnY2hhbmdlX2xpc3RlbmVyJywgY2hhbmdlX2xpc3RlbmVyKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2NoZWNrYm94X29wdGlvbnMnLCBjaGVja2JveF9vcHRpb25zKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2NsZWFyX2J1dHRvbicsIGNsZWFyX2J1dHRvbik7XG5Ub21TZWxlY3QuZGVmaW5lKCdkcmFnX2Ryb3AnLCBkcmFnX2Ryb3ApO1xuVG9tU2VsZWN0LmRlZmluZSgnZHJvcGRvd25faGVhZGVyJywgZHJvcGRvd25faGVhZGVyKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2NhcmV0X3Bvc2l0aW9uJywgY2FyZXRfcG9zaXRpb24pO1xuVG9tU2VsZWN0LmRlZmluZSgnZHJvcGRvd25faW5wdXQnLCBkcm9wZG93bl9pbnB1dCk7XG5Ub21TZWxlY3QuZGVmaW5lKCdpbnB1dF9hdXRvZ3JvdycsIGlucHV0X2F1dG9ncm93KTtcblRvbVNlbGVjdC5kZWZpbmUoJ25vX2JhY2tzcGFjZV9kZWxldGUnLCBub19iYWNrc3BhY2VfZGVsZXRlKTtcblRvbVNlbGVjdC5kZWZpbmUoJ25vX2FjdGl2ZV9pdGVtcycsIG5vX2FjdGl2ZV9pdGVtcyk7XG5Ub21TZWxlY3QuZGVmaW5lKCdvcHRncm91cF9jb2x1bW5zJywgb3B0Z3JvdXBfY29sdW1ucyk7XG5Ub21TZWxlY3QuZGVmaW5lKCdyZW1vdmVfYnV0dG9uJywgcmVtb3ZlX2J1dHRvbik7XG5Ub21TZWxlY3QuZGVmaW5lKCdyZXN0b3JlX29uX2JhY2tzcGFjZScsIHJlc3RvcmVfb25fYmFja3NwYWNlKTtcblRvbVNlbGVjdC5kZWZpbmUoJ3ZpcnR1YWxfc2Nyb2xsJywgdmlydHVhbF9zY3JvbGwpO1xuXG5leHBvcnQgZGVmYXVsdCBUb21TZWxlY3Q7XG4iLCAiLyoqXHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKiB0b3BiYXIgMS4wLjAsIDIwMjEtMDEtMDZcclxuICogaHR0cHM6Ly9idXVuZ3V5ZW4uZ2l0aHViLmlvL3RvcGJhclxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgQnV1IE5ndXllblxyXG4gKi9cclxuKGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50KSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXHJcbiAgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBsYXN0VGltZSA9IDA7XHJcbiAgICB2YXIgdmVuZG9ycyA9IFtcIm1zXCIsIFwibW96XCIsIFwid2Via2l0XCIsIFwib1wiXTtcclxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xyXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cclxuICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xyXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPVxyXG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiXSB8fFxyXG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XHJcbiAgICB9XHJcbiAgICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXHJcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcclxuICAgICAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xyXG4gICAgICAgIH0sIHRpbWVUb0NhbGwpO1xyXG4gICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgICAgfTtcclxuICAgIGlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxyXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgICB9O1xyXG4gIH0pKCk7XHJcblxyXG4gIHZhciBjYW52YXMsXHJcbiAgICBwcm9ncmVzc1RpbWVySWQsXHJcbiAgICBmYWRlVGltZXJJZCxcclxuICAgIGN1cnJlbnRQcm9ncmVzcyxcclxuICAgIHNob3dpbmcsXHJcbiAgICBhZGRFdmVudCA9IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBoYW5kbGVyKSB7XHJcbiAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgIGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIGVsZW0uYXR0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgaGFuZGxlcik7XHJcbiAgICAgIGVsc2UgZWxlbVtcIm9uXCIgKyB0eXBlXSA9IGhhbmRsZXI7XHJcbiAgICB9LFxyXG4gICAgb3B0aW9ucyA9IHtcclxuICAgICAgYXV0b1J1bjogdHJ1ZSxcclxuICAgICAgYmFyVGhpY2tuZXNzOiAzLFxyXG4gICAgICBiYXJDb2xvcnM6IHtcclxuICAgICAgICAwOiBcInJnYmEoMjYsICAxODgsIDE1NiwgLjkpXCIsXHJcbiAgICAgICAgXCIuMjVcIjogXCJyZ2JhKDUyLCAgMTUyLCAyMTksIC45KVwiLFxyXG4gICAgICAgIFwiLjUwXCI6IFwicmdiYSgyNDEsIDE5NiwgMTUsICAuOSlcIixcclxuICAgICAgICBcIi43NVwiOiBcInJnYmEoMjMwLCAxMjYsIDM0LCAgLjkpXCIsXHJcbiAgICAgICAgXCIxLjBcIjogXCJyZ2JhKDIxMSwgODQsICAwLCAgIC45KVwiLFxyXG4gICAgICB9LFxyXG4gICAgICBzaGFkb3dCbHVyOiAxMCxcclxuICAgICAgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAgIDAsICAgMCwgICAuNilcIixcclxuICAgICAgY2xhc3NOYW1lOiBudWxsLFxyXG4gICAgfSxcclxuICAgIHJlcGFpbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5iYXJUaGlja25lc3MgKiA1OyAvLyBuZWVkIHNwYWNlIGZvciBzaGFkb3dcclxuXHJcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IG9wdGlvbnMuc2hhZG93Qmx1cjtcclxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gb3B0aW9ucy5zaGFkb3dDb2xvcjtcclxuXHJcbiAgICAgIHZhciBsaW5lR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgY2FudmFzLndpZHRoLCAwKTtcclxuICAgICAgZm9yICh2YXIgc3RvcCBpbiBvcHRpb25zLmJhckNvbG9ycylcclxuICAgICAgICBsaW5lR3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIG9wdGlvbnMuYmFyQ29sb3JzW3N0b3BdKTtcclxuICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xyXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgIGN0eC5tb3ZlVG8oMCwgb3B0aW9ucy5iYXJUaGlja25lc3MgLyAyKTtcclxuICAgICAgY3R4LmxpbmVUbyhcclxuICAgICAgICBNYXRoLmNlaWwoY3VycmVudFByb2dyZXNzICogY2FudmFzLndpZHRoKSxcclxuICAgICAgICBvcHRpb25zLmJhclRoaWNrbmVzcyAvIDJcclxuICAgICAgKTtcclxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGluZUdyYWRpZW50O1xyXG4gICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICB2YXIgc3R5bGUgPSBjYW52YXMuc3R5bGU7XHJcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xyXG4gICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gc3R5bGUucmlnaHQgPSBzdHlsZS5tYXJnaW4gPSBzdHlsZS5wYWRkaW5nID0gMDtcclxuICAgICAgc3R5bGUuekluZGV4ID0gMTAwMDAxO1xyXG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgIGlmIChvcHRpb25zLmNsYXNzTmFtZSkgY2FudmFzLmNsYXNzTGlzdC5hZGQob3B0aW9ucy5jbGFzc05hbWUpO1xyXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XHJcbiAgICAgIGFkZEV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgcmVwYWludCk7XHJcbiAgICB9LFxyXG4gICAgdG9wYmFyID0ge1xyXG4gICAgICBjb25maWc6IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpXHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBvcHRpb25zW2tleV0gPSBvcHRzW2tleV07XHJcbiAgICAgIH0sXHJcbiAgICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoc2hvd2luZykgcmV0dXJuO1xyXG4gICAgICAgIHNob3dpbmcgPSB0cnVlO1xyXG4gICAgICAgIGlmIChmYWRlVGltZXJJZCAhPT0gbnVsbCkgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGZhZGVUaW1lcklkKTtcclxuICAgICAgICBpZiAoIWNhbnZhcykgY3JlYXRlQ2FudmFzKCk7XHJcbiAgICAgICAgY2FudmFzLnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gICAgICAgIHRvcGJhci5wcm9ncmVzcygwKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5hdXRvUnVuKSB7XHJcbiAgICAgICAgICAoZnVuY3Rpb24gbG9vcCgpIHtcclxuICAgICAgICAgICAgcHJvZ3Jlc3NUaW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcclxuICAgICAgICAgICAgdG9wYmFyLnByb2dyZXNzKFxyXG4gICAgICAgICAgICAgIFwiK1wiICsgMC4wNSAqIE1hdGgucG93KDEgLSBNYXRoLnNxcnQoY3VycmVudFByb2dyZXNzKSwgMilcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBwcm9ncmVzczogZnVuY3Rpb24gKHRvKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGN1cnJlbnRQcm9ncmVzcztcclxuICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICB0byA9XHJcbiAgICAgICAgICAgICh0by5pbmRleE9mKFwiK1wiKSA+PSAwIHx8IHRvLmluZGV4T2YoXCItXCIpID49IDBcclxuICAgICAgICAgICAgICA/IGN1cnJlbnRQcm9ncmVzc1xyXG4gICAgICAgICAgICAgIDogMCkgKyBwYXJzZUZsb2F0KHRvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFByb2dyZXNzID0gdG8gPiAxID8gMSA6IHRvO1xyXG4gICAgICAgIHJlcGFpbnQoKTtcclxuICAgICAgICByZXR1cm4gY3VycmVudFByb2dyZXNzO1xyXG4gICAgICB9LFxyXG4gICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFzaG93aW5nKSByZXR1cm47XHJcbiAgICAgICAgc2hvd2luZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChwcm9ncmVzc1RpbWVySWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHByb2dyZXNzVGltZXJJZCk7XHJcbiAgICAgICAgICBwcm9ncmVzc1RpbWVySWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoZnVuY3Rpb24gbG9vcCgpIHtcclxuICAgICAgICAgIGlmICh0b3BiYXIucHJvZ3Jlc3MoXCIrLjFcIikgPj0gMSkge1xyXG4gICAgICAgICAgICBjYW52YXMuc3R5bGUub3BhY2l0eSAtPSAwLjA1O1xyXG4gICAgICAgICAgICBpZiAoY2FudmFzLnN0eWxlLm9wYWNpdHkgPD0gMC4wNSkge1xyXG4gICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgICAgZmFkZVRpbWVySWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZmFkZVRpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gdG9wYmFyO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0b3BiYXI7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy50b3BiYXIgPSB0b3BiYXI7XHJcbiAgfVxyXG59LmNhbGwodGhpcywgd2luZG93LCBkb2N1bWVudCkpO1xyXG4iLCAiLyohXG4gKiBDaGFydC5qcyB2My45LjFcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMiBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbihnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5DaGFydCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuY29uc3QgdWlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaWQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlkKys7XG4gIH07XG59KCkpO1xuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHR5cGUuc2xpY2UoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnNsaWNlKC02KSA9PT0gJ0FycmF5XScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5jb25zdCBpc051bWJlckZpbml0ZSA9ICh2YWx1ZSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG5mdW5jdGlvbiBmaW5pdGVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59XG5jb25zdCB0b1BlcmNlbnRhZ2UgPSAodmFsdWUsIGRpbWVuc2lvbikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMFxuICAgIDogdmFsdWUgLyBkaW1lbnNpb247XG5jb25zdCB0b0RpbWVuc2lvbiA9ICh2YWx1ZSwgZGltZW5zaW9uKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogZGltZW5zaW9uXG4gICAgOiArdmFsdWU7XG5mdW5jdGlvbiBjYWxsYmFjayhmbiwgYXJncywgdGhpc0FyZykge1xuICBpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVhY2gobG9vcGFibGUsIGZuLCB0aGlzQXJnLCByZXZlcnNlKSB7XG4gIGxldCBpLCBsZW4sIGtleXM7XG4gIGlmIChpc0FycmF5KGxvb3BhYmxlKSkge1xuICAgIGxlbiA9IGxvb3BhYmxlLmxlbmd0aDtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobG9vcGFibGUpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGxvb3BhYmxlKTtcbiAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVba2V5c1tpXV0sIGtleXNbaV0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTAsIGExKSB7XG4gIGxldCBpLCBpbGVuLCB2MCwgdjE7XG4gIGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhMC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2MCA9IGEwW2ldO1xuICAgIHYxID0gYTFbaV07XG4gICAgaWYgKHYwLmRhdGFzZXRJbmRleCAhPT0gdjEuZGF0YXNldEluZGV4IHx8IHYwLmluZGV4ICE9PSB2MS5pbmRleCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lJDEoc291cmNlKSB7XG4gIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlLm1hcChjbG9uZSQxKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcbiAgICBmb3IgKDsgayA8IGtsZW47ICsraykge1xuICAgICAgdGFyZ2V0W2tleXNba11dID0gY2xvbmUkMShzb3VyY2Vba2V5c1trXV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5kZXhPZihrZXkpID09PSAtMTtcbn1cbmZ1bmN0aW9uIF9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZSQxKHN2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBzb3VyY2VzID0gaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbWVyZ2VyID0gb3B0aW9ucy5tZXJnZXIgfHwgX21lcmdlcjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgIGlmICghaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIG1lcmdlcihrZXlzW2tdLCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBtZXJnZUlmKHRhcmdldCwgc291cmNlKSB7XG4gIHJldHVybiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwge21lcmdlcjogX21lcmdlcklmfSk7XG59XG5mdW5jdGlvbiBfbWVyZ2VySWYoa2V5LCB0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgbWVyZ2VJZih0dmFsLCBzdmFsKTtcbiAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUkMShzdmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlcHJlY2F0ZWQoc2NvcGUsIHZhbHVlLCBwcmV2aW91cywgY3VycmVudCkge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybihzY29wZSArICc6IFwiJyArIHByZXZpb3VzICtcblx0XHRcdCdcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiJyArIGN1cnJlbnQgKyAnXCIgaW5zdGVhZCcpO1xuICB9XG59XG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gICcnOiB2ID0+IHYsXG4gIHg6IG8gPT4gby54LFxuICB5OiBvID0+IG8ueVxufTtcbmZ1bmN0aW9uIHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpIHtcbiAgY29uc3QgcmVzb2x2ZXIgPSBrZXlSZXNvbHZlcnNba2V5XSB8fCAoa2V5UmVzb2x2ZXJzW2tleV0gPSBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSk7XG4gIHJldHVybiByZXNvbHZlcihvYmopO1xufVxuZnVuY3Rpb24gX2dldEtleVJlc29sdmVyKGtleSkge1xuICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmogJiYgb2JqW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuZnVuY3Rpb24gX3NwbGl0S2V5KGtleSkge1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCBrZXlzID0gW107XG4gIGxldCB0bXAgPSAnJztcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgdG1wICs9IHBhcnQ7XG4gICAgaWYgKHRtcC5lbmRzV2l0aCgnXFxcXCcpKSB7XG4gICAgICB0bXAgPSB0bXAuc2xpY2UoMCwgLTEpICsgJy4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2godG1wKTtcbiAgICAgIHRtcCA9ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuY29uc3QgZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IHNldHNFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSkge1xuICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gX2lzQ2xpY2tFdmVudChlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAnY29udGV4dG1lbnUnO1xufVxuXG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBUQVUgPSAyICogUEk7XG5jb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5jb25zdCBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xuY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5jb25zdCBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcbmNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMDtcbmNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBuaWNlTnVtKHJhbmdlKSB7XG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gIGNvbnN0IG5pY2VSYW5nZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHJhbmdlKSkpO1xuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIG5pY2VSYW5nZTtcbn1cbmZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHtcbiAgICByZXN1bHQucHVzaChzcXJ0KTtcbiAgfVxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuZnVuY3Rpb24gYWxtb3N0RXF1YWxzKHgsIHksIGVwc2lsb24pIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG59XG5mdW5jdGlvbiBhbG1vc3RXaG9sZSh4LCBlcHNpbG9uKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuICByZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XG59XG5mdW5jdGlvbiBfc2V0TWluQW5kTWF4QnlLZXkoYXJyYXksIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJheVtpXVtwcm9wZXJ0eV07XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHRhcmdldC5taW4gPSBNYXRoLm1pbih0YXJnZXQubWluLCB2YWx1ZSk7XG4gICAgICB0YXJnZXQubWF4ID0gTWF0aC5tYXgodGFyZ2V0Lm1heCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gUEkpO1xufVxuZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeCkge1xuICBpZiAoIWlzTnVtYmVyRmluaXRlKHgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBlID0gMTtcbiAgbGV0IHAgPSAwO1xuICB3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG4gICAgZSAqPSAxMDtcbiAgICBwKys7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBnZXRBbmdsZUZyb21Qb2ludChjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuICBjb25zdCBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG4gIGNvbnN0IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcbiAgICBhbmdsZSArPSBUQVU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbmdsZSxcbiAgICBkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG4gIH07XG59XG5mdW5jdGlvbiBkaXN0YW5jZUJldHdlZW5Qb2ludHMocHQxLCBwdDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cbmZ1bmN0aW9uIF9hbmdsZURpZmYoYSwgYikge1xuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplQW5nbGUoYSkge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnQsIGVuZCwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuZnVuY3Rpb24gX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlKSB7XG4gIHJldHVybiBfbGltaXRWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG59XG5mdW5jdGlvbiBfaXNCZXR3ZWVuKHZhbHVlLCBzdGFydCwgZW5kLCBlcHNpbG9uID0gMWUtNikge1xuICByZXR1cm4gdmFsdWUgPj0gTWF0aC5taW4oc3RhcnQsIGVuZCkgLSBlcHNpbG9uICYmIHZhbHVlIDw9IE1hdGgubWF4KHN0YXJ0LCBlbmQpICsgZXBzaWxvbjtcbn1cblxuZnVuY3Rpb24gX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGNtcCkge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkO1xuICB3aGlsZSAoaGkgLSBsbyA+IDEpIHtcbiAgICBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICBpZiAoY21wKG1pZCkpIHtcbiAgICAgIGxvID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuY29uc3QgX2xvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlLCBsYXN0KSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgbGFzdFxuICAgID8gaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPD0gdmFsdWVcbiAgICA6IGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldIDwgdmFsdWUpO1xuY29uc3QgX3Jsb29rdXBCeUtleSA9ICh0YWJsZSwga2V5LCB2YWx1ZSkgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcbmZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlcywgbWluLCBtYXgpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IHZhbHVlcy5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cbiAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoXG4gICAgPyB2YWx1ZXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICA6IHZhbHVlcztcbn1cbmNvbnN0IGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGlmIChhcnJheS5fY2hhcnRqcykge1xuICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xuICAgIGNvbnN0IGJhc2UgPSBhcnJheVtrZXldO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG4gIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcbiAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuZnVuY3Rpb24gX2FycmF5VW5pcXVlKGl0ZW1zKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBzZXQuYWRkKGl0ZW1zW2ldKTtcbiAgfVxuICBpZiAoc2V0LnNpemUgPT09IGlsZW4pIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZnVuY3Rpb24gZm9udFN0cmluZyhwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xuICByZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xufVxuY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpKTtcbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZywgdXBkYXRlRm4pIHtcbiAgY29uc3QgdXBkYXRlQXJncyA9IHVwZGF0ZUZuIHx8ICgoYXJncykgPT4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykpO1xuICBsZXQgdGlja2luZyA9IGZhbHNlO1xuICBsZXQgYXJncyA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24oLi4ucmVzdCkge1xuICAgIGFyZ3MgPSB1cGRhdGVBcmdzKHJlc3QpO1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXksIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IGFsaWduID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbmNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduLCBzdGFydCwgZW5kKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5jb25zdCBfdGV4dFggPSAoYWxpZ24sIGxlZnQsIHJpZ2h0LCBydGwpID0+IHtcbiAgY29uc3QgY2hlY2sgPSBydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xufTtcbmZ1bmN0aW9uIF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuICBpZiAobWV0YS5fc29ydGVkKSB7XG4gICAgY29uc3Qge2lTY2FsZSwgX3BhcnNlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShNYXRoLm1pbihcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtaW4pLmxvLFxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyBwb2ludENvdW50IDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWluKSkubG8pLFxuICAgICAgMCwgcG9pbnRDb3VudCAtIDEpO1xuICAgIH1cbiAgICBpZiAobWF4RGVmaW5lZCkge1xuICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShNYXRoLm1heChcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtYXgsIHRydWUpLmhpICsgMSxcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gMCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1heCksIHRydWUpLmhpICsgMSksXG4gICAgICBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cbmZ1bmN0aW9uIF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xuICBjb25zdCBuZXdSYW5nZXMgPSB7XG4gICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxuICAgIHltaW46IHlTY2FsZS5taW4sXG4gICAgeW1heDogeVNjYWxlLm1heFxuICB9O1xuICBpZiAoIV9zY2FsZVJhbmdlcykge1xuICAgIG1ldGEuX3NjYWxlUmFuZ2VzID0gbmV3UmFuZ2VzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoYW5nZWQgPSBfc2NhbGVSYW5nZXMueG1pbiAhPT0geFNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueW1heCAhPT0geVNjYWxlLm1heDtcbiAgT2JqZWN0LmFzc2lnbihfc2NhbGVSYW5nZXMsIG5ld1Jhbmdlcyk7XG4gIHJldHVybiBjaGFuZ2VkO1xufVxuXG5jbGFzcyBBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdERhdGUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsIHR5cGUpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBhbmltcy5saXN0ZW5lcnNbdHlwZV07XG4gICAgY29uc3QgbnVtU3RlcHMgPSBhbmltcy5kdXJhdGlvbjtcbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XG4gICAgICBjaGFydCxcbiAgICAgIGluaXRpYWw6IGFuaW1zLmluaXRpYWwsXG4gICAgICBudW1TdGVwcyxcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgIH0pKTtcbiAgfVxuICBfcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XG4gICAgdGhpcy5fY2hhcnRzLmZvckVhY2goKGFuaW1zLCBjaGFydCkgPT4ge1xuICAgICAgaWYgKCFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBkcmF3ID0gZmFsc2U7XG4gICAgICBsZXQgaXRlbTtcbiAgICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtLl9hY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgYW5pbXMuZHVyYXRpb24gPSBpdGVtLl90b3RhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbS50aWNrKGRhdGUpO1xuICAgICAgICAgIGRyYXcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1zW2ldID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaXRlbXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNoYXJ0LmRyYXcoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBhbmltcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdjb21wbGV0ZScpO1xuICAgICAgICBhbmltcy5pbml0aWFsID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgKz0gaXRlbXMubGVuZ3RoO1xuICAgIH0pO1xuICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcbiAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9nZXRBbmltcyhjaGFydCkge1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICBsZXQgYW5pbXMgPSBjaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICBhbmltcyA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbXM7XG4gIH1cbiAgbGlzdGVuKGNoYXJ0LCBldmVudCwgY2IpIHtcbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNiKTtcbiAgfVxuICBhZGQoY2hhcnQsIGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5wdXNoKC4uLml0ZW1zKTtcbiAgfVxuICBoYXMoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cbiAgc3RhcnQoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGFuaW1zLmR1cmF0aW9uID0gYW5pbXMuaXRlbXMucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIHJ1bm5pbmcoY2hhcnQpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgfVxuICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gIH1cbiAgcmVtb3ZlKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICB9XG59XG52YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTtcblxuLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjIuMVxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDIyIEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiByb3VuZCh2KSB7XG4gIHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIG4yYih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDI1NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBiMm4odikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgLyAyLjU1KSAvIDEwMCwgMCwgMSk7XG59XG5mdW5jdGlvbiBuMnAodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAxMDApLCAwLCAxMDApO1xufVxuY29uc3QgbWFwJDEgPSB7MDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCwgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSwgQTogMTAsIEI6IDExLCBDOiAxMiwgRDogMTMsIEU6IDE0LCBGOiAxNSwgYTogMTAsIGI6IDExLCBjOiAxMiwgZDogMTMsIGU6IDE0LCBmOiAxNX07XG5jb25zdCBoZXggPSBbLi4uJzAxMjM0NTY3ODlBQkNERUYnXTtcbmNvbnN0IGgxID0gYiA9PiBoZXhbYiAmIDB4Rl07XG5jb25zdCBoMiA9IGIgPT4gaGV4WyhiICYgMHhGMCkgPj4gNF0gKyBoZXhbYiAmIDB4Rl07XG5jb25zdCBlcSA9IGIgPT4gKChiICYgMHhGMCkgPj4gNCkgPT09IChiICYgMHhGKTtcbmNvbnN0IGlzU2hvcnQgPSB2ID0+IGVxKHYucikgJiYgZXEodi5nKSAmJiBlcSh2LmIpICYmIGVxKHYuYSk7XG5mdW5jdGlvbiBoZXhQYXJzZShzdHIpIHtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gIHZhciByZXQ7XG4gIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgIGlmIChsZW4gPT09IDQgfHwgbGVuID09PSA1KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IDI1NSAmIG1hcCQxW3N0clsxXV0gKiAxNyxcbiAgICAgICAgZzogMjU1ICYgbWFwJDFbc3RyWzJdXSAqIDE3LFxuICAgICAgICBiOiAyNTUgJiBtYXAkMVtzdHJbM11dICogMTcsXG4gICAgICAgIGE6IGxlbiA9PT0gNSA/IG1hcCQxW3N0cls0XV0gKiAxNyA6IDI1NVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gNyB8fCBsZW4gPT09IDkpIHtcbiAgICAgIHJldCA9IHtcbiAgICAgICAgcjogbWFwJDFbc3RyWzFdXSA8PCA0IHwgbWFwJDFbc3RyWzJdXSxcbiAgICAgICAgZzogbWFwJDFbc3RyWzNdXSA8PCA0IHwgbWFwJDFbc3RyWzRdXSxcbiAgICAgICAgYjogbWFwJDFbc3RyWzVdXSA8PCA0IHwgbWFwJDFbc3RyWzZdXSxcbiAgICAgICAgYTogbGVuID09PSA5ID8gKG1hcCQxW3N0cls3XV0gPDwgNCB8IG1hcCQxW3N0cls4XV0pIDogMjU1XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuY29uc3QgYWxwaGEgPSAoYSwgZikgPT4gYSA8IDI1NSA/IGYoYSkgOiAnJztcbmZ1bmN0aW9uIGhleFN0cmluZyh2KSB7XG4gIHZhciBmID0gaXNTaG9ydCh2KSA/IGgxIDogaDI7XG4gIHJldHVybiB2XG4gICAgPyAnIycgKyBmKHYucikgKyBmKHYuZykgKyBmKHYuYikgKyBhbHBoYSh2LmEsIGYpXG4gICAgOiB1bmRlZmluZWQ7XG59XG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuICBjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuICByZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuICByZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuICBjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuICBsZXQgaTtcbiAgaWYgKHcgKyBiID4gMSkge1xuICAgIGkgPSAxIC8gKHcgKyBiKTtcbiAgICB3ICo9IGk7XG4gICAgYiAqPSBpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByZ2JbaV0gKj0gMSAtIHcgLSBiO1xuICAgIHJnYltpXSArPSB3O1xuICB9XG4gIHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpIHtcbiAgaWYgKHIgPT09IG1heCkge1xuICAgIHJldHVybiAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApO1xuICB9XG4gIGlmIChnID09PSBtYXgpIHtcbiAgICByZXR1cm4gKGIgLSByKSAvIGQgKyAyO1xuICB9XG4gIHJldHVybiAociAtIGcpIC8gZCArIDQ7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcbiAgY29uc3QgcmFuZ2UgPSAyNTU7XG4gIGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcbiAgY29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuICBjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgbGV0IGgsIHMsIGQ7XG4gIGlmIChtYXggIT09IG1pbikge1xuICAgIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIGggPSBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpO1xuICAgIGggPSBoICogNjAgKyAwLjU7XG4gIH1cbiAgcmV0dXJuIFtoIHwgMCwgcyB8fCAwLCBsXTtcbn1cbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KGEpXG4gICAgICA/IGYoYVswXSwgYVsxXSwgYVsyXSlcbiAgICAgIDogZihhLCBiLCBjKVxuICApLm1hcChuMmIpO1xufVxuZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKSB7XG4gIHJldHVybiBjYWxsbihoc2wycmdibiwgaCwgcywgbCk7XG59XG5mdW5jdGlvbiBod2IycmdiKGgsIHcsIGIpIHtcbiAgcmV0dXJuIGNhbGxuKGh3YjJyZ2JuLCBoLCB3LCBiKTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2IoaCwgcywgdikge1xuICByZXR1cm4gY2FsbG4oaHN2MnJnYm4sIGgsIHMsIHYpO1xufVxuZnVuY3Rpb24gaHVlKGgpIHtcbiAgcmV0dXJuIChoICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIGh1ZVBhcnNlKHN0cikge1xuICBjb25zdCBtID0gSFVFX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCB2O1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bNV0gIT09IHYpIHtcbiAgICBhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xuICB9XG4gIGNvbnN0IGggPSBodWUoK21bMl0pO1xuICBjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xuICBjb25zdCBwMiA9ICttWzRdIC8gMTAwO1xuICBpZiAobVsxXSA9PT0gJ2h3YicpIHtcbiAgICB2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2UgaWYgKG1bMV0gPT09ICdoc3YnKSB7XG4gICAgdiA9IGhzdjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICB2ID0gaHNsMnJnYihoLCBwMSwgcDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcjogdlswXSxcbiAgICBnOiB2WzFdLFxuICAgIGI6IHZbMl0sXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcm90YXRlKHYsIGRlZykge1xuICB2YXIgaCA9IHJnYjJoc2wodik7XG4gIGhbMF0gPSBodWUoaFswXSArIGRlZyk7XG4gIGggPSBoc2wycmdiKGgpO1xuICB2LnIgPSBoWzBdO1xuICB2LmcgPSBoWzFdO1xuICB2LmIgPSBoWzJdO1xufVxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcbiAgaWYgKCF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSByZ2IyaHNsKHYpO1xuICBjb25zdCBoID0gYVswXTtcbiAgY29uc3QgcyA9IG4ycChhWzFdKTtcbiAgY29uc3QgbCA9IG4ycChhWzJdKTtcbiAgcmV0dXJuIHYuYSA8IDI1NVxuICAgID8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXG4gICAgOiBgaHNsKCR7aH0sICR7c30lLCAke2x9JSlgO1xufVxuY29uc3QgbWFwJDIgPSB7XG4gIHg6ICdkYXJrJyxcbiAgWjogJ2xpZ2h0JyxcbiAgWTogJ3JlJyxcbiAgWDogJ2JsdScsXG4gIFc6ICdncicsXG4gIFY6ICdtZWRpdW0nLFxuICBVOiAnc2xhdGUnLFxuICBBOiAnZWUnLFxuICBUOiAnb2wnLFxuICBTOiAnb3InLFxuICBCOiAncmEnLFxuICBDOiAnbGF0ZWcnLFxuICBEOiAnaWdodHMnLFxuICBSOiAnaW4nLFxuICBROiAndHVycXVvaXMnLFxuICBFOiAnaGknLFxuICBQOiAncm8nLFxuICBPOiAnYWwnLFxuICBOOiAnbGUnLFxuICBNOiAnZGUnLFxuICBMOiAneWVsbG8nLFxuICBGOiAnZW4nLFxuICBLOiAnY2gnLFxuICBHOiAnYXJrcycsXG4gIEg6ICdlYScsXG4gIEk6ICdpZ2h0ZycsXG4gIEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuICBPaWNlWGU6ICdmMGY4ZmYnLFxuICBhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG4gIGFxdWE6ICdmZmZmJyxcbiAgYXF1YW1hclJlOiAnN2ZmZmQ0JyxcbiAgYXp1WTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwJyxcbiAgYmxhbktlZE9tb25kOiAnZmZlYmNkJyxcbiAgWGU6ICdmZicsXG4gIFhldmlUZXQ6ICc4YTJiZTInLFxuICBiUHduOiAnYTUyYTJhJyxcbiAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgY2FNdFhlOiAnNWY5ZWEwJyxcbiAgS2FydFl1c2U6ICc3ZmZmMDAnLFxuICBLb2NUYXRlOiAnZDI2OTFlJyxcbiAgY1NPOiAnZmY3ZjUwJyxcbiAgY1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuICBjU25zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICdmZmZmJyxcbiAgeFhlOiAnOGInLFxuICB4Y3lhbjogJzhiOGInLFxuICB4Z1RNblBkOiAnYjg4NjBiJyxcbiAgeFdheTogJ2E5YTlhOScsXG4gIHhnWUY6ICc2NDAwJyxcbiAgeGdZeTogJ2E5YTlhOScsXG4gIHhraGFraTogJ2JkYjc2YicsXG4gIHhtYWdGdGE6ICc4YjAwOGInLFxuICB4VGl2ZWdZRjogJzU1NmIyZicsXG4gIHhTYW5nZTogJ2ZmOGMwMCcsXG4gIHhTY0VkOiAnOTkzMmNjJyxcbiAgeFlkOiAnOGIwMDAwJyxcbiAgeHNPbW9uOiAnZTk5NjdhJyxcbiAgeHNIZ1lGOiAnOGZiYzhmJyxcbiAgeFVYZTogJzQ4M2Q4YicsXG4gIHhVV2F5OiAnMmY0ZjRmJyxcbiAgeFVnWXk6ICcyZjRmNGYnLFxuICB4UWU6ICdjZWQxJyxcbiAgeHZpVGV0OiAnOTQwMGQzJyxcbiAgZEFwcFJrOiAnZmYxNDkzJyxcbiAgZEFwc2t5WGU6ICdiZmZmJyxcbiAgZGltV2F5OiAnNjk2OTY5JyxcbiAgZGltZ1l5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyWGU6ICcxZTkwZmYnLFxuICBmaVlicmljazogJ2IyMjIyMicsXG4gIGZsU093RXRlOiAnZmZmYWYwJyxcbiAgZm9Zc3RXQW46ICcyMjhiMjInLFxuICBmdUtzaWE6ICdmZjAwZmYnLFxuICBnYVJzYlNvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3RXRlOiAnZjhmOGZmJyxcbiAgZ1RkOiAnZmZkNzAwJyxcbiAgZ1RNblBkOiAnZGFhNTIwJyxcbiAgV2F5OiAnODA4MDgwJyxcbiAgZ1lGOiAnODAwMCcsXG4gIGdZRkx3OiAnYWRmZjJmJyxcbiAgZ1l5OiAnODA4MDgwJyxcbiAgaG9uZXlNdzogJ2YwZmZmMCcsXG4gIGhvdHBSazogJ2ZmNjliNCcsXG4gIFJkaWFuWWQ6ICdjZDVjNWMnLFxuICBSZGlnbzogJzRiMDA4MicsXG4gIGl2U3k6ICdmZmZmZjAnLFxuICBraGFraTogJ2YwZTY4YycsXG4gIGxhdkZNcjogJ2U2ZTZmYScsXG4gIGxhdkZNclhzaDogJ2ZmZjBmNScsXG4gIGxhd25nWUY6ICc3Y2ZjMDAnLFxuICBObW9uY0VmZm9uOiAnZmZmYWNkJyxcbiAgWlhlOiAnYWRkOGU2JyxcbiAgWmNTTzogJ2YwODA4MCcsXG4gIFpjeWFuOiAnZTBmZmZmJyxcbiAgWmdUTW5QZEx3OiAnZmFmYWQyJyxcbiAgWldheTogJ2QzZDNkMycsXG4gIFpnWUY6ICc5MGVlOTAnLFxuICBaZ1l5OiAnZDNkM2QzJyxcbiAgWnBSazogJ2ZmYjZjMScsXG4gIFpzT21vbjogJ2ZmYTA3YScsXG4gIFpzSGdZRjogJzIwYjJhYScsXG4gIFpza3lYZTogJzg3Y2VmYScsXG4gIFpVV2F5OiAnNzc4ODk5JyxcbiAgWlVnWXk6ICc3Nzg4OTknLFxuICBac3RBbFhlOiAnYjBjNGRlJyxcbiAgWkx3OiAnZmZmZmUwJyxcbiAgbGltZTogJ2ZmMDAnLFxuICBsaW1lZ1lGOiAnMzJjZDMyJyxcbiAgbFJGOiAnZmFmMGU2JyxcbiAgbWFnRnRhOiAnZmYwMGZmJyxcbiAgbWFQb246ICc4MDAwMDAnLFxuICBWYXF1YW1hclJlOiAnNjZjZGFhJyxcbiAgVlhlOiAnY2QnLFxuICBWU2NFZDogJ2JhNTVkMycsXG4gIFZwdXJwTjogJzkzNzBkYicsXG4gIFZzSGdZRjogJzNjYjM3MScsXG4gIFZVWGU6ICc3YjY4ZWUnLFxuICBWc3ByUmdnWUY6ICdmYTlhJyxcbiAgVlFlOiAnNDhkMWNjJyxcbiAgVnZpVGV0WWQ6ICdjNzE1ODUnLFxuICBtaWRuaWdodFhlOiAnMTkxOTcwJyxcbiAgbVJ0Y1lhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5UHNlOiAnZmZlNGUxJyxcbiAgbW9jY2FzUjogJ2ZmZTRiNScsXG4gIG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnODAnLFxuICBUZGxhY2U6ICdmZGY1ZTYnLFxuICBUaXZlOiAnODA4MDAwJyxcbiAgVGl2ZWRCYjogJzZiOGUyMycsXG4gIFNhbmdlOiAnZmZhNTAwJyxcbiAgU2FuZ2VZZDogJ2ZmNDUwMCcsXG4gIFNjRWQ6ICdkYTcwZDYnLFxuICBwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuICBwT2VnWUY6ICc5OGZiOTgnLFxuICBwT2VRZTogJ2FmZWVlZScsXG4gIHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuICBwYXBheWF3RXA6ICdmZmVmZDUnLFxuICBwSEtwdWZmOiAnZmZkYWI5JyxcbiAgcGVydTogJ2NkODUzZicsXG4gIHBSazogJ2ZmYzBjYicsXG4gIHBsdW06ICdkZGEwZGQnLFxuICBwb3dNclhlOiAnYjBlMGU2JyxcbiAgcHVycE46ICc4MDAwODAnLFxuICBZYmVjY2FwdXJwTjogJzY2MzM5OScsXG4gIFlkOiAnZmYwMDAwJyxcbiAgUHN5YnJvd246ICdiYzhmOGYnLFxuICBQeU9YZTogJzQxNjllMScsXG4gIHNhZGROYlB3bjogJzhiNDUxMycsXG4gIHNPbW9uOiAnZmE4MDcyJyxcbiAgc2FuZHliUHduOiAnZjRhNDYwJyxcbiAgc0hnWUY6ICcyZThiNTcnLFxuICBzSHNoZWxsOiAnZmZmNWVlJyxcbiAgc2lGbmE6ICdhMDUyMmQnLFxuICBzaWx2ZXI6ICdjMGMwYzAnLFxuICBza3lYZTogJzg3Y2VlYicsXG4gIFVYZTogJzZhNWFjZCcsXG4gIFVXYXk6ICc3MDgwOTAnLFxuICBVZ1l5OiAnNzA4MDkwJyxcbiAgc25vdzogJ2ZmZmFmYScsXG4gIHNwclJnZ1lGOiAnZmY3ZicsXG4gIHN0QWxYZTogJzQ2ODJiNCcsXG4gIHRhbjogJ2QyYjQ4YycsXG4gIHRlTzogJzgwODAnLFxuICB0RXN0TjogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIFFlOiAnNDBlMGQwJyxcbiAgdmlUZXQ6ICdlZTgyZWUnLFxuICBKSHQ6ICdmNWRlYjMnLFxuICB3RXRlOiAnZmZmZmZmJyxcbiAgd0V0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgTHc6ICdmZmZmMDAnLFxuICBMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXAkMik7XG4gIGxldCBpLCBqLCBrLCBvaywgbms7XG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgb2sgPSBuayA9IGtleXNbaV07XG4gICAgZm9yIChqID0gMDsgaiA8IHRrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICBrID0gdGtleXNbal07XG4gICAgICBuayA9IG5rLnJlcGxhY2UoaywgbWFwJDJba10pO1xuICAgIH1cbiAgICBrID0gcGFyc2VJbnQobmFtZXMkMVtva10sIDE2KTtcbiAgICB1bnBhY2tlZFtua10gPSBbayA+PiAxNiAmIDB4RkYsIGsgPj4gOCAmIDB4RkYsIGsgJiAweEZGXTtcbiAgfVxuICByZXR1cm4gdW5wYWNrZWQ7XG59XG5sZXQgbmFtZXM7XG5mdW5jdGlvbiBuYW1lUGFyc2Uoc3RyKSB7XG4gIGlmICghbmFtZXMpIHtcbiAgICBuYW1lcyA9IHVucGFjaygpO1xuICAgIG5hbWVzLnRyYW5zcGFyZW50ID0gWzAsIDAsIDAsIDBdO1xuICB9XG4gIGNvbnN0IGEgPSBuYW1lc1tzdHIudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBhICYmIHtcbiAgICByOiBhWzBdLFxuICAgIGc6IGFbMV0sXG4gICAgYjogYVsyXSxcbiAgICBhOiBhLmxlbmd0aCA9PT0gNCA/IGFbM10gOiAyNTVcbiAgfTtcbn1cbmNvbnN0IFJHQl9SRSA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBSR0JfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHIsIGcsIGI7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs3XSAhPT0gcikge1xuICAgIGNvbnN0IHYgPSArbVs3XTtcbiAgICBhID0gbVs4XSA/IHAyYih2KSA6IGxpbSh2ICogMjU1LCAwLCAyNTUpO1xuICB9XG4gIHIgPSArbVsxXTtcbiAgZyA9ICttWzNdO1xuICBiID0gK21bNV07XG4gIHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IGxpbShyLCAwLCAyNTUpKTtcbiAgZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogbGltKGcsIDAsIDI1NSkpO1xuICBiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBsaW0oYiwgMCwgMjU1KSk7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHYgJiYgKFxuICAgIHYuYSA8IDI1NVxuICAgICAgPyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG4gICAgICA6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG4gICk7XG59XG5jb25zdCB0byA9IHYgPT4gdiA8PSAwLjAwMzEzMDggPyB2ICogMTIuOTIgOiBNYXRoLnBvdyh2LCAxLjAgLyAyLjQpICogMS4wNTUgLSAwLjA1NTtcbmNvbnN0IGZyb20gPSB2ID0+IHYgPD0gMC4wNDA0NSA/IHYgLyAxMi45MiA6IE1hdGgucG93KCh2ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSQxKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cbmZ1bmN0aW9uIG1vZEhTTCh2LCBpLCByYXRpbykge1xuICBpZiAodikge1xuICAgIGxldCB0bXAgPSByZ2IyaHNsKHYpO1xuICAgIHRtcFtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRtcFtpXSArIHRtcFtpXSAqIHJhdGlvLCBpID09PSAwID8gMzYwIDogMSkpO1xuICAgIHRtcCA9IGhzbDJyZ2IodG1wKTtcbiAgICB2LnIgPSB0bXBbMF07XG4gICAgdi5nID0gdG1wWzFdO1xuICAgIHYuYiA9IHRtcFsyXTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmUodiwgcHJvdG8pIHtcbiAgcmV0dXJuIHYgPyBPYmplY3QuYXNzaWduKHByb3RvIHx8IHt9LCB2KSA6IHY7XG59XG5mdW5jdGlvbiBmcm9tT2JqZWN0KGlucHV0KSB7XG4gIHZhciB2ID0ge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDI1NX07XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPj0gMykge1xuICAgICAgdiA9IHtyOiBpbnB1dFswXSwgZzogaW5wdXRbMV0sIGI6IGlucHV0WzJdLCBhOiAyNTV9O1xuICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgdi5hID0gbjJiKGlucHV0WzNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdiA9IGNsb25lKGlucHV0LCB7cjogMCwgZzogMCwgYjogMCwgYTogMX0pO1xuICAgIHYuYSA9IG4yYih2LmEpO1xuICB9XG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25QYXJzZShzdHIpIHtcbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICdyJykge1xuICAgIHJldHVybiByZ2JQYXJzZShzdHIpO1xuICB9XG4gIHJldHVybiBodWVQYXJzZShzdHIpO1xufVxuY2xhc3MgQ29sb3Ige1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG4gICAgbGV0IHY7XG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2ID0gZnJvbU9iamVjdChpbnB1dCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdiA9IGhleFBhcnNlKGlucHV0KSB8fCBuYW1lUGFyc2UoaW5wdXQpIHx8IGZ1bmN0aW9uUGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aGlzLl9yZ2IgPSB2O1xuICAgIHRoaXMuX3ZhbGlkID0gISF2O1xuICB9XG4gIGdldCB2YWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gIH1cbiAgZ2V0IHJnYigpIHtcbiAgICB2YXIgdiA9IGNsb25lKHRoaXMuX3JnYik7XG4gICAgaWYgKHYpIHtcbiAgICAgIHYuYSA9IGIybih2LmEpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuICBzZXQgcmdiKG9iaikge1xuICAgIHRoaXMuX3JnYiA9IGZyb21PYmplY3Qob2JqKTtcbiAgfVxuICByZ2JTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gcmdiU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhleFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIGhzbFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoc2xTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBtaXgoY29sb3IsIHdlaWdodCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgY29uc3QgYzEgPSB0aGlzLnJnYjtcbiAgICAgIGNvbnN0IGMyID0gY29sb3IucmdiO1xuICAgICAgbGV0IHcyO1xuICAgICAgY29uc3QgcCA9IHdlaWdodCA9PT0gdzIgPyAwLjUgOiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3ID0gMiAqIHAgLSAxO1xuICAgICAgY29uc3QgYSA9IGMxLmEgLSBjMi5hO1xuICAgICAgY29uc3QgdzEgPSAoKHcgKiBhID09PSAtMSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG4gICAgICB3MiA9IDEgLSB3MTtcbiAgICAgIGMxLnIgPSAweEZGICYgdzEgKiBjMS5yICsgdzIgKiBjMi5yICsgMC41O1xuICAgICAgYzEuZyA9IDB4RkYgJiB3MSAqIGMxLmcgKyB3MiAqIGMyLmcgKyAwLjU7XG4gICAgICBjMS5iID0gMHhGRiAmIHcxICogYzEuYiArIHcyICogYzIuYiArIDAuNTtcbiAgICAgIGMxLmEgPSBwICogYzEuYSArICgxIC0gcCkgKiBjMi5hO1xuICAgICAgdGhpcy5yZ2IgPSBjMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW50ZXJwb2xhdGUoY29sb3IsIHQpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuX3JnYiA9IGludGVycG9sYXRlJDEodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG4gIH1cbiAgYWxwaGEoYSkge1xuICAgIHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSAtIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuICAgIHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvcGFxdWVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgKyByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuX3JnYjtcbiAgICB2LnIgPSAyNTUgLSB2LnI7XG4gICAgdi5nID0gMjU1IC0gdi5nO1xuICAgIHYuYiA9IDI1NSAtIHYuYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRhcmtlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm90YXRlKGRlZykge1xuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluZGV4X2VzbShpbnB1dCkge1xuICByZXR1cm4gbmV3IENvbG9yKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBDYW52YXNQYXR0ZXJuXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IGluZGV4X2VzbSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IGluZGV4X2VzbSh2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cblxuY29uc3Qgb3ZlcnJpZGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGdldFNjb3BlJDEobm9kZSwga2V5KSB7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY29uc3Qga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgayA9IGtleXNbaV07XG4gICAgbm9kZSA9IG5vZGVba10gfHwgKG5vZGVba10gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1lcmdlKGdldFNjb3BlJDEocm9vdCwgc2NvcGUpLCB2YWx1ZXMpO1xuICB9XG4gIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsICcnKSwgc2NvcGUpO1xufVxuY2xhc3MgRGVmYXVsdHMge1xuICBjb25zdHJ1Y3RvcihfZGVzY3JpcHRvcnMpIHtcbiAgICB0aGlzLmFuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuYm9yZGVyQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmNvbG9yID0gJyM2NjYnO1xuICAgIHRoaXMuZGF0YXNldHMgPSB7fTtcbiAgICB0aGlzLmRldmljZVBpeGVsUmF0aW8gPSAoY29udGV4dCkgPT4gY29udGV4dC5jaGFydC5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IHt9O1xuICAgIHRoaXMuZXZlbnRzID0gW1xuICAgICAgJ21vdXNlbW92ZScsXG4gICAgICAnbW91c2VvdXQnLFxuICAgICAgJ2NsaWNrJyxcbiAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICd0b3VjaG1vdmUnXG4gICAgXTtcbiAgICB0aGlzLmZvbnQgPSB7XG4gICAgICBmYW1pbHk6IFwiJ0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWZcIixcbiAgICAgIHNpemU6IDEyLFxuICAgICAgc3R5bGU6ICdub3JtYWwnLFxuICAgICAgbGluZUhlaWdodDogMS4yLFxuICAgICAgd2VpZ2h0OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmhvdmVyID0ge307XG4gICAgdGhpcy5ob3ZlckJhY2tncm91bmRDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJCb3JkZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcik7XG4gICAgdGhpcy5ob3ZlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmNvbG9yKTtcbiAgICB0aGlzLmluZGV4QXhpcyA9ICd4JztcbiAgICB0aGlzLmludGVyYWN0aW9uID0ge1xuICAgICAgbW9kZTogJ25lYXJlc3QnLFxuICAgICAgaW50ZXJzZWN0OiB0cnVlLFxuICAgICAgaW5jbHVkZUludmlzaWJsZTogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMubWFpbnRhaW5Bc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgdGhpcy5vbkhvdmVyID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xpY2sgPSBudWxsO1xuICAgIHRoaXMucGFyc2luZyA9IHRydWU7XG4gICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgdGhpcy5yZXNwb25zaXZlID0gdHJ1ZTtcbiAgICB0aGlzLnNjYWxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5zaG93TGluZSA9IHRydWU7XG4gICAgdGhpcy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcCA9IHRydWU7XG4gICAgdGhpcy5kZXNjcmliZShfZGVzY3JpcHRvcnMpO1xuICB9XG4gIHNldChzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICBnZXQoc2NvcGUpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGUkMSh0aGlzLCBzY29wZSk7XG4gIH1cbiAgZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQoZGVzY3JpcHRvcnMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgcm91dGUoc2NvcGUsIG5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKSB7XG4gICAgY29uc3Qgc2NvcGVPYmplY3QgPSBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgdGFyZ2V0U2NvcGUpO1xuICAgIGNvbnN0IHByaXZhdGVOYW1lID0gJ18nICsgbmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzY29wZU9iamVjdCwge1xuICAgICAgW3ByaXZhdGVOYW1lXToge1xuICAgICAgICB2YWx1ZTogc2NvcGVPYmplY3RbbmFtZV0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCBsb2NhbCA9IHRoaXNbcHJpdmF0ZU5hbWVdO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldFNjb3BlT2JqZWN0W3RhcmdldE5hbWVdO1xuICAgICAgICAgIGlmIChpc09iamVjdChsb2NhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQsIGxvY2FsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KGxvY2FsLCB0YXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzW3ByaXZhdGVOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbnZhciBkZWZhdWx0cyA9IG5ldyBEZWZhdWx0cyh7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdldmVudHMnLFxuICBob3Zlcjoge1xuICAgIF9mYWxsYmFjazogJ2ludGVyYWN0aW9uJ1xuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlKSB7XG4gIGxldCBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWUsIG5vZGUsIHBhcmVudFByb3BlcnR5KSB7XG4gIGxldCB2YWx1ZUluUGl4ZWxzO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICB2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuY29uc3QgZ2V0Q29tcHV0ZWRTdHlsZSA9IChlbGVtZW50KSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbmZ1bmN0aW9uIGdldFN0eWxlKGVsLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG59XG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlcywgc3R5bGUsIHN1ZmZpeCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCB1c2VPZmZzZXRQb3MgPSAoeCwgeSwgdGFyZ2V0KSA9PiAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICF0YXJnZXQuc2hhZG93Um9vdCk7XG5mdW5jdGlvbiBnZXRDYW52YXNQb3NpdGlvbihlLCBjYW52YXMpIHtcbiAgY29uc3QgdG91Y2hlcyA9IGUudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gdG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlO1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2U7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2dCwgY2hhcnQpIHtcbiAgaWYgKCduYXRpdmUnIGluIGV2dCkge1xuICAgIHJldHVybiBldnQ7XG4gIH1cbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjaGFydDtcbiAgaWYgKGJvcmRlckJveCkge1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLnJvdW5kKCh4IC0geE9mZnNldCkgLyB3aWR0aCAqIGNhbnZhcy53aWR0aCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKSxcbiAgICB5OiBNYXRoLnJvdW5kKCh5IC0geU9mZnNldCkgLyBoZWlnaHQgKiBjYW52YXMuaGVpZ2h0IC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgbWF4V2lkdGgsIG1heEhlaWdodDtcbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJvcmRlciA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGNvbnRhaW5lclBhZGRpbmcuaGVpZ2h0IC0gY29udGFpbmVyQm9yZGVyLmhlaWdodDtcbiAgICAgIG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhXaWR0aCwgY29udGFpbmVyLCAnY2xpZW50V2lkdGgnKTtcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0IHx8IElORklOSVRZXG4gIH07XG59XG5jb25zdCByb3VuZDEgPSB2ID0+IE1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IG1hcmdpbnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdtYXJnaW4nKTtcbiAgY29uc3QgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heFdpZHRoLCBjYW52YXMsICdjbGllbnRXaWR0aCcpIHx8IElORklOSVRZO1xuICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSBnZXRDb250YWluZXJTaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQpO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY29udGFpbmVyU2l6ZTtcbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICB3aWR0aCA9IHJvdW5kMShNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgsIGNvbnRhaW5lclNpemUubWF4V2lkdGgpKTtcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIGhlaWdodCA9IHJvdW5kMSh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiByZXRpbmFTY2FsZShjaGFydCwgZm9yY2VSYXRpbywgZm9yY2VTdHlsZSkge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAxO1xuICBjb25zdCBkZXZpY2VIZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VXaWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcbiAgY2hhcnQuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0IC8gcGl4ZWxSYXRpbztcbiAgY2hhcnQud2lkdGggPSBkZXZpY2VXaWR0aCAvIHBpeGVsUmF0aW87XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG4gIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGl4ZWxSYXRpb1xuICAgICAgfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0XG4gICAgICB8fCBjYW52YXMud2lkdGggIT09IGRldmljZVdpZHRoKSB7XG4gICAgY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkZXZpY2VIZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gZGV2aWNlV2lkdGg7XG4gICAgY2hhcnQuY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcbmZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCB2YWx1ZSA9IGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuICByZXR1cm4gbWF0Y2hlcyA/ICttYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udCkge1xuICBpZiAoIWZvbnQgfHwgaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cbmZ1bmN0aW9uIF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBzdHJpbmcpIHtcbiAgbGV0IHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcbiAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcbiAgICBnYy5wdXNoKHN0cmluZyk7XG4gIH1cbiAgaWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcbiAgICBsb25nZXN0ID0gdGV4dFdpZHRoO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuZnVuY3Rpb24gX2xvbmdlc3RUZXh0KGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcbiAgY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgbGV0IGRhdGEgPSBjYWNoZS5kYXRhID0gY2FjaGUuZGF0YSB8fCB7fTtcbiAgbGV0IGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcbiAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICBkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcbiAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQ7XG4gIGxldCBsb25nZXN0ID0gMDtcbiAgY29uc3QgaWxlbiA9IGFycmF5T2ZUaGluZ3MubGVuZ3RoO1xuICBsZXQgaSwgaiwgamxlbiwgdGhpbmcsIG5lc3RlZFRoaW5nO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdGhpbmcgPSBhcnJheU9mVGhpbmdzW2ldO1xuICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmIGlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XG4gICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpbmcpKSB7XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gdGhpbmcubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIG5lc3RlZFRoaW5nID0gdGhpbmdbal07XG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuICAgICAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG4gIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgaWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuICAgICAgZGVsZXRlIGRhdGFbZ2NbaV1dO1xuICAgIH1cbiAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuZnVuY3Rpb24gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCB3aWR0aCkge1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcbn1cbmZ1bmN0aW9uIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KSB7XG4gIGN0eCA9IGN0eCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHgsIHkpIHtcbiAgZHJhd1BvaW50TGVnZW5kKGN0eCwgb3B0aW9ucywgeCwgeSwgbnVsbCk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCB3KSB7XG4gIGxldCB0eXBlLCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBjb3JuZXJSYWRpdXMsIHdpZHRoO1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgIHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHgucm90YXRlKHJhZCk7XG4gICAgICBjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHN3aXRjaCAoc3R5bGUpIHtcbiAgZGVmYXVsdDpcbiAgICBpZiAodykge1xuICAgICAgY3R4LmVsbGlwc2UoeCwgeSwgdyAvIDIsIHJhZGl1cywgMCwgMCwgVEFVKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIFRBVSk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAndHJpYW5nbGUnOlxuICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdFJvdW5kZWQnOlxuICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgIHNpemUgPSByYWRpdXMgLSBjb3JuZXJSYWRpdXM7XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgIGN0eC5hcmMoeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIFBJLCByYWQgLSBIQUxGX1BJKTtcbiAgICBjdHguYXJjKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xuICAgIGN0eC5hcmMoeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG4gICAgY3R4LmFyYyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkICsgSEFMRl9QSSwgcmFkICsgUEkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdCc6XG4gICAgaWYgKCFyb3RhdGlvbikge1xuICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogc2l6ZTtcbiAgICAgIGN0eC5yZWN0KHggLSB3aWR0aCwgeSAtIHNpemUsIDIgKiB3aWR0aCwgMiAqIHNpemUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICBjYXNlICdyZWN0Um90JzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdjcm9zc1JvdCc6XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gIGNhc2UgJ2Nyb3NzJzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3N0YXInOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2xpbmUnOlxuICAgIHhPZmZzZXQgPSB3ID8gdyAvIDIgOiBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rhc2gnOlxuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqIHJhZGl1cywgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuICAgIGJyZWFrO1xuICB9XG4gIGN0eC5maWxsKCk7XG4gIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gX2lzUG9pbnRJbkFyZWEocG9pbnQsIGFyZWEsIG1hcmdpbikge1xuICBtYXJnaW4gPSBtYXJnaW4gfHwgMC41O1xuICByZXR1cm4gIWFyZWEgfHwgKHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiZcblx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBtYXJnaW4gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgbWFyZ2luKTtcbn1cbmZ1bmN0aW9uIGNsaXBBcmVhKGN0eCwgYXJlYSkge1xuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdW5jbGlwQXJlYShjdHgpIHtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCwgbW9kZSkge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBpZiAobW9kZSA9PT0gJ21pZGRsZScpIHtcbiAgICBjb25zdCBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHRhcmdldC55KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAnYWZ0ZXInICE9PSAhIWZsaXApIHtcbiAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiBfYmV6aWVyQ3VydmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXApIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXggOiBwcmV2aW91cy5jcDJ4LFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF5IDogcHJldmlvdXMuY3AyeSxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnggOiB0YXJnZXQuY3AxeCxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnkgOiB0YXJnZXQuY3AxeSxcbiAgICB0YXJnZXQueCxcbiAgICB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiByZW5kZXJUZXh0KGN0eCwgdGV4dCwgeCwgeSwgZm9udCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbdGV4dF07XG4gIGNvbnN0IHN0cm9rZSA9IG9wdHMuc3Ryb2tlV2lkdGggPiAwICYmIG9wdHMuc3Ryb2tlQ29sb3IgIT09ICcnO1xuICBsZXQgaSwgbGluZTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xuICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgaWYgKG9wdHMuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0cy5zdHJva2VDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnN0cm9rZVdpZHRoKSkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIH1cbiAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cyk7XG4gICAgeSArPSBmb250LmxpbmVIZWlnaHQ7XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKSB7XG4gIGlmIChvcHRzLnRyYW5zbGF0aW9uKSB7XG4gICAgY3R4LnRyYW5zbGF0ZShvcHRzLnRyYW5zbGF0aW9uWzBdLCBvcHRzLnRyYW5zbGF0aW9uWzFdKTtcbiAgfVxuICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5yb3RhdGlvbikpIHtcbiAgICBjdHgucm90YXRlKG9wdHMucm90YXRpb24pO1xuICB9XG4gIGlmIChvcHRzLmNvbG9yKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3I7XG4gIH1cbiAgaWYgKG9wdHMudGV4dEFsaWduKSB7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduO1xuICB9XG4gIGlmIChvcHRzLnRleHRCYXNlbGluZSkge1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRzLnRleHRCYXNlbGluZTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cykge1xuICBpZiAob3B0cy5zdHJpa2V0aHJvdWdoIHx8IG9wdHMudW5kZXJsaW5lKSB7XG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICBjb25zdCBsZWZ0ID0geCAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgIGNvbnN0IHJpZ2h0ID0geCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcbiAgICBjb25zdCB0b3AgPSB5IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgY29uc3QgeURlY29yYXRpb24gPSBvcHRzLnN0cmlrZXRocm91Z2ggPyAodG9wICsgYm90dG9tKSAvIDIgOiBib3R0b207XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuZGVjb3JhdGlvbldpZHRoIHx8IDI7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LmxpbmVUbyhyaWdodCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjb25zdCB7eCwgeSwgdywgaCwgcmFkaXVzfSA9IHJlY3Q7XG4gIGN0eC5hcmMoeCArIHJhZGl1cy50b3BMZWZ0LCB5ICsgcmFkaXVzLnRvcExlZnQsIHJhZGl1cy50b3BMZWZ0LCAtSEFMRl9QSSwgUEksIHRydWUpO1xuICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xuICBjdHguYXJjKHggKyByYWRpdXMuYm90dG9tTGVmdCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCwgcmFkaXVzLmJvdHRvbUxlZnQsIFBJLCBIQUxGX1BJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGgpO1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdywgeSArIHJhZGl1cy50b3BSaWdodCk7XG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMudG9wUmlnaHQsIHkgKyByYWRpdXMudG9wUmlnaHQsIHJhZGl1cy50b3BSaWdodCwgMCwgLUhBTEZfUEksIHRydWUpO1xuICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzID0gWycnXSwgcm9vdFNjb3BlcyA9IHNjb3BlcywgZmFsbGJhY2ssIGdldFRhcmdldCA9ICgpID0+IHNjb3Blc1swXSkge1xuICBpZiAoIWRlZmluZWQoZmFsbGJhY2spKSB7XG4gICAgZmFsbGJhY2sgPSBfcmVzb2x2ZSgnX2ZhbGxiYWNrJywgc2NvcGVzKTtcbiAgfVxuICBjb25zdCBjYWNoZSA9IHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ09iamVjdCcsXG4gICAgX2NhY2hlYWJsZTogdHJ1ZSxcbiAgICBfc2NvcGVzOiBzY29wZXMsXG4gICAgX3Jvb3RTY29wZXM6IHJvb3RTY29wZXMsXG4gICAgX2ZhbGxiYWNrOiBmYWxsYmFjayxcbiAgICBfZ2V0VGFyZ2V0OiBnZXRUYXJnZXQsXG4gICAgb3ZlcnJpZGU6IChzY29wZSkgPT4gX2NyZWF0ZVJlc29sdmVyKFtzY29wZSwgLi4uc2NvcGVzXSwgcHJlZml4ZXMsIHJvb3RTY29wZXMsIGZhbGxiYWNrKSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7XG4gICAgICBkZWxldGUgc2NvcGVzWzBdW3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHRhcmdldCkpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5fc2NvcGVzWzBdLCBwcm9wKTtcbiAgICB9LFxuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yoc2NvcGVzWzBdKTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpLmluY2x1ZGVzKHByb3ApO1xuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXQuX3N0b3JhZ2UgfHwgKHRhcmdldC5fc3RvcmFnZSA9IGdldFRhcmdldCgpKTtcbiAgICAgIHRhcmdldFtwcm9wXSA9IHN0b3JhZ2VbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gX2F0dGFjaENvbnRleHQocHJveHksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgY29uc3QgY2FjaGUgPSB7XG4gICAgX2NhY2hlYWJsZTogZmFsc2UsXG4gICAgX3Byb3h5OiBwcm94eSxcbiAgICBfY29udGV4dDogY29udGV4dCxcbiAgICBfc3ViUHJveHk6IHN1YlByb3h5LFxuICAgIF9zdGFjazogbmV3IFNldCgpLFxuICAgIF9kZXNjcmlwdG9yczogX2Rlc2NyaXB0b3JzKHByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIHNldENvbnRleHQ6IChjdHgpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5LCBjdHgsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIG92ZXJyaWRlOiAoc2NvcGUpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5Lm92ZXJyaWRlKHNjb3BlKSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIGRlbGV0ZSBwcm94eVtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Ll9kZXNjcmlwdG9ycy5hbGxLZXlzXG4gICAgICAgID8gUmVmbGVjdC5oYXMocHJveHksIHByb3ApID8ge2VudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0gOiB1bmRlZmluZWRcbiAgICAgICAgOiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm94eSwgcHJvcCk7XG4gICAgfSxcbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHByb3h5KTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwcm94eSk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJveHlbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKHByb3h5LCBkZWZhdWx0cyA9IHtzY3JpcHRhYmxlOiB0cnVlLCBpbmRleGFibGU6IHRydWV9KSB7XG4gIGNvbnN0IHtfc2NyaXB0YWJsZSA9IGRlZmF1bHRzLnNjcmlwdGFibGUsIF9pbmRleGFibGUgPSBkZWZhdWx0cy5pbmRleGFibGUsIF9hbGxLZXlzID0gZGVmYXVsdHMuYWxsS2V5c30gPSBwcm94eTtcbiAgcmV0dXJuIHtcbiAgICBhbGxLZXlzOiBfYWxsS2V5cyxcbiAgICBzY3JpcHRhYmxlOiBfc2NyaXB0YWJsZSxcbiAgICBpbmRleGFibGU6IF9pbmRleGFibGUsXG4gICAgaXNTY3JpcHRhYmxlOiBpc0Z1bmN0aW9uKF9zY3JpcHRhYmxlKSA/IF9zY3JpcHRhYmxlIDogKCkgPT4gX3NjcmlwdGFibGUsXG4gICAgaXNJbmRleGFibGU6IGlzRnVuY3Rpb24oX2luZGV4YWJsZSkgPyBfaW5kZXhhYmxlIDogKCkgPT4gX2luZGV4YWJsZVxuICB9O1xufVxuY29uc3QgcmVhZEtleSA9IChwcmVmaXgsIG5hbWUpID0+IHByZWZpeCA/IHByZWZpeCArIF9jYXBpdGFsaXplKG5hbWUpIDogbmFtZTtcbmNvbnN0IG5lZWRzU3ViUmVzb2x2ZXIgPSAocHJvcCwgdmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBwcm9wICE9PSAnYWRhcHRlcnMnICYmXG4gIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsIHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuZnVuY3Rpb24gX2NhY2hlZCh0YXJnZXQsIHByb3AsIHJlc29sdmUpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgfVxuICBjb25zdCB2YWx1ZSA9IHJlc29sdmUoKTtcbiAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgbGV0IHZhbHVlID0gX3Byb3h5W3Byb3BdO1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgJiYgZGVzY3JpcHRvcnMuaXNTY3JpcHRhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgZGVzY3JpcHRvcnMuaXNJbmRleGFibGUpO1xuICB9XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVTY3JpcHRhYmxlKHByb3AsIHZhbHVlLCB0YXJnZXQsIHJlY2VpdmVyKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9zdGFja30gPSB0YXJnZXQ7XG4gIGlmIChfc3RhY2suaGFzKHByb3ApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWN1cnNpb24gZGV0ZWN0ZWQ6ICcgKyBBcnJheS5mcm9tKF9zdGFjaykuam9pbignLT4nKSArICctPicgKyBwcm9wKTtcbiAgfVxuICBfc3RhY2suYWRkKHByb3ApO1xuICB2YWx1ZSA9IHZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGNyZWF0ZVN1YlJlc29sdmVyKF9wcm94eS5fc2NvcGVzLCBfcHJveHksIHByb3AsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGlzSW5kZXhhYmxlKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBpZiAoZGVmaW5lZChfY29udGV4dC5pbmRleCkgJiYgaXNJbmRleGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcbiAgICBjb25zdCBhcnIgPSB2YWx1ZTtcbiAgICBjb25zdCBzY29wZXMgPSBfcHJveHkuX3Njb3Blcy5maWx0ZXIocyA9PiBzICE9PSBhcnIpO1xuICAgIHZhbHVlID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgY29uc3QgcmVzb2x2ZXIgPSBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIF9wcm94eSwgcHJvcCwgaXRlbSk7XG4gICAgICB2YWx1ZS5wdXNoKF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKGZhbGxiYWNrLCBwcm9wLCB2YWx1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcbn1cbmNvbnN0IGdldFNjb3BlID0gKGtleSwgcGFyZW50KSA9PiBrZXkgPT09IHRydWUgPyBwYXJlbnRcbiAgOiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHJlc29sdmVPYmplY3RLZXkocGFyZW50LCBrZXkpIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gYWRkU2NvcGVzKHNldCwgcGFyZW50U2NvcGVzLCBrZXksIHBhcmVudEZhbGxiYWNrLCB2YWx1ZSkge1xuICBmb3IgKGNvbnN0IHBhcmVudCBvZiBwYXJlbnRTY29wZXMpIHtcbiAgICBjb25zdCBzY29wZSA9IGdldFNjb3BlKGtleSwgcGFyZW50KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHNldC5hZGQoc2NvcGUpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2soc2NvcGUuX2ZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmIChkZWZpbmVkKGZhbGxiYWNrKSAmJiBmYWxsYmFjayAhPT0ga2V5ICYmIGZhbGxiYWNrICE9PSBwYXJlbnRGYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gZmFsc2UgJiYgZGVmaW5lZChwYXJlbnRGYWxsYmFjaykgJiYga2V5ICE9PSBwYXJlbnRGYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN1YlJlc29sdmVyKHBhcmVudFNjb3BlcywgcmVzb2x2ZXIsIHByb3AsIHZhbHVlKSB7XG4gIGNvbnN0IHJvb3RTY29wZXMgPSByZXNvbHZlci5fcm9vdFNjb3BlcztcbiAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2socmVzb2x2ZXIuX2ZhbGxiYWNrLCBwcm9wLCB2YWx1ZSk7XG4gIGNvbnN0IGFsbFNjb3BlcyA9IFsuLi5wYXJlbnRTY29wZXMsIC4uLnJvb3RTY29wZXNdO1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIHNldC5hZGQodmFsdWUpO1xuICBsZXQga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgcHJvcCwgZmFsbGJhY2sgfHwgcHJvcCwgdmFsdWUpO1xuICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkZWZpbmVkKGZhbGxiYWNrKSAmJiBmYWxsYmFjayAhPT0gcHJvcCkge1xuICAgIGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfY3JlYXRlUmVzb2x2ZXIoQXJyYXkuZnJvbShzZXQpLCBbJyddLCByb290U2NvcGVzLCBmYWxsYmFjayxcbiAgICAoKSA9PiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKSB7XG4gIHdoaWxlIChrZXkpIHtcbiAgICBrZXkgPSBhZGRTY29wZXMoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AsIHZhbHVlKSB7XG4gIGNvbnN0IHBhcmVudCA9IHJlc29sdmVyLl9nZXRUYXJnZXQoKTtcbiAgaWYgKCEocHJvcCBpbiBwYXJlbnQpKSB7XG4gICAgcGFyZW50W3Byb3BdID0ge307XG4gIH1cbiAgY29uc3QgdGFyZ2V0ID0gcGFyZW50W3Byb3BdO1xuICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgcHJveHkpIHtcbiAgbGV0IHZhbHVlO1xuICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgIHZhbHVlID0gX3Jlc29sdmUocmVhZEtleShwcmVmaXgsIHByb3ApLCBzY29wZXMpO1xuICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpXG4gICAgICAgID8gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBwcm94eSwgcHJvcCwgdmFsdWUpXG4gICAgICAgIDogdmFsdWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfcmVzb2x2ZShrZXksIHNjb3Blcykge1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjb3BlW2tleV07XG4gICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpIHtcbiAgbGV0IGtleXMgPSB0YXJnZXQuX2tleXM7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSB0YXJnZXQuX2tleXMgPSByZXNvbHZlS2V5c0Zyb21BbGxTY29wZXModGFyZ2V0Ll9zY29wZXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3Blcykge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cbmZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7a2V5ID0gJ3InfSA9IHRoaXMuX3BhcnNpbmc7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgIHI6IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIGtleSksIGluZGV4KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuY29uc3QgZ2V0UG9pbnQgPSAocG9pbnRzLCBpKSA9PiBpIDwgcG9pbnRzLmxlbmd0aCAmJiAhcG9pbnRzW2ldLnNraXAgJiYgcG9pbnRzW2ldO1xuY29uc3QgZ2V0VmFsdWVBeGlzID0gKGluZGV4QXhpcykgPT4gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG5mdW5jdGlvbiBzcGxpbmVDdXJ2ZShmaXJzdFBvaW50LCBtaWRkbGVQb2ludCwgYWZ0ZXJQb2ludCwgdCkge1xuICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgY29uc3QgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuICBjb25zdCBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICBjb25zdCBkMTIgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMobmV4dCwgY3VycmVudCk7XG4gIGxldCBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcbiAgbGV0IHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgczEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG4gIGNvbnN0IGZhID0gdCAqIHMwMTtcbiAgY29uc3QgZmIgPSB0ICogczEyO1xuICByZXR1cm4ge1xuICAgIHByZXZpb3VzOiB7XG4gICAgICB4OiBjdXJyZW50LnggLSBmYSAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSAtIGZhICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfSxcbiAgICBuZXh0OiB7XG4gICAgICB4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKSB7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBhbHBoYUssIGJldGFLLCB0YXVLLCBzcXVhcmVkTWFnbml0dWRlLCBwb2ludEN1cnJlbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCB8fCAhcG9pbnRBZnRlcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbG1vc3RFcXVhbHMoZGVsdGFLW2ldLCAwLCBFUFNJTE9OKSkge1xuICAgICAgbUtbaV0gPSBtS1tpICsgMV0gPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGFscGhhSyA9IG1LW2ldIC8gZGVsdGFLW2ldO1xuICAgIGJldGFLID0gbUtbaSArIDFdIC8gZGVsdGFLW2ldO1xuICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgIGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcbiAgICBtS1tpXSA9IGFscGhhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gICAgbUtbaSArIDFdID0gYmV0YUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICB9XG59XG5mdW5jdGlvbiBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgZGVsdGEsIHBvaW50QmVmb3JlLCBwb2ludEN1cnJlbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaVBpeGVsID0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgY29uc3QgdlBpeGVsID0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc107XG4gICAgaWYgKHBvaW50QmVmb3JlKSB7XG4gICAgICBkZWx0YSA9IChpUGl4ZWwgLSBwb2ludEJlZm9yZVtpbmRleEF4aXNdKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMSR7aW5kZXhBeGlzfWBdID0gaVBpeGVsIC0gZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMSR7dmFsdWVBeGlzfWBdID0gdlBpeGVsIC0gZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGRlbHRhID0gKHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIGlQaXhlbCkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDIke2luZGV4QXhpc31gXSA9IGlQaXhlbCArIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDIke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCArIGRlbHRhICogbUtbaV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBkZWx0YUsgPSBBcnJheShwb2ludHNMZW4pLmZpbGwoMCk7XG4gIGNvbnN0IG1LID0gQXJyYXkocG9pbnRzTGVuKTtcbiAgbGV0IGksIHBvaW50QmVmb3JlLCBwb2ludEN1cnJlbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgICAgZGVsdGFLW2ldID0gc2xvcGVEZWx0YSAhPT0gMCA/IChwb2ludEFmdGVyW3ZhbHVlQXhpc10gLSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXSkgLyBzbG9wZURlbHRhIDogMDtcbiAgICB9XG4gICAgbUtbaV0gPSAhcG9pbnRCZWZvcmUgPyBkZWx0YUtbaV1cbiAgICAgIDogIXBvaW50QWZ0ZXIgPyBkZWx0YUtbaSAtIDFdXG4gICAgICA6IChzaWduKGRlbHRhS1tpIC0gMV0pICE9PSBzaWduKGRlbHRhS1tpXSkpID8gMFxuICAgICAgOiAoZGVsdGFLW2kgLSAxXSArIGRlbHRhS1tpXSkgLyAyO1xuICB9XG4gIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG4gIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMpO1xufVxuZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0LCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG59XG5mdW5jdGlvbiBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgaW5BcmVhLCBpbkFyZWFQcmV2O1xuICBsZXQgaW5BcmVhTmV4dCA9IF9pc1BvaW50SW5BcmVhKHBvaW50c1swXSwgYXJlYSk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5BcmVhUHJldiA9IGluQXJlYTtcbiAgICBpbkFyZWEgPSBpbkFyZWFOZXh0O1xuICAgIGluQXJlYU5leHQgPSBpIDwgaWxlbiAtIDEgJiYgX2lzUG9pbnRJbkFyZWEocG9pbnRzW2kgKyAxXSwgYXJlYSk7XG4gICAgaWYgKCFpbkFyZWEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICBpZiAoaW5BcmVhUHJldikge1xuICAgICAgcG9pbnQuY3AxeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AxeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgICBpZiAoaW5BcmVhTmV4dCkge1xuICAgICAgcG9pbnQuY3AyeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AyeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMocG9pbnRzLCBvcHRpb25zLCBhcmVhLCBsb29wLCBpbmRleEF4aXMpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBjb250cm9sUG9pbnRzO1xuICBpZiAob3B0aW9ucy5zcGFuR2Fwcykge1xuICAgIHBvaW50cyA9IHBvaW50cy5maWx0ZXIoKHB0KSA9PiAhcHQuc2tpcCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzLCBpbmRleEF4aXMpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwcmV2ID0gbG9vcCA/IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gOiBwb2ludHNbMF07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29udHJvbFBvaW50cyA9IHNwbGluZUN1cnZlKFxuICAgICAgICBwcmV2LFxuICAgICAgICBwb2ludCxcbiAgICAgICAgcG9pbnRzW01hdGgubWluKGkgKyAxLCBpbGVuIC0gKGxvb3AgPyAwIDogMSkpICUgaWxlbl0sXG4gICAgICAgIG9wdGlvbnMudGVuc2lvblxuICAgICAgKTtcbiAgICAgIHBvaW50LmNwMXggPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLng7XG4gICAgICBwb2ludC5jcDF5ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuICAgICAgcG9pbnQuY3AyeCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuICAgICAgcG9pbnQuY3AyeSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuICAgICAgcHJldiA9IHBvaW50O1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5jYXBCZXppZXJQb2ludHMpIHtcbiAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgfVxufVxuXG5jb25zdCBhdEVkZ2UgPSAodCkgPT4gdCA9PT0gMCB8fCB0ID09PSAxO1xuY29uc3QgZWxhc3RpY0luID0gKHQsIHMsIHApID0+IC0oTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkpO1xuY29uc3QgZWxhc3RpY091dCA9ICh0LCBzLCBwKSA9PiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSArIDE7XG5jb25zdCBlZmZlY3RzID0ge1xuICBsaW5lYXI6IHQgPT4gdCxcbiAgZWFzZUluUXVhZDogdCA9PiB0ICogdCxcbiAgZWFzZU91dFF1YWQ6IHQgPT4gLXQgKiAodCAtIDIpLFxuICBlYXNlSW5PdXRRdWFkOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuICBlYXNlSW5DdWJpYzogdCA9PiB0ICogdCAqIHQsXG4gIGVhc2VPdXRDdWJpYzogdCA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0Q3ViaWM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuICBlYXNlSW5RdWFydDogdCA9PiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVhcnQ6IHQgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuICBlYXNlSW5PdXRRdWFydDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG4gIGVhc2VJblF1aW50OiB0ID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVpbnQ6IHQgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0UXVpbnQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcbiAgZWFzZUluU2luZTogdCA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcbiAgZWFzZU91dFNpbmU6IHQgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuICBlYXNlSW5PdXRTaW5lOiB0ID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuICBlYXNlSW5FeHBvOiB0ID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuICBlYXNlT3V0RXhwbzogdCA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcbiAgZWFzZUluT3V0RXhwbzogdCA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG4gIGVhc2VJbkNpcmM6IHQgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuICBlYXNlT3V0Q2lyYzogdCA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG4gIGVhc2VJbk91dENpcmM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG4gIGVhc2VJbkVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcbiAgZWFzZU91dEVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG4gIGVhc2VJbk91dEVsYXN0aWModCkge1xuICAgIGNvbnN0IHMgPSAwLjExMjU7XG4gICAgY29uc3QgcCA9IDAuNDU7XG4gICAgcmV0dXJuIGF0RWRnZSh0KSA/IHQgOlxuICAgICAgdCA8IDAuNVxuICAgICAgICA/IDAuNSAqIGVsYXN0aWNJbih0ICogMiwgcywgcClcbiAgICAgICAgOiAwLjUgKyAwLjUgKiBlbGFzdGljT3V0KHQgKiAyIC0gMSwgcywgcCk7XG4gIH0sXG4gIGVhc2VJbkJhY2sodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICB9LFxuICBlYXNlT3V0QmFjayh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcbiAgZWFzZUluT3V0QmFjayh0KSB7XG4gICAgbGV0IHMgPSAxLjcwMTU4O1xuICAgIGlmICgodCAvPSAwLjUpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgfVxuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG4gIH0sXG4gIGVhc2VJbkJvdW5jZTogdCA9PiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KSxcbiAgZWFzZU91dEJvdW5jZSh0KSB7XG4gICAgY29uc3QgbSA9IDcuNTYyNTtcbiAgICBjb25zdCBkID0gMi43NTtcbiAgICBpZiAodCA8ICgxIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogdCAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgKDIgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMS41IC8gZCkpICogdCArIDAuNzU7XG4gICAgfVxuICAgIGlmICh0IDwgKDIuNSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgyLjI1IC8gZCkpICogdCArIDAuOTM3NTtcbiAgICB9XG4gICAgcmV0dXJuIG0gKiAodCAtPSAoMi42MjUgLyBkKSkgKiB0ICsgMC45ODQzNzU7XG4gIH0sXG4gIGVhc2VJbk91dEJvdW5jZTogdCA9PiAodCA8IDAuNSlcbiAgICA/IGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNVxuICAgIDogZWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAwLjUsXG59O1xuXG5mdW5jdGlvbiBfcG9pbnRJbkxpbmUocDEsIHAyLCB0LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KVxuICB9O1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBtb2RlID09PSAnbWlkZGxlJyA/IHQgPCAwLjUgPyBwMS55IDogcDIueVxuICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICA6IHQgPiAwID8gcDIueSA6IHAxLnlcbiAgfTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG5cbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChudW0pO1xufVxuXG5jb25zdCBMSU5FX0hFSUdIVCA9IG5ldyBSZWdFeHAoL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8pO1xuY29uc3QgRk9OVF9TVFlMRSA9IG5ldyBSZWdFeHAoL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC8pO1xuZnVuY3Rpb24gdG9MaW5lSGVpZ2h0KHZhbHVlLCBzaXplKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goTElORV9IRUlHSFQpO1xuICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcbiAgICByZXR1cm4gc2l6ZSAqIDEuMjtcbiAgfVxuICB2YWx1ZSA9ICttYXRjaGVzWzJdO1xuICBzd2l0Y2ggKG1hdGNoZXNbM10pIHtcbiAgY2FzZSAncHgnOlxuICAgIHJldHVybiB2YWx1ZTtcbiAgY2FzZSAnJSc6XG4gICAgdmFsdWUgLz0gMTAwO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBzaXplICogdmFsdWU7XG59XG5jb25zdCBudW1iZXJPclplcm8gPSB2ID0+ICt2IHx8IDA7XG5mdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgcHJvcHMpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNvbnN0IG9ialByb3BzID0gaXNPYmplY3QocHJvcHMpO1xuICBjb25zdCBrZXlzID0gb2JqUHJvcHMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcztcbiAgY29uc3QgcmVhZCA9IGlzT2JqZWN0KHZhbHVlKVxuICAgID8gb2JqUHJvcHNcbiAgICAgID8gcHJvcCA9PiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZVtwcm9wXSwgdmFsdWVbcHJvcHNbcHJvcF1dKVxuICAgICAgOiBwcm9wID0+IHZhbHVlW3Byb3BdXG4gICAgOiAoKSA9PiB2YWx1ZTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIGtleXMpIHtcbiAgICByZXRbcHJvcF0gPSBudW1iZXJPclplcm8ocmVhZChwcm9wKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHRvVFJCTCh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHt0b3A6ICd5JywgcmlnaHQ6ICd4JywgYm90dG9tOiAneScsIGxlZnQ6ICd4J30pO1xufVxuZnVuY3Rpb24gdG9UUkJMQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0J10pO1xufVxuZnVuY3Rpb24gdG9QYWRkaW5nKHZhbHVlKSB7XG4gIGNvbnN0IG9iaiA9IHRvVFJCTCh2YWx1ZSk7XG4gIG9iai53aWR0aCA9IG9iai5sZWZ0ICsgb2JqLnJpZ2h0O1xuICBvYmouaGVpZ2h0ID0gb2JqLnRvcCArIG9iai5ib3R0b207XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiB0b0ZvbnQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgZGVmYXVsdHMuZm9udDtcbiAgbGV0IHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnNpemUsIGZhbGxiYWNrLnNpemUpO1xuICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2l6ZSA9IHBhcnNlSW50KHNpemUsIDEwKTtcbiAgfVxuICBsZXQgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnN0eWxlLCBmYWxsYmFjay5zdHlsZSk7XG4gIGlmIChzdHlsZSAmJiAhKCcnICsgc3R5bGUpLm1hdGNoKEZPTlRfU1RZTEUpKSB7XG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGZvbnQgc3R5bGUgc3BlY2lmaWVkOiBcIicgKyBzdHlsZSArICdcIicpO1xuICAgIHN0eWxlID0gJyc7XG4gIH1cbiAgY29uc3QgZm9udCA9IHtcbiAgICBmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZmFtaWx5LCBmYWxsYmFjay5mYW1pbHkpLFxuICAgIGxpbmVIZWlnaHQ6IHRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGZhbGxiYWNrLmxpbmVIZWlnaHQpLCBzaXplKSxcbiAgICBzaXplLFxuICAgIHN0eWxlLFxuICAgIHdlaWdodDogdmFsdWVPckRlZmF1bHQob3B0aW9ucy53ZWlnaHQsIGZhbGxiYWNrLndlaWdodCksXG4gICAgc3RyaW5nOiAnJ1xuICB9O1xuICBmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcbiAgcmV0dXJuIGZvbnQ7XG59XG5mdW5jdGlvbiByZXNvbHZlKGlucHV0cywgY29udGV4dCwgaW5kZXgsIGluZm8pIHtcbiAgbGV0IGNhY2hlYWJsZSA9IHRydWU7XG4gIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IGlucHV0c1tpXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW2luZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xuICAgICAgICBpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2FkZEdyYWNlKG1pbm1heCwgZ3JhY2UsIGJlZ2luQXRaZXJvKSB7XG4gIGNvbnN0IHttaW4sIG1heH0gPSBtaW5tYXg7XG4gIGNvbnN0IGNoYW5nZSA9IHRvRGltZW5zaW9uKGdyYWNlLCAobWF4IC0gbWluKSAvIDIpO1xuICBjb25zdCBrZWVwWmVybyA9ICh2YWx1ZSwgYWRkKSA9PiBiZWdpbkF0WmVybyAmJiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSArIGFkZDtcbiAgcmV0dXJuIHtcbiAgICBtaW46IGtlZXBaZXJvKG1pbiwgLU1hdGguYWJzKGNoYW5nZSkpLFxuICAgIG1heDoga2VlcFplcm8obWF4LCBjaGFuZ2UpXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KHBhcmVudENvbnRleHQsIGNvbnRleHQpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnRDb250ZXh0KSwgY29udGV4dCk7XG59XG5cbmNvbnN0IGdldFJpZ2h0VG9MZWZ0QWRhcHRlciA9IGZ1bmN0aW9uKHJlY3RYLCB3aWR0aCkge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHJlY3RYICsgcmVjdFggKyB3aWR0aCAtIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgICB3aWR0aCA9IHc7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFsaWduO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCAtIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBpdGVtV2lkdGgpIHtcbiAgICAgIHJldHVybiB4IC0gaXRlbVdpZHRoO1xuICAgIH0sXG4gIH07XG59O1xuY29uc3QgZ2V0TGVmdFRvUmlnaHRBZGFwdGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHtcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4ICsgdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIF9pdGVtV2lkdGgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0UnRsQWRhcHRlcihydGwsIHJlY3RYLCB3aWR0aCkge1xuICByZXR1cm4gcnRsID8gZ2V0UmlnaHRUb0xlZnRBZGFwdGVyKHJlY3RYLCB3aWR0aCkgOiBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIoKTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIGRpcmVjdGlvbikge1xuICBsZXQgc3R5bGUsIG9yaWdpbmFsO1xuICBpZiAoZGlyZWN0aW9uID09PSAnbHRyJyB8fCBkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgc3R5bGUgPSBjdHguY2FudmFzLnN0eWxlO1xuICAgIG9yaWdpbmFsID0gW1xuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJyksXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdkaXJlY3Rpb24nKSxcbiAgICBdO1xuICAgIHN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBkaXJlY3Rpb24sICdpbXBvcnRhbnQnKTtcbiAgICBjdHgucHJldlRleHREaXJlY3Rpb24gPSBvcmlnaW5hbDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcmlnaW5hbCkge1xuICBpZiAob3JpZ2luYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSBjdHgucHJldlRleHREaXJlY3Rpb247XG4gICAgY3R4LmNhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgb3JpZ2luYWxbMF0sIG9yaWdpbmFsWzFdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZuKHByb3BlcnR5KSB7XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHJldHVybiB7XG4gICAgICBiZXR3ZWVuOiBfYW5nbGVCZXR3ZWVuLFxuICAgICAgY29tcGFyZTogX2FuZ2xlRGlmZixcbiAgICAgIG5vcm1hbGl6ZTogX25vcm1hbGl6ZUFuZ2xlLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiZXR3ZWVuOiBfaXNCZXR3ZWVuLFxuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhIC0gYixcbiAgICBub3JtYWxpemU6IHggPT4geFxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2VnbWVudCh7c3RhcnQsIGVuZCwgY291bnQsIGxvb3AsIHN0eWxlfSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCAlIGNvdW50LFxuICAgIGVuZDogZW5kICUgY291bnQsXG4gICAgbG9vcDogbG9vcCAmJiAoZW5kIC0gc3RhcnQgKyAxKSAlIGNvdW50ID09PSAwLFxuICAgIHN0eWxlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCB7YmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCB7c3RhcnQsIGVuZCwgbG9vcH0gPSBzZWdtZW50O1xuICBsZXQgaSwgaWxlbjtcbiAgaWYgKGxvb3ApIHtcbiAgICBzdGFydCArPSBjb3VudDtcbiAgICBlbmQgKz0gY291bnQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoIWJldHdlZW4obm9ybWFsaXplKHBvaW50c1tzdGFydCAlIGNvdW50XVtwcm9wZXJ0eV0pLCBzdGFydEJvdW5kLCBlbmRCb3VuZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGFydC0tO1xuICAgICAgZW5kLS07XG4gICAgfVxuICAgIHN0YXJ0ICU9IGNvdW50O1xuICAgIGVuZCAlPSBjb3VudDtcbiAgfVxuICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICBlbmQgKz0gY291bnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZTogc2VnbWVudC5zdHlsZX07XG59XG5mdW5jdGlvbiBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGlmICghYm91bmRzKSB7XG4gICAgcmV0dXJuIFtzZWdtZW50XTtcbiAgfVxuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7Y29tcGFyZSwgYmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGV9ID0gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcyk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gIGxldCBzdWJTdGFydCA9IG51bGw7XG4gIGxldCB2YWx1ZSwgcG9pbnQsIHByZXZWYWx1ZTtcbiAgY29uc3Qgc3RhcnRJc0JlZm9yZSA9ICgpID0+IGJldHdlZW4oc3RhcnRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSkgJiYgY29tcGFyZShzdGFydEJvdW5kLCBwcmV2VmFsdWUpICE9PSAwO1xuICBjb25zdCBlbmRJc0JlZm9yZSA9ICgpID0+IGNvbXBhcmUoZW5kQm91bmQsIHZhbHVlKSA9PT0gMCB8fCBiZXR3ZWVuKGVuZEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKTtcbiAgY29uc3Qgc2hvdWxkU3RhcnQgPSAoKSA9PiBpbnNpZGUgfHwgc3RhcnRJc0JlZm9yZSgpO1xuICBjb25zdCBzaG91bGRTdG9wID0gKCkgPT4gIWluc2lkZSB8fCBlbmRJc0JlZm9yZSgpO1xuICBmb3IgKGxldCBpID0gc3RhcnQsIHByZXYgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW2kgJSBjb3VudF07XG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZShwb2ludFtwcm9wZXJ0eV0pO1xuICAgIGlmICh2YWx1ZSA9PT0gcHJldlZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaW5zaWRlID0gYmV0d2Vlbih2YWx1ZSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpO1xuICAgIGlmIChzdWJTdGFydCA9PT0gbnVsbCAmJiBzaG91bGRTdGFydCgpKSB7XG4gICAgICBzdWJTdGFydCA9IGNvbXBhcmUodmFsdWUsIHN0YXJ0Qm91bmQpID09PSAwID8gaSA6IHByZXY7XG4gICAgfVxuICAgIGlmIChzdWJTdGFydCAhPT0gbnVsbCAmJiBzaG91bGRTdG9wKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kOiBpLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gICAgICBzdWJTdGFydCA9IG51bGw7XG4gICAgfVxuICAgIHByZXYgPSBpO1xuICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGlmIChzdWJTdGFydCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9ib3VuZFNlZ21lbnRzKGxpbmUsIGJvdW5kcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3ViID0gX2JvdW5kU2VnbWVudChzZWdtZW50c1tpXSwgbGluZS5wb2ludHMsIGJvdW5kcyk7XG4gICAgaWYgKHN1Yi5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKC4uLnN1Yik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IGNvdW50IC0gMTtcbiAgaWYgKGxvb3AgJiYgIXNwYW5HYXBzKSB7XG4gICAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgIXBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICBzdGFydCAlPSBjb3VudDtcbiAgaWYgKGxvb3ApIHtcbiAgICBlbmQgKz0gc3RhcnQ7XG4gIH1cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHBvaW50c1tlbmQgJSBjb3VudF0uc2tpcCkge1xuICAgIGVuZC0tO1xuICB9XG4gIGVuZCAlPSBjb3VudDtcbiAgcmV0dXJuIHtzdGFydCwgZW5kfTtcbn1cbmZ1bmN0aW9uIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBsb29wKSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBsYXN0ID0gc3RhcnQ7XG4gIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0XTtcbiAgbGV0IGVuZDtcbiAgZm9yIChlbmQgPSBzdGFydCArIDE7IGVuZCA8PSBtYXg7ICsrZW5kKSB7XG4gICAgY29uc3QgY3VyID0gcG9pbnRzW2VuZCAlIGNvdW50XTtcbiAgICBpZiAoY3VyLnNraXAgfHwgY3VyLnN0b3ApIHtcbiAgICAgIGlmICghcHJldi5za2lwKSB7XG4gICAgICAgIGxvb3AgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IChlbmQgLSAxKSAlIGNvdW50LCBsb29wfSk7XG4gICAgICAgIHN0YXJ0ID0gbGFzdCA9IGN1ci5zdG9wID8gZW5kIDogbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IGVuZDtcbiAgICAgIGlmIChwcmV2LnNraXApIHtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXYgPSBjdXI7XG4gIH1cbiAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogbGFzdCAlIGNvdW50LCBsb29wfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9jb21wdXRlU2VnbWVudHMobGluZSwgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHNwYW5HYXBzID0gbGluZS5vcHRpb25zLnNwYW5HYXBzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgbG9vcCA9ICEhbGluZS5fbG9vcDtcbiAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKTtcbiAgaWYgKHNwYW5HYXBzID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgW3tzdGFydCwgZW5kLCBsb29wfV0sIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IG1heCA9IGVuZCA8IHN0YXJ0ID8gZW5kICsgY291bnQgOiBlbmQ7XG4gIGNvbnN0IGNvbXBsZXRlTG9vcCA9ICEhbGluZS5fZnVsbExvb3AgJiYgc3RhcnQgPT09IDAgJiYgZW5kID09PSBjb3VudCAtIDE7XG4gIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBjb21wbGV0ZUxvb3ApLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHNwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgaWYgKCFzZWdtZW50T3B0aW9ucyB8fCAhc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dCB8fCAhcG9pbnRzKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRzO1xuICB9XG4gIHJldHVybiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGV4dCA9IGxpbmUuX2NoYXJ0LmdldENvbnRleHQoKTtcbiAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XG4gIGNvbnN0IHtfZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXgsIG9wdGlvbnM6IHtzcGFuR2Fwc319ID0gbGluZTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHByZXZTdHlsZSA9IGJhc2VTdHlsZTtcbiAgbGV0IHN0YXJ0ID0gc2VnbWVudHNbMF0uc3RhcnQ7XG4gIGxldCBpID0gc3RhcnQ7XG4gIGZ1bmN0aW9uIGFkZFN0eWxlKHMsIGUsIGwsIHN0KSB7XG4gICAgY29uc3QgZGlyID0gc3BhbkdhcHMgPyAtMSA6IDE7XG4gICAgaWYgKHMgPT09IGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcyArPSBjb3VudDtcbiAgICB3aGlsZSAocG9pbnRzW3MgJSBjb3VudF0uc2tpcCkge1xuICAgICAgcyAtPSBkaXI7XG4gICAgfVxuICAgIHdoaWxlIChwb2ludHNbZSAlIGNvdW50XS5za2lwKSB7XG4gICAgICBlICs9IGRpcjtcbiAgICB9XG4gICAgaWYgKHMgJSBjb3VudCAhPT0gZSAlIGNvdW50KSB7XG4gICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHMgJSBjb3VudCwgZW5kOiBlICUgY291bnQsIGxvb3A6IGwsIHN0eWxlOiBzdH0pO1xuICAgICAgcHJldlN0eWxlID0gc3Q7XG4gICAgICBzdGFydCA9IGUgJSBjb3VudDtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc3RhcnQgPSBzcGFuR2FwcyA/IHN0YXJ0IDogc2VnbWVudC5zdGFydDtcbiAgICBsZXQgcHJldiA9IHBvaW50c1tzdGFydCAlIGNvdW50XTtcbiAgICBsZXQgc3R5bGU7XG4gICAgZm9yIChpID0gc3RhcnQgKyAxOyBpIDw9IHNlZ21lbnQuZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IHB0ID0gcG9pbnRzW2kgJSBjb3VudF07XG4gICAgICBzdHlsZSA9IHJlYWRTdHlsZShzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0KGNyZWF0ZUNvbnRleHQoY2hhcnRDb250ZXh0LCB7XG4gICAgICAgIHR5cGU6ICdzZWdtZW50JyxcbiAgICAgICAgcDA6IHByZXYsXG4gICAgICAgIHAxOiBwdCxcbiAgICAgICAgcDBEYXRhSW5kZXg6IChpIC0gMSkgJSBjb3VudCxcbiAgICAgICAgcDFEYXRhSW5kZXg6IGkgJSBjb3VudCxcbiAgICAgICAgZGF0YXNldEluZGV4XG4gICAgICB9KSkpO1xuICAgICAgaWYgKHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSkge1xuICAgICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByZXYgPSBwdDtcbiAgICAgIHByZXZTdHlsZSA9IHN0eWxlO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPCBpIC0gMSkge1xuICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IG9wdGlvbnMuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yXG4gIH07XG59XG5mdW5jdGlvbiBzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkge1xuICByZXR1cm4gcHJldlN0eWxlICYmIEpTT04uc3RyaW5naWZ5KHN0eWxlKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldlN0eWxlKTtcbn1cblxudmFyIGhlbHBlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5lYXNpbmdFZmZlY3RzOiBlZmZlY3RzLFxuaXNQYXR0ZXJuT3JHcmFkaWVudDogaXNQYXR0ZXJuT3JHcmFkaWVudCxcbmNvbG9yOiBjb2xvcixcbmdldEhvdmVyQ29sb3I6IGdldEhvdmVyQ29sb3IsXG5ub29wOiBub29wLFxudWlkOiB1aWQsXG5pc051bGxPclVuZGVmOiBpc051bGxPclVuZGVmLFxuaXNBcnJheTogaXNBcnJheSxcbmlzT2JqZWN0OiBpc09iamVjdCxcbmlzRmluaXRlOiBpc051bWJlckZpbml0ZSxcbmZpbml0ZU9yRGVmYXVsdDogZmluaXRlT3JEZWZhdWx0LFxudmFsdWVPckRlZmF1bHQ6IHZhbHVlT3JEZWZhdWx0LFxudG9QZXJjZW50YWdlOiB0b1BlcmNlbnRhZ2UsXG50b0RpbWVuc2lvbjogdG9EaW1lbnNpb24sXG5jYWxsYmFjazogY2FsbGJhY2ssXG5lYWNoOiBlYWNoLFxuX2VsZW1lbnRzRXF1YWw6IF9lbGVtZW50c0VxdWFsLFxuY2xvbmU6IGNsb25lJDEsXG5fbWVyZ2VyOiBfbWVyZ2VyLFxubWVyZ2U6IG1lcmdlLFxubWVyZ2VJZjogbWVyZ2VJZixcbl9tZXJnZXJJZjogX21lcmdlcklmLFxuX2RlcHJlY2F0ZWQ6IF9kZXByZWNhdGVkLFxucmVzb2x2ZU9iamVjdEtleTogcmVzb2x2ZU9iamVjdEtleSxcbl9zcGxpdEtleTogX3NwbGl0S2V5LFxuX2NhcGl0YWxpemU6IF9jYXBpdGFsaXplLFxuZGVmaW5lZDogZGVmaW5lZCxcbmlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG5zZXRzRXF1YWw6IHNldHNFcXVhbCxcbl9pc0NsaWNrRXZlbnQ6IF9pc0NsaWNrRXZlbnQsXG50b0ZvbnRTdHJpbmc6IHRvRm9udFN0cmluZyxcbl9tZWFzdXJlVGV4dDogX21lYXN1cmVUZXh0LFxuX2xvbmdlc3RUZXh0OiBfbG9uZ2VzdFRleHQsXG5fYWxpZ25QaXhlbDogX2FsaWduUGl4ZWwsXG5jbGVhckNhbnZhczogY2xlYXJDYW52YXMsXG5kcmF3UG9pbnQ6IGRyYXdQb2ludCxcbmRyYXdQb2ludExlZ2VuZDogZHJhd1BvaW50TGVnZW5kLFxuX2lzUG9pbnRJbkFyZWE6IF9pc1BvaW50SW5BcmVhLFxuY2xpcEFyZWE6IGNsaXBBcmVhLFxudW5jbGlwQXJlYTogdW5jbGlwQXJlYSxcbl9zdGVwcGVkTGluZVRvOiBfc3RlcHBlZExpbmVUbyxcbl9iZXppZXJDdXJ2ZVRvOiBfYmV6aWVyQ3VydmVUbyxcbnJlbmRlclRleHQ6IHJlbmRlclRleHQsXG5hZGRSb3VuZGVkUmVjdFBhdGg6IGFkZFJvdW5kZWRSZWN0UGF0aCxcbl9sb29rdXA6IF9sb29rdXAsXG5fbG9va3VwQnlLZXk6IF9sb29rdXBCeUtleSxcbl9ybG9va3VwQnlLZXk6IF9ybG9va3VwQnlLZXksXG5fZmlsdGVyQmV0d2VlbjogX2ZpbHRlckJldHdlZW4sXG5saXN0ZW5BcnJheUV2ZW50czogbGlzdGVuQXJyYXlFdmVudHMsXG51bmxpc3RlbkFycmF5RXZlbnRzOiB1bmxpc3RlbkFycmF5RXZlbnRzLFxuX2FycmF5VW5pcXVlOiBfYXJyYXlVbmlxdWUsXG5fY3JlYXRlUmVzb2x2ZXI6IF9jcmVhdGVSZXNvbHZlcixcbl9hdHRhY2hDb250ZXh0OiBfYXR0YWNoQ29udGV4dCxcbl9kZXNjcmlwdG9yczogX2Rlc2NyaXB0b3JzLFxuX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlOiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUsXG5zcGxpbmVDdXJ2ZTogc3BsaW5lQ3VydmUsXG5zcGxpbmVDdXJ2ZU1vbm90b25lOiBzcGxpbmVDdXJ2ZU1vbm90b25lLFxuX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHM6IF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzLFxuX2lzRG9tU3VwcG9ydGVkOiBfaXNEb21TdXBwb3J0ZWQsXG5fZ2V0UGFyZW50Tm9kZTogX2dldFBhcmVudE5vZGUsXG5nZXRTdHlsZTogZ2V0U3R5bGUsXG5nZXRSZWxhdGl2ZVBvc2l0aW9uOiBnZXRSZWxhdGl2ZVBvc2l0aW9uLFxuZ2V0TWF4aW11bVNpemU6IGdldE1heGltdW1TaXplLFxucmV0aW5hU2NhbGU6IHJldGluYVNjYWxlLFxuc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9uczogc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyxcbnJlYWRVc2VkU2l6ZTogcmVhZFVzZWRTaXplLFxuZm9udFN0cmluZzogZm9udFN0cmluZyxcbnJlcXVlc3RBbmltRnJhbWU6IHJlcXVlc3RBbmltRnJhbWUsXG50aHJvdHRsZWQ6IHRocm90dGxlZCxcbmRlYm91bmNlOiBkZWJvdW5jZSxcbl90b0xlZnRSaWdodENlbnRlcjogX3RvTGVmdFJpZ2h0Q2VudGVyLFxuX2FsaWduU3RhcnRFbmQ6IF9hbGlnblN0YXJ0RW5kLFxuX3RleHRYOiBfdGV4dFgsXG5fZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50czogX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsXG5fc2NhbGVSYW5nZXNDaGFuZ2VkOiBfc2NhbGVSYW5nZXNDaGFuZ2VkLFxuX3BvaW50SW5MaW5lOiBfcG9pbnRJbkxpbmUsXG5fc3RlcHBlZEludGVycG9sYXRpb246IF9zdGVwcGVkSW50ZXJwb2xhdGlvbixcbl9iZXppZXJJbnRlcnBvbGF0aW9uOiBfYmV6aWVySW50ZXJwb2xhdGlvbixcbmZvcm1hdE51bWJlcjogZm9ybWF0TnVtYmVyLFxudG9MaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQsXG5fcmVhZFZhbHVlVG9Qcm9wczogX3JlYWRWYWx1ZVRvUHJvcHMsXG50b1RSQkw6IHRvVFJCTCxcbnRvVFJCTENvcm5lcnM6IHRvVFJCTENvcm5lcnMsXG50b1BhZGRpbmc6IHRvUGFkZGluZyxcbnRvRm9udDogdG9Gb250LFxucmVzb2x2ZTogcmVzb2x2ZSxcbl9hZGRHcmFjZTogX2FkZEdyYWNlLFxuY3JlYXRlQ29udGV4dDogY3JlYXRlQ29udGV4dCxcblBJOiBQSSxcblRBVTogVEFVLFxuUElUQVU6IFBJVEFVLFxuSU5GSU5JVFk6IElORklOSVRZLFxuUkFEX1BFUl9ERUc6IFJBRF9QRVJfREVHLFxuSEFMRl9QSTogSEFMRl9QSSxcblFVQVJURVJfUEk6IFFVQVJURVJfUEksXG5UV09fVEhJUkRTX1BJOiBUV09fVEhJUkRTX1BJLFxubG9nMTA6IGxvZzEwLFxuc2lnbjogc2lnbixcbm5pY2VOdW06IG5pY2VOdW0sXG5fZmFjdG9yaXplOiBfZmFjdG9yaXplLFxuaXNOdW1iZXI6IGlzTnVtYmVyLFxuYWxtb3N0RXF1YWxzOiBhbG1vc3RFcXVhbHMsXG5hbG1vc3RXaG9sZTogYWxtb3N0V2hvbGUsXG5fc2V0TWluQW5kTWF4QnlLZXk6IF9zZXRNaW5BbmRNYXhCeUtleSxcbnRvUmFkaWFuczogdG9SYWRpYW5zLFxudG9EZWdyZWVzOiB0b0RlZ3JlZXMsXG5fZGVjaW1hbFBsYWNlczogX2RlY2ltYWxQbGFjZXMsXG5nZXRBbmdsZUZyb21Qb2ludDogZ2V0QW5nbGVGcm9tUG9pbnQsXG5kaXN0YW5jZUJldHdlZW5Qb2ludHM6IGRpc3RhbmNlQmV0d2VlblBvaW50cyxcbl9hbmdsZURpZmY6IF9hbmdsZURpZmYsXG5fbm9ybWFsaXplQW5nbGU6IF9ub3JtYWxpemVBbmdsZSxcbl9hbmdsZUJldHdlZW46IF9hbmdsZUJldHdlZW4sXG5fbGltaXRWYWx1ZTogX2xpbWl0VmFsdWUsXG5faW50MTZSYW5nZTogX2ludDE2UmFuZ2UsXG5faXNCZXR3ZWVuOiBfaXNCZXR3ZWVuLFxuZ2V0UnRsQWRhcHRlcjogZ2V0UnRsQWRhcHRlcixcbm92ZXJyaWRlVGV4dERpcmVjdGlvbjogb3ZlcnJpZGVUZXh0RGlyZWN0aW9uLFxucmVzdG9yZVRleHREaXJlY3Rpb246IHJlc3RvcmVUZXh0RGlyZWN0aW9uLFxuX2JvdW5kU2VnbWVudDogX2JvdW5kU2VnbWVudCxcbl9ib3VuZFNlZ21lbnRzOiBfYm91bmRTZWdtZW50cyxcbl9jb21wdXRlU2VnbWVudHM6IF9jb21wdXRlU2VnbWVudHNcbn0pO1xuXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2gobWV0YXNldCwgYXhpcywgdmFsdWUsIGludGVyc2VjdCkge1xuICBjb25zdCB7Y29udHJvbGxlciwgZGF0YSwgX3NvcnRlZH0gPSBtZXRhc2V0O1xuICBjb25zdCBpU2NhbGUgPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhLmlTY2FsZTtcbiAgaWYgKGlTY2FsZSAmJiBheGlzID09PSBpU2NhbGUuYXhpcyAmJiBheGlzICE9PSAncicgJiYgX3NvcnRlZCAmJiBkYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGxvb2t1cE1ldGhvZCA9IGlTY2FsZS5fcmV2ZXJzZVBpeGVscyA/IF9ybG9va3VwQnlLZXkgOiBfbG9va3VwQnlLZXk7XG4gICAgaWYgKCFpbnRlcnNlY3QpIHtcbiAgICAgIHJldHVybiBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgLSByYW5nZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge2xvOiAwLCBoaTogZGF0YS5sZW5ndGggLSAxfTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGhhbmRsZXIsIGludGVyc2VjdCkge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltheGlzXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCB7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV07XG4gICAgY29uc3Qge2xvLCBoaX0gPSBiaW5hcnlTZWFyY2gobWV0YXNldHNbaV0sIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpO1xuICAgIGZvciAobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcbiAgY29uc3QgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcbiAgY29uc3QgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcbiAgICBjb25zdCBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgY29uc3QgZXZhbHVhdGlvbkZ1bmMgPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFfaXNQb2ludEluQXJlYShlbGVtZW50LCBjaGFydC5jaGFydEFyZWEsIDApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH07XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jLCB0cnVlKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZX0gPSBlbGVtZW50LmdldFByb3BzKFsnc3RhcnRBbmdsZScsICdlbmRBbmdsZSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGV9ID0gZ2V0QW5nbGVGcm9tUG9pbnQoZWxlbWVudCwge3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnl9KTtcbiAgICBpZiAoX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBjb25zdCBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKTtcbiAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgaW5SYW5nZSA9IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBpZiAoaW50ZXJzZWN0ICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgcG9pbnRJbkFyZWEgPSAhIWluY2x1ZGVJbnZpc2libGUgfHwgY2hhcnQuaXNQb2ludEluQXJlYShjZW50ZXIpO1xuICAgIGlmICghcG9pbnRJbkFyZWEgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcbiAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMgPSBbe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9XTtcbiAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gYXhpcyA9PT0gJ3InICYmICFpbnRlcnNlY3RcbiAgICA/IGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pXG4gICAgOiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHJhbmdlTWV0aG9kID0gYXhpcyA9PT0gJ3gnID8gJ2luWFJhbmdlJyA6ICdpbllSYW5nZSc7XG4gIGxldCBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCAoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkgPT4ge1xuICAgIGlmIChlbGVtZW50W3JhbmdlTWV0aG9kXShwb3NpdGlvbltheGlzXSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICAgIGludGVyc2VjdHNJdGVtID0gaW50ZXJzZWN0c0l0ZW0gfHwgZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfSk7XG4gIGlmIChpbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cbnZhciBJbnRlcmFjdGlvbiA9IHtcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zLFxuICBtb2Rlczoge1xuICAgIGluZGV4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgY29uc3QgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSlcbiAgICAgICAgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmZvckVhY2goKG1ldGEpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpdGVtc1swXS5pbmRleDtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG1ldGEuZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChlbGVtZW50ICYmICFlbGVtZW50LnNraXApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXgsIGluZGV4fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sXG4gICAgZGF0YXNldChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBsZXQgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkgOlxuICAgICAgICBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0SW5kZXggPSBpdGVtc1swXS5kYXRhc2V0SW5kZXg7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmRhdGE7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQ6IGRhdGFbaV0sIGRhdGFzZXRJbmRleCwgaW5kZXg6IGl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG4gICAgcG9pbnQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcbiAgICBuZWFyZXN0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcbiAgICB4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd4Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH0sXG4gICAgeShjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneScsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IFNUQVRJQ19QT1NJVElPTlMgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5mdW5jdGlvbiBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMoYXJyYXksIGF4aXMpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IFNUQVRJQ19QT1NJVElPTlMuaW5kZXhPZih2LnBvcykgPT09IC0xICYmIHYuYm94LmF4aXMgPT09IGF4aXMpO1xufVxuZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XG4gIHJldHVybiBhcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgdjAgPSByZXZlcnNlID8gYiA6IGE7XG4gICAgY29uc3QgdjEgPSByZXZlcnNlID8gYSA6IGI7XG4gICAgcmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cbiAgICAgIHYwLmluZGV4IC0gdjEuaW5kZXggOlxuICAgICAgdjAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IChib3hlcyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgYm94ID0gYm94ZXNbaV07XG4gICAgKHtwb3NpdGlvbjogcG9zLCBvcHRpb25zOiB7c3RhY2ssIHN0YWNrV2VpZ2h0ID0gMX19ID0gYm94KTtcbiAgICBsYXlvdXRCb3hlcy5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgYm94LFxuICAgICAgcG9zLFxuICAgICAgaG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxuICAgICAgd2VpZ2h0OiBib3gud2VpZ2h0LFxuICAgICAgc3RhY2s6IHN0YWNrICYmIChwb3MgKyBzdGFjayksXG4gICAgICBzdGFja1dlaWdodFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsYXlvdXRCb3hlcztcbn1cbmZ1bmN0aW9uIGJ1aWxkU3RhY2tzKGxheW91dHMpIHtcbiAgY29uc3Qgc3RhY2tzID0ge307XG4gIGZvciAoY29uc3Qgd3JhcCBvZiBsYXlvdXRzKSB7XG4gICAgY29uc3Qge3N0YWNrLCBwb3MsIHN0YWNrV2VpZ2h0fSA9IHdyYXA7XG4gICAgaWYgKCFzdGFjayB8fCAhU1RBVElDX1BPU0lUSU9OUy5pbmNsdWRlcyhwb3MpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgX3N0YWNrID0gc3RhY2tzW3N0YWNrXSB8fCAoc3RhY2tzW3N0YWNrXSA9IHtjb3VudDogMCwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDAsIHNpemU6IDB9KTtcbiAgICBfc3RhY2suY291bnQrKztcbiAgICBfc3RhY2sud2VpZ2h0ICs9IHN0YWNrV2VpZ2h0O1xuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuICBjb25zdCBzdGFja3MgPSBidWlsZFN0YWNrcyhsYXlvdXRzKTtcbiAgY29uc3Qge3ZCb3hNYXhXaWR0aCwgaEJveE1heEhlaWdodH0gPSBwYXJhbXM7XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGxheW91dHNbaV07XG4gICAgY29uc3Qge2Z1bGxTaXplfSA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcbiAgICBjb25zdCBmYWN0b3IgPSBzdGFjayAmJiBsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQ7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gaEJveE1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGZhY3RvciA/IGZhY3RvciAqIGhCb3hNYXhIZWlnaHQgOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlSGVpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IHdyYXBCb3hlcyhib3hlcyk7XG4gIGNvbnN0IGZ1bGxTaXplID0gc29ydEJ5V2VpZ2h0KGxheW91dEJveGVzLmZpbHRlcih3cmFwID0+IHdyYXAuYm94LmZ1bGxTaXplKSwgdHJ1ZSk7XG4gIGNvbnN0IGxlZnQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2xlZnQnKSwgdHJ1ZSk7XG4gIGNvbnN0IHJpZ2h0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdyaWdodCcpKTtcbiAgY29uc3QgdG9wID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICd0b3AnKSwgdHJ1ZSk7XG4gIGNvbnN0IGJvdHRvbSA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnYm90dG9tJykpO1xuICBjb25zdCBjZW50ZXJIb3Jpem9udGFsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneCcpO1xuICBjb25zdCBjZW50ZXJWZXJ0aWNhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3knKTtcbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCBhLCBiKSB7XG4gIHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94UGFkZGluZykge1xuICBtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XG4gIG1heFBhZGRpbmcubGVmdCA9IE1hdGgubWF4KG1heFBhZGRpbmcubGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcbiAgbWF4UGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuICBtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG59XG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGlmICghaXNPYmplY3QocG9zKSkge1xuICAgIGlmIChsYXlvdXQuc2l6ZSkge1xuICAgICAgY2hhcnRBcmVhW3Bvc10gLT0gbGF5b3V0LnNpemU7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge3NpemU6IDAsIGNvdW50OiAxfTtcbiAgICBzdGFjay5zaXplID0gTWF0aC5tYXgoc3RhY2suc2l6ZSwgbGF5b3V0Lmhvcml6b250YWwgPyBib3guaGVpZ2h0IDogYm94LndpZHRoKTtcbiAgICBsYXlvdXQuc2l6ZSA9IHN0YWNrLnNpemUgLyBzdGFjay5jb3VudDtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBsYXlvdXQuc2l6ZTtcbiAgfVxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG4gIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJykpO1xuICBjb25zdCB3aWR0aENoYW5nZWQgPSBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLnc7XG4gIGNvbnN0IGhlaWdodENoYW5nZWQgPSBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xuICBjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xuICBjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcbiAgcmV0dXJuIGxheW91dC5ob3Jpem9udGFsXG4gICAgPyB7c2FtZTogd2lkdGhDaGFuZ2VkLCBvdGhlcjogaGVpZ2h0Q2hhbmdlZH1cbiAgICA6IHtzYW1lOiBoZWlnaHRDaGFuZ2VkLCBvdGhlcjogd2lkdGhDaGFuZ2VkfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuICAgIGNvbnN0IGNoYW5nZSA9IE1hdGgubWF4KG1heFBhZGRpbmdbcG9zXSAtIGNoYXJ0QXJlYVtwb3NdLCAwKTtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICBjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xuICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcbiAgdXBkYXRlUG9zKCdyaWdodCcpO1xuICB1cGRhdGVQb3MoJ2JvdHRvbScpO1xufVxuZnVuY3Rpb24gZ2V0TWFyZ2lucyhob3Jpem9udGFsLCBjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG4gIHJldHVybiBob3Jpem9udGFsXG4gICAgPyBtYXJnaW5Gb3JQb3NpdGlvbnMoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xufVxuZnVuY3Rpb24gZml0Qm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgcmVmaXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0LCBib3gsIHJlZml0LCBjaGFuZ2VkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuICAgIGJveC51cGRhdGUoXG4gICAgICBsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXG4gICAgICBsYXlvdXQuaGVpZ2h0IHx8IGNoYXJ0QXJlYS5oLFxuICAgICAgZ2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKVxuICAgICk7XG4gICAgY29uc3Qge3NhbWUsIG90aGVyfSA9IHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKTtcbiAgICByZWZpdCB8PSBzYW1lICYmIHJlZml0Qm94ZXMubGVuZ3RoO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuICAgIGlmICghYm94LmZ1bGxTaXplKSB7XG4gICAgICByZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZml0ICYmIGZpdEJveGVzKHJlZml0Qm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHx8IGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcbiAgbGV0IHt4LCB5fSA9IGNoYXJ0QXJlYTtcbiAgZm9yIChjb25zdCBsYXlvdXQgb2YgYm94ZXMpIHtcbiAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge2NvdW50OiAxLCBwbGFjZWQ6IDAsIHdlaWdodDogMX07XG4gICAgY29uc3Qgd2VpZ2h0ID0gKGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodCkgfHwgMTtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gY2hhcnRBcmVhLncgKiB3ZWlnaHQ7XG4gICAgICBjb25zdCBoZWlnaHQgPSBzdGFjay5zaXplIHx8IGJveC5oZWlnaHQ7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeSA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgdXNlclBhZGRpbmcubGVmdCwgeSwgcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCAtIHVzZXJQYWRkaW5nLmxlZnQsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgY2hhcnRBcmVhLmxlZnQgKyBzdGFjay5wbGFjZWQsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB5O1xuICAgICAgc3RhY2sucGxhY2VkICs9IHdpZHRoO1xuICAgICAgeSA9IGJveC5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNoYXJ0QXJlYS5oICogd2VpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSBzdGFjay5zaXplIHx8IGJveC53aWR0aDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB4ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCB1c2VyUGFkZGluZy50b3AsIHdpZHRoLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSB1c2VyUGFkZGluZy5ib3R0b20gLSB1c2VyUGFkZGluZy50b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIGNoYXJ0QXJlYS50b3AgKyBzdGFjay5wbGFjZWQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB4O1xuICAgICAgc3RhY2sucGxhY2VkICs9IGhlaWdodDtcbiAgICAgIHggPSBib3gucmlnaHQ7XG4gICAgfVxuICB9XG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gIGF1dG9QYWRkaW5nOiB0cnVlLFxuICBwYWRkaW5nOiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH1cbn0pO1xudmFyIGxheW91dHMgPSB7XG4gIGFkZEJveChjaGFydCwgaXRlbSkge1xuICAgIGlmICghY2hhcnQuYm94ZXMpIHtcbiAgICAgIGNoYXJ0LmJveGVzID0gW107XG4gICAgfVxuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICBpdGVtLl9sYXllcnMgPSBpdGVtLl9sYXllcnMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogMCxcbiAgICAgICAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICAgICAgICBpdGVtLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfTtcbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuICByZW1vdmVCb3goY2hhcnQsIGxheW91dEl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcoY2hhcnQub3B0aW9ucy5sYXlvdXQucGFkZGluZyk7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIHBhZGRpbmcud2lkdGgsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcbiAgICBjb25zdCBib3hlcyA9IGJ1aWxkTGF5b3V0Qm94ZXMoY2hhcnQuYm94ZXMpO1xuICAgIGNvbnN0IHZlcnRpY2FsQm94ZXMgPSBib3hlcy52ZXJ0aWNhbDtcbiAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHZpc2libGVWZXJ0aWNhbEJveENvdW50ID0gdmVydGljYWxCb3hlcy5yZWR1Y2UoKHRvdGFsLCB3cmFwKSA9PlxuICAgICAgd3JhcC5ib3gub3B0aW9ucyAmJiB3cmFwLmJveC5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlID8gdG90YWwgOiB0b3RhbCArIDEsIDApIHx8IDE7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBvdXRlcldpZHRoOiB3aWR0aCxcbiAgICAgIG91dGVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICBwYWRkaW5nLFxuICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZpc2libGVWZXJ0aWNhbEJveENvdW50LFxuICAgICAgaEJveE1heEhlaWdodDogYXZhaWxhYmxlSGVpZ2h0IC8gMlxuICAgIH0pO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBwYWRkaW5nKTtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIHRvUGFkZGluZyhtaW5QYWRkaW5nKSk7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtYXhQYWRkaW5nLFxuICAgICAgdzogYXZhaWxhYmxlV2lkdGgsXG4gICAgICBoOiBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB4OiBwYWRkaW5nLmxlZnQsXG4gICAgICB5OiBwYWRkaW5nLnRvcFxuICAgIH0sIHBhZGRpbmcpO1xuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcbiAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIH1cbiAgICBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSk7XG4gICAgcGxhY2VCb3hlcyhib3hlcy5sZWZ0QW5kVG9wLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcbiAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydC5jaGFydEFyZWEgPSB7XG4gICAgICBsZWZ0OiBjaGFydEFyZWEubGVmdCxcbiAgICAgIHRvcDogY2hhcnRBcmVhLnRvcCxcbiAgICAgIHJpZ2h0OiBjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS53LFxuICAgICAgYm90dG9tOiBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0QXJlYS5oLFxuICAgICAgd2lkdGg6IGNoYXJ0QXJlYS53LFxuICAgIH07XG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmNsYXNzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHt9XG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fVxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGdldE1heGltdW1TaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCB8fCBlbGVtZW50LndpZHRoKTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQpXG4gICAgfTtcbiAgfVxuICBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgfVxufVxuXG5jbGFzcyBCYXNpY1BsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoaXRlbSkge1xuICAgIHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnLm9wdGlvbnMuYW5pbWF0aW9uID0gZmFsc2U7XG4gIH1cbn1cblxuY29uc3QgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xuY29uc3QgRVZFTlRfVFlQRVMgPSB7XG4gIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuICB0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3VjaGVuZDogJ21vdXNldXAnLFxuICBwb2ludGVyZW50ZXI6ICdtb3VzZWVudGVyJyxcbiAgcG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxuICBwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXG4gIHBvaW50ZXJ1cDogJ21vdXNldXAnLFxuICBwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXG4gIHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcbn07XG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuICBjb25zdCByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgY29uc3QgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgc3R5bGUuYm94U2l6aW5nID0gc3R5bGUuYm94U2l6aW5nIHx8ICdib3JkZXItYm94JztcbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlckhlaWdodCkpIHtcbiAgICBpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FudmFzO1xufVxuY29uc3QgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjaGFydC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgY2hhcnQsXG4gICAgbmF0aXZlOiBldmVudCxcbiAgICB4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vZGVMaXN0Q29udGFpbnMobm9kZUxpc3QsIGNhbnZhcykge1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxpc3QpIHtcbiAgICBpZiAobm9kZSA9PT0gY2FudmFzIHx8IG5vZGUuY29udGFpbnMoY2FudmFzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVBdHRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmNvbnN0IGRycExpc3RlbmluZ0NoYXJ0cyA9IG5ldyBNYXAoKTtcbmxldCBvbGREZXZpY2VQaXhlbFJhdGlvID0gMDtcbmZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xuICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgaWYgKGRwciA9PT0gb2xkRGV2aWNlUGl4ZWxSYXRpbykge1xuICAgIHJldHVybjtcbiAgfVxuICBvbGREZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZm9yRWFjaCgocmVzaXplLCBjaGFydCkgPT4ge1xuICAgIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gZHByKSB7XG4gICAgICByZXNpemUoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxuICBkcnBMaXN0ZW5pbmdDaGFydHMuc2V0KGNoYXJ0LCByZXNpemUpO1xufVxuZnVuY3Rpb24gdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCkge1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcyAmJiBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZXNpemUgPSB0aHJvdHRsZWQoKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB3ID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGxpc3RlbmVyKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmICh3IDwgY29udGFpbmVyLmNsaWVudFdpZHRoKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwgd2luZG93KTtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuICBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gcmVsZWFzZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBvYnNlcnZlcikge1xuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG4gICAgdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5QW5kTGlzdGVuKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IHByb3h5ID0gdGhyb3R0bGVkKChldmVudCkgPT4ge1xuICAgIGlmIChjaGFydC5jdHggIT09IG51bGwpIHtcbiAgICAgIGxpc3RlbmVyKGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpKTtcbiAgICB9XG4gIH0sIGNoYXJ0LCAoYXJncykgPT4ge1xuICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICByZXR1cm4gW2V2ZW50LCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZXTtcbiAgfSk7XG4gIGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5jbGFzcyBEb21QbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0ICYmIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBjYW52YXMpIHtcbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xuICAgIFsnaGVpZ2h0JywgJ3dpZHRoJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzdHlsZSA9IGluaXRpYWwuc3R5bGUgfHwge307XG4gICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY2FudmFzLnN0eWxlW2tleV0gPSBzdHlsZVtrZXldO1xuICAgIH0pO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSk7XG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGNyZWF0ZVByb3h5QW5kTGlzdGVuO1xuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuICAgIGlmICghcHJveHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIGRldGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgcmVzaXplOiByZWxlYXNlT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCByZW1vdmVMaXN0ZW5lcjtcbiAgICBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBwcm94eSk7XG4gICAgcHJveGllc1t0eXBlXSA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuICBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICB9XG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICByZXR1cm4gISEoY29udGFpbmVyICYmIGNvbnRhaW5lci5pc0Nvbm5lY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RldGVjdFBsYXRmb3JtKGNhbnZhcykge1xuICBpZiAoIV9pc0RvbVN1cHBvcnRlZCgpIHx8ICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpKSB7XG4gICAgcmV0dXJuIEJhc2ljUGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIERvbVBsYXRmb3JtO1xufVxuXG52YXIgcGxhdGZvcm1zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuX2RldGVjdFBsYXRmb3JtOiBfZGV0ZWN0UGxhdGZvcm0sXG5CYXNlUGxhdGZvcm06IEJhc2VQbGF0Zm9ybSxcbkJhc2ljUGxhdGZvcm06IEJhc2ljUGxhdGZvcm0sXG5Eb21QbGF0Zm9ybTogRG9tUGxhdGZvcm1cbn0pO1xuXG5jb25zdCB0cmFuc3BhcmVudCA9ICd0cmFuc3BhcmVudCc7XG5jb25zdCBpbnRlcnBvbGF0b3JzID0ge1xuICBib29sZWFuKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZmFjdG9yID4gMC41ID8gdG8gOiBmcm9tO1xuICB9LFxuICBjb2xvcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgY29uc3QgYzAgPSBjb2xvcihmcm9tIHx8IHRyYW5zcGFyZW50KTtcbiAgICBjb25zdCBjMSA9IGMwLnZhbGlkICYmIGNvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcbiAgICByZXR1cm4gYzEgJiYgYzEudmFsaWRcbiAgICAgID8gYzEubWl4KGMwLCBmYWN0b3IpLmhleFN0cmluZygpXG4gICAgICA6IHRvO1xuICB9LFxuICBudW1iZXIoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XG4gIH1cbn07XG5jbGFzcyBBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcihjZmcsIHRhcmdldCwgcHJvcCwgdG8pIHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgY29uc3QgZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcbiAgICB0aGlzLl9lYXNpbmcgPSBlZmZlY3RzW2NmZy5lYXNpbmddIHx8IGVmZmVjdHMubGluZWFyO1xuICAgIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKGNmZy5kZWxheSB8fCAwKSk7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fcHJvcCA9IHByb3A7XG4gICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgdGhpcy5fdG8gPSB0bztcbiAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgfVxuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuICB1cGRhdGUoY2ZnLCB0bywgZGF0ZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcF07XG4gICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgY29uc3QgcmVtYWluID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuICAgICAgdGhpcy5fc3RhcnQgPSBkYXRlO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XG4gICAgICB0aGlzLl90b3RhbCArPSBlbGFwc2VkO1xuICAgICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICB0aGlzLl90byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICAgIHRoaXMuX2Zyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIH1cbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy50aWNrKERhdGUubm93KCkpO1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgIH1cbiAgfVxuICB0aWNrKGRhdGUpIHtcbiAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuX3Byb3A7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XG4gICAgY29uc3QgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgY29uc3QgdG8gPSB0aGlzLl90bztcbiAgICBsZXQgZmFjdG9yO1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZyb20gIT09IHRvICYmIChsb29wIHx8IChlbGFwc2VkIDwgZHVyYXRpb24pKTtcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdG87XG4gICAgICB0aGlzLl9ub3RpZnkodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGFwc2VkIDwgMCkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gZnJvbTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmFjdG9yID0gKGVsYXBzZWQgLyBkdXJhdGlvbikgJSAyO1xuICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XG4gICAgZmFjdG9yID0gdGhpcy5fZWFzaW5nKE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGZhY3RvcikpKTtcbiAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0aGlzLl9mbihmcm9tLCB0bywgZmFjdG9yKTtcbiAgfVxuICB3YWl0KCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goe3JlcywgcmVqfSk7XG4gICAgfSk7XG4gIH1cbiAgX25vdGlmeShyZXNvbHZlZCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlc29sdmVkID8gJ3JlcycgOiAncmVqJztcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2VzW2ldW21ldGhvZF0oKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbnVtYmVycyA9IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cycsICd0ZW5zaW9uJ107XG5jb25zdCBjb2xvcnMgPSBbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JhY2tncm91bmRDb2xvciddO1xuZGVmYXVsdHMuc2V0KCdhbmltYXRpb24nLCB7XG4gIGRlbGF5OiB1bmRlZmluZWQsXG4gIGR1cmF0aW9uOiAxMDAwLFxuICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICBmbjogdW5kZWZpbmVkLFxuICBmcm9tOiB1bmRlZmluZWQsXG4gIGxvb3A6IHVuZGVmaW5lZCxcbiAgdG86IHVuZGVmaW5lZCxcbiAgdHlwZTogdW5kZWZpbmVkLFxufSk7XG5jb25zdCBhbmltYXRpb25PcHRpb25zID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuYW5pbWF0aW9uKTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb24nLCB7XG4gIF9mYWxsYmFjazogZmFsc2UsXG4gIF9pbmRleGFibGU6IGZhbHNlLFxuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdvblByb2dyZXNzJyAmJiBuYW1lICE9PSAnb25Db21wbGV0ZScgJiYgbmFtZSAhPT0gJ2ZuJyxcbn0pO1xuZGVmYXVsdHMuc2V0KCdhbmltYXRpb25zJywge1xuICBjb2xvcnM6IHtcbiAgICB0eXBlOiAnY29sb3InLFxuICAgIHByb3BlcnRpZXM6IGNvbG9yc1xuICB9LFxuICBudW1iZXJzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgcHJvcGVydGllczogbnVtYmVyc1xuICB9LFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9ucycsIHtcbiAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJyxcbn0pO1xuZGVmYXVsdHMuc2V0KCd0cmFuc2l0aW9ucycsIHtcbiAgYWN0aXZlOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwXG4gICAgfVxuICB9LFxuICByZXNpemU6IHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiAwXG4gICAgfVxuICB9LFxuICBzaG93OiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIGZyb206ICd0cmFuc3BhcmVudCdcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuICBoaWRlOiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIHRvOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGZuOiB2ID0+IHYgfCAwXG4gICAgICB9LFxuICAgIH1cbiAgfVxufSk7XG5jbGFzcyBBbmltYXRpb25zIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuICB9XG4gIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBjZmcgPSBjb25maWdba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3QoY2ZnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgYW5pbWF0aW9uT3B0aW9ucykge1xuICAgICAgICByZXNvbHZlZFtvcHRpb25dID0gY2ZnW29wdGlvbl07XG4gICAgICB9XG4gICAgICAoaXNBcnJheShjZmcucHJvcGVydGllcykgJiYgY2ZnLnByb3BlcnRpZXMgfHwgW2tleV0pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09IGtleSB8fCAhYW5pbWF0ZWRQcm9wcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICBhbmltYXRlZFByb3BzLnNldChwcm9wLCByZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB2YWx1ZXMub3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMob3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgaWYgKG5ld09wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgcnVubmluZyA9IHRhcmdldC4kYW5pbWF0aW9ucyB8fCAodGFyZ2V0LiRhbmltYXRpb25zID0ge30pO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBwcm9wcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHByb3AuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaCguLi50aGlzLl9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3Byb3BdO1xuICAgICAgbGV0IGFuaW1hdGlvbiA9IHJ1bm5pbmdbcHJvcF07XG4gICAgICBjb25zdCBjZmcgPSBhbmltYXRlZFByb3BzLmdldChwcm9wKTtcbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcbiAgICAgICAgICBhbmltYXRpb24udXBkYXRlKGNmZywgdmFsdWUsIGRhdGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjZmcgfHwgIWNmZy5kdXJhdGlvbikge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBydW5uaW5nW3Byb3BdID0gYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihjZmcsIHRhcmdldCwgcHJvcCwgdmFsdWUpO1xuICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIHVwZGF0ZSh0YXJnZXQsIHZhbHVlcykge1xuICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcyk7XG4gICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBhbmltYXRvci5hZGQodGhpcy5fY2hhcnQsIGFuaW1hdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhd2FpdEFsbChhbmltYXRpb25zLCBwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IHJ1bm5pbmcgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhbmltID0gYW5pbWF0aW9uc1trZXlzW2ldXTtcbiAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XG4gICAgICBydW5uaW5nLnB1c2goYW5pbS53YWl0KCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwocnVubmluZyk7XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpIHtcbiAgaWYgKCFuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnM7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wdGlvbnMuJHNoYXJlZCkge1xuICAgIHRhcmdldC5vcHRpb25zID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHskc2hhcmVkOiBmYWxzZSwgJGFuaW1hdGlvbnM6IHt9fSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHNjYWxlQ2xpcChzY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zIHx8IHt9O1xuICBjb25zdCByZXZlcnNlID0gb3B0cy5yZXZlcnNlO1xuICBjb25zdCBtaW4gPSBvcHRzLm1pbiA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgY29uc3QgbWF4ID0gb3B0cy5tYXggPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHJldmVyc2UgPyBtYXggOiBtaW4sXG4gICAgZW5kOiByZXZlcnNlID8gbWluIDogbWF4XG4gIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZUNsaXAoeFNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHkuZW5kLFxuICAgIHJpZ2h0OiB4LmVuZCxcbiAgICBib3R0b206IHkuc3RhcnQsXG4gICAgbGVmdDogeC5zdGFydFxuICB9O1xufVxuZnVuY3Rpb24gdG9DbGlwKHZhbHVlKSB7XG4gIGxldCB0LCByLCBiLCBsO1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdCA9IHZhbHVlLnRvcDtcbiAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICBsID0gdmFsdWUubGVmdDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gciA9IGIgPSBsID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IHIsXG4gICAgYm90dG9tOiBiLFxuICAgIGxlZnQ6IGwsXG4gICAgZGlzYWJsZWQ6IHZhbHVlID09PSBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIGZpbHRlclZpc2libGUpIHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSk7XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5cy5wdXNoKG1ldGFzZXRzW2ldLmluZGV4KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBkc0luZGV4LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qga2V5cyA9IHN0YWNrLmtleXM7XG4gIGNvbnN0IHNpbmdsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdzaW5nbGUnO1xuICBsZXQgaSwgaWxlbiwgZGF0YXNldEluZGV4LCBvdGhlclZhbHVlO1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZGF0YXNldEluZGV4ID0gK2tleXNbaV07XG4gICAgaWYgKGRhdGFzZXRJbmRleCA9PT0gZHNJbmRleCkge1xuICAgICAgaWYgKG9wdGlvbnMuYWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG90aGVyVmFsdWUgPSBzdGFjay52YWx1ZXNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoaXNOdW1iZXJGaW5pdGUob3RoZXJWYWx1ZSkgJiYgKHNpbmdsZU1vZGUgfHwgKHZhbHVlID09PSAwIHx8IHNpZ24odmFsdWUpID09PSBzaWduKG90aGVyVmFsdWUpKSkpIHtcbiAgICAgIHZhbHVlICs9IG90aGVyVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgY29uc3QgYWRhdGEgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICBsZXQgaSwgaWxlbiwga2V5O1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIGFkYXRhW2ldID0ge1xuICAgICAgeDoga2V5LFxuICAgICAgeTogZGF0YVtrZXldXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYWRhdGE7XG59XG5mdW5jdGlvbiBpc1N0YWNrZWQoc2NhbGUsIG1ldGEpIHtcbiAgY29uc3Qgc3RhY2tlZCA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgcmV0dXJuIHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gZ2V0U3RhY2tLZXkoaW5kZXhTY2FsZSwgdmFsdWVTY2FsZSwgbWV0YSkge1xuICByZXR1cm4gYCR7aW5kZXhTY2FsZS5pZH0uJHt2YWx1ZVNjYWxlLmlkfS4ke21ldGEuc3RhY2sgfHwgbWV0YS50eXBlfWA7XG59XG5mdW5jdGlvbiBnZXRVc2VyQm91bmRzKHNjYWxlKSB7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBzY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW5EZWZpbmVkID8gbWluIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgIG1heDogbWF4RGVmaW5lZCA/IG1heCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIHN0YWNrS2V5LCBpbmRleFZhbHVlKSB7XG4gIGNvbnN0IHN1YlN0YWNrID0gc3RhY2tzW3N0YWNrS2V5XSB8fCAoc3RhY2tzW3N0YWNrS2V5XSA9IHt9KTtcbiAgcmV0dXJuIHN1YlN0YWNrW2luZGV4VmFsdWVdIHx8IChzdWJTdGFja1tpbmRleFZhbHVlXSA9IHt9KTtcbn1cbmZ1bmN0aW9uIGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgcG9zaXRpdmUsIHR5cGUpIHtcbiAgZm9yIChjb25zdCBtZXRhIG9mIHZTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKS5yZXZlcnNlKCkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YWNrW21ldGEuaW5kZXhdO1xuICAgIGlmICgocG9zaXRpdmUgJiYgdmFsdWUgPiAwKSB8fCAoIXBvc2l0aXZlICYmIHZhbHVlIDwgMCkpIHtcbiAgICAgIHJldHVybiBtZXRhLmluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrcyhjb250cm9sbGVyLCBwYXJzZWQpIHtcbiAgY29uc3Qge2NoYXJ0LCBfY2FjaGVkTWV0YTogbWV0YX0gPSBjb250cm9sbGVyO1xuICBjb25zdCBzdGFja3MgPSBjaGFydC5fc3RhY2tzIHx8IChjaGFydC5fc3RhY2tzID0ge30pO1xuICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIGluZGV4OiBkYXRhc2V0SW5kZXh9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgY29uc3Qga2V5ID0gZ2V0U3RhY2tLZXkoaVNjYWxlLCB2U2NhbGUsIG1ldGEpO1xuICBjb25zdCBpbGVuID0gcGFyc2VkLmxlbmd0aDtcbiAgbGV0IHN0YWNrO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBwYXJzZWRbaV07XG4gICAgY29uc3Qge1tpQXhpc106IGluZGV4LCBbdkF4aXNdOiB2YWx1ZX0gPSBpdGVtO1xuICAgIGNvbnN0IGl0ZW1TdGFja3MgPSBpdGVtLl9zdGFja3MgfHwgKGl0ZW0uX3N0YWNrcyA9IHt9KTtcbiAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgIHN0YWNrW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcbiAgICBzdGFjay5fdG9wID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCB0cnVlLCBtZXRhLnR5cGUpO1xuICAgIHN0YWNrLl9ib3R0b20gPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIGZhbHNlLCBtZXRhLnR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsIGF4aXMpIHtcbiAgY29uc3Qgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xuICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoa2V5ID0+IHNjYWxlc1trZXldLmF4aXMgPT09IGF4aXMpLnNoaWZ0KCk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCxcbiAgICB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgZGF0YXNldDogdW5kZWZpbmVkLFxuICAgICAgZGF0YXNldEluZGV4OiBpbmRleCxcbiAgICAgIGluZGV4LFxuICAgICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgICAgdHlwZTogJ2RhdGFzZXQnXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YUNvbnRleHQocGFyZW50LCBpbmRleCwgZWxlbWVudCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgcGFyc2VkOiB1bmRlZmluZWQsXG4gICAgcmF3OiB1bmRlZmluZWQsXG4gICAgZWxlbWVudCxcbiAgICBpbmRleCxcbiAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgdHlwZTogJ2RhdGEnXG4gIH0pO1xufVxuZnVuY3Rpb24gY2xlYXJTdGFja3MobWV0YSwgaXRlbXMpIHtcbiAgY29uc3QgZGF0YXNldEluZGV4ID0gbWV0YS5jb250cm9sbGVyLmluZGV4O1xuICBjb25zdCBheGlzID0gbWV0YS52U2NhbGUgJiYgbWV0YS52U2NhbGUuYXhpcztcbiAgaWYgKCFheGlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGl0ZW1zID0gaXRlbXMgfHwgbWV0YS5fcGFyc2VkO1xuICBmb3IgKGNvbnN0IHBhcnNlZCBvZiBpdGVtcykge1xuICAgIGNvbnN0IHN0YWNrcyA9IHBhcnNlZC5fc3RhY2tzO1xuICAgIGlmICghc3RhY2tzIHx8IHN0YWNrc1theGlzXSA9PT0gdW5kZWZpbmVkIHx8IHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdO1xuICB9XG59XG5jb25zdCBpc0RpcmVjdFVwZGF0ZU1vZGUgPSAobW9kZSkgPT4gbW9kZSA9PT0gJ3Jlc2V0JyB8fCBtb2RlID09PSAnbm9uZSc7XG5jb25zdCBjbG9uZUlmTm90U2hhcmVkID0gKGNhY2hlZCwgc2hhcmVkKSA9PiBzaGFyZWQgPyBjYWNoZWQgOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZWQpO1xuY29uc3QgY3JlYXRlU3RhY2sgPSAoY2FuU3RhY2ssIG1ldGEsIGNoYXJ0KSA9PiBjYW5TdGFjayAmJiAhbWV0YS5oaWRkZW4gJiYgbWV0YS5fc3RhY2tlZFxuICAmJiB7a2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLCB2YWx1ZXM6IG51bGx9O1xuY2xhc3MgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX2N0eCA9IGNoYXJ0LmN0eDtcbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gICAgdGhpcy5fY2FjaGVkTWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuICAgIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29iamVjdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmxpbmtTY2FsZXMoKTtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG4gIH1cbiAgdXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KSB7XG4gICAgaWYgKHRoaXMuaW5kZXggIT09IGRhdGFzZXRJbmRleCkge1xuICAgICAgY2xlYXJTdGFja3ModGhpcy5fY2FjaGVkTWV0YSk7XG4gICAgfVxuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gIH1cbiAgbGlua1NjYWxlcygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGNob29zZUlkID0gKGF4aXMsIHgsIHksIHIpID0+IGF4aXMgPT09ICd4JyA/IHggOiBheGlzID09PSAncicgPyByIDogeTtcbiAgICBjb25zdCB4aWQgPSBtZXRhLnhBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnhBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3gnKSk7XG4gICAgY29uc3QgeWlkID0gbWV0YS55QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC55QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd5JykpO1xuICAgIGNvbnN0IHJpZCA9IG1ldGEuckF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuckF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAncicpKTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBtZXRhLmluZGV4QXhpcztcbiAgICBjb25zdCBpaWQgPSBtZXRhLmlBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHhpZCwgeWlkLCByaWQpO1xuICAgIGNvbnN0IHZpZCA9IG1ldGEudkF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeWlkLCB4aWQsIHJpZCk7XG4gICAgbWV0YS54U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeGlkKTtcbiAgICBtZXRhLnlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh5aWQpO1xuICAgIG1ldGEuclNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHJpZCk7XG4gICAgbWV0YS5pU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoaWlkKTtcbiAgICBtZXRhLnZTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh2aWQpO1xuICB9XG4gIGdldERhdGFzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcbiAgfVxuICBnZXRNZXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuICB9XG4gIGdldFNjYWxlRm9ySWQoc2NhbGVJRCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcbiAgfVxuICBfZ2V0T3RoZXJTY2FsZShzY2FsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHJldHVybiBzY2FsZSA9PT0gbWV0YS5pU2NhbGVcbiAgICAgID8gbWV0YS52U2NhbGVcbiAgICAgIDogbWV0YS5pU2NhbGU7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fdXBkYXRlKCdyZXNldCcpO1xuICB9XG4gIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgfVxuICB9XG4gIF9kYXRhQ2hlY2soKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcbiAgICBjb25zdCBfZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCB0aGlzKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgICBtZXRhLl9wYXJzZWQgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcbiAgICAgICAgbGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuICAgIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgbWV0YS5kYXRhc2V0ID0gbmV3IHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICB9XG4gIGJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBzdGFja0NoYW5nZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcbiAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICBpZiAobWV0YS5zdGFjayAhPT0gZGF0YXNldC5zdGFjaykge1xuICAgICAgc3RhY2tDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgbWV0YS5zdGFjayA9IGRhdGFzZXQuc3RhY2s7XG4gICAgfVxuICAgIHRoaXMuX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIGlmIChzdGFja0NoYW5nZWQgfHwgb2xkU3RhY2tlZCAhPT0gbWV0YS5fc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldFNjb3BlS2V5cyh0aGlzLl90eXBlKTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMsIHRydWUpO1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLl9wYXJzaW5nID0gdGhpcy5vcHRpb25zLnBhcnNpbmc7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgfVxuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IG1ldGEsIF9kYXRhOiBkYXRhfSA9IHRoaXM7XG4gICAgY29uc3Qge2lTY2FsZSwgX3N0YWNrZWR9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgIGxldCBwcmV2ID0gc3RhcnQgPiAwICYmIG1ldGEuX3BhcnNlZFtzdGFydCAtIDFdO1xuICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgICBtZXRhLl9zb3J0ZWQgPSB0cnVlO1xuICAgICAgcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJyYXkoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYgPSAoKSA9PiBjdXJbaUF4aXNdID09PSBudWxsIHx8IChwcmV2ICYmIGN1cltpQXhpc10gPCBwcmV2W2lBeGlzXSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaSArIHN0YXJ0XSA9IGN1ciA9IHBhcnNlZFtpXTtcbiAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgIGlmIChpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldigpKSB7XG4gICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWV0YS5fc29ydGVkID0gc29ydGVkO1xuICAgIH1cbiAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBwYXJzZWQpO1xuICAgIH1cbiAgfVxuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIFtpQXhpc106IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaW5kZXhdLCBpbmRleCksXG4gICAgICAgIFt2QXhpc106IHZTY2FsZS5wYXJzZShkYXRhW2luZGV4XSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShpdGVtWzBdLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShpdGVtWzFdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB4QXhpc0tleSksIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeUF4aXNLZXkpLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgZ2V0UGFyc2VkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZFtpbmRleF07XG4gIH1cbiAgZ2V0RGF0YUVsZW1lbnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgfVxuICBhcHBseVN0YWNrKHNjYWxlLCBwYXJzZWQsIG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgY29uc3Qgc3RhY2sgPSB7XG4gICAgICBrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksXG4gICAgICB2YWx1ZXM6IHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdXG4gICAgfTtcbiAgICByZXR1cm4gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIG1ldGEuaW5kZXgsIHttb2RlfSk7XG4gIH1cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFZhbHVlID09PSBudWxsID8gTmFOIDogcGFyc2VkVmFsdWU7XG4gICAgY29uc3QgdmFsdWVzID0gc3RhY2sgJiYgcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc107XG4gICAgaWYgKHN0YWNrICYmIHZhbHVlcykge1xuICAgICAgc3RhY2sudmFsdWVzID0gdmFsdWVzO1xuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XG4gICAgfVxuICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICB9XG4gIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xuICAgIGNvbnN0IG90aGVyU2NhbGUgPSB0aGlzLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICBjb25zdCBzdGFjayA9IGNyZWF0ZVN0YWNrKGNhblN0YWNrLCBtZXRhLCB0aGlzLmNoYXJ0KTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIGNvbnN0IHttaW46IG90aGVyTWluLCBtYXg6IG90aGVyTWF4fSA9IGdldFVzZXJCb3VuZHMob3RoZXJTY2FsZSk7XG4gICAgbGV0IGksIHBhcnNlZDtcbiAgICBmdW5jdGlvbiBfc2tpcCgpIHtcbiAgICAgIHBhcnNlZCA9IF9wYXJzZWRbaV07XG4gICAgICBjb25zdCBvdGhlclZhbHVlID0gcGFyc2VkW290aGVyU2NhbGUuYXhpc107XG4gICAgICByZXR1cm4gIWlzTnVtYmVyRmluaXRlKHBhcnNlZFtzY2FsZS5heGlzXSkgfHwgb3RoZXJNaW4gPiBvdGhlclZhbHVlIHx8IG90aGVyTWF4IDwgb3RoZXJWYWx1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgZm9yIChpID0gaWxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICBnZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWQ7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc051bWJlckZpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogaVNjYWxlID8gJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSA6ICcnLFxuICAgICAgdmFsdWU6IHZTY2FsZSA/ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSkgOiAnJ1xuICAgIH07XG4gIH1cbiAgX3VwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGUobW9kZSB8fCAnZGVmYXVsdCcpO1xuICAgIG1ldGEuX2NsaXAgPSB0b0NsaXAodmFsdWVPckRlZmF1bHQodGhpcy5vcHRpb25zLmNsaXAsIGRlZmF1bHRDbGlwKG1ldGEueFNjYWxlLCBtZXRhLnlTY2FsZSwgdGhpcy5nZXRNYXhPdmVyZmxvdygpKSkpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7fVxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhY3RpdmUgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2RyYXdTdGFydCB8fCAwO1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZHJhd0NvdW50IHx8IChlbGVtZW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgY29uc3QgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0aGlzLm9wdGlvbnMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3A7XG4gICAgbGV0IGk7XG4gICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKGVsZW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuYWN0aXZlICYmIGRyYXdBY3RpdmVFbGVtZW50c09uVG9wKSB7XG4gICAgICAgIGFjdGl2ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5kcmF3KGN0eCwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFjdGl2ZVtpXS5kcmF3KGN0eCwgYXJlYSk7XG4gICAgfVxuICB9XG4gIGdldFN0eWxlKGluZGV4LCBhY3RpdmUpIHtcbiAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XG4gICAgICA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKVxuICAgICAgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXggfHwgMCwgbW9kZSk7XG4gIH1cbiAgZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fFxuICAgICAgICAoZWxlbWVudC4kY29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgY29udGV4dC5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHxcbiAgICAgICAgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpO1xuICAgICAgY29udGV4dC5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuICAgIGNvbnRleHQuYWN0aXZlID0gISFhY3RpdmU7XG4gICAgY29udGV4dC5tb2RlID0gbW9kZTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCBtb2RlKTtcbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFFbGVtZW50VHlwZS5pZCwgbW9kZSwgaW5kZXgpO1xuICB9XG4gIF9yZXNvbHZlRWxlbWVudE9wdGlvbnMoZWxlbWVudFR5cGUsIG1vZGUgPSAnZGVmYXVsdCcsIGluZGV4KSB7XG4gICAgY29uc3QgYWN0aXZlID0gbW9kZSA9PT0gJ2FjdGl2ZSc7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGVsZW1lbnRUeXBlICsgJy0nICsgbW9kZTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgY29uc3Qgc2hhcmluZyA9IHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyAmJiBkZWZpbmVkKGluZGV4KTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2xvbmVJZk5vdFNoYXJlZChjYWNoZWQsIHNoYXJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEVsZW1lbnRTY29wZUtleXModGhpcy5fdHlwZSwgZWxlbWVudFR5cGUpO1xuICAgIGNvbnN0IHByZWZpeGVzID0gYWN0aXZlID8gW2Ake2VsZW1lbnRUeXBlfUhvdmVyYCwgJ2hvdmVyJywgZWxlbWVudFR5cGUsICcnXSA6IFtlbGVtZW50VHlwZSwgJyddO1xuICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5lbGVtZW50c1tlbGVtZW50VHlwZV0pO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSk7XG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzLiRzaGFyZWQgPSBzaGFyaW5nO1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIF9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgdHJhbnNpdGlvbiwgYWN0aXZlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgYW5pbWF0aW9uLSR7dHJhbnNpdGlvbn1gO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAoY2hhcnQub3B0aW9ucy5hbmltYXRpb24gIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKHRoaXMuX3R5cGUsIHRyYW5zaXRpb24pO1xuICAgICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICAgIG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgdHJhbnNpdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnMoY2hhcnQsIG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb25zKTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9jYWNoZWFibGUpIHtcbiAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIGdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zaGFyZWRPcHRpb25zIHx8ICh0aGlzLl9zaGFyZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICB9XG4gIGluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gIXNoYXJlZE9wdGlvbnMgfHwgaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgfVxuICBfZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSkge1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgcHJldmlvdXNseVNoYXJlZE9wdGlvbnMgPSB0aGlzLl9zaGFyZWRPcHRpb25zO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykgfHwgKHNoYXJlZE9wdGlvbnMgIT09IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICByZXR1cm4ge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfTtcbiAgfVxuICB1cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCBwcm9wZXJ0aWVzLCBtb2RlKSB7XG4gICAgaWYgKGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUpLnVwZGF0ZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKS51cGRhdGUoc2hhcmVkT3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIF9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgbW9kZSwgYWN0aXZlKSB7XG4gICAgZWxlbWVudC5hY3RpdmUgPSBhY3RpdmU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSk7XG4gICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUsIGFjdGl2ZSkudXBkYXRlKGVsZW1lbnQsIHtcbiAgICAgIG9wdGlvbnM6ICghYWN0aXZlICYmIHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSkgfHwgb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHJlbW92ZUhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgZmFsc2UpO1xuICB9XG4gIHNldEhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XG4gIH1cbiAgX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgX3NldERhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIHRydWUpO1xuICAgIH1cbiAgfVxuICBfcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIGZvciAoY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gb2YgdGhpcy5fc3luY0xpc3QpIHtcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICBjb25zdCBudW1NZXRhID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bURhdGEgPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKG51bURhdGEsIG51bU1ldGEpO1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5wYXJzZSgwLCBjb3VudCk7XG4gICAgfVxuICAgIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuICAgICAgdGhpcy5faW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEsIHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIH0gZWxzZSBpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnRzKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gIH1cbiAgX2luc2VydEVsZW1lbnRzKHN0YXJ0LCBjb3VudCwgcmVzZXROZXdFbGVtZW50cyA9IHRydWUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbW92ZSA9IChhcnIpID0+IHtcbiAgICAgIGFyci5sZW5ndGggKz0gY291bnQ7XG4gICAgICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSBlbmQ7IGktLSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJbaSAtIGNvdW50XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vdmUoZGF0YSk7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgZGF0YVtpXSA9IG5ldyB0aGlzLmRhdGFFbGVtZW50VHlwZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgbW92ZShtZXRhLl9wYXJzZWQpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlKHN0YXJ0LCBjb3VudCk7XG4gICAgaWYgKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZGF0YSwgc3RhcnQsIGNvdW50LCAncmVzZXQnKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoZWxlbWVudCwgc3RhcnQsIGNvdW50LCBtb2RlKSB7fVxuICBfcmVtb3ZlRWxlbWVudHMoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhLCByZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuICB9XG4gIF9zeW5jKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgdGhpcy5fc3luY0xpc3QucHVzaChhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gPSBhcmdzO1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0Ll9kYXRhQ2hhbmdlcy5wdXNoKFt0aGlzLmluZGV4LCAuLi5hcmdzXSk7XG4gIH1cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xuICB9XG4gIF9vbkRhdGFQb3AoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGggLSAxLCAxXSk7XG4gIH1cbiAgX29uRGF0YVNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCAwLCAxXSk7XG4gIH1cbiAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCBzdGFydCwgY291bnRdKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCBzdGFydCwgbmV3Q291bnRdKTtcbiAgICB9XG4gIH1cbiAgX29uRGF0YVVuc2hpZnQoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIDAsIGFyZ3VtZW50cy5sZW5ndGhdKTtcbiAgfVxufVxuRGF0YXNldENvbnRyb2xsZXIuZGVmYXVsdHMgPSB7fTtcbkRhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5kYXRhc2V0RWxlbWVudFR5cGUgPSBudWxsO1xuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmRhdGFFbGVtZW50VHlwZSA9IG51bGw7XG5cbmNsYXNzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgfVxuICBnZXRQcm9wcyhwcm9wcywgZmluYWwpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgaWYgKCFmaW5hbCB8fCAhYW5pbXMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgcmV0W3Byb3BdID0gYW5pbXNbcHJvcF0gJiYgYW5pbXNbcHJvcF0uYWN0aXZlKCkgPyBhbmltc1twcm9wXS5fdG8gOiB0aGlzW3Byb3BdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbkVsZW1lbnQuZGVmYXVsdHMgPSB7fTtcbkVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHVuZGVmaW5lZDtcblxuY29uc3QgZm9ybWF0dGVycyA9IHtcbiAgdmFsdWVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiAnJyArIHZhbHVlO1xuICB9LFxuICBudW1lcmljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbm90YXRpb247XG4gICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlO1xuICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0udmFsdWUpLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgaWYgKG1heFRpY2sgPCAxZS00IHx8IG1heFRpY2sgPiAxZSsxNSkge1xuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgIH1cbiAgICAgIGRlbHRhID0gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcyk7XG4gICAgfVxuICAgIGNvbnN0IGxvZ0RlbHRhID0gbG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcbiAgICBjb25zdCBudW1EZWNpbWFsID0gTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKSwgMjApLCAwKTtcbiAgICBjb25zdCBvcHRpb25zID0ge25vdGF0aW9uLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWwsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbH07XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHRpY2tWYWx1ZSwgbG9jYWxlLCBvcHRpb25zKTtcbiAgfSxcbiAgbG9nYXJpdGhtaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCByZW1haW4gPSB0aWNrVmFsdWUgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbHVlKSkpKTtcbiAgICBpZiAocmVtYWluID09PSAxIHx8IHJlbWFpbiA9PT0gMiB8fCByZW1haW4gPT09IDUpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWVyaWMuY2FsbCh0aGlzLCB0aWNrVmFsdWUsIGluZGV4LCB0aWNrcyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxufTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpIHtcbiAgbGV0IGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdLnZhbHVlIC0gdGlja3NbMV0udmFsdWUgOiB0aWNrc1sxXS52YWx1ZSAtIHRpY2tzWzBdLnZhbHVlO1xuICBpZiAoTWF0aC5hYnMoZGVsdGEpID49IDEgJiYgdGlja1ZhbHVlICE9PSBNYXRoLmZsb29yKHRpY2tWYWx1ZSkpIHtcbiAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG52YXIgVGlja3MgPSB7Zm9ybWF0dGVyc307XG5cbmRlZmF1bHRzLnNldCgnc2NhbGUnLCB7XG4gIGRpc3BsYXk6IHRydWUsXG4gIG9mZnNldDogZmFsc2UsXG4gIHJldmVyc2U6IGZhbHNlLFxuICBiZWdpbkF0WmVybzogZmFsc2UsXG4gIGJvdW5kczogJ3RpY2tzJyxcbiAgZ3JhY2U6IDAsXG4gIGdyaWQ6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGxpbmVXaWR0aDogMSxcbiAgICBkcmF3Qm9yZGVyOiB0cnVlLFxuICAgIGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcbiAgICBkcmF3VGlja3M6IHRydWUsXG4gICAgdGlja0xlbmd0aDogOCxcbiAgICB0aWNrV2lkdGg6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICB0aWNrQ29sb3I6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmNvbG9yLFxuICAgIG9mZnNldDogZmFsc2UsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMC4wLFxuICAgIGJvcmRlcldpZHRoOiAxXG4gIH0sXG4gIHRpdGxlOiB7XG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgdGV4dDogJycsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiA0LFxuICAgICAgYm90dG9tOiA0XG4gICAgfVxuICB9LFxuICB0aWNrczoge1xuICAgIG1pblJvdGF0aW9uOiAwLFxuICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICBtaXJyb3I6IGZhbHNlLFxuICAgIHRleHRTdHJva2VXaWR0aDogMCxcbiAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgIHBhZGRpbmc6IDMsXG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICBhdXRvU2tpcFBhZGRpbmc6IDMsXG4gICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuICAgIG1pbm9yOiB7fSxcbiAgICBtYWpvcjoge30sXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGNyb3NzQWxpZ246ICduZWFyJyxcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogZmFsc2UsXG4gICAgYmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgfVxufSk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGlja3MnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2JvcmRlckNvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpdGxlJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlJywge1xuICBfZmFsbGJhY2s6IGZhbHNlLFxuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAndGlja0JvcmRlckRhc2gnLFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICBfZmFsbGJhY2s6ICdzY2FsZScsXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZS50aWNrcycsIHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyAmJiBuYW1lICE9PSAnY2FsbGJhY2snLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG59KTtcblxuZnVuY3Rpb24gYXV0b1NraXAoc2NhbGUsIHRpY2tzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gc2NhbGUub3B0aW9ucy50aWNrcztcbiAgY29uc3QgdGlja3NMaW1pdCA9IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xuICBjb25zdCBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xuICBjb25zdCBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IG1ham9ySW5kaWNlc1swXTtcbiAgY29uc3QgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcbiAgY29uc3QgbmV3VGlja3MgPSBbXTtcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IHRpY2tzTGltaXQpIHtcbiAgICBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBudW1NYWpvckluZGljZXMgLyB0aWNrc0xpbWl0KTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgY29uc3Qgc3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCk7XG4gIGlmIChudW1NYWpvckluZGljZXMgPiAwKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgYXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IE1hdGgucm91bmQoKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkpIDogbnVsbDtcbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gMCA6IGZpcnN0IC0gYXZnTWFqb3JTcGFjaW5nLCBmaXJzdCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xuICAgIH1cbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbGFzdCwgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcbiAgcmV0dXJuIG5ld1RpY2tzO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gc2NhbGUub3B0aW9ucy5vZmZzZXQ7XG4gIGNvbnN0IHRpY2tMZW5ndGggPSBzY2FsZS5fdGlja1NpemUoKTtcbiAgY29uc3QgbWF4U2NhbGUgPSBzY2FsZS5fbGVuZ3RoIC8gdGlja0xlbmd0aCArIChvZmZzZXQgPyAwIDogMSk7XG4gIGNvbnN0IG1heENoYXJ0ID0gc2NhbGUuX21heExlbmd0aCAvIHRpY2tMZW5ndGg7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKG1heFNjYWxlLCBtYXhDaGFydCkpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KSB7XG4gIGNvbnN0IGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcbiAgaWYgKCFldmVuTWFqb3JTcGFjaW5nKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xuICB9XG4gIGNvbnN0IGZhY3RvcnMgPSBfZmFjdG9yaXplKGV2ZW5NYWpvclNwYWNpbmcpO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IGZhY3RvcnNbaV07XG4gICAgaWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcbiAgICAgIHJldHVybiBmYWN0b3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbn1cbmZ1bmN0aW9uIGdldE1ham9ySW5kaWNlcyh0aWNrcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubWFqb3IpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgc3BhY2luZykge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcbiAgbGV0IGk7XG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gbWFqb3JJbmRpY2VzW2NvdW50ICogc3BhY2luZ107XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcbiAgY29uc3Qgc3RhcnQgPSB2YWx1ZU9yRGVmYXVsdChtYWpvclN0YXJ0LCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBsZW5ndGgsIGksIG5leHQ7XG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGlmIChtYWpvckVuZCkge1xuICAgIGxlbmd0aCA9IG1ham9yRW5kIC0gbWFqb3JTdGFydDtcbiAgICBzcGFjaW5nID0gbGVuZ3RoIC8gTWF0aC5mbG9vcihsZW5ndGggLyBzcGFjaW5nKTtcbiAgfVxuICBuZXh0ID0gc3RhcnQ7XG4gIHdoaWxlIChuZXh0IDwgMCkge1xuICAgIGNvdW50Kys7XG4gICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICB9XG4gIGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSwgZGlmZjtcbiAgaWYgKGxlbiA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG5cbmNvbnN0IHJldmVyc2VBbGlnbiA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdsZWZ0JyA/ICdyaWdodCcgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6IGFsaWduO1xuY29uc3Qgb2Zmc2V0RnJvbUVkZ2UgPSAoc2NhbGUsIGVkZ2UsIG9mZnNldCkgPT4gZWRnZSA9PT0gJ3RvcCcgfHwgZWRnZSA9PT0gJ2xlZnQnID8gc2NhbGVbZWRnZV0gKyBvZmZzZXQgOiBzY2FsZVtlZGdlXSAtIG9mZnNldDtcbmZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBpbmNyZW1lbnQgPSBhcnIubGVuZ3RoIC8gbnVtSXRlbXM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0UGl4ZWxGb3JHcmlkTGluZShzY2FsZSwgaW5kZXgsIG9mZnNldEdyaWRMaW5lcykge1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS50aWNrcy5sZW5ndGg7XG4gIGNvbnN0IHZhbGlkSW5kZXggPSBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gIGNvbnN0IHN0YXJ0ID0gc2NhbGUuX3N0YXJ0UGl4ZWw7XG4gIGNvbnN0IGVuZCA9IHNjYWxlLl9lbmRQaXhlbDtcbiAgY29uc3QgZXBzaWxvbiA9IDFlLTY7XG4gIGxldCBsaW5lVmFsdWUgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCk7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kcmF3VGlja3MgPyBvcHRpb25zLnRpY2tMZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBmb250ID0gdG9Gb250KG9wdGlvbnMuZm9udCwgZmFsbGJhY2spO1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheShvcHRpb25zLnRleHQpID8gb3B0aW9ucy50ZXh0Lmxlbmd0aCA6IDE7XG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVTY2FsZUNvbnRleHQocGFyZW50LCBzY2FsZSkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBzY2FsZSxcbiAgICB0eXBlOiAnc2NhbGUnXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVGlja0NvbnRleHQocGFyZW50LCBpbmRleCwgdGljaykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0aWNrLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICd0aWNrJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIGxldCByZXQgPSBfdG9MZWZ0UmlnaHRDZW50ZXIoYWxpZ24pO1xuICBpZiAoKHJldmVyc2UgJiYgcG9zaXRpb24gIT09ICdyaWdodCcpIHx8ICghcmV2ZXJzZSAmJiBwb3NpdGlvbiA9PT0gJ3JpZ2h0JykpIHtcbiAgICByZXQgPSByZXZlcnNlQWxpZ24ocmV0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICBpZiAoc2NhbGUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVkgPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVkgPSAoY2hhcnRBcmVhLmJvdHRvbSArIGNoYXJ0QXJlYS50b3ApIC8gMiArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVZID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVYID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMiAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVggPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgcm90YXRpb24gPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xuICB9XG4gIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG59XG5jbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBjZmcuaWQ7XG4gICAgdGhpcy50eXBlID0gY2ZnLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY3R4ID0gY2ZnLmN0eDtcbiAgICB0aGlzLmNoYXJ0ID0gY2ZnLmNoYXJ0O1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpY2tzID0gW107XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSAwO1xuICAgIHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUgPSB7fTtcbiAgICB0aGlzLl9zdGFydFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSAwO1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLmF4aXMgPSBvcHRpb25zLmF4aXM7XG4gICAgdGhpcy5fdXNlck1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5taW4pO1xuICAgIHRoaXMuX3VzZXJNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMubWF4KTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWluKTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWF4KTtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgcmV0dXJuIHJhdztcbiAgfVxuICBnZXRVc2VyQm91bmRzKCkge1xuICAgIGxldCB7X3VzZXJNaW4sIF91c2VyTWF4LCBfc3VnZ2VzdGVkTWluLCBfc3VnZ2VzdGVkTWF4fSA9IHRoaXM7XG4gICAgX3VzZXJNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3VzZXJNYXggPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1pbiA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNYXggPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIF9zdWdnZXN0ZWRNaW4pLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIF9zdWdnZXN0ZWRNYXgpLFxuICAgICAgbWluRGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNaW4pLFxuICAgICAgbWF4RGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNYXgpXG4gICAgfTtcbiAgfVxuICBnZXRNaW5NYXgoY2FuU3RhY2spIHtcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCByYW5nZTtcbiAgICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgICB9XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgodGhpcywgY2FuU3RhY2spO1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcmFuZ2UubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJhbmdlLm1heCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1pbiA9IG1heERlZmluZWQgJiYgbWluID4gbWF4ID8gbWF4IDogbWluO1xuICAgIG1heCA9IG1pbkRlZmluZWQgJiYgbWluID4gbWF4ID8gbWluIDogbWF4O1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChtaW4sIGZpbml0ZU9yRGVmYXVsdChtYXgsIG1pbikpLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxuICAgIH07XG4gIH1cbiAgZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xuICB9XG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgfVxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVybywgZ3JhY2UsIHRpY2tzOiB0aWNrT3B0c30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XG4gICAgdGhpcy5iZWZvcmVVcGRhdGUoKTtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH0sIG1hcmdpbnMpO1xuICAgIHRoaXMudGlja3MgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxuICAgICAgOiB0aGlzLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG4gICAgaWYgKCF0aGlzLl9kYXRhTGltaXRzQ2FjaGVkKSB7XG4gICAgICB0aGlzLmJlZm9yZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuZGV0ZXJtaW5lRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5hZnRlckRhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuX3JhbmdlID0gX2FkZEdyYWNlKHRoaXMsIGdyYWNlLCBiZWdpbkF0WmVybyk7XG4gICAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5iZWZvcmVCdWlsZFRpY2tzKCk7XG4gICAgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdO1xuICAgIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aGlzLnRpY2tzLCBzYW1wbGVTaXplKSA6IHRoaXMudGlja3MpO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpKSB7XG4gICAgICB0aGlzLnRpY2tzID0gYXV0b1NraXAodGhpcywgdGhpcy50aWNrcyk7XG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICAgIHRoaXMuYWZ0ZXJBdXRvU2tpcCgpO1xuICAgIH1cbiAgICBpZiAoc2FtcGxpbmdFbmFibGVkKSB7XG4gICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyh0aGlzLnRpY2tzKTtcbiAgICB9XG4gICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICB0aGlzLmZpdCgpO1xuICAgIHRoaXMuYWZ0ZXJGaXQoKTtcbiAgICB0aGlzLmFmdGVyVXBkYXRlKCk7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGxldCByZXZlcnNlUGl4ZWxzID0gdGhpcy5vcHRpb25zLnJldmVyc2U7XG4gICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cbiAgYWZ0ZXJVcGRhdGUoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIF9jYWxsSG9va3MobmFtZSkge1xuICAgIHRoaXMuY2hhcnQubm90aWZ5UGx1Z2lucyhuYW1lLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zW25hbWVdLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZURhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVEYXRhTGltaXRzJyk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHt9XG4gIGFmdGVyRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyRGF0YUxpbWl0cycpO1xuICB9XG4gIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IGNhbGxiYWNrKHRpY2tPcHRzLmNhbGxiYWNrLCBbdGljay52YWx1ZSwgaSwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCBudW1UaWNrcyA9IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xuICAgIGxldCBsYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgbGV0IHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGNvbnN0IG1heExhYmVsSGVpZ2h0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodDtcbiAgICBjb25zdCBtYXhXaWR0aCA9IF9saW1pdFZhbHVlKHRoaXMuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aWNrV2lkdGggPSBvcHRpb25zLm9mZnNldCA/IHRoaXMubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG4gICAgaWYgKG1heExhYmVsV2lkdGggKyA2ID4gdGlja1dpZHRoKSB7XG4gICAgICB0aWNrV2lkdGggPSBtYXhXaWR0aCAvIChudW1UaWNrcyAtIChvcHRpb25zLm9mZnNldCA/IDAuNSA6IDEpKTtcbiAgICAgIG1heEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKVxuXHRcdFx0XHQtIHRpY2tPcHRzLnBhZGRpbmcgLSBnZXRUaXRsZUhlaWdodChvcHRpb25zLnRpdGxlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBtYXhMYWJlbERpYWdvbmFsID0gTWF0aC5zcXJ0KG1heExhYmVsV2lkdGggKiBtYXhMYWJlbFdpZHRoICsgbWF4TGFiZWxIZWlnaHQgKiBtYXhMYWJlbEhlaWdodCk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gdG9EZWdyZWVzKE1hdGgubWluKFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUoKGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyA2KSAvIHRpY2tXaWR0aCwgLTEsIDEpKSxcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSkgLSBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4TGFiZWxIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpXG4gICAgICApKTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSBNYXRoLm1heChtaW5Sb3RhdGlvbiwgTWF0aC5taW4obWF4Um90YXRpb24sIGxhYmVsUm90YXRpb24pKTtcbiAgICB9XG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcbiAgfVxuICBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge31cbiAgYmVmb3JlRml0KCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IG1pblNpemUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgY29uc3Qge2NoYXJ0LCBvcHRpb25zOiB7dGlja3M6IHRpY2tPcHRzLCB0aXRsZTogdGl0bGVPcHRzLCBncmlkOiBncmlkT3B0c319ID0gdGhpcztcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5faXNWaXNpYmxlKCk7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSBnZXRUaXRsZUhlaWdodCh0aXRsZU9wdHMsIGNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1pblNpemUud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qge2ZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3R9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmcgKiAyO1xuICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja09wdHMubWlycm9yID8gMCA6IHNpbiAqIHdpZGVzdC53aWR0aCArIGNvcyAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBjb3MgKiB3aWRlc3Qud2lkdGggKyBzaW4gKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGggKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LndpZHRoIC0gdGhpcy5fbWFyZ2lucy5sZWZ0IC0gdGhpcy5fbWFyZ2lucy5yaWdodDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSBtaW5TaXplLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9sZW5ndGggPSBjaGFydC5oZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tO1xuICAgIH1cbiAgfVxuICBfY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpIHtcbiAgICBjb25zdCB7dGlja3M6IHthbGlnbiwgcGFkZGluZ30sIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLmxhYmVsUm90YXRpb24gIT09IDA7XG4gICAgY29uc3QgbGFiZWxzQmVsb3dUaWNrcyA9IHBvc2l0aW9uICE9PSAndG9wJyAmJiB0aGlzLmF4aXMgPT09ICd4JztcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0O1xuICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgIGlmIChpc1JvdGF0ZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc0JlbG93VGlja3MpIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IGNvcyAqIGZpcnN0LndpZHRoO1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHNpbiAqIGxhc3QuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gc2luICogZmlyc3QuaGVpZ2h0O1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGNvcyAqIGxhc3Qud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGggLyAyO1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRMZWZ0KSwgMCk7XG4gICAgICB0aGlzLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KChwYWRkaW5nUmlnaHQgLSBvZmZzZXRSaWdodCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodCAvIDI7XG4gICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodCAvIDI7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XG4gICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cbiAgX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgaWYgKHRoaXMuX21hcmdpbnMpIHtcbiAgICAgIHRoaXMuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0xlZnQsIHRoaXMuX21hcmdpbnMubGVmdCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnRvcCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1RvcCwgdGhpcy5fbWFyZ2lucy50b3ApO1xuICAgICAgdGhpcy5fbWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1JpZ2h0LCB0aGlzLl9tYXJnaW5zLnJpZ2h0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nQm90dG9tLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSk7XG4gICAgfVxuICB9XG4gIGFmdGVyRml0KCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3Qge2F4aXMsIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBheGlzID09PSAneCc7XG4gIH1cbiAgaXNGdWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxTaXplO1xuICB9XG4gIF9jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykge1xuICAgIHRoaXMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gICAgdGhpcy5nZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHRpY2tzW2ldLmxhYmVsKSkge1xuICAgICAgICB0aWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlsZW4tLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cbiAgX2dldExhYmVsU2l6ZXMoKSB7XG4gICAgbGV0IGxhYmVsU2l6ZXMgPSB0aGlzLl9sYWJlbFNpemVzO1xuICAgIGlmICghbGFiZWxTaXplcykge1xuICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgbGV0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgIGlmIChzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHRpY2tzID0gc2FtcGxlKHRpY2tzLCBzYW1wbGVTaXplKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoKSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBsZXQgd2lkZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgbGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcbiAgICAgIHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZyA9IHRpY2tGb250LnN0cmluZztcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ZvbnRTdHJpbmddID0gY2FjaGVzW2ZvbnRTdHJpbmddIHx8IHtkYXRhOiB7fSwgZ2M6IFtdfTtcbiAgICAgIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gbGFiZWxbal07XG4gICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG5lc3RlZExhYmVsKSAmJiAhaXNBcnJheShuZXN0ZWRMYWJlbCkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XG4gICAgICAgICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpZHRocy5wdXNoKHdpZHRoKTtcbiAgICAgIGhlaWdodHMucHVzaChoZWlnaHQpO1xuICAgICAgd2lkZXN0TGFiZWxTaXplID0gTWF0aC5tYXgod2lkdGgsIHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgICBoaWdoZXN0TGFiZWxTaXplID0gTWF0aC5tYXgoaGVpZ2h0LCBoaWdoZXN0TGFiZWxTaXplKTtcbiAgICB9XG4gICAgZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xuICAgIGNvbnN0IHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgaGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuICAgIHJldHVybiB7XG4gICAgICBmaXJzdDogdmFsdWVBdCgwKSxcbiAgICAgIGxhc3Q6IHZhbHVlQXQobGVuZ3RoIC0gMSksXG4gICAgICB3aWRlc3Q6IHZhbHVlQXQod2lkZXN0KSxcbiAgICAgIGhpZ2hlc3Q6IHZhbHVlQXQoaGlnaGVzdCksXG4gICAgICB3aWR0aHMsXG4gICAgICBoZWlnaHRzLFxuICAgIH07XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge31cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICB9XG4gICAgY29uc3QgcGl4ZWwgPSB0aGlzLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gX2ludDE2UmFuZ2UodGhpcy5fYWxpZ25Ub1BpeGVscyA/IF9hbGlnblBpeGVsKHRoaXMuY2hhcnQsIHBpeGVsLCAwKSA6IHBpeGVsKTtcbiAgfVxuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0QmFzZVZhbHVlKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIHJldHVybiBtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuICAgICAgbWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcbiAgICAgIDA7XG4gIH1cbiAgZ2V0Q29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyB8fCBbXTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XG5cdFx0XHRcdCh0aWNrLiRjb250ZXh0ID0gY3JlYXRlVGlja0NvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCByb3QgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG4gICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG4gIF9pc1Zpc2libGUoKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcbiAgfVxuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb259ID0gb3B0aW9ucztcbiAgICBjb25zdCBvZmZzZXQgPSBncmlkLm9mZnNldDtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aCArIChvZmZzZXQgPyAxIDogMCk7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZHJhd0JvcmRlciA/IGJvcmRlck9wdHMuYm9yZGVyV2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmJvdHRvbSk7XG4gICAgICB0eTEgPSB0aGlzLmJvdHRvbSAtIHRsO1xuICAgICAgdHkyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeTEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS50b3ApICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMudG9wKTtcbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEuYm90dG9tKSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0aGlzLnRvcCArIHRsO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMucmlnaHQpO1xuICAgICAgdHgxID0gdGhpcy5yaWdodCAtIHRsO1xuICAgICAgdHgyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeDEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5sZWZ0KSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5sZWZ0KTtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnJpZ2h0KSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0aGlzLmxlZnQgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIgKyAwLjUpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHR5MSArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdHgxIC0gdGw7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0LCB0aWNrc0xlbmd0aCk7XG4gICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0aWNrc0xlbmd0aCAvIGxpbWl0KSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRpY2tzTGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBvcHRzQXRJbmRleC5saW5lV2lkdGg7XG4gICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBjb25zdCB0aWNrV2lkdGggPSBvcHRzQXRJbmRleC50aWNrV2lkdGg7XG4gICAgICBjb25zdCB0aWNrQ29sb3IgPSBvcHRzQXRJbmRleC50aWNrQ29sb3I7XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGxpbmVWYWx1ZSA9IGdldFBpeGVsRm9yR3JpZExpbmUodGhpcywgaSwgb2Zmc2V0KTtcbiAgICAgIGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHR4MSxcbiAgICAgICAgdHkxLFxuICAgICAgICB0eDIsXG4gICAgICAgIHR5MixcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MixcbiAgICAgICAgeTIsXG4gICAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgIGNvbG9yOiBsaW5lQ29sb3IsXG4gICAgICAgIGJvcmRlckRhc2gsXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgIHRpY2tXaWR0aCxcbiAgICAgICAgdGlja0NvbG9yLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBfY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IG9wdGlvblRpY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3Qge2FsaWduLCBjcm9zc0FsaWduLCBwYWRkaW5nLCBtaXJyb3J9ID0gb3B0aW9uVGlja3M7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IGhUaWNrQW5kUGFkZGluZyA9IG1pcnJvciA/IC1wYWRkaW5nIDogdGlja0FuZFBhZGRpbmc7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdGljaywgbGFiZWwsIHgsIHksIHRleHRBbGlnbiwgcGl4ZWwsIGZvbnQsIGxpbmVIZWlnaHQsIGxpbmVDb3VudCwgdGV4dE9mZnNldDtcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgeSA9IHRoaXMuYm90dG9tIC0gaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICB5ID0gdGhpcy50b3AgKyBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHkgPSAoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHkgPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB4ID0gKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKSAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB4ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkudGV4dEFsaWduO1xuICAgIH1cbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IG9wdGlvblRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcbiAgICAgIHBpeGVsID0gdGhpcy5nZXRQaXhlbEZvclRpY2soaSkgKyBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDtcbiAgICAgIGZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgbGluZUhlaWdodCA9IGZvbnQubGluZUhlaWdodDtcbiAgICAgIGxpbmVDb3VudCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IGhhbGZDb3VudCA9IGxpbmVDb3VudCAvIDI7XG4gICAgICBjb25zdCBjb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3I7XG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aDtcbiAgICAgIGxldCB0aWNrVGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB4ID0gcGl4ZWw7XG4gICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGluZUNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxpbmVDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ID0gcGl4ZWw7XG4gICAgICAgIHRleHRPZmZzZXQgPSAoMSAtIGxpbmVDb3VudCkgKiBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgIH1cbiAgICAgIGxldCBiYWNrZHJvcDtcbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBsYWJlbFBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGxhYmVsU2l6ZXMud2lkdGhzW2ldO1xuICAgICAgICBsZXQgdG9wID0geSArIHRleHRPZmZzZXQgLSBsYWJlbFBhZGRpbmcudG9wO1xuICAgICAgICBsZXQgbGVmdCA9IHggLSBsYWJlbFBhZGRpbmcubGVmdDtcbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJhY2tkcm9wID0ge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCArIGxhYmVsUGFkZGluZy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArIGxhYmVsUGFkZGluZy5oZWlnaHQsXG4gICAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3IsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmb250LFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB0ZXh0T2Zmc2V0LFxuICAgICAgICB0ZXh0QWxpZ246IHRpY2tUZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgICAgdHJhbnNsYXRpb246IFt4LCB5XSxcbiAgICAgICAgYmFja2Ryb3AsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3N9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfVxuICAgIGxldCBhbGlnbiA9ICdjZW50ZXInO1xuICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICBhbGlnbiA9ICdpbm5lcic7XG4gICAgfVxuICAgIHJldHVybiBhbGlnbjtcbiAgfVxuICBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IHtjcm9zc0FsaWduLCBtaXJyb3IsIHBhZGRpbmd9fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IHdpZGVzdCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGxldCB0ZXh0QWxpZ247XG4gICAgbGV0IHg7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ICs9IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggLT0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9IHdpZGVzdCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ID0gdGhpcy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4ge3RleHRBbGlnbiwgeH07XG4gIH1cbiAgX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aWNrcy5taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogdGhpcy5sZWZ0LCBib3R0b206IGNoYXJ0LmhlaWdodCwgcmlnaHQ6IHRoaXMucmlnaHR9O1xuICAgIH0gaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiB7dG9wOiB0aGlzLnRvcCwgbGVmdDogMCwgYm90dG9tOiB0aGlzLmJvdHRvbSwgcmlnaHQ6IGNoYXJ0LndpZHRofTtcbiAgICB9XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge2JhY2tncm91bmRDb2xvcn0sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFncmlkLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgaW5kZXggPSB0aWNrcy5maW5kSW5kZXgodCA9PiB0LnZhbHVlID09PSB2YWx1ZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuZHJhd1RpY2tzKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS50eDEsIHk6IGl0ZW0udHkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MiwgeTogaXRlbS50eTJ9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXG4gICAgICAgICAgICAgIHdpZHRoOiBpdGVtLnRpY2tXaWR0aCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaDogaXRlbS50aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHtcbiAgICBjb25zdCB7Y2hhcnQsIGN0eCwgb3B0aW9uczoge2dyaWR9fSA9IHRoaXM7XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gZ3JpZC5kcmF3Qm9yZGVyID8gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aCA6IDA7XG4gICAgaWYgKCFheGlzV2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdExpbmVXaWR0aCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aDtcbiAgICBjb25zdCBib3JkZXJWYWx1ZSA9IHRoaXMuX2JvcmRlclZhbHVlO1xuICAgIGxldCB4MSwgeDIsIHkxLCB5MjtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMudG9wLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHkyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeDEgPSB4MiA9IGJvcmRlclZhbHVlO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJPcHRzLmJvcmRlcldpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlck9wdHMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd0xhYmVscyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2NvbXB1dGVMYWJlbEFyZWEoKTtcbiAgICBpZiAoYXJlYSkge1xuICAgICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYWJlbEl0ZW1zIHx8ICh0aGlzLl9sYWJlbEl0ZW1zID0gdGhpcy5fY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSBpdGVtLmZvbnQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGl0ZW0ubGFiZWw7XG4gICAgICBpZiAoaXRlbS5iYWNrZHJvcCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gaXRlbS5iYWNrZHJvcC5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGl0ZW0uYmFja2Ryb3AubGVmdCwgaXRlbS5iYWNrZHJvcC50b3AsIGl0ZW0uYmFja2Ryb3Aud2lkdGgsIGl0ZW0uYmFja2Ryb3AuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGxldCB5ID0gaXRlbS50ZXh0T2Zmc2V0O1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxhYmVsLCAwLCB5LCB0aWNrRm9udCwgaXRlbSk7XG4gICAgfVxuICAgIGlmIChhcmVhKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9zaXRpb24sIHRpdGxlLCByZXZlcnNlfX0gPSB0aGlzO1xuICAgIGlmICghdGl0bGUuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250ID0gdG9Gb250KHRpdGxlLmZvbnQpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGUucGFkZGluZyk7XG4gICAgY29uc3QgYWxpZ24gPSB0aXRsZS5hbGlnbjtcbiAgICBsZXQgb2Zmc2V0ID0gZm9udC5saW5lSGVpZ2h0IC8gMjtcbiAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nIHx8IHBvc2l0aW9uID09PSAnY2VudGVyJyB8fCBpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLmJvdHRvbTtcbiAgICAgIGlmIChpc0FycmF5KHRpdGxlLnRleHQpKSB7XG4gICAgICAgIG9mZnNldCArPSBmb250LmxpbmVIZWlnaHQgKiAodGl0bGUudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcudG9wO1xuICAgIH1cbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aXRsZUFyZ3ModGhpcywgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pO1xuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZS50ZXh0LCAwLCAwLCBmb250LCB7XG4gICAgICBjb2xvcjogdGl0bGUuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbiAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuICBfbGF5ZXJzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdHogPSBvcHRzLnRpY2tzICYmIG9wdHMudGlja3MueiB8fCAwO1xuICAgIGNvbnN0IGd6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ncmlkICYmIG9wdHMuZ3JpZC56LCAtMSk7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCB0aGlzLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgICB0aGlzLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBbe1xuICAgICAgejogZ3osXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICAgICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgICAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IGd6ICsgMSxcbiAgICAgIGRyYXc6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogdHosXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1dO1xuICB9XG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpIHtcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICAgIGlmIChtZXRhW2F4aXNJRF0gPT09IHRoaXMuaWQgJiYgKCF0eXBlIHx8IG1ldGEudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICB9XG59XG5cbmNsYXNzIFR5cGVkUmVnaXN0cnkge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzY29wZSwgb3ZlcnJpZGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5pdGVtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgaXNGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICB9XG4gIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpdGVtKTtcbiAgICBsZXQgcGFyZW50U2NvcGU7XG4gICAgaWYgKGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSkge1xuICAgICAgcGFyZW50U2NvcGUgPSB0aGlzLnJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGUgKyAnLicgKyBpZDtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGRvZXMgbm90IGhhdmUgaWQ6ICcgKyBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICAgIGl0ZW1zW2lkXSA9IGl0ZW07XG4gICAgcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICBkZWZhdWx0cy5vdmVycmlkZShpdGVtLmlkLCBpdGVtLm92ZXJyaWRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XG4gIH1cbiAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGU7XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgIH1cbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XG4gICAgICBkZWxldGUgZGVmYXVsdHNbc2NvcGVdW2lkXTtcbiAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgIHBhcmVudFNjb3BlID8gZGVmYXVsdHMuZ2V0KHBhcmVudFNjb3BlKSA6IHt9LFxuICAgIGRlZmF1bHRzLmdldChzY29wZSksXG4gICAgaXRlbS5kZWZhdWx0c1xuICBdKTtcbiAgZGVmYXVsdHMuc2V0KHNjb3BlLCBpdGVtRGVmYXVsdHMpO1xuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgcm91dGVEZWZhdWx0cyhzY29wZSwgaXRlbS5kZWZhdWx0Um91dGVzKTtcbiAgfVxuICBpZiAoaXRlbS5kZXNjcmlwdG9ycykge1xuICAgIGRlZmF1bHRzLmRlc2NyaWJlKHNjb3BlLCBpdGVtLmRlc2NyaXB0b3JzKTtcbiAgfVxufVxuZnVuY3Rpb24gcm91dGVEZWZhdWx0cyhzY29wZSwgcm91dGVzKSB7XG4gIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgY29uc3Qgc291cmNlU2NvcGUgPSBbc2NvcGVdLmNvbmNhdChwcm9wZXJ0eVBhcnRzKS5qb2luKCcuJyk7XG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlID0gcGFydHMuam9pbignLicpO1xuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcbiAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cblxuY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFR5cGVkUmVnaXN0cnkoRGF0YXNldENvbnRyb2xsZXIsICdkYXRhc2V0cycsIHRydWUpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgVHlwZWRSZWdpc3RyeShPYmplY3QsICdwbHVnaW5zJyk7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgVHlwZWRSZWdpc3RyeShTY2FsZSwgJ3NjYWxlcycpO1xuICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFt0aGlzLmNvbnRyb2xsZXJzLCB0aGlzLnNjYWxlcywgdGhpcy5lbGVtZW50c107XG4gIH1cbiAgYWRkKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIGFkZENvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG4gIGFkZFBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICBhZGRTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG4gIGdldEVsZW1lbnQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmVsZW1lbnRzLCAnZWxlbWVudCcpO1xuICB9XG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG4gIGdldFNjYWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5zY2FsZXMsICdzY2FsZScpO1xuICB9XG4gIHJlbW92ZUNvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cbiAgcmVtb3ZlRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICByZW1vdmVQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cbiAgX2VhY2gobWV0aG9kLCBhcmdzLCB0eXBlZFJlZ2lzdHJ5KSB7XG4gICAgWy4uLmFyZ3NdLmZvckVhY2goYXJnID0+IHtcbiAgICAgIGNvbnN0IHJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGFyZyk7XG4gICAgICBpZiAodHlwZWRSZWdpc3RyeSB8fCByZWcuaXNGb3JUeXBlKGFyZykgfHwgKHJlZyA9PT0gdGhpcy5wbHVnaW5zICYmIGFyZy5pZCkpIHtcbiAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIHJlZywgYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhY2goYXJnLCBpdGVtID0+IHtcbiAgICAgICAgICBjb25zdCBpdGVtUmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoaXRlbSk7XG4gICAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIGl0ZW1SZWcsIGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZXhlYyhtZXRob2QsIHJlZ2lzdHJ5LCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBjYW1lbE1ldGhvZCA9IF9jYXBpdGFsaXplKG1ldGhvZCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydiZWZvcmUnICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgICByZWdpc3RyeVttZXRob2RdKGNvbXBvbmVudCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydhZnRlcicgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpO1xuICB9XG4gIF9nZXRSZWdpc3RyeUZvclR5cGUodHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWcgPSB0aGlzLl90eXBlZFJlZ2lzdHJpZXNbaV07XG4gICAgICBpZiAocmVnLmlzRm9yVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcmVnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG4gIF9nZXQoaWQsIHR5cGVkUmVnaXN0cnksIHR5cGUpIHtcbiAgICBjb25zdCBpdGVtID0gdHlwZWRSZWdpc3RyeS5nZXQoaWQpO1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgaWQgKyAnXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCAnICsgdHlwZSArICcuJyk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG59XG52YXIgcmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkoKTtcblxuY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuICBub3RpZnkoY2hhcnQsIGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIGlmIChob29rID09PSAnYmVmb3JlSW5pdCcpIHtcbiAgICAgIHRoaXMuX2luaXQgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgdHJ1ZSk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICdpbnN0YWxsJyk7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuICAgIGlmIChob29rID09PSAnYWZ0ZXJEZXN0cm95Jykge1xuICAgICAgdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgJ3N0b3AnKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ3VuaW5zdGFsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBsdWdpbltob29rXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcbiAgICAgIGlmIChjYWxsYmFjayhtZXRob2QsIHBhcmFtcywgcGx1Z2luKSA9PT0gZmFsc2UgJiYgYXJncy5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodGhpcy5fY2FjaGUpKSB7XG4gICAgICB0aGlzLl9vbGRDYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgdGhpcy5fY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIF9kZXNjcmlwdG9ycyhjaGFydCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCk7XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG4gIF9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgYWxsKSB7XG4gICAgY29uc3QgY29uZmlnID0gY2hhcnQgJiYgY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZU9yRGVmYXVsdChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gICAgY29uc3QgcGx1Z2lucyA9IGFsbFBsdWdpbnMoY29uZmlnKTtcbiAgICByZXR1cm4gb3B0aW9ucyA9PT0gZmFsc2UgJiYgIWFsbCA/IFtdIDogY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHBsdWdpbnMsIG9wdGlvbnMsIGFsbCk7XG4gIH1cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgIGNvbnN0IHByZXZpb3VzRGVzY3JpcHRvcnMgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYocHJldmlvdXNEZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0b3AnKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgfVxufVxuZnVuY3Rpb24gYWxsUGx1Z2lucyhjb25maWcpIHtcbiAgY29uc3QgbG9jYWxJZHMgPSB7fTtcbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGx1Z2lucy5pdGVtcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHBsdWdpbnMucHVzaChyZWdpc3RyeS5nZXRQbHVnaW4oa2V5c1tpXSkpO1xuICB9XG4gIGNvbnN0IGxvY2FsID0gY29uZmlnLnBsdWdpbnMgfHwgW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIGxvY2FsSWRzW3BsdWdpbi5pZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge3BsdWdpbnMsIGxvY2FsSWRzfTtcbn1cbmZ1bmN0aW9uIGdldE9wdHMob3B0aW9ucywgYWxsKSB7XG4gIGlmICghYWxsICYmIG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwge3BsdWdpbnMsIGxvY2FsSWRzfSwgb3B0aW9ucywgYWxsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBjb250ZXh0ID0gY2hhcnQuZ2V0Q29udGV4dCgpO1xuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBwbHVnaW4sXG4gICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywge3BsdWdpbiwgbG9jYWw6IGxvY2FsSWRzW2lkXX0sIG9wdHMsIGNvbnRleHQpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBsdWdpbk9wdHMoY29uZmlnLCB7cGx1Z2luLCBsb2NhbH0sIG9wdHMsIGNvbnRleHQpIHtcbiAgY29uc3Qga2V5cyA9IGNvbmZpZy5wbHVnaW5TY29wZUtleXMocGx1Z2luKTtcbiAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhvcHRzLCBrZXlzKTtcbiAgaWYgKGxvY2FsICYmIHBsdWdpbi5kZWZhdWx0cykge1xuICAgIHNjb3Blcy5wdXNoKHBsdWdpbi5kZWZhdWx0cyk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIFsnJ10sIHtcbiAgICBzY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBpbmRleGFibGU6IGZhbHNlLFxuICAgIGFsbEtleXM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9O1xuICBjb25zdCBkYXRhc2V0T3B0aW9ucyA9IChvcHRpb25zLmRhdGFzZXRzIHx8IHt9KVt0eXBlXSB8fCB7fTtcbiAgcmV0dXJuIGRhdGFzZXRPcHRpb25zLmluZGV4QXhpcyB8fCBvcHRpb25zLmluZGV4QXhpcyB8fCBkYXRhc2V0RGVmYXVsdHMuaW5kZXhBeGlzIHx8ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoaWQsIGluZGV4QXhpcykge1xuICBsZXQgYXhpcyA9IGlkO1xuICBpZiAoaWQgPT09ICdfaW5kZXhfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXM7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICdfdmFsdWVfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgfVxuICByZXR1cm4gYXhpcztcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgaW5kZXhBeGlzKSB7XG4gIHJldHVybiBheGlzID09PSBpbmRleEF4aXMgPyAnX2luZGV4XycgOiAnX3ZhbHVlXyc7XG59XG5mdW5jdGlvbiBheGlzRnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd4JztcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAneSc7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucykge1xuICBpZiAoaWQgPT09ICd4JyB8fCBpZCA9PT0gJ3knKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHJldHVybiBzY2FsZU9wdGlvbnMuYXhpcyB8fCBheGlzRnJvbVBvc2l0aW9uKHNjYWxlT3B0aW9ucy5wb3NpdGlvbikgfHwgaWQuY2hhckF0KDApLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucykge1xuICBjb25zdCBjaGFydERlZmF1bHRzID0gb3ZlcnJpZGVzW2NvbmZpZy50eXBlXSB8fCB7c2NhbGVzOiB7fX07XG4gIGNvbnN0IGNvbmZpZ1NjYWxlcyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICBjb25zdCBjaGFydEluZGV4QXhpcyA9IGdldEluZGV4QXhpcyhjb25maWcudHlwZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGZpcnN0SURzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgc2NhbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgT2JqZWN0LmtleXMoY29uZmlnU2NhbGVzKS5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBzY2FsZUNvbmYgPSBjb25maWdTY2FsZXNbaWRdO1xuICAgIGlmICghaXNPYmplY3Qoc2NhbGVDb25mKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgc2NhbGUgY29uZmlndXJhdGlvbiBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGlmIChzY2FsZUNvbmYuX3Byb3h5KSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKGBJZ25vcmluZyByZXNvbHZlciBwYXNzZWQgYXMgb3B0aW9ucyBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZUNvbmYpO1xuICAgIGNvbnN0IGRlZmF1bHRJZCA9IGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgY2hhcnRJbmRleEF4aXMpO1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBjaGFydERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBmaXJzdElEc1theGlzXSA9IGZpcnN0SURzW2F4aXNdIHx8IGlkO1xuICAgIHNjYWxlc1tpZF0gPSBtZXJnZUlmKE9iamVjdC5jcmVhdGUobnVsbCksIFt7YXhpc30sIHNjYWxlQ29uZiwgZGVmYXVsdFNjYWxlT3B0aW9uc1theGlzXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SWRdXSk7XG4gIH0pO1xuICBjb25maWcuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGRhdGFzZXQgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgY29uZmlnLnR5cGU7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IG92ZXJyaWRlc1t0eXBlXSB8fCB7fTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gZGF0YXNldERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhkZWZhdWx0U2NhbGVPcHRpb25zKS5mb3JFYWNoKGRlZmF1bHRJRCA9PiB7XG4gICAgICBjb25zdCBheGlzID0gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChkZWZhdWx0SUQsIGluZGV4QXhpcyk7XG4gICAgICBjb25zdCBpZCA9IGRhdGFzZXRbYXhpcyArICdBeGlzSUQnXSB8fCBmaXJzdElEc1theGlzXSB8fCBheGlzO1xuICAgICAgc2NhbGVzW2lkXSA9IHNjYWxlc1tpZF0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG1lcmdlSWYoc2NhbGVzW2lkXSwgW3theGlzfSwgY29uZmlnU2NhbGVzW2lkXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SURdXSk7XG4gICAgfSk7XG4gIH0pO1xuICBPYmplY3Qua2V5cyhzY2FsZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1trZXldO1xuICAgIG1lcmdlSWYoc2NhbGUsIFtkZWZhdWx0cy5zY2FsZXNbc2NhbGUudHlwZV0sIGRlZmF1bHRzLnNjYWxlXSk7XG4gIH0pO1xuICByZXR1cm4gc2NhbGVzO1xufVxuZnVuY3Rpb24gaW5pdE9wdGlvbnMoY29uZmlnKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjb25maWcub3B0aW9ucyB8fCAoY29uZmlnLm9wdGlvbnMgPSB7fSk7XG4gIG9wdGlvbnMucGx1Z2lucyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMucGx1Z2lucywge30pO1xuICBvcHRpb25zLnNjYWxlcyA9IG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGluaXREYXRhKGRhdGEpIHtcbiAgZGF0YSA9IGRhdGEgfHwge307XG4gIGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuICBkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGluaXRDb25maWcoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgY29uZmlnLmRhdGEgPSBpbml0RGF0YShjb25maWcuZGF0YSk7XG4gIGluaXRPcHRpb25zKGNvbmZpZyk7XG4gIHJldHVybiBjb25maWc7XG59XG5jb25zdCBrZXlDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IGtleXNDYWNoZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBjYWNoZWRLZXlzKGNhY2hlS2V5LCBnZW5lcmF0ZSkge1xuICBsZXQga2V5cyA9IGtleUNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSBnZW5lcmF0ZSgpO1xuICAgIGtleUNhY2hlLnNldChjYWNoZUtleSwga2V5cyk7XG4gICAga2V5c0NhY2hlZC5hZGQoa2V5cyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5jb25zdCBhZGRJZkZvdW5kID0gKHNldCwgb2JqLCBrZXkpID0+IHtcbiAgY29uc3Qgb3B0cyA9IHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpO1xuICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0LmFkZChvcHRzKTtcbiAgfVxufTtcbmNsYXNzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuX2NvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9zY29wZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0IHBsYXRmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGxhdGZvcm07XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50eXBlO1xuICB9XG4gIHNldCB0eXBlKHR5cGUpIHtcbiAgICB0aGlzLl9jb25maWcudHlwZSA9IHR5cGU7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kYXRhO1xuICB9XG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLl9jb25maWcuZGF0YSA9IGluaXREYXRhKGRhdGEpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcub3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGdldCBwbHVnaW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGx1Z2lucztcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5fY29uZmlnO1xuICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgIGluaXRPcHRpb25zKGNvbmZpZyk7XG4gIH1cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9zY29wZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZS5jbGVhcigpO1xuICB9XG4gIGRhdGFzZXRTY29wZUtleXMoZGF0YXNldFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhkYXRhc2V0VHlwZSxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cbiAgZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgdHJhbnNpdGlvbikge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9uLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICAgIGB0cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICAgJydcbiAgICAgICAgXVxuICAgICAgXSk7XG4gIH1cbiAgZGF0YXNldEVsZW1lbnRTY29wZUtleXMoZGF0YXNldFR5cGUsIGVsZW1lbnRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LSR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS5lbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgIGBlbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cbiAgcGx1Z2luU2NvcGVLZXlzKHBsdWdpbikge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7dHlwZX0tcGx1Z2luLSR7aWR9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBwbHVnaW5zLiR7aWR9YCxcbiAgICAgICAgLi4ucGx1Z2luLmFkZGl0aW9uYWxPcHRpb25TY29wZXMgfHwgW10sXG4gICAgICBdXSk7XG4gIH1cbiAgX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCBfc2NvcGVDYWNoZSA9IHRoaXMuX3Njb3BlQ2FjaGU7XG4gICAgbGV0IGNhY2hlID0gX3Njb3BlQ2FjaGUuZ2V0KG1haW5TY29wZSk7XG4gICAgaWYgKCFjYWNoZSB8fCByZXNldENhY2hlKSB7XG4gICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgIF9zY29wZUNhY2hlLnNldChtYWluU2NvcGUsIGNhY2hlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9XG4gIGdldE9wdGlvblNjb3BlcyhtYWluU2NvcGUsIGtleUxpc3RzLCByZXNldENhY2hlKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXlMaXN0cyk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzID0gbmV3IFNldCgpO1xuICAgIGtleUxpc3RzLmZvckVhY2goa2V5cyA9PiB7XG4gICAgICBpZiAobWFpblNjb3BlKSB7XG4gICAgICAgIHNjb3Blcy5hZGQobWFpblNjb3BlKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgbWFpblNjb3BlLCBrZXkpKTtcbiAgICAgIH1cbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG9wdGlvbnMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlZmF1bHRzLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlc2NyaXB0b3JzLCBrZXkpKTtcbiAgICB9KTtcbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20oc2NvcGVzKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICBhcnJheS5wdXNoKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cbiAgICBpZiAoa2V5c0NhY2hlZC5oYXMoa2V5TGlzdHMpKSB7XG4gICAgICBjYWNoZS5zZXQoa2V5TGlzdHMsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvdmVycmlkZXNbdHlwZV0gfHwge30sXG4gICAgICBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fSxcbiAgICAgIHt0eXBlfSxcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgZGVzY3JpcHRvcnNcbiAgICBdO1xuICB9XG4gIHJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyRzaGFyZWQ6IHRydWV9O1xuICAgIGNvbnN0IHtyZXNvbHZlciwgc3ViUHJlZml4ZXN9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgbGV0IG9wdGlvbnMgPSByZXNvbHZlcjtcbiAgICBpZiAobmVlZENvbnRleHQocmVzb2x2ZXIsIG5hbWVzKSkge1xuICAgICAgcmVzdWx0LiRzaGFyZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQgPSBpc0Z1bmN0aW9uKGNvbnRleHQpID8gY29udGV4dCgpIDogY29udGV4dDtcbiAgICAgIGNvbnN0IHN1YlJlc29sdmVyID0gdGhpcy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHN1YlByZWZpeGVzKTtcbiAgICAgIG9wdGlvbnMgPSBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgc3ViUmVzb2x2ZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10sIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICAgIGNvbnN0IHtyZXNvbHZlcn0gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICByZXR1cm4gaXNPYmplY3QoY29udGV4dClcbiAgICAgID8gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHVuZGVmaW5lZCwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICAgICAgOiByZXNvbHZlcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIocmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcykge1xuICBsZXQgY2FjaGUgPSByZXNvbHZlckNhY2hlLmdldChzY29wZXMpO1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmVzb2x2ZXJDYWNoZS5zZXQoc2NvcGVzLCBjYWNoZSk7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBwcmVmaXhlcy5qb2luKCk7XG4gIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWNhY2hlZCkge1xuICAgIGNvbnN0IHJlc29sdmVyID0gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGNhY2hlZCA9IHtcbiAgICAgIHJlc29sdmVyLFxuICAgICAgc3ViUHJlZml4ZXM6IHByZWZpeGVzLmZpbHRlcihwID0+ICFwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hvdmVyJykpXG4gICAgfTtcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlZDtcbn1cbmNvbnN0IGhhc0Z1bmN0aW9uID0gdmFsdWUgPT4gaXNPYmplY3QodmFsdWUpXG4gICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2MgfHwgaXNGdW5jdGlvbih2YWx1ZVtrZXldKSwgZmFsc2UpO1xuZnVuY3Rpb24gbmVlZENvbnRleHQocHJveHksIG5hbWVzKSB7XG4gIGNvbnN0IHtpc1NjcmlwdGFibGUsIGlzSW5kZXhhYmxlfSA9IF9kZXNjcmlwdG9ycyhwcm94eSk7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgIGNvbnN0IHNjcmlwdGFibGUgPSBpc1NjcmlwdGFibGUocHJvcCk7XG4gICAgY29uc3QgaW5kZXhhYmxlID0gaXNJbmRleGFibGUocHJvcCk7XG4gICAgY29uc3QgdmFsdWUgPSAoaW5kZXhhYmxlIHx8IHNjcmlwdGFibGUpICYmIHByb3h5W3Byb3BdO1xuICAgIGlmICgoc2NyaXB0YWJsZSAmJiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaGFzRnVuY3Rpb24odmFsdWUpKSlcbiAgICAgIHx8IChpbmRleGFibGUgJiYgaXNBcnJheSh2YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMy45LjFcIjtcblxuY29uc3QgS05PV05fUE9TSVRJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAnY2hhcnRBcmVhJ107XG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbiwgYXhpcykge1xuICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCAoS05PV05fUE9TSVRJT05TLmluZGV4T2YocG9zaXRpb24pID09PSAtMSAmJiBheGlzID09PSAneCcpO1xufVxuZnVuY3Rpb24gY29tcGFyZTJMZXZlbChsMSwgbDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYVtsMV0gPT09IGJbbDFdXG4gICAgICA/IGFbbDJdIC0gYltsMl1cbiAgICAgIDogYVtsMV0gLSBiW2wxXTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uc0NvbXBsZXRlKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyUmVuZGVyJyk7XG4gIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uUHJvZ3Jlc3MoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uUHJvZ3Jlc3MsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuZnVuY3Rpb24gZ2V0Q2FudmFzKGl0ZW0pIHtcbiAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpICYmIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtICYmIGl0ZW0ubGVuZ3RoKSB7XG4gICAgaXRlbSA9IGl0ZW1bMF07XG4gIH1cbiAgaWYgKGl0ZW0gJiYgaXRlbS5jYW52YXMpIHtcbiAgICBpdGVtID0gaXRlbS5jYW52YXM7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcbmNvbnN0IGdldENoYXJ0ID0gKGtleSkgPT4ge1xuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoa2V5KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaW5zdGFuY2VzKS5maWx0ZXIoKGMpID0+IGMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xufTtcbmZ1bmN0aW9uIG1vdmVOdW1lcmljS2V5cyhvYmosIHN0YXJ0LCBtb3ZlKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgaW50S2V5ID0gK2tleTtcbiAgICBpZiAoaW50S2V5ID49IHN0YXJ0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgaWYgKG1vdmUgPiAwIHx8IGludEtleSA+IHN0YXJ0KSB7XG4gICAgICAgIG9ialtpbnRLZXkgKyBtb3ZlXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIGxhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spIHtcbiAgaWYgKCFpbkNoYXJ0QXJlYSB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNDbGljaykge1xuICAgIHJldHVybiBsYXN0RXZlbnQ7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5jbGFzcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKGl0ZW0sIHVzZXJDb25maWcpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcodXNlckNvbmZpZyk7XG4gICAgY29uc3QgaW5pdGlhbENhbnZhcyA9IGdldENhbnZhcyhpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0NoYXJ0ID0gZ2V0Q2hhcnQoaW5pdGlhbENhbnZhcyk7XG4gICAgaWYgKGV4aXN0aW5nQ2hhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NhbnZhcyBpcyBhbHJlYWR5IGluIHVzZS4gQ2hhcnQgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5pZCArICdcXCcnICtcblx0XHRcdFx0JyBtdXN0IGJlIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNhbnZhcyB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmNhbnZhcy5pZCArICdcXCcgY2FuIGJlIHJldXNlZC4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICB0aGlzLnBsYXRmb3JtLnVwZGF0ZUNvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGluaXRpYWxDYW52YXMsIG9wdGlvbnMuYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQgJiYgY29udGV4dC5jYW52YXM7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuICAgIHRoaXMuaWQgPSB1aWQoKTtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJveGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5fcGx1Z2lucyA9IG5ldyBQbHVnaW5TZXJ2aWNlKCk7XG4gICAgdGhpcy4kcHJveGllcyA9IHt9O1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXMgPSB7fTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZG9SZXNpemUgPSBkZWJvdW5jZShtb2RlID0+IHRoaXMudXBkYXRlKG1vZGUpLCBvcHRpb25zLnJlc2l6ZURlbGF5IHx8IDApO1xuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgaW5zdGFuY2VzW3RoaXMuaWRdID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcbiAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICBjb25zdCB7b3B0aW9uczoge2FzcGVjdFJhdGlvLCBtYWludGFpbkFzcGVjdFJhdGlvfSwgd2lkdGgsIGhlaWdodCwgX2FzcGVjdFJhdGlvfSA9IHRoaXM7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGFzcGVjdFJhdGlvKSkge1xuICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBpZiAobWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBfYXNwZWN0UmF0aW8pIHtcbiAgICAgIHJldHVybiBfYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuY29uZmlnLmRhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldGluYVNjYWxlKHRoaXMsIHRoaXMub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9XG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICBjbGVhckNhbnZhcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgfVxuICBfcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gb3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMucGxhdGZvcm0uZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgbmV3UmF0aW8gPSBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8gfHwgdGhpcy5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgY29uc3QgbW9kZSA9IHRoaXMud2lkdGggPyAncmVzaXplJyA6ICdhdHRhY2gnO1xuICAgIHRoaXMud2lkdGggPSBuZXdTaXplLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3U2l6ZS5oZWlnaHQ7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGlmICghcmV0aW5hU2NhbGUodGhpcywgbmV3UmF0aW8sIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzaXplJywge3NpemU6IG5ld1NpemV9KTtcbiAgICBjYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbdGhpcywgbmV3U2l6ZV0sIHRoaXMpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBpZiAodGhpcy5fZG9SZXNpemUobW9kZSkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5zdXJlU2NhbGVzSGF2ZUlEcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgICBlYWNoKHNjYWxlc09wdGlvbnMsIChheGlzT3B0aW9ucywgYXhpc0lEKSA9PiB7XG4gICAgICBheGlzT3B0aW9ucy5pZCA9IGF4aXNJRDtcbiAgICB9KTtcbiAgfVxuICBidWlsZE9yVXBkYXRlU2NhbGVzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVPcHRzID0gb3B0aW9ucy5zY2FsZXM7XG4gICAgY29uc3Qgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKChvYmosIGlkKSA9PiB7XG4gICAgICBvYmpbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICBpZiAoc2NhbGVPcHRzKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc2NhbGVPcHRzKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGVPcHRzW2lkXTtcbiAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgICAgICBjb25zdCBpc1JhZGlhbCA9IGF4aXMgPT09ICdyJztcbiAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBheGlzID09PSAneCc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcbiAgICAgICAgICAgIGRwb3NpdGlvbjogaXNSYWRpYWwgPyAnY2hhcnRBcmVhJyA6IGlzSG9yaXpvbnRhbCA/ICdib3R0b20nIDogJ2xlZnQnLFxuICAgICAgICAgICAgZHR5cGU6IGlzUmFkaWFsID8gJ3JhZGlhbExpbmVhcicgOiBpc0hvcml6b250YWwgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcidcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgZWFjaChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG4gICAgICBpZiAoc2NhbGVPcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uLCBheGlzKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XG4gICAgICAgIHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9IGl0ZW0uZHBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgdXBkYXRlZFtpZF0gPSB0cnVlO1xuICAgICAgbGV0IHNjYWxlID0gbnVsbDtcbiAgICAgIGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcbiAgICAgICAgc2NhbGUgPSBzY2FsZXNbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2NhbGVDbGFzcyA9IHJlZ2lzdHJ5LmdldFNjYWxlKHNjYWxlVHlwZSk7XG4gICAgICAgIHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHR5cGU6IHNjYWxlVHlwZSxcbiAgICAgICAgICBjdHg6IHRoaXMuY3R4LFxuICAgICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG4gICAgICB9XG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgZWFjaCh1cGRhdGVkLCAoaGFzVXBkYXRlZCwgaWQpID0+IHtcbiAgICAgIGlmICghaGFzVXBkYXRlZCkge1xuICAgICAgICBkZWxldGUgc2NhbGVzW2lkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlYWNoKHNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLmNvbmZpZ3VyZSh0aGlzLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZU1ldGFzZXRzKCkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgY29uc3QgbnVtRGF0YSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtTWV0YSA9IG1ldGFzZXRzLmxlbmd0aDtcbiAgICBtZXRhc2V0cy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gICAgaWYgKG51bU1ldGEgPiBudW1EYXRhKSB7XG4gICAgICBmb3IgKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gIH1cbiAgX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCkge1xuICAgIGNvbnN0IHtfbWV0YXNldHM6IG1ldGFzZXRzLCBkYXRhOiB7ZGF0YXNldHN9fSA9IHRoaXM7XG4gICAgaWYgKG1ldGFzZXRzLmxlbmd0aCA+IGRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N0YWNrcztcbiAgICB9XG4gICAgbWV0YXNldHMuZm9yRWFjaCgobWV0YSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChkYXRhc2V0cy5maWx0ZXIoeCA9PiB4ID09PSBtZXRhLl9kYXRhc2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcbiAgICAgIGxldCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgdGhpcy5jb25maWcudHlwZTtcbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XG4gICAgICBpZiAobWV0YS5jb250cm9sbGVyKSB7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci51cGRhdGVJbmRleChpKTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IENvbnRyb2xsZXJDbGFzcyA9IHJlZ2lzdHJ5LmdldENvbnRyb2xsZXIodHlwZSk7XG4gICAgICAgIGNvbnN0IHtkYXRhc2V0RWxlbWVudFR5cGUsIGRhdGFFbGVtZW50VHlwZX0gPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihDb250cm9sbGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFFbGVtZW50VHlwZSksXG4gICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBkYXRhc2V0RWxlbWVudFR5cGUgJiYgcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhc2V0RWxlbWVudFR5cGUpXG4gICAgICAgIH0pO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMsIGkpO1xuICAgICAgICBuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICB9XG4gIF9yZXNldEVsZW1lbnRzKCkge1xuICAgIGVhY2godGhpcy5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2V0Jyk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25maWcudXBkYXRlKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhbmltc0Rpc2FibGVkID0gdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gIW9wdGlvbnMuYW5pbWF0aW9uO1xuICAgIHRoaXMuX3VwZGF0ZVNjYWxlcygpO1xuICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xuICAgIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKTtcbiAgICB0aGlzLl9wbHVnaW5zLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFbGVtZW50c1VwZGF0ZScpO1xuICAgIGxldCBtaW5QYWRkaW5nID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHtjb250cm9sbGVyfSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCByZXNldCA9ICFhbmltc0Rpc2FibGVkICYmIG5ld0NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPT09IC0xO1xuICAgICAgY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXQpO1xuICAgICAgbWluUGFkZGluZyA9IE1hdGgubWF4KCtjb250cm9sbGVyLmdldE1heE92ZXJmbG93KCksIG1pblBhZGRpbmcpO1xuICAgIH1cbiAgICBtaW5QYWRkaW5nID0gdGhpcy5fbWluUGFkZGluZyA9IG9wdGlvbnMubGF5b3V0LmF1dG9QYWRkaW5nID8gbWluUGFkZGluZyA6IDA7XG4gICAgdGhpcy5fdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpO1xuICAgIGlmICghYW5pbXNEaXNhYmxlZCkge1xuICAgICAgZWFjaChuZXdDb250cm9sbGVycywgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJVcGRhdGUnLCB7bW9kZX0pO1xuICAgIHRoaXMuX2xheWVycy5zb3J0KGNvbXBhcmUyTGV2ZWwoJ3onLCAnX2lkeCcpKTtcbiAgICBjb25zdCB7X2FjdGl2ZSwgX2xhc3RFdmVudH0gPSB0aGlzO1xuICAgIGlmIChfbGFzdEV2ZW50KSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoX2xhc3RFdmVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChfYWN0aXZlLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoX2FjdGl2ZSwgX2FjdGl2ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgX3VwZGF0ZVNjYWxlcygpIHtcbiAgICBlYWNoKHRoaXMuc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMucmVtb3ZlQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgICB0aGlzLmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcbiAgICB0aGlzLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgfVxuICBfY2hlY2tFdmVudEJpbmRpbmdzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZXhpc3RpbmdFdmVudHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykpO1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IG5ldyBTZXQob3B0aW9ucy5ldmVudHMpO1xuICAgIGlmICghc2V0c0VxdWFsKGV4aXN0aW5nRXZlbnRzLCBuZXdFdmVudHMpIHx8ICEhdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyAhPT0gb3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVIaWRkZW5JbmRpY2VzKCkge1xuICAgIGNvbnN0IHtfaGlkZGVuSW5kaWNlc30gPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IHttZXRob2QsIHN0YXJ0LCBjb3VudH0gb2YgY2hhbmdlcykge1xuICAgICAgY29uc3QgbW92ZSA9IG1ldGhvZCA9PT0gJ19yZW1vdmVFbGVtZW50cycgPyAtY291bnQgOiBjb3VudDtcbiAgICAgIG1vdmVOdW1lcmljS2V5cyhfaGlkZGVuSW5kaWNlcywgc3RhcnQsIG1vdmUpO1xuICAgIH1cbiAgfVxuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgIGNvbnN0IF9kYXRhQ2hhbmdlcyA9IHRoaXMuX2RhdGFDaGFuZ2VzO1xuICAgIGlmICghX2RhdGFDaGFuZ2VzIHx8ICFfZGF0YUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgY29uc3QgZGF0YXNldENvdW50ID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBtYWtlU2V0ID0gKGlkeCkgPT4gbmV3IFNldChcbiAgICAgIF9kYXRhQ2hhbmdlc1xuICAgICAgICAuZmlsdGVyKGMgPT4gY1swXSA9PT0gaWR4KVxuICAgICAgICAubWFwKChjLCBpKSA9PiBpICsgJywnICsgYy5zcGxpY2UoMSkuam9pbignLCcpKVxuICAgICk7XG4gICAgY29uc3QgY2hhbmdlU2V0ID0gbWFrZVNldCgwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGFzZXRDb3VudDsgaSsrKSB7XG4gICAgICBpZiAoIXNldHNFcXVhbChjaGFuZ2VTZXQsIG1ha2VTZXQoaSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbmdlU2V0KVxuICAgICAgLm1hcChjID0+IGMuc3BsaXQoJywnKSlcbiAgICAgIC5tYXAoYSA9PiAoe21ldGhvZDogYVsxXSwgc3RhcnQ6ICthWzJdLCBjb3VudDogK2FbM119KSk7XG4gIH1cbiAgX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGF5b3V0cy51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIG1pblBhZGRpbmcpO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBub0FyZWEgPSBhcmVhLndpZHRoIDw9IDAgfHwgYXJlYS5oZWlnaHQgPD0gMDtcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpID0+IHtcbiAgICAgIGlmIChub0FyZWEgJiYgYm94LnBvc2l0aW9uID09PSAnY2hhcnRBcmVhJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYm94LmNvbmZpZ3VyZSkge1xuICAgICAgICBib3guY29uZmlndXJlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXllcnMucHVzaCguLi5ib3guX2xheWVycygpKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGl0ZW0uX2lkeCA9IGluZGV4O1xuICAgIH0pO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJMYXlvdXQnKTtcbiAgfVxuICBfdXBkYXRlRGF0YXNldHMobW9kZSkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIuY29uZmlndXJlKCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YXNldChpLCBpc0Z1bmN0aW9uKG1vZGUpID8gbW9kZSh7ZGF0YXNldEluZGV4OiBpfSkgOiBtb2RlKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzVXBkYXRlJywge21vZGV9KTtcbiAgfVxuICBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBhcmdzID0ge21ldGEsIGluZGV4LCBtb2RlLCBjYW5jZWxhYmxlOiB0cnVlfTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0VXBkYXRlJywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1ldGEuY29udHJvbGxlci5fdXBkYXRlKG1vZGUpO1xuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgYXJncyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVJlbmRlcicsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhbmltYXRvci5oYXModGhpcykpIHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICAgIGFuaW1hdG9yLnN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICAgIG9uQW5pbWF0aW9uc0NvbXBsZXRlKHtjaGFydDogdGhpc30pO1xuICAgIH1cbiAgfVxuICBkcmF3KCkge1xuICAgIGxldCBpO1xuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aCAmJiBsYXllcnNbaV0ueiA8PSAwOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG4gICAgdGhpcy5fZHJhd0RhdGFzZXRzKCk7XG4gICAgZm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRyYXcnKTtcbiAgfVxuICBfZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX3NvcnRlZE1ldGFzZXRzO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc2V0c1tpXTtcbiAgICAgIGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZXRhLnZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKHRydWUpO1xuICB9XG4gIF9kcmF3RGF0YXNldHMoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRoaXMuX2RyYXdEYXRhc2V0KG1ldGFzZXRzW2ldKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzRHJhdycpO1xuICB9XG4gIF9kcmF3RGF0YXNldChtZXRhKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY2xpcCA9IG1ldGEuX2NsaXA7XG4gICAgY29uc3QgdXNlQ2xpcCA9ICFjbGlwLmRpc2FibGVkO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgbWV0YSxcbiAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwge1xuICAgICAgICBsZWZ0OiBjbGlwLmxlZnQgPT09IGZhbHNlID8gMCA6IGFyZWEubGVmdCAtIGNsaXAubGVmdCxcbiAgICAgICAgcmlnaHQ6IGNsaXAucmlnaHQgPT09IGZhbHNlID8gdGhpcy53aWR0aCA6IGFyZWEucmlnaHQgKyBjbGlwLnJpZ2h0LFxuICAgICAgICB0b3A6IGNsaXAudG9wID09PSBmYWxzZSA/IDAgOiBhcmVhLnRvcCAtIGNsaXAudG9wLFxuICAgICAgICBib3R0b206IGNsaXAuYm90dG9tID09PSBmYWxzZSA/IHRoaXMuaGVpZ2h0IDogYXJlYS5ib3R0b20gKyBjbGlwLmJvdHRvbVxuICAgICAgfSk7XG4gICAgfVxuICAgIG1ldGEuY29udHJvbGxlci5kcmF3KCk7XG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXREcmF3JywgYXJncyk7XG4gIH1cbiAgaXNQb2ludEluQXJlYShwb2ludCkge1xuICAgIHJldHVybiBfaXNQb2ludEluQXJlYShwb2ludCwgdGhpcy5jaGFydEFyZWEsIHRoaXMuX21pblBhZGRpbmcpO1xuICB9XG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgbGV0IG1ldGEgPSBtZXRhc2V0cy5maWx0ZXIoeCA9PiB4ICYmIHguX2RhdGFzZXQgPT09IGRhdGFzZXQpLnBvcCgpO1xuICAgIGlmICghbWV0YSkge1xuICAgICAgbWV0YSA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICBfZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCwge2NoYXJ0OiB0aGlzLCB0eXBlOiAnY2hhcnQnfSkpO1xuICB9XG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gIH1cbiAgc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBtZXRhLmhpZGRlbiA9ICF2aXNpYmxlO1xuICB9XG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbW9kZSA9IHZpc2libGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcbiAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKTtcbiAgICAgIGFuaW1zLnVwZGF0ZShtZXRhLCB7dmlzaWJsZX0pO1xuICAgICAgdGhpcy51cGRhdGUoKGN0eCkgPT4gY3R4LmRhdGFzZXRJbmRleCA9PT0gZGF0YXNldEluZGV4ID8gbW9kZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG4gIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCBmYWxzZSk7XG4gIH1cbiAgc2hvdyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHRydWUpO1xuICB9XG4gIF9kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gIH1cbiAgX3N0b3AoKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgYW5pbWF0b3IucmVtb3ZlKHRoaXMpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IHRoaXM7XG4gICAgdGhpcy5fc3RvcCgpO1xuICAgIHRoaXMuY29uZmlnLmNsZWFyQ2FjaGUoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpO1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2Rlc3Ryb3knKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEZXN0cm95Jyk7XG4gIH1cbiAgdG9CYXNlNjRJbWFnZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcbiAgfVxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuYmluZFVzZXJFdmVudHMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMuYmluZFJlc3BvbnNpdmVFdmVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGJpbmRVc2VyRXZlbnRzKCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKGUsIHgsIHkpID0+IHtcbiAgICAgIGUub2Zmc2V0WCA9IHg7XG4gICAgICBlLm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKGUpO1xuICAgIH07XG4gICAgZWFjaCh0aGlzLm9wdGlvbnMuZXZlbnRzLCAodHlwZSkgPT4gX2FkZCh0eXBlLCBsaXN0ZW5lcikpO1xuICB9XG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZSA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBkZXRhY2hlZDtcbiAgICBjb25zdCBhdHRhY2hlZCA9ICgpID0+IHtcbiAgICAgIF9yZW1vdmUoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIF9hZGQoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgIF9hZGQoJ2RldGFjaCcsIGRldGFjaGVkKTtcbiAgICB9O1xuICAgIGRldGFjaGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgX3JlbW92ZSgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgdGhpcy5fcmVzaXplKDAsIDApO1xuICAgICAgX2FkZCgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtLmlzQXR0YWNoZWQodGhpcy5jYW52YXMpKSB7XG4gICAgICBhdHRhY2hlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCgpO1xuICAgIH1cbiAgfVxuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgZWFjaCh0aGlzLl9saXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICBlYWNoKHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZUhvdmVyU3R5bGUoaXRlbXMsIG1vZGUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcbiAgICBsZXQgbWV0YSwgaXRlbSwgaSwgaWxlbjtcbiAgICBpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5kYXRhc2V0SW5kZXgpO1xuICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBpdGVtICYmIHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyW3ByZWZpeCArICdIb3ZlclN0eWxlJ10oaXRlbS5lbGVtZW50LCBpdGVtLmRhdGFzZXRJbmRleCwgaXRlbS5pbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMpIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgfVxuICB9XG4gIG5vdGlmeVBsdWdpbnMoaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMubm90aWZ5KHRoaXMsIGhvb2ssIGFyZ3MsIGZpbHRlcik7XG4gIH1cbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBhY3RpdmF0ZWQgPSByZXBsYXkgPyBhY3RpdmUgOiBkaWZmKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZhdGVkLmxlbmd0aCAmJiBob3Zlck9wdGlvbnMubW9kZSkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuICAgIH1cbiAgfVxuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBldmVudDogZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBpbkNoYXJ0QXJlYTogdGhpcy5pc1BvaW50SW5BcmVhKGUpXG4gICAgfTtcbiAgICBjb25zdCBldmVudEZpbHRlciA9IChwbHVnaW4pID0+IChwbHVnaW4ub3B0aW9ucy5ldmVudHMgfHwgdGhpcy5vcHRpb25zLmV2ZW50cykuaW5jbHVkZXMoZS5uYXRpdmUudHlwZSk7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9oYW5kbGVFdmVudChlLCByZXBsYXksIGFyZ3MuaW5DaGFydEFyZWEpO1xuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKTtcbiAgICBpZiAoY2hhbmdlZCB8fCBhcmdzLmNoYW5nZWQpIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9oYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qge19hY3RpdmU6IGxhc3RBY3RpdmUgPSBbXSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSByZXBsYXk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IGlzQ2xpY2sgPSBfaXNDbGlja0V2ZW50KGUpO1xuICAgIGNvbnN0IGxhc3RFdmVudCA9IGRldGVybWluZUxhc3RFdmVudChlLCB0aGlzLl9sYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKTtcbiAgICBpZiAoaW5DaGFydEFyZWEpIHtcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICBjYWxsYmFjayhvcHRpb25zLm9uSG92ZXIsIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25DbGljaywgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSk7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RFdmVudCA9IGxhc3RFdmVudDtcbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxufVxuY29uc3QgaW52YWxpZGF0ZVBsdWdpbnMgPSAoKSA9PiBlYWNoKENoYXJ0Lmluc3RhbmNlcywgKGNoYXJ0KSA9PiBjaGFydC5fcGx1Z2lucy5pbnZhbGlkYXRlKCkpO1xuY29uc3QgZW51bWVyYWJsZSA9IHRydWU7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFydCwge1xuICBkZWZhdWx0czoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGRlZmF1bHRzXG4gIH0sXG4gIGluc3RhbmNlczoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGluc3RhbmNlc1xuICB9LFxuICBvdmVycmlkZXM6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBvdmVycmlkZXNcbiAgfSxcbiAgcmVnaXN0cnk6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiByZWdpc3RyeVxuICB9LFxuICB2ZXJzaW9uOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogdmVyc2lvblxuICB9LFxuICBnZXRDaGFydDoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGdldENoYXJ0XG4gIH0sXG4gIHJlZ2lzdGVyOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogKC4uLml0ZW1zKSA9PiB7XG4gICAgICByZWdpc3RyeS5hZGQoLi4uaXRlbXMpO1xuICAgICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJlZ2lzdHJ5LnJlbW92ZSguLi5pdGVtcyk7XG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGFic3RyYWN0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogQ2hlY2sgdGhhdCBhIGNvbXBsZXRlIGRhdGUgYWRhcHRlciBpcyBwcm92aWRlZC4nKTtcbn1cbmNsYXNzIERhdGVBZGFwdGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIH1cbiAgaW5pdChjaGFydE9wdGlvbnMpIHt9XG4gIGZvcm1hdHMoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgcGFyc2UodmFsdWUsIGZvcm1hdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGZvcm1hdCh0aW1lc3RhbXAsIGZvcm1hdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGFkZCh0aW1lc3RhbXAsIGFtb3VudCwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGRpZmYoYSwgYiwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIHN0YXJ0T2YodGltZXN0YW1wLCB1bml0LCB3ZWVrZGF5KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZW5kT2YodGltZXN0YW1wLCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbn1cbkRhdGVBZGFwdGVyLm92ZXJyaWRlID0gZnVuY3Rpb24obWVtYmVycykge1xuICBPYmplY3QuYXNzaWduKERhdGVBZGFwdGVyLnByb3RvdHlwZSwgbWVtYmVycyk7XG59O1xudmFyIF9hZGFwdGVycyA9IHtcbiAgX2RhdGU6IERhdGVBZGFwdGVyXG59O1xuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgdHlwZSkge1xuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgdmlzaWJsZU1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSk7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdmlzaWJsZU1ldGFzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh2aXNpYmxlTWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpKTtcbiAgICB9XG4gICAgc2NhbGUuX2NhY2hlLiRiYXIgPSBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlLl9jYWNoZS4kYmFyO1xufVxuZnVuY3Rpb24gY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSkge1xuICBjb25zdCBzY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2YWx1ZXMgPSBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgbWV0YS50eXBlKTtcbiAgbGV0IG1pbiA9IHNjYWxlLl9sZW5ndGg7XG4gIGxldCBpLCBpbGVuLCBjdXJyLCBwcmV2O1xuICBjb25zdCB1cGRhdGVNaW5BbmRQcmV2ID0gKCkgPT4ge1xuICAgIGlmIChjdXJyID09PSAzMjc2NyB8fCBjdXJyID09PSAtMzI3NjgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgfVxuICAgIHByZXYgPSBjdXJyO1xuICB9O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlc1tpXSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG4gIHByZXYgPSB1bmRlZmluZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBzY2FsZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuICByZXR1cm4gbWluO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcbiAgbGV0IHNpemUsIHJhdGlvO1xuICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xuICAgIHJhdGlvID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbyxcbiAgICBzdGFydDogcnVsZXIucGl4ZWxzW2luZGV4XSAtIChzaXplIC8gMilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHBpeGVscyA9IHJ1bGVyLnBpeGVscztcbiAgY29uc3QgY3VyciA9IHBpeGVsc1tpbmRleF07XG4gIGxldCBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xuICBsZXQgbmV4dCA9IGluZGV4IDwgcGl4ZWxzLmxlbmd0aCAtIDEgPyBwaXhlbHNbaW5kZXggKyAxXSA6IG51bGw7XG4gIGNvbnN0IHBlcmNlbnQgPSBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICBwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG4gIH1cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICBuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuICB9XG4gIGNvbnN0IHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XG4gIGNvbnN0IHNpemUgPSBNYXRoLmFicyhuZXh0IC0gcHJldikgLyAyICogcGVyY2VudDtcbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcbiAgICBzdGFydFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xuICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gIGxldCBiYXJFbmQgPSBtYXg7XG4gIGlmIChNYXRoLmFicyhtaW4pID4gTWF0aC5hYnMobWF4KSkge1xuICAgIGJhclN0YXJ0ID0gbWF4O1xuICAgIGJhckVuZCA9IG1pbjtcbiAgfVxuICBpdGVtW3ZTY2FsZS5heGlzXSA9IGJhckVuZDtcbiAgaXRlbS5fY3VzdG9tID0ge1xuICAgIGJhclN0YXJ0LFxuICAgIGJhckVuZCxcbiAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICBlbmQ6IGVuZFZhbHVlLFxuICAgIG1pbixcbiAgICBtYXhcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcbiAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gIGNvbnN0IHBhcnNlZCA9IFtdO1xuICBsZXQgaSwgaWxlbiwgaXRlbSwgZW50cnk7XG4gIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGVudHJ5ID0gZGF0YVtpXTtcbiAgICBpdGVtID0ge307XG4gICAgaXRlbVtpU2NhbGUuYXhpc10gPSBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2ldLCBpKTtcbiAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgcmV0dXJuIGN1c3RvbSAmJiBjdXN0b20uYmFyU3RhcnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b20uYmFyRW5kICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkge1xuICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgIHJldHVybiBzaWduKHNpemUpO1xuICB9XG4gIHJldHVybiAodlNjYWxlLmlzSG9yaXpvbnRhbCgpID8gMSA6IC0xKSAqICh2U2NhbGUubWluID49IGFjdHVhbEJhc2UgPyAxIDogLTEpO1xufVxuZnVuY3Rpb24gYm9yZGVyUHJvcHMocHJvcGVydGllcykge1xuICBsZXQgcmV2ZXJzZSwgc3RhcnQsIGVuZCwgdG9wLCBib3R0b207XG4gIGlmIChwcm9wZXJ0aWVzLmhvcml6b250YWwpIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlID4gcHJvcGVydGllcy54O1xuICAgIHN0YXJ0ID0gJ2xlZnQnO1xuICAgIGVuZCA9ICdyaWdodCc7XG4gIH0gZWxzZSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA8IHByb3BlcnRpZXMueTtcbiAgICBzdGFydCA9ICdib3R0b20nO1xuICAgIGVuZCA9ICd0b3AnO1xuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgdG9wID0gJ2VuZCc7XG4gICAgYm90dG9tID0gJ3N0YXJ0JztcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAnc3RhcnQnO1xuICAgIGJvdHRvbSA9ICdlbmQnO1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219O1xufVxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgbGV0IGVkZ2UgPSBvcHRpb25zLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBpZiAoIWVkZ2UpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlZGdlID09PSB0cnVlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0ge3RvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSwgbGVmdDogdHJ1ZX07XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcbiAgaWYgKGVkZ2UgPT09ICdtaWRkbGUnICYmIHN0YWNrKSB7XG4gICAgcHJvcGVydGllcy5lbmFibGVCb3JkZXJSYWRpdXMgPSB0cnVlO1xuICAgIGlmICgoc3RhY2suX3RvcCB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfSBlbHNlIGlmICgoc3RhY2suX2JvdHRvbSB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSBib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1twYXJzZUVkZ2UoYm90dG9tLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9XG4gIH1cbiAgcmVzW3BhcnNlRWRnZShlZGdlLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG59XG5mdW5jdGlvbiBwYXJzZUVkZ2UoZWRnZSwgYSwgYiwgcmV2ZXJzZSkge1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuICByZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuZnVuY3Rpb24gc3RhcnRFbmQodiwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogdiA9PT0gJ2VuZCcgPyBlbmQgOiB2O1xufVxuZnVuY3Rpb24gc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCB7aW5mbGF0ZUFtb3VudH0sIHJhdGlvKSB7XG4gIHByb3BlcnRpZXMuaW5mbGF0ZUFtb3VudCA9IGluZmxhdGVBbW91bnQgPT09ICdhdXRvJ1xuICAgID8gcmF0aW8gPT09IDEgPyAwLjMzIDogMFxuICAgIDogaW5mbGF0ZUFtb3VudDtcbn1cbmNsYXNzIEJhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCBjdXN0b20ubWluKTtcbiAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgY3VzdG9tLm1heCk7XG4gICAgfVxuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgdmFsdWUgPSBpc0Zsb2F0QmFyKGN1c3RvbSlcbiAgICAgID8gJ1snICsgY3VzdG9tLnN0YXJ0ICsgJywgJyArIGN1c3RvbS5lbmQgKyAnXSdcbiAgICAgIDogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLnN0YWNrID0gdGhpcy5nZXREYXRhc2V0KCkuc3RhY2s7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYmFycywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpbmRleCwgX2NhY2hlZE1ldGE6IHt2U2NhbGV9fSA9IHRoaXM7XG4gICAgY29uc3QgYmFzZSA9IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdlNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHJ1bGVyID0gdGhpcy5fZ2V0UnVsZXIoKTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHZwaXhlbHMgPSByZXNldCB8fCBpc051bGxPclVuZGVmKHBhcnNlZFt2U2NhbGUuYXhpc10pID8ge2Jhc2UsIGhlYWQ6IGJhc2V9IDogdGhpcy5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaSk7XG4gICAgICBjb25zdCBpcGl4ZWxzID0gdGhpcy5fY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaSwgcnVsZXIpO1xuICAgICAgY29uc3Qgc3RhY2sgPSAocGFyc2VkLl9zdGFja3MgfHwge30pW3ZTY2FsZS5heGlzXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGhvcml6b250YWwsXG4gICAgICAgIGJhc2U6IHZwaXhlbHMuYmFzZSxcbiAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhc3RhY2sgfHwgaXNGbG9hdEJhcihwYXJzZWQuX2N1c3RvbSkgfHwgKGluZGV4ID09PSBzdGFjay5fdG9wIHx8IGluZGV4ID09PSBzdGFjay5fYm90dG9tKSxcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxuICAgICAgICB5OiBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiB2cGl4ZWxzLmhlYWQsXG4gICAgICAgIGhlaWdodDogaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSksXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBiYXJzW2ldLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gcHJvcGVydGllcy5vcHRpb25zIHx8IGJhcnNbaV0ub3B0aW9ucztcbiAgICAgIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KTtcbiAgICAgIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywgb3B0aW9ucywgcnVsZXIucmF0aW8pO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGJhcnNbaV0sIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHtpU2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKVxuICAgICAgLmZpbHRlcihtZXRhID0+IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQpO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuICAgIGNvbnN0IHNraXBOdWxsID0gKG1ldGEpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IG1ldGEuY29udHJvbGxlci5nZXRQYXJzZWQoZGF0YUluZGV4KTtcbiAgICAgIGNvbnN0IHZhbCA9IHBhcnNlZCAmJiBwYXJzZWRbbWV0YS52U2NhbGUuYXhpc107XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWwpIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbWV0YXNldHMpIHtcbiAgICAgIGlmIChkYXRhSW5kZXggIT09IHVuZGVmaW5lZCAmJiBza2lwTnVsbChtZXRhKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3RhY2tzLmxlbmd0aCkge1xuICAgICAgc3RhY2tzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3ModW5kZWZpbmVkLCBpbmRleCkubGVuZ3RoO1xuICB9XG4gIF9nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCwgbmFtZSwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KTtcbiAgICBjb25zdCBpbmRleCA9IChuYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICA/IHN0YWNrcy5pbmRleE9mKG5hbWUpXG4gICAgICA6IC0xO1xuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuICBfZ2V0UnVsZXIoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBwaXhlbHMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuICAgIGNvbnN0IGJhclRoaWNrbmVzcyA9IG9wdHMuYmFyVGhpY2tuZXNzO1xuICAgIGNvbnN0IG1pbiA9IGJhclRoaWNrbmVzcyB8fCBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluLFxuICAgICAgcGl4ZWxzLFxuICAgICAgc3RhcnQ6IGlTY2FsZS5fc3RhcnRQaXhlbCxcbiAgICAgIGVuZDogaVNjYWxlLl9lbmRQaXhlbCxcbiAgICAgIHN0YWNrQ291bnQ6IHRoaXMuX2dldFN0YWNrQ291bnQoKSxcbiAgICAgIHNjYWxlOiBpU2NhbGUsXG4gICAgICBncm91cGVkOiBvcHRzLmdyb3VwZWQsXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuICBfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaW5kZXgpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IHt2U2NhbGUsIF9zdGFja2VkfSwgb3B0aW9uczoge2Jhc2U6IGJhc2VWYWx1ZSwgbWluQmFyTGVuZ3RofX0gPSB0aGlzO1xuICAgIGNvbnN0IGFjdHVhbEJhc2UgPSBiYXNlVmFsdWUgfHwgMDtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgZmxvYXRpbmcgPSBpc0Zsb2F0QmFyKGN1c3RvbSk7XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkW3ZTY2FsZS5heGlzXTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBsZW5ndGggPSBfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogdmFsdWU7XG4gICAgbGV0IGhlYWQsIHNpemU7XG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGZsb2F0aW5nKSB7XG4gICAgICB2YWx1ZSA9IGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIGxlbmd0aCA9IGN1c3RvbS5iYXJFbmQgLSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBpZiAodmFsdWUgIT09IDAgJiYgc2lnbih2YWx1ZSkgIT09IHNpZ24oY3VzdG9tLmJhckVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgKz0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG4gICAgaWYgKHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICBoZWFkID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQgKyBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkID0gYmFzZTtcbiAgICB9XG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuICAgIGlmIChNYXRoLmFicyhzaXplKSA8IG1pbkJhckxlbmd0aCkge1xuICAgICAgc2l6ZSA9IGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSAqIG1pbkJhckxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZSA9PT0gYWN0dWFsQmFzZSkge1xuICAgICAgICBiYXNlIC09IHNpemUgLyAyO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMCk7XG4gICAgICBjb25zdCBlbmRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMSk7XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBiYXNlID0gTWF0aC5tYXgoTWF0aC5taW4oYmFzZSwgbWF4KSwgbWluKTtcbiAgICAgIGhlYWQgPSBiYXNlICsgc2l6ZTtcbiAgICB9XG4gICAgaWYgKGJhc2UgPT09IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGFjdHVhbEJhc2UpKSB7XG4gICAgICBjb25zdCBoYWxmR3JpZCA9IHNpZ24oc2l6ZSkgKiB2U2NhbGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUoYWN0dWFsQmFzZSkgLyAyO1xuICAgICAgYmFzZSArPSBoYWxmR3JpZDtcbiAgICAgIHNpemUgLT0gaGFsZkdyaWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzaXplLFxuICAgICAgYmFzZSxcbiAgICAgIGhlYWQsXG4gICAgICBjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGluZGV4LCBydWxlcikge1xuICAgIGNvbnN0IHNjYWxlID0gcnVsZXIuc2NhbGU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBza2lwTnVsbCA9IG9wdGlvbnMuc2tpcE51bGw7XG4gICAgY29uc3QgbWF4QmFyVGhpY2tuZXNzID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KTtcbiAgICBsZXQgY2VudGVyLCBzaXplO1xuICAgIGlmIChydWxlci5ncm91cGVkKSB7XG4gICAgICBjb25zdCBzdGFja0NvdW50ID0gc2tpcE51bGwgPyB0aGlzLl9nZXRTdGFja0NvdW50KGluZGV4KSA6IHJ1bGVyLnN0YWNrQ291bnQ7XG4gICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcbiAgICAgICAgPyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudClcbiAgICAgICAgOiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KTtcbiAgICAgIGNvbnN0IHN0YWNrSW5kZXggPSB0aGlzLl9nZXRTdGFja0luZGV4KHRoaXMuaW5kZXgsIHRoaXMuX2NhY2hlZE1ldGEuc3RhY2ssIHNraXBOdWxsID8gaW5kZXggOiB1bmRlZmluZWQpO1xuICAgICAgY2VudGVyID0gcmFuZ2Uuc3RhcnQgKyAocmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4KSArIChyYW5nZS5jaHVuayAvIDIpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbnRlciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaW5kZXgpW3NjYWxlLmF4aXNdLCBpbmRleCk7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCBydWxlci5taW4gKiBydWxlci5yYXRpbyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCByZWN0cyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBpbGVuID0gcmVjdHMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKHRoaXMuZ2V0UGFyc2VkKGkpW3ZTY2FsZS5heGlzXSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0c1tpXS5kcmF3KHRoaXMuX2N0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5CYXJDb250cm9sbGVyLmlkID0gJ2Jhcic7XG5CYXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdiYXInLFxuICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgYmFyUGVyY2VudGFnZTogMC45LFxuICBncm91cGVkOiB0cnVlLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddXG4gICAgfVxuICB9XG59O1xuQmFyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICBncmlkOiB7XG4gICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIEJ1YmJsZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtWzJdLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgfVxuICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcbiAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBtZXRhLmxhYmVsLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSAhcmVzZXQgJiYgdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IHJlc2V0ID8gaVNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0ID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zLnJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgbGV0IHZhbHVlcyA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpO1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzLCB7JHNoYXJlZDogZmFsc2V9KTtcbiAgICB9XG4gICAgY29uc3QgcmFkaXVzID0gdmFsdWVzLnJhZGl1cztcbiAgICBpZiAobW9kZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHZhbHVlcy5yYWRpdXMgPSAwO1xuICAgIH1cbiAgICB2YWx1ZXMucmFkaXVzICs9IHZhbHVlT3JEZWZhdWx0KHBhcnNlZCAmJiBwYXJzZWQuX2N1c3RvbSwgcmFkaXVzKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59XG5CdWJibGVDb250cm9sbGVyLmlkID0gJ2J1YmJsZSc7XG5CdWJibGVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cyddXG4gICAgfVxuICB9XG59O1xuQnViYmxlQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIHg6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH1cbiAgfSxcbiAgcGx1Z2luczoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpIHtcbiAgbGV0IHJhdGlvWCA9IDE7XG4gIGxldCByYXRpb1kgPSAxO1xuICBsZXQgb2Zmc2V0WCA9IDA7XG4gIGxldCBvZmZzZXRZID0gMDtcbiAgaWYgKGNpcmN1bWZlcmVuY2UgPCBUQVUpIHtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgY29uc3QgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcbiAgICBjb25zdCBzdGFydFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBlbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgIGNvbnN0IGVuZFkgPSBNYXRoLnNpbihlbmRBbmdsZSk7XG4gICAgY29uc3QgY2FsY01heCA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gMSA6IE1hdGgubWF4KGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IGNhbGNNaW4gPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IC0xIDogTWF0aC5taW4oYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgbWF4WCA9IGNhbGNNYXgoMCwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtYXhZID0gY2FsY01heChIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIGNvbnN0IG1pblggPSBjYWxjTWluKFBJLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1pblkgPSBjYWxjTWluKFBJICsgSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICByYXRpb1ggPSAobWF4WCAtIG1pblgpIC8gMjtcbiAgICByYXRpb1kgPSAobWF4WSAtIG1pblkpIC8gMjtcbiAgICBvZmZzZXRYID0gLShtYXhYICsgbWluWCkgLyAyO1xuICAgIG9mZnNldFkgPSAtKG1heFkgKyBtaW5ZKSAvIDI7XG4gIH1cbiAgcmV0dXJuIHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX07XG59XG5jbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRZID0gdW5kZWZpbmVkO1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7fVxuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhc2V0KCkuZGF0YTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBnZXR0ZXIgPSAoaSkgPT4gK2RhdGFbaV07XG4gICAgICBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIGNvbnN0IHtrZXkgPSAndmFsdWUnfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgICAgIGdldHRlciA9IChpKSA9PiArcmVzb2x2ZU9iamVjdEtleShkYXRhW2ldLCBrZXkpO1xuICAgICAgfVxuICAgICAgbGV0IGksIGlsZW47XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2ldID0gZ2V0dGVyKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gIH1cbiAgX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XG4gIH1cbiAgX2dldFJvdGF0aW9uRXh0ZW50cygpIHtcbiAgICBsZXQgbWluID0gVEFVO1xuICAgIGxldCBtYXggPSAtVEFVO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gY29udHJvbGxlci5fZ2V0Um90YXRpb24oKTtcbiAgICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IGNvbnRyb2xsZXIuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByb3RhdGlvbik7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcm90YXRpb24gKyBjaXJjdW1mZXJlbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiBtaW4sXG4gICAgICBjaXJjdW1mZXJlbmNlOiBtYXggLSBtaW4sXG4gICAgfTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCB7Y2hhcnRBcmVhfSA9IGNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KGFyY3MpICsgdGhpcy5vcHRpb25zLnNwYWNpbmc7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KChNYXRoLm1pbihjaGFydEFyZWEud2lkdGgsIGNoYXJ0QXJlYS5oZWlnaHQpIC0gc3BhY2luZykgLyAyLCAwKTtcbiAgICBjb25zdCBjdXRvdXQgPSBNYXRoLm1pbih0b1BlcmNlbnRhZ2UodGhpcy5vcHRpb25zLmN1dG91dCwgbWF4U2l6ZSksIDEpO1xuICAgIGNvbnN0IGNoYXJ0V2VpZ2h0ID0gdGhpcy5fZ2V0UmluZ1dlaWdodCh0aGlzLmluZGV4KTtcbiAgICBjb25zdCB7Y2lyY3VtZmVyZW5jZSwgcm90YXRpb259ID0gdGhpcy5fZ2V0Um90YXRpb25FeHRlbnRzKCk7XG4gICAgY29uc3Qge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfSA9IGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IChjaGFydEFyZWEuaGVpZ2h0IC0gc3BhY2luZykgLyByYXRpb1k7XG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKHRoaXMub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gdGhpcy5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZICogb3V0ZXJSYWRpdXM7XG4gICAgbWV0YS50b3RhbCA9IHRoaXMuY2FsY3VsYXRlVG90YWwoKTtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIF9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgIGlmICgocmVzZXQgJiYgb3B0cy5hbmltYXRpb24uYW5pbWF0ZVJvdGF0ZSkgfHwgIXRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgfHwgbWV0YS5fcGFyc2VkW2ldID09PSBudWxsIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG1ldGEuX3BhcnNlZFtpXSAqIGNpcmN1bWZlcmVuY2UgLyBUQVUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5vdXRlclJhZGl1cztcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBzdGFydEFuZ2xlICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IGNlbnRlclkgKyB0aGlzLm9mZnNldFksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgc3RhcnRBbmdsZSArPSBjaXJjdW1mZXJlbmNlO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFEYXRhID0gbWV0YS5kYXRhO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGFEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG1ldGEuX3BhcnNlZFtpXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgJiYgIW1ldGFEYXRhW2ldLmhpZGRlbikge1xuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuICBjYWxjdWxhdGVDaXJjdW1mZXJlbmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgIGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFRBVSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XSwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgZ2V0TWF4Qm9yZGVyV2lkdGgoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsZXQgaSwgaWxlbiwgbWV0YSwgY29udHJvbGxlciwgb3B0aW9ucztcbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICBhcmNzID0gbWV0YS5kYXRhO1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvcHRpb25zID0gY29udHJvbGxlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsIG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBnZXRNYXhPZmZzZXQoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMub2Zmc2V0IHx8IDAsIG9wdGlvbnMuaG92ZXJPZmZzZXQgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHRPZmZzZXQoZGF0YXNldEluZGV4KSB7XG4gICAgbGV0IHJpbmdXZWlnaHRPZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgcmluZ1dlaWdodE9mZnNldCArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcbiAgfVxuICBfZ2V0UmluZ1dlaWdodChkYXRhc2V0SW5kZXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XG4gIH1cbiAgX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCkgfHwgMTtcbiAgfVxufVxuRG91Z2hudXRDb250cm9sbGVyLmlkID0gJ2RvdWdobnV0JztcbkRvdWdobnV0Q29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgYW5pbWF0aW9uOiB7XG4gICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICBhbmltYXRlU2NhbGU6IGZhbHNlXG4gIH0sXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsnY2lyY3VtZmVyZW5jZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdzdGFydEFuZ2xlJywgJ3gnLCAneScsICdvZmZzZXQnLCAnYm9yZGVyV2lkdGgnLCAnc3BhY2luZyddXG4gICAgfSxcbiAgfSxcbiAgY3V0b3V0OiAnNTAlJyxcbiAgcm90YXRpb246IDAsXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgcmFkaXVzOiAnMTAwJScsXG4gIHNwYWNpbmc6IDAsXG4gIGluZGV4QXhpczogJ3InLFxufTtcbkRvdWdobnV0Q29udHJvbGxlci5kZXNjcmlwdG9ycyA9IHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG59O1xuRG91Z2hudXRDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcbiAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgICBsZXQgZGF0YUxhYmVsID0gdG9vbHRpcEl0ZW0ubGFiZWw7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoZGF0YUxhYmVsKSkge1xuICAgICAgICAgICAgZGF0YUxhYmVsID0gZGF0YUxhYmVsLnNsaWNlKCk7XG4gICAgICAgICAgICBkYXRhTGFiZWxbMF0gKz0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbCArPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGFMYWJlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgTGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIGRhdGE6IHBvaW50cyA9IFtdLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgIH1cbiAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgIG9wdGlvbnNcbiAgICB9LCBtb2RlKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgbWV0YS5pU2NhbGUuYXhpcyk7XG4gICAgc3VwZXIuZHJhdygpO1xuICB9XG59XG5MaW5lQ29udHJvbGxlci5pZCA9ICdsaW5lJztcbkxpbmVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBzaG93TGluZTogdHJ1ZSxcbiAgc3BhbkdhcHM6IGZhbHNlLFxufTtcbkxpbmVDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgX2luZGV4Xzoge1xuICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICB9LFxuICAgIF92YWx1ZV86IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgIH0sXG4gIH1cbn07XG5cbmNsYXNzIFBvbGFyQXJlYUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLnIsIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGFyY3MgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgdGhpcy5fdXBkYXRlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgZ2V0TWluTWF4KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCkucjtcbiAgICAgIGlmICghaXNOYU4ocGFyc2VkKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBpZiAocGFyc2VkIDwgcmFuZ2UubWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWQgPiByYW5nZS5tYXgpIHtcbiAgICAgICAgICByYW5nZS5tYXggPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgX3VwZGF0ZVJhZGl1cygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKG91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIChyYWRpdXNMZW5ndGggKiB0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aDtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgIGNvbnN0IGRhdGFzZXRTdGFydEFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZSgwKSAtIDAuNSAqIFBJO1xuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGRlZmF1bHRBbmdsZSA9IDM2MCAvIHRoaXMuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgYW5nbGUgKz0gdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgbGV0IHN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgIGxldCBlbmRBbmdsZSA9IGFuZ2xlICsgdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgICBsZXQgb3V0ZXJSYWRpdXMgPSBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSA/IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpLnIpIDogMDtcbiAgICAgIGFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlKSB7XG4gICAgICAgICAgb3V0ZXJSYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgaW5uZXJSYWRpdXM6IDAsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIGNvdW50VmlzaWJsZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzTmFOKHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBfY29tcHV0ZUFuZ2xlKGluZGV4LCBtb2RlLCBkZWZhdWx0QW5nbGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleClcbiAgICAgID8gdG9SYWRpYW5zKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkuYW5nbGUgfHwgZGVmYXVsdEFuZ2xlKVxuICAgICAgOiAwO1xuICB9XG59XG5Qb2xhckFyZWFDb250cm9sbGVyLmlkID0gJ3BvbGFyQXJlYSc7XG5Qb2xhckFyZWFDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICBhbmltYXRpb246IHtcbiAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgIGFuaW1hdGVTY2FsZTogdHJ1ZVxuICB9LFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJ11cbiAgICB9LFxuICB9LFxuICBpbmRleEF4aXM6ICdyJyxcbiAgc3RhcnRBbmdsZTogMCxcbn07XG5Qb2xhckFyZWFDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcbiAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwoY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNoYXJ0LmRhdGEubGFiZWxzW2NvbnRleHQuZGF0YUluZGV4XSArICc6ICcgKyBjb250ZXh0LmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICByOiB7XG4gICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgY2lyY3VsYXI6IHRydWVcbiAgICAgIH0sXG4gICAgICBwb2ludExhYmVsczoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHN0YXJ0QW5nbGU6IDBcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIFBpZUNvbnRyb2xsZXIgZXh0ZW5kcyBEb3VnaG51dENvbnRyb2xsZXIge1xufVxuUGllQ29udHJvbGxlci5pZCA9ICdwaWUnO1xuUGllQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgY3V0b3V0OiAwLFxuICByb3RhdGlvbjogMCxcbiAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICByYWRpdXM6ICcxMDAlJ1xufTtcblxuY2xhc3MgUmFkYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgdlNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdlNjYWxlLmdldExhYmVscygpW2luZGV4XSxcbiAgICAgIHZhbHVlOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pXG4gICAgfTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBsYWJlbHMgPSBtZXRhLmlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICBpZiAobW9kZSAhPT0gJ3Jlc2l6ZScpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIF9sb29wOiB0cnVlLFxuICAgICAgICBfZnVsbExvb3A6IGxhYmVscy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdGhpcy5nZXRQYXJzZWQoaSkucik7XG4gICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGFuZ2xlOiBwb2ludFBvc2l0aW9uLmFuZ2xlLFxuICAgICAgICBza2lwOiBpc05hTih4KSB8fCBpc05hTih5KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG59XG5SYWRhckNvbnRyb2xsZXIuaWQgPSAncmFkYXInO1xuUmFkYXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBpbmRleEF4aXM6ICdyJyxcbiAgc2hvd0xpbmU6IHRydWUsXG4gIGVsZW1lbnRzOiB7XG4gICAgbGluZToge1xuICAgICAgZmlsbDogJ3N0YXJ0J1xuICAgIH1cbiAgfSxcbn07XG5SYWRhckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgc2NhbGVzOiB7XG4gICAgcjoge1xuICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBTY2F0dGVyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YTogcG9pbnRzID0gW119ID0gbWV0YTtcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgbW9kZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHtzaG93TGluZX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiBzaG93TGluZSkge1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSByZWdpc3RyeS5nZXRFbGVtZW50KCdsaW5lJyk7XG4gICAgfVxuICAgIHN1cGVyLmFkZEVsZW1lbnRzKCk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgbGV0IG1heCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cbn1cblNjYXR0ZXJDb250cm9sbGVyLmlkID0gJ3NjYXR0ZXInO1xuU2NhdHRlckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgc2hvd0xpbmU6IGZhbHNlLFxuICBmaWxsOiBmYWxzZVxufTtcblNjYXR0ZXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBtb2RlOiAncG9pbnQnXG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuICcoJyArIGl0ZW0ubGFiZWwgKyAnLCAnICsgaXRlbS5mb3JtYXR0ZWRWYWx1ZSArICcpJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgeDoge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfVxuICB9XG59O1xuXG52YXIgY29udHJvbGxlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5CYXJDb250cm9sbGVyOiBCYXJDb250cm9sbGVyLFxuQnViYmxlQ29udHJvbGxlcjogQnViYmxlQ29udHJvbGxlcixcbkRvdWdobnV0Q29udHJvbGxlcjogRG91Z2hudXRDb250cm9sbGVyLFxuTGluZUNvbnRyb2xsZXI6IExpbmVDb250cm9sbGVyLFxuUG9sYXJBcmVhQ29udHJvbGxlcjogUG9sYXJBcmVhQ29udHJvbGxlcixcblBpZUNvbnRyb2xsZXI6IFBpZUNvbnRyb2xsZXIsXG5SYWRhckNvbnRyb2xsZXI6IFJhZGFyQ29udHJvbGxlcixcblNjYXR0ZXJDb250cm9sbGVyOiBTY2F0dGVyQ29udHJvbGxlclxufSk7XG5cbmZ1bmN0aW9uIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSkge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xuICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbik7XG4gIGlmIChpbm5lclJhZGl1cyA+IHBpeGVsTWFyZ2luKSB7XG4gICAgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGlubmVyUmFkaXVzO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4sIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmFyYyh4LCB5LCBwaXhlbE1hcmdpbiwgZW5kQW5nbGUgKyBIQUxGX1BJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdG9SYWRpdXNDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWydvdXRlclN0YXJ0JywgJ291dGVyRW5kJywgJ2lubmVyU3RhcnQnLCAnaW5uZXJFbmQnXSk7XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyQxKGFyYywgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBhbmdsZURlbHRhKSB7XG4gIGNvbnN0IG8gPSB0b1JhZGl1c0Nvcm5lcnMoYXJjLm9wdGlvbnMuYm9yZGVyUmFkaXVzKTtcbiAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIDI7XG4gIGNvbnN0IGlubmVyTGltaXQgPSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBhbmdsZURlbHRhICogaW5uZXJSYWRpdXMgLyAyKTtcbiAgY29uc3QgY29tcHV0ZU91dGVyTGltaXQgPSAodmFsKSA9PiB7XG4gICAgY29uc3Qgb3V0ZXJBcmNMaW1pdCA9IChvdXRlclJhZGl1cyAtIE1hdGgubWluKGhhbGZUaGlja25lc3MsIHZhbCkpICogYW5nbGVEZWx0YSAvIDI7XG4gICAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbCwgMCwgTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgb3V0ZXJBcmNMaW1pdCkpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG91dGVyU3RhcnQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJTdGFydCksXG4gICAgb3V0ZXJFbmQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJFbmQpLFxuICAgIGlubmVyU3RhcnQ6IF9saW1pdFZhbHVlKG8uaW5uZXJTdGFydCwgMCwgaW5uZXJMaW1pdCksXG4gICAgaW5uZXJFbmQ6IF9saW1pdFZhbHVlKG8uaW5uZXJFbmQsIDAsIGlubmVyTGltaXQpLFxuICB9O1xufVxuZnVuY3Rpb24gclRoZXRhVG9YWShyLCB0aGV0YSwgeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHg6IHggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgIHk6IHkgKyByICogTWF0aC5zaW4odGhldGEpLFxuICB9O1xufVxuZnVuY3Rpb24gcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kLCBjaXJjdWxhcikge1xuICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZTogc3RhcnQsIHBpeGVsTWFyZ2luLCBpbm5lclJhZGl1czogaW5uZXJSfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoZWxlbWVudC5vdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiArIHNwYWNpbmcgKyBvZmZzZXQgKyBwaXhlbE1hcmdpbiA6IDA7XG4gIGxldCBzcGFjaW5nT2Zmc2V0ID0gMDtcbiAgY29uc3QgYWxwaGEgPSBlbmQgLSBzdGFydDtcbiAgaWYgKHNwYWNpbmcpIHtcbiAgICBjb25zdCBub1NwYWNpbmdJbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBub1NwYWNpbmdPdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzID4gMCA/IG91dGVyUmFkaXVzIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3QgYXZOb2dTcGFjaW5nUmFkaXVzID0gKG5vU3BhY2luZ0lubmVyUmFkaXVzICsgbm9TcGFjaW5nT3V0ZXJSYWRpdXMpIC8gMjtcbiAgICBjb25zdCBhZGp1c3RlZEFuZ2xlID0gYXZOb2dTcGFjaW5nUmFkaXVzICE9PSAwID8gKGFscGhhICogYXZOb2dTcGFjaW5nUmFkaXVzKSAvIChhdk5vZ1NwYWNpbmdSYWRpdXMgKyBzcGFjaW5nKSA6IGFscGhhO1xuICAgIHNwYWNpbmdPZmZzZXQgPSAoYWxwaGEgLSBhZGp1c3RlZEFuZ2xlKSAvIDI7XG4gIH1cbiAgY29uc3QgYmV0YSA9IE1hdGgubWF4KDAuMDAxLCBhbHBoYSAqIG91dGVyUmFkaXVzIC0gb2Zmc2V0IC8gUEkpIC8gb3V0ZXJSYWRpdXM7XG4gIGNvbnN0IGFuZ2xlT2Zmc2V0ID0gKGFscGhhIC0gYmV0YSkgLyAyO1xuICBjb25zdCBzdGFydEFuZ2xlID0gc3RhcnQgKyBhbmdsZU9mZnNldCArIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IGVuZEFuZ2xlID0gZW5kIC0gYW5nbGVPZmZzZXQgLSBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCB7b3V0ZXJTdGFydCwgb3V0ZXJFbmQsIGlubmVyU3RhcnQsIGlubmVyRW5kfSA9IHBhcnNlQm9yZGVyUmFkaXVzJDEoZWxlbWVudCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyU3RhcnQ7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyRW5kO1xuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBvdXRlclN0YXJ0IC8gb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIG91dGVyRW5kIC8gb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lclN0YXJ0O1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lckVuZDtcbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgaW5uZXJTdGFydCAvIGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBpbm5lckVuZCAvIGlubmVyRW5kQWRqdXN0ZWRSYWRpdXM7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSk7XG4gICAgaWYgKG91dGVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJFbmRBZGp1c3RlZFJhZGl1cywgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyRW5kLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIGVuZEFuZ2xlICsgSEFMRl9QSSk7XG4gICAgfVxuICAgIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwNC54LCBwNC55KTtcbiAgICBpZiAoaW5uZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBpbm5lckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJFbmQsIGVuZEFuZ2xlICsgSEFMRl9QSSwgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSk7XG4gICAgfVxuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuICAgIGlmIChpbm5lclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzLCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lclN0YXJ0LCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSArIE1hdGguUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgICB9XG4gICAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcbiAgICBpZiAob3V0ZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJTdGFydCwgc3RhcnRBbmdsZSAtIEhBTEZfUEksIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjb25zdCBvdXRlclN0YXJ0WCA9IE1hdGguY29zKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlclN0YXJ0WSA9IE1hdGguc2luKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyU3RhcnRYLCBvdXRlclN0YXJ0WSk7XG4gICAgY29uc3Qgb3V0ZXJFbmRYID0gTWF0aC5jb3Mob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlckVuZFkgPSBNYXRoLnNpbihvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJFbmRYLCBvdXRlckVuZFkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbmZ1bmN0aW9uIGRyYXdBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZX0gPSBlbGVtZW50O1xuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBzdGFydEFuZ2xlICsgVEFVLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlICUgVEFVO1xuICAgICAgaWYgKGNpcmN1bWZlcmVuY2UgJSBUQVUgPT09IDApIHtcbiAgICAgICAgZW5kQW5nbGUgKz0gVEFVO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguZmlsbCgpO1xuICByZXR1cm4gZW5kQW5nbGU7XG59XG5mdW5jdGlvbiBkcmF3RnVsbENpcmNsZUJvcmRlcnMoY3R4LCBlbGVtZW50LCBpbm5lcikge1xuICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIGZ1bGxDaXJjbGVzfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoZWxlbWVudC5vdXRlclJhZGl1cyAtIHBpeGVsTWFyZ2luLCAwKTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBlbGVtZW50LmlubmVyUmFkaXVzICsgcGl4ZWxNYXJnaW47XG4gIGxldCBpO1xuICBpZiAoaW5uZXIpIHtcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgc3RhcnRBbmdsZSArIFRBVSk7XG4gIH1cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBzdGFydEFuZ2xlICsgVEFVLCBzdGFydEFuZ2xlLCB0cnVlKTtcbiAgZm9yIChpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBzdGFydEFuZ2xlICsgVEFVKTtcbiAgZm9yIChpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdCb3JkZXIoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcikge1xuICBjb25zdCB7b3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCB7Ym9yZGVyV2lkdGgsIGJvcmRlckpvaW5TdHlsZX0gPSBvcHRpb25zO1xuICBjb25zdCBpbm5lciA9IG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcic7XG4gIGlmICghYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlubmVyKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoICogMjtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdiZXZlbCc7XG4gIH1cbiAgaWYgKGVsZW1lbnQuZnVsbENpcmNsZXMpIHtcbiAgICBkcmF3RnVsbENpcmNsZUJvcmRlcnMoY3R4LCBlbGVtZW50LCBpbm5lcik7XG4gIH1cbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKTtcbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguc3Ryb2tlKCk7XG59XG5jbGFzcyBBcmNFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2lyY3VtZmVyZW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IDA7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKGNoYXJ0WCwgY2hhcnRZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9IHRoaXMub3B0aW9ucy5zcGFjaW5nIC8gMjtcbiAgICBjb25zdCBfY2lyY3VtZmVyZW5jZSA9IHZhbHVlT3JEZWZhdWx0KGNpcmN1bWZlcmVuY2UsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgYmV0d2VlbkFuZ2xlcyA9IF9jaXJjdW1mZXJlbmNlID49IFRBVSB8fCBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgY29uc3Qgd2l0aGluUmFkaXVzID0gX2lzQmV0d2VlbihkaXN0YW5jZSwgaW5uZXJSYWRpdXMgKyByQWRqdXN0LCBvdXRlclJhZGl1cyArIHJBZGp1c3QpO1xuICAgIHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1c30gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICd4JyxcbiAgICAgICd5JyxcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJyxcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7b2Zmc2V0LCBzcGFjaW5nfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBoYWxmQW5nbGUgPSAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDI7XG4gICAgY29uc3QgaGFsZlJhZGl1cyA9IChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCkgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcbiAgICB9O1xuICB9XG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLm9mZnNldCB8fCAwKSAvIDI7XG4gICAgY29uc3Qgc3BhY2luZyA9IChvcHRpb25zLnNwYWNpbmcgfHwgMCkgLyAyO1xuICAgIGNvbnN0IGNpcmN1bGFyID0gb3B0aW9ucy5jaXJjdWxhcjtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gKG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcicpID8gMC4zMyA6IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IGNpcmN1bWZlcmVuY2UgPiBUQVUgPyBNYXRoLmZsb29yKGNpcmN1bWZlcmVuY2UgLyBUQVUpIDogMDtcbiAgICBpZiAoY2lyY3VtZmVyZW5jZSA9PT0gMCB8fCB0aGlzLmlubmVyUmFkaXVzIDwgMCB8fCB0aGlzLm91dGVyUmFkaXVzIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGxldCByYWRpdXNPZmZzZXQgPSAwO1xuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgIHJhZGl1c09mZnNldCA9IG9mZnNldCAvIDI7XG4gICAgICBjb25zdCBoYWxmQW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlICsgdGhpcy5lbmRBbmdsZSkgLyAyO1xuICAgICAgY3R4LnRyYW5zbGF0ZShNYXRoLmNvcyhoYWxmQW5nbGUpICogcmFkaXVzT2Zmc2V0LCBNYXRoLnNpbihoYWxmQW5nbGUpICogcmFkaXVzT2Zmc2V0KTtcbiAgICAgIGlmICh0aGlzLmNpcmN1bWZlcmVuY2UgPj0gUEkpIHtcbiAgICAgICAgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IGRyYXdBcmMoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcbiAgICBkcmF3Qm9yZGVyKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbkFyY0VsZW1lbnQuaWQgPSAnYXJjJztcbkFyY0VsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgYm9yZGVyV2lkdGg6IDIsXG4gIG9mZnNldDogMCxcbiAgc3BhY2luZzogMCxcbiAgYW5nbGU6IHVuZGVmaW5lZCxcbiAgY2lyY3VsYXI6IHRydWUsXG59O1xuQXJjRWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXG59O1xuXG5mdW5jdGlvbiBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHN0eWxlID0gb3B0aW9ucykge1xuICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNhcFN0eWxlLCBvcHRpb25zLmJvcmRlckNhcFN0eWxlKTtcbiAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2gsIG9wdGlvbnMuYm9yZGVyRGFzaCkpO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LCBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQpO1xuICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJKb2luU3R5bGUsIG9wdGlvbnMuYm9yZGVySm9pblN0eWxlKTtcbiAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ29sb3IsIG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xufVxuZnVuY3Rpb24gbGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCkge1xuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZExpbmVUbztcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVyQ3VydmVUbztcbiAgfVxuICByZXR1cm4gbGluZVRvO1xufVxuZnVuY3Rpb24gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMgPSB7fSkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtzdGFydDogcGFyYW1zU3RhcnQgPSAwLCBlbmQ6IHBhcmFtc0VuZCA9IGNvdW50IC0gMX0gPSBwYXJhbXM7XG4gIGNvbnN0IHtzdGFydDogc2VnbWVudFN0YXJ0LCBlbmQ6IHNlZ21lbnRFbmR9ID0gc2VnbWVudDtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChwYXJhbXNTdGFydCwgc2VnbWVudFN0YXJ0KTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ocGFyYW1zRW5kLCBzZWdtZW50RW5kKTtcbiAgY29uc3Qgb3V0c2lkZSA9IHBhcmFtc1N0YXJ0IDwgc2VnbWVudFN0YXJ0ICYmIHBhcmFtc0VuZCA8IHNlZ21lbnRTdGFydCB8fCBwYXJhbXNTdGFydCA+IHNlZ21lbnRFbmQgJiYgcGFyYW1zRW5kID4gc2VnbWVudEVuZDtcbiAgcmV0dXJuIHtcbiAgICBjb3VudCxcbiAgICBzdGFydCxcbiAgICBsb29wOiBzZWdtZW50Lmxvb3AsXG4gICAgaWxlbjogZW5kIDwgc3RhcnQgJiYgIW91dHNpZGUgPyBjb3VudCArIGVuZCAtIHN0YXJ0IDogZW5kIC0gc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHtwb2ludHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgbG9vcCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IGxpbmVNZXRob2QgPSBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpO1xuICBsZXQge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGksIHBvaW50LCBwcmV2O1xuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGkgOiBpKSkgJSBjb3VudF07XG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAobW92ZSkge1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgIG1vdmUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgIH1cbiAgICBwcmV2ID0gcG9pbnQ7XG4gIH1cbiAgaWYgKGxvb3ApIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gOiAwKSkgJSBjb3VudF07XG4gICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICB9XG4gIHJldHVybiAhIWxvb3A7XG59XG5mdW5jdGlvbiBmYXN0UGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHByZXZYLCBtaW5ZLCBtYXhZLCBsYXN0WTtcbiAgY29uc3QgcG9pbnRJbmRleCA9IChpbmRleCkgPT4gKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaW5kZXggOiBpbmRleCkpICUgY291bnQ7XG4gIGNvbnN0IGRyYXdYID0gKCkgPT4ge1xuICAgIGlmIChtaW5ZICE9PSBtYXhZKSB7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtaW5ZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbGFzdFkpO1xuICAgIH1cbiAgfTtcbiAgaWYgKG1vdmUpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KDApXTtcbiAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleChpKV07XG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB4ID0gcG9pbnQueDtcbiAgICBjb25zdCB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHgpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdYKCk7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgIH1cbiAgICBsYXN0WSA9IHk7XG4gIH1cbiAgZHJhd1goKTtcbn1cbmZ1bmN0aW9uIF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpIHtcbiAgY29uc3Qgb3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHMuYm9yZGVyRGFzaCAmJiBvcHRzLmJvcmRlckRhc2gubGVuZ3RoO1xuICBjb25zdCB1c2VGYXN0UGF0aCA9ICFsaW5lLl9kZWNpbWF0ZWQgJiYgIWxpbmUuX2xvb3AgJiYgIW9wdHMudGVuc2lvbiAmJiBvcHRzLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgIT09ICdtb25vdG9uZScgJiYgIW9wdHMuc3RlcHBlZCAmJiAhYm9yZGVyRGFzaDtcbiAgcmV0dXJuIHVzZUZhc3RQYXRoID8gZmFzdFBhdGhTZWdtZW50IDogcGF0aFNlZ21lbnQ7XG59XG5mdW5jdGlvbiBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uO1xuICB9XG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJJbnRlcnBvbGF0aW9uO1xuICB9XG4gIHJldHVybiBfcG9pbnRJbkxpbmU7XG59XG5mdW5jdGlvbiBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGxldCBwYXRoID0gbGluZS5fcGF0aDtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcGF0aCA9IGxpbmUuX3BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgaWYgKGxpbmUucGF0aChwYXRoLCBzdGFydCwgY291bnQpKSB7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRTdHlsZShjdHgsIGxpbmUub3B0aW9ucyk7XG4gIGN0eC5zdHJva2UocGF0aCk7XG59XG5mdW5jdGlvbiBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IHtzZWdtZW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QobGluZSk7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc2VnbWVudC5zdHlsZSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmIChzZWdtZW50TWV0aG9kKGN0eCwgbGluZSwgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSkpIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5jb25zdCB1c2VQYXRoMkQgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nO1xuZnVuY3Rpb24gZHJhdyhjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBpZiAodXNlUGF0aDJEICYmICFsaW5lLm9wdGlvbnMuc2VnbWVudCkge1xuICAgIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9IGVsc2Uge1xuICAgIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9XG59XG5jbGFzcyBMaW5lRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9sb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Z1bGxMb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NlZ21lbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlY2ltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhc2V0SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVDb250cm9sUG9pbnRzKGNoYXJ0QXJlYSwgaW5kZXhBeGlzKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpICYmICFvcHRpb25zLnN0ZXBwZWQgJiYgIXRoaXMuX3BvaW50c1VwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IGxvb3AgPSBvcHRpb25zLnNwYW5HYXBzID8gdGhpcy5fbG9vcCA6IHRoaXMuX2Z1bGxMb29wO1xuICAgICAgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHModGhpcy5fcG9pbnRzLCBvcHRpb25zLCBjaGFydEFyZWEsIGxvb3AsIGluZGV4QXhpcyk7XG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgc2V0IHBvaW50cyhwb2ludHMpIHtcbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgZGVsZXRlIHRoaXMuX3NlZ21lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9wYXRoO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQgcG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gIH1cbiAgZ2V0IHNlZ21lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWdtZW50cyB8fCAodGhpcy5fc2VnbWVudHMgPSBfY29tcHV0ZVNlZ21lbnRzKHRoaXMsIHRoaXMub3B0aW9ucy5zZWdtZW50KSk7XG4gIH1cbiAgZmlyc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggJiYgcG9pbnRzW3NlZ21lbnRzWzBdLnN0YXJ0XTtcbiAgfVxuICBsYXN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gY291bnQgJiYgcG9pbnRzW3NlZ21lbnRzW2NvdW50IC0gMV0uZW5kXTtcbiAgfVxuICBpbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGhpcywge3Byb3BlcnR5LCBzdGFydDogdmFsdWUsIGVuZDogdmFsdWV9KTtcbiAgICBpZiAoIXNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBfaW50ZXJwb2xhdGUgPSBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50c1tpXTtcbiAgICAgIGNvbnN0IHAxID0gcG9pbnRzW3N0YXJ0XTtcbiAgICAgIGNvbnN0IHAyID0gcG9pbnRzW2VuZF07XG4gICAgICBpZiAocDEgPT09IHAyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0ID0gTWF0aC5hYnMoKHZhbHVlIC0gcDFbcHJvcGVydHldKSAvIChwMltwcm9wZXJ0eV0gLSBwMVtwcm9wZXJ0eV0pKTtcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZCA9IF9pbnRlcnBvbGF0ZShwMSwgcDIsIHQsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgICBpbnRlcnBvbGF0ZWRbcHJvcGVydHldID0gcG9pbnRbcHJvcGVydHldO1xuICAgICAgcmVzdWx0LnB1c2goaW50ZXJwb2xhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH1cbiAgcGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgcmV0dXJuIHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCBwYXJhbXMpO1xuICB9XG4gIHBhdGgoY3R4LCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIGxldCBsb29wID0gdGhpcy5fbG9vcDtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgY291bnQgPSBjb3VudCB8fCAodGhpcy5wb2ludHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgbG9vcCAmPSBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSk7XG4gICAgfVxuICAgIHJldHVybiAhIWxvb3A7XG4gIH1cbiAgZHJhdyhjdHgsIGNoYXJ0QXJlYSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cyB8fCBbXTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCAmJiBvcHRpb25zLmJvcmRlcldpZHRoKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgZHJhdyhjdHgsIHRoaXMsIHN0YXJ0LCBjb3VudCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbmltYXRlZCkge1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cbkxpbmVFbGVtZW50LmlkID0gJ2xpbmUnO1xuTGluZUVsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG4gIGJvcmRlckRhc2g6IFtdLFxuICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICBib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXG4gIGJvcmRlcldpZHRoOiAzLFxuICBjYXBCZXppZXJQb2ludHM6IHRydWUsXG4gIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdkZWZhdWx0JyxcbiAgZmlsbDogZmFsc2UsXG4gIHNwYW5HYXBzOiBmYWxzZSxcbiAgc3RlcHBlZDogZmFsc2UsXG4gIHRlbnNpb246IDAsXG59O1xuTGluZUVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5MaW5lRWxlbWVudC5kZXNjcmlwdG9ycyA9IHtcbiAgX3NjcmlwdGFibGU6IHRydWUsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2ZpbGwnLFxufTtcblxuZnVuY3Rpb24gaW5SYW5nZSQxKGVsLCBwb3MsIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gIGNvbnN0IHtbYXhpc106IHZhbHVlfSA9IGVsLmdldFByb3BzKFtheGlzXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIHJldHVybiAoTWF0aC5hYnMocG9zIC0gdmFsdWUpIDwgb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cyk7XG59XG5jbGFzcyBQb2ludEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5za2lwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RvcCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuICgoTWF0aC5wb3cobW91c2VYIC0geCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB5LCAyKSkgPCBNYXRoLnBvdyhvcHRpb25zLmhpdFJhZGl1cyArIG9wdGlvbnMucmFkaXVzLCAyKSk7XG4gIH1cbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UkMSh0aGlzLCBtb3VzZVgsICd4JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UkMSh0aGlzLCBtb3VzZVksICd5JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuICBzaXplKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgbGV0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDA7XG4gICAgcmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCByYWRpdXMgJiYgb3B0aW9ucy5ob3ZlclJhZGl1cyB8fCAwKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IHJhZGl1cyAmJiBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgcmV0dXJuIChyYWRpdXMgKyBib3JkZXJXaWR0aCkgKiAyO1xuICB9XG4gIGRyYXcoY3R4LCBhcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy5za2lwIHx8IG9wdGlvbnMucmFkaXVzIDwgMC4xIHx8ICFfaXNQb2ludEluQXJlYSh0aGlzLCBhcmVhLCB0aGlzLnNpemUob3B0aW9ucykgLyAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB0aGlzLngsIHRoaXMueSk7XG4gIH1cbiAgZ2V0UmFuZ2UoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cztcbiAgfVxufVxuUG9pbnRFbGVtZW50LmlkID0gJ3BvaW50JztcblBvaW50RWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyV2lkdGg6IDEsXG4gIGhpdFJhZGl1czogMSxcbiAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgaG92ZXJSYWRpdXM6IDQsXG4gIHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuICByYWRpdXM6IDMsXG4gIHJvdGF0aW9uOiAwXG59O1xuUG9pbnRFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHt4LCB5LCBiYXNlLCB3aWR0aCwgaGVpZ2h0fSA9IGJhci5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgbGV0IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgaGFsZjtcbiAgaWYgKGJhci5ob3Jpem9udGFsKSB7XG4gICAgaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgbGVmdCA9IE1hdGgubWluKHgsIGJhc2UpO1xuICAgIHJpZ2h0ID0gTWF0aC5tYXgoeCwgYmFzZSk7XG4gICAgdG9wID0geSAtIGhhbGY7XG4gICAgYm90dG9tID0geSArIGhhbGY7XG4gIH0gZWxzZSB7XG4gICAgaGFsZiA9IHdpZHRoIC8gMjtcbiAgICBsZWZ0ID0geCAtIGhhbGY7XG4gICAgcmlnaHQgPSB4ICsgaGFsZjtcbiAgICB0b3AgPSBNYXRoLm1pbih5LCBiYXNlKTtcbiAgICBib3R0b20gPSBNYXRoLm1heCh5LCBiYXNlKTtcbiAgfVxuICByZXR1cm4ge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX07XG59XG5mdW5jdGlvbiBza2lwT3JMaW1pdChza2lwLCB2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHNraXAgPyAwIDogX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgbyA9IHRvVFJCTCh2YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgdDogc2tpcE9yTGltaXQoc2tpcC50b3AsIG8udG9wLCAwLCBtYXhIKSxcbiAgICByOiBza2lwT3JMaW1pdChza2lwLnJpZ2h0LCBvLnJpZ2h0LCAwLCBtYXhXKSxcbiAgICBiOiBza2lwT3JMaW1pdChza2lwLmJvdHRvbSwgby5ib3R0b20sIDAsIG1heEgpLFxuICAgIGw6IHNraXBPckxpbWl0KHNraXAubGVmdCwgby5sZWZ0LCAwLCBtYXhXKVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHtlbmFibGVCb3JkZXJSYWRpdXN9ID0gYmFyLmdldFByb3BzKFsnZW5hYmxlQm9yZGVyUmFkaXVzJ10pO1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlclJhZGl1cztcbiAgY29uc3QgbyA9IHRvVFJCTENvcm5lcnModmFsdWUpO1xuICBjb25zdCBtYXhSID0gTWF0aC5taW4obWF4VywgbWF4SCk7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgZW5hYmxlQm9yZGVyID0gZW5hYmxlQm9yZGVyUmFkaXVzIHx8IGlzT2JqZWN0KHZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICB0b3BMZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAubGVmdCwgby50b3BMZWZ0LCAwLCBtYXhSKSxcbiAgICB0b3BSaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLnJpZ2h0LCBvLnRvcFJpZ2h0LCAwLCBtYXhSKSxcbiAgICBib3R0b21MZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAubGVmdCwgby5ib3R0b21MZWZ0LCAwLCBtYXhSKSxcbiAgICBib3R0b21SaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLnJpZ2h0LCBvLmJvdHRvbVJpZ2h0LCAwLCBtYXhSKVxuICB9O1xufVxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhiYXIpIHtcbiAgY29uc3QgYm91bmRzID0gZ2V0QmFyQm91bmRzKGJhcik7XG4gIGNvbnN0IHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuICBjb25zdCBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgY29uc3QgcmFkaXVzID0gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICByZXR1cm4ge1xuICAgIG91dGVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCxcbiAgICAgIHk6IGJvdW5kcy50b3AsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodCxcbiAgICAgIHJhZGl1c1xuICAgIH0sXG4gICAgaW5uZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG4gICAgICB5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG4gICAgICB3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG4gICAgICBoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iLFxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHRvcExlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BMZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5sKSksXG4gICAgICAgIHRvcFJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wUmlnaHQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLnIpKSxcbiAgICAgICAgYm90dG9tTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbUxlZnQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLmwpKSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21SaWdodCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIucikpLFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGluUmFuZ2UoYmFyLCB4LCB5LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHNraXBYID0geCA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcFkgPSB5ID09PSBudWxsO1xuICBjb25zdCBza2lwQm90aCA9IHNraXBYICYmIHNraXBZO1xuICBjb25zdCBib3VuZHMgPSBiYXIgJiYgIXNraXBCb3RoICYmIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pO1xuICByZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IF9pc0JldHdlZW4oeCwgYm91bmRzLmxlZnQsIGJvdW5kcy5yaWdodCkpXG5cdFx0JiYgKHNraXBZIHx8IF9pc0JldHdlZW4oeSwgYm91bmRzLnRvcCwgYm91bmRzLmJvdHRvbSkpO1xufVxuZnVuY3Rpb24gaGFzUmFkaXVzKHJhZGl1cykge1xuICByZXR1cm4gcmFkaXVzLnRvcExlZnQgfHwgcmFkaXVzLnRvcFJpZ2h0IHx8IHJhZGl1cy5ib3R0b21MZWZ0IHx8IHJhZGl1cy5ib3R0b21SaWdodDtcbn1cbmZ1bmN0aW9uIGFkZE5vcm1hbFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xufVxuZnVuY3Rpb24gaW5mbGF0ZVJlY3QocmVjdCwgYW1vdW50LCByZWZSZWN0ID0ge30pIHtcbiAgY29uc3QgeCA9IHJlY3QueCAhPT0gcmVmUmVjdC54ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHkgPSByZWN0LnkgIT09IHJlZlJlY3QueSA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB3ID0gKHJlY3QueCArIHJlY3QudyAhPT0gcmVmUmVjdC54ICsgcmVmUmVjdC53ID8gYW1vdW50IDogMCkgLSB4O1xuICBjb25zdCBoID0gKHJlY3QueSArIHJlY3QuaCAhPT0gcmVmUmVjdC55ICsgcmVmUmVjdC5oID8gYW1vdW50IDogMCkgLSB5O1xuICByZXR1cm4ge1xuICAgIHg6IHJlY3QueCArIHgsXG4gICAgeTogcmVjdC55ICsgeSxcbiAgICB3OiByZWN0LncgKyB3LFxuICAgIGg6IHJlY3QuaCArIGgsXG4gICAgcmFkaXVzOiByZWN0LnJhZGl1c1xuICB9O1xufVxuY2xhc3MgQmFyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhvcml6b250YWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbmZsYXRlQW1vdW50ID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7aW5mbGF0ZUFtb3VudCwgb3B0aW9uczoge2JvcmRlckNvbG9yLCBiYWNrZ3JvdW5kQ29sb3J9fSA9IHRoaXM7XG4gICAgY29uc3Qge2lubmVyLCBvdXRlcn0gPSBib3VuZGluZ1JlY3RzKHRoaXMpO1xuICAgIGNvbnN0IGFkZFJlY3RQYXRoID0gaGFzUmFkaXVzKG91dGVyLnJhZGl1cykgPyBhZGRSb3VuZGVkUmVjdFBhdGggOiBhZGROb3JtYWxSZWN0UGF0aDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChvdXRlci53ICE9PSBpbm5lci53IHx8IG91dGVyLmggIT09IGlubmVyLmgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3Qob3V0ZXIsIGluZmxhdGVBbW91bnQsIGlubmVyKSk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgLWluZmxhdGVBbW91bnQsIG91dGVyKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbCgnZXZlbm9kZCcpO1xuICAgIH1cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgaW5mbGF0ZUFtb3VudCkpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBudWxsLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBudWxsLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgYmFzZSwgaG9yaXpvbnRhbH0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnaG9yaXpvbnRhbCddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/ICh4ICsgYmFzZSkgLyAyIDogeCxcbiAgICAgIHk6IGhvcml6b250YWwgPyB5IDogKHkgKyBiYXNlKSAvIDJcbiAgICB9O1xuICB9XG4gIGdldFJhbmdlKGF4aXMpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLmhlaWdodCAvIDI7XG4gIH1cbn1cbkJhckVsZW1lbnQuaWQgPSAnYmFyJztcbkJhckVsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlclNraXBwZWQ6ICdzdGFydCcsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGluZmxhdGVBbW91bnQ6ICdhdXRvJyxcbiAgcG9pbnRTdHlsZTogdW5kZWZpbmVkXG59O1xuQmFyRWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcblxudmFyIGVsZW1lbnRzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQXJjRWxlbWVudDogQXJjRWxlbWVudCxcbkxpbmVFbGVtZW50OiBMaW5lRWxlbWVudCxcblBvaW50RWxlbWVudDogUG9pbnRFbGVtZW50LFxuQmFyRWxlbWVudDogQmFyRWxlbWVudFxufSk7XG5cbmZ1bmN0aW9uIGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2FtcGxlcyA9IG9wdGlvbnMuc2FtcGxlcyB8fCBhdmFpbGFibGVXaWR0aDtcbiAgaWYgKHNhbXBsZXMgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZShzdGFydCwgc3RhcnQgKyBjb3VudCk7XG4gIH1cbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGJ1Y2tldFdpZHRoID0gKGNvdW50IC0gMikgLyAoc2FtcGxlcyAtIDIpO1xuICBsZXQgc2FtcGxlZEluZGV4ID0gMDtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgbGV0IGEgPSBzdGFydDtcbiAgbGV0IGksIG1heEFyZWFQb2ludCwgbWF4QXJlYSwgYXJlYSwgbmV4dEE7XG4gIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2FdO1xuICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcyAtIDI7IGkrKykge1xuICAgIGxldCBhdmdYID0gMDtcbiAgICBsZXQgYXZnWSA9IDA7XG4gICAgbGV0IGo7XG4gICAgY29uc3QgYXZnUmFuZ2VTdGFydCA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUVuZCA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAyKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlTGVuZ3RoID0gYXZnUmFuZ2VFbmQgLSBhdmdSYW5nZVN0YXJ0O1xuICAgIGZvciAoaiA9IGF2Z1JhbmdlU3RhcnQ7IGogPCBhdmdSYW5nZUVuZDsgaisrKSB7XG4gICAgICBhdmdYICs9IGRhdGFbal0ueDtcbiAgICAgIGF2Z1kgKz0gZGF0YVtqXS55O1xuICAgIH1cbiAgICBhdmdYIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgIGF2Z1kgLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgY29uc3QgcmFuZ2VPZmZzID0gTWF0aC5mbG9vcihpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IHJhbmdlVG8gPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCB7eDogcG9pbnRBeCwgeTogcG9pbnRBeX0gPSBkYXRhW2FdO1xuICAgIG1heEFyZWEgPSBhcmVhID0gLTE7XG4gICAgZm9yIChqID0gcmFuZ2VPZmZzOyBqIDwgcmFuZ2VUbzsgaisrKSB7XG4gICAgICBhcmVhID0gMC41ICogTWF0aC5hYnMoXG4gICAgICAgIChwb2ludEF4IC0gYXZnWCkgKiAoZGF0YVtqXS55IC0gcG9pbnRBeSkgLVxuICAgICAgICAocG9pbnRBeCAtIGRhdGFbal0ueCkgKiAoYXZnWSAtIHBvaW50QXkpXG4gICAgICApO1xuICAgICAgaWYgKGFyZWEgPiBtYXhBcmVhKSB7XG4gICAgICAgIG1heEFyZWEgPSBhcmVhO1xuICAgICAgICBtYXhBcmVhUG9pbnQgPSBkYXRhW2pdO1xuICAgICAgICBuZXh0QSA9IGo7XG4gICAgICB9XG4gICAgfVxuICAgIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBtYXhBcmVhUG9pbnQ7XG4gICAgYSA9IG5leHRBO1xuICB9XG4gIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2VuZEluZGV4XTtcbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cbmZ1bmN0aW9uIG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCkge1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHgsIHksIHByZXZYLCBtaW5JbmRleCwgbWF4SW5kZXgsIHN0YXJ0SW5kZXgsIG1pblksIG1heFk7XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICBjb25zdCB4TWluID0gZGF0YVtzdGFydF0ueDtcbiAgY29uc3QgeE1heCA9IGRhdGFbZW5kSW5kZXhdLng7XG4gIGNvbnN0IGR4ID0geE1heCAtIHhNaW47XG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgcG9pbnQgPSBkYXRhW2ldO1xuICAgIHggPSAocG9pbnQueCAtIHhNaW4pIC8gZHggKiBhdmFpbGFibGVXaWR0aDtcbiAgICB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgICBtaW5JbmRleCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgICBtYXhJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyBwb2ludC54KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBpIC0gMTtcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihtaW5JbmRleCkgJiYgIWlzTnVsbE9yVW5kZWYobWF4SW5kZXgpKSB7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MSA9IE1hdGgubWluKG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MiA9IE1hdGgubWF4KG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgIGlmIChpbnRlcm1lZGlhdGVJbmRleDEgIT09IHN0YXJ0SW5kZXggJiYgaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4MV0sXG4gICAgICAgICAgICB4OiBhdmdYLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcm1lZGlhdGVJbmRleDIgIT09IHN0YXJ0SW5kZXggJiYgaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4Ml0sXG4gICAgICAgICAgICB4OiBhdmdYXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID4gMCAmJiBsYXN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgZGVjaW1hdGVkLnB1c2goZGF0YVtsYXN0SW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIGRlY2ltYXRlZC5wdXNoKHBvaW50KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICAgIG1pbkluZGV4ID0gbWF4SW5kZXggPSBzdGFydEluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0Ll9kZWNpbWF0ZWQpIHtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5fZGF0YTtcbiAgICBkZWxldGUgZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kYXRhO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHt2YWx1ZTogZGF0YX0pO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpIHtcbiAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIHBvaW50cykge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGNvdW50O1xuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1pbikubG8sIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCkge1xuICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgfSBlbHNlIHtcbiAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XG59XG52YXIgcGx1Z2luX2RlY2ltYXRpb24gPSB7XG4gIGlkOiAnZGVjaW1hdGlvbicsXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxnb3JpdGhtOiAnbWluLW1heCcsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gIH0sXG4gIGJlZm9yZUVsZW1lbnRzVXBkYXRlOiAoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBjaGFydC53aWR0aDtcbiAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgY29uc3Qge19kYXRhLCBpbmRleEF4aXN9ID0gZGF0YXNldDtcbiAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgY29uc3QgZGF0YSA9IF9kYXRhIHx8IGRhdGFzZXQuZGF0YTtcbiAgICAgIGlmIChyZXNvbHZlKFtpbmRleEF4aXMsIGNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzXSkgPT09ICd5Jykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGEuY29udHJvbGxlci5zdXBwb3J0c0RlY2ltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeEF4aXMgPSBjaGFydC5zY2FsZXNbbWV0YS54QXhpc0lEXTtcbiAgICAgIGlmICh4QXhpcy50eXBlICE9PSAnbGluZWFyJyAmJiB4QXhpcy50eXBlICE9PSAndGltZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXJ0Lm9wdGlvbnMucGFyc2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBkYXRhKTtcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkIHx8IDQgKiBhdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmIChjb3VudCA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZihfZGF0YSkpIHtcbiAgICAgICAgZGF0YXNldC5fZGF0YSA9IGRhdGE7XG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGE7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY2ltYXRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxldCBkZWNpbWF0ZWQ7XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgICBjYXNlICdsdHRiJzpcbiAgICAgICAgZGVjaW1hdGVkID0gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWluLW1heCc6XG4gICAgICAgIGRlY2ltYXRlZCA9IG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZWNpbWF0aW9uIGFsZ29yaXRobSAnJHtvcHRpb25zLmFsZ29yaXRobX0nYCk7XG4gICAgICB9XG4gICAgICBkYXRhc2V0Ll9kZWNpbWF0ZWQgPSBkZWNpbWF0ZWQ7XG4gICAgfSk7XG4gIH0sXG4gIGRlc3Ryb3koY2hhcnQpIHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB0cG9pbnRzID0gdGFyZ2V0LnBvaW50cztcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgbGV0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyk7XG4gICAgY29uc3QgYm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XG4gICAgaWYgKCF0YXJnZXQuc2VnbWVudHMpIHtcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICBzb3VyY2U6IHNlZ21lbnQsXG4gICAgICAgIHRhcmdldDogYm91bmRzLFxuICAgICAgICBzdGFydDogcG9pbnRzW3N0YXJ0XSxcbiAgICAgICAgZW5kOiBwb2ludHNbZW5kXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0U2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0YXJnZXQsIGJvdW5kcyk7XG4gICAgZm9yIChjb25zdCB0Z3Qgb2YgdGFyZ2V0U2VnbWVudHMpIHtcbiAgICAgIGNvbnN0IHN1YkJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHRwb2ludHNbdGd0LnN0YXJ0XSwgdHBvaW50c1t0Z3QuZW5kXSwgdGd0Lmxvb3ApO1xuICAgICAgY29uc3QgZmlsbFNvdXJjZXMgPSBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgc3ViQm91bmRzKTtcbiAgICAgIGZvciAoY29uc3QgZmlsbFNvdXJjZSBvZiBmaWxsU291cmNlcykge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2U6IGZpbGxTb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnc3RhcnQnLCBNYXRoLm1heClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdlbmQnLCBNYXRoLm1pbilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5mdW5jdGlvbiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBmaXJzdCwgbGFzdCwgbG9vcCkge1xuICBpZiAobG9vcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhcnQgPSBmaXJzdFtwcm9wZXJ0eV07XG4gIGxldCBlbmQgPSBsYXN0W3Byb3BlcnR5XTtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgc3RhcnQgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICAgIGVuZCA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICB9XG4gIHJldHVybiB7cHJvcGVydHksIHN0YXJ0LCBlbmR9O1xufVxuZnVuY3Rpb24gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSkge1xuICBjb25zdCB7eCA9IG51bGwsIHkgPSBudWxsfSA9IGJvdW5kYXJ5IHx8IHt9O1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBsaW5lLnNlZ21lbnRzLmZvckVhY2goKHtzdGFydCwgZW5kfSkgPT4ge1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBsaW5lUG9pbnRzKTtcbiAgICBjb25zdCBmaXJzdCA9IGxpbmVQb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3QgPSBsaW5lUG9pbnRzW2VuZF07XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBmaXJzdC54LCB5fSk7XG4gICAgICBwb2ludHMucHVzaCh7eDogbGFzdC54LCB5fSk7XG4gICAgfSBlbHNlIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogZmlyc3QueX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGxhc3QueX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5mdW5jdGlvbiBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XG4gIGZvciAoO2VuZCA+IHN0YXJ0OyBlbmQtLSkge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2VuZF07XG4gICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gX2dldEVkZ2UoYSwgYiwgcHJvcCwgZm4pIHtcbiAgaWYgKGEgJiYgYikge1xuICAgIHJldHVybiBmbihhW3Byb3BdLCBiW3Byb3BdKTtcbiAgfVxuICByZXR1cm4gYSA/IGFbcHJvcF0gOiBiID8gYltwcm9wXSA6IDA7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpIHtcbiAgbGV0IHBvaW50cyA9IFtdO1xuICBsZXQgX2xvb3AgPSBmYWxzZTtcbiAgaWYgKGlzQXJyYXkoYm91bmRhcnkpKSB7XG4gICAgX2xvb3AgPSB0cnVlO1xuICAgIHBvaW50cyA9IGJvdW5kYXJ5O1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpO1xuICB9XG4gIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICBwb2ludHMsXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxuICAgIF9sb29wLFxuICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuZmlsbCAhPT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGluZGV4LCBwcm9wYWdhdGUpIHtcbiAgY29uc3Qgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gIGxldCBmaWxsID0gc291cmNlLmZpbGw7XG4gIGNvbnN0IHZpc2l0ZWQgPSBbaW5kZXhdO1xuICBsZXQgdGFyZ2V0O1xuICBpZiAoIXByb3BhZ2F0ZSkge1xuICAgIHJldHVybiBmaWxsO1xuICB9XG4gIHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG4gICAgaWYgKCFpc051bWJlckZpbml0ZShmaWxsKSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuICAgIHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG4gICAgdmlzaXRlZC5wdXNoKGZpbGwpO1xuICAgIGZpbGwgPSB0YXJnZXQuZmlsbDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgY29uc3QgZmlsbCA9IHBhcnNlRmlsbE9wdGlvbihsaW5lKTtcbiAgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICB9XG4gIGxldCB0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwpO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUodGFyZ2V0KSAmJiBNYXRoLmZsb29yKHRhcmdldCkgPT09IHRhcmdldCkge1xuICAgIHJldHVybiBkZWNvZGVUYXJnZXRJbmRleChmaWxsWzBdLCBpbmRleCwgdGFyZ2V0LCBjb3VudCk7XG4gIH1cbiAgcmV0dXJuIFsnb3JpZ2luJywgJ3N0YXJ0JywgJ2VuZCcsICdzdGFjaycsICdzaGFwZSddLmluZGV4T2YoZmlsbCkgPj0gMCAmJiBmaWxsO1xufVxuZnVuY3Rpb24gZGVjb2RlVGFyZ2V0SW5kZXgoZmlyc3RDaCwgaW5kZXgsIHRhcmdldCwgY291bnQpIHtcbiAgaWYgKGZpcnN0Q2ggPT09ICctJyB8fCBmaXJzdENoID09PSAnKycpIHtcbiAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcbiAgfVxuICBpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKSB7XG4gIGxldCBwaXhlbCA9IG51bGw7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5ib3R0b207XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLnRvcDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHBpeGVsID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICB9XG4gIHJldHVybiBwaXhlbDtcbn1cbmZ1bmN0aW9uIF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnRWYWx1ZSkge1xuICBsZXQgdmFsdWU7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgdmFsdWUgPSBzdGFydFZhbHVlO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgdmFsdWUgPSBzY2FsZS5vcHRpb25zLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXg7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBzY2FsZS5nZXRCYXNlVmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICBjb25zdCBvcHRpb25zID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZmlsbCA9ICEhb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ29yaWdpbic7XG4gIH1cbiAgcmV0dXJuIGZpbGw7XG59XG5cbmZ1bmN0aW9uIF9idWlsZFN0YWNrTGluZShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBpbmRleCwgbGluZX0gPSBzb3VyY2U7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHNvdXJjZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBsaW5lc0JlbG93ID0gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpO1xuICBsaW5lc0JlbG93LnB1c2goX2NyZWF0ZUJvdW5kYXJ5TGluZSh7eDogbnVsbCwgeTogc2NhbGUuYm90dG9tfSwgbGluZSkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGZvciAobGV0IGogPSBzZWdtZW50LnN0YXJ0OyBqIDw9IHNlZ21lbnQuZW5kOyBqKyspIHtcbiAgICAgIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnRzW2pdLCBsaW5lc0JlbG93KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMaW5lRWxlbWVudCh7cG9pbnRzLCBvcHRpb25zOiB7fX0pO1xufVxuZnVuY3Rpb24gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpIHtcbiAgY29uc3QgYmVsb3cgPSBbXTtcbiAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnbGluZScpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgIGlmIChtZXRhLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbWV0YS5oaWRkZW4pIHtcbiAgICAgIGJlbG93LnVuc2hpZnQobWV0YS5kYXRhc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlbG93O1xufVxuZnVuY3Rpb24gYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludCwgbGluZXNCZWxvdykge1xuICBjb25zdCBwb3N0cG9uZWQgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lc0JlbG93Lmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzQmVsb3dbal07XG4gICAgY29uc3Qge2ZpcnN0LCBsYXN0LCBwb2ludH0gPSBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsICd4Jyk7XG4gICAgaWYgKCFwb2ludCB8fCAoZmlyc3QgJiYgbGFzdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIHBvc3Rwb25lZC51bnNoaWZ0KHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb2ludHMucHVzaCguLi5wb3N0cG9uZWQpO1xufVxuZnVuY3Rpb24gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBwb2ludCA9IGxpbmUuaW50ZXJwb2xhdGUoc291cmNlUG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKCFwb2ludCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBwb2ludFZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gIGxldCBsYXN0ID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5zdGFydF1bcHJvcGVydHldO1xuICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5lbmRdW3Byb3BlcnR5XTtcbiAgICBpZiAoX2lzQmV0d2Vlbihwb2ludFZhbHVlLCBmaXJzdFZhbHVlLCBsYXN0VmFsdWUpKSB7XG4gICAgICBmaXJzdCA9IHBvaW50VmFsdWUgPT09IGZpcnN0VmFsdWU7XG4gICAgICBsYXN0ID0gcG9pbnRWYWx1ZSA9PT0gbGFzdFZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7Zmlyc3QsIGxhc3QsIHBvaW50fTtcbn1cblxuY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuICBwYXRoU2VnbWVudChjdHgsIGJvdW5kcywgb3B0cykge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBib3VuZHMgPSBib3VuZHMgfHwge3N0YXJ0OiAwLCBlbmQ6IFRBVX07XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGJvdW5kcy5lbmQsIGJvdW5kcy5zdGFydCwgdHJ1ZSk7XG4gICAgcmV0dXJuICFvcHRzLmJvdW5kcztcbiAgfVxuICBpbnRlcnBvbGF0ZShwb2ludCkge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBjb25zdCBhbmdsZSA9IHBvaW50LmFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0VGFyZ2V0KHNvdXJjZSkge1xuICBjb25zdCB7Y2hhcnQsIGZpbGwsIGxpbmV9ID0gc291cmNlO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcbiAgICByZXR1cm4gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGZpbGwpO1xuICB9XG4gIGlmIChmaWxsID09PSAnc3RhY2snKSB7XG4gICAgcmV0dXJuIF9idWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICB9XG4gIGlmIChmaWxsID09PSAnc2hhcGUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcbiAgaWYgKGJvdW5kYXJ5IGluc3RhbmNlb2Ygc2ltcGxlQXJjKSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKTtcbn1cbmZ1bmN0aW9uIGdldExpbmVCeUluZGV4KGNoYXJ0LCBpbmRleCkge1xuICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICBjb25zdCB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcbiAgcmV0dXJuIHZpc2libGUgPyBtZXRhLmRhdGFzZXQgOiBudWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCBzY2FsZSA9IHNvdXJjZS5zY2FsZSB8fCB7fTtcbiAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlID0ge30sIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBwaXhlbCA9IF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSk7XG4gIGlmIChpc051bWJlckZpbml0ZShwaXhlbCkpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyBwaXhlbCA6IG51bGwsXG4gICAgICB5OiBob3Jpem9udGFsID8gbnVsbCA6IHBpeGVsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgY29uc3QgdmFsdWUgPSBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0KTtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG4gIGlmIChvcHRpb25zLmdyaWQuY2lyY3VsYXIpIHtcbiAgICBjb25zdCBjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xuICAgIHJldHVybiBuZXcgc2ltcGxlQXJjKHtcbiAgICAgIHg6IGNlbnRlci54LFxuICAgICAgeTogY2VudGVyLnksXG4gICAgICByYWRpdXM6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKVxuICAgIH0pO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB0YXJnZXQucHVzaChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdmFsdWUpKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gX2dldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7bGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xuICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IGxpbmVPcHRzLmZpbGw7XG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xuICBjb25zdCB7YWJvdmUgPSBjb2xvciwgYmVsb3cgPSBjb2xvcn0gPSBmaWxsT3B0aW9uIHx8IHt9O1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpc30pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBwcm9wZXJ0eSA9IGxpbmUuX2xvb3AgPyAnYW5nbGUnIDogY2ZnLmF4aXM7XG4gIGN0eC5zYXZlKCk7XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnICYmIGJlbG93ICE9PSBhYm92ZSkge1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS50b3ApO1xuICAgIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgfVxuICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGJlbG93LCBzY2FsZSwgcHJvcGVydHl9KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgY2xpcFkpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBwb2ludHN9ID0gdGFyZ2V0O1xuICBsZXQgZmlyc3QgPSB0cnVlO1xuICBsZXQgbGluZUxvb3AgPSBmYWxzZTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBjbGlwWSk7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICB9XG4gICAgbGluZUxvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHttb3ZlOiBsaW5lTG9vcH0pO1xuICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGxhc3RQb2ludC54LCBjbGlwWSk7XG4gICAgfVxuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiBmaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIHByb3BlcnR5LCBjb2xvciwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBzZWdtZW50cyA9IF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KTtcbiAgZm9yIChjb25zdCB7c291cmNlOiBzcmMsIHRhcmdldDogdGd0LCBzdGFydCwgZW5kfSBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdHlsZToge2JhY2tncm91bmRDb2xvciA9IGNvbG9yfSA9IHt9fSA9IHNyYztcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBub3RTaGFwZSAmJiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBzdGFydCwgZW5kKSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNvbnN0IGxpbmVMb29wID0gISFsaW5lLnBhdGhTZWdtZW50KGN0eCwgc3JjKTtcbiAgICBsZXQgbG9vcDtcbiAgICBpZiAobm90U2hhcGUpIHtcbiAgICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIGVuZCwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0TG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgdGd0LCB7bW92ZTogbGluZUxvb3AsIHJldmVyc2U6IHRydWV9KTtcbiAgICAgIGxvb3AgPSBsaW5lTG9vcCAmJiB0YXJnZXRMb29wO1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgc3RhcnQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKGxvb3AgPyAnZXZlbm9kZCcgOiAnbm9uemVybycpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgYm91bmRzKSB7XG4gIGNvbnN0IHt0b3AsIGJvdHRvbX0gPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KHN0YXJ0LCB0b3AsIGVuZCAtIHN0YXJ0LCBib3R0b20gLSB0b3ApO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgcG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGludGVycG9sYXRlZFBvaW50ID0gdGFyZ2V0LmludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmIChpbnRlcnBvbGF0ZWRQb2ludCkge1xuICAgIGN0eC5saW5lVG8oaW50ZXJwb2xhdGVkUG9pbnQueCwgaW50ZXJwb2xhdGVkUG9pbnQueSk7XG4gIH1cbn1cblxudmFyIGluZGV4ID0ge1xuICBpZDogJ2ZpbGxlcicsXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgICAgc291cmNlID0gbnVsbDtcbiAgICAgIGlmIChsaW5lICYmIGxpbmUub3B0aW9ucyAmJiBsaW5lIGluc3RhbmNlb2YgTGluZUVsZW1lbnQpIHtcbiAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgIHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgZmlsbDogX2RlY29kZUZpbGwobGluZSwgaSwgY291bnQpLFxuICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgIGF4aXM6IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmluZGV4QXhpcyxcbiAgICAgICAgICBzY2FsZTogbWV0YS52U2NhbGUsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5maWxsID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5maWxsID0gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaSwgb3B0aW9ucy5wcm9wYWdhdGUpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UubGluZS51cGRhdGVDb250cm9sUG9pbnRzKGFyZWEsIHNvdXJjZS5heGlzKTtcbiAgICAgIGlmIChkcmF3ICYmIHNvdXJjZS5maWxsKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiZWZvcmVEYXRhc2V0c0RyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0c0RyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgIGlmIChfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldERyYXcoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmdzLm1ldGEuJGZpbGxlcjtcbiAgICBpZiAoIV9zaG91bGRBcHBseUZpbGwoc291cmNlKSB8fCBvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldERyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0RHJhdydcbiAgfVxufTtcblxuY29uc3QgZ2V0Qm94U2l6ZSA9IChsYWJlbE9wdHMsIGZvbnRTaXplKSA9PiB7XG4gIGxldCB7Ym94SGVpZ2h0ID0gZm9udFNpemUsIGJveFdpZHRoID0gZm9udFNpemV9ID0gbGFiZWxPcHRzO1xuICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcbiAgICBib3hXaWR0aCA9IGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJveFdpZHRoLFxuICAgIGJveEhlaWdodCxcbiAgICBpdGVtSGVpZ2h0OiBNYXRoLm1heChmb250U2l6ZSwgYm94SGVpZ2h0KVxuICB9O1xufTtcbmNvbnN0IGl0ZW1zRXF1YWwgPSAoYSwgYikgPT4gYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuZGF0YXNldEluZGV4ID09PSBiLmRhdGFzZXRJbmRleCAmJiBhLmluZGV4ID09PSBiLmluZGV4O1xuY2xhc3MgTGVnZW5kIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuICAgIHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbHVtblNpemVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGluZVdpZHRocyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnM7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5idWlsZExhYmVscygpO1xuICAgIHRoaXMuZml0KCk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSB0aGlzLl9tYXJnaW5zLmxlZnQ7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHRoaXMudG9wID0gdGhpcy5fbWFyZ2lucy50b3A7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgfVxuICBidWlsZExhYmVscygpIHtcbiAgICBjb25zdCBsYWJlbE9wdHMgPSB0aGlzLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICAgIGxldCBsZWdlbmRJdGVtcyA9IGNhbGxiYWNrKGxhYmVsT3B0cy5nZW5lcmF0ZUxhYmVscywgW3RoaXMuY2hhcnRdLCB0aGlzKSB8fCBbXTtcbiAgICBpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGxhYmVsT3B0cy5maWx0ZXIoaXRlbSwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsYWJlbE9wdHMuc29ydCkge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5zb3J0KChhLCBiKSA9PiBsYWJlbE9wdHMuc29ydChhLCBiLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHRoaXMubGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcztcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGN0eH0gPSB0aGlzO1xuICAgIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbE9wdHMgPSBvcHRpb25zLmxhYmVscztcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7Ym94V2lkdGgsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMuX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB3aWR0aCA9IHRoaXMuX2ZpdENvbHModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWluKHdpZHRoLCBvcHRpb25zLm1heFdpZHRoIHx8IHRoaXMubWF4V2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBvcHRpb25zLm1heEhlaWdodCB8fCB0aGlzLm1heEhlaWdodCk7XG4gIH1cbiAgX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heFdpZHRoLCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgbGluZVdpZHRocyA9IHRoaXMubGluZVdpZHRocyA9IFswXTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgbGV0IHRvdGFsSGVpZ2h0ID0gdGl0bGVIZWlnaHQ7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgbGV0IHJvdyA9IC0xO1xuICAgIGxldCB0b3AgPSAtbGluZUhlaWdodDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGlmIChpID09PSAwIHx8IGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArIGl0ZW1XaWR0aCArIDIgKiBwYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIChpID4gMCA/IDAgOiAxKV0gPSAwO1xuICAgICAgICB0b3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0OiAwLCB0b3AsIHJvdywgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcbiAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSBpdGVtV2lkdGggKyBwYWRkaW5nO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3RhbEhlaWdodDtcbiAgfVxuICBfZml0Q29scyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4SGVpZ2h0LCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmNvbHVtblNpemVzID0gW107XG4gICAgY29uc3QgaGVpZ2h0TGltaXQgPSBtYXhIZWlnaHQgLSB0aXRsZUhlaWdodDtcbiAgICBsZXQgdG90YWxXaWR0aCA9IHBhZGRpbmc7XG4gICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IDA7XG4gICAgbGV0IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgY29sID0gMDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCArIDIgKiBwYWRkaW5nID4gaGVpZ2h0TGltaXQpIHtcbiAgICAgICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTtcbiAgICAgICAgbGVmdCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2wrKztcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0LCB0b3A6IGN1cnJlbnRDb2xIZWlnaHQsIGNvbCwgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcbiAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcbiAgICAgIGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgfSk7XG4gICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGg7XG4gICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7XG4gICAgcmV0dXJuIHRvdGFsV2lkdGg7XG4gIH1cbiAgYWRqdXN0SGl0Qm94ZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtsZWdlbmRIaXRCb3hlczogaGl0Ym94ZXMsIG9wdGlvbnM6IHthbGlnbiwgbGFiZWxzOiB7cGFkZGluZ30sIHJ0bH19ID0gdGhpcztcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKHJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICBsZXQgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKHJvdyAhPT0gaGl0Ym94LnJvdykge1xuICAgICAgICAgIHJvdyA9IGhpdGJveC5yb3c7XG4gICAgICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgKz0gdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngobGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIGxlZnQgKz0gaGl0Ym94LndpZHRoICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbCA9IDA7XG4gICAgICBsZXQgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKGhpdGJveC5jb2wgIT09IGNvbCkge1xuICAgICAgICAgIGNvbCA9IGhpdGJveC5jb2w7XG4gICAgICAgICAgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgPSB0b3A7XG4gICAgICAgIGhpdGJveC5sZWZ0ICs9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngoaGl0Ym94LmxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICB0b3AgKz0gaGl0Ym94LmhlaWdodCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuICB9XG4gIGRyYXcoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGNsaXBBcmVhKGN0eCwgdGhpcyk7XG4gICAgICB0aGlzLl9kcmF3KCk7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG4gIF9kcmF3KCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiBvcHRzLCBjb2x1bW5TaXplcywgbGluZVdpZHRocywgY3R4fSA9IHRoaXM7XG4gICAgY29uc3Qge2FsaWduLCBsYWJlbHM6IGxhYmVsT3B0c30gPSBvcHRzO1xuICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IGRlZmF1bHRzLmNvbG9yO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCB7Y29sb3I6IGZvbnRDb2xvciwgcGFkZGluZ30gPSBsYWJlbE9wdHM7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG4gICAgbGV0IGN1cnNvcjtcbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuICAgIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0LCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG4gICAgY29uc3QgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCB8fCBpc05hTihib3hIZWlnaHQpIHx8IGJveEhlaWdodCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCAxKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmZpbGxTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lQ2FwLCAnYnV0dCcpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgMCk7XG4gICAgICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVKb2luLCAnbWl0ZXInKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2gsIFtdKSk7XG4gICAgICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgICAgcmFkaXVzOiBib3hIZWlnaHQgKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuICAgICAgICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSwgbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCAmJiBib3hXaWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB5Qm94VG9wID0geSArIE1hdGgubWF4KChmb250U2l6ZSAtIGJveEhlaWdodCkgLyAyLCAwKTtcbiAgICAgICAgY29uc3QgeEJveExlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCk7XG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGVnZW5kSXRlbS5ib3JkZXJSYWRpdXMpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgeDogeEJveExlZnQsXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxuICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIChpdGVtSGVpZ2h0IC8gMiksIGxhYmVsRm9udCwge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICB5OiB0aGlzLnRvcCArIHBhZGRpbmcgKyB0aXRsZUhlaWdodCxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiB0aGlzLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbMF0uaGVpZ2h0KSxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yIHx8IGZvbnRDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvciB8fCBmb250Q29sb3I7XG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xuICAgICAgY29uc3Qgd2lkdGggPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHRleHRXaWR0aDtcbiAgICAgIGxldCB4ID0gY3Vyc29yLng7XG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xuICAgICAgcnRsSGVscGVyLnNldFdpZHRoKHRoaXMud2lkdGgpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWxYID0gcnRsSGVscGVyLngoeCk7XG4gICAgICBkcmF3TGVnZW5kQm94KHJlYWxYLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcbiAgICAgIGZpbGxUZXh0KHJ0bEhlbHBlci54KHgpLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN0b3JlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aXRsZU9wdHMgPSBvcHRzLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xuICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICBsZXQgeTtcbiAgICBsZXQgbGVmdCA9IHRoaXMubGVmdDtcbiAgICBsZXQgbWF4V2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLmNvbHVtblNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBNYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20gLSBtYXhIZWlnaHQgLSBvcHRzLmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cbiAgICBjb25zdCB4ID0gX2FsaWduU3RhcnRFbmQocG9zaXRpb24sIGxlZnQsIGxlZnQgKyBtYXhXaWR0aCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oX3RvTGVmdFJpZ2h0Q2VudGVyKHBvc2l0aW9uKSk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cbiAgX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcbiAgICBjb25zdCB0aXRsZU9wdHMgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIHJldHVybiB0aXRsZU9wdHMuZGlzcGxheSA/IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVQYWRkaW5nLmhlaWdodCA6IDA7XG4gIH1cbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XG4gICAgbGV0IGksIGhpdEJveCwgbGg7XG4gICAgaWYgKF9pc0JldHdlZW4oeCwgdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KVxuICAgICAgJiYgX2lzQmV0d2Vlbih5LCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pKSB7XG4gICAgICBsaCA9IHRoaXMubGVnZW5kSGl0Qm94ZXM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaGl0Qm94ID0gbGhbaV07XG4gICAgICAgIGlmIChfaXNCZXR3ZWVuKHgsIGhpdEJveC5sZWZ0LCBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aClcbiAgICAgICAgICAmJiBfaXNCZXR3ZWVuKHksIGhpdEJveC50b3AsIGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghaXNMaXN0ZW5lZChlLnR5cGUsIG9wdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5faG92ZXJlZEl0ZW07XG4gICAgICBjb25zdCBzYW1lSXRlbSA9IGl0ZW1zRXF1YWwocHJldmlvdXMsIGhvdmVyZWRJdGVtKTtcbiAgICAgIGlmIChwcmV2aW91cyAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbGJhY2sob3B0cy5vbkxlYXZlLCBbZSwgcHJldmlvdXMsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG4gICAgICBpZiAoaG92ZXJlZEl0ZW0gJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdHMub25Ib3ZlciwgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChob3ZlcmVkSXRlbSkge1xuICAgICAgY2FsbGJhY2sob3B0cy5vbkNsaWNrLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTGlzdGVuZWQodHlwZSwgb3B0cykge1xuICBpZiAoKHR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IHR5cGUgPT09ICdtb3VzZW91dCcpICYmIChvcHRzLm9uSG92ZXIgfHwgb3B0cy5vbkxlYXZlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRzLm9uQ2xpY2sgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ21vdXNldXAnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBwbHVnaW5fbGVnZW5kID0ge1xuICBpZDogJ2xlZ2VuZCcsXG4gIF9lbGVtZW50OiBMZWdlbmQsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoe2N0eDogY2hhcnQuY3R4LCBvcHRpb25zLCBjaGFydH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuICB9LFxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGNoYXJ0LmxlZ2VuZCk7XG4gICAgZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsZWdlbmQub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGFmdGVyVXBkYXRlKGNoYXJ0KSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxlZ2VuZC5idWlsZExhYmVscygpO1xuICAgIGxlZ2VuZC5hZGp1c3RIaXRCb3hlcygpO1xuICB9LFxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKCFhcmdzLnJlcGxheSkge1xuICAgICAgY2hhcnQubGVnZW5kLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcmV2ZXJzZTogZmFsc2UsXG4gICAgd2VpZ2h0OiAxMDAwLFxuICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuICAgICAgY29uc3QgY2kgPSBsZWdlbmQuY2hhcnQ7XG4gICAgICBpZiAoY2kuaXNEYXRhc2V0VmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgY2kuaGlkZShpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpLnNob3coaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkxlYXZlOiBudWxsLFxuICAgIGxhYmVsczoge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgYm94V2lkdGg6IDQwLFxuICAgICAgcGFkZGluZzogMTAsXG4gICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG4gICAgICAgIGNvbnN0IHtsYWJlbHM6IHt1c2VQb2ludFN0eWxlLCBwb2ludFN0eWxlLCB0ZXh0QWxpZ24sIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpID0+IHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0b1BhZGRpbmcoc3R5bGUuYm9yZGVyV2lkdGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBkYXRhc2V0c1ttZXRhLmluZGV4XS5sYWJlbCxcbiAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGhpZGRlbjogIW1ldGEudmlzaWJsZSxcbiAgICAgICAgICAgIGxpbmVDYXA6IHN0eWxlLmJvcmRlckNhcFN0eWxlLFxuICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICAgIGxpbmVKb2luOiBzdHlsZS5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChib3JkZXJXaWR0aC53aWR0aCArIGJvcmRlcldpZHRoLmhlaWdodCkgLyA0LFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSB8fCBzdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gICAgICB0ZXh0OiAnJyxcbiAgICB9XG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhWydnZW5lcmF0ZUxhYmVscycsICdmaWx0ZXInLCAnc29ydCddLmluY2x1ZGVzKG5hbWUpLFxuICAgIH1cbiAgfSxcbn07XG5cbmNsYXNzIFRpdGxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5fcGFkZGluZyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5sZWZ0ID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IHRoaXMucmlnaHQgPSB0aGlzLmJvdHRvbSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0ID0gbWF4V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdHRvbSA9IG1heEhlaWdodDtcbiAgICBjb25zdCBsaW5lQ291bnQgPSBpc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcbiAgICB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMucGFkZGluZyk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBsaW5lQ291bnQgKiB0b0ZvbnQob3B0cy5mb250KS5saW5lSGVpZ2h0ICsgdGhpcy5fcGFkZGluZy5oZWlnaHQ7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0ZXh0U2l6ZTtcbiAgICB9XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuICB9XG4gIF9kcmF3QXJncyhvZmZzZXQpIHtcbiAgICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgIHRpdGxlWSA9IHRvcCArIG9mZnNldDtcbiAgICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRpdGxlWCA9IGxlZnQgKyBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAtMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGVYID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0b3AsIGJvdHRvbSk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAwLjU7XG4gICAgICB9XG4gICAgICBtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcbiAgICB9XG4gICAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm9udE9wdHMgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIHRoaXMuX3BhZGRpbmcudG9wO1xuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRoaXMuX2RyYXdBcmdzKG9mZnNldCk7XG4gICAgcmVuZGVyVGV4dChjdHgsIG9wdHMudGV4dCwgMCwgMCwgZm9udE9wdHMsIHtcbiAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogX3RvTGVmdFJpZ2h0Q2VudGVyKG9wdHMuYWxpZ24pLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVUaXRsZShjaGFydCwgdGl0bGVPcHRzKSB7XG4gIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICBvcHRpb25zOiB0aXRsZU9wdHMsXG4gICAgY2hhcnRcbiAgfSk7XG4gIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcbiAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgY2hhcnQudGl0bGVCbG9jayA9IHRpdGxlO1xufVxudmFyIHBsdWdpbl90aXRsZSA9IHtcbiAgaWQ6ICd0aXRsZScsXG4gIF9lbGVtZW50OiBUaXRsZSxcbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY3JlYXRlVGl0bGUoY2hhcnQsIG9wdGlvbnMpO1xuICB9LFxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHRpdGxlQmxvY2spO1xuICAgIGRlbGV0ZSBjaGFydC50aXRsZUJsb2NrO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMTAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMjAwMFxuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG5cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgcGx1Z2luX3N1YnRpdGxlID0ge1xuICBpZDogJ3N1YnRpdGxlJyxcbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgICAgY3R4OiBjaGFydC5jdHgsXG4gICAgICBvcHRpb25zLFxuICAgICAgY2hhcnRcbiAgICB9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gICAgbWFwLnNldChjaGFydCwgdGl0bGUpO1xuICB9LFxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIG1hcC5nZXQoY2hhcnQpKTtcbiAgICBtYXAuZGVsZXRlKGNoYXJ0KTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbWFwLmdldChjaGFydCk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMTUwMFxuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG5cbmNvbnN0IHBvc2l0aW9uZXJzID0ge1xuICBhdmVyYWdlKGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGksIGxlbjtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICB4ICs9IHBvcy54O1xuICAgICAgICB5ICs9IHBvcy55O1xuICAgICAgICArK2NvdW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogeCAvIGNvdW50LFxuICAgICAgeTogeSAvIGNvdW50XG4gICAgfTtcbiAgfSxcbiAgbmVhcmVzdChpdGVtcywgZXZlbnRQb3NpdGlvbikge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCB4ID0gZXZlbnRQb3NpdGlvbi54O1xuICAgIGxldCB5ID0gZXZlbnRQb3NpdGlvbi55O1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZWwuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuICAgICAgICBpZiAoZCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkO1xuICAgICAgICAgIG5lYXJlc3RFbGVtZW50ID0gZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lYXJlc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgeCA9IHRwLng7XG4gICAgICB5ID0gdHAueTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcbiAgaWYgKHRvUHVzaCkge1xuICAgIGlmIChpc0FycmF5KHRvUHVzaCkpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UucHVzaCh0b1B1c2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZTtcbn1cbmZ1bmN0aW9uIHNwbGl0TmV3bGluZXMoc3RyKSB7XG4gIGlmICgodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nKSAmJiBzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgIHJldHVybiBzdHIuc3BsaXQoJ1xcbicpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShjaGFydCwgaXRlbSkge1xuICBjb25zdCB7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0gPSBpdGVtO1xuICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICBjb25zdCB7bGFiZWwsIHZhbHVlfSA9IGNvbnRyb2xsZXIuZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCk7XG4gIHJldHVybiB7XG4gICAgY2hhcnQsXG4gICAgbGFiZWwsXG4gICAgcGFyc2VkOiBjb250cm9sbGVyLmdldFBhcnNlZChpbmRleCksXG4gICAgcmF3OiBjaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0sXG4gICAgZm9ybWF0dGVkVmFsdWU6IHZhbHVlLFxuICAgIGRhdGFzZXQ6IGNvbnRyb2xsZXIuZ2V0RGF0YXNldCgpLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgZGF0YXNldEluZGV4LFxuICAgIGVsZW1lbnRcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgY3R4ID0gdG9vbHRpcC5jaGFydC5jdHg7XG4gIGNvbnN0IHtib2R5LCBmb290ZXIsIHRpdGxlfSA9IHRvb2x0aXA7XG4gIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICBjb25zdCBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xuICBjb25zdCBmb290ZXJMaW5lQ291bnQgPSBmb290ZXIubGVuZ3RoO1xuICBjb25zdCBib2R5TGluZUl0ZW1Db3VudCA9IGJvZHkubGVuZ3RoO1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGxldCBoZWlnaHQgPSBwYWRkaW5nLmhlaWdodDtcbiAgbGV0IHdpZHRoID0gMDtcbiAgbGV0IGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKChjb3VudCwgYm9keUl0ZW0pID0+IGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aCwgMCk7XG4gIGNvbWJpbmVkQm9keUxlbmd0aCArPSB0b29sdGlwLmJlZm9yZUJvZHkubGVuZ3RoICsgdG9vbHRpcC5hZnRlckJvZHkubGVuZ3RoO1xuICBpZiAodGl0bGVMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMudGl0bGVTcGFjaW5nXG5cdFx0XHQrIG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b207XG4gIH1cbiAgaWYgKGNvbWJpbmVkQm9keUxlbmd0aCkge1xuICAgIGNvbnN0IGJvZHlMaW5lSGVpZ2h0ID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gTWF0aC5tYXgoYm94SGVpZ2h0LCBib2R5Rm9udC5saW5lSGVpZ2h0KSA6IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgaGVpZ2h0ICs9IGJvZHlMaW5lSXRlbUNvdW50ICogYm9keUxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIGJvZHlMaW5lSXRlbUNvdW50KSAqIGJvZHlGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIDEpICogb3B0aW9ucy5ib2R5U3BhY2luZztcbiAgfVxuICBpZiAoZm9vdGVyTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wXG5cdFx0XHQrIGZvb3RlckxpbmVDb3VudCAqIGZvb3RlckZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoZm9vdGVyTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gIH1cbiAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XG4gIGNvbnN0IG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuICB9O1xuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC50aXRsZSwgbWF4TGluZVdpZHRoKTtcbiAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5iZWZvcmVCb2R5LmNvbmNhdCh0b29sdGlwLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG4gIHdpZHRoUGFkZGluZyA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IChib3hXaWR0aCArIDIgKyBvcHRpb25zLmJveFBhZGRpbmcpIDogMDtcbiAgZWFjaChib2R5LCAoYm9keUl0ZW0pID0+IHtcbiAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG4gIH0pO1xuICB3aWR0aFBhZGRpbmcgPSAwO1xuICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuICBjdHgucmVzdG9yZSgpO1xuICB3aWR0aCArPSBwYWRkaW5nLndpZHRoO1xuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKSB7XG4gIGNvbnN0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcbiAgaWYgKHkgPCBoZWlnaHQgLyAyKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9IGVsc2UgaWYgKHkgPiAoY2hhcnQuaGVpZ2h0IC0gaGVpZ2h0IC8gMikpIHtcbiAgICByZXR1cm4gJ2JvdHRvbSc7XG4gIH1cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuZnVuY3Rpb24gZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCBjYXJldCA9IG9wdGlvbnMuY2FyZXRTaXplICsgb3B0aW9ucy5jYXJldFBhZGRpbmc7XG4gIGlmICh4QWxpZ24gPT09ICdsZWZ0JyAmJiB4ICsgd2lkdGggKyBjYXJldCA+IGNoYXJ0LndpZHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0JyAmJiB4IC0gd2lkdGggLSBjYXJldCA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IHt3aWR0aDogY2hhcnRXaWR0aCwgY2hhcnRBcmVhOiB7bGVmdCwgcmlnaHR9fSA9IGNoYXJ0O1xuICBsZXQgeEFsaWduID0gJ2NlbnRlcic7XG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeEFsaWduID0geCA8PSAobGVmdCArIHJpZ2h0KSAvIDIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKHggPD0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKHggPj0gY2hhcnRXaWR0aCAtIHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdyaWdodCc7XG4gIH1cbiAgaWYgKGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkpIHtcbiAgICB4QWxpZ24gPSAnY2VudGVyJztcbiAgfVxuICByZXR1cm4geEFsaWduO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHlBbGlnbiA9IHNpemUueUFsaWduIHx8IG9wdGlvbnMueUFsaWduIHx8IGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSk7XG4gIHJldHVybiB7XG4gICAgeEFsaWduOiBzaXplLnhBbGlnbiB8fCBvcHRpb25zLnhBbGlnbiB8fCBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbiksXG4gICAgeUFsaWduXG4gIH07XG59XG5mdW5jdGlvbiBhbGlnblgoc2l6ZSwgeEFsaWduKSB7XG4gIGxldCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gd2lkdGg7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHdpZHRoIC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSkge1xuICBsZXQge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgIHkgKz0gcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSB7XG4gICAgeSAtPSAoaGVpZ2h0IC8gMik7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuICBjb25zdCB7Y2FyZXRTaXplLCBjYXJldFBhZGRpbmcsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gYWxpZ25tZW50O1xuICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcbiAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gIGxldCB4ID0gYWxpZ25YKHNpemUsIHhBbGlnbik7XG4gIGNvbnN0IHkgPSBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSk7XG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB4ICs9IHBhZGRpbmdBbmRTaXplO1xuICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB4IC09IHBhZGRpbmdBbmRTaXplO1xuICAgIH1cbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgIHggLT0gTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyBjYXJldFNpemU7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCArPSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpICsgY2FyZXRTaXplO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogX2xpbWl0VmFsdWUoeCwgMCwgY2hhcnQud2lkdGggLSBzaXplLndpZHRoKSxcbiAgICB5OiBfbGltaXRWYWx1ZSh5LCAwLCBjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFsaWduZWRYKHRvb2x0aXAsIGFsaWduLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJ1xuICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAvIDJcbiAgICA6IGFsaWduID09PSAncmlnaHQnXG4gICAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLSBwYWRkaW5nLnJpZ2h0XG4gICAgICA6IHRvb2x0aXAueCArIHBhZGRpbmcubGVmdDtcbn1cbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG4gIHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBDb250ZXh0KHBhcmVudCwgdG9vbHRpcCwgdG9vbHRpcEl0ZW1zKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRvb2x0aXAsXG4gICAgdG9vbHRpcEl0ZW1zLFxuICAgIHR5cGU6ICd0b29sdGlwJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCkge1xuICBjb25zdCBvdmVycmlkZSA9IGNvbnRleHQgJiYgY29udGV4dC5kYXRhc2V0ICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcbiAgcmV0dXJuIG92ZXJyaWRlID8gY2FsbGJhY2tzLm92ZXJyaWRlKG92ZXJyaWRlKSA6IGNhbGxiYWNrcztcbn1cbmNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IFtdO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0IHx8IGNvbmZpZy5fY2hhcnQ7XG4gICAgdGhpcy5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmVmb3JlQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZnRlckJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb290ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRZID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxDb2xvcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG4gIF9yZXNvbHZlQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9jYWNoZWRBbmltYXRpb25zO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmVuYWJsZWQgJiYgY2hhcnQub3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmNoYXJ0LCBvcHRzKTtcbiAgICBpZiAob3B0cy5fY2FjaGVhYmxlKSB7XG4gICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVUb29sdGlwQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcywgdGhpcy5fdG9vbHRpcEl0ZW1zKSk7XG4gIH1cbiAgZ2V0VGl0bGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBiZWZvcmVUaXRsZSA9IGNhbGxiYWNrcy5iZWZvcmVUaXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGNvbnN0IHRpdGxlID0gY2FsbGJhY2tzLnRpdGxlLmFwcGx5KHRoaXMsIFtjb250ZXh0XSk7XG4gICAgY29uc3QgYWZ0ZXJUaXRsZSA9IGNhbGxiYWNrcy5hZnRlclRpdGxlLmFwcGx5KHRoaXMsIFtjb250ZXh0XSk7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlVGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyh0aXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyVGl0bGUpKTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMob3B0aW9ucy5jYWxsYmFja3MuYmVmb3JlQm9keS5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSkpO1xuICB9XG4gIGdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlJdGVtcyA9IFtdO1xuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgYm9keUl0ZW0gPSB7XG4gICAgICAgIGJlZm9yZTogW10sXG4gICAgICAgIGxpbmVzOiBbXSxcbiAgICAgICAgYWZ0ZXI6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIHNwbGl0TmV3bGluZXMoc2NvcGVkLmJlZm9yZUxhYmVsLmNhbGwodGhpcywgY29udGV4dCkpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgc2NvcGVkLmxhYmVsLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmFmdGVyLCBzcGxpdE5ld2xpbmVzKHNjb3BlZC5hZnRlckxhYmVsLmNhbGwodGhpcywgY29udGV4dCkpKTtcbiAgICAgIGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm9keUl0ZW1zO1xuICB9XG4gIGdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMob3B0aW9ucy5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKSk7XG4gIH1cbiAgZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBiZWZvcmVGb290ZXIgPSBjYWxsYmFja3MuYmVmb3JlRm9vdGVyLmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKTtcbiAgICBjb25zdCBmb290ZXIgPSBjYWxsYmFja3MuZm9vdGVyLmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKTtcbiAgICBjb25zdCBhZnRlckZvb3RlciA9IGNhbGxiYWNrcy5hZnRlckZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZXMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFRleHRDb2xvcnMgPSBbXTtcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgbGV0IGksIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhY3RpdmUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRvb2x0aXBJdGVtcy5wdXNoKGNyZWF0ZVRvb2x0aXBJdGVtKHRoaXMuY2hhcnQsIGFjdGl2ZVtpXSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gb3B0aW9ucy5maWx0ZXIoZWxlbWVudCwgaW5kZXgsIGFycmF5LCBkYXRhKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLml0ZW1Tb3J0KSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuc29ydCgoYSwgYikgPT4gb3B0aW9ucy5pdGVtU29ydChhLCBiLCBkYXRhKSk7XG4gICAgfVxuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3Mob3B0aW9ucy5jYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgbGFiZWxDb2xvcnMucHVzaChzY29wZWQubGFiZWxDb2xvci5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsUG9pbnRTdHlsZXMucHVzaChzY29wZWQubGFiZWxQb2ludFN0eWxlLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goc2NvcGVkLmxhYmVsVGV4dENvbG9yLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgIH0pO1xuICAgIHRoaXMubGFiZWxDb2xvcnMgPSBsYWJlbENvbG9ycztcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSBsYWJlbFBvaW50U3R5bGVzO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcbiAgICByZXR1cm4gdG9vbHRpcEl0ZW1zO1xuICB9XG4gIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRoaXMuX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpO1xuICAgICAgdGhpcy50aXRsZSA9IHRoaXMuZ2V0VGl0bGUodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYmVmb3JlQm9keSA9IHRoaXMuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5ib2R5ID0gdGhpcy5nZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmFmdGVyQm9keSA9IHRoaXMuZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmZvb3RlciA9IHRoaXMuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIHRoaXMuY2hhcnQpO1xuICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgeDogYmFja2dyb3VuZFBvaW50LngsXG4gICAgICAgIHk6IGJhY2tncm91bmRQb2ludC55LFxuICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgY2FyZXRYOiBwb3NpdGlvbi54LFxuICAgICAgICBjYXJldFk6IHBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcztcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZWQgJiYgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgb3B0aW9ucy5leHRlcm5hbC5jYWxsKHRoaXMsIHtjaGFydDogdGhpcy5jaGFydCwgdG9vbHRpcDogdGhpcywgcmVwbGF5fSk7XG4gICAgfVxuICB9XG4gIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcbiAgfVxuICBnZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHtjYXJldFNpemUsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuICAgIGNvbnN0IHt4OiBwdFgsIHk6IHB0WX0gPSB0b29sdGlwUG9pbnQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2l6ZTtcbiAgICBsZXQgeDEsIHgyLCB4MywgeTEsIHkyLCB5MztcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgeTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDEgPSBwdFg7XG4gICAgICAgIHgyID0geDEgLSBjYXJldFNpemU7XG4gICAgICAgIHkxID0geTIgKyBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IHB0WCArIHdpZHRoO1xuICAgICAgICB4MiA9IHgxICsgY2FyZXRTaXplO1xuICAgICAgICB5MSA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeDMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyAoY2FyZXRTaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgIH1cbiAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkxID0gcHRZO1xuICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xuICAgICAgICB4MSA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSBwdFkgKyBoZWlnaHQ7XG4gICAgICAgIHkyID0geTEgKyBjYXJldFNpemU7XG4gICAgICAgIHgxID0geDIgKyBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgLSBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB5MyA9IHkxO1xuICAgIH1cbiAgICByZXR1cm4ge3gxLCB4MiwgeDMsIHkxLCB5MiwgeTN9O1xuICB9XG4gIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcbiAgICBsZXQgdGl0bGVGb250LCB0aXRsZVNwYWNpbmcsIGk7XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLnRpdGxlQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy50aXRsZUFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gICAgICB0aXRsZVNwYWNpbmcgPSBvcHRpb25zLnRpdGxlU3BhY2luZztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLnRpdGxlQ29sb3I7XG4gICAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVNwYWNpbmc7XG4gICAgICAgIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcHQueSArPSBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSB0aGlzLmxhYmVsQ29sb3JzW2ldO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZSA9IHRoaXMubGFiZWxQb2ludFN0eWxlc1tpXTtcbiAgICBjb25zdCB7Ym94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGNvbnN0IGNvbG9yWCA9IGdldEFsaWduZWRYKHRoaXMsICdsZWZ0Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcbiAgICBjb25zdCB5T2ZmU2V0ID0gYm94SGVpZ2h0IDwgYm9keUZvbnQubGluZUhlaWdodCA/IChib2R5Rm9udC5saW5lSGVpZ2h0IC0gYm94SGVpZ2h0KSAvIDIgOiAwO1xuICAgIGNvbnN0IGNvbG9yWSA9IHB0LnkgKyB5T2ZmU2V0O1xuICAgIGlmIChvcHRpb25zLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICByYWRpdXM6IE1hdGgubWluKGJveFdpZHRoLCBib3hIZWlnaHQpIC8gMixcbiAgICAgICAgcG9pbnRTdHlsZTogbGFiZWxQb2ludFN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9O1xuICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGNvbG9yWSArIGJveEhlaWdodCAvIDI7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGlzT2JqZWN0KGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMobGFiZWxDb2xvcnMuYm9yZGVyV2lkdGgpKSA6IChsYWJlbENvbG9ycy5ib3JkZXJXaWR0aCB8fCAxKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKGxhYmVsQ29sb3JzLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvcnMuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCAtIGJveFBhZGRpbmcpO1xuICAgICAgY29uc3QgaW5uZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLnhQbHVzKHJ0bENvbG9yWCwgMSksIGJveFdpZHRoIC0gYm94UGFkZGluZyAtIDIpO1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsYWJlbENvbG9ycy5ib3JkZXJSYWRpdXMpO1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBvdXRlclgsXG4gICAgICAgICAgeTogY29sb3JZLFxuICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogaW5uZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSArIDEsXG4gICAgICAgICAgdzogYm94V2lkdGggLSAyLFxuICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpbm5lclgsIGNvbG9yWSArIDEsIGJveFdpZHRoIC0gMiwgYm94SGVpZ2h0IC0gMik7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgfVxuICBkcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2JvZHl9ID0gdGhpcztcbiAgICBjb25zdCB7Ym9keVNwYWNpbmcsIGJvZHlBbGlnbiwgZGlzcGxheUNvbG9ycywgYm94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGxldCBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgbGV0IHhMaW5lUGFkZGluZyA9IDA7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGN0eC5maWxsVGV4dChsaW5lLCBydGxIZWxwZXIueChwdC54ICsgeExpbmVQYWRkaW5nKSwgcHQueSArIGJvZHlMaW5lSGVpZ2h0IC8gMik7XG4gICAgICBwdC55ICs9IGJvZHlMaW5lSGVpZ2h0ICsgYm9keVNwYWNpbmc7XG4gICAgfTtcbiAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICBsZXQgYm9keUl0ZW0sIHRleHRDb2xvciwgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XG4gICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uLCBvcHRpb25zKTtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgZWFjaCh0aGlzLmJlZm9yZUJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB4TGluZVBhZGRpbmcgPSBkaXNwbGF5Q29sb3JzICYmIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uICE9PSAncmlnaHQnXG4gICAgICA/IGJvZHlBbGlnbiA9PT0gJ2NlbnRlcicgPyAoYm94V2lkdGggLyAyICsgYm94UGFkZGluZykgOiAoYm94V2lkdGggKyAyICsgYm94UGFkZGluZylcbiAgICAgIDogMDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYm9keS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGJvZHlJdGVtID0gYm9keVtpXTtcbiAgICAgIHRleHRDb2xvciA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgICBsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGluZXMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgIGZpbGxMaW5lT2ZUZXh0KGxpbmVzW2pdKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuICAgIH1cbiAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgcHQueSAtPSBib2R5U3BhY2luZztcbiAgfVxuICBkcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb290ZXIgPSB0aGlzLmZvb3RlcjtcbiAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgIGxldCBmb290ZXJGb250LCBpO1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy5mb290ZXJBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBwdC55ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5mb290ZXJDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge3gsIHl9ID0gcHQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdG9vbHRpcFNpemU7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKG9wdGlvbnMuY29ybmVyUmFkaXVzKTtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgdG9wTGVmdCwgeSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSB0b3BSaWdodCwgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0b3BSaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYm90dG9tUmlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyB0b3BMZWZ0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wTGVmdCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbVggPSBhbmltcyAmJiBhbmltcy54O1xuICAgIGNvbnN0IGFuaW1ZID0gYW5pbXMgJiYgYW5pbXMueTtcbiAgICBpZiAoYW5pbVggfHwgYW5pbVkpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0aGlzLl9hY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHRoaXMuX3NpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgcG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIGNoYXJ0KTtcbiAgICAgIGlmIChhbmltWC5fdG8gIT09IHBvaW50LnggfHwgYW5pbVkuX3RvICE9PSBwb2ludC55KSB7XG4gICAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYXJldFggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLmNhcmV0WSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3dpbGxSZW5kZXIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5vcGFjaXR5O1xuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBsZXQgb3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpO1xuICAgIGNvbnN0IHRvb2x0aXBTaXplID0ge1xuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBwdCA9IHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueVxuICAgIH07XG4gICAgb3BhY2l0eSA9IE1hdGguYWJzKG9wYWNpdHkpIDwgMWUtMyA/IDAgOiBvcGFjaXR5O1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgICBjb25zdCBoYXNUb29sdGlwQ29udGVudCA9IHRoaXMudGl0bGUubGVuZ3RoIHx8IHRoaXMuYmVmb3JlQm9keS5sZW5ndGggfHwgdGhpcy5ib2R5Lmxlbmd0aCB8fCB0aGlzLmFmdGVyQm9keS5sZW5ndGggfHwgdGhpcy5mb290ZXIubGVuZ3RoO1xuICAgIGlmIChvcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgICBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgcHQueSArPSBwYWRkaW5nLnRvcDtcbiAgICAgIHRoaXMuZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5kcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYSBkYXRhc2V0IGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGV2ZW50UG9zaXRpb24pO1xuICAgIGlmIChjaGFuZ2VkIHx8IHBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IGV2ZW50UG9zaXRpb247XG4gICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEgPSB0cnVlKSB7XG4gICAgaWYgKHJlcGxheSAmJiB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gZmFsc2U7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpO1xuICAgIGNvbnN0IGNoYW5nZWQgPSByZXBsYXkgfHwgIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSkgfHwgcG9zaXRpb25DaGFuZ2VkO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBlLngsXG4gICAgICAgICAgeTogZS55XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlKHRydWUsIHJlcGxheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zLCByZXBsYXkpO1xuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmU7XG4gIH1cbiAgX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpIHtcbiAgICBjb25zdCB7Y2FyZXRYLCBjYXJldFksIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCBlKTtcbiAgICByZXR1cm4gcG9zaXRpb24gIT09IGZhbHNlICYmIChjYXJldFggIT09IHBvc2l0aW9uLnggfHwgY2FyZXRZICE9PSBwb3NpdGlvbi55KTtcbiAgfVxufVxuVG9vbHRpcC5wb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzO1xudmFyIHBsdWdpbl90b29sdGlwID0ge1xuICBpZDogJ3Rvb2x0aXAnLFxuICBfZWxlbWVudDogVG9vbHRpcCxcbiAgcG9zaXRpb25lcnMsXG4gIGFmdGVySW5pdChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgY2hhcnQudG9vbHRpcCA9IG5ldyBUb29sdGlwKHtjaGFydCwgb3B0aW9uc30pO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuICByZXNldChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgYWZ0ZXJEcmF3KGNoYXJ0KSB7XG4gICAgY29uc3QgdG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXA7XG4gICAgaWYgKHRvb2x0aXAgJiYgdG9vbHRpcC5fd2lsbFJlbmRlcigpKSB7XG4gICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICB0b29sdGlwXG4gICAgICB9O1xuICAgICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRvb2x0aXAuZHJhdyhjaGFydC5jdHgpO1xuICAgICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICAgIH1cbiAgfSxcbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gYXJncy5yZXBsYXk7XG4gICAgICBpZiAoY2hhcnQudG9vbHRpcC5oYW5kbGVFdmVudChhcmdzLmV2ZW50LCB1c2VGaW5hbFBvc2l0aW9uLCBhcmdzLmluQ2hhcnRBcmVhKSkge1xuICAgICAgICBhcmdzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGV4dGVybmFsOiBudWxsLFxuICAgIHBvc2l0aW9uOiAnYXZlcmFnZScsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICB0aXRsZUNvbG9yOiAnI2ZmZicsXG4gICAgdGl0bGVGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIHRpdGxlU3BhY2luZzogMixcbiAgICB0aXRsZU1hcmdpbkJvdHRvbTogNixcbiAgICB0aXRsZUFsaWduOiAnbGVmdCcsXG4gICAgYm9keUNvbG9yOiAnI2ZmZicsXG4gICAgYm9keVNwYWNpbmc6IDIsXG4gICAgYm9keUZvbnQ6IHtcbiAgICB9LFxuICAgIGJvZHlBbGlnbjogJ2xlZnQnLFxuICAgIGZvb3RlckNvbG9yOiAnI2ZmZicsXG4gICAgZm9vdGVyU3BhY2luZzogMixcbiAgICBmb290ZXJNYXJnaW5Ub3A6IDYsXG4gICAgZm9vdGVyRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmb290ZXJBbGlnbjogJ2xlZnQnLFxuICAgIHBhZGRpbmc6IDYsXG4gICAgY2FyZXRQYWRkaW5nOiAyLFxuICAgIGNhcmV0U2l6ZTogNSxcbiAgICBjb3JuZXJSYWRpdXM6IDYsXG4gICAgYm94SGVpZ2h0OiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgYm94V2lkdGg6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBtdWx0aUtleUJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBkaXNwbGF5Q29sb3JzOiB0cnVlLFxuICAgIGJveFBhZGRpbmc6IDAsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2NhcmV0WCcsICdjYXJldFknXSxcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGR1cmF0aW9uOiAyMDBcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgYmVmb3JlVGl0bGU6IG5vb3AsXG4gICAgICB0aXRsZSh0b29sdGlwSXRlbXMpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgICAgICBjb25zdCBsYWJlbHMgPSBpdGVtLmNoYXJ0LmRhdGEubGFiZWxzO1xuICAgICAgICAgIGNvbnN0IGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcbiAgICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5kYXRhSW5kZXggPCBsYWJlbENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSxcbiAgICAgIGFmdGVyVGl0bGU6IG5vb3AsXG4gICAgICBiZWZvcmVCb2R5OiBub29wLFxuICAgICAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gICAgICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgIHJldHVybiB0b29sdGlwSXRlbS5sYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZSB8fCB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFiZWwgPSB0b29sdGlwSXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICBsYWJlbCArPSAnOiAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgICBsYWJlbCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9LFxuICAgICAgbGFiZWxDb2xvcih0b29sdGlwSXRlbSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbGFiZWxUZXh0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICAgICAgfSxcbiAgICAgIGxhYmVsUG9pbnRTdHlsZSh0b29sdGlwSXRlbSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhZnRlckxhYmVsOiBub29wLFxuICAgICAgYWZ0ZXJCb2R5OiBub29wLFxuICAgICAgYmVmb3JlRm9vdGVyOiBub29wLFxuICAgICAgZm9vdGVyOiBub29wLFxuICAgICAgYWZ0ZXJGb290ZXI6IG5vb3BcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBib2R5Rm9udDogJ2ZvbnQnLFxuICAgIGZvb3RlckZvbnQ6ICdmb250JyxcbiAgICB0aXRsZUZvbnQ6ICdmb250J1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSAhPT0gJ2l0ZW1Tb3J0JyAmJiBuYW1lICE9PSAnZXh0ZXJuYWwnLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICB9XG4gIH0sXG4gIGFkZGl0aW9uYWxPcHRpb25TY29wZXM6IFsnaW50ZXJhY3Rpb24nXVxufTtcblxudmFyIHBsdWdpbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5EZWNpbWF0aW9uOiBwbHVnaW5fZGVjaW1hdGlvbixcbkZpbGxlcjogaW5kZXgsXG5MZWdlbmQ6IHBsdWdpbl9sZWdlbmQsXG5TdWJUaXRsZTogcGx1Z2luX3N1YnRpdGxlLFxuVGl0bGU6IHBsdWdpbl90aXRsZSxcblRvb2x0aXA6IHBsdWdpbl90b29sdGlwXG59KTtcblxuY29uc3QgYWRkSWZTdHJpbmcgPSAobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykgPT4ge1xuICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICBpbmRleCA9IGxhYmVscy5wdXNoKHJhdykgLSAxO1xuICAgIGFkZGVkTGFiZWxzLnVuc2hpZnQoe2luZGV4LCBsYWJlbDogcmF3fSk7XG4gIH0gZWxzZSBpZiAoaXNOYU4ocmF3KSkge1xuICAgIGluZGV4ID0gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xuZnVuY3Rpb24gZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykge1xuICBjb25zdCBmaXJzdCA9IGxhYmVscy5pbmRleE9mKHJhdyk7XG4gIGlmIChmaXJzdCA9PT0gLTEpIHtcbiAgICByZXR1cm4gYWRkSWZTdHJpbmcobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscyk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGxhYmVscy5sYXN0SW5kZXhPZihyYXcpO1xuICByZXR1cm4gZmlyc3QgIT09IGxhc3QgPyBpbmRleCA6IGZpcnN0O1xufVxuY29uc3QgdmFsaWRJbmRleCA9IChpbmRleCwgbWF4KSA9PiBpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfbGltaXRWYWx1ZShNYXRoLnJvdW5kKGluZGV4KSwgMCwgbWF4KTtcbmNsYXNzIENhdGVnb3J5U2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICB9XG4gIGluaXQoc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYWRkZWQgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgZm9yIChjb25zdCB7aW5kZXgsIGxhYmVsfSBvZiBhZGRlZCkge1xuICAgICAgICBpZiAobGFiZWxzW2luZGV4XSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICBsYWJlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdGlvbnMpO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpbmRleCA9IGlzRmluaXRlKGluZGV4KSAmJiBsYWJlbHNbaW5kZXhdID09PSByYXcgPyBpbmRleFxuICAgICAgOiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgdmFsdWVPckRlZmF1bHQoaW5kZXgsIHJhdyksIHRoaXMuX2FkZGVkTGFiZWxzKTtcbiAgICByZXR1cm4gdmFsaWRJbmRleChpbmRleCwgbGFiZWxzLmxlbmd0aCAtIDEpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQ7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBsZXQgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBsYWJlbHMgPSAobWluID09PSAwICYmIG1heCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1pbiwgbWF4ICsgMSk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IE1hdGgubWF4KGxhYmVscy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5taW4gLSAob2Zmc2V0ID8gMC41IDogMCk7XG4gICAgZm9yIChsZXQgdmFsdWUgPSBtaW47IHZhbHVlIDw9IG1heDsgdmFsdWUrKykge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWV9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGxhYmVsc1t2YWx1ZV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgaWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gIXRoaXMuX3JldmVyc2VQaXhlbHM7XG4gICAgfVxuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG59XG5DYXRlZ29yeVNjYWxlLmlkID0gJ2NhdGVnb3J5JztcbkNhdGVnb3J5U2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IENhdGVnb3J5U2NhbGUucHJvdG90eXBlLmdldExhYmVsRm9yVmFsdWVcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgTUlOX1NQQUNJTkcgPSAxZS0xNDtcbiAgY29uc3Qge2JvdW5kcywgc3RlcCwgbWluLCBtYXgsIHByZWNpc2lvbiwgY291bnQsIG1heFRpY2tzLCBtYXhEaWdpdHMsIGluY2x1ZGVCb3VuZHN9ID0gZ2VuZXJhdGlvbk9wdGlvbnM7XG4gIGNvbnN0IHVuaXQgPSBzdGVwIHx8IDE7XG4gIGNvbnN0IG1heFNwYWNlcyA9IG1heFRpY2tzIC0gMTtcbiAgY29uc3Qge21pbjogcm1pbiwgbWF4OiBybWF4fSA9IGRhdGFSYW5nZTtcbiAgY29uc3QgbWluRGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1pbik7XG4gIGNvbnN0IG1heERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtYXgpO1xuICBjb25zdCBjb3VudERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihjb3VudCk7XG4gIGNvbnN0IG1pblNwYWNpbmcgPSAocm1heCAtIHJtaW4pIC8gKG1heERpZ2l0cyArIDEpO1xuICBsZXQgc3BhY2luZyA9IG5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgbGV0IGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7dmFsdWU6IHJtaW59LCB7dmFsdWU6IHJtYXh9XTtcbiAgfVxuICBudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG4gIGlmIChudW1TcGFjZXMgPiBtYXhTcGFjZXMpIHtcbiAgICBzcGFjaW5nID0gbmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICB9XG4gIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgfVxuICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gIH0gZWxzZSB7XG4gICAgbmljZU1pbiA9IHJtaW47XG4gICAgbmljZU1heCA9IHJtYXg7XG4gIH1cbiAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCAmJiBzdGVwICYmIGFsbW9zdFdob2xlKChtYXggLSBtaW4pIC8gc3RlcCwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgIG5pY2VNaW4gPSBtaW47XG4gICAgbmljZU1heCA9IG1heDtcbiAgfSBlbHNlIGlmIChjb3VudERlZmluZWQpIHtcbiAgICBuaWNlTWluID0gbWluRGVmaW5lZCA/IG1pbiA6IG5pY2VNaW47XG4gICAgbmljZU1heCA9IG1heERlZmluZWQgPyBtYXggOiBuaWNlTWF4O1xuICAgIG51bVNwYWNlcyA9IGNvdW50IC0gMTtcbiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIG51bVNwYWNlcztcbiAgfSBlbHNlIHtcbiAgICBudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcbiAgICBpZiAoYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChcbiAgICBfZGVjaW1hbFBsYWNlcyhzcGFjaW5nKSxcbiAgICBfZGVjaW1hbFBsYWNlcyhuaWNlTWluKVxuICApO1xuICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pID8gZGVjaW1hbFBsYWNlcyA6IHByZWNpc2lvbik7XG4gIG5pY2VNaW4gPSBNYXRoLnJvdW5kKG5pY2VNaW4gKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbGV0IGogPSAwO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIGlmIChpbmNsdWRlQm91bmRzICYmIG5pY2VNaW4gIT09IG1pbikge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1pbn0pO1xuICAgICAgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgICAgaWYgKGFsbW9zdEVxdWFscyhNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvciwgbWluLCByZWxhdGl2ZUxhYmVsU2l6ZShtaW4sIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yfSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICBpZiAodGlja3MubGVuZ3RoICYmIGFsbW9zdEVxdWFscyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSwgbWF4LCByZWxhdGl2ZUxhYmVsU2l6ZShtYXgsIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWF4fSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBuaWNlTWF4fSk7XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gcmVsYXRpdmVMYWJlbFNpemUodmFsdWUsIG1pblNwYWNpbmcsIHtob3Jpem9udGFsLCBtaW5Sb3RhdGlvbn0pIHtcbiAgY29uc3QgcmFkID0gdG9SYWRpYW5zKG1pblJvdGF0aW9uKTtcbiAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKHJhZCkgOiBNYXRoLmNvcyhyYWQpKSB8fCAwLjAwMTtcbiAgY29uc3QgbGVuZ3RoID0gMC43NSAqIG1pblNwYWNpbmcgKiAoJycgKyB2YWx1ZSkubGVuZ3RoO1xuICByZXR1cm4gTWF0aC5taW4obWluU3BhY2luZyAvIHJhdGlvLCBsZW5ndGgpO1xufVxuY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHJhdyA9PT0gJ251bWJlcicgfHwgcmF3IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUoK3JhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gK3JhdztcbiAgfVxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG4gICAgaWYgKGJlZ2luQXRaZXJvKSB7XG4gICAgICBjb25zdCBtaW5TaWduID0gc2lnbihtaW4pO1xuICAgICAgY29uc3QgbWF4U2lnbiA9IHNpZ24obWF4KTtcbiAgICAgIGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuICAgICAgICBzZXRNYXgoMCk7XG4gICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgIHNldE1pbigwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gMTtcbiAgICAgIGlmIChtYXggPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgbWluIDw9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGguYWJzKG1heCAqIDAuMDUpO1xuICAgICAgfVxuICAgICAgc2V0TWF4KG1heCArIG9mZnNldCk7XG4gICAgICBpZiAoIWJlZ2luQXRaZXJvKSB7XG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBnZXRUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IHttYXhUaWNrc0xpbWl0LCBzdGVwU2l6ZX0gPSB0aWNrT3B0cztcbiAgICBsZXQgbWF4VGlja3M7XG4gICAgaWYgKHN0ZXBTaXplKSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGguY2VpbCh0aGlzLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IodGhpcy5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuICAgICAgaWYgKG1heFRpY2tzID4gMTAwMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYHNjYWxlcy4ke3RoaXMuaWR9LnRpY2tzLnN0ZXBTaXplOiAke3N0ZXBTaXplfSB3b3VsZCByZXN1bHQgZ2VuZXJhdGluZyB1cCB0byAke21heFRpY2tzfSB0aWNrcy4gTGltaXRpbmcgdG8gMTAwMC5gKTtcbiAgICAgICAgbWF4VGlja3MgPSAxMDAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhUaWNrcyA9IHRoaXMuY29tcHV0ZVRpY2tMaW1pdCgpO1xuICAgICAgbWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG4gICAgfVxuICAgIGlmIChtYXhUaWNrc0xpbWl0KSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGgubWluKG1heFRpY2tzTGltaXQsIG1heFRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heFRpY2tzO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICAgIGxldCBtYXhUaWNrcyA9IHRoaXMuZ2V0VGlja0xpbWl0KCk7XG4gICAgbWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG4gICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG4gICAgICBtYXhUaWNrcyxcbiAgICAgIGJvdW5kczogb3B0cy5ib3VuZHMsXG4gICAgICBtaW46IG9wdHMubWluLFxuICAgICAgbWF4OiBvcHRzLm1heCxcbiAgICAgIHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXG4gICAgICBjb3VudDogdGlja09wdHMuY291bnQsXG4gICAgICBtYXhEaWdpdHM6IHRoaXMuX21heERpZ2l0cygpLFxuICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFSYW5nZSA9IHRoaXMuX3JhbmdlIHx8IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzJDEobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIGRhdGFSYW5nZSk7XG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBsZXQgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICBsZXQgZW5kID0gdGhpcy5tYXg7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbn1cblxuY2xhc3MgTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IG1heCA6IDE7XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBsZW5ndGggPSBob3Jpem9udGFsID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy50aWNrcy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKG1pblJvdGF0aW9uKSA6IE1hdGguY29zKG1pblJvdGF0aW9uKSkgfHwgMC4wMDE7XG4gICAgY29uc3QgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApO1xuICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoIC8gTWF0aC5taW4oNDAsIHRpY2tGb250LmxpbmVIZWlnaHQgLyByYXRpbykpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XG4gIH1cbn1cbkxpbmVhclNjYWxlLmlkID0gJ2xpbmVhcic7XG5MaW5lYXJTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzTWFqb3IodGlja1ZhbCkge1xuICBjb25zdCByZW1haW4gPSB0aWNrVmFsIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKSkpO1xuICByZXR1cm4gcmVtYWluID09PSAxO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IGVuZEV4cCA9IE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1heCkpO1xuICBjb25zdCBlbmRTaWduaWZpY2FuZCA9IE1hdGguY2VpbChkYXRhUmFuZ2UubWF4IC8gTWF0aC5wb3coMTAsIGVuZEV4cCkpO1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBsZXQgdGlja1ZhbCA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xuICBsZXQgZXhwID0gTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSk7XG4gIGxldCBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodGlja1ZhbCAvIE1hdGgucG93KDEwLCBleHApKTtcbiAgbGV0IHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuICBkbyB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IHRpY2tWYWwsIG1ham9yOiBpc01ham9yKHRpY2tWYWwpfSk7XG4gICAgKytzaWduaWZpY2FuZDtcbiAgICBpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG4gICAgICBzaWduaWZpY2FuZCA9IDE7XG4gICAgICArK2V4cDtcbiAgICAgIHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcbiAgICB9XG4gICAgdGlja1ZhbCA9IE1hdGgucm91bmQoc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH0gd2hpbGUgKGV4cCA8IGVuZEV4cCB8fCAoZXhwID09PSBlbmRFeHAgJiYgc2lnbmlmaWNhbmQgPCBlbmRTaWduaWZpY2FuZCkpO1xuICBjb25zdCBsYXN0VGljayA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHRpY2tWYWwpO1xuICB0aWNrcy5wdXNoKHt2YWx1ZTogbGFzdFRpY2ssIG1ham9yOiBpc01ham9yKHRpY2tWYWwpfSk7XG4gIHJldHVybiB0aWNrcztcbn1cbmNsYXNzIExvZ2FyaXRobWljU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgW3JhdywgaW5kZXhdKTtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gTWF0aC5tYXgoMCwgbWluKSA6IG51bGw7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpID8gTWF0aC5tYXgoMCwgbWF4KSA6IG51bGw7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5iZWdpbkF0WmVybykge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IG1pbiA9IHRoaXMubWluO1xuICAgIGxldCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuICAgIGNvbnN0IGV4cCA9ICh2LCBtKSA9PiBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh2KSkgKyBtKTtcbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgICBzZXRNaW4oMSk7XG4gICAgICAgIHNldE1heCgxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRNaW4oZXhwKG1pbiwgLTEpKTtcbiAgICAgICAgc2V0TWF4KGV4cChtYXgsICsxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgc2V0TWluKGV4cChtYXgsIC0xKSk7XG4gICAgfVxuICAgIGlmIChtYXggPD0gMCkge1xuICAgICAgc2V0TWF4KGV4cChtaW4sICsxKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl96ZXJvICYmIHRoaXMubWluICE9PSB0aGlzLl9zdWdnZXN0ZWRNaW4gJiYgbWluID09PSBleHAodGhpcy5taW4sIDApKSB7XG4gICAgICBzZXRNaW4oZXhwKG1pbiwgLTEpKTtcbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGdlbmVyYXRpb25PcHRpb25zID0ge1xuICAgICAgbWluOiB0aGlzLl91c2VyTWluLFxuICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XG4gICAgfTtcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHRoaXMpO1xuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnMCdcbiAgICAgIDogZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBsb2cxMCh0aGlzLm1heCkgLSBsb2cxMChzdGFydCk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwodmFsdWUgPT09IHRoaXMubWluXG4gICAgICA/IDBcbiAgICAgIDogKGxvZzEwKHZhbHVlKSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGFydFZhbHVlICsgZGVjaW1hbCAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG59XG5Mb2dhcml0aG1pY1NjYWxlLmlkID0gJ2xvZ2FyaXRobWljJztcbkxvZ2FyaXRobWljU2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWMsXG4gICAgbWFqb3I6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250ICYmIHRpY2tPcHRzLmZvbnQuc2l6ZSwgZGVmYXVsdHMuZm9udC5zaXplKSArIHBhZGRpbmcuaGVpZ2h0O1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGZvbnQsIGxhYmVsKSB7XG4gIGxhYmVsID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbCA6IFtsYWJlbF07XG4gIHJldHVybiB7XG4gICAgdzogX2xvbmdlc3RUZXh0KGN0eCwgZm9udC5zdHJpbmcsIGxhYmVsKSxcbiAgICBoOiBsYWJlbC5sZW5ndGggKiBmb250LmxpbmVIZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gc2l6ZSxcbiAgICAgIGVuZDogcG9zXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBwb3MsXG4gICAgZW5kOiBwb3MgKyBzaXplXG4gIH07XG59XG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcbiAgY29uc3Qgb3JpZyA9IHtcbiAgICBsOiBzY2FsZS5sZWZ0ICsgc2NhbGUuX3BhZGRpbmcubGVmdCxcbiAgICByOiBzY2FsZS5yaWdodCAtIHNjYWxlLl9wYWRkaW5nLnJpZ2h0LFxuICAgIHQ6IHNjYWxlLnRvcCArIHNjYWxlLl9wYWRkaW5nLnRvcCxcbiAgICBiOiBzY2FsZS5ib3R0b20gLSBzY2FsZS5fcGFkZGluZy5ib3R0b21cbiAgfTtcbiAgY29uc3QgbGltaXRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZyk7XG4gIGNvbnN0IGxhYmVsU2l6ZXMgPSBbXTtcbiAgY29uc3QgcGFkZGluZyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgcG9pbnRMYWJlbE9wdHMgPSBzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBwb2ludExhYmVsT3B0cy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIHBhZGRpbmdbaV0gPSBvcHRzLnBhZGRpbmc7XG4gICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICBsYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG4gICAgY29uc3QgYW5nbGVSYWRpYW5zID0gX25vcm1hbGl6ZUFuZ2xlKHNjYWxlLmdldEluZGV4QW5nbGUoaSkgKyBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSk7XG4gICAgY29uc3QgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuICAgIGNvbnN0IHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG4gICAgdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGVSYWRpYW5zLCBoTGltaXRzLCB2TGltaXRzKTtcbiAgfVxuICBzY2FsZS5zZXRDZW50ZXJQb2ludChcbiAgICBvcmlnLmwgLSBsaW1pdHMubCxcbiAgICBsaW1pdHMuciAtIG9yaWcucixcbiAgICBvcmlnLnQgLSBsaW1pdHMudCxcbiAgICBsaW1pdHMuYiAtIG9yaWcuYlxuICApO1xuICBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zID0gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGUsIGhMaW1pdHMsIHZMaW1pdHMpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKTtcbiAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmIChoTGltaXRzLnN0YXJ0IDwgb3JpZy5sKSB7XG4gICAgeCA9IChvcmlnLmwgLSBoTGltaXRzLnN0YXJ0KSAvIHNpbjtcbiAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcbiAgfSBlbHNlIGlmIChoTGltaXRzLmVuZCA+IG9yaWcucikge1xuICAgIHggPSAoaExpbWl0cy5lbmQgLSBvcmlnLnIpIC8gc2luO1xuICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xuICB9XG4gIGlmICh2TGltaXRzLnN0YXJ0IDwgb3JpZy50KSB7XG4gICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcbiAgICBsaW1pdHMudCA9IE1hdGgubWluKGxpbWl0cy50LCBvcmlnLnQgLSB5KTtcbiAgfSBlbHNlIGlmICh2TGltaXRzLmVuZCA+IG9yaWcuYikge1xuICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xuICAgIGxpbWl0cy5iID0gTWF0aC5tYXgobGltaXRzLmIsIG9yaWcuYiArIHkpO1xuICB9XG59XG5mdW5jdGlvbiBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZykge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGV4dHJhID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIC8gMjtcbiAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBvcHRzLnBvaW50TGFiZWxzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhfbm9ybWFsaXplQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLmFuZ2xlICsgSEFMRl9QSSkpKTtcbiAgICBjb25zdCBzaXplID0gbGFiZWxTaXplc1tpXTtcbiAgICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcbiAgICBjb25zdCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG4gICAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgICBpdGVtcy5wdXNoKHtcbiAgICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgICAgeSxcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIGxlZnQsXG4gICAgICB0b3A6IHksXG4gICAgICByaWdodDogbGVmdCArIHNpemUudyxcbiAgICAgIGJvdHRvbTogeSArIHNpemUuaFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG4gICAgcmV0dXJuICdjZW50ZXInO1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfVxuICByZXR1cm4gJ3JpZ2h0Jztcbn1cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHlGb3JBbmdsZSh5LCBoLCBhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcbiAgICB5IC09IChoIC8gMik7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuICAgIHkgLT0gaDtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuICBmb3IgKGxldCBpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgb3B0c0F0SW5kZXggPSBwb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgY29uc3Qge3gsIHksIHRleHRBbGlnbiwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHNjYWxlLl9wb2ludExhYmVsSXRlbXNbaV07XG4gICAgY29uc3Qge2JhY2tkcm9wQ29sb3J9ID0gb3B0c0F0SW5kZXg7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGJhY2tkcm9wQ29sb3IpKSB7XG4gICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKG9wdHNBdEluZGV4LmJvcmRlclJhZGl1cyk7XG4gICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BDb2xvcjtcbiAgICAgIGNvbnN0IGJhY2tkcm9wTGVmdCA9IGxlZnQgLSBwYWRkaW5nLmxlZnQ7XG4gICAgICBjb25zdCBiYWNrZHJvcFRvcCA9IHRvcCAtIHBhZGRpbmcudG9wO1xuICAgICAgY29uc3QgYmFja2Ryb3BXaWR0aCA9IHJpZ2h0IC0gbGVmdCArIHBhZGRpbmcud2lkdGg7XG4gICAgICBjb25zdCBiYWNrZHJvcEhlaWdodCA9IGJvdHRvbSAtIHRvcCArIHBhZGRpbmcuaGVpZ2h0O1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogYmFja2Ryb3BMZWZ0LFxuICAgICAgICAgIHk6IGJhY2tkcm9wVG9wLFxuICAgICAgICAgIHc6IGJhY2tkcm9wV2lkdGgsXG4gICAgICAgICAgaDogYmFja2Ryb3BIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGJhY2tkcm9wTGVmdCwgYmFja2Ryb3BUb3AsIGJhY2tkcm9wV2lkdGgsIGJhY2tkcm9wSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyVGV4dChcbiAgICAgIGN0eCxcbiAgICAgIHNjYWxlLl9wb2ludExhYmVsc1tpXSxcbiAgICAgIHgsXG4gICAgICB5ICsgKHBsRm9udC5saW5lSGVpZ2h0IC8gMiksXG4gICAgICBwbEZvbnQsXG4gICAgICB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4fSA9IHNjYWxlO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICBjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgVEFVKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcbiAgICBjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IGN0eCA9IHNjYWxlLmN0eDtcbiAgY29uc3QgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XG4gIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IGdyaWRMaW5lT3B0cztcbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIGN0eC5zZXRMaW5lRGFzaChncmlkTGluZU9wdHMuYm9yZGVyRGFzaCk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0O1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVQb2ludExhYmVsQ29udGV4dChwYXJlbnQsIGluZGV4LCBsYWJlbCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBsYWJlbCxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAncG9pbnRMYWJlbCdcbiAgfSk7XG59XG5jbGFzcyBSYWRpYWxMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gW107XG4gICAgdGhpcy5fcG9pbnRMYWJlbEl0ZW1zID0gW107XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDIpO1xuICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCAtIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcbiAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMubGVmdCArIHcgLyAyICsgcGFkZGluZy5sZWZ0KTtcbiAgICB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgaCAvIDIgKyBwYWRkaW5nLnRvcCk7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heChmYWxzZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiAwO1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrTGFiZWxzLmNhbGwodGhpcywgdGlja3MpO1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKVxuICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2FsbGJhY2sodGhpcy5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBbdmFsdWUsIGluZGV4XSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBsYWJlbCB8fCBsYWJlbCA9PT0gMCA/IGxhYmVsIDogJyc7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigodiwgaSkgPT4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSk7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGZpdFdpdGhQb2ludExhYmVscyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cbiAgc2V0Q2VudGVyUG9pbnQobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcbiAgICB0aGlzLnhDZW50ZXIgKz0gTWF0aC5mbG9vcigobGVmdE1vdmVtZW50IC0gcmlnaHRNb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLnlDZW50ZXIgKz0gTWF0aC5mbG9vcigodG9wTW92ZW1lbnQgLSBib3R0b21Nb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhIC09IE1hdGgubWluKHRoaXMuZHJhd2luZ0FyZWEgLyAyLCBNYXRoLm1heChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkpO1xuICB9XG4gIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcbiAgICBjb25zdCBhbmdsZU11bHRpcGxpZXIgPSBUQVUgLyAodGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoIHx8IDEpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLm9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwO1xuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICB9XG4gIGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBzY2FsaW5nRmFjdG9yID0gdGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHJldHVybiAodGhpcy5tYXggLSB2YWx1ZSkgKiBzY2FsaW5nRmFjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5taW4pICogc2NhbGluZ0ZhY3RvcjtcbiAgfVxuICBnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlcihkaXN0YW5jZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKGRpc3RhbmNlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVkRGlzdGFuY2UgPSBkaXN0YW5jZSAvICh0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UgPyB0aGlzLm1heCAtIHNjYWxlZERpc3RhbmNlIDogdGhpcy5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgfVxuICBnZXRQb2ludExhYmVsQ29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHBvaW50TGFiZWxzID0gdGhpcy5fcG9pbnRMYWJlbHMgfHwgW107XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwb2ludExhYmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBvaW50TGFiZWwgPSBwb2ludExhYmVsc1tpbmRleF07XG4gICAgICByZXR1cm4gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBwb2ludExhYmVsKTtcbiAgICB9XG4gIH1cbiAgZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyLCBhZGRpdGlvbmFsQW5nbGUgPSAwKSB7XG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG4gIGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSk7XG4gIH1cbiAgZ2V0QmFzZVBvc2l0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsIHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gdGhpcy5fcG9pbnRMYWJlbEl0ZW1zW2luZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgIH07XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2JhY2tncm91bmRDb2xvciwgZ3JpZDoge2NpcmN1bGFyfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aFJhZGl1c0xpbmUodGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCB0aGlzLl9wb2ludExhYmVscy5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkfSA9IG9wdHM7XG4gICAgY29uc3QgbGFiZWxDb3VudCA9IHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgICBsZXQgaSwgb2Zmc2V0LCBwb3NpdGlvbjtcbiAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XG4gICAgfVxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aWNrLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXggLSAxKSk7XG4gICAgICAgICAgZHJhd1JhZGl1c0xpbmUodGhpcywgb3B0c0F0SW5kZXgsIG9mZnNldCwgbGFiZWxDb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYW5nbGVMaW5lcy5kaXNwbGF5KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgZm9yIChpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gYW5nbGVMaW5lcy5zZXRDb250ZXh0KHRoaXMuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBvcHRzQXRJbmRleDtcbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHt9XG4gIGRyYXdMYWJlbHMoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgaWYgKCF0aWNrT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICBjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ID09PSAwICYmICFvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSB0aWNrT3B0cy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAtd2lkdGggLyAyIC0gcGFkZGluZy5sZWZ0LFxuICAgICAgICAgIC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHBhZGRpbmcudG9wLFxuICAgICAgICAgIHdpZHRoICsgcGFkZGluZy53aWR0aCxcbiAgICAgICAgICB0aWNrRm9udC5zaXplICsgcGFkZGluZy5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlclRleHQoY3R4LCB0aWNrLmxhYmVsLCAwLCAtb2Zmc2V0LCB0aWNrRm9udCwge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdUaXRsZSgpIHt9XG59XG5SYWRpYWxMaW5lYXJTY2FsZS5pZCA9ICdyYWRpYWxMaW5lYXInO1xuUmFkaWFsTGluZWFyU2NhbGUuZGVmYXVsdHMgPSB7XG4gIGRpc3BsYXk6IHRydWUsXG4gIGFuaW1hdGU6IHRydWUsXG4gIHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcbiAgYW5nbGVMaW5lczoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuICB9LFxuICBncmlkOiB7XG4gICAgY2lyY3VsYXI6IGZhbHNlXG4gIH0sXG4gIHN0YXJ0QW5nbGU6IDAsXG4gIHRpY2tzOiB7XG4gICAgc2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9LFxuICBwb2ludExhYmVsczoge1xuICAgIGJhY2tkcm9wQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBmb250OiB7XG4gICAgICBzaXplOiAxMFxuICAgIH0sXG4gICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9LFxuICAgIHBhZGRpbmc6IDUsXG4gICAgY2VudGVyUG9pbnRMYWJlbHM6IGZhbHNlXG4gIH1cbn07XG5SYWRpYWxMaW5lYXJTY2FsZS5kZWZhdWx0Um91dGVzID0ge1xuICAnYW5nbGVMaW5lcy5jb2xvcic6ICdib3JkZXJDb2xvcicsXG4gICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICd0aWNrcy5jb2xvcic6ICdjb2xvcidcbn07XG5SYWRpYWxMaW5lYXJTY2FsZS5kZXNjcmlwdG9ycyA9IHtcbiAgYW5nbGVMaW5lczoge1xuICAgIF9mYWxsYmFjazogJ2dyaWQnXG4gIH1cbn07XG5cbmNvbnN0IElOVEVSVkFMUyA9IHtcbiAgbWlsbGlzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEsIHN0ZXBzOiAxMDAwfSxcbiAgc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxMDAwLCBzdGVwczogNjB9LFxuICBtaW51dGU6IHtjb21tb246IHRydWUsIHNpemU6IDYwMDAwLCBzdGVwczogNjB9LFxuICBob3VyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzNjAwMDAwLCBzdGVwczogMjR9LFxuICBkYXk6IHtjb21tb246IHRydWUsIHNpemU6IDg2NDAwMDAwLCBzdGVwczogMzB9LFxuICB3ZWVrOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNjA0ODAwMDAwLCBzdGVwczogNH0sXG4gIG1vbnRoOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAyLjYyOGU5LCBzdGVwczogMTJ9LFxuICBxdWFydGVyOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNy44ODRlOSwgc3RlcHM6IDR9LFxuICB5ZWFyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzLjE1NGUxMH1cbn07XG5jb25zdCBVTklUUyA9IChPYmplY3Qua2V5cyhJTlRFUlZBTFMpKTtcbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xuICBpZiAoaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IHtwYXJzZXIsIHJvdW5kLCBpc29XZWVrZGF5fSA9IHNjYWxlLl9wYXJzZU9wdHM7XG4gIGxldCB2YWx1ZSA9IGlucHV0O1xuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuICBpZiAoIWlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdHlwZW9mIHBhcnNlciA9PT0gJ3N0cmluZydcbiAgICAgID8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgcGFyc2VyKVxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocm91bmQpIHtcbiAgICB2YWx1ZSA9IHJvdW5kID09PSAnd2VlaycgJiYgKGlzTnVtYmVyKGlzb1dlZWtkYXkpIHx8IGlzb1dlZWtkYXkgPT09IHRydWUpXG4gICAgICA/IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgJ2lzb1dlZWsnLCBpc29XZWVrZGF5KVxuICAgICAgOiBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsIHJvdW5kKTtcbiAgfVxuICByZXR1cm4gK3ZhbHVlO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcbiAgY29uc3QgaWxlbiA9IFVOSVRTLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuICAgIGNvbnN0IGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG4gICAgY29uc3QgdW5pdCA9IFVOSVRTW2ldO1xuICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBVTklUU1ttaW5Vbml0ID8gVU5JVFMuaW5kZXhPZihtaW5Vbml0KSA6IDBdO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIHRpY2tzW3RpbWVdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHtsbywgaGl9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2xvXSA+PSB0aW1lID8gdGltZXN0YW1wc1tsb10gOiB0aW1lc3RhbXBzW2hpXTtcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBtYWpvciwgaW5kZXg7XG4gIGZvciAobWFqb3IgPSBmaXJzdDsgbWFqb3IgPD0gbGFzdDsgbWFqb3IgPSArYWRhcHRlci5hZGQobWFqb3IsIDEsIG1ham9yVW5pdCkpIHtcbiAgICBpbmRleCA9IG1hcFttYWpvcl07XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBjb25zdCBpbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgbGV0IGksIHZhbHVlO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgbWFwW3ZhbHVlXSA9IGk7XG4gICAgdGlja3MucHVzaCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIG1ham9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAoaWxlbiA9PT0gMCB8fCAhbWFqb3JVbml0KSA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cbmNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgICB0aGlzLl91bml0ID0gJ2RheSc7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29mZnNldHMgPSB7fTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXQoc2NhbGVPcHRzLCBvcHRzKSB7XG4gICAgY29uc3QgdGltZSA9IHNjYWxlT3B0cy50aW1lIHx8IChzY2FsZU9wdHMudGltZSA9IHt9KTtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBfYWRhcHRlcnMuX2RhdGUoc2NhbGVPcHRzLmFkYXB0ZXJzLmRhdGUpO1xuICAgIGFkYXB0ZXIuaW5pdChvcHRzKTtcbiAgICBtZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB7XG4gICAgICBwYXJzZXI6IHRpbWUucGFyc2VyLFxuICAgICAgcm91bmQ6IHRpbWUucm91bmQsXG4gICAgICBpc29XZWVrZGF5OiB0aW1lLmlzb1dlZWtkYXlcbiAgICB9O1xuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRzKTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gb3B0cy5ub3JtYWxpemVkO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAocmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgfVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgc3VwZXIuYmVmb3JlTGF5b3V0KCk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdW5pdCA9IG9wdGlvbnMudGltZS51bml0IHx8ICdkYXknO1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgZnVuY3Rpb24gX2FwcGx5Qm91bmRzKGJvdW5kcykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkICYmICFpc05hTihib3VuZHMubWluKSkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGJvdW5kcy5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkICYmICFpc05hTihib3VuZHMubWF4KSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGJvdW5kcy5tYXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1pbkRlZmluZWQgfHwgIW1heERlZmluZWQpIHtcbiAgICAgIF9hcHBseUJvdW5kcyh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvdW5kcyAhPT0gJ3RpY2tzJyB8fCBvcHRpb25zLnRpY2tzLnNvdXJjZSAhPT0gJ2xhYmVscycpIHtcbiAgICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuZ2V0TWluTWF4KGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpO1xuICAgIG1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDE7XG4gICAgdGhpcy5taW4gPSBNYXRoLm1pbihtaW4sIG1heCAtIDEpO1xuICAgIHRoaXMubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcbiAgfVxuICBfZ2V0TGFiZWxCb3VuZHMoKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBsZXQgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgIG1pbiA9IGFyclswXTtcbiAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiB7bWluLCBtYXh9O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2xhYmVscycgPyB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpIDogdGhpcy5fZ2VuZXJhdGUoKTtcbiAgICBpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubWluID0gdGhpcy5fdXNlck1pbiB8fCB0aW1lc3RhbXBzWzBdO1xuICAgICAgdGhpcy5tYXggPSB0aGlzLl91c2VyTWF4IHx8IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XG4gICAgdGhpcy5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgKHRpY2tPcHRzLmF1dG9Ta2lwXG4gICAgICA/IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpXG4gICAgICA6IGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHRoaXMsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSk7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gIXRpY2tPcHRzLm1ham9yLmVuYWJsZWQgfHwgdGhpcy5fdW5pdCA9PT0gJ3llYXInID8gdW5kZWZpbmVkXG4gICAgICA6IGRldGVybWluZU1ham9yVW5pdCh0aGlzLl91bml0KTtcbiAgICB0aGlzLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgdGlja3MsIHRoaXMuX21ham9yVW5pdCk7XG4gIH1cbiAgYWZ0ZXJBdXRvU2tpcCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldEFmdGVyQXV0b3NraXApIHtcbiAgICAgIHRoaXMuaW5pdE9mZnNldHModGhpcy50aWNrcy5tYXAodGljayA9PiArdGljay52YWx1ZSkpO1xuICAgIH1cbiAgfVxuICBpbml0T2Zmc2V0cyh0aW1lc3RhbXBzKSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBsZXQgZmlyc3QsIGxhc3Q7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIGZpcnN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1swXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSAxIC0gZmlyc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICB9XG4gICAgICBsYXN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbmQgPSBsYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gKGxhc3QgLSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBsaW1pdCk7XG4gICAgZW5kID0gX2xpbWl0VmFsdWUoZW5kLCAwLCBsaW1pdCk7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHtzdGFydCwgZW5kLCBmYWN0b3I6IDEgLyAoc3RhcnQgKyAxICsgZW5kKX07XG4gIH1cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSk7XG4gICAgY29uc3Qgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdCh0aW1lT3B0cy5zdGVwU2l6ZSwgMSk7XG4gICAgY29uc3Qgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG4gICAgY29uc3QgaGFzV2Vla2RheSA9IGlzTnVtYmVyKHdlZWtkYXkpIHx8IHdlZWtkYXkgPT09IHRydWU7XG4gICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICBsZXQgZmlyc3QgPSBtaW47XG4gICAgbGV0IHRpbWUsIGNvdW50O1xuICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgfVxuICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgaGFzV2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuICAgIGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcik7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBvcHRpb25zLnRpY2tzLnNvdXJjZSA9PT0gJ2RhdGEnICYmIHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBmb3IgKHRpbWUgPSBmaXJzdCwgY291bnQgPSAwOyB0aW1lIDwgbWF4OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vciksIGNvdW50KyspIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cbiAgICBpZiAodGltZSA9PT0gbWF4IHx8IG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnIHx8IGNvdW50ID09PSAxKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRpY2tzKS5zb3J0KChhLCBiKSA9PiBhIC0gYikubWFwKHggPT4gK3gpO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG4gICAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcbiAgfVxuICBfdGlja0Zvcm1hdEZ1bmN0aW9uKHRpbWUsIGluZGV4LCB0aWNrcywgZm9ybWF0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcbiAgICBjb25zdCBtaW5vckZvcm1hdCA9IHVuaXQgJiYgZm9ybWF0c1t1bml0XTtcbiAgICBjb25zdCBtYWpvckZvcm1hdCA9IG1ham9yVW5pdCAmJiBmb3JtYXRzW21ham9yVW5pdF07XG4gICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICBjb25zdCBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLl9hZGFwdGVyLmZvcm1hdCh0aW1lLCBmb3JtYXQgfHwgKG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCkpO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG9wdGlvbnMudGlja3MuY2FsbGJhY2s7XG4gICAgcmV0dXJuIGZvcm1hdHRlciA/IGNhbGxiYWNrKGZvcm1hdHRlciwgW2xhYmVsLCBpbmRleCwgdGlja3NdLCB0aGlzKSA6IGxhYmVsO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24odGljay52YWx1ZSwgaSwgdGlja3MpO1xuICAgIH1cbiAgfVxuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiAodmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiB0aGlzLm1pbiArIHBvcyAqICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuICBfZ2V0TGFiZWxTaXplKGxhYmVsKSB7XG4gICAgY29uc3QgdGlja3NPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tMYWJlbFdpZHRoID0gdGhpcy5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIGNvbnN0IGFuZ2xlID0gdG9SYWRpYW5zKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aWNrc09wdHMubWF4Um90YXRpb24gOiB0aWNrc09wdHMubWluUm90YXRpb24pO1xuICAgIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHRpY2tGb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkuc2l6ZTtcbiAgICByZXR1cm4ge1xuICAgICAgdzogKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKSxcbiAgICAgIGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcbiAgICB9O1xuICB9XG4gIF9nZXRMYWJlbENhcGFjaXR5KGV4YW1wbGVUaW1lKSB7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICBjb25zdCBkaXNwbGF5Rm9ybWF0cyA9IHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IGZvcm1hdCA9IGRpc3BsYXlGb3JtYXRzW3RpbWVPcHRzLnVuaXRdIHx8IGRpc3BsYXlGb3JtYXRzLm1pbGxpc2Vjb25kO1xuICAgIGNvbnN0IGV4YW1wbGVMYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCBbZXhhbXBsZVRpbWVdLCB0aGlzLl9tYWpvclVuaXQpLCBmb3JtYXQpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRMYWJlbFNpemUoZXhhbXBsZUxhYmVsKTtcbiAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyBzaXplLncgOiB0aGlzLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgIHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG4gIH1cbiAgZ2V0RGF0YVRpbWVzdGFtcHMoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGlmICh0aGlzLl9ub3JtYWxpemVkICYmIG1ldGFzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gbWV0YXNbMF0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5jb25jYXQobWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cbiAgZ2V0TGFiZWxUaW1lc3RhbXBzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5sYWJlbHMgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcy5wdXNoKHBhcnNlKHRoaXMsIGxhYmVsc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmxhYmVscyA9IHRoaXMuX25vcm1hbGl6ZWQgPyB0aW1lc3RhbXBzIDogdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG4gIG5vcm1hbGl6ZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KHNvcnRlcikpO1xuICB9XG59XG5UaW1lU2NhbGUuaWQgPSAndGltZSc7XG5UaW1lU2NhbGUuZGVmYXVsdHMgPSB7XG4gIGJvdW5kczogJ2RhdGEnLFxuICBhZGFwdGVyczoge30sXG4gIHRpbWU6IHtcbiAgICBwYXJzZXI6IGZhbHNlLFxuICAgIHVuaXQ6IGZhbHNlLFxuICAgIHJvdW5kOiBmYWxzZSxcbiAgICBpc29XZWVrZGF5OiBmYWxzZSxcbiAgICBtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuICAgIGRpc3BsYXlGb3JtYXRzOiB7fVxuICB9LFxuICB0aWNrczoge1xuICAgIHNvdXJjZTogJ2F1dG8nLFxuICAgIG1ham9yOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUodGFibGUsIHZhbCwgcmV2ZXJzZSkge1xuICBsZXQgbG8gPSAwO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgcHJldlNvdXJjZSwgbmV4dFNvdXJjZSwgcHJldlRhcmdldCwgbmV4dFRhcmdldDtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS5wb3MgJiYgdmFsIDw9IHRhYmxlW2hpXS5wb3MpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3BvcycsIHZhbCkpO1xuICAgIH1cbiAgICAoe3BvczogcHJldlNvdXJjZSwgdGltZTogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7cG9zOiBuZXh0U291cmNlLCB0aW1lOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10udGltZSAmJiB2YWwgPD0gdGFibGVbaGldLnRpbWUpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3RpbWUnLCB2YWwpKTtcbiAgICB9XG4gICAgKHt0aW1lOiBwcmV2U291cmNlLCBwb3M6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3RpbWU6IG5leHRTb3VyY2UsIHBvczogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9XG4gIGNvbnN0IHNwYW4gPSBuZXh0U291cmNlIC0gcHJldlNvdXJjZTtcbiAgcmV0dXJuIHNwYW4gPyBwcmV2VGFyZ2V0ICsgKG5leHRUYXJnZXQgLSBwcmV2VGFyZ2V0KSAqICh2YWwgLSBwcmV2U291cmNlKSAvIHNwYW4gOiBwcmV2VGFyZ2V0O1xufVxuY2xhc3MgVGltZVNlcmllc1NjYWxlIGV4dGVuZHMgVGltZVNjYWxlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5fdGFibGUgPSBbXTtcbiAgICB0aGlzLl9taW5Qb3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0T2Zmc2V0cygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCk7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLl90YWJsZSA9IHRoaXMuYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKTtcbiAgICB0aGlzLl9taW5Qb3MgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5taW4pO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5tYXgpIC0gdGhpcy5fbWluUG9zO1xuICAgIHN1cGVyLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICB9XG4gIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgdGFibGUgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgcHJldiwgY3VyciwgbmV4dDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuICAgICAgaWYgKGN1cnIgPj0gbWluICYmIGN1cnIgPD0gbWF4KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goY3Vycik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdGVtcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7dGltZTogbWluLCBwb3M6IDB9LFxuICAgICAgICB7dGltZTogbWF4LCBwb3M6IDF9XG4gICAgICBdO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBuZXh0ID0gaXRlbXNbaSArIDFdO1xuICAgICAgcHJldiA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgIGN1cnIgPSBpdGVtc1tpXTtcbiAgICAgIGlmIChNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuICAgICAgICB0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuICBfZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsIHx8IFtdO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAmJiBsYWJlbC5sZW5ndGgpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aGlzLm5vcm1hbGl6ZShkYXRhLmNvbmNhdChsYWJlbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lc3RhbXBzID0gZGF0YS5sZW5ndGggPyBkYXRhIDogbGFiZWw7XG4gICAgfVxuICAgIHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgPSB0aW1lc3RhbXBzO1xuICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIHZhbHVlKSAtIHRoaXMuX21pblBvcykgLyB0aGlzLl90YWJsZVJhbmdlO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIGRlY2ltYWwgKiB0aGlzLl90YWJsZVJhbmdlICsgdGhpcy5fbWluUG9zLCB0cnVlKTtcbiAgfVxufVxuVGltZVNlcmllc1NjYWxlLmlkID0gJ3RpbWVzZXJpZXMnO1xuVGltZVNlcmllc1NjYWxlLmRlZmF1bHRzID0gVGltZVNjYWxlLmRlZmF1bHRzO1xuXG52YXIgc2NhbGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQ2F0ZWdvcnlTY2FsZTogQ2F0ZWdvcnlTY2FsZSxcbkxpbmVhclNjYWxlOiBMaW5lYXJTY2FsZSxcbkxvZ2FyaXRobWljU2NhbGU6IExvZ2FyaXRobWljU2NhbGUsXG5SYWRpYWxMaW5lYXJTY2FsZTogUmFkaWFsTGluZWFyU2NhbGUsXG5UaW1lU2NhbGU6IFRpbWVTY2FsZSxcblRpbWVTZXJpZXNTY2FsZTogVGltZVNlcmllc1NjYWxlXG59KTtcblxuQ2hhcnQucmVnaXN0ZXIoY29udHJvbGxlcnMsIHNjYWxlcywgZWxlbWVudHMsIHBsdWdpbnMpO1xuQ2hhcnQuaGVscGVycyA9IHsuLi5oZWxwZXJzfTtcbkNoYXJ0Ll9hZGFwdGVycyA9IF9hZGFwdGVycztcbkNoYXJ0LkFuaW1hdGlvbiA9IEFuaW1hdGlvbjtcbkNoYXJ0LkFuaW1hdGlvbnMgPSBBbmltYXRpb25zO1xuQ2hhcnQuYW5pbWF0b3IgPSBhbmltYXRvcjtcbkNoYXJ0LmNvbnRyb2xsZXJzID0gcmVnaXN0cnkuY29udHJvbGxlcnMuaXRlbXM7XG5DaGFydC5EYXRhc2V0Q29udHJvbGxlciA9IERhdGFzZXRDb250cm9sbGVyO1xuQ2hhcnQuRWxlbWVudCA9IEVsZW1lbnQ7XG5DaGFydC5lbGVtZW50cyA9IGVsZW1lbnRzO1xuQ2hhcnQuSW50ZXJhY3Rpb24gPSBJbnRlcmFjdGlvbjtcbkNoYXJ0LmxheW91dHMgPSBsYXlvdXRzO1xuQ2hhcnQucGxhdGZvcm1zID0gcGxhdGZvcm1zO1xuQ2hhcnQuU2NhbGUgPSBTY2FsZTtcbkNoYXJ0LlRpY2tzID0gVGlja3M7XG5PYmplY3QuYXNzaWduKENoYXJ0LCBjb250cm9sbGVycywgc2NhbGVzLCBlbGVtZW50cywgcGx1Z2lucywgcGxhdGZvcm1zKTtcbkNoYXJ0LkNoYXJ0ID0gQ2hhcnQ7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luZG93LkNoYXJ0ID0gQ2hhcnQ7XG59XG5cbnJldHVybiBDaGFydDtcblxufSkpO1xuIiwgIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4nKS5oZWxwZXJzO1xuIiwgIi8qIVxuICogY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyB2Mi4yLjBcbiAqIGh0dHBzOi8vY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5uZXRsaWZ5LmFwcFxuICogKGMpIDIwMTctMjAyMiBjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnY2hhcnQuanMvaGVscGVycycpLCByZXF1aXJlKCdjaGFydC5qcycpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydjaGFydC5qcy9oZWxwZXJzJywgJ2NoYXJ0LmpzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5DaGFydERhdGFMYWJlbHMgPSBmYWN0b3J5KGdsb2JhbC5DaGFydC5oZWxwZXJzLCBnbG9iYWwuQ2hhcnQpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoaGVscGVycywgY2hhcnRfanMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgLy8gZGV2aWNlUGl4ZWxSYXRpbyBpcyB1bmRlZmluZWQgb24gSUUxMFxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDIwNDE4MC84ODM3ODg3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvODVcbiAgICB2YXIgc2NyZWVuID0gd2luZG93LnNjcmVlbjtcbiAgICBpZiAoc2NyZWVuKSB7XG4gICAgICByZXR1cm4gKHNjcmVlbi5kZXZpY2VYRFBJIHx8IDEpIC8gKHNjcmVlbi5sb2dpY2FsWERQSSB8fCAxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMTtcbn0oKSk7XG5cbnZhciB1dGlscyA9IHtcbiAgLy8gQHRvZG8gbW92ZSB0aGlzIGluIENoYXJ0LmhlbHBlcnMudG9UZXh0TGluZXNcbiAgdG9UZXh0TGluZXM6IGZ1bmN0aW9uKGlucHV0cykge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHZhciBpbnB1dDtcblxuICAgIGlucHV0cyA9IFtdLmNvbmNhdChpbnB1dHMpO1xuICAgIHdoaWxlIChpbnB1dHMubGVuZ3RoKSB7XG4gICAgICBpbnB1dCA9IGlucHV0cy5wb3AoKTtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxpbmVzLnVuc2hpZnQuYXBwbHkobGluZXMsIGlucHV0LnNwbGl0KCdcXG4nKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGlucHV0cy5wdXNoLmFwcGx5KGlucHV0cywgaW5wdXQpO1xuICAgICAgfSBlbHNlIGlmICghaGVscGVycy5pc051bGxPclVuZGVmKGlucHV0cykpIHtcbiAgICAgICAgbGluZXMudW5zaGlmdCgnJyArIGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH0sXG5cbiAgLy8gQHRvZG8gbW92ZSB0aGlzIGluIENoYXJ0LmhlbHBlcnMuY2FudmFzLnRleHRTaXplXG4gIC8vIEB0b2RvIGNhY2hlIGNhbGxzIG9mIG1lYXN1cmVUZXh0IGlmIGZvbnQgZG9lc24ndCBjaGFuZ2U/IVxuICB0ZXh0U2l6ZTogZnVuY3Rpb24oY3R4LCBsaW5lcywgZm9udCkge1xuICAgIHZhciBpdGVtcyA9IFtdLmNvbmNhdChsaW5lcyk7XG4gICAgdmFyIGlsZW4gPSBpdGVtcy5sZW5ndGg7XG4gICAgdmFyIHByZXYgPSBjdHguZm9udDtcbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIHZhciBpO1xuXG4gICAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgoY3R4Lm1lYXN1cmVUZXh0KGl0ZW1zW2ldKS53aWR0aCwgd2lkdGgpO1xuICAgIH1cblxuICAgIGN0eC5mb250ID0gcHJldjtcblxuICAgIHJldHVybiB7XG4gICAgICBoZWlnaHQ6IGlsZW4gKiBmb250LmxpbmVIZWlnaHQsXG4gICAgICB3aWR0aDogd2lkdGhcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHZhbHVlIGJvdW5kZWQgYnkgbWluIGFuZCBtYXguIFRoaXMgaXMgZXF1aXZhbGVudCB0byBtYXgobWluLCBtaW4odmFsdWUsIG1heCkpLlxuICAgKiBAdG9kbyBtb3ZlIHRoaXMgbWV0aG9kIGluIENoYXJ0LmhlbHBlcnMuYm91bmRcbiAgICogaHR0cHM6Ly9kb2MucXQuaW8vcXQtNS9xdGdsb2JhbC5odG1sI3FCb3VuZFxuICAgKi9cbiAgYm91bmQ6IGZ1bmN0aW9uKG1pbiwgdmFsdWUsIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBwYWlyIFt2YWx1ZSwgc3RhdGVdIHdoZXJlIHN0YXRlIGlzOlxuICAgKiAqIC0xOiB2YWx1ZSBpcyBvbmx5IGluIGEwIChyZW1vdmVkKVxuICAgKiAqICAxOiB2YWx1ZSBpcyBvbmx5IGluIGExIChhZGRlZClcbiAgICovXG4gIGFycmF5RGlmZjogZnVuY3Rpb24oYTAsIGExKSB7XG4gICAgdmFyIHByZXYgPSBhMC5zbGljZSgpO1xuICAgIHZhciB1cGRhdGVzID0gW107XG4gICAgdmFyIGksIGosIGlsZW4sIHY7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYTEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB2ID0gYTFbaV07XG4gICAgICBqID0gcHJldi5pbmRleE9mKHYpO1xuXG4gICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgdXBkYXRlcy5wdXNoKFt2LCAxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2LnNwbGljZShqLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcHJldi5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHVwZGF0ZXMucHVzaChbcHJldltpXSwgLTFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlcztcbiAgfSxcblxuICAvKipcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvNzBcbiAgICovXG4gIHJhc3Rlcml6ZTogZnVuY3Rpb24odikge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHYgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW87XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG9yaWVudChwb2ludCwgb3JpZ2luKSB7XG4gIHZhciB4MCA9IG9yaWdpbi54O1xuICB2YXIgeTAgPSBvcmlnaW4ueTtcblxuICBpZiAoeDAgPT09IG51bGwpIHtcbiAgICByZXR1cm4ge3g6IDAsIHk6IC0xfTtcbiAgfVxuICBpZiAoeTAgPT09IG51bGwpIHtcbiAgICByZXR1cm4ge3g6IDEsIHk6IDB9O1xuICB9XG5cbiAgdmFyIGR4ID0gcG9pbnQueCAtIHgwO1xuICB2YXIgZHkgPSBwb2ludC55IC0geTA7XG4gIHZhciBsbiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBsbiA/IGR4IC8gbG4gOiAwLFxuICAgIHk6IGxuID8gZHkgLyBsbiA6IC0xXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsaWduZWQoeCwgeSwgdngsIHZ5LCBhbGlnbikge1xuICBzd2l0Y2ggKGFsaWduKSB7XG4gIGNhc2UgJ2NlbnRlcic6XG4gICAgdnggPSB2eSA9IDA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2JvdHRvbSc6XG4gICAgdnggPSAwO1xuICAgIHZ5ID0gMTtcbiAgICBicmVhaztcbiAgY2FzZSAncmlnaHQnOlxuICAgIHZ4ID0gMTtcbiAgICB2eSA9IDA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2xlZnQnOlxuICAgIHZ4ID0gLTE7XG4gICAgdnkgPSAwO1xuICAgIGJyZWFrO1xuICBjYXNlICd0b3AnOlxuICAgIHZ4ID0gMDtcbiAgICB2eSA9IC0xO1xuICAgIGJyZWFrO1xuICBjYXNlICdzdGFydCc6XG4gICAgdnggPSAtdng7XG4gICAgdnkgPSAtdnk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2VuZCc6XG4gICAgLy8ga2VlcCBuYXR1cmFsIG9yaWVudGF0aW9uXG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgLy8gY2xvY2t3aXNlIHJvdGF0aW9uIChpbiBkZWdyZWUpXG4gICAgYWxpZ24gKj0gKE1hdGguUEkgLyAxODApO1xuICAgIHZ4ID0gTWF0aC5jb3MoYWxpZ24pO1xuICAgIHZ5ID0gTWF0aC5zaW4oYWxpZ24pO1xuICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgdng6IHZ4LFxuICAgIHZ5OiB2eVxuICB9O1xufVxuXG4vLyBMaW5lIGNsaXBwaW5nIChDb2hlblx1MjAxM1N1dGhlcmxhbmQgYWxnb3JpdGhtKVxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29oZW5cdTIwMTNTdXRoZXJsYW5kX2FsZ29yaXRobVxuXG52YXIgUl9JTlNJREUgPSAwO1xudmFyIFJfTEVGVCA9IDE7XG52YXIgUl9SSUdIVCA9IDI7XG52YXIgUl9CT1RUT00gPSA0O1xudmFyIFJfVE9QID0gODtcblxuZnVuY3Rpb24gcmVnaW9uKHgsIHksIHJlY3QpIHtcbiAgdmFyIHJlcyA9IFJfSU5TSURFO1xuXG4gIGlmICh4IDwgcmVjdC5sZWZ0KSB7XG4gICAgcmVzIHw9IFJfTEVGVDtcbiAgfSBlbHNlIGlmICh4ID4gcmVjdC5yaWdodCkge1xuICAgIHJlcyB8PSBSX1JJR0hUO1xuICB9XG4gIGlmICh5IDwgcmVjdC50b3ApIHtcbiAgICByZXMgfD0gUl9UT1A7XG4gIH0gZWxzZSBpZiAoeSA+IHJlY3QuYm90dG9tKSB7XG4gICAgcmVzIHw9IFJfQk9UVE9NO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY2xpcHBlZChzZWdtZW50LCBhcmVhKSB7XG4gIHZhciB4MCA9IHNlZ21lbnQueDA7XG4gIHZhciB5MCA9IHNlZ21lbnQueTA7XG4gIHZhciB4MSA9IHNlZ21lbnQueDE7XG4gIHZhciB5MSA9IHNlZ21lbnQueTE7XG4gIHZhciByMCA9IHJlZ2lvbih4MCwgeTAsIGFyZWEpO1xuICB2YXIgcjEgPSByZWdpb24oeDEsIHkxLCBhcmVhKTtcbiAgdmFyIHIsIHgsIHk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghKHIwIHwgcjEpIHx8IChyMCAmIHIxKSkge1xuICAgICAgLy8gYm90aCBwb2ludHMgaW5zaWRlIG9yIG9uIHRoZSBzYW1lIHNpZGU6IG5vIGNsaXBwaW5nXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBhdCBsZWFzdCBvbmUgcG9pbnQgaXMgb3V0c2lkZVxuICAgIHIgPSByMCB8fCByMTtcblxuICAgIGlmIChyICYgUl9UT1ApIHtcbiAgICAgIHggPSB4MCArICh4MSAtIHgwKSAqIChhcmVhLnRvcCAtIHkwKSAvICh5MSAtIHkwKTtcbiAgICAgIHkgPSBhcmVhLnRvcDtcbiAgICB9IGVsc2UgaWYgKHIgJiBSX0JPVFRPTSkge1xuICAgICAgeCA9IHgwICsgKHgxIC0geDApICogKGFyZWEuYm90dG9tIC0geTApIC8gKHkxIC0geTApO1xuICAgICAgeSA9IGFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAociAmIFJfUklHSFQpIHtcbiAgICAgIHkgPSB5MCArICh5MSAtIHkwKSAqIChhcmVhLnJpZ2h0IC0geDApIC8gKHgxIC0geDApO1xuICAgICAgeCA9IGFyZWEucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChyICYgUl9MRUZUKSB7XG4gICAgICB5ID0geTAgKyAoeTEgLSB5MCkgKiAoYXJlYS5sZWZ0IC0geDApIC8gKHgxIC0geDApO1xuICAgICAgeCA9IGFyZWEubGVmdDtcbiAgICB9XG5cbiAgICBpZiAociA9PT0gcjApIHtcbiAgICAgIHgwID0geDtcbiAgICAgIHkwID0geTtcbiAgICAgIHIwID0gcmVnaW9uKHgwLCB5MCwgYXJlYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHgxID0geDtcbiAgICAgIHkxID0geTtcbiAgICAgIHIxID0gcmVnaW9uKHgxLCB5MSwgYXJlYSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4MDogeDAsXG4gICAgeDE6IHgxLFxuICAgIHkwOiB5MCxcbiAgICB5MTogeTFcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZSQxKHJhbmdlLCBjb25maWcpIHtcbiAgdmFyIGFuY2hvciA9IGNvbmZpZy5hbmNob3I7XG4gIHZhciBzZWdtZW50ID0gcmFuZ2U7XG4gIHZhciB4LCB5O1xuXG4gIGlmIChjb25maWcuY2xhbXApIHtcbiAgICBzZWdtZW50ID0gY2xpcHBlZChzZWdtZW50LCBjb25maWcuYXJlYSk7XG4gIH1cblxuICBpZiAoYW5jaG9yID09PSAnc3RhcnQnKSB7XG4gICAgeCA9IHNlZ21lbnQueDA7XG4gICAgeSA9IHNlZ21lbnQueTA7XG4gIH0gZWxzZSBpZiAoYW5jaG9yID09PSAnZW5kJykge1xuICAgIHggPSBzZWdtZW50LngxO1xuICAgIHkgPSBzZWdtZW50LnkxO1xuICB9IGVsc2Uge1xuICAgIHggPSAoc2VnbWVudC54MCArIHNlZ21lbnQueDEpIC8gMjtcbiAgICB5ID0gKHNlZ21lbnQueTAgKyBzZWdtZW50LnkxKSAvIDI7XG4gIH1cblxuICByZXR1cm4gYWxpZ25lZCh4LCB5LCByYW5nZS52eCwgcmFuZ2UudnksIGNvbmZpZy5hbGlnbik7XG59XG5cbnZhciBwb3NpdGlvbmVycyA9IHtcbiAgYXJjOiBmdW5jdGlvbihlbCwgY29uZmlnKSB7XG4gICAgdmFyIGFuZ2xlID0gKGVsLnN0YXJ0QW5nbGUgKyBlbC5lbmRBbmdsZSkgLyAyO1xuICAgIHZhciB2eCA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB2YXIgdnkgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgdmFyIHIwID0gZWwuaW5uZXJSYWRpdXM7XG4gICAgdmFyIHIxID0gZWwub3V0ZXJSYWRpdXM7XG5cbiAgICByZXR1cm4gY29tcHV0ZSQxKHtcbiAgICAgIHgwOiBlbC54ICsgdnggKiByMCxcbiAgICAgIHkwOiBlbC55ICsgdnkgKiByMCxcbiAgICAgIHgxOiBlbC54ICsgdnggKiByMSxcbiAgICAgIHkxOiBlbC55ICsgdnkgKiByMSxcbiAgICAgIHZ4OiB2eCxcbiAgICAgIHZ5OiB2eVxuICAgIH0sIGNvbmZpZyk7XG4gIH0sXG5cbiAgcG9pbnQ6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcbiAgICB2YXIgdiA9IG9yaWVudChlbCwgY29uZmlnLm9yaWdpbik7XG4gICAgdmFyIHJ4ID0gdi54ICogZWwub3B0aW9ucy5yYWRpdXM7XG4gICAgdmFyIHJ5ID0gdi55ICogZWwub3B0aW9ucy5yYWRpdXM7XG5cbiAgICByZXR1cm4gY29tcHV0ZSQxKHtcbiAgICAgIHgwOiBlbC54IC0gcngsXG4gICAgICB5MDogZWwueSAtIHJ5LFxuICAgICAgeDE6IGVsLnggKyByeCxcbiAgICAgIHkxOiBlbC55ICsgcnksXG4gICAgICB2eDogdi54LFxuICAgICAgdnk6IHYueVxuICAgIH0sIGNvbmZpZyk7XG4gIH0sXG5cbiAgYmFyOiBmdW5jdGlvbihlbCwgY29uZmlnKSB7XG4gICAgdmFyIHYgPSBvcmllbnQoZWwsIGNvbmZpZy5vcmlnaW4pO1xuICAgIHZhciB4ID0gZWwueDtcbiAgICB2YXIgeSA9IGVsLnk7XG4gICAgdmFyIHN4ID0gMDtcbiAgICB2YXIgc3kgPSAwO1xuXG4gICAgaWYgKGVsLmhvcml6b250YWwpIHtcbiAgICAgIHggPSBNYXRoLm1pbihlbC54LCBlbC5iYXNlKTtcbiAgICAgIHN4ID0gTWF0aC5hYnMoZWwuYmFzZSAtIGVsLngpO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ID0gTWF0aC5taW4oZWwueSwgZWwuYmFzZSk7XG4gICAgICBzeSA9IE1hdGguYWJzKGVsLmJhc2UgLSBlbC55KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcHV0ZSQxKHtcbiAgICAgIHgwOiB4LFxuICAgICAgeTA6IHkgKyBzeSxcbiAgICAgIHgxOiB4ICsgc3gsXG4gICAgICB5MTogeSxcbiAgICAgIHZ4OiB2LngsXG4gICAgICB2eTogdi55XG4gICAgfSwgY29uZmlnKTtcbiAgfSxcblxuICBmYWxsYmFjazogZnVuY3Rpb24oZWwsIGNvbmZpZykge1xuICAgIHZhciB2ID0gb3JpZW50KGVsLCBjb25maWcub3JpZ2luKTtcblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IGVsLngsXG4gICAgICB5MDogZWwueSxcbiAgICAgIHgxOiBlbC54ICsgKGVsLndpZHRoIHx8IDApLFxuICAgICAgeTE6IGVsLnkgKyAoZWwuaGVpZ2h0IHx8IDApLFxuICAgICAgdng6IHYueCxcbiAgICAgIHZ5OiB2LnlcbiAgICB9LCBjb25maWcpO1xuICB9XG59O1xuXG52YXIgcmFzdGVyaXplID0gdXRpbHMucmFzdGVyaXplO1xuXG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKG1vZGVsKSB7XG4gIHZhciBib3JkZXJXaWR0aCA9IG1vZGVsLmJvcmRlcldpZHRoIHx8IDA7XG4gIHZhciBwYWRkaW5nID0gbW9kZWwucGFkZGluZztcbiAgdmFyIHRoID0gbW9kZWwuc2l6ZS5oZWlnaHQ7XG4gIHZhciB0dyA9IG1vZGVsLnNpemUud2lkdGg7XG4gIHZhciB0eCA9IC10dyAvIDI7XG4gIHZhciB0eSA9IC10aCAvIDI7XG5cbiAgcmV0dXJuIHtcbiAgICBmcmFtZToge1xuICAgICAgeDogdHggLSBwYWRkaW5nLmxlZnQgLSBib3JkZXJXaWR0aCxcbiAgICAgIHk6IHR5IC0gcGFkZGluZy50b3AgLSBib3JkZXJXaWR0aCxcbiAgICAgIHc6IHR3ICsgcGFkZGluZy53aWR0aCArIGJvcmRlcldpZHRoICogMixcbiAgICAgIGg6IHRoICsgcGFkZGluZy5oZWlnaHQgKyBib3JkZXJXaWR0aCAqIDJcbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIHg6IHR4LFxuICAgICAgeTogdHksXG4gICAgICB3OiB0dyxcbiAgICAgIGg6IHRoXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZU9yaWdpbihlbCwgY29udGV4dCkge1xuICB2YXIgc2NhbGUgPSBjb250ZXh0LmNoYXJ0LmdldERhdGFzZXRNZXRhKGNvbnRleHQuZGF0YXNldEluZGV4KS52U2NhbGU7XG5cbiAgaWYgKCFzY2FsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHNjYWxlLnhDZW50ZXIgIT09IHVuZGVmaW5lZCAmJiBzY2FsZS55Q2VudGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge3g6IHNjYWxlLnhDZW50ZXIsIHk6IHNjYWxlLnlDZW50ZXJ9O1xuICB9XG5cbiAgdmFyIHBpeGVsID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gIHJldHVybiBlbC5ob3Jpem9udGFsID9cbiAgICB7eDogcGl4ZWwsIHk6IG51bGx9IDpcbiAgICB7eDogbnVsbCwgeTogcGl4ZWx9O1xufVxuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbmVyKGVsKSB7XG4gIGlmIChlbCBpbnN0YW5jZW9mIGNoYXJ0X2pzLkFyY0VsZW1lbnQpIHtcbiAgICByZXR1cm4gcG9zaXRpb25lcnMuYXJjO1xuICB9XG4gIGlmIChlbCBpbnN0YW5jZW9mIGNoYXJ0X2pzLlBvaW50RWxlbWVudCkge1xuICAgIHJldHVybiBwb3NpdGlvbmVycy5wb2ludDtcbiAgfVxuICBpZiAoZWwgaW5zdGFuY2VvZiBjaGFydF9qcy5CYXJFbGVtZW50KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uZXJzLmJhcjtcbiAgfVxuICByZXR1cm4gcG9zaXRpb25lcnMuZmFsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIGRyYXdSb3VuZGVkUmVjdChjdHgsIHgsIHksIHcsIGgsIHJhZGl1cykge1xuICB2YXIgSEFMRl9QSSA9IE1hdGguUEkgLyAyO1xuXG4gIGlmIChyYWRpdXMpIHtcbiAgICB2YXIgciA9IE1hdGgubWluKHJhZGl1cywgaCAvIDIsIHcgLyAyKTtcbiAgICB2YXIgbGVmdCA9IHggKyByO1xuICAgIHZhciB0b3AgPSB5ICsgcjtcbiAgICB2YXIgcmlnaHQgPSB4ICsgdyAtIHI7XG4gICAgdmFyIGJvdHRvbSA9IHkgKyBoIC0gcjtcblxuICAgIGN0eC5tb3ZlVG8oeCwgdG9wKTtcbiAgICBpZiAobGVmdCA8IHJpZ2h0ICYmIHRvcCA8IGJvdHRvbSkge1xuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1NYXRoLlBJLCAtSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKHJpZ2h0LCB0b3AsIHIsIC1IQUxGX1BJLCAwKTtcbiAgICAgIGN0eC5hcmMocmlnaHQsIGJvdHRvbSwgciwgMCwgSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKGxlZnQsIGJvdHRvbSwgciwgSEFMRl9QSSwgTWF0aC5QSSk7XG4gICAgfSBlbHNlIGlmIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgIGN0eC5tb3ZlVG8obGVmdCwgeSk7XG4gICAgICBjdHguYXJjKHJpZ2h0LCB0b3AsIHIsIC1IQUxGX1BJLCBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMobGVmdCwgdG9wLCByLCBIQUxGX1BJLCBNYXRoLlBJICsgSEFMRl9QSSk7XG4gICAgfSBlbHNlIGlmICh0b3AgPCBib3R0b20pIHtcbiAgICAgIGN0eC5hcmMobGVmdCwgdG9wLCByLCAtTWF0aC5QSSwgMCk7XG4gICAgICBjdHguYXJjKGxlZnQsIGJvdHRvbSwgciwgMCwgTWF0aC5QSSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5hcmMobGVmdCwgdG9wLCByLCAtTWF0aC5QSSwgTWF0aC5QSSk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5yZWN0KHgsIHksIHcsIGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdGcmFtZShjdHgsIHJlY3QsIG1vZGVsKSB7XG4gIHZhciBiZ0NvbG9yID0gbW9kZWwuYmFja2dyb3VuZENvbG9yO1xuICB2YXIgYm9yZGVyQ29sb3IgPSBtb2RlbC5ib3JkZXJDb2xvcjtcbiAgdmFyIGJvcmRlcldpZHRoID0gbW9kZWwuYm9yZGVyV2lkdGg7XG5cbiAgaWYgKCFiZ0NvbG9yICYmICghYm9yZGVyQ29sb3IgfHwgIWJvcmRlcldpZHRoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBkcmF3Um91bmRlZFJlY3QoXG4gICAgY3R4LFxuICAgIHJhc3Rlcml6ZShyZWN0LngpICsgYm9yZGVyV2lkdGggLyAyLFxuICAgIHJhc3Rlcml6ZShyZWN0LnkpICsgYm9yZGVyV2lkdGggLyAyLFxuICAgIHJhc3Rlcml6ZShyZWN0LncpIC0gYm9yZGVyV2lkdGgsXG4gICAgcmFzdGVyaXplKHJlY3QuaCkgLSBib3JkZXJXaWR0aCxcbiAgICBtb2RlbC5ib3JkZXJSYWRpdXMpO1xuXG4gIGN0eC5jbG9zZVBhdGgoKTtcblxuICBpZiAoYmdDb2xvcikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBiZ0NvbG9yO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cblxuICBpZiAoYm9yZGVyQ29sb3IgJiYgYm9yZGVyV2lkdGgpIHtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gJ21pdGVyJztcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGV4dEdlb21ldHJ5KHJlY3QsIGFsaWduLCBmb250KSB7XG4gIHZhciBoID0gZm9udC5saW5lSGVpZ2h0O1xuICB2YXIgdyA9IHJlY3QudztcbiAgdmFyIHggPSByZWN0Lng7XG4gIHZhciB5ID0gcmVjdC55ICsgaCAvIDI7XG5cbiAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggKz0gdyAvIDI7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnIHx8IGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCArPSB3O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoOiBoLFxuICAgIHc6IHcsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRyYXdUZXh0TGluZShjdHgsIHRleHQsIGNmZykge1xuICB2YXIgc2hhZG93ID0gY3R4LnNoYWRvd0JsdXI7XG4gIHZhciBzdHJva2VkID0gY2ZnLnN0cm9rZWQ7XG4gIHZhciB4ID0gcmFzdGVyaXplKGNmZy54KTtcbiAgdmFyIHkgPSByYXN0ZXJpemUoY2ZnLnkpO1xuICB2YXIgdyA9IHJhc3Rlcml6ZShjZmcudyk7XG5cbiAgaWYgKHN0cm9rZWQpIHtcbiAgICBjdHguc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5LCB3KTtcbiAgfVxuXG4gIGlmIChjZmcuZmlsbGVkKSB7XG4gICAgaWYgKHNoYWRvdyAmJiBzdHJva2VkKSB7XG4gICAgICAvLyBQcmV2ZW50IGRyYXdpbmcgc2hhZG93IG9uIGJvdGggdGhlIHRleHQgc3Ryb2tlIGFuZCBmaWxsLCBzb1xuICAgICAgLy8gaWYgdGhlIHRleHQgaXMgc3Ryb2tlZCwgcmVtb3ZlIHRoZSBzaGFkb3cgZm9yIHRoZSB0ZXh0IGZpbGwuXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgfVxuXG4gICAgY3R4LmZpbGxUZXh0KHRleHQsIHgsIHksIHcpO1xuXG4gICAgaWYgKHNoYWRvdyAmJiBzdHJva2VkKSB7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IHNoYWRvdztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1RleHQoY3R4LCBsaW5lcywgcmVjdCwgbW9kZWwpIHtcbiAgdmFyIGFsaWduID0gbW9kZWwudGV4dEFsaWduO1xuICB2YXIgY29sb3IgPSBtb2RlbC5jb2xvcjtcbiAgdmFyIGZpbGxlZCA9ICEhY29sb3I7XG4gIHZhciBmb250ID0gbW9kZWwuZm9udDtcbiAgdmFyIGlsZW4gPSBsaW5lcy5sZW5ndGg7XG4gIHZhciBzdHJva2VDb2xvciA9IG1vZGVsLnRleHRTdHJva2VDb2xvcjtcbiAgdmFyIHN0cm9rZVdpZHRoID0gbW9kZWwudGV4dFN0cm9rZVdpZHRoO1xuICB2YXIgc3Ryb2tlZCA9IHN0cm9rZUNvbG9yICYmIHN0cm9rZVdpZHRoO1xuICB2YXIgaTtcblxuICBpZiAoIWlsZW4gfHwgKCFmaWxsZWQgJiYgIXN0cm9rZWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQWRqdXN0IGNvb3JkaW5hdGVzIGJhc2VkIG9uIHRleHQgYWxpZ25tZW50IGFuZCBsaW5lIGhlaWdodFxuICByZWN0ID0gdGV4dEdlb21ldHJ5KHJlY3QsIGFsaWduLCBmb250KTtcblxuICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuICBjdHgudGV4dEFsaWduID0gYWxpZ247XG4gIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgY3R4LnNoYWRvd0JsdXIgPSBtb2RlbC50ZXh0U2hhZG93Qmx1cjtcbiAgY3R4LnNoYWRvd0NvbG9yID0gbW9kZWwudGV4dFNoYWRvd0NvbG9yO1xuXG4gIGlmIChmaWxsZWQpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gIH1cbiAgaWYgKHN0cm9rZWQpIHtcbiAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvcjtcbiAgfVxuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkcmF3VGV4dExpbmUoY3R4LCBsaW5lc1tpXSwge1xuICAgICAgc3Ryb2tlZDogc3Ryb2tlZCxcbiAgICAgIGZpbGxlZDogZmlsbGVkLFxuICAgICAgdzogcmVjdC53LFxuICAgICAgeDogcmVjdC54LFxuICAgICAgeTogcmVjdC55ICsgcmVjdC5oICogaVxuICAgIH0pO1xuICB9XG59XG5cbnZhciBMYWJlbCA9IGZ1bmN0aW9uKGNvbmZpZywgY3R4LCBlbCwgaW5kZXgpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICBtZS5fY29uZmlnID0gY29uZmlnO1xuICBtZS5faW5kZXggPSBpbmRleDtcbiAgbWUuX21vZGVsID0gbnVsbDtcbiAgbWUuX3JlY3RzID0gbnVsbDtcbiAgbWUuX2N0eCA9IGN0eDtcbiAgbWUuX2VsID0gZWw7XG59O1xuXG5oZWxwZXJzLm1lcmdlKExhYmVsLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb2RlbGl6ZTogZnVuY3Rpb24oZGlzcGxheSwgbGluZXMsIGNvbmZpZywgY29udGV4dCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGluZGV4ID0gbWUuX2luZGV4O1xuICAgIHZhciBmb250ID0gaGVscGVycy50b0ZvbnQoaGVscGVycy5yZXNvbHZlKFtjb25maWcuZm9udCwge31dLCBjb250ZXh0LCBpbmRleCkpO1xuICAgIHZhciBjb2xvciA9IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmNvbG9yLCBjaGFydF9qcy5kZWZhdWx0cy5jb2xvcl0sIGNvbnRleHQsIGluZGV4KTtcblxuICAgIHJldHVybiB7XG4gICAgICBhbGlnbjogaGVscGVycy5yZXNvbHZlKFtjb25maWcuYWxpZ24sICdjZW50ZXInXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYW5jaG9yOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5hbmNob3IsICdjZW50ZXInXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYXJlYTogY29udGV4dC5jaGFydC5jaGFydEFyZWEsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmJhY2tncm91bmRDb2xvciwgbnVsbF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGJvcmRlckNvbG9yOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5ib3JkZXJDb2xvciwgbnVsbF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGJvcmRlclJhZGl1czogaGVscGVycy5yZXNvbHZlKFtjb25maWcuYm9yZGVyUmFkaXVzLCAwXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYm9yZGVyV2lkdGg6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmJvcmRlcldpZHRoLCAwXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgY2xhbXA6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmNsYW1wLCBmYWxzZV0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGNsaXA6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmNsaXAsIGZhbHNlXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgZGlzcGxheTogZGlzcGxheSxcbiAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICBsaW5lczogbGluZXMsXG4gICAgICBvZmZzZXQ6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLm9mZnNldCwgNF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIG9wYWNpdHk6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLm9wYWNpdHksIDFdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBvcmlnaW46IGdldFNjYWxlT3JpZ2luKG1lLl9lbCwgY29udGV4dCksXG4gICAgICBwYWRkaW5nOiBoZWxwZXJzLnRvUGFkZGluZyhoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5wYWRkaW5nLCA0XSwgY29udGV4dCwgaW5kZXgpKSxcbiAgICAgIHBvc2l0aW9uZXI6IGdldFBvc2l0aW9uZXIobWUuX2VsKSxcbiAgICAgIHJvdGF0aW9uOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5yb3RhdGlvbiwgMF0sIGNvbnRleHQsIGluZGV4KSAqIChNYXRoLlBJIC8gMTgwKSxcbiAgICAgIHNpemU6IHV0aWxzLnRleHRTaXplKG1lLl9jdHgsIGxpbmVzLCBmb250KSxcbiAgICAgIHRleHRBbGlnbjogaGVscGVycy5yZXNvbHZlKFtjb25maWcudGV4dEFsaWduLCAnc3RhcnQnXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgdGV4dFNoYWRvd0JsdXI6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLnRleHRTaGFkb3dCbHVyLCAwXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgdGV4dFNoYWRvd0NvbG9yOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy50ZXh0U2hhZG93Q29sb3IsIGNvbG9yXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgdGV4dFN0cm9rZUNvbG9yOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy50ZXh0U3Ryb2tlQ29sb3IsIGNvbG9yXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgdGV4dFN0cm9rZVdpZHRoOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy50ZXh0U3Ryb2tlV2lkdGgsIDBdLCBjb250ZXh0LCBpbmRleClcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIG1vZGVsID0gbnVsbDtcbiAgICB2YXIgcmVjdHMgPSBudWxsO1xuICAgIHZhciBpbmRleCA9IG1lLl9pbmRleDtcbiAgICB2YXIgY29uZmlnID0gbWUuX2NvbmZpZztcbiAgICB2YXIgdmFsdWUsIGxhYmVsLCBsaW5lcztcblxuICAgIC8vIFdlIGZpcnN0IHJlc29sdmUgdGhlIGRpc3BsYXkgb3B0aW9uIChzZXBhcmF0ZWx5KSB0byBhdm9pZCBjb21wdXRpbmdcbiAgICAvLyBvdGhlciBvcHRpb25zIGluIGNhc2UgdGhlIGxhYmVsIGlzIGhpZGRlbiAoaS5lLiBkaXNwbGF5OiBmYWxzZSkuXG4gICAgdmFyIGRpc3BsYXkgPSBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5kaXNwbGF5LCB0cnVlXSwgY29udGV4dCwgaW5kZXgpO1xuXG4gICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgIHZhbHVlID0gY29udGV4dC5kYXRhc2V0LmRhdGFbaW5kZXhdO1xuICAgICAgbGFiZWwgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGhlbHBlcnMuY2FsbGJhY2soY29uZmlnLmZvcm1hdHRlciwgW3ZhbHVlLCBjb250ZXh0XSksIHZhbHVlKTtcbiAgICAgIGxpbmVzID0gaGVscGVycy5pc051bGxPclVuZGVmKGxhYmVsKSA/IFtdIDogdXRpbHMudG9UZXh0TGluZXMobGFiZWwpO1xuXG4gICAgICBpZiAobGluZXMubGVuZ3RoKSB7XG4gICAgICAgIG1vZGVsID0gbWUuX21vZGVsaXplKGRpc3BsYXksIGxpbmVzLCBjb25maWcsIGNvbnRleHQpO1xuICAgICAgICByZWN0cyA9IGJvdW5kaW5nUmVjdHMobW9kZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lLl9tb2RlbCA9IG1vZGVsO1xuICAgIG1lLl9yZWN0cyA9IHJlY3RzO1xuICB9LFxuXG4gIGdlb21ldHJ5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjdHMgPyB0aGlzLl9yZWN0cy5mcmFtZSA6IHt9O1xuICB9LFxuXG4gIHJvdGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwgPyB0aGlzLl9tb2RlbC5yb3RhdGlvbiA6IDA7XG4gIH0sXG5cbiAgdmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsICYmIHRoaXMuX21vZGVsLm9wYWNpdHk7XG4gIH0sXG5cbiAgbW9kZWw6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbDtcbiAgfSxcblxuICBkcmF3OiBmdW5jdGlvbihjaGFydCwgY2VudGVyKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgY3R4ID0gY2hhcnQuY3R4O1xuICAgIHZhciBtb2RlbCA9IG1lLl9tb2RlbDtcbiAgICB2YXIgcmVjdHMgPSBtZS5fcmVjdHM7XG4gICAgdmFyIGFyZWE7XG5cbiAgICBpZiAoIXRoaXMudmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGlmIChtb2RlbC5jbGlwKSB7XG4gICAgICBhcmVhID0gbW9kZWwuYXJlYTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5yZWN0KFxuICAgICAgICBhcmVhLmxlZnQsXG4gICAgICAgIGFyZWEudG9wLFxuICAgICAgICBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LFxuICAgICAgICBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgfVxuXG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdXRpbHMuYm91bmQoMCwgbW9kZWwub3BhY2l0eSwgMSk7XG4gICAgY3R4LnRyYW5zbGF0ZShyYXN0ZXJpemUoY2VudGVyLngpLCByYXN0ZXJpemUoY2VudGVyLnkpKTtcbiAgICBjdHgucm90YXRlKG1vZGVsLnJvdGF0aW9uKTtcblxuICAgIGRyYXdGcmFtZShjdHgsIHJlY3RzLmZyYW1lLCBtb2RlbCk7XG4gICAgZHJhd1RleHQoY3R4LCBtb2RlbC5saW5lcywgcmVjdHMudGV4dCwgbW9kZWwpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufSk7XG5cbnZhciBNSU5fSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVzL25vLW51bWJlci1taW5zYWZlaW50ZWdlclxudmFyIE1BWF9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXMvbm8tbnVtYmVyLW1heHNhZmVpbnRlZ2VyXG5cbmZ1bmN0aW9uIHJvdGF0ZWQocG9pbnQsIGNlbnRlciwgYW5nbGUpIHtcbiAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgdmFyIGN4ID0gY2VudGVyLng7XG4gIHZhciBjeSA9IGNlbnRlci55O1xuXG4gIHJldHVybiB7XG4gICAgeDogY3ggKyBjb3MgKiAocG9pbnQueCAtIGN4KSAtIHNpbiAqIChwb2ludC55IC0gY3kpLFxuICAgIHk6IGN5ICsgc2luICogKHBvaW50LnggLSBjeCkgKyBjb3MgKiAocG9pbnQueSAtIGN5KVxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0ZWQocG9pbnRzLCBheGlzKSB7XG4gIHZhciBtaW4gPSBNQVhfSU5URUdFUjtcbiAgdmFyIG1heCA9IE1JTl9JTlRFR0VSO1xuICB2YXIgb3JpZ2luID0gYXhpcy5vcmlnaW47XG4gIHZhciBpLCBwdCwgdngsIHZ5LCBkcDtcblxuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgcHQgPSBwb2ludHNbaV07XG4gICAgdnggPSBwdC54IC0gb3JpZ2luLng7XG4gICAgdnkgPSBwdC55IC0gb3JpZ2luLnk7XG4gICAgZHAgPSBheGlzLnZ4ICogdnggKyBheGlzLnZ5ICogdnk7XG4gICAgbWluID0gTWF0aC5taW4obWluLCBkcCk7XG4gICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkcCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvQXhpcyhwMCwgcDEpIHtcbiAgdmFyIHZ4ID0gcDEueCAtIHAwLng7XG4gIHZhciB2eSA9IHAxLnkgLSBwMC55O1xuICB2YXIgbG4gPSBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xuXG4gIHJldHVybiB7XG4gICAgdng6IChwMS54IC0gcDAueCkgLyBsbixcbiAgICB2eTogKHAxLnkgLSBwMC55KSAvIGxuLFxuICAgIG9yaWdpbjogcDAsXG4gICAgbG46IGxuXG4gIH07XG59XG5cbnZhciBIaXRCb3ggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcm90YXRpb24gPSAwO1xuICB0aGlzLl9yZWN0ID0ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3OiAwLFxuICAgIGg6IDBcbiAgfTtcbn07XG5cbmhlbHBlcnMubWVyZ2UoSGl0Qm94LnByb3RvdHlwZSwge1xuICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gdGhpcy5fcmVjdDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogci54ICsgci53IC8gMixcbiAgICAgIHk6IHIueSArIHIuaCAvIDJcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24oY2VudGVyLCByZWN0LCByb3RhdGlvbikge1xuICAgIHRoaXMuX3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5fcmVjdCA9IHtcbiAgICAgIHg6IHJlY3QueCArIGNlbnRlci54LFxuICAgICAgeTogcmVjdC55ICsgY2VudGVyLnksXG4gICAgICB3OiByZWN0LncsXG4gICAgICBoOiByZWN0LmhcbiAgICB9O1xuICB9LFxuXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIG1hcmdpbiA9IDE7XG4gICAgdmFyIHJlY3QgPSBtZS5fcmVjdDtcblxuICAgIHBvaW50ID0gcm90YXRlZChwb2ludCwgbWUuY2VudGVyKCksIC1tZS5fcm90YXRpb24pO1xuXG4gICAgcmV0dXJuICEocG9pbnQueCA8IHJlY3QueCAtIG1hcmdpblxuICAgICAgfHwgcG9pbnQueSA8IHJlY3QueSAtIG1hcmdpblxuICAgICAgfHwgcG9pbnQueCA+IHJlY3QueCArIHJlY3QudyArIG1hcmdpbiAqIDJcbiAgICAgIHx8IHBvaW50LnkgPiByZWN0LnkgKyByZWN0LmggKyBtYXJnaW4gKiAyKTtcbiAgfSxcblxuICAvLyBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbVxuICAvLyBodHRwczovL2dhbWVkZXZlbG9wbWVudC50dXRzcGx1cy5jb20vdHV0b3JpYWxzL2NvbGxpc2lvbi1kZXRlY3Rpb24tdXNpbmctdGhlLXNlcGFyYXRpbmctYXhpcy10aGVvcmVtLS1nYW1lZGV2LTE2OVxuICBpbnRlcnNlY3RzOiBmdW5jdGlvbihvdGhlcikge1xuICAgIHZhciByMCA9IHRoaXMuX3BvaW50cygpO1xuICAgIHZhciByMSA9IG90aGVyLl9wb2ludHMoKTtcbiAgICB2YXIgYXhlcyA9IFtcbiAgICAgIHRvQXhpcyhyMFswXSwgcjBbMV0pLFxuICAgICAgdG9BeGlzKHIwWzBdLCByMFszXSlcbiAgICBdO1xuICAgIHZhciBpLCBwcjAsIHByMTtcblxuICAgIGlmICh0aGlzLl9yb3RhdGlvbiAhPT0gb3RoZXIuX3JvdGF0aW9uKSB7XG4gICAgICAvLyBPbmx5IHNlcGFyYXRlIHdpdGggcjEgYXhpcyBpZiB0aGUgcm90YXRpb24gaXMgZGlmZmVyZW50LFxuICAgICAgLy8gZWxzZSBpdCdzIGVub3VnaCB0byBzZXBhcmF0ZSByMCBhbmQgcjEgd2l0aCByMCBheGlzIG9ubHkhXG4gICAgICBheGVzLnB1c2goXG4gICAgICAgIHRvQXhpcyhyMVswXSwgcjFbMV0pLFxuICAgICAgICB0b0F4aXMocjFbMF0sIHIxWzNdKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgcHIwID0gcHJvamVjdGVkKHIwLCBheGVzW2ldKTtcbiAgICAgIHByMSA9IHByb2plY3RlZChyMSwgYXhlc1tpXSk7XG5cbiAgICAgIGlmIChwcjAubWF4IDwgcHIxLm1pbiB8fCBwcjEubWF4IDwgcHIwLm1pbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZWN0ID0gbWUuX3JlY3Q7XG4gICAgdmFyIGFuZ2xlID0gbWUuX3JvdGF0aW9uO1xuICAgIHZhciBjZW50ZXIgPSBtZS5jZW50ZXIoKTtcblxuICAgIHJldHVybiBbXG4gICAgICByb3RhdGVkKHt4OiByZWN0LngsIHk6IHJlY3QueX0sIGNlbnRlciwgYW5nbGUpLFxuICAgICAgcm90YXRlZCh7eDogcmVjdC54ICsgcmVjdC53LCB5OiByZWN0Lnl9LCBjZW50ZXIsIGFuZ2xlKSxcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCArIHJlY3QudywgeTogcmVjdC55ICsgcmVjdC5ofSwgY2VudGVyLCBhbmdsZSksXG4gICAgICByb3RhdGVkKHt4OiByZWN0LngsIHk6IHJlY3QueSArIHJlY3QuaH0sIGNlbnRlciwgYW5nbGUpXG4gICAgXTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvb3JkaW5hdGVzKGVsLCBtb2RlbCwgZ2VvbWV0cnkpIHtcbiAgdmFyIHBvaW50ID0gbW9kZWwucG9zaXRpb25lcihlbCwgbW9kZWwpO1xuICB2YXIgdnggPSBwb2ludC52eDtcbiAgdmFyIHZ5ID0gcG9pbnQudnk7XG5cbiAgaWYgKCF2eCAmJiAhdnkpIHtcbiAgICAvLyBpZiBhbGlnbmVkIGNlbnRlciwgd2UgZG9uJ3Qgd2FudCB0byBvZmZzZXQgdGhlIGNlbnRlciBwb2ludFxuICAgIHJldHVybiB7eDogcG9pbnQueCwgeTogcG9pbnQueX07XG4gIH1cblxuICB2YXIgdyA9IGdlb21ldHJ5Lnc7XG4gIHZhciBoID0gZ2VvbWV0cnkuaDtcblxuICAvLyB0YWtlIGluIGFjY291bnQgdGhlIGxhYmVsIHJvdGF0aW9uXG4gIHZhciByb3RhdGlvbiA9IG1vZGVsLnJvdGF0aW9uO1xuICB2YXIgZHggPSBNYXRoLmFicyh3IC8gMiAqIE1hdGguY29zKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoIC8gMiAqIE1hdGguc2luKHJvdGF0aW9uKSk7XG4gIHZhciBkeSA9IE1hdGguYWJzKHcgLyAyICogTWF0aC5zaW4ocm90YXRpb24pKSArIE1hdGguYWJzKGggLyAyICogTWF0aC5jb3Mocm90YXRpb24pKTtcblxuICAvLyBzY2FsZSB0aGUgdW5pdCB2ZWN0b3IgKHZ4LCB2eSkgdG8gZ2V0IGF0IGxlYXN0IGR4IG9yIGR5IGVxdWFsIHRvXG4gIC8vIHcgb3IgaCByZXNwZWN0aXZlbHkgKGVsc2Ugd2Ugd291bGQgY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB0byB0aGVcbiAgLy8gZWxsaXBzZSBpbnNjcmliZWQgaW4gdGhlIGJvdW5kaW5nIHJlY3QpXG4gIHZhciB2cyA9IDEgLyBNYXRoLm1heChNYXRoLmFicyh2eCksIE1hdGguYWJzKHZ5KSk7XG4gIGR4ICo9IHZ4ICogdnM7XG4gIGR5ICo9IHZ5ICogdnM7XG5cbiAgLy8gZmluYWxseSwgaW5jbHVkZSB0aGUgZXhwbGljaXQgb2Zmc2V0XG4gIGR4ICs9IG1vZGVsLm9mZnNldCAqIHZ4O1xuICBkeSArPSBtb2RlbC5vZmZzZXQgKiB2eTtcblxuICByZXR1cm4ge1xuICAgIHg6IHBvaW50LnggKyBkeCxcbiAgICB5OiBwb2ludC55ICsgZHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29sbGlkZShsYWJlbHMsIGNvbGxpZGVyKSB7XG4gIHZhciBpLCBqLCBzMCwgczE7XG5cbiAgLy8gSU1QT1JUQU5UIEl0ZXJhdGUgaW4gdGhlIHJldmVyc2Ugb3JkZXIgc2luY2UgaXRlbXMgYXQgdGhlIGVuZCBvZiB0aGVcbiAgLy8gbGlzdCBoYXZlIGFuIGhpZ2hlciB3ZWlnaHQvcHJpb3JpdHkgYW5kIHRodXMgc2hvdWxkIGJlIGxlc3MgaW1wYWN0ZWRcbiAgLy8gYnkgdGhlIG92ZXJsYXBwaW5nIHN0cmF0ZWd5LlxuXG4gIGZvciAoaSA9IGxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHMwID0gbGFiZWxzW2ldLiRsYXlvdXQ7XG5cbiAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwICYmIHMwLl92aXNpYmxlOyAtLWopIHtcbiAgICAgIHMxID0gbGFiZWxzW2pdLiRsYXlvdXQ7XG5cbiAgICAgIGlmIChzMS5fdmlzaWJsZSAmJiBzMC5fYm94LmludGVyc2VjdHMoczEuX2JveCkpIHtcbiAgICAgICAgY29sbGlkZXIoczAsIHMxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFiZWxzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlKGxhYmVscykge1xuICB2YXIgaSwgaWxlbiwgbGFiZWwsIHN0YXRlLCBnZW9tZXRyeSwgY2VudGVyLCBwcm94eTtcblxuICAvLyBJbml0aWFsaXplIGxhYmVscyBmb3Igb3ZlcmxhcCBkZXRlY3Rpb25cbiAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICBzdGF0ZSA9IGxhYmVsLiRsYXlvdXQ7XG5cbiAgICBpZiAoc3RhdGUuX3Zpc2libGUpIHtcbiAgICAgIC8vIENoYXJ0LmpzIDMgcmVtb3ZlZCBlbC5fbW9kZWwgaW4gZmF2b3Igb2YgZ2V0UHJvcHMoKSwgbWFraW5nIGhhcmRlciB0b1xuICAgICAgLy8gYWJzdHJhY3QgcmVhZGluZyB2YWx1ZXMgaW4gcG9zaXRpb25lcnMuIEFsc28sIHVzaW5nIHN0cmluZyBhcnJheXMgdG9cbiAgICAgIC8vIHJlYWQgdmFsdWVzIChpLmUuIHZhciB7YSxiLGN9ID0gZWwuZ2V0UHJvcHMoW1wiYVwiLFwiYlwiLFwiY1wiXSkpIHdvdWxkIG1ha2VcbiAgICAgIC8vIHBvc2l0aW9uZXJzIGluZWZmaWNpZW50IGluIHRoZSBub3JtYWwgY2FzZSAoaS5lLiBub3QgdGhlIGZpbmFsIHZhbHVlcylcbiAgICAgIC8vIGFuZCB0aGUgY29kZSBhIGJpdCB1Z2x5LCBzbyBsZXQncyB1c2UgYSBQcm94eSBpbnN0ZWFkLlxuICAgICAgcHJveHkgPSBuZXcgUHJveHkobGFiZWwuX2VsLCB7Z2V0OiAoZWwsIHApID0+IGVsLmdldFByb3BzKFtwXSwgdHJ1ZSlbcF19KTtcblxuICAgICAgZ2VvbWV0cnkgPSBsYWJlbC5nZW9tZXRyeSgpO1xuICAgICAgY2VudGVyID0gY29vcmRpbmF0ZXMocHJveHksIGxhYmVsLm1vZGVsKCksIGdlb21ldHJ5KTtcbiAgICAgIHN0YXRlLl9ib3gudXBkYXRlKGNlbnRlciwgZ2VvbWV0cnksIGxhYmVsLnJvdGF0aW9uKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF1dG8gaGlkZSBvdmVybGFwcGluZyBsYWJlbHNcbiAgcmV0dXJuIGNvbGxpZGUobGFiZWxzLCBmdW5jdGlvbihzMCwgczEpIHtcbiAgICB2YXIgaDAgPSBzMC5faGlkYWJsZTtcbiAgICB2YXIgaDEgPSBzMS5faGlkYWJsZTtcblxuICAgIGlmICgoaDAgJiYgaDEpIHx8IGgxKSB7XG4gICAgICBzMS5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaDApIHtcbiAgICAgIHMwLl92aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGxheW91dCA9IHtcbiAgcHJlcGFyZTogZnVuY3Rpb24oZGF0YXNldHMpIHtcbiAgICB2YXIgbGFiZWxzID0gW107XG4gICAgdmFyIGksIGosIGlsZW4sIGpsZW4sIGxhYmVsO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgZm9yIChqID0gMCwgamxlbiA9IGRhdGFzZXRzW2ldLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICBsYWJlbCA9IGRhdGFzZXRzW2ldW2pdO1xuICAgICAgICBsYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIGxhYmVsLiRsYXlvdXQgPSB7XG4gICAgICAgICAgX2JveDogbmV3IEhpdEJveCgpLFxuICAgICAgICAgIF9oaWRhYmxlOiBmYWxzZSxcbiAgICAgICAgICBfdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICBfc2V0OiBpLFxuICAgICAgICAgIF9pZHg6IGxhYmVsLl9pbmRleFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gTmV3IGB6YCBvcHRpb246IGxhYmVscyB3aXRoIGEgaGlnaGVyIHotaW5kZXggYXJlIGRyYXduXG4gICAgLy8gb2YgdG9wIG9mIHRoZSBvbmVzIHdpdGggYSBsb3dlciBpbmRleC4gTG93ZXN0IHotaW5kZXggbGFiZWxzXG4gICAgLy8gYXJlIGFsc28gZGlzY2FyZGVkIGZpcnN0IHdoZW4gaGlkaW5nIG92ZXJsYXBwaW5nIGxhYmVscy5cbiAgICBsYWJlbHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICB2YXIgc2EgPSBhLiRsYXlvdXQ7XG4gICAgICB2YXIgc2IgPSBiLiRsYXlvdXQ7XG5cbiAgICAgIHJldHVybiBzYS5faWR4ID09PSBzYi5faWR4XG4gICAgICAgID8gc2IuX3NldCAtIHNhLl9zZXRcbiAgICAgICAgOiBzYi5faWR4IC0gc2EuX2lkeDtcbiAgICB9KTtcblxuICAgIHRoaXMudXBkYXRlKGxhYmVscyk7XG5cbiAgICByZXR1cm4gbGFiZWxzO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24obGFiZWxzKSB7XG4gICAgdmFyIGRpcnR5ID0gZmFsc2U7XG4gICAgdmFyIGksIGlsZW4sIGxhYmVsLCBtb2RlbCwgc3RhdGU7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgICBtb2RlbCA9IGxhYmVsLm1vZGVsKCk7XG4gICAgICBzdGF0ZSA9IGxhYmVsLiRsYXlvdXQ7XG4gICAgICBzdGF0ZS5faGlkYWJsZSA9IG1vZGVsICYmIG1vZGVsLmRpc3BsYXkgPT09ICdhdXRvJztcbiAgICAgIHN0YXRlLl92aXNpYmxlID0gbGFiZWwudmlzaWJsZSgpO1xuICAgICAgZGlydHkgfD0gc3RhdGUuX2hpZGFibGU7XG4gICAgfVxuXG4gICAgaWYgKGRpcnR5KSB7XG4gICAgICBjb21wdXRlKGxhYmVscyk7XG4gICAgfVxuICB9LFxuXG4gIGxvb2t1cDogZnVuY3Rpb24obGFiZWxzLCBwb2ludCkge1xuICAgIHZhciBpLCBzdGF0ZTtcblxuICAgIC8vIElNUE9SVEFOVCBJdGVyYXRlIGluIHRoZSByZXZlcnNlIG9yZGVyIHNpbmNlIGl0ZW1zIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgbGlzdCBoYXZlIGFuIGhpZ2hlciB6LWluZGV4LCB0aHVzIHNob3VsZCBiZSBwaWNrZWQgZmlyc3QuXG5cbiAgICBmb3IgKGkgPSBsYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0YXRlID0gbGFiZWxzW2ldLiRsYXlvdXQ7XG5cbiAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5fdmlzaWJsZSAmJiBzdGF0ZS5fYm94LmNvbnRhaW5zKHBvaW50KSkge1xuICAgICAgICByZXR1cm4gbGFiZWxzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIGRyYXc6IGZ1bmN0aW9uKGNoYXJ0LCBsYWJlbHMpIHtcbiAgICB2YXIgaSwgaWxlbiwgbGFiZWwsIHN0YXRlLCBnZW9tZXRyeSwgY2VudGVyO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgc3RhdGUgPSBsYWJlbC4kbGF5b3V0O1xuXG4gICAgICBpZiAoc3RhdGUuX3Zpc2libGUpIHtcbiAgICAgICAgZ2VvbWV0cnkgPSBsYWJlbC5nZW9tZXRyeSgpO1xuICAgICAgICBjZW50ZXIgPSBjb29yZGluYXRlcyhsYWJlbC5fZWwsIGxhYmVsLm1vZGVsKCksIGdlb21ldHJ5KTtcbiAgICAgICAgc3RhdGUuX2JveC51cGRhdGUoY2VudGVyLCBnZW9tZXRyeSwgbGFiZWwucm90YXRpb24oKSk7XG4gICAgICAgIGxhYmVsLmRyYXcoY2hhcnQsIGNlbnRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgZm9ybWF0dGVyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKGhlbHBlcnMuaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsYWJlbCA9IHZhbHVlO1xuICB2YXIga2V5cywga2xlbiwgaztcbiAgaWYgKGhlbHBlcnMuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgaWYgKCFoZWxwZXJzLmlzTnVsbE9yVW5kZWYodmFsdWUubGFiZWwpKSB7XG4gICAgICBsYWJlbCA9IHZhbHVlLmxhYmVsO1xuICAgIH0gZWxzZSBpZiAoIWhlbHBlcnMuaXNOdWxsT3JVbmRlZih2YWx1ZS5yKSkge1xuICAgICAgbGFiZWwgPSB2YWx1ZS5yO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYWJlbCA9ICcnO1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgIGZvciAoayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuICAgICAgICBsYWJlbCArPSAoayAhPT0gMCA/ICcsICcgOiAnJykgKyBrZXlzW2tdICsgJzogJyArIHZhbHVlW2tleXNba11dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJyArIGxhYmVsO1xufTtcblxuLyoqXG4gKiBJTVBPUlRBTlQ6IG1ha2Ugc3VyZSB0byBhbHNvIHVwZGF0ZSB0ZXN0cyBhbmQgVHlwZVNjcmlwdCBkZWZpbml0aW9uXG4gKiBmaWxlcyAoYC90ZXN0L3NwZWNzL2RlZmF1bHRzLnNwZWMuanNgIGFuZCBgL3R5cGVzL29wdGlvbnMuZC50c2ApXG4gKi9cblxudmFyIGRlZmF1bHRzID0ge1xuICBhbGlnbjogJ2NlbnRlcicsXG4gIGFuY2hvcjogJ2NlbnRlcicsXG4gIGJhY2tncm91bmRDb2xvcjogbnVsbCxcbiAgYm9yZGVyQ29sb3I6IG51bGwsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgYm9yZGVyV2lkdGg6IDAsXG4gIGNsYW1wOiBmYWxzZSxcbiAgY2xpcDogZmFsc2UsXG4gIGNvbG9yOiB1bmRlZmluZWQsXG4gIGRpc3BsYXk6IHRydWUsXG4gIGZvbnQ6IHtcbiAgICBmYW1pbHk6IHVuZGVmaW5lZCxcbiAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgIHN0eWxlOiB1bmRlZmluZWQsXG4gICAgd2VpZ2h0OiBudWxsXG4gIH0sXG4gIGZvcm1hdHRlcjogZm9ybWF0dGVyLFxuICBsYWJlbHM6IHVuZGVmaW5lZCxcbiAgbGlzdGVuZXJzOiB7fSxcbiAgb2Zmc2V0OiA0LFxuICBvcGFjaXR5OiAxLFxuICBwYWRkaW5nOiB7XG4gICAgdG9wOiA0LFxuICAgIHJpZ2h0OiA0LFxuICAgIGJvdHRvbTogNCxcbiAgICBsZWZ0OiA0XG4gIH0sXG4gIHJvdGF0aW9uOiAwLFxuICB0ZXh0QWxpZ246ICdzdGFydCcsXG4gIHRleHRTdHJva2VDb2xvcjogdW5kZWZpbmVkLFxuICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gIHRleHRTaGFkb3dCbHVyOiAwLFxuICB0ZXh0U2hhZG93Q29sb3I6IHVuZGVmaW5lZFxufTtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTc2XG4gKi9cblxudmFyIEVYUEFORE9fS0VZID0gJyRkYXRhbGFiZWxzJztcbnZhciBERUZBVUxUX0tFWSA9ICckZGVmYXVsdCc7XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZShkYXRhc2V0LCBvcHRpb25zKSB7XG4gIHZhciBvdmVycmlkZSA9IGRhdGFzZXQuZGF0YWxhYmVscztcbiAgdmFyIGxpc3RlbmVycyA9IHt9O1xuICB2YXIgY29uZmlncyA9IFtdO1xuICB2YXIgbGFiZWxzLCBrZXlzO1xuXG4gIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHtcbiAgICBvdmVycmlkZSA9IHt9O1xuICB9XG5cbiAgb3B0aW9ucyA9IGhlbHBlcnMubWVyZ2Uoe30sIFtvcHRpb25zLCBvdmVycmlkZV0pO1xuICBsYWJlbHMgPSBvcHRpb25zLmxhYmVscyB8fCB7fTtcbiAga2V5cyA9IE9iamVjdC5rZXlzKGxhYmVscyk7XG4gIGRlbGV0ZSBvcHRpb25zLmxhYmVscztcblxuICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAobGFiZWxzW2tleV0pIHtcbiAgICAgICAgY29uZmlncy5wdXNoKGhlbHBlcnMubWVyZ2Uoe30sIFtcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGxhYmVsc1trZXldLFxuICAgICAgICAgIHtfa2V5OiBrZXl9XG4gICAgICAgIF0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWZhdWx0IGxhYmVsIGlmIG5vIFwibmFtZWRcIiBsYWJlbCBkZWZpbmVkLlxuICAgIGNvbmZpZ3MucHVzaChvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGxpc3RlbmVyczogezxldmVudC10eXBlPjogezxsYWJlbC1rZXk+OiA8Zm4+fX1cbiAgbGlzdGVuZXJzID0gY29uZmlncy5yZWR1Y2UoZnVuY3Rpb24odGFyZ2V0LCBjb25maWcpIHtcbiAgICBoZWxwZXJzLmVhY2goY29uZmlnLmxpc3RlbmVycyB8fCB7fSwgZnVuY3Rpb24oZm4sIGV2ZW50KSB7XG4gICAgICB0YXJnZXRbZXZlbnRdID0gdGFyZ2V0W2V2ZW50XSB8fCB7fTtcbiAgICAgIHRhcmdldFtldmVudF1bY29uZmlnLl9rZXkgfHwgREVGQVVMVF9LRVldID0gZm47XG4gICAgfSk7XG5cbiAgICBkZWxldGUgY29uZmlnLmxpc3RlbmVycztcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIHtcbiAgICBsYWJlbHM6IGNvbmZpZ3MsXG4gICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChjaGFydCwgbGlzdGVuZXJzLCBsYWJlbCwgZXZlbnQpIHtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29udGV4dCA9IGxhYmVsLiRjb250ZXh0O1xuICB2YXIgZ3JvdXBzID0gbGFiZWwuJGdyb3VwcztcbiAgdmFyIGNhbGxiYWNrO1xuXG4gIGlmICghbGlzdGVuZXJzW2dyb3Vwcy5fc2V0XSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbGlzdGVuZXJzW2dyb3Vwcy5fc2V0XVtncm91cHMuX2tleV07XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaGVscGVycy5jYWxsYmFjayhjYWxsYmFjaywgW2NvbnRleHQsIGV2ZW50XSkgPT09IHRydWUpIHtcbiAgICAvLyBVc2VycyBhcmUgYWxsb3dlZCB0byB0d2VhayB0aGUgZ2l2ZW4gY29udGV4dCBieSBpbmplY3RpbmcgdmFsdWVzIHRoYXQgY2FuIGJlXG4gICAgLy8gdXNlZCBpbiBzY3JpcHRhYmxlIG9wdGlvbnMgdG8gZGlzcGxheSBsYWJlbHMgZGlmZmVyZW50bHkgYmFzZWQgb24gdGhlIGN1cnJlbnRcbiAgICAvLyBldmVudCAoZS5nLiBoaWdobGlnaHQgYW4gaG92ZXJlZCBsYWJlbCkuIFRoYXQncyB3aHkgd2UgdXBkYXRlIHRoZSBsYWJlbCB3aXRoXG4gICAgLy8gdGhlIG91dHB1dCBjb250ZXh0IGFuZCBzY2hlZHVsZSBhIG5ldyBjaGFydCByZW5kZXIgYnkgc2V0dGluZyBpdCBkaXJ0eS5cbiAgICBjaGFydFtFWFBBTkRPX0tFWV0uX2RpcnR5ID0gdHJ1ZTtcbiAgICBsYWJlbC51cGRhdGUoY29udGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hNb3ZlRXZlbnRzKGNoYXJ0LCBsaXN0ZW5lcnMsIHByZXZpb3VzLCBsYWJlbCwgZXZlbnQpIHtcbiAgdmFyIGVudGVyLCBsZWF2ZTtcblxuICBpZiAoIXByZXZpb3VzICYmICFsYWJlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghcHJldmlvdXMpIHtcbiAgICBlbnRlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoIWxhYmVsKSB7XG4gICAgbGVhdmUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHByZXZpb3VzICE9PSBsYWJlbCkge1xuICAgIGxlYXZlID0gZW50ZXIgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGxlYXZlKSB7XG4gICAgZGlzcGF0Y2hFdmVudChjaGFydCwgbGlzdGVuZXJzLmxlYXZlLCBwcmV2aW91cywgZXZlbnQpO1xuICB9XG4gIGlmIChlbnRlcikge1xuICAgIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGxpc3RlbmVycy5lbnRlciwgbGFiZWwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNb3ZlRXZlbnRzKGNoYXJ0LCBldmVudCkge1xuICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgdmFyIGxpc3RlbmVycyA9IGV4cGFuZG8uX2xpc3RlbmVycztcbiAgdmFyIHByZXZpb3VzLCBsYWJlbDtcblxuICBpZiAoIWxpc3RlbmVycy5lbnRlciAmJiAhbGlzdGVuZXJzLmxlYXZlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgbGFiZWwgPSBsYXlvdXQubG9va3VwKGV4cGFuZG8uX2xhYmVscywgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgIT09ICdtb3VzZW91dCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcmV2aW91cyA9IGV4cGFuZG8uX2hvdmVyZWQ7XG4gIGV4cGFuZG8uX2hvdmVyZWQgPSBsYWJlbDtcbiAgZGlzcGF0Y2hNb3ZlRXZlbnRzKGNoYXJ0LCBsaXN0ZW5lcnMsIHByZXZpb3VzLCBsYWJlbCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVDbGlja0V2ZW50cyhjaGFydCwgZXZlbnQpIHtcbiAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gIHZhciBoYW5kbGVycyA9IGV4cGFuZG8uX2xpc3RlbmVycy5jbGljaztcbiAgdmFyIGxhYmVsID0gaGFuZGxlcnMgJiYgbGF5b3V0Lmxvb2t1cChleHBhbmRvLl9sYWJlbHMsIGV2ZW50KTtcbiAgaWYgKGxhYmVsKSB7XG4gICAgZGlzcGF0Y2hFdmVudChjaGFydCwgaGFuZGxlcnMsIGxhYmVsLCBldmVudCk7XG4gIH1cbn1cblxudmFyIHBsdWdpbiA9IHtcbiAgaWQ6ICdkYXRhbGFiZWxzJyxcblxuICBkZWZhdWx0czogZGVmYXVsdHMsXG5cbiAgYmVmb3JlSW5pdDogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICBjaGFydFtFWFBBTkRPX0tFWV0gPSB7XG4gICAgICBfYWN0aXZlczogW11cbiAgICB9O1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgICBleHBhbmRvLl9saXN0ZW5lZCA9IGZhbHNlO1xuICAgIGV4cGFuZG8uX2xpc3RlbmVycyA9IHt9OyAgICAgLy8gezxldmVudC10eXBlPjogezxkYXRhc2V0LWluZGV4PjogezxsYWJlbC1rZXk+OiA8Zm4+fX19XG4gICAgZXhwYW5kby5fZGF0YXNldHMgPSBbXTsgICAgICAvLyBwZXIgZGF0YXNldCBsYWJlbHM6IFtMYWJlbFtdXVxuICAgIGV4cGFuZG8uX2xhYmVscyA9IFtdOyAgICAgICAgLy8gbGF5b3V0ZWQgbGFiZWxzOiBMYWJlbFtdXG4gIH0sXG5cbiAgYWZ0ZXJEYXRhc2V0VXBkYXRlOiBmdW5jdGlvbihjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgIHZhciBkYXRhc2V0SW5kZXggPSBhcmdzLmluZGV4O1xuICAgIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICAgIHZhciBsYWJlbHMgPSBleHBhbmRvLl9kYXRhc2V0c1tkYXRhc2V0SW5kZXhdID0gW107XG4gICAgdmFyIHZpc2libGUgPSBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCk7XG4gICAgdmFyIGRhdGFzZXQgPSBjaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgdmFyIGNvbmZpZyA9IGNvbmZpZ3VyZShkYXRhc2V0LCBvcHRpb25zKTtcbiAgICB2YXIgZWxlbWVudHMgPSBhcmdzLm1ldGEuZGF0YSB8fCBbXTtcbiAgICB2YXIgY3R4ID0gY2hhcnQuY3R4O1xuICAgIHZhciBpLCBqLCBpbGVuLCBqbGVuLCBjZmcsIGtleSwgZWwsIGxhYmVsO1xuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGVsID0gZWxlbWVudHNbaV07XG4gICAgICBlbFtFWFBBTkRPX0tFWV0gPSBbXTtcblxuICAgICAgaWYgKHZpc2libGUgJiYgZWwgJiYgY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgJiYgIWVsLnNraXApIHtcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGNvbmZpZy5sYWJlbHMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgY2ZnID0gY29uZmlnLmxhYmVsc1tqXTtcbiAgICAgICAgICBrZXkgPSBjZmcuX2tleTtcblxuICAgICAgICAgIGxhYmVsID0gbmV3IExhYmVsKGNmZywgY3R4LCBlbCwgaSk7XG4gICAgICAgICAgbGFiZWwuJGdyb3VwcyA9IHtcbiAgICAgICAgICAgIF9zZXQ6IGRhdGFzZXRJbmRleCxcbiAgICAgICAgICAgIF9rZXk6IGtleSB8fCBERUZBVUxUX0tFWVxuICAgICAgICAgIH07XG4gICAgICAgICAgbGFiZWwuJGNvbnRleHQgPSB7XG4gICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgY2hhcnQ6IGNoYXJ0LFxuICAgICAgICAgICAgZGF0YUluZGV4OiBpLFxuICAgICAgICAgICAgZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogZGF0YXNldEluZGV4XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGxhYmVsLnVwZGF0ZShsYWJlbC4kY29udGV4dCk7XG4gICAgICAgICAgZWxbRVhQQU5ET19LRVldLnB1c2gobGFiZWwpO1xuICAgICAgICAgIGxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAvLyBTdG9yZSBsaXN0ZW5lcnMgYXQgdGhlIGNoYXJ0IGxldmVsIGFuZCBwZXIgZXZlbnQgdHlwZSB0byBvcHRpbWl6ZVxuICAgIC8vIGNhc2VzIHdoZXJlIG5vIGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZCBmb3IgYSBzcGVjaWZpYyBldmVudC5cbiAgICBoZWxwZXJzLm1lcmdlKGV4cGFuZG8uX2xpc3RlbmVycywgY29uZmlnLmxpc3RlbmVycywge1xuICAgICAgbWVyZ2VyOiBmdW5jdGlvbihldmVudCwgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgdGFyZ2V0W2V2ZW50XSA9IHRhcmdldFtldmVudF0gfHwge307XG4gICAgICAgIHRhcmdldFtldmVudF1bYXJncy5pbmRleF0gPSBzb3VyY2VbZXZlbnRdO1xuICAgICAgICBleHBhbmRvLl9saXN0ZW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgY2hhcnRbRVhQQU5ET19LRVldLl9sYWJlbHMgPSBsYXlvdXQucHJlcGFyZShjaGFydFtFWFBBTkRPX0tFWV0uX2RhdGFzZXRzKTtcbiAgfSxcblxuICAvLyBEcmF3IGxhYmVscyBvbiB0b3Agb2YgYWxsIGRhdGFzZXQgZWxlbWVudHNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvMjlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvMzJcbiAgYWZ0ZXJEYXRhc2V0c0RyYXc6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgbGF5b3V0LmRyYXcoY2hhcnQsIGNoYXJ0W0VYUEFORE9fS0VZXS5fbGFiZWxzKTtcbiAgfSxcblxuICBiZWZvcmVFdmVudDogZnVuY3Rpb24oY2hhcnQsIGFyZ3MpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBsaXN0ZW5lciByZWdpc3RlcmVkIGZvciB0aGlzIGNoYXJ0LCBgbGlzdGVuZWRgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gbWVhbmluZyB3ZSBjYW4gaW1tZWRpYXRlbHkgaWdub3JlIHRoZSBpbmNvbWluZyBldmVudCBhbmQgYXZvaWQgdXNlbGVzcyBleHRyYVxuICAgIC8vIGNvbXB1dGF0aW9uIGZvciB1c2VycyB3aG8gZG9uJ3QgaW1wbGVtZW50IGxhYmVsIGludGVyYWN0aW9ucy5cbiAgICBpZiAoY2hhcnRbRVhQQU5ET19LRVldLl9saXN0ZW5lZCkge1xuICAgICAgdmFyIGV2ZW50ID0gYXJncy5ldmVudDtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAgaGFuZGxlTW92ZUV2ZW50cyhjaGFydCwgZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgaGFuZGxlQ2xpY2tFdmVudHMoY2hhcnQsIGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGFmdGVyRXZlbnQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gICAgdmFyIHByZXZpb3VzID0gZXhwYW5kby5fYWN0aXZlcztcbiAgICB2YXIgYWN0aXZlcyA9IGV4cGFuZG8uX2FjdGl2ZXMgPSBjaGFydC5nZXRBY3RpdmVFbGVtZW50cygpO1xuICAgIHZhciB1cGRhdGVzID0gdXRpbHMuYXJyYXlEaWZmKHByZXZpb3VzLCBhY3RpdmVzKTtcbiAgICB2YXIgaSwgaWxlbiwgaiwgamxlbiwgdXBkYXRlLCBsYWJlbCwgbGFiZWxzO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHVwZGF0ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2ldO1xuICAgICAgaWYgKHVwZGF0ZVsxXSkge1xuICAgICAgICBsYWJlbHMgPSB1cGRhdGVbMF0uZWxlbWVudFtFWFBBTkRPX0tFWV0gfHwgW107XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbHMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbGFiZWwgPSBsYWJlbHNbal07XG4gICAgICAgICAgbGFiZWwuJGNvbnRleHQuYWN0aXZlID0gKHVwZGF0ZVsxXSA9PT0gMSk7XG4gICAgICAgICAgbGFiZWwudXBkYXRlKGxhYmVsLiRjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHBhbmRvLl9kaXJ0eSB8fCB1cGRhdGVzLmxlbmd0aCkge1xuICAgICAgbGF5b3V0LnVwZGF0ZShleHBhbmRvLl9sYWJlbHMpO1xuICAgICAgY2hhcnQucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIGV4cGFuZG8uX2RpcnR5O1xuICB9XG59O1xuXG5yZXR1cm4gcGx1Z2luO1xuXG59KSk7XG4iLCAiLy8gV2UgaW1wb3J0IHRoZSBDU1Mgd2hpY2ggaXMgZXh0cmFjdGVkIHRvIGl0cyBvd24gZmlsZSBieSBlc2J1aWxkLlxyXG4vLyBSZW1vdmUgdGhpcyBsaW5lIGlmIHlvdSBhZGQgYSB5b3VyIG93biBDU1MgYnVpbGQgcGlwZWxpbmUgKGUuZyBwb3N0Y3NzKS5cclxuaW1wb3J0IFwiLi4vY3NzL2FwcC5jc3NcIjtcclxuXHJcbmltcG9ydCBcIi4vQm9hcmRDb250cm9sZS5qc1wiO1xyXG5cclxuaW1wb3J0ICd0b20tc2VsZWN0J1xyXG5pbXBvcnQgeyBhZGRSb3csIGhhdmVMaW5lTm90U2F2ZWQgfSBmcm9tIFwiLi90b21fc2VsZWN0X3NhaXNpZV9wYWdlLmpzXCI7XHJcbmltcG9ydCBUb21TZWxlY3QgZnJvbSBcInRvbS1zZWxlY3RcIjtcclxuXHJcblxyXG5cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAvLyBWXHUwMEU5cmlmaWVyIHNpIGxlcyBcdTAwRTlsXHUwMEU5bWVudHMgZXhpc3RlbnQgc3VyIGxhIHBhZ2VcclxuICBjb25zdCB0YWJsZUJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVjb3JkLXRhYmxlLWJvZHknKTtcclxuICBjb25zdCBhZGRSb3dMaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZFJvd0ljb24nKTtcclxuICBjb25zdCBkYXRhQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RhdGEtY29udGFpbmVyJyk7XHJcblxyXG4gIC8vIFZcdTAwRTlyaWZpZXIgc2kgbGVzIFx1MDBFOWxcdTAwRTltZW50cyBuXHUwMEU5Y2Vzc2FpcmVzIGV4aXN0ZW50XHJcbiAgaWYgKHRhYmxlQm9keSAmJiBhZGRSb3dMaW5rICYmIGRhdGFDb250YWluZXIpIHtcclxuICAgIC8vIFJcdTAwRTljdXBcdTAwRTlyZXIgbGVzIGRvbm5cdTAwRTllcyB1bmlxdWVtZW50IHNpIGxlcyBcdTAwRTlsXHUwMEU5bWVudHMgZXhpc3RlbnRcclxuICAgIGNvbnN0IHVzZXJJZCA9IGRhdGFDb250YWluZXIuZGF0YXNldC51c2VySWQ7XHJcbiAgICAvL2NvbnNvbGUubG9nKHVzZXJJZClcclxuICAgIGNvbnN0IGRhdGUgPSBkYXRhQ29udGFpbmVyLmRhdGFzZXQudG9kYXk7XHJcbiAgICAvL2NvbnNvbGUubG9nKGRhdGUpXHJcbiAgICBjb25zdCB1c2VybmFtZSA9IGRhdGFDb250YWluZXIuZGF0YXNldC51c2VybmFtZTtcclxuICAgIC8vY29uc29sZS5sb2codXNlcm5hbWUpXHJcbiAgICAvL2NvbnNvbGUubG9nKGRhdGFDb250YWluZXIuZGF0YXNldC5wcm9qZWN0cylcclxuICAgIGNvbnN0IHByb2plY3RzID0gSlNPTi5wYXJzZShkYXRhQ29udGFpbmVyLmRhdGFzZXQucHJvamVjdHMpO1xyXG4gICAgLy9jb25zb2xlLmxvZyhwcm9qZWN0cylcclxuXHJcbiAgICAvLyBBam91dGVyIHVuIFx1MDBFOWNvdXRldXIgZCdcdTAwRTl2XHUwMEU5bmVtZW50cyB1bmlxdWVtZW50IHNpIGwnaWNcdTAwRjRuZSBkJ2Fqb3V0IGRlIGxpZ25lIGV4aXN0ZVxyXG4gICAgYWRkUm93TGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICBcclxuICAgICAgbGluZU5vdFNhdmVkID0gaGF2ZUxpbmVOb3RTYXZlZCh0YWJsZUJvZHkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhsaW5lTm90U2F2ZWQpO1xyXG4gICAgICBpZiAoIWxpbmVOb3RTYXZlZCkge1xyXG4gICAgICAgIGFkZFJvdyh0YWJsZUJvZHksIFRvbVNlbGVjdCwgdXNlcklkLCBkYXRlLCB1c2VybmFtZSwgcHJvamVjdHMpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2V7XHJcbiAgICAgICBcclxuICAgICAgICB2YXIgYWRkUm93SWNvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhZGRSb3dJY29uIGknKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhhZGRSb3dJY29uKTtcclxuICAgICAgICBhZGRSb3dMaW5rLmNsYXNzTGlzdC5hZGQoJ25vbi1jbGlxdWFibGUnKTtcclxuICAgICAgICBhZGRSb3dJY29uLnN0eWxlLmN1cnNvciA9ICdub3QtYWxsb3dlZCc7XHJcbiAgICAgICAgXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuIFxyXG4gXHJcbn0pO1xyXG5cclxuXHJcblxyXG4vKlxyXG52YXIgdGVzdCA9XHJcblxyXG5cclxuXHJcblxyXG5cclxuICBuZXcgVG9tU2VsZWN0KCcjc2VsZWN0LXBlcnNvbicpO1xyXG5cclxuXHJcblxyXG5cclxuY29uc29sZS5sb2codGVzdCk7XHJcbiovXHJcblxyXG5cclxuLy9pbXBvcnQgXCIuL3RhYmxlX3NhaXNpZV90ZW1wX2NvbnRyb2xlLmpzXCJcclxuXHJcbi8vIElmIHlvdSB3YW50IHRvIHVzZSBQaG9lbml4IGNoYW5uZWxzLCBydW4gYG1peCBoZWxwIHBoeC5nZW4uY2hhbm5lbGBcclxuLy8gdG8gZ2V0IHN0YXJ0ZWQgYW5kIHRoZW4gdW5jb21tZW50IHRoZSBsaW5lIGJlbG93LlxyXG4vLyBpbXBvcnQgXCIuL3VzZXJfc29ja2V0LmpzXCJcclxuXHJcbi8vIFlvdSBjYW4gaW5jbHVkZSBkZXBlbmRlbmNpZXMgaW4gdHdvIHdheXMuXHJcbi8vXHJcbi8vIFRoZSBzaW1wbGVzdCBvcHRpb24gaXMgdG8gcHV0IHRoZW0gaW4gYXNzZXRzL3ZlbmRvciBhbmRcclxuLy8gaW1wb3J0IHRoZW0gdXNpbmcgcmVsYXRpdmUgcGF0aHM6XHJcbi8vXHJcbi8vICAgICBpbXBvcnQgXCIuLi92ZW5kb3Ivc29tZS1wYWNrYWdlLmpzXCJcclxuLy9cclxuLy8gQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBgbnBtIGluc3RhbGwgc29tZS1wYWNrYWdlIC0tcHJlZml4IGFzc2V0c2AgYW5kIGltcG9ydFxyXG4vLyB0aGVtIHVzaW5nIGEgcGF0aCBzdGFydGluZyB3aXRoIHRoZSBwYWNrYWdlIG5hbWU6XHJcbi8vXHJcbi8vICAgICBpbXBvcnQgXCJzb21lLXBhY2thZ2VcIlxyXG4vL1xyXG5cclxucmVxdWlyZShcImJvb3RzdHJhcC1pY29ucy9mb250L2Jvb3RzdHJhcC1pY29ucy5jc3NcIik7XHJcbnJlcXVpcmUoXCJtYXRlcmlhbC1pY29ucy9pY29uZm9udC9tYXRlcmlhbC1pY29ucy5jc3NcIik7XHJcblxyXG4vLyBpbXBvcnQgJ2Jvb3RzdHJhcC1pY29ucy9mb250L2Jvb3RzdHJhcC1pY29ucy5jc3MnO1xyXG4vLyBpbXBvcnQgJ21hdGVyaWFsLWljb25zL2ljb25mb250L21hdGVyaWFsLWljb25zLmNzcyc7XHJcblxyXG4vLyBJbmNsdWRlIHBob2VuaXhfaHRtbCB0byBoYW5kbGUgbWV0aG9kPVBVVC9ERUxFVEUgaW4gZm9ybXMgYW5kIGJ1dHRvbnMuXHJcbmltcG9ydCBcInBob2VuaXhfaHRtbFwiO1xyXG4vLyBFc3RhYmxpc2ggUGhvZW5peCBTb2NrZXQgYW5kIExpdmVWaWV3IGNvbmZpZ3VyYXRpb24uXHJcbmltcG9ydCB7IFNvY2tldCB9IGZyb20gXCJwaG9lbml4XCI7XHJcbmltcG9ydCB7IExpdmVTb2NrZXQgfSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIjtcclxuaW1wb3J0IHsgU29ydGFibGUsIFBsdWdpbnMgfSBmcm9tIFwiQHNob3BpZnkvZHJhZ2dhYmxlXCI7XHJcbmltcG9ydCB0b3BiYXIgZnJvbSBcIi4uL3ZlbmRvci90b3BiYXJcIjtcclxuaW1wb3J0IHtcclxuICBEb3VnaE51dENoYXJ0LFxyXG4gIEhvcml6b250YWxCYXJDaGFydCxcclxuICBTdGFja2VkQmFyQ2hhcnQsXHJcbiAgTGluZUNoYXJ0LFxyXG4gIFN1cnZleUNoYXJ0XHJcbn0gZnJvbSBcIi4vY2hhcnQuanNcIjtcclxuaW1wb3J0IGNoYXJ0IGZyb20gXCJjaGFydC5qcy9kaXN0L2NoYXJ0XCI7XHJcblxyXG5cclxuY29uc3QgSG9va3MgPSB7fTtcclxuXHJcbi8vIEhvb2tzLkRvdWdoTnV0Q2hhcnQgPSB7XHJcbi8vICAgbW91bnRlZCgpIHtcclxuLy8gICAgIGNvbnN0IHsgbGFiZWxzX3Rhc2tzX2J5X2NvbnRyaWJ1dG9ycywgdmFsdWVzX3Rhc2tzX2J5X2NvbnRyaWJ1dG9ycyB9ID0gSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQuY2hhcnREYXRhKVxyXG4vLyAgICAgdGhpcy5jaGFydCA9IG5ldyBEb3VnaE51dENoYXJ0KHRoaXMuZWwsIGxhYmVsc190YXNrc19ieV9jb250cmlidXRvcnMsIHZhbHVlc190YXNrc19ieV9jb250cmlidXRvcnMpXHJcbi8vICAgfVxyXG4vLyB9XHJcblxyXG5cclxuXHJcblxyXG4vKiBob29rcyBwaG9lbml4IHBvdXIgbGVzIGNoYW5nZW1lbnQgY291bGV1ciBkZXMgbGlnbmVzIHN1cnZvbFx1MDBFOVxyXG5tZXR0cmUgY2V0dGUgaG9va3MgZW4gYXR0cmlidXQgZHUgYmFsaXNlIDx0YWJsZT48L3RhYmxlPiBzaSBsZSB0YWJsZSBhIGJlc29pbiBkZSBjZXR0ZSBmb25jdGlvbmFsaXRcdTAwRTlcclxuTkIgOiBhIG1ldHRyZSB1bmlxdWVtZW50IHN1ciB1bmUgZWxlbWVudCBodG1sIHRhYmxlXHJcblxyXG4qL1xyXG5cclxuSG9va3MudGFibGVIb3ZlciA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgY29uc3QgdGFibGUgPSB0aGlzLmVsOyAvLyBSXHUwMEU5Y3VwXHUwMEU5cmVyIGxhIHRhYmxlIFx1MDBFMCBwYXJ0aXIgZGUgdGhpcy5lbFxyXG5cclxuICAgIHRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3Rib2R5IHRyJykuZm9yRWFjaChyb3cgPT4ge1xyXG4gICAgICBsZXQgY3VycmVudENvbG9yID0gJyc7XHJcblxyXG4gICAgICByb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgKCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRDb2xvciA9IHJvdy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgcm93LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjNjBiMGYwJztcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCAoKSA9PiB7XHJcbiAgICAgICAgcm93LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGN1cnJlbnRDb2xvcjtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcblxyXG5Ib29rcy5DdXN0b21TYW1wbGVTZWxlY3QgPSB7XHJcbiAgbW91bnRlZCgpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiQ3VzdG9tU2FtcGxlU2VsZWN0IGhvb2sgaW5pdGlhbGl6ZWRcIik7XHJcblxyXG4gICAgLy8gUlx1MDBFOWN1cFx1MDBFOXJlciBsJ1x1MDBFOWxcdTAwRTltZW50IHNlbGVjdFxyXG4gICAgdmFyIHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15U2VsZWN0XCIpO1xyXG5cclxuICAgIC8vIEFzc3VyZXotdm91cyBxdWUgbCdcdTAwRTlsXHUwMEU5bWVudCBzZWxlY3QgZXN0IHJlbmR1IGRhbnMgbGUgRE9NXHJcbiAgICBpZiAoc2VsZWN0RWxlbWVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkVsZW1lbnQgZm91bmQ6XCIsIHNlbGVjdEVsZW1lbnQpO1xyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZXogVG9tU2VsZWN0IGF2ZWMgbCdcdTAwRTlsXHUwMEU5bWVudCBzZWxlY3QgcydpbCBuJ2V4aXN0ZSBwYXMgZFx1MDBFOWpcdTAwRTAgZCdpbnN0YW5jZVxyXG4gICAgICBpZiAoIXNlbGVjdEVsZW1lbnQudG9tc2VsZWN0KSB7XHJcbiAgICAgICAgc2VsZWN0RWxlbWVudC50b21zZWxlY3QgPSBuZXcgVG9tU2VsZWN0KHNlbGVjdEVsZW1lbnQsIHtcclxuICAgICAgICAgIC8vIENvbmZpZ3VyYXRpb25zIGRlIFRvbVNlbGVjdCBpY2lcclxuICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXHJcbiAgICAgICAgICBzb3J0RmllbGQ6IHtcclxuICAgICAgICAgICAgZmllbGQ6IFwidGV4dFwiLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiYXNjXCJcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlRvbVNlbGVjdCBvcHRpb25zOlwiLCBzZWxlY3RFbGVtZW50LnRvbXNlbGVjdC5vcHRpb25zKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlNlbGVjdCBlbGVtZW50IG5vdCBmb3VuZFwiKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHVwZGF0ZWQoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkN1c3RvbVNhbXBsZVNlbGVjdCBob29rIHVwZGF0ZWRcIik7XHJcblxyXG4gICAgLy8gUlx1MDBFOWN1cFx1MDBFOXJlciBsJ1x1MDBFOWxcdTAwRTltZW50IHNlbGVjdFxyXG4gICAgdmFyIHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15U2VsZWN0XCIpO1xyXG5cclxuICAgIC8vIFZcdTAwRTlyaWZpZXogc2kgdW5lIGluc3RhbmNlIGRlIFRvbVNlbGVjdCBlc3QgYXR0YWNoXHUwMEU5ZSBcdTAwRTAgbCdcdTAwRTlsXHUwMEU5bWVudCBzZWxlY3RcclxuICAgIGlmIChzZWxlY3RFbGVtZW50ICYmIHNlbGVjdEVsZW1lbnQudG9tc2VsZWN0KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiRWxlbWVudCBmb3VuZDpcIiwgc2VsZWN0RWxlbWVudCk7XHJcblxyXG4gICAgICAvLyBTdXBwcmltZXogdG91dGVzIGxlcyBvcHRpb25zIGFjdHVlbGxlcyBkZSBUb21TZWxlY3RcclxuICAgICAgc2VsZWN0RWxlbWVudC50b21zZWxlY3QuY2xlYXJPcHRpb25zKCk7XHJcblxyXG4gICAgICAvLyBBam91dGV6IGRlIG5vdXZlbGxlcyBvcHRpb25zIFx1MDBFMCBUb21TZWxlY3QgXHUwMEUwIHBhcnRpciBkZSBsJ1x1MDBFOWxcdTAwRTltZW50IHNlbGVjdFxyXG4gICAgICB2YXIgc2VsZWN0T3B0aW9ucyA9IHNlbGVjdEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIm9wdGlvblwiKTtcclxuICAgICAgc2VsZWN0T3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICBzZWxlY3RFbGVtZW50LnRvbXNlbGVjdC5hZGRPcHRpb24oe1xyXG4gICAgICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcclxuICAgICAgICAgIHRleHQ6IG9wdGlvbi50ZXh0Q29udGVudFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEFjdHVhbGlzZXogbGUgVG9tU2VsZWN0IHBvdXIgcmVmbFx1MDBFOXRlciBsZXMgbW9kaWZpY2F0aW9uc1xyXG4gICAgICBzZWxlY3RFbGVtZW50LnRvbXNlbGVjdC5yZWZyZXNoT3B0aW9ucygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlNlbGVjdCBlbGVtZW50IG9yIFRvbVNlbGVjdCBpbnN0YW5jZSBub3QgZm91bmRcIik7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5Ib29rcy5Dc3ZFeHBvcnRIb29rID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICB0aGlzLmhhbmRsZUV4cG9ydENsaWNrID0gdGhpcy5oYW5kbGVFeHBvcnRDbGljay5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVFeHBvcnRDbGljayk7XHJcbiAgfSxcclxuICBkZXN0cm95ZWQoKSB7XHJcbiAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmhhbmRsZUV4cG9ydENsaWNrKTtcclxuICB9LFxyXG5cclxuIFxyXG5cclxuXHJcbiAgaGFuZGxlRXhwb3J0Q2xpY2soZXZlbnQpIHtcclxuXHJcbiAgXHJcblxyXG4gIFxyXG5cclxuICAgIGxldCBjc3ZEYXRhID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNzdlwiKTtcclxuICAgIGNvbnNvbGUubG9nKFwiYXZhbnQgOlwiICxjc3ZEYXRhKVxyXG4gICAgY3N2RGF0YSA9IGNzdkRhdGEucmVwbGFjZSgvXFxcXHJcXFxcbi9nLCAnXFxuJylcclxuICAgIC8vbGV0IHRlc3QgPSBcIk5hbWUsQWdlLENpdHlcXG5Kb2huLDMwLE5ldyBZb3JrXFxuSmFuZSwyNSxTYW4gRnJhbmNpc2NvXFxuQm9iLDM1LENoaWNhZ29cIjtcclxuICAgIGNvbnNvbGUubG9nIChcImFwcmVzIDpcIiAsY3N2RGF0YSlcclxuICAgIC8vIENyXHUwMEU5ZXIgdW4gb2JqZXQgQmxvYiBcdTAwRTAgcGFydGlyIGRlIGxhIGNoYVx1MDBFRW5lIENTVlxyXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtjc3ZEYXRhXSwgeyB0eXBlOiAndGV4dC9jc3Y7Y2hhcnNldD11dGYtODsnIH0pO1xyXG5cclxuICAgIC8vIENyXHUwMEU5ZXIgdW4gXHUwMEU5bFx1MDBFOW1lbnQgPGE+IHBvdXIgdFx1MDBFOWxcdTAwRTljaGFyZ2VyIGxlIGZpY2hpZXIgQ1NWXHJcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgbGluay5ocmVmID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICBsaW5rLmRvd25sb2FkID0gJ2V4ZW1wbGUuY3N2JztcclxuXHJcbiAgICAvLyBBam91dGVyIGwnXHUwMEU5bFx1MDBFOW1lbnQgPGE+IFx1MDBFMCBsYSBwYWdlXHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xyXG5cclxuICAgIC8vIFNpbXVsZXIgdW4gY2xpYyBzdXIgbGUgbGllbiBwb3VyIGRcdTAwRTljbGVuY2hlciBsZSB0XHUwMEU5bFx1MDBFOWNoYXJnZW1lbnRcclxuICAgIGxpbmsuY2xpY2soKTtcclxuXHJcbiAgICAvLyBTdXBwcmltZXIgbCdcdTAwRTlsXHUwMEU5bWVudCA8YT4gYXByXHUwMEU4cyBsZSB0XHUwMEU5bFx1MDBFOWNoYXJnZW1lbnRcclxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XHJcblxyXG4gICAgLy8gLi4uIEF1dHJlcyBhY3Rpb25zIFx1MDBFMCBlZmZlY3R1ZXIgYXZlYyBjc3ZEYXRhIC4uLlxyXG4gIH0sXHJcblxyXG5cclxufTtcclxuXHJcbkhvb2tzLkhvcml6b250YWxCYXJDaGFydCA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgY29uc3QgeyBsYWJlbHNfdGFza3NfYnlfY29udHJpYnV0b3JzLCB2YWx1ZXNfdGFza3NfYnlfY29udHJpYnV0b3JzIH0gPVxyXG4gICAgICBKU09OLnBhcnNlKHRoaXMuZWwuZGF0YXNldC5jaGFydERhdGEpO1xyXG4gICAgdGhpcy5jaGFydCA9IG5ldyBIb3Jpem9udGFsQmFyQ2hhcnQoXHJcbiAgICAgIHRoaXMuZWwsXHJcbiAgICAgIGxhYmVsc190YXNrc19ieV9jb250cmlidXRvcnMsXHJcbiAgICAgIHZhbHVlc190YXNrc19ieV9jb250cmlidXRvcnNcclxuICAgICk7XHJcbiAgfSxcclxufTtcclxuXHJcbkhvb2tzLlN0YWNrZWRCYXJDaGFydCA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB2YWx1ZXNfdGFza3NfdG9kb19ieV9tb250aCxcclxuICAgICAgdmFsdWVzX2Jsb2NraW5nX3Rhc2tzX2J5X21vbnRoLFxyXG4gICAgICB2YWx1ZXNfdGFza3NfaW5fcHJvZ3Jlc3NfYnlfbW9udGgsXHJcbiAgICAgIHZhbHVlc190YXNrc19pbl9jb250cm9sX2J5X21vbnRoLFxyXG4gICAgICB2YWx1ZXNfdGFza3NfYWNoaWV2ZWRfYnlfbW9udGgsXHJcbiAgICB9ID0gSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQuY2hhcnREYXRhKTtcclxuICAgIHRoaXMuY2hhcnQgPSBuZXcgU3RhY2tlZEJhckNoYXJ0KFxyXG4gICAgICB0aGlzLmVsLFxyXG4gICAgICB2YWx1ZXNfdGFza3NfdG9kb19ieV9tb250aCxcclxuICAgICAgdmFsdWVzX2Jsb2NraW5nX3Rhc2tzX2J5X21vbnRoLFxyXG4gICAgICB2YWx1ZXNfdGFza3NfaW5fcHJvZ3Jlc3NfYnlfbW9udGgsXHJcbiAgICAgIHZhbHVlc190YXNrc19pbl9jb250cm9sX2J5X21vbnRoLFxyXG4gICAgICB2YWx1ZXNfdGFza3NfYWNoaWV2ZWRfYnlfbW9udGhcclxuICAgICk7XHJcbiAgfSxcclxufTtcclxuXHJcblxyXG5Ib29rcy5TdXJ2ZXlDaGFydCA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgY29uc29sZS5sb2coXCJpcyBtb3VudGVkXCIpO1xyXG5cclxuICAgIGNvbnN0IHsgdmFsdWVzIH0gPSBKU09OLnBhcnNlKHRoaXMuZWwuZGF0YXNldC5jaGFydERhdGEpO1xyXG5cclxuICAgIHRoaXMubXljaGFydCA9IG5ldyBTdXJ2ZXlDaGFydCh0aGlzLmVsLCB2YWx1ZXMpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEhvb2tzLkxpbmVDaGFydCA9IHtcclxuLy8gICBtb3VudGVkKCkge1xyXG4vLyAgICAgY29uc3QgeyB2YWx1ZXNfdGFza3NfdG9kb19ieV9tb250aCwgdmFsdWVzX2Jsb2NraW5nX3Rhc2tzX2J5X21vbnRoLCB2YWx1ZXNfdGFza3NfaW5fcHJvZ3Jlc3NfYnlfbW9udGgsIHZhbHVlc190YXNrc19pbl9jb250cm9sX2J5X21vbnRoLCB2YWx1ZXNfdGFza3NfYWNoaWV2ZWRfYnlfbW9udGggfSA9IEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LmNoYXJ0RGF0YSlcclxuLy8gICAgIHRoaXMuY2hhcnQgPSBuZXcgTGluZUNoYXJ0KHRoaXMuZWwsIHZhbHVlc190YXNrc190b2RvX2J5X21vbnRoLCB2YWx1ZXNfYmxvY2tpbmdfdGFza3NfYnlfbW9udGgsIHZhbHVlc190YXNrc19pbl9wcm9ncmVzc19ieV9tb250aCwgdmFsdWVzX3Rhc2tzX2luX2NvbnRyb2xfYnlfbW9udGgsIHZhbHVlc190YXNrc19hY2hpZXZlZF9ieV9tb250aClcclxuLy8gICB9XHJcbi8vIH1cclxuXHJcbkhvb2tzLkJvYXJkID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICB0aGlzLmluaXREcmFnZ2FibGVzKCk7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlZCgpIHtcclxuICAgIHRoaXMuc29ydGFibGVDYXJkLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuc29ydGFibGVTdGFnZS5kZXN0cm95KCk7XHJcbiAgICB0aGlzLmluaXREcmFnZ2FibGVzKCk7XHJcbiAgfSxcclxuXHJcbiAgaW5pdERyYWdnYWJsZXMoKSB7XHJcbiAgICB0aGlzLnNvcnRhYmxlQ2FyZCA9IG5ldyBTb3J0YWJsZShcclxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5zdGFnZV9fY2FyZHNcIiksXHJcbiAgICAgIHtcclxuICAgICAgICBkcmFnZ2FibGU6IFwiLmNhcmRcIixcclxuICAgICAgICBtaXJyb3I6IHtcclxuICAgICAgICAgIGNvbnN0cmFpbkRpbWVuc2lvbnM6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzd2FwQW5pbWF0aW9uOiB7XHJcbiAgICAgICAgICBkdXJhdGlvbjogMjAwLFxyXG4gICAgICAgICAgZWFzaW5nRnVuY3Rpb246IFwiZWFzZS1pbi1vdXRcIixcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBsdWdpbnM6IFtQbHVnaW5zLlN3YXBBbmltYXRpb25dLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuc29ydGFibGVDYXJkLm9uKFwic29ydGFibGU6c3RvcFwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgY29uc3Qgc291cmNlID0gZXZlbnQuZGF0YS5kcmFnRXZlbnQuZGF0YS5zb3VyY2U7XHJcbiAgICAgIGNvbnN0IGNhcmRJZCA9IHBhcnNlSW50KHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNhcmQtaWRcIikpO1xyXG4gICAgICBjb25zdCBuZXdTdGFnZUlkID0gcGFyc2VJbnQoXHJcbiAgICAgICAgZXZlbnQuZGF0YS5uZXdDb250YWluZXIuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdGFnZS1pZFwiKVxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBuZXdJbmRleCA9IHBhcnNlSW50KGV2ZW50LmRhdGEubmV3SW5kZXgpO1xyXG4gICAgICBjb25zdCBjYXJkUGF5bG9hZCA9IHtcclxuICAgICAgICBjYXJkOiB7XHJcbiAgICAgICAgICBpZDogY2FyZElkLFxyXG4gICAgICAgICAgc3RhZ2VfaWQ6IG5ld1N0YWdlSWQsXHJcbiAgICAgICAgICBwb3NpdGlvbjogbmV3SW5kZXgsXHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5wdXNoRXZlbnQoXCJ1cGRhdGVfY2FyZFwiLCBjYXJkUGF5bG9hZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnNvcnRhYmxlU3RhZ2UgPSBuZXcgU29ydGFibGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ib2FyZFwiKSwge1xyXG4gICAgICBkcmFnZ2FibGU6IFwiLnN0YWdlXCIsXHJcbiAgICAgIGhhbmRsZTogXCIuZHJhZ2dhYmxlLWhhbmRsZVwiLFxyXG4gICAgICBtaXJyb3I6IHtcclxuICAgICAgICBjb25zdHJhaW5EaW1lbnNpb25zOiB0cnVlLFxyXG4gICAgICAgIHlBeGlzOiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc29ydGFibGVTdGFnZS5vbihcInNvcnRhYmxlOnN0b3BcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGV2ZW50LmRhdGEuZHJhZ0V2ZW50LmRhdGEuc291cmNlO1xyXG4gICAgICBjb25zdCBzdGFnZUlkID0gcGFyc2VJbnQoc291cmNlLmdldEF0dHJpYnV0ZShcImRhdGEtc3RhZ2UtaWRcIikpO1xyXG4gICAgICBjb25zdCBuZXdJbmRleCA9IHBhcnNlSW50KGV2ZW50LmRhdGEubmV3SW5kZXgpO1xyXG4gICAgICBjb25zdCBzdGFnZVBheWxvYWQgPSB7XHJcbiAgICAgICAgc3RhZ2U6IHtcclxuICAgICAgICAgIGlkOiBzdGFnZUlkLFxyXG4gICAgICAgICAgcG9zaXRpb246IG5ld0luZGV4LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMucHVzaEV2ZW50KFwidXBkYXRlX3N0YWdlXCIsIHN0YWdlUGF5bG9hZCk7XHJcbiAgICB9KTtcclxuICB9LFxyXG59O1xyXG5cclxuSG9va3MuQW5pbWF0ZUFsZXJ0ID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhcInRhZmlkaXRyYSBhbGVydFwiKVxyXG4gICAgdGhpcy5oYW5kbGVFdmVudChcIkFuaW1hdGVBbGVydFwiLCAoe30pID0+IHRoaXMucmVzZXRfb3BhY2l0eSgpKTtcclxuICB9LFxyXG4gIHVwZGF0ZWQoKSB7fSxcclxuICByZXNldF9vcGFjaXR5KCkge1xyXG4gICAgdmFyIGFsZXJ0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNhbGVydF9hbmltXCIpO1xyXG4gICAgYWxlcnQuc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIC8qIGFsZXJ0LnN0eWxlLm9wYWNpdHkgPSAwOyAqL1xyXG4gICAgICBhbGVydC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICB9LCAyMDAwKTtcclxuICB9LFxyXG4gIGFuaW1fb25sb2FkKCkge1xyXG4gICAgdmFyIGFsZXJ0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWxlcnRcIik7XHJcbiAgICAvLyAgY29uc29sZS5sb2coYWxlcnRzKTtcclxuXHJcbiAgICBhbGVydHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICBpdGVtLnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gICAgICBpdGVtLm9ubG9hZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpdGVtLnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICB9LCAyMDAwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxlcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGFsZXJ0c1tpXS5zdHlsZS5vcGFjaXR5ID0gMTtcclxuICAgICAgYWxlcnRzW2ldLm9ubG9hZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhbGVydHNbaV0uc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgIH0sIDIwMDApO1xyXG4gICAgfVxyXG4gIH0sXHJcbn07XHJcblxyXG5Ib29rcy5ibHVySG9vayA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgLy8gY29uc29sZS5sb2coXCJ0YWZpZGl0cmEgYmx1ckhvb2tcIilcclxuICAgIHRoaXMuaGFuZGxlRXZlbnQoXCJibHVyQm9keVwiLCAoeyBwYXJhbTEsIHBhcmFtMiB9KSA9PlxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhwYXJhbTEpXHJcbiAgICAgIHRoaXMuYmx1ckJvZHkoKVxyXG4gICAgKTtcclxuICB9LFxyXG4gIGJsdXJCb2R5KCkge1xyXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgdmFyIHJlcXVlc3RfZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjdGhlX3JlcXVlc3RfZm9ybVwiKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKHJlcXVlc3RfZm9ybSk7XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coYm9keSk7XHJcbiAgICBib2R5LnN0eWxlLm9wYWNpdHkgPSAwLjU7XHJcblxyXG4gICAgLy8gdmFyIG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5tb2RhbC1jb250YWluZXJcIik7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhtb2RhbCk7XHJcbiAgICAvLyBtb2RhbC5zdHlsZS5maWx0ZXIgPSBcImJsdXIoMXB4KVwiO1xyXG4gICAgcmVxdWVzdF9mb3JtLnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gIH0sXHJcbn07XHJcblxyXG5Ib29rcy5NZXNzYWdlQm9keSA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgdmFyIG1lc3NhZ2VCb2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNtZXNzYWdlQm9keVwiKTtcclxuICAgIHRoaXMuaGFuZGxlRXZlbnQoXHJcbiAgICAgIFwidXBkYXRlU2Nyb2xsXCIsXHJcbiAgICAgICh7fSkgPT5cclxuICAgICAgICAobWVzc2FnZUJvZHkuc2Nyb2xsVG9wID1cclxuICAgICAgICAgIG1lc3NhZ2VCb2R5LnNjcm9sbEhlaWdodCAtIG1lc3NhZ2VCb2R5LmNsaWVudEhlaWdodClcclxuICAgICk7XHJcbiAgfSxcclxufTtcclxuXHJcbi8vIEdldCB1cmwgbG9jYXRpb25cclxuSG9va3MudXJsUHJvY2VzcyA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgbGV0IG1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI21haW5cIik7XHJcblxyXG4gICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xyXG5cclxuICAgIC8vIFRlcm5hcnkgZnVuY3Rpb25cclxuICAgIHVybC5pbmNsdWRlcyhcIi9sb2dzXCIpXHJcbiAgICAgID8gbWFpbi5jbGFzc0xpc3QucmVtb3ZlKFwiY29udGFpbmVyXCIpXHJcbiAgICAgIDogbWFpbi5jbGFzc0xpc3QuYWRkKFwiY29udGFpbmVyXCIpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5Ib29rcy5TcGluVGVzdCA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgLy8gY29uc29sZS5sb2coXCJ0YWZpZGl0cmEgaG9va1wiKVxyXG4gICAgdGhpcy5oYW5kbGVFdmVudChcIlNwaW5UZXN0XCIsICh7fSkgPT4gdGhpcy5zcGluX2ljb24oKSk7XHJcbiAgICB0aGlzLmhhbmRsZUV2ZW50KFwiU3BpbkNvbW1lbnRcIiwgKHt9KSA9PiB0aGlzLnNwaW5fY29tbWVudF9pY29uKCkpO1xyXG4gIH0sXHJcbiAgc3Bpbl9pY29uKCkge1xyXG4gICAgdmFyIHNwaW5zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ub3RpZl9fbG9hZFwiKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKHNwaW4pO1xyXG4gICAgLy8gc3BpbnMuY2xhc3NMaXN0LmFkZCgncm90YXRlX19pY29uJyk7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhzcGluKTtcclxuICAgIC8vIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c3BpbnMuY2xhc3NMaXN0LnJlbW92ZSgncm90YXRlX19pY29uJyk7fSwgNTAwKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKCdub3RpZicpXHJcbiAgICBzcGlucy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChcIm5ld19fcm90YXRlX19pY29uXCIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc3BpbnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKFwibmV3X19yb3RhdGVfX2ljb25cIik7XHJcbiAgICAgIH0sIDUwMCk7XHJcbiAgICB9KTtcclxuICB9LFxyXG4gIHNwaW5fY29tbWVudF9pY29uKCkge1xyXG4gICAgLy8gY29uc29sZS5sb2coJ2NvbW1lbnQnKVxyXG4gICAgdmFyIGNsb2NrX2NvbW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNsb2NrX2NvbW1lbnRcIik7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhjbG9ja19jb21tZW50KTtcclxuICAgIGNsb2NrX2NvbW1lbnQuY2xhc3NMaXN0LmFkZChcInJvdGF0ZV9faWNvblwiKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKGNsb2NrX2NvbW1lbnQpO1xyXG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICBjbG9ja19jb21tZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJyb3RhdGVfX2ljb25cIik7XHJcbiAgICB9LCA1MDApO1xyXG4gICAgLy8gY29uc29sZS5sb2coY2xvY2tfY29tbWVudCk7XHJcbiAgfSxcclxufTtcclxuXHJcbmxldCBuYXZUb2dnbGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLm5hdl9fdG9nZ2xlXCIpO1xyXG5sZXQgbmF2V3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubmF2X193cmFwcGVyXCIpO1xyXG5uYXZUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcclxuICBpZiAobmF2V3JhcHBlci5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIikpIHtcclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpO1xyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwibWVudVwiKTtcclxuICAgIG5hdldyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbmF2V3JhcHBlci5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiY2xvc2UgbWVudVwiKTtcclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XHJcbiAgfVxyXG59KTtcclxuIC8vIFJcdTAwRTljdXBcdTAwRTlyZXogbCdcdTAwRTlsXHUwMEU5bWVudCBwYXIgc29uIElEXHJcbiB2YXIgY29weXJpZ2h0SWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb3B5cmlnaHRfX2ljb24nKTtcclxuXHJcbiAvLyBWXHUwMEU5cmlmaWV6IHNpIGwnXHUwMEU5bFx1MDBFOW1lbnQgYSBcdTAwRTl0XHUwMEU5IHRyb3V2XHUwMEU5IGF2YW50IGRlIGxlIG1vZGlmaWVyXHJcbiBpZiAoY29weXJpZ2h0SWNvbikge1xyXG4gICAgIGNvcHlyaWdodEljb24uaW5uZXJIVE1MID0gJ2NvcHlyaWdodCBQSElESUEgLyBQcm9qZWN0IG1vbml0b3JpbmcgLTIwMjQnO1xyXG4gfVxyXG5jb25zdCBtZW51QnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5tZW51LWJ0blwiKTtcclxubGV0IG1lbnVPcGVuID0gZmFsc2U7XHJcbm1lbnVCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcclxuICBpZiAoIW1lbnVPcGVuKSB7XHJcbiAgICBtZW51QnRuLmNsYXNzTGlzdC5hZGQoXCJvcGVuXCIpO1xyXG4gICAgbWVudU9wZW4gPSB0cnVlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtZW51QnRuLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGVuXCIpO1xyXG4gICAgbWVudU9wZW4gPSBmYWxzZTtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIGFsZXJ0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWxlcnRcIik7XHJcblxyXG5hbGVydHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gIGl0ZW0uc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgaXRlbS5vbmxvYWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICBpdGVtLnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gIH0sIDIwMDApO1xyXG59KTtcclxuXHJcbmxldCBjc3JmVG9rZW4gPSBkb2N1bWVudFxyXG4gIC5xdWVyeVNlbGVjdG9yKFwibWV0YVtuYW1lPSdjc3JmLXRva2VuJ11cIilcclxuICAuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKTtcclxubGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwge1xyXG4gIHBhcmFtczogeyBfY3NyZl90b2tlbjogY3NyZlRva2VuIH0sXHJcbiAgaG9va3M6IEhvb2tzLFxyXG59KTtcclxuXHJcbmxldCB0b3BCYXJTY2hlZHVsZWQgPSB1bmRlZmluZWQ7XHJcblxyXG4vLyBTaG93IHByb2dyZXNzIGJhciBvbiBsaXZlIG5hdmlnYXRpb24gYW5kIGZvcm0gc3VibWl0c1xyXG50b3BiYXIuY29uZmlnKHsgYmFyQ29sb3JzOiB7IDA6IFwiIzI5ZFwiIH0sIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgLjMpXCIgfSk7XHJcblxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwgKGluZm8pID0+IHRvcGJhci5zaG93KCkpO1xyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLCAoaW5mbykgPT4gdG9wYmFyLmhpZGUoKSk7XHJcblxyXG4vLyBjb25uZWN0IGlmIHRoZXJlIGFyZSBhbnkgTGl2ZVZpZXdzIG9uIHRoZSBwYWdlXHJcbmxpdmVTb2NrZXQuY29ubmVjdCgpO1xyXG5cclxuLy8gZXhwb3NlIGxpdmVTb2NrZXQgb24gd2luZG93IGZvciB3ZWIgY29uc29sZSBkZWJ1ZyBsb2dzIGFuZCBsYXRlbmN5IHNpbXVsYXRpb246XHJcbi8vID4+IGxpdmVTb2NrZXQuZW5hYmxlRGVidWcoKVxyXG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZUxhdGVuY3lTaW0oMTAwMCkgIC8vIGVuYWJsZWQgZm9yIGR1cmF0aW9uIG9mIGJyb3dzZXIgc2Vzc2lvblxyXG4vLyA+PiBsaXZlU29ja2V0LmRpc2FibGVMYXRlbmN5U2ltKClcclxud2luZG93LmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0O1xyXG5cclxuIiwgIi8qXG5maWNoaWVyIEpTIHBvdXIgbGEgZ2VuZXJlcmF0aW9uIGV0IHNhdXZnYXJkZSBkZSBsaWduZSBkZSBzYWlzaWVcbnJlcXVpcmVkIFRvbVNlbGVjdFxuYSB2b2lyIGF1c3NpIFRhc2tDb250cm9sbGVyLnRhc2tfYnlfcHJvamVjdCAgLy9hcGkgZGUgcmVjdXBlcmF0aW9uIGRlcyB0YWNoZXMgZXQgaW5mbyBjbGllbnQgcGFyIHByb2pldFxuU2Fpc2llQ29udHJvbGxlci5jcmVhdGUgIC8vYXBpIGRlIHNhdXZnYXJkZSBkJ3VuZSBsaWduZVxuYXV0aG9yICA6IGxvaWNSYXZlbG8wNUBnbWFpbC5jb21cbiovXG5cblxuXG5cblxuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gXCJ0b20tc2VsZWN0XCI7XG5cblxuXG5cbi8vIEZvbmN0aW9uIHBvdXIgc2F1dmVnYXJkZXIgdW5lIGxpZ25lXG5mdW5jdGlvbiBzYXZlUm93KGljb24pIHtcbiAgICBjb25zdCByb3cgPSBpY29uLmNsb3Nlc3QoJ3RyJyk7XG4gICAgY29uc3QgaW5wdXRzID0gcm93LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBzZWxlY3QnKTsgLy8gZ2V0IGFsbCBpbnB1dHMgXG4gICAgY29uc3Qgcm93RGF0YSA9IHt9OyAvL2xlcyB2YWxldXIgZGUgY2hhcXVlIGlucHV0XG4gICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICByb3dEYXRhW2lucHV0Lm5hbWVdID0gaW5wdXQudmFsdWU7XG4gICAgfSk7XG4gICAgLy8gVm91cyBwb3V2ZXogbWFpbnRlbmFudCBzb3VtZXR0cmUgY2V0dGUgbGlnbmUgZGUgZG9ublx1MDBFOWVzIFx1MDBFMCB2b3RyZSBiYWNrZW5kIG91IGVmZmVjdHVlciBkJ2F1dHJlcyBhY3Rpb25zXG4gICAgY29uc29sZS5sb2coXCJEb25uXHUwMEU5ZXMgXHUwMEUwIHNhdXZlZ2FyZGVyOlwiLCByb3dEYXRhKTtcblxuICAgIC8vIFJcdTAwRTljdXBcdTAwRTlyZXIgbGUgamV0b24gQ1NSRiBkZXB1aXMgdW4gY2hhbXAgY2FjaFx1MDBFOSBkYW5zIGxlIGZvcm11bGFpcmVcbiAgICBjb25zdCBjc3JmVG9rZW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJykuZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG5cbiAgICAvLyBFbnZvaSBkZXMgZG9ublx1MDBFOWVzIGF1IGJhY2tlbmQgYXZlYyBsZSBqZXRvbiBDU1JGXG4gICAgZmV0Y2goJy9zYXZlX3NhaXNpZScsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnWC1DU1JGLVRva2VuJzogY3NyZlRva2VuICAvLyBJbmNsdXJlIGxlIGpldG9uIENTUkYgZGFucyBsZXMgZW4tdFx1MDBFQXRlcyBkZSBsYSByZXF1XHUwMEVBdGVcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocm93RGF0YSlcbiAgICB9KVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiByZXNwb25zZSA6IFwiLCByZXNwb25zZSlcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VycmV1ciBsb3JzIGRlIGxhIHNhdXZlZ2FyZGUgZGVzIGRvbm5cdTAwRTllcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAvLyBUcmFpdGVtZW50IGRlIGxhIHJcdTAwRTlwb25zZSBkdSBiYWNrZW5kXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU3VjY1x1MDBFOHM6JywgZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTsgLy8gb3UgdG91dGUgYXV0cmUgYWN0aW9uIHF1ZSB2b3VzIHZvdWxleiBlZmZlY3R1ZXIgZW4gY2FzIGRlIHN1Y2NcdTAwRThzXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJldXIgOicsIGVycm9yKTtcbiAgICAgICAgICAgIGFsZXJ0KCdVbmUgZXJyZXVyIGVzdCBzdXJ2ZW51ZSBsb3JzIGRlIGxhIHNhdXZlZ2FyZGUuIFZldWlsbGV6IHZcdTAwRTlyaWZpZXIgcXVlIHRvdXMgbGVzIGNoYW1wcyBzb250IGJpZW4gcmVtcGxpcyBldCBhdSBib24gZm9ybWF0Jyk7XG4gICAgICAgIH0pO1xufVxuLy8gRm9uY3Rpb24gcG91ciBzdXBwcmltZXIgdW5lIGxpZ25lXG5mdW5jdGlvbiByZW1vdmVSb3coaWNvbikge1xuICAgIGljb24uY2xvc2VzdCgndHInKS5yZW1vdmUoKTtcbn1cblxuLy8gZm9uY3Rpb24gZGUgdmFsaWRhdGlvbiBkdSBjaGFtcCBkZWNpbWFsIGRlIGwnaW5wdXRcbmZ1bmN0aW9uIGlzRGVjaW1hbFZhbGlkKGlucHV0VmFsdWUpIHtcbiAgICAvLyBWXHUwMEU5cmlmaWUgc2kgbGEgdmFsZXVyIHNhaXNpZSBlc3QgdW4gbm9tYnJlIGRcdTAwRTljaW1hbCB2YWxpZGUgZW50cmUgMCBldCAyMFxuICAgIGNvbnN0IG51bWVyaWNWYWx1ZSA9IHBhcnNlRmxvYXQoaW5wdXRWYWx1ZSk7XG4gICAgcmV0dXJuICFpc05hTihudW1lcmljVmFsdWUpICYmIG51bWVyaWNWYWx1ZSA+PSAwICYmIG51bWVyaWNWYWx1ZSA8PSAyMCA7XG59XG5cblxuZnVuY3Rpb24gaXNMYWJlbFZhbGlkKGlucHV0VmFsdWUpIHtcbiAgICAvLyBWXHUwMEU5cmlmaWUgc2kgbGEgdmFsZXVyIHNhaXNpZSBuJ2VzdCBwYXMgdmlkZSBldCBuZSBkXHUwMEU5cGFzc2UgcGFzIDI1NSBjYXJhY3RcdTAwRThyZXNcbiAgICByZXR1cm4gaW5wdXRWYWx1ZS50cmltKCkgIT09ICcnICYmIGlucHV0VmFsdWUubGVuZ3RoIDw9IDI1NTtcbn1cblxuZnVuY3Rpb24gaXNQcm9qZWN0SWRWYWxpZCh2YWx1ZSkge1xuICAgIC8vIFZcdTAwRTlyaWZpZSBzaSBsYSB2YWxldXIgZHUgY2hhbXAgZGUgc1x1MDBFOWxlY3Rpb24gZGUgcHJvamV0IG4nZXN0IHBhcyB2aWRlXG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gJyc7XG59XG5cbmZ1bmN0aW9uIGlzVGFza1ZhbGlkKHNlbGVjdGVkVGFzaykge1xuICAgIC8vIFZcdTAwRTlyaWZpZSBzaSB1bmUgdFx1MDBFMmNoZSBlc3Qgc1x1MDBFOWxlY3Rpb25uXHUwMEU5ZVxuICAgIHJldHVybiBzZWxlY3RlZFRhc2sgIT09ICcnO1xufVxuXG5cblxuXG4vLyBlY291dGV1ciBkJ2V2ZW5lbWVudCBkdSBjaGFtcCBkZWNpbWFsXG5cbmZ1bmN0aW9uIGhhbmRsZURlY2ltYWxJbnB1dChldmVudCkge1xuICAgLy8gY29uc3Qgc3RyaW5nRm9ybWF0ID0gdGhpcy52YWx1ZTtcblxuICAgIC8vIFN1cHByaW1lciBsZXMgc2lnbmVzICcrJyBldCAnLScgZGUgbGEgdmFsZXVyIHNhaXNpZVxuICAgIGlmICh0aGlzLnZhbHVlLmluY2x1ZGVzKCcrJykgfHwgdGhpcy52YWx1ZS5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gc3RyaW5nRm9ybWF0LnJlcGxhY2UoL1srLV0vZywgJycpO1xuICAgICAgICB0aGlzLnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgfVxuICAgXG4gICAgLy8gVmFsaWRlciBsYSB2YWxldXIgc2Fpc2llIGV0IGNoYW5nZXIgbGEgY291bGV1ciBkZSBsYSBib3JkdXJlIGVuIGNvbnNcdTAwRTlxdWVuY2VcbiAgICBpZiAoIWlzRGVjaW1hbFZhbGlkKHRoaXMudmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuYm9yZGVyQ29sb3IgPSAncmVkJzsgLy8gQ2hhbmdlbWVudCBkZSBsYSBjb3VsZXVyIGRlIGxhIGJvcmR1cmUgZW4gcm91Z2UgZW4gY2FzIGQnZXJyZXVyXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVlx1MDBFOXJpZmllciBsYSBsb25ndWV1ciBkZSBsYSBwYXJ0aWUgZFx1MDBFOWNpbWFsZVxuICAgICAgICBjb25zdCBkZWNpbWFsTGVuZ3RoID0gKHRoaXMudmFsdWUuc3BsaXQoJy4nKVsxXSB8fCAnJykubGVuZ3RoO1xuICAgICAgICBjb25zb2xlLmxvZyhkZWNpbWFsTGVuZ3RoKTtcbiAgICAgICAgaWYgKGRlY2ltYWxMZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YWxldXIgPSBwYXJzZUZsb2F0KHRoaXMudmFsdWUpLnRvRml4ZWQoMik7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsZXVyOyAvLyBMaW1pdGVyIFx1MDBFMCBkZXV4IGNoaWZmcmVzIGFwclx1MDBFOHMgbGEgdmlyZ3VsZVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3R5bGUuYm9yZGVyQ29sb3IgPSAnZ3JlZW4nOyAvLyBSXHUwMEU5aW5pdGlhbGlzYXRpb24gZGUgbGEgY291bGV1ciBkZSBsYSBib3JkdXJlIFx1MDBFMCBzYSB2YWxldXIgcGFyIGRcdTAwRTlmYXV0XG4gICAgfVxufVxuXG5cblxuZnVuY3Rpb24gaGFuZGxlTGFiZWxJbnB1dChldmVudCkge1xuICAgIGlmICghaXNMYWJlbFZhbGlkKHRoaXMudmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuYm9yZGVyQ29sb3IgPSAncmVkJzsgLy8gQ2hhbmdlbWVudCBkZSBsYSBjb3VsZXVyIGRlIGxhIGJvcmR1cmUgZW4gcm91Z2UgZW4gY2FzIGQnZXJyZXVyXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdHlsZS5ib3JkZXJDb2xvciA9ICdncmVlbic7IC8vIFJcdTAwRTlpbml0aWFsaXNhdGlvbiBkZSBsYSBjb3VsZXVyIGRlIGxhIGJvcmR1cmUgXHUwMEUwIHNhIHZhbGV1ciBwYXIgZFx1MDBFOWZhdXRcbiAgICB9XG59XG5cblxuXG4vL2dlc3Rpb24gZCdldmVuZW1lbnQgZHUgbGEgbGlzdGUgZGVyb3VsYW50ZSBkZXMgcHJvamV0XG5mdW5jdGlvbiBoYW5kbGVQcm9qZWN0U2VsZWN0Q2hhbmdlKGV2ZW50ICwgdGFza190b21fc2VsZWN0KSB7XG4gICAgY29uc3QgcHJvamVjdEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucHJvamVjdF9pZCcpO1xuICAgIGNvbnN0IHRzQ29udHJvbEVsZW1lbnQgPSBwcm9qZWN0RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudHMtY29udHJvbCcpO1xuICAgIGNvbnN0IHNlbGVjdGVkUHJvamVjdElkID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuXG4gICAgaWYgKCFpc1Byb2plY3RJZFZhbGlkKHNlbGVjdGVkUHJvamVjdElkKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm1ha2F0byBhbWluIHJlZFwiKTtcbiAgICAgICAgdHNDb250cm9sRWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9ICdyZWQnOyAvLyBDaGFuZ2VtZW50IGRlIGxhIGNvdWxldXIgZGUgbGEgYm9yZHVyZSBlbiByb3VnZSBlbiBjYXMgZCdlcnJldXJcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm1ha2F0byBhbWluIGdyZWVuXCIpO1xuICAgICAgICB0c0NvbnRyb2xFbGVtZW50LnN0eWxlLmJvcmRlckNvbG9yID0gJ2dyZWVuJzsgLy8gUlx1MDBFOWluaXRpYWxpc2F0aW9uIGRlIGxhIGNvdWxldXIgZGUgbGEgYm9yZHVyZSBcdTAwRTAgc2EgdmFsZXVyIHBhciBkXHUwMEU5ZmF1dFxuICAgIH1cblxuICAgIC8vIE1pc2UgXHUwMEUwIGpvdXIgZGUgbGEgbGlzdGUgZFx1MDBFOXJvdWxhbnRlIGRlcyB0XHUwMEUyY2hlcyBlbiBmb25jdGlvbiBkdSBwcm9qZXQgc1x1MDBFOWxlY3Rpb25uXHUwMEU5XG4gICAgdXBkYXRlVGFza09wdGlvbnMoc2VsZWN0ZWRQcm9qZWN0SWQsIHRhc2tfdG9tX3NlbGVjdCk7XG59XG5cblxuXG5cbi8qXG5lY291dGV1ciBkJ2V2ZW5lbWVudCBzdXIgbGEgbGlzdGUgZGVyb3VsYW50ZSBkZSBwcm9qZXRcbiovXG5mdW5jdGlvbiBoYW5kbGVUYXNrU2VsZWN0Q2hhbmdlKGV2ZW50KSB7XG4gICAgY29uc3QgdGFza0VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFzaycpO1xuICAgIGNvbnN0IHRzQ29udHJvbEVsZW1lbnQgPSB0YXNrRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudHMtY29udHJvbCcpO1xuICAgIGNvbnN0IHNlbGVjdGVkVGFzayA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblxuICAgIGlmICghaXNUYXNrVmFsaWQoc2VsZWN0ZWRUYXNrKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkxhIHRcdTAwRTJjaGUgc1x1MDBFOWxlY3Rpb25uXHUwMEU5ZSBlc3QgaW52YWxpZGVcIik7XG4gICAgICAgIHRzQ29udHJvbEVsZW1lbnQuc3R5bGUuYm9yZGVyQ29sb3IgPSAncmVkJzsgLy8gQ2hhbmdlbWVudCBkZSBsYSBjb3VsZXVyIGRlIGxhIGJvcmR1cmUgZW4gcm91Z2UgZW4gY2FzIGQnZXJyZXVyXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJMYSB0XHUwMEUyY2hlIHNcdTAwRTlsZWN0aW9ublx1MDBFOWUgZXN0IHZhbGlkZVwiKTtcbiAgICAgICAgdHNDb250cm9sRWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9ICdncmVlbic7IC8vIFJcdTAwRTlpbml0aWFsaXNhdGlvbiBkZSBsYSBjb3VsZXVyIGRlIGxhIGJvcmR1cmUgXHUwMEUwIHNhIHZhbGV1ciBwYXIgZFx1MDBFOWZhdXRcbiAgICB9XG59XG5cblxuXG5cblxuLyogZm9uY3Rpb24gcXVpIGFqb3V0IGxlcyBjb3VsZXVyIHBhciBkZWZhdXQgcm91Z2Ugc3VyIGxlcyBjaGFtcCBwdWlzcXVlIGxlcyBjaGFtcCBzb250IHRvdXMgdmlkZSBsb3JzIGRlIGxhIGdlbmVyYXRpb24gZCd1bmUgbm91dmVsbGUgbGlnbmUgXG5OQiA6IGFwcGVsZXIgY2V0dGUgIGZvbmN0aW9uIGp1c3RlIGFwcmVzIGF2b2lyIGNyZWVyIGxlcyBpbnN0YW5jZSBkZSB0b21TZWxlY3Qgc3VyIGxlcyBsaXN0ZSBkZXJvdWxhbnRlID0+IGlsIHkgYSBkZXMgZGl2IGdlbmVyZXIganVzdGUgYXByZXMgYXZvaXIgbWlzIHVuZSBpbnN0YW5jZSBkZSB0b21TZWxlY3Qgc3VyIHVuZSBsaXN0ZSBkZXJvdWxhbnRlICgudHMtY29udHJvbClcbiovXG5cbmZ1bmN0aW9uIGFwcGx5RmllbGRWYWxpZGF0aW9ucyh0YWJsZUJvZHkpIHtcblxuICAgIGNvbnN0IHRhc2tFbGVtZW50ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJy50YXNrJyk7XG4gICAgY29uc3QgdHNDb250cm9sRWxlbWVudDEgPSB0YXNrRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudHMtY29udHJvbCcpO1xuICAgIHRzQ29udHJvbEVsZW1lbnQxLnN0eWxlLmJvcmRlckNvbG9yID0gJ3JlZCc7XG5cbiAgICBjb25zdCBwcm9qZWN0RWxlbWVudCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCcucHJvamVjdF9pZCcpO1xuICAgIGNvbnN0IHRzQ29udHJvbEVsZW1lbnQgPSBwcm9qZWN0RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudHMtY29udHJvbCcpO1xuICAgIHRzQ29udHJvbEVsZW1lbnQuc3R5bGUuYm9yZGVyQ29sb3IgPSAncmVkJztcblxuICAgIGNvbnN0IGxhYmVsSW5wdXQgPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcigndHI6bGFzdC1jaGlsZCBpbnB1dFtuYW1lPVwibGFiZWxzXCJdJyk7XG4gICAgLy8gYWpvdXQgZGUgbGEgY291bGV1ciBpbnRpYWwgXG4gICAgbGFiZWxJbnB1dC5zdHlsZS5ib3JkZXJDb2xvciA9ICdyZWQnO1xuICAgXG59XG5cbmZ1bmN0aW9uIGxpbmVWYWxpZGF0aW9uKHRhYmxlQm9keSkge1xuICAgIGNvbnN0IGxhYmVsSW5wdXQgPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcigndHI6bGFzdC1jaGlsZCBpbnB1dFtuYW1lPVwibGFiZWxzXCJdJyk7XG4gICAgY29uc3QgdGFza1NlbGVjdCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIHNlbGVjdFtuYW1lPVwidGFza1wiXScpO1xuICAgIGNvbnN0IHByb2plY3RTZWxlY3QgPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcigndHI6bGFzdC1jaGlsZCBzZWxlY3RbbmFtZT1cInByb2plY3RfaWRcIl0nKTtcbiAgICBjb25zdCBkZWNpbWFsSW5wdXQgPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcigndHI6bGFzdC1jaGlsZCBpbnB1dFtuYW1lPVwiaG91cnNcIl0nKTtcblxuICAgIC8vIFZhbGlkYXRpb24gZHUgY2hhbXAgZGUgbGliZWxsXHUwMEU5XG4gICAgY29uc3QgaXNMYWJlbFZhbGlkUmVzdWx0ID0gaXNMYWJlbFZhbGlkKGxhYmVsSW5wdXQudmFsdWUpO1xuXG4gICAgLy8gVmFsaWRhdGlvbiBkdSBjaGFtcCBkZSBzXHUwMEU5bGVjdGlvbiBkZSB0XHUwMEUyY2hlXG4gICAgY29uc3QgaXNUYXNrVmFsaWRSZXN1bHQgPSBpc1Rhc2tWYWxpZCh0YXNrU2VsZWN0LnZhbHVlKTtcblxuICAgIC8vIFZhbGlkYXRpb24gZHUgY2hhbXAgZGUgc1x1MDBFOWxlY3Rpb24gZGUgcHJvamV0XG4gICAgY29uc3QgaXNQcm9qZWN0SWRWYWxpZFJlc3VsdCA9IGlzUHJvamVjdElkVmFsaWQocHJvamVjdFNlbGVjdC52YWx1ZSk7XG5cbiAgICAvLyBWYWxpZGF0aW9uIGR1IGNoYW1wIGRcdTAwRTljaW1hbFxuICAgIGNvbnN0IGlzRGVjaW1hbFZhbGlkUmVzdWx0ID0gaXNEZWNpbWFsVmFsaWQoZGVjaW1hbElucHV0LnZhbHVlKTtcblxuICAgIC8vIFNpIHRvdXRlcyBsZXMgdmFsaWRhdGlvbnMgc29udCB2YWxpZGVzLCByZXRvdXJuZXogdHJ1ZSwgc2lub24gcmV0b3VybmV6IGZhbHNlXG4gICAgcmV0dXJuIGlzTGFiZWxWYWxpZFJlc3VsdCAmJiBpc1Rhc2tWYWxpZFJlc3VsdCAmJiBpc1Byb2plY3RJZFZhbGlkUmVzdWx0ICYmIGlzRGVjaW1hbFZhbGlkUmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGF2ZUxpbmVOb3RTYXZlZCh0YWJsZUJvZHkpIHtcbiAgICBjb25zdCBuZXdUYXNrU2VsZWN0ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJ3RyOmxhc3QtY2hpbGQgc2VsZWN0W25hbWU9XCJ0YXNrXCJdJyk7XG4gICAgaWYgKG5ld1Rhc2tTZWxlY3QgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIFxufVxuXG5cblxuXG4vL2ZvbmN0aW9uIGRlIGdcdTAwRTluXHUwMEU5cmF0aW9uIGR5bmFtaXF1ZSBkZXMgbGlnbmUgZGUgc2Fpc2llXG5leHBvcnQgZnVuY3Rpb24gYWRkUm93KHRhYmxlQm9keSwgVG9tU2VsZWN0LCB1c2VySWQsIGRhdGUsIHVzZXJuYW1lLCBwcm9qZWN0cykge1xuICAgIC8vbGVzIGVsZW1lbnQgZGUgbGlnbmVzIFxuICAgIGNvbnN0IG5ld1JvdyA9IGBcbiAgICAgICAgPHRyPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwidXNlcl9pZFwiIHZhbHVlPVwiJHt1c2VySWR9XCI+XG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJkYXRlXCI+PGlucHV0IHR5cGU9XCJkYXRlXCIgbmFtZT1cImRhdGVcIiB2YWx1ZT1cIiR7ZGF0ZX1cIj48L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwidXNlclwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJ1c2VyXCIgdmFsdWU9XCIke3VzZXJuYW1lfVwiIHJlYWRvbmx5PjwvdGQ+XG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJwcm9qZWN0X2lkXCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBuYW1lPVwicHJvamVjdF9pZFwiIGlkPVwidG9tX3NlbGVjdFwiPlxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiXCI+U1x1MDBFOWxlY3Rpb25uZXIgdW4gcHJvamV0PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICR7cHJvamVjdHMubWFwKHByb2plY3QgPT4gYDxvcHRpb24gdmFsdWU9XCIke3Byb2plY3QuaWR9XCI+JHtwcm9qZWN0LnRpdGxlfTwvb3B0aW9uPmApLmpvaW4oJycpfVxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cImNsaWVudFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJjbGllbnRfbmFtZVwiIHZhbHVlPVwiXCIgcmVhZG9ubHk+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwidGFza1wiPlxuICAgICAgICAgICAgICAgIDxzZWxlY3QgbmFtZT1cInRhc2tcIiBpZD1cInRhc2tzX3NlbGVjdFwiIHBsYWNlaG9sZGVyPVwiU1x1MDBFOWxlY3Rpb25lciB1bmUgdFx1MDBFMmNoZVwiPjwvc2VsZWN0PlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cImxhYmVsc1wiPjxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYWJlbHNcIiBwbGFjZWhvbGRlcj1cIkxpYmVsbFx1MDBFOVwiPjwvdGQ+XG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJ0ZW1wc1wiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgaWQ9XCJkZWNpbWFsX2lucHV0XCIgbmFtZT1cImhvdXJzXCIgc3RlcD1cIjAuMVwiIHZhbHVlPVwiMC4wXCI+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwiYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgIDxpIHRpdGxlPVwiU2F1dmVnYXJkZXJcIiBjbGFzcz1cImJpIGJpLXNhdmVcIiBzdHlsZT1cImN1cnNvcjogcG9pbnRlcjtcIj48L2k+XG4gICAgICAgICAgICAgICAgPGkgdGl0bGU9XCJTdXBwcmltZXJcIiBpZD1cInN1cHByXCIgY2xhc3M9XCJiaSBiaS10cmFzaFwiIHN0eWxlPVwiY3Vyc29yOiBwb2ludGVyO1wiID48L2k+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICA8L3RyPlxuICAgIGA7XG4gXG4gICAgdGFibGVCb2R5Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgbmV3Um93KTtcbiAgXG5cblxuICAgIC8vYWpvdXQgdG9tU2VsZWN0IGEgbGEgbGlzdGUgZGVyb3VsYW50ZSBkZXMgcHJvamV0XG4gICAgY29uc3QgbmV3UHJvamVjdFNlbGVjdCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIHNlbGVjdFtuYW1lPVwicHJvamVjdF9pZFwiXScpO1xuXG4gICAgbmV3IFRvbVNlbGVjdChuZXdQcm9qZWN0U2VsZWN0LCB7XG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gZGUgVG9tU2VsZWN0XG4gICAgICAgIHNlYXJjaGFibGU6IHRydWUsXG4gICAgICAgIHNvcnRGaWVsZDoge1xuICAgICAgICAgICAgZmllbGQ6IFwidGV4dFwiLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImFzY1wiXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vY3JlYXRpb24gZCd1biBpbnN0YW5jZSBkZSB0b21TZWxlY3QgYXZlYyBsYSBsaXN0ZSBkZXJvdWxhbnRlIGRlcyB0YWNoZXMgZGFucyBsYSBsaWduZSBub3V2ZWxsZW1lbnQgZ2VucmVyXG4gICAgY29uc3QgbmV3VGFza1NlbGVjdCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIHNlbGVjdFtuYW1lPVwidGFza1wiXScpO1xuICAgIG5ld1Rhc2tTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlVGFza1NlbGVjdENoYW5nZSk7XG4gICAgLy9jb25zb2xlLmxvZyhuZXdUYXNrU2VsZWN0KVxuICAgIHRhc2tfdG9tX3NlbGVjdCA9IG5ldyBUb21TZWxlY3QobmV3VGFza1NlbGVjdCwge1xuICAgICAgICAvLyBDb25maWd1cmF0aW9uIGRlIFRvbVNlbGVjdFxuICAgICAgICBzZWFyY2hhYmxlOiB0cnVlLFxuICAgICAgICBzb3J0RmllbGQ6IHtcbiAgICAgICAgICAgIGZpZWxkOiBcInRleHRcIixcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJhc2NcIlxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8vYXBwZWxlIGRlIGxhIGZvbmN0aW9uIHF1aSBham91dGUgbGVzIHN0eWxlIGRlIGNvdWxldXIgcGFyZGVmYXV0IGRlcyBjaGFtcCBqdXN0ZSBhcHJlcyBhdm9pciBjcmVlciBsZXMgaW5zdGFuY2UgZGUgdG9tU2VsZWN0XG4gICAgYXBwbHlGaWVsZFZhbGlkYXRpb25zKHRhYmxlQm9keSlcblxuICAgIC8vZXh0cmFjdCBsZSBwcm9qZXQgc2VsZWN0aW9uZXIgcG91ciByZWN1cGVyZXIgbGVzIHRhY2hlIGNvcnJlc3BvbmRhbnRcbiAgICBjb25zdCBwcm9qZWN0U2VsZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2VsZWN0W25hbWU9XCJwcm9qZWN0X2lkXCJdJyk7XG4gICAgLy8gQWpvdXQgZCd1biBcdTAwRTljb3V0ZXVyIGQnXHUwMEU5dlx1MDBFOW5lbWVudHMgXHUwMEUwIHByb2plY3RTZWxlY3QgYXZlYyB1bmUgZm9uY3Rpb24gZGUgcmFwcGVsXG4gICAgcHJvamVjdFNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQXBwZWwgZGUgaGFuZGxlUHJvamVjdFNlbGVjdENoYW5nZSBhdmVjIGwnb2JqZXQgZXZlbnQgZXQgdGFza190b21fc2VsZWN0XG4gICAgICAgIGhhbmRsZVByb2plY3RTZWxlY3RDaGFuZ2UoZXZlbnQsIHRhc2tfdG9tX3NlbGVjdCk7XG4gICAgfSk7XG5cblxuICAgIC8vIEFqb3V0IGQndW4gXHUwMEU5Y291dGV1ciBkJ1x1MDBFOXZcdTAwRTluZW1lbnRzIHN1ciBsJ2VudHJcdTAwRTllIGRcdTAwRTljaW1hbGUgcG91ciBsYSB2YWxpZGF0aW9uIGVuIGRpcmVjdFxuICAgIGNvbnN0IGRlY2ltYWxJbnB1dCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIGlucHV0W25hbWU9XCJob3Vyc1wiXScpO1xuICAgIGRlY2ltYWxJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGhhbmRsZURlY2ltYWxJbnB1dCk7XG5cbiAgICBcbiAgICBjb25zdCBsYWJlbElucHV0ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJ3RyOmxhc3QtY2hpbGQgaW5wdXRbbmFtZT1cImxhYmVsc1wiXScpO1xuICAgIC8vIEFqb3V0IGQndW4gXHUwMEU5Y291dGV1ciBkJ1x1MDBFOXZcdTAwRTluZW1lbnRzIHN1ciBsZSBjaGFtcCBkZSB0ZXh0ZSBwb3VyIGxhIHZhbGlkYXRpb24gZW4gZGlyZWN0XG4gICAgbGFiZWxJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGhhbmRsZUxhYmVsSW5wdXQpO1xuXG4gICAgLy8gQWpvdXRleiBsZXMgXHUwMEU5Y291dGV1cnMgZCdcdTAwRTl2XHUwMEU5bmVtZW50cyBhdXggaWNcdTAwRjRuZXMgc2F1dmVnYXJkZXIgZXQgc3VwcHJpbWVyIGRlIGxhIG5vdXZlbGxlIGxpZ25lXG4gICAgY29uc3QgbmV3U2F2ZUljb24gPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcignLmJpLXNhdmUnKTtcbiAgICBuZXdTYXZlSWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVlx1MDBFOXJpZmlleiBsYSB2YWxpZGl0XHUwMEU5IGRlcyBjaGFtcHMgZGUgbGEgZGVybmlcdTAwRThyZSBsaWduZVxuICAgICAgICBjb25zdCBpc1ZhbGlkID0gbGluZVZhbGlkYXRpb24odGFibGVCb2R5KTtcblxuICAgICAgICAvLyBTaSB0b3VzIGxlcyBjaGFtcHMgc29udCB2YWxpZGVzLCBhcHBlbGV6IGxhIGZvbmN0aW9uIHNhdmVSb3dcbiAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgIHNhdmVSb3cobmV3U2F2ZUljb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2lub24sIGFmZmljaGV6IHVuIG1lc3NhZ2UgZCdlcnJldXIgb3UgZWZmZWN0dWV6IHVuZSBhdXRyZSBhY3Rpb25cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMZXMgY2hhbXBzIG5lIHNvbnQgcGFzIHZhbGlkZXMuIFZldWlsbGV6IHZcdTAwRTlyaWZpZXIgdm9zIHNhaXNpZXMuJyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHN1cHByZXNzaW9uIGRlcyBsaWduZXMgZ2VucmVyXG4gICAgY29uc3QgbmV3UmVtb3ZlSWNvbiA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCcjc3VwcHInKTtcbiAgICBjb25zb2xlLmxvZyhuZXdSZW1vdmVJY29uKVxuICAgIG5ld1JlbW92ZUljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVJvdyhuZXdSZW1vdmVJY29uKTtcbiAgICAgICAgcmVzZXRBZGRSb3dJY29uKCk7XG4gICAgfSk7XG5cblxuXG5cbiAgICBcbiAgIFxuXG5cblxufVxuLy9mb25jdGlvbiBkZSBtaXNlIFx1MDBFMCBqb3VyIGRlIGxhIGxpc3RlIGRcdTAwRTlyb3VsYW50ZSBkZXMgdFx1MDBFMmNoZXMgcGFyIHByb2pldCBzXHUwMEU5bGVjdGlvbm5cdTAwRTlcbi8vYXBwZWwgXHUwMEUwIHVuZSBBUEkgZGFucyBUYXNrQ29udHJvbGxlci50YXNrX2J5X3Byb2plY3QgPT4gcmV0b3VybmUgbGVzIHRcdTAwRTJjaGVzIGV0IGxlcyBkXHUwMEU5dGFpbHMgZHUgY2xpZW50IHJhdHRhY2hcdTAwRTkgYXUgcHJvamV0IHNcdTAwRTlsZWN0aW9ublx1MDBFOVxuZnVuY3Rpb24gdXBkYXRlVGFza09wdGlvbnMoc2VsZWN0ZWRQcm9qZWN0SWQsIHRhc2tUb21TZWxlY3QpIHtcbiAgICAvLyBWb3RyZSBsb2dpcXVlIHBvdXIgbWV0dHJlIFx1MDBFMCBqb3VyIGxlcyBvcHRpb25zIGR1IG1lbnUgZFx1MDBFOXJvdWxhbnQgZGVzIHRcdTAwRTJjaGVzIGljaVxuICAgIC8vY29uc29sZS5sb2coJ1Byb2pldCBzXHUwMEU5bGVjdGlvbm5cdTAwRTk6Jywgc2VsZWN0ZWRQcm9qZWN0SWQpO1xuXG4gICAgLy8gRWZmZWN0dWVyIHVuZSByZXF1XHUwMEVBdGUgQUpBWCB2ZXJzIHZvdHJlIGVuZHBvaW50IGJhY2tlbmQgcG91ciByXHUwMEU5Y3VwXHUwMEU5cmVyIGxlcyB0XHUwMEUyY2hlcyBhc3NvY2lcdTAwRTllcyBhdSBwcm9qZXQgc1x1MDBFOWxlY3Rpb25uXHUwMEU5XG4gICAgZmV0Y2goYC90YXNrcy8ke3NlbGVjdGVkUHJvamVjdElkfWApXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyZXVyIGxvcnMgZGUgbGEgclx1MDBFOWN1cFx1MDBFOXJhdGlvbiBkZXMgdFx1MDBFMmNoZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgLy8gTWV0dHJlIFx1MDBFMCBqb3VyIGxhIGxpc3RlIGRcdTAwRTlyb3VsYW50ZSBkZXMgdFx1MDBFMmNoZXMgYXZlYyBsZXMgZG9ublx1MDBFOWVzIHJcdTAwRTljdXBcdTAwRTlyXHUwMEU5ZXNcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgICAgICBjb25zdCB0YXNrcyA9IGRhdGEudGFza3M7XG4gICAgICAgICAgICB0YXNrVG9tU2VsZWN0LmNsZWFyKCk7XG4gICAgICAgICAgICB0YXNrVG9tU2VsZWN0LmNsZWFyT3B0aW9ucygpOyAvLyBFZmZhY2VyIGxlcyBvcHRpb25zIHByXHUwMEU5Y1x1MDBFOWRlbnRlc1xuICAgICAgICAgICAgdGFza3MuZm9yRWFjaCh0YXNrID0+IHtcbiAgICAgICAgICAgICAgICB0YXNrVG9tU2VsZWN0LmFkZE9wdGlvbih7IHZhbHVlOiB0YXNrLmlkLCB0ZXh0OiB0YXNrLnRpdGxlIH0pOyAgLy9ham91dCBkZXMgbm91dmVsbGVzIG9wdGlvbiBhIGwnaW5zdGFuY2UgZHUgdG9tU2VsZWN0IHBhc3NlciBlbiBwYXJhbWV0cmVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRyYWl0ZW1lbnQgZGVzIGRcdTAwRTl0YWlscyBjbGllbnRzXG4gICAgICAgICAgICBjb25zdCBjbGllbnREZXRhaWxzID0gZGF0YS5jbGllbnRfZGV0YWlscztcbiAgICAgICAgICAgIC8vIEV4ZW1wbGUgZCd1dGlsaXNhdGlvbiBkZXMgZFx1MDBFOXRhaWxzIGR1IGNsaWVudFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ05vbSBkdSBjbGllbnQ6JywgY2xpZW50RGV0YWlscy5jbGllbnRzX25hbWUpO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50TmFtZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT1cImNsaWVudF9uYW1lXCJdJyk7XG4gICAgICAgICAgICBjbGllbnROYW1lSW5wdXQudmFsdWUgPSBjbGllbnREZXRhaWxzLmNsaWVudHNfbmFtZTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudE5hbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W25hbWU9XCJjbGllbnRfbmFtZVwiXScpO1xuICAgICAgICAgICAgY2xpZW50TmFtZUlucHV0LnZhbHVlID0gJyc7XG4gICAgICAgICAgICB0YXNrVG9tU2VsZWN0LmNsZWFyKCk7XG4gICAgICAgICAgICB0YXNrVG9tU2VsZWN0LmNsZWFyT3B0aW9ucygpOyAvLyBFZmZhY2VyIGxlcyBvcHRpb25zIHByXHUwMEU5Y1x1MDBFOWRlbnRlc1xuICAgICAgICAgICAgY29uc29sZS5sb2codGFza1RvbVNlbGVjdCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJldXIgOicsIGVycm9yKTtcbiAgICAgICAgfSk7XG59XG5cblxuLy9yZXNldCBhZGQgcm93IGljb24gXG5mdW5jdGlvbiByZXNldEFkZFJvd0ljb24oKSB7XG4gICAgdmFyIGFkZFJvd0xpbmsgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWRkUm93SWNvbicpOyBcbiAgICB2YXIgYWRkUm93SWNvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhZGRSb3dJY29uIGknKTtcbiAgICBhZGRSb3dMaW5rLmNsYXNzTGlzdC5yZW1vdmUoJ25vbi1jbGlxdWFibGUnKTtcbiAgICBhZGRSb3dJY29uLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbn1cblxuXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFBvbHlmaWxsRXZlbnQgPSBldmVudENvbnN0cnVjdG9yKCk7XG5cbiAgZnVuY3Rpb24gZXZlbnRDb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gd2luZG93LkN1c3RvbUV2ZW50O1xuICAgIC8vIElFPD05IFN1cHBvcnRcbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge2J1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWR9O1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfVxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRIaWRkZW5JbnB1dChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGVsZW1lbnQsIHRhcmdldE1vZGlmaWVyS2V5KSB7XG4gICAgdmFyIHRvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvXCIpLFxuICAgICAgICBtZXRob2QgPSBidWlsZEhpZGRlbklucHV0KFwiX21ldGhvZFwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSxcbiAgICAgICAgY3NyZiA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfY3NyZl90b2tlblwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY3NyZlwiKSksXG4gICAgICAgIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgc3VibWl0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuICAgICAgICB0YXJnZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcblxuICAgIGZvcm0ubWV0aG9kID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikgPT09IFwiZ2V0XCIpID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICAgIGZvcm0uYWN0aW9uID0gdG87XG4gICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICBpZiAodGFyZ2V0KSBmb3JtLnRhcmdldCA9IHRhcmdldDtcbiAgICBlbHNlIGlmICh0YXJnZXRNb2RpZmllcktleSkgZm9ybS50YXJnZXQgPSBcIl9ibGFua1wiO1xuXG4gICAgZm9ybS5hcHBlbmRDaGlsZChjc3JmKTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKG1ldGhvZCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIC8vIEluc2VydCBhIGJ1dHRvbiBhbmQgY2xpY2sgaXQgaW5zdGVhZCBvZiB1c2luZyBgZm9ybS5zdWJtaXRgXG4gICAgLy8gYmVjYXVzZSB0aGUgYHN1Ym1pdGAgZnVuY3Rpb24gZG9lcyBub3QgZW1pdCBhIGBzdWJtaXRgIGV2ZW50LlxuICAgIHN1Ym1pdC50eXBlID0gXCJzdWJtaXRcIjtcbiAgICBmb3JtLmFwcGVuZENoaWxkKHN1Ym1pdCk7XG4gICAgc3VibWl0LmNsaWNrKCk7XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGUudGFyZ2V0O1xuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKSB7XG4gICAgICB2YXIgcGhvZW5peExpbmtFdmVudCA9IG5ldyBQb2x5ZmlsbEV2ZW50KCdwaG9lbml4LmxpbmsuY2xpY2snLCB7XG4gICAgICAgIFwiYnViYmxlc1wiOiB0cnVlLCBcImNhbmNlbGFibGVcIjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghZWxlbWVudC5kaXNwYXRjaEV2ZW50KHBob2VuaXhMaW5rRXZlbnQpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSkge1xuICAgICAgICBoYW5kbGVDbGljayhlbGVtZW50LCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIGZhbHNlKTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGhvZW5peC5saW5rLmNsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbWVzc2FnZSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29uZmlybVwiKTtcbiAgICBpZihtZXNzYWdlICYmICF3aW5kb3cuY29uZmlybShtZXNzYWdlKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xufSkoKTtcbiIsICIvLyB3cmFwcyB2YWx1ZSBpbiBjbG9zdXJlIG9yIHJldHVybnMgY2xvc3VyZVxuZXhwb3J0IGxldCBjbG9zdXJlID0gKHZhbHVlKSA9PiB7XG4gIGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKXtcbiAgICByZXR1cm4gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBsZXQgY2xvc3VyZSA9IGZ1bmN0aW9uICgpeyByZXR1cm4gdmFsdWUgfVxuICAgIHJldHVybiBjbG9zdXJlXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgZ2xvYmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IG51bGxcbmV4cG9ydCBjb25zdCBwaHhXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogbnVsbFxuZXhwb3J0IGNvbnN0IGdsb2JhbCA9IGdsb2JhbFNlbGYgfHwgcGh4V2luZG93IHx8IGdsb2JhbFxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVlNOID0gXCIyLjAuMFwiXG5leHBvcnQgY29uc3QgU09DS0VUX1NUQVRFUyA9IHtjb25uZWN0aW5nOiAwLCBvcGVuOiAxLCBjbG9zaW5nOiAyLCBjbG9zZWQ6IDN9XG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FT1VUID0gMTAwMDBcbmV4cG9ydCBjb25zdCBXU19DTE9TRV9OT1JNQUwgPSAxMDAwXG5leHBvcnQgY29uc3QgQ0hBTk5FTF9TVEFURVMgPSB7XG4gIGNsb3NlZDogXCJjbG9zZWRcIixcbiAgZXJyb3JlZDogXCJlcnJvcmVkXCIsXG4gIGpvaW5lZDogXCJqb2luZWRcIixcbiAgam9pbmluZzogXCJqb2luaW5nXCIsXG4gIGxlYXZpbmc6IFwibGVhdmluZ1wiLFxufVxuZXhwb3J0IGNvbnN0IENIQU5ORUxfRVZFTlRTID0ge1xuICBjbG9zZTogXCJwaHhfY2xvc2VcIixcbiAgZXJyb3I6IFwicGh4X2Vycm9yXCIsXG4gIGpvaW46IFwicGh4X2pvaW5cIixcbiAgcmVwbHk6IFwicGh4X3JlcGx5XCIsXG4gIGxlYXZlOiBcInBoeF9sZWF2ZVwiXG59XG5cbmV4cG9ydCBjb25zdCBUUkFOU1BPUlRTID0ge1xuICBsb25ncG9sbDogXCJsb25ncG9sbFwiLFxuICB3ZWJzb2NrZXQ6IFwid2Vic29ja2V0XCJcbn1cbmV4cG9ydCBjb25zdCBYSFJfU1RBVEVTID0ge1xuICBjb21wbGV0ZTogNFxufVxuIiwgIi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBDaGFubmVsXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IDEyM31gXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCAtIFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2gge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsLCBldmVudCwgcGF5bG9hZCwgdGltZW91dCl7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbFxuICAgIHRoaXMuZXZlbnQgPSBldmVudFxuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQgfHwgZnVuY3Rpb24gKCl7IHJldHVybiB7fSB9XG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbFxuICAgIHRoaXMucmVjSG9va3MgPSBbXVxuICAgIHRoaXMuc2VudCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAgICovXG4gIHJlc2VuZCh0aW1lb3V0KXtcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgdGhpcy5yZXNldCgpXG4gICAgdGhpcy5zZW5kKClcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgc2VuZCgpe1xuICAgIGlmKHRoaXMuaGFzUmVjZWl2ZWQoXCJ0aW1lb3V0XCIpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnN0YXJ0VGltZW91dCgpXG4gICAgdGhpcy5zZW50ID0gdHJ1ZVxuICAgIHRoaXMuY2hhbm5lbC5zb2NrZXQucHVzaCh7XG4gICAgICB0b3BpYzogdGhpcy5jaGFubmVsLnRvcGljLFxuICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICBwYXlsb2FkOiB0aGlzLnBheWxvYWQoKSxcbiAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHsqfSBzdGF0dXNcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcmVjZWl2ZShzdGF0dXMsIGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLmhhc1JlY2VpdmVkKHN0YXR1cykpe1xuICAgICAgY2FsbGJhY2sodGhpcy5yZWNlaXZlZFJlc3AucmVzcG9uc2UpXG4gICAgfVxuXG4gICAgdGhpcy5yZWNIb29rcy5wdXNoKHtzdGF0dXMsIGNhbGxiYWNrfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldCgpe1xuICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKVxuICAgIHRoaXMucmVmID0gbnVsbFxuICAgIHRoaXMucmVmRXZlbnQgPSBudWxsXG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy5zZW50ID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbWF0Y2hSZWNlaXZlKHtzdGF0dXMsIHJlc3BvbnNlLCBfcmVmfSl7XG4gICAgdGhpcy5yZWNIb29rcy5maWx0ZXIoaCA9PiBoLnN0YXR1cyA9PT0gc3RhdHVzKVxuICAgICAgLmZvckVhY2goaCA9PiBoLmNhbGxiYWNrKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuY2VsUmVmRXZlbnQoKXtcbiAgICBpZighdGhpcy5yZWZFdmVudCl7IHJldHVybiB9XG4gICAgdGhpcy5jaGFubmVsLm9mZih0aGlzLnJlZkV2ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxUaW1lb3V0KCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKVxuICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydFRpbWVvdXQoKXtcbiAgICBpZih0aGlzLnRpbWVvdXRUaW1lcil7IHRoaXMuY2FuY2VsVGltZW91dCgpIH1cbiAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQubWFrZVJlZigpXG4gICAgdGhpcy5yZWZFdmVudCA9IHRoaXMuY2hhbm5lbC5yZXBseUV2ZW50TmFtZSh0aGlzLnJlZilcblxuICAgIHRoaXMuY2hhbm5lbC5vbih0aGlzLnJlZkV2ZW50LCBwYXlsb2FkID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKVxuICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KClcbiAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZFxuICAgICAgdGhpcy5tYXRjaFJlY2VpdmUocGF5bG9hZClcbiAgICB9KVxuXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihcInRpbWVvdXRcIiwge30pXG4gICAgfSwgdGhpcy50aW1lb3V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXNSZWNlaXZlZChzdGF0dXMpe1xuICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1c1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyKHN0YXR1cywgcmVzcG9uc2Upe1xuICAgIHRoaXMuY2hhbm5lbC50cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHtzdGF0dXMsIHJlc3BvbnNlfSlcbiAgfVxufVxuIiwgIi8qKlxuICpcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtXG4gKiBjYWxjdWxhdGVkIHRpbWVvdXQgcmV0cmllcywgc3VjaCBhcyBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgcmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5jb25uZWN0KCksIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogfSlcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDUwMDBcbiAqIHJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gdGltZXJDYWxjXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHRpbWVyQ2FsYyl7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGNcbiAgICB0aGlzLnRpbWVyID0gbnVsbFxuICAgIHRoaXMudHJpZXMgPSAwXG4gIH1cblxuICByZXNldCgpe1xuICAgIHRoaXMudHJpZXMgPSAwXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhbnkgcHJldmlvdXMgc2NoZWR1bGVUaW1lb3V0IGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAgICovXG4gIHNjaGVkdWxlVGltZW91dCgpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuXG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxXG4gICAgICB0aGlzLmNhbGxiYWNrKClcbiAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpXG4gIH1cbn1cbiIsICJpbXBvcnQge2Nsb3N1cmV9IGZyb20gXCIuL3V0aWxzXCJcbmltcG9ydCB7XG4gIENIQU5ORUxfRVZFTlRTLFxuICBDSEFOTkVMX1NUQVRFUyxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IFB1c2ggZnJvbSBcIi4vcHVzaFwiXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vdGltZXJcIlxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAqIEBwYXJhbSB7KE9iamVjdHxmdW5jdGlvbil9IHBhcmFtc1xuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFubmVsIHtcbiAgY29uc3RydWN0b3IodG9waWMsIHBhcmFtcywgc29ja2V0KXtcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkXG4gICAgdGhpcy50b3BpYyA9IHRvcGljXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyB8fCB7fSlcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIHRoaXMuYmluZGluZ3MgPSBbXVxuICAgIHRoaXMuYmluZGluZ1JlZiA9IDBcbiAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0XG4gICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2VcbiAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dClcbiAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzID0gW11cblxuICAgIHRoaXMucmVqb2luVGltZXIgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luKCkgfVxuICAgIH0sIHRoaXMuc29ja2V0LnJlam9pbkFmdGVyTXMpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbkVycm9yKCgpID0+IHRoaXMucmVqb2luVGltZXIucmVzZXQoKSkpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbk9wZW4oKCkgPT4ge1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICBpZih0aGlzLmlzRXJyb3JlZCgpKXsgdGhpcy5yZWpvaW4oKSB9XG4gICAgfSlcbiAgICApXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwib2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZFxuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaChwdXNoRXZlbnQgPT4gcHVzaEV2ZW50LnNlbmQoKSlcbiAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdXG4gICAgfSlcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5vbkNsb3NlKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLmpvaW5SZWYoKX1gKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlKHRoaXMpXG4gICAgfSlcbiAgICB0aGlzLm9uRXJyb3IocmVhc29uID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKVxuICAgICAgaWYodGhpcy5pc0pvaW5pbmcoKSl7IHRoaXMuam9pblB1c2gucmVzZXQoKSB9XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgdGltZW91dCAke3RoaXMudG9waWN9ICgke3RoaXMuam9pblJlZigpfSlgLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpXG4gICAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aGlzLnRpbWVvdXQpXG4gICAgICBsZWF2ZVB1c2guc2VuZCgpXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgdGhpcy5qb2luUHVzaC5yZXNldCgpXG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKSB9XG4gICAgfSlcbiAgICB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLnJlcGx5LCAocGF5bG9hZCwgcmVmKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIodGhpcy5yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSm9pbiB0aGUgY2hhbm5lbFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRpbWVvdXRcbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIGlmKHRoaXMuam9pbmVkT25jZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmllZCB0byBqb2luIG11bHRpcGxlIHRpbWVzLiAnam9pbicgY2FuIG9ubHkgYmUgY2FsbGVkIGEgc2luZ2xlIHRpbWUgcGVyIGNoYW5uZWwgaW5zdGFuY2VcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZVxuICAgICAgdGhpcy5yZWpvaW4oKVxuICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2hcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSG9vayBpbnRvIGNoYW5uZWwgY2xvc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgaW50byBjaGFubmVsIGVycm9yc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgcmV0dXJuIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHJlYXNvbiA9PiBjYWxsYmFjayhyZWFzb24pKVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgb24gY2hhbm5lbCBldmVudHNcbiAgICpcbiAgICogU3Vic2NyaXB0aW9uIHJldHVybnMgYSByZWYgY291bnRlciwgd2hpY2ggY2FuIGJlIHVzZWQgbGF0ZXIgdG9cbiAgICogdW5zdWJzY3JpYmUgdGhlIGV4YWN0IGV2ZW50IGxpc3RlbmVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlZjEgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fc3R1ZmYpXG4gICAqIGNvbnN0IHJlZjIgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fb3RoZXJfc3R1ZmYpXG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIiwgcmVmMSlcbiAgICogLy8gU2luY2UgdW5zdWJzY3JpcHRpb24sIGRvX3N0dWZmIHdvbid0IGZpcmUsXG4gICAqIC8vIHdoaWxlIGRvX290aGVyX3N0dWZmIHdpbGwga2VlcCBmaXJpbmcgb24gdGhlIFwiZXZlbnRcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge2ludGVnZXJ9IHJlZlxuICAgKi9cbiAgb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5iaW5kaW5nUmVmKytcbiAgICB0aGlzLmJpbmRpbmdzLnB1c2goe2V2ZW50LCByZWYsIGNhbGxiYWNrfSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIG9mZiBvZiBjaGFubmVsIGV2ZW50c1xuICAgKlxuICAgKiBVc2UgdGhlIHJlZiByZXR1cm5lZCBmcm9tIGEgY2hhbm5lbC5vbigpIHRvIHVuc3Vic2NyaWJlIG9uZVxuICAgKiBoYW5kbGVyLCBvciBwYXNzIG5vdGhpbmcgZm9yIHRoZSByZWYgdG8gdW5zdWJzY3JpYmUgYWxsXG4gICAqIGhhbmRsZXJzIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFVuc3Vic2NyaWJlIHRoZSBkb19zdHVmZiBoYW5kbGVyXG4gICAqIGNvbnN0IHJlZjEgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fc3R1ZmYpXG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIiwgcmVmMSlcbiAgICpcbiAgICogLy8gVW5zdWJzY3JpYmUgYWxsIGhhbmRsZXJzIGZyb20gZXZlbnRcbiAgICogY2hhbm5lbC5vZmYoXCJldmVudFwiKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSByZWZcbiAgICovXG4gIG9mZihldmVudCwgcmVmKXtcbiAgICB0aGlzLmJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgIHJldHVybiAhKGJpbmQuZXZlbnQgPT09IGV2ZW50ICYmICh0eXBlb2YgcmVmID09PSBcInVuZGVmaW5lZFwiIHx8IHJlZiA9PT0gYmluZC5yZWYpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhblB1c2goKXsgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5pc0pvaW5lZCgpIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlIGBldmVudGAgdG8gcGhvZW5peCB3aXRoIHRoZSBwYXlsb2FkIGBwYXlsb2FkYC5cbiAgICogUGhvZW5peCByZWNlaXZlcyB0aGlzIGluIHRoZSBgaGFuZGxlX2luKGV2ZW50LCBwYXlsb2FkLCBzb2NrZXQpYFxuICAgKiBmdW5jdGlvbi4gaWYgcGhvZW5peCByZXBsaWVzIG9yIGl0IHRpbWVzIG91dCAoZGVmYXVsdCAxMDAwMG1zKSxcbiAgICogdGhlbiBvcHRpb25hbGx5IHRoZSByZXBseSBjYW4gYmUgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNoYW5uZWwucHVzaChcImV2ZW50XCIpXG4gICAqICAgLnJlY2VpdmUoXCJva1wiLCBwYXlsb2FkID0+IGNvbnNvbGUubG9nKFwicGhvZW5peCByZXBsaWVkOlwiLCBwYXlsb2FkKSlcbiAgICogICAucmVjZWl2ZShcImVycm9yXCIsIGVyciA9PiBjb25zb2xlLmxvZyhcInBob2VuaXggZXJyb3JlZFwiLCBlcnIpKVxuICAgKiAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiBjb25zb2xlLmxvZyhcInRpbWVkIG91dCBwdXNoaW5nXCIpKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0XVxuICAgKiBAcmV0dXJucyB7UHVzaH1cbiAgICovXG4gIHB1c2goZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIHBheWxvYWQgPSBwYXlsb2FkIHx8IHt9XG4gICAgaWYoIXRoaXMuam9pbmVkT25jZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNgKVxuICAgIH1cbiAgICBsZXQgcHVzaEV2ZW50ID0gbmV3IFB1c2godGhpcywgZXZlbnQsIGZ1bmN0aW9uICgpeyByZXR1cm4gcGF5bG9hZCB9LCB0aW1lb3V0KVxuICAgIGlmKHRoaXMuY2FuUHVzaCgpKXtcbiAgICAgIHB1c2hFdmVudC5zZW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIucHVzaChwdXNoRXZlbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHB1c2hFdmVudFxuICB9XG5cbiAgLyoqIExlYXZlcyB0aGUgY2hhbm5lbFxuICAgKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBzZXJ2ZXIgZXZlbnRzLCBhbmRcbiAgICogaW5zdHJ1Y3RzIGNoYW5uZWwgdG8gdGVybWluYXRlIG9uIHNlcnZlclxuICAgKlxuICAgKiBUcmlnZ2VycyBvbkNsb3NlKCkgaG9va3NcbiAgICpcbiAgICogVG8gcmVjZWl2ZSBsZWF2ZSBhY2tub3dsZWRnZW1lbnRzLCB1c2UgdGhlIGByZWNlaXZlYFxuICAgKiBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFubmVsLmxlYXZlKCkucmVjZWl2ZShcIm9rXCIsICgpID0+IGFsZXJ0KFwibGVmdCFcIikgKVxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRpbWVvdXRcbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBsZWF2ZSh0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICB0aGlzLmpvaW5QdXNoLmNhbmNlbFRpbWVvdXQoKVxuXG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmdcbiAgICBsZXQgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBsZWF2ZSAke3RoaXMudG9waWN9YClcbiAgICAgIHRoaXMudHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5jbG9zZSwgXCJsZWF2ZVwiKVxuICAgIH1cbiAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aW1lb3V0KVxuICAgIGxlYXZlUHVzaC5yZWNlaXZlKFwib2tcIiwgKCkgPT4gb25DbG9zZSgpKVxuICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IG9uQ2xvc2UoKSlcbiAgICBsZWF2ZVB1c2guc2VuZCgpXG4gICAgaWYoIXRoaXMuY2FuUHVzaCgpKXsgbGVhdmVQdXNoLnRyaWdnZXIoXCJva1wiLCB7fSkgfVxuXG4gICAgcmV0dXJuIGxlYXZlUHVzaFxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgKlxuICAgKiBSZWNlaXZlcyBhbGwgZXZlbnRzIGZvciBzcGVjaWFsaXplZCBtZXNzYWdlIGhhbmRsaW5nXG4gICAqIGJlZm9yZSBkaXNwYXRjaGluZyB0byB0aGUgY2hhbm5lbCBjYWxsYmFja3MuXG4gICAqXG4gICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHJlZlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgb25NZXNzYWdlKF9ldmVudCwgcGF5bG9hZCwgX3JlZil7IHJldHVybiBwYXlsb2FkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTWVtYmVyKHRvcGljLCBldmVudCwgcGF5bG9hZCwgam9pblJlZil7XG4gICAgaWYodGhpcy50b3BpYyAhPT0gdG9waWMpeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYoam9pblJlZiAmJiBqb2luUmVmICE9PSB0aGlzLmpvaW5SZWYoKSl7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBcImRyb3BwaW5nIG91dGRhdGVkIG1lc3NhZ2VcIiwge3RvcGljLCBldmVudCwgcGF5bG9hZCwgam9pblJlZn0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGpvaW5SZWYoKXsgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBpZih0aGlzLmlzTGVhdmluZygpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnNvY2tldC5sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKVxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nXG4gICAgdGhpcy5qb2luUHVzaC5yZXNlbmQodGltZW91dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luUmVmKXtcbiAgICBsZXQgaGFuZGxlZFBheWxvYWQgPSB0aGlzLm9uTWVzc2FnZShldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luUmVmKVxuICAgIGlmKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKXsgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXCIpIH1cblxuICAgIGxldCBldmVudEJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoYmluZCA9PiBiaW5kLmV2ZW50ID09PSBldmVudClcblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBldmVudEJpbmRpbmdzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGxldCBiaW5kID0gZXZlbnRCaW5kaW5nc1tpXVxuICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmLCBqb2luUmVmIHx8IHRoaXMuam9pblJlZigpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVwbHlFdmVudE5hbWUocmVmKXsgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNDbG9zZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0Vycm9yZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmVycm9yZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNKb2luZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0pvaW5pbmcoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmcgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNMZWF2aW5nKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nIH1cbn1cbiIsICJpbXBvcnQge1xuICBnbG9iYWwsXG4gIFhIUl9TVEFURVNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWpheCB7XG5cbiAgc3RhdGljIHJlcXVlc3QobWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICBpZihnbG9iYWwuWERvbWFpblJlcXVlc3Qpe1xuICAgICAgbGV0IHJlcSA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKSAvLyBJRTgsIElFOVxuICAgICAgcmV0dXJuIHRoaXMueGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVxID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpIC8vIElFNyssIEZpcmVmb3gsIENocm9tZSwgT3BlcmEsIFNhZmFyaVxuICAgICAgcmV0dXJuIHRoaXMueGhyUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgeGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICByZXEudGltZW91dCA9IHRpbWVvdXRcbiAgICByZXEub3BlbihtZXRob2QsIGVuZFBvaW50KVxuICAgIHJlcS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcG9uc2UpXG4gICAgfVxuICAgIGlmKG9udGltZW91dCl7IHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQgfVxuXG4gICAgLy8gV29yayBhcm91bmQgYnVnIGluIElFOSB0aGF0IHJlcXVpcmVzIGFuIGF0dGFjaGVkIG9ucHJvZ3Jlc3MgaGFuZGxlclxuICAgIHJlcS5vbnByb2dyZXNzID0gKCkgPT4geyB9XG5cbiAgICByZXEuc2VuZChib2R5KVxuICAgIHJldHVybiByZXFcbiAgfVxuXG4gIHN0YXRpYyB4aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICByZXEub3BlbihtZXRob2QsIGVuZFBvaW50LCB0cnVlKVxuICAgIHJlcS50aW1lb3V0ID0gdGltZW91dFxuICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIGFjY2VwdClcbiAgICByZXEub25lcnJvciA9ICgpID0+IGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpXG4gICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmKHJlcS5yZWFkeVN0YXRlID09PSBYSFJfU1RBVEVTLmNvbXBsZXRlICYmIGNhbGxiYWNrKXtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdGhpcy5wYXJzZUpTT04ocmVxLnJlc3BvbnNlVGV4dClcbiAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKG9udGltZW91dCl7IHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQgfVxuXG4gICAgcmVxLnNlbmQoYm9keSlcbiAgICByZXR1cm4gcmVxXG4gIH1cblxuICBzdGF0aWMgcGFyc2VKU09OKHJlc3Ape1xuICAgIGlmKCFyZXNwIHx8IHJlc3AgPT09IFwiXCIpeyByZXR1cm4gbnVsbCB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcClcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgIGNvbnNvbGUgJiYgY29uc29sZS5sb2coXCJmYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZVwiLCByZXNwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgc2VyaWFsaXplKG9iaiwgcGFyZW50S2V5KXtcbiAgICBsZXQgcXVlcnlTdHIgPSBbXVxuICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICBpZighT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSl7IGNvbnRpbnVlIH1cbiAgICAgIGxldCBwYXJhbUtleSA9IHBhcmVudEtleSA/IGAke3BhcmVudEtleX1bJHtrZXl9XWAgOiBrZXlcbiAgICAgIGxldCBwYXJhbVZhbCA9IG9ialtrZXldXG4gICAgICBpZih0eXBlb2YgcGFyYW1WYWwgPT09IFwib2JqZWN0XCIpe1xuICAgICAgICBxdWVyeVN0ci5wdXNoKHRoaXMuc2VyaWFsaXplKHBhcmFtVmFsLCBwYXJhbUtleSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeVN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwYXJhbUtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbCkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVN0ci5qb2luKFwiJlwiKVxuICB9XG5cbiAgc3RhdGljIGFwcGVuZFBhcmFtcyh1cmwsIHBhcmFtcyl7XG4gICAgaWYoT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApeyByZXR1cm4gdXJsIH1cblxuICAgIGxldCBwcmVmaXggPSB1cmwubWF0Y2goL1xcPy8pID8gXCImXCIgOiBcIj9cIlxuICAgIHJldHVybiBgJHt1cmx9JHtwcmVmaXh9JHt0aGlzLnNlcmlhbGl6ZShwYXJhbXMpfWBcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFNPQ0tFVF9TVEFURVMsXG4gIFRSQU5TUE9SVFNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IEFqYXggZnJvbSBcIi4vYWpheFwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvbmdQb2xsIHtcblxuICBjb25zdHJ1Y3RvcihlbmRQb2ludCl7XG4gICAgdGhpcy5lbmRQb2ludCA9IG51bGxcbiAgICB0aGlzLnRva2VuID0gbnVsbFxuICAgIHRoaXMuc2tpcEhlYXJ0YmVhdCA9IHRydWVcbiAgICB0aGlzLnJlcXMgPSBuZXcgU2V0KClcbiAgICB0aGlzLm9ub3BlbiA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbmNsb3NlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMucG9sbEVuZHBvaW50ID0gdGhpcy5ub3JtYWxpemVFbmRwb2ludChlbmRQb2ludClcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcbiAgICB0aGlzLnBvbGwoKVxuICB9XG5cbiAgbm9ybWFsaXplRW5kcG9pbnQoZW5kUG9pbnQpe1xuICAgIHJldHVybiAoZW5kUG9pbnRcbiAgICAgIC5yZXBsYWNlKFwid3M6Ly9cIiwgXCJodHRwOi8vXCIpXG4gICAgICAucmVwbGFjZShcIndzczovL1wiLCBcImh0dHBzOi8vXCIpXG4gICAgICAucmVwbGFjZShuZXcgUmVnRXhwKFwiKC4qKVxcL1wiICsgVFJBTlNQT1JUUy53ZWJzb2NrZXQpLCBcIiQxL1wiICsgVFJBTlNQT1JUUy5sb25ncG9sbCkpXG4gIH1cblxuICBlbmRwb2ludFVSTCgpe1xuICAgIHJldHVybiBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLnBvbGxFbmRwb2ludCwge3Rva2VuOiB0aGlzLnRva2VufSlcbiAgfVxuXG4gIGNsb3NlQW5kUmV0cnkoY29kZSwgcmVhc29uLCB3YXNDbGVhbil7XG4gICAgdGhpcy5jbG9zZShjb2RlLCByZWFzb24sIHdhc0NsZWFuKVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZ1xuICB9XG5cbiAgb250aW1lb3V0KCl7XG4gICAgdGhpcy5vbmVycm9yKFwidGltZW91dFwiKVxuICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDA1LCBcInRpbWVvdXRcIiwgZmFsc2UpXG4gIH1cblxuICBpc0FjdGl2ZSgpeyByZXR1cm4gdGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLm9wZW4gfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmcgfVxuXG4gIHBvbGwoKXtcbiAgICB0aGlzLmFqYXgoXCJHRVRcIiwgbnVsbCwgKCkgPT4gdGhpcy5vbnRpbWVvdXQoKSwgcmVzcCA9PiB7XG4gICAgICBpZihyZXNwKXtcbiAgICAgICAgdmFyIHtzdGF0dXMsIHRva2VuLCBtZXNzYWdlc30gPSByZXNwXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gMFxuICAgICAgfVxuXG4gICAgICBzd2l0Y2goc3RhdHVzKXtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgLy8gVGFza3MgYXJlIHdoYXQgdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIHNldFRpbWVvdXQgY2FsbGJhY2tzLFxuICAgICAgICAgICAgLy8gcHJvbWlzZSByZXNvbHZlcyBhbmQgbW9yZSBhcmUgcnVuIHdpdGhpbi5cbiAgICAgICAgICAgIC8vIEluIG1vZGVybiBicm93c2VycywgdGhlcmUgYXJlIHR3byBkaWZmZXJlbnQga2luZHMgb2YgdGFza3MsXG4gICAgICAgICAgICAvLyBtaWNyb3Rhc2tzIGFuZCBtYWNyb3Rhc2tzLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhcmUgbWFpbmx5IHVzZWQgZm9yIFByb21pc2VzLCB3aGlsZSBtYWNyb3Rhc2tzIGFyZVxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhbHdheXMgaGF2ZSBwcmlvcml0eSBvdmVyIG1hY3JvdGFza3MuIElmIHRoZSBKUyBlbmdpbmVcbiAgICAgICAgICAgIC8vIGlzIGxvb2tpbmcgZm9yIGEgdGFzayB0byBydW4sIGl0IHdpbGwgYWx3YXlzIHRyeSB0byBlbXB0eSB0aGVcbiAgICAgICAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byBydW4gYW55dGhpbmcgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIG1hY3JvdGFzayBxdWV1ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3IgdGhlIFdlYlNvY2tldCB0cmFuc3BvcnQsIG1lc3NhZ2VzIGFsd2F5cyBhcnJpdmUgaW4gdGhlaXIgb3duXG4gICAgICAgICAgICAvLyBldmVudC4gVGhpcyBtZWFucyB0aGF0IGlmIGFueSBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgZnJvbSB3aXRoaW4sXG4gICAgICAgICAgICAvLyB0aGVpciBjYWxsYmFja3Mgd2lsbCBhbHdheXMgZmluaXNoIGV4ZWN1dGlvbiBieSB0aGUgdGltZSB0aGVcbiAgICAgICAgICAgIC8vIG5leHQgbWVzc2FnZSBldmVudCBoYW5kbGVyIGlzIHJ1bi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBlbXVsYXRlIHRoaXMgYmVoYXZpb3VyLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBlYWNoXG4gICAgICAgICAgICAvLyBvbm1lc3NhZ2UgaGFuZGxlciBpcyBydW4gd2l0aGluIGl0J3Mgb3duIG1hY3JvdGFzay5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5vbm1lc3NhZ2Uoe2RhdGE6IG1zZ30pLCAwKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDEwOlxuICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMub3BlblxuICAgICAgICAgIHRoaXMub25vcGVuKHt9KVxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0MDM6XG4gICAgICAgICAgdGhpcy5vbmVycm9yKDQwMylcbiAgICAgICAgICB0aGlzLmNsb3NlKDEwMDgsIFwiZm9yYmlkZGVuXCIsIGZhbHNlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSA1MDA6XG4gICAgICAgICAgdGhpcy5vbmVycm9yKDUwMClcbiAgICAgICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoMTAxMSwgXCJpbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIiwgNTAwKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHBvbGwgc3RhdHVzICR7c3RhdHVzfWApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNlbmQoYm9keSl7XG4gICAgdGhpcy5hamF4KFwiUE9TVFwiLCBib2R5LCAoKSA9PiB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpLCByZXNwID0+IHtcbiAgICAgIGlmKCFyZXNwIHx8IHJlc3Auc3RhdHVzICE9PSAyMDApe1xuICAgICAgICB0aGlzLm9uZXJyb3IocmVzcCAmJiByZXNwLnN0YXR1cylcbiAgICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMTEsIFwiaW50ZXJuYWwgc2VydmVyIGVycm9yXCIsIGZhbHNlKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjbG9zZShjb2RlLCByZWFzb24sIHdhc0NsZWFuKXtcbiAgICBmb3IobGV0IHJlcSBvZiB0aGlzLnJlcXMpeyByZXEuYWJvcnQoKSB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jbG9zZWRcbiAgICBsZXQgb3B0cyA9IE9iamVjdC5hc3NpZ24oe2NvZGU6IDEwMDAsIHJlYXNvbjogdW5kZWZpbmVkLCB3YXNDbGVhbjogdHJ1ZX0sIHtjb2RlLCByZWFzb24sIHdhc0NsZWFufSlcbiAgICBpZih0eXBlb2YoQ2xvc2VFdmVudCkgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgdGhpcy5vbmNsb3NlKG5ldyBDbG9zZUV2ZW50KFwiY2xvc2VcIiwgb3B0cykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25jbG9zZShvcHRzKVxuICAgIH1cbiAgfVxuXG4gIGFqYXgobWV0aG9kLCBib2R5LCBvbkNhbGxlclRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICBsZXQgcmVxXG4gICAgbGV0IG9udGltZW91dCA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVxcy5kZWxldGUocmVxKVxuICAgICAgb25DYWxsZXJUaW1lb3V0KClcbiAgICB9XG4gICAgcmVxID0gQWpheC5yZXF1ZXN0KG1ldGhvZCwgdGhpcy5lbmRwb2ludFVSTCgpLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgYm9keSwgdGhpcy50aW1lb3V0LCBvbnRpbWVvdXQsIHJlc3AgPT4ge1xuICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyZXEpXG4gICAgICBpZih0aGlzLmlzQWN0aXZlKCkpeyBjYWxsYmFjayhyZXNwKSB9XG4gICAgfSlcbiAgICB0aGlzLnJlcXMuYWRkKHJlcSlcbiAgfVxufVxuIiwgIi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFByZXNlbmNlXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWwgLSBUaGUgQ2hhbm5lbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyxcbiAqICAgICAgICBmb3IgZXhhbXBsZSBge2V2ZW50czoge3N0YXRlOiBcInN0YXRlXCIsIGRpZmY6IFwiZGlmZlwifX1gXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZXNlbmNlIHtcblxuICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzID0ge30pe1xuICAgIGxldCBldmVudHMgPSBvcHRzLmV2ZW50cyB8fCB7c3RhdGU6IFwicHJlc2VuY2Vfc3RhdGVcIiwgZGlmZjogXCJwcmVzZW5jZV9kaWZmXCJ9XG4gICAgdGhpcy5zdGF0ZSA9IHt9XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWxcbiAgICB0aGlzLmpvaW5SZWYgPSBudWxsXG4gICAgdGhpcy5jYWxsZXIgPSB7XG4gICAgICBvbkpvaW46IGZ1bmN0aW9uICgpeyB9LFxuICAgICAgb25MZWF2ZTogZnVuY3Rpb24gKCl7IH0sXG4gICAgICBvblN5bmM6IGZ1bmN0aW9uICgpeyB9XG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5zdGF0ZSwgbmV3U3RhdGUgPT4ge1xuICAgICAgbGV0IHtvbkpvaW4sIG9uTGVhdmUsIG9uU3luY30gPSB0aGlzLmNhbGxlclxuXG4gICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuam9pblJlZigpXG4gICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpXG5cbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goZGlmZiA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpXG4gICAgICB9KVxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgICAgb25TeW5jKClcbiAgICB9KVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5kaWZmLCBkaWZmID0+IHtcbiAgICAgIGxldCB7b25Kb2luLCBvbkxlYXZlLCBvblN5bmN9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgaWYodGhpcy5pblBlbmRpbmdTeW5jU3RhdGUoKSl7XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpXG4gICAgICAgIG9uU3luYygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbihjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uSm9pbiA9IGNhbGxiYWNrIH1cblxuICBvbkxlYXZlKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25MZWF2ZSA9IGNhbGxiYWNrIH1cblxuICBvblN5bmMoY2FsbGJhY2speyB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjayB9XG5cbiAgbGlzdChieSl7IHJldHVybiBQcmVzZW5jZS5saXN0KHRoaXMuc3RhdGUsIGJ5KSB9XG5cbiAgaW5QZW5kaW5nU3luY1N0YXRlKCl7XG4gICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgKHRoaXMuam9pblJlZiAhPT0gdGhpcy5jaGFubmVsLmpvaW5SZWYoKSlcbiAgfVxuXG4gIC8vIGxvd2VyLWxldmVsIHB1YmxpYyBzdGF0aWMgQVBJXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlclxuICAgKiB3aXRoIHRoZSBjbGllbnQncyBzdGF0ZS4gQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW5cbiAgICogYmUgcHJvdmlkZWQgdG8gcmVhY3QgdG8gY2hhbmdlcyBpbiB0aGUgY2xpZW50J3MgbG9jYWwgcHJlc2VuY2VzIGFjcm9zc1xuICAgKiBkaXNjb25uZWN0cyBhbmQgcmVjb25uZWN0cyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBzeW5jU3RhdGUoY3VycmVudFN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKXtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmNsb25lKGN1cnJlbnRTdGF0ZSlcbiAgICBsZXQgam9pbnMgPSB7fVxuICAgIGxldCBsZWF2ZXMgPSB7fVxuXG4gICAgdGhpcy5tYXAoc3RhdGUsIChrZXksIHByZXNlbmNlKSA9PiB7XG4gICAgICBpZighbmV3U3RhdGVba2V5XSl7XG4gICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMubWFwKG5ld1N0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZSl7XG4gICAgICAgIGxldCBuZXdSZWZzID0gbmV3UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgY3VyUmVmcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICAgIGxldCBqb2luZWRNZXRhcyA9IG5ld1ByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IGN1clJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgbGV0IGxlZnRNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBuZXdSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIGlmKGpvaW5lZE1ldGFzLmxlbmd0aCA+IDApe1xuICAgICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZVxuICAgICAgICAgIGpvaW5zW2tleV0ubWV0YXMgPSBqb2luZWRNZXRhc1xuICAgICAgICB9XG4gICAgICAgIGlmKGxlZnRNZXRhcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICBsZWF2ZXNba2V5XSA9IHRoaXMuY2xvbmUoY3VycmVudFByZXNlbmNlKVxuICAgICAgICAgIGxlYXZlc1trZXldLm1ldGFzID0gbGVmdE1ldGFzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHtqb2luczogam9pbnMsIGxlYXZlczogbGVhdmVzfSwgb25Kb2luLCBvbkxlYXZlKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIFVzZWQgdG8gc3luYyBhIGRpZmYgb2YgcHJlc2VuY2Ugam9pbiBhbmQgbGVhdmVcbiAgICogZXZlbnRzIGZyb20gdGhlIHNlcnZlciwgYXMgdGhleSBoYXBwZW4uIExpa2UgYHN5bmNTdGF0ZWAsIGBzeW5jRGlmZmBcbiAgICogYWNjZXB0cyBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrcyB0byByZWFjdCB0byBhIHVzZXJcbiAgICogam9pbmluZyBvciBsZWF2aW5nIGZyb20gYSBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBzeW5jRGlmZihzdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKXtcbiAgICBsZXQge2pvaW5zLCBsZWF2ZXN9ID0gdGhpcy5jbG9uZShkaWZmKVxuICAgIGlmKCFvbkpvaW4peyBvbkpvaW4gPSBmdW5jdGlvbiAoKXsgfSB9XG4gICAgaWYoIW9uTGVhdmUpeyBvbkxlYXZlID0gZnVuY3Rpb24gKCl7IH0gfVxuXG4gICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmUobmV3UHJlc2VuY2UpXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2Upe1xuICAgICAgICBsZXQgam9pbmVkUmVmcyA9IHN0YXRlW2tleV0ubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgY3VyTWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gam9pbmVkUmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBzdGF0ZVtrZXldLm1ldGFzLnVuc2hpZnQoLi4uY3VyTWV0YXMpXG4gICAgICB9XG4gICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2UsIG5ld1ByZXNlbmNlKVxuICAgIH0pXG4gICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBpZighY3VycmVudFByZXNlbmNlKXsgcmV0dXJuIH1cbiAgICAgIGxldCByZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgY3VycmVudFByZXNlbmNlLm1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihwID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZnNUb1JlbW92ZS5pbmRleE9mKHAucGh4X3JlZikgPCAwXG4gICAgICB9KVxuICAgICAgb25MZWF2ZShrZXksIGN1cnJlbnRQcmVzZW5jZSwgbGVmdFByZXNlbmNlKVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlLm1ldGFzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZVtrZXldXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcmVzZW5jZXMsIHdpdGggc2VsZWN0ZWQgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVzZW5jZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hvb3NlclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgbGlzdChwcmVzZW5jZXMsIGNob29zZXIpe1xuICAgIGlmKCFjaG9vc2VyKXsgY2hvb3NlciA9IGZ1bmN0aW9uIChrZXksIHByZXMpeyByZXR1cm4gcHJlcyB9IH1cblxuICAgIHJldHVybiB0aGlzLm1hcChwcmVzZW5jZXMsIChrZXksIHByZXNlbmNlKSA9PiB7XG4gICAgICByZXR1cm4gY2hvb3NlcihrZXksIHByZXNlbmNlKVxuICAgIH0pXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgc3RhdGljIG1hcChvYmosIGZ1bmMpe1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcChrZXkgPT4gZnVuYyhrZXksIG9ialtrZXldKSlcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShvYmopeyByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKSB9XG59XG4iLCAiLyogVGhlIGRlZmF1bHQgc2VyaWFsaXplciBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIG1lc3NhZ2VzICovXG5pbXBvcnQge1xuICBDSEFOTkVMX0VWRU5UU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEhFQURFUl9MRU5HVEg6IDEsXG4gIE1FVEFfTEVOR1RIOiA0LFxuICBLSU5EUzoge3B1c2g6IDAsIHJlcGx5OiAxLCBicm9hZGNhc3Q6IDJ9LFxuXG4gIGVuY29kZShtc2csIGNhbGxiYWNrKXtcbiAgICBpZihtc2cucGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RW5jb2RlKG1zZykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXlsb2FkID0gW21zZy5qb2luX3JlZiwgbXNnLnJlZiwgbXNnLnRvcGljLCBtc2cuZXZlbnQsIG1zZy5wYXlsb2FkXVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgIH1cbiAgfSxcblxuICBkZWNvZGUocmF3UGF5bG9hZCwgY2FsbGJhY2spe1xuICAgIGlmKHJhd1BheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmJpbmFyeURlY29kZShyYXdQYXlsb2FkKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IFtqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWRdID0gSlNPTi5wYXJzZShyYXdQYXlsb2FkKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKHtqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWR9KVxuICAgIH1cbiAgfSxcblxuICAvLyBwcml2YXRlXG5cbiAgYmluYXJ5RW5jb2RlKG1lc3NhZ2Upe1xuICAgIGxldCB7am9pbl9yZWYsIHJlZiwgZXZlbnQsIHRvcGljLCBwYXlsb2FkfSA9IG1lc3NhZ2VcbiAgICBsZXQgbWV0YUxlbmd0aCA9IHRoaXMuTUVUQV9MRU5HVEggKyBqb2luX3JlZi5sZW5ndGggKyByZWYubGVuZ3RoICsgdG9waWMubGVuZ3RoICsgZXZlbnQubGVuZ3RoXG4gICAgbGV0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKVxuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGhlYWRlcilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdGhpcy5LSU5EUy5wdXNoKSAvLyBraW5kXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgam9pbl9yZWYubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHJlZi5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdG9waWMubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGV2ZW50Lmxlbmd0aClcbiAgICBBcnJheS5mcm9tKGpvaW5fcmVmLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbShyZWYsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKHRvcGljLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbShldmVudCwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuXG4gICAgdmFyIGNvbWJpbmVkID0gbmV3IFVpbnQ4QXJyYXkoaGVhZGVyLmJ5dGVMZW5ndGggKyBwYXlsb2FkLmJ5dGVMZW5ndGgpXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGhlYWRlciksIDApXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBoZWFkZXIuYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiBjb21iaW5lZC5idWZmZXJcbiAgfSxcblxuICBiaW5hcnlEZWNvZGUoYnVmZmVyKXtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXG4gICAgbGV0IGtpbmQgPSB2aWV3LmdldFVpbnQ4KDApXG4gICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5wdXNoOiByZXR1cm4gdGhpcy5kZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5yZXBseTogcmV0dXJuIHRoaXMuZGVjb2RlUmVwbHkoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICAgICAgY2FzZSB0aGlzLktJTkRTLmJyb2FkY2FzdDogcmV0dXJuIHRoaXMuZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICB9XG4gIH0sXG5cbiAgZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDMpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEggLSAxIC8vIHB1c2hlcyBoYXZlIG5vIHJlZlxuICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgcmV0dXJuIHtqb2luX3JlZjogam9pblJlZiwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YX1cbiAgfSxcblxuICBkZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgcmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgzKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDQpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEhcbiAgICBsZXQgam9pblJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGpvaW5SZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBqb2luUmVmU2l6ZVxuICAgIGxldCByZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyByZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyByZWZTaXplXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgbGV0IHBheWxvYWQgPSB7c3RhdHVzOiBldmVudCwgcmVzcG9uc2U6IGRhdGF9XG4gICAgcmV0dXJuIHtqb2luX3JlZjogam9pblJlZiwgcmVmOiByZWYsIHRvcGljOiB0b3BpYywgZXZlbnQ6IENIQU5ORUxfRVZFTlRTLnJlcGx5LCBwYXlsb2FkOiBwYXlsb2FkfVxuICB9LFxuXG4gIGRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMlxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuXG4gICAgcmV0dXJuIHtqb2luX3JlZjogbnVsbCwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YX1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIGdsb2JhbCxcbiAgcGh4V2luZG93LFxuICBDSEFOTkVMX0VWRU5UUyxcbiAgREVGQVVMVF9USU1FT1VULFxuICBERUZBVUxUX1ZTTixcbiAgU09DS0VUX1NUQVRFUyxcbiAgVFJBTlNQT1JUUyxcbiAgV1NfQ0xPU0VfTk9STUFMXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNsb3N1cmVcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQWpheCBmcm9tIFwiLi9hamF4XCJcbmltcG9ydCBDaGFubmVsIGZyb20gXCIuL2NoYW5uZWxcIlxuaW1wb3J0IExvbmdQb2xsIGZyb20gXCIuL2xvbmdwb2xsXCJcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gXCIuL3NlcmlhbGl6ZXJcIlxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL3RpbWVyXCJcblxuLyoqIEluaXRpYWxpemVzIHRoZSBTb2NrZXQgKlxuICpcbiAqIEZvciBJRTggc3VwcG9ydCB1c2UgYW4gRVM1LXNoaW0gKGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kUG9pbnQgLSBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIGBcIndzOi8vZXhhbXBsZS5jb20vc29ja2V0XCJgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIndzczovL2V4YW1wbGUuY29tXCJgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFwiL3NvY2tldFwiYCAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy50cmFuc3BvcnRdIC0gVGhlIFdlYnNvY2tldCBUcmFuc3BvcnQsIGZvciBleGFtcGxlIFdlYlNvY2tldCBvciBQaG9lbml4LkxvbmdQb2xsLlxuICpcbiAqIERlZmF1bHRzIHRvIFdlYlNvY2tldCB3aXRoIGF1dG9tYXRpYyBMb25nUG9sbCBmYWxsYmFjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmVuY29kZV0gLSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLlxuICpcbiAqIERlZmF1bHRzIHRvIEpTT04gZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5kZWNvZGVdIC0gVGhlIGZ1bmN0aW9uIHRvIGRlY29kZSBpbmNvbWluZyBtZXNzYWdlcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBKU09OOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIChwYXlsb2FkLCBjYWxsYmFjaykgPT4gY2FsbGJhY2soSlNPTi5wYXJzZShwYXlsb2FkKSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0XSAtIFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAqXG4gKiBEZWZhdWx0cyBgREVGQVVMVF9USU1FT1VUYFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlYXJ0YmVhdEludGVydmFsTXNdIC0gVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJlY29ubmVjdEFmdGVyTXNdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbGlzZWNcbiAqIHNvY2tldCByZWNvbm5lY3QgaW50ZXJ2YWwuXG4gKlxuICogRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMucmVqb2luQWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsaXNlY1xuICogcmVqb2luIGludGVydmFsIGZvciBpbmRpdmlkdWFsIGNoYW5uZWxzLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiB9XG4gKiBgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMubG9nZ2VyXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24oa2luZCwgbXNnLCBkYXRhKSB7XG4gKiAgIGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxvbmdwb2xsZXJUaW1lb3V0XSAtIFRoZSBtYXhpbXVtIHRpbWVvdXQgb2YgYSBsb25nIHBvbGwgQUpBWCByZXF1ZXN0LlxuICpcbiAqIERlZmF1bHRzIHRvIDIwcyAoZG91YmxlIHRoZSBzZXJ2ZXIgbG9uZyBwb2xsIHRpbWVyKS5cbiAqXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBbb3B0cy5wYXJhbXNdIC0gVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJpbmFyeVR5cGVdIC0gVGhlIGJpbmFyeSB0eXBlIHRvIHVzZSBmb3IgYmluYXJ5IFdlYlNvY2tldCBmcmFtZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gXCJhcnJheWJ1ZmZlclwiXG4gKlxuICogQHBhcmFtIHt2c259IFtvcHRzLnZzbl0gLSBUaGUgc2VyaWFsaXplcidzIHByb3RvY29sIHZlcnNpb24gdG8gc2VuZCBvbiBjb25uZWN0LlxuICpcbiAqIERlZmF1bHRzIHRvIERFRkFVTFRfVlNOLlxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRzID0ge30pe1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7b3BlbjogW10sIGNsb3NlOiBbXSwgZXJyb3I6IFtdLCBtZXNzYWdlOiBbXX1cbiAgICB0aGlzLmNoYW5uZWxzID0gW11cbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIHRoaXMucmVmID0gMFxuICAgIHRoaXMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVRcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG9wdHMudHJhbnNwb3J0IHx8IGdsb2JhbC5XZWJTb2NrZXQgfHwgTG9uZ1BvbGxcbiAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnMgPSAwXG4gICAgdGhpcy5kZWZhdWx0RW5jb2RlciA9IFNlcmlhbGl6ZXIuZW5jb2RlLmJpbmQoU2VyaWFsaXplcilcbiAgICB0aGlzLmRlZmF1bHREZWNvZGVyID0gU2VyaWFsaXplci5kZWNvZGUuYmluZChTZXJpYWxpemVyKVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5iaW5hcnlUeXBlID0gb3B0cy5iaW5hcnlUeXBlIHx8IFwiYXJyYXlidWZmZXJcIlxuICAgIHRoaXMuY29ubmVjdENsb2NrID0gMVxuICAgIGlmKHRoaXMudHJhbnNwb3J0ICE9PSBMb25nUG9sbCl7XG4gICAgICB0aGlzLmVuY29kZSA9IG9wdHMuZW5jb2RlIHx8IHRoaXMuZGVmYXVsdEVuY29kZXJcbiAgICAgIHRoaXMuZGVjb2RlID0gb3B0cy5kZWNvZGUgfHwgdGhpcy5kZWZhdWx0RGVjb2RlclxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuY29kZSA9IHRoaXMuZGVmYXVsdEVuY29kZXJcbiAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWZhdWx0RGVjb2RlclxuICAgIH1cbiAgICBsZXQgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGxcbiAgICBpZihwaHhXaW5kb3cgJiYgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIpe1xuICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfZSA9PiB7XG4gICAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gdGhpcy5jb25uZWN0Q2xvY2tcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwgX2UgPT4ge1xuICAgICAgICBpZihhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID09PSB0aGlzLmNvbm5lY3RDbG9jayl7XG4gICAgICAgICAgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGxcbiAgICAgICAgICB0aGlzLmNvbm5lY3QoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBvcHRzLmhlYXJ0YmVhdEludGVydmFsTXMgfHwgMzAwMDBcbiAgICB0aGlzLnJlam9pbkFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgIGlmKG9wdHMucmVqb2luQWZ0ZXJNcyl7XG4gICAgICAgIHJldHVybiBvcHRzLnJlam9pbkFmdGVyTXModHJpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEwMDAsIDIwMDAsIDUwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZWNvbm5lY3RBZnRlck1zID0gKHRyaWVzKSA9PiB7XG4gICAgICBpZihvcHRzLnJlY29ubmVjdEFmdGVyTXMpe1xuICAgICAgICByZXR1cm4gb3B0cy5yZWNvbm5lY3RBZnRlck1zKHRyaWVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBvcHRzLmxvZ2dlciB8fCBudWxsXG4gICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMjAwMDBcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pXG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLnZzbiA9IG9wdHMudnNuIHx8IERFRkFVTFRfVlNOXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lb3V0VGltZXIgPSBudWxsXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKVxuICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBMb25nUG9sbCB0cmFuc3BvcnQgcmVmZXJlbmNlXG4gICAqL1xuICBnZXRMb25nUG9sbFRyYW5zcG9ydCgpeyByZXR1cm4gTG9uZ1BvbGwgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyBhbmQgcmVwbGFjZXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3VHJhbnNwb3J0IC0gVGhlIG5ldyB0cmFuc3BvcnQgY2xhc3MgdG8gaW5zdGFudGlhdGVcbiAgICpcbiAgICovXG4gIHJlcGxhY2VUcmFuc3BvcnQobmV3VHJhbnNwb3J0KXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdXG4gICAgaWYodGhpcy5jb25uKXtcbiAgICAgIHRoaXMuY29ubi5jbG9zZSgpXG4gICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgfVxuICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc29ja2V0IHByb3RvY29sXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBwcm90b2NvbCgpeyByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL15odHRwcy8pID8gXCJ3c3NcIiA6IFwid3NcIiB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxseSBxdWFsaWZpZWQgc29ja2V0IHVybFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZW5kUG9pbnRVUkwoKXtcbiAgICBsZXQgdXJpID0gQWpheC5hcHBlbmRQYXJhbXMoXG4gICAgICBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCB0aGlzLnBhcmFtcygpKSwge3ZzbjogdGhpcy52c259KVxuICAgIGlmKHVyaS5jaGFyQXQoMCkgIT09IFwiL1wiKXsgcmV0dXJuIHVyaSB9XG4gICAgaWYodXJpLmNoYXJBdCgxKSA9PT0gXCIvXCIpeyByZXR1cm4gYCR7dGhpcy5wcm90b2NvbCgpfToke3VyaX1gIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9Oi8vJHtsb2NhdGlvbi5ob3N0fSR7dXJpfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0XG4gICAqXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXMgZm9yIHZhbGlkIHN0YXR1cyBjb2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgc29ja2V0IGlzIGRpc2Nvbm5lY3RlZC5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBjb2RlIC0gQSBzdGF0dXMgY29kZSBmb3IgZGlzY29ubmVjdGlvbiAoT3B0aW9uYWwpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gQSB0ZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSByZWFzb24gdG8gZGlzY29ubmVjdC4gKE9wdGlvbmFsKVxuICAgKi9cbiAgZGlzY29ubmVjdChjYWxsYmFjaywgY29kZSwgcmVhc29uKXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMudGVhcmRvd24oY2FsbGJhY2ssIGNvZGUsIHJlYXNvbilcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtcyB0byBzZW5kIHdoZW4gY29ubmVjdGluZywgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiB1c2VyVG9rZW59YFxuICAgKlxuICAgKiBQYXNzaW5nIHBhcmFtcyB0byBjb25uZWN0IGlzIGRlcHJlY2F0ZWQ7IHBhc3MgdGhlbSBpbiB0aGUgU29ja2V0IGNvbnN0cnVjdG9yIGluc3RlYWQ6XG4gICAqIGBuZXcgU29ja2V0KFwiL3NvY2tldFwiLCB7cGFyYW1zOiB7dXNlcl9pZDogdXNlclRva2VufX0pYC5cbiAgICovXG4gIGNvbm5lY3QocGFyYW1zKXtcbiAgICBpZihwYXJhbXMpe1xuICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcInBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBwYXNzIDpwYXJhbXMgdG8gdGhlIFNvY2tldCBjb25zdHJ1Y3RvclwiKVxuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcylcbiAgICB9XG4gICAgaWYodGhpcy5jb25uKXsgcmV0dXJuIH1cblxuICAgIHRoaXMuY29ubmVjdENsb2NrKytcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZFBvaW50VVJMKCkpXG4gICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSB0aGlzLmJpbmFyeVR5cGVcbiAgICB0aGlzLmNvbm4udGltZW91dCA9IHRoaXMubG9uZ3BvbGxlclRpbWVvdXRcbiAgICB0aGlzLmNvbm4ub25vcGVuID0gKCkgPT4gdGhpcy5vbkNvbm5PcGVuKClcbiAgICB0aGlzLmNvbm4ub25lcnJvciA9IGVycm9yID0+IHRoaXMub25Db25uRXJyb3IoZXJyb3IpXG4gICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IGV2ZW50ID0+IHRoaXMub25Db25uTWVzc2FnZShldmVudClcbiAgICB0aGlzLmNvbm4ub25jbG9zZSA9IGV2ZW50ID0+IHRoaXMub25Db25uQ2xvc2UoZXZlbnQpXG4gIH1cblxuICAvKipcbiAgICogTG9ncyB0aGUgbWVzc2FnZS4gT3ZlcnJpZGUgYHRoaXMubG9nZ2VyYCBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZy4gbm9vcHMgYnkgZGVmYXVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXNnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBsb2coa2luZCwgbXNnLCBkYXRhKXsgdGhpcy5sb2dnZXIoa2luZCwgbXNnLCBkYXRhKSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGxvZ2dlciBoYXMgYmVlbiBzZXQgb24gdGhpcyBzb2NrZXQuXG4gICAqL1xuICBoYXNMb2dnZXIoKXsgcmV0dXJuIHRoaXMubG9nZ2VyICE9PSBudWxsIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBvcGVuIGV2ZW50c1xuICAgKlxuICAgKiBAZXhhbXBsZSBzb2NrZXQub25PcGVuKGZ1bmN0aW9uKCl7IGNvbnNvbGUuaW5mbyhcInRoZSBzb2NrZXQgd2FzIG9wZW5lZFwiKSB9KVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25PcGVuKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4ucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gY2xvc2UgZXZlbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkNsb3NlKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLnB1c2goW3JlZiwgY2FsbGJhY2tdKVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIGVycm9yIGV2ZW50c1xuICAgKlxuICAgKiBAZXhhbXBsZSBzb2NrZXQub25FcnJvcihmdW5jdGlvbihlcnJvcil7IGFsZXJ0KFwiQW4gZXJyb3Igb2NjdXJyZWRcIikgfSlcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uRXJyb3IoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gbWVzc2FnZSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uTWVzc2FnZShjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLnB1c2goW3JlZiwgY2FsbGJhY2tdKVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBQaW5ncyB0aGUgc2VydmVyIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBSVFQgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGluZyB3YXMgcHVzaGVkIG9yIGZhbHNlIGlmIHVuYWJsZSB0byBiZSBwdXNoZWQuXG4gICAqL1xuICBwaW5nKGNhbGxiYWNrKXtcbiAgICBpZighdGhpcy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIHRoaXMucHVzaCh7dG9waWM6IFwicGhvZW5peFwiLCBldmVudDogXCJoZWFydGJlYXRcIiwgcGF5bG9hZDoge30sIHJlZjogcmVmfSlcbiAgICBsZXQgb25Nc2dSZWYgPSB0aGlzLm9uTWVzc2FnZShtc2cgPT4ge1xuICAgICAgaWYobXNnLnJlZiA9PT0gcmVmKXtcbiAgICAgICAgdGhpcy5vZmYoW29uTXNnUmVmXSlcbiAgICAgICAgY2FsbGJhY2soRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgY2xlYXJIZWFydGJlYXRzKCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZW91dFRpbWVyKVxuICB9XG5cbiAgb25Db25uT3Blbigpe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBjb25uZWN0ZWQgdG8gJHt0aGlzLmVuZFBvaW50VVJMKCl9YClcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucysrXG4gICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMucmVzZXRIZWFydGJlYXQoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IGNhbGxiYWNrKCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgaGVhcnRiZWF0VGltZW91dCgpe1xuICAgIGlmKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZil7XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKXsgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblwiKSB9XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICAgIHRoaXMudGVhcmRvd24oKCkgPT4gdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSwgV1NfQ0xPU0VfTk9STUFMLCBcImhlYXJ0YmVhdCB0aW1lb3V0XCIpXG4gICAgfVxuICB9XG5cbiAgcmVzZXRIZWFydGJlYXQoKXtcbiAgICBpZih0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnNraXBIZWFydGJlYXQpeyByZXR1cm4gfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICB0aGlzLmNsZWFySGVhcnRiZWF0cygpXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgfVxuXG4gIHRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pe1xuICAgIGlmKCF0aGlzLmNvbm4pe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB0aGlzLndhaXRGb3JCdWZmZXJEb25lKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgIGlmKGNvZGUpeyB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uIHx8IFwiXCIpIH0gZWxzZSB7IHRoaXMuY29ubi5jbG9zZSgpIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKCgpID0+IHtcbiAgICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgICB0aGlzLmNvbm4ub25vcGVuID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgd2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzID0gMSl7XG4gICAgaWYodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCAhdGhpcy5jb25uLmJ1ZmZlcmVkQW1vdW50KXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgd2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgPSAxKXtcbiAgICBpZih0cmllcyA9PT0gNSB8fCAhdGhpcy5jb25uIHx8IHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNsb3NlZCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgb25Db25uQ2xvc2UoZXZlbnQpe1xuICAgIGxldCBjbG9zZUNvZGUgPSBldmVudCAmJiBldmVudC5jb2RlXG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJjbG9zZVwiLCBldmVudClcbiAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIHRoaXMuY2xlYXJIZWFydGJlYXRzKClcbiAgICBpZighdGhpcy5jbG9zZVdhc0NsZWFuICYmIGNsb3NlQ29kZSAhPT0gMTAwMCl7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjayhldmVudCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uQ29ubkVycm9yKGVycm9yKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBlcnJvcilcbiAgICBsZXQgdHJhbnNwb3J0QmVmb3JlID0gdGhpcy50cmFuc3BvcnRcbiAgICBsZXQgZXN0YWJsaXNoZWRCZWZvcmUgPSB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnNcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIHRyYW5zcG9ydEJlZm9yZSwgZXN0YWJsaXNoZWRCZWZvcmUpXG4gICAgfSlcbiAgICBpZih0cmFuc3BvcnRCZWZvcmUgPT09IHRoaXMudHJhbnNwb3J0IHx8IGVzdGFibGlzaGVkQmVmb3JlID4gMCl7XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlckNoYW5FcnJvcigpe1xuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgIGlmKCEoY2hhbm5lbC5pc0Vycm9yZWQoKSB8fCBjaGFubmVsLmlzTGVhdmluZygpIHx8IGNoYW5uZWwuaXNDbG9zZWQoKSkpe1xuICAgICAgICBjaGFubmVsLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCl7XG4gICAgc3dpdGNoKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSl7XG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzogcmV0dXJuIFwiY29ubmVjdGluZ1wiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMub3BlbjogcmV0dXJuIFwib3BlblwiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzogcmV0dXJuIFwiY2xvc2luZ1wiXG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJjbG9zZWRcIlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBcIm9wZW5cIiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q2hhbm5lbH1cbiAgICovXG4gIHJlbW92ZShjaGFubmVsKXtcbiAgICB0aGlzLm9mZihjaGFubmVsLnN0YXRlQ2hhbmdlUmVmcylcbiAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5maWx0ZXIoYyA9PiBjLmpvaW5SZWYoKSAhPT0gY2hhbm5lbC5qb2luUmVmKCkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBgb25PcGVuYCwgYG9uQ2xvc2VgLCBgb25FcnJvcixgIGFuZCBgb25NZXNzYWdlYCByZWdpc3RyYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge3JlZnN9IC0gbGlzdCBvZiByZWZzIHJldHVybmVkIGJ5IGNhbGxzIHRvXG4gICAqICAgICAgICAgICAgICAgICBgb25PcGVuYCwgYG9uQ2xvc2VgLCBgb25FcnJvcixgIGFuZCBgb25NZXNzYWdlYFxuICAgKi9cbiAgb2ZmKHJlZnMpe1xuICAgIGZvcihsZXQga2V5IGluIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mpe1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldLmZpbHRlcigoW3JlZl0pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZnMuaW5kZXhPZihyZWYpID09PSAtMVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgbmV3IGNoYW5uZWwgZm9yIHRoZSBnaXZlbiB0b3BpY1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5QYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgY2hhbm5lbFxuICAgKiBAcmV0dXJucyB7Q2hhbm5lbH1cbiAgICovXG4gIGNoYW5uZWwodG9waWMsIGNoYW5QYXJhbXMgPSB7fSl7XG4gICAgbGV0IGNoYW4gPSBuZXcgQ2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcywgdGhpcylcbiAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbilcbiAgICByZXR1cm4gY2hhblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBwdXNoKGRhdGEpe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpe1xuICAgICAgbGV0IHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWZ9ID0gZGF0YVxuICAgICAgdGhpcy5sb2coXCJwdXNoXCIsIGAke3RvcGljfSAke2V2ZW50fSAoJHtqb2luX3JlZn0sICR7cmVmfSlgLCBwYXlsb2FkKVxuICAgIH1cblxuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSl7XG4gICAgICB0aGlzLmVuY29kZShkYXRhLCByZXN1bHQgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goKCkgPT4gdGhpcy5lbmNvZGUoZGF0YSwgcmVzdWx0ID0+IHRoaXMuY29ubi5zZW5kKHJlc3VsdCkpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5leHQgbWVzc2FnZSByZWYsIGFjY291bnRpbmcgZm9yIG92ZXJmbG93c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgbWFrZVJlZigpe1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDFcbiAgICBpZihuZXdSZWYgPT09IHRoaXMucmVmKXsgdGhpcy5yZWYgPSAwIH0gZWxzZSB7IHRoaXMucmVmID0gbmV3UmVmIH1cblxuICAgIHJldHVybiB0aGlzLnJlZi50b1N0cmluZygpXG4gIH1cblxuICBzZW5kSGVhcnRiZWF0KCl7XG4gICAgaWYodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmICYmICF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5wdXNoKHt0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWZ9KVxuICAgIHRoaXMuaGVhcnRiZWF0VGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhlYXJ0YmVhdFRpbWVvdXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICB9XG5cbiAgZmx1c2hTZW5kQnVmZmVyKCl7XG4gICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKXtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpXG4gICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSl7XG4gICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCBtc2cgPT4ge1xuICAgICAgbGV0IHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWZ9ID0gbXNnXG4gICAgICBpZihyZWYgJiYgcmVmID09PSB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpe1xuICAgICAgICB0aGlzLmNsZWFySGVhcnRiZWF0cygpXG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJyZWNlaXZlXCIsIGAke3BheWxvYWQuc3RhdHVzIHx8IFwiXCJ9ICR7dG9waWN9ICR7ZXZlbnR9ICR7cmVmICYmIFwiKFwiICsgcmVmICsgXCIpXCIgfHwgXCJcIn1gLCBwYXlsb2FkKVxuXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldXG4gICAgICAgIGlmKCFjaGFubmVsLmlzTWVtYmVyKHRvcGljLCBldmVudCwgcGF5bG9hZCwgam9pbl9yZWYpKXsgY29udGludWUgfVxuICAgICAgICBjaGFubmVsLnRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWYpXG4gICAgICB9XG5cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UubGVuZ3RoOyBpKyspe1xuICAgICAgICBsZXQgWywgY2FsbGJhY2tdID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlW2ldXG4gICAgICAgIGNhbGxiYWNrKG1zZylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgbGVhdmVPcGVuVG9waWModG9waWMpe1xuICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKGMgPT4gYy50b3BpYyA9PT0gdG9waWMgJiYgKGMuaXNKb2luZWQoKSB8fCBjLmlzSm9pbmluZygpKSlcbiAgICBpZihkdXBDaGFubmVsKXtcbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKVxuICAgICAgZHVwQ2hhbm5lbC5sZWF2ZSgpXG4gICAgfVxuICB9XG59IiwgIlxuZXhwb3J0IGNvbnN0IENPTlNFQ1VUSVZFX1JFTE9BRFMgPSBcImNvbnNlY3V0aXZlLXJlbG9hZHNcIlxuZXhwb3J0IGNvbnN0IE1BWF9SRUxPQURTID0gMTBcbmV4cG9ydCBjb25zdCBSRUxPQURfSklUVEVSX01JTiA9IDUwMDBcbmV4cG9ydCBjb25zdCBSRUxPQURfSklUVEVSX01BWCA9IDEwMDAwXG5leHBvcnQgY29uc3QgRkFJTFNBRkVfSklUVEVSID0gMzAwMDBcbmV4cG9ydCBjb25zdCBQSFhfRVZFTlRfQ0xBU1NFUyA9IFtcbiAgXCJwaHgtY2xpY2stbG9hZGluZ1wiLCBcInBoeC1jaGFuZ2UtbG9hZGluZ1wiLCBcInBoeC1zdWJtaXQtbG9hZGluZ1wiLFxuICBcInBoeC1rZXlkb3duLWxvYWRpbmdcIiwgXCJwaHgta2V5dXAtbG9hZGluZ1wiLCBcInBoeC1ibHVyLWxvYWRpbmdcIiwgXCJwaHgtZm9jdXMtbG9hZGluZ1wiXG5dXG5leHBvcnQgY29uc3QgUEhYX0NPTVBPTkVOVCA9IFwiZGF0YS1waHgtY29tcG9uZW50XCJcbmV4cG9ydCBjb25zdCBQSFhfTElWRV9MSU5LID0gXCJkYXRhLXBoeC1saW5rXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJBQ0tfU1RBVElDID0gXCJ0cmFjay1zdGF0aWNcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSU5LX1NUQVRFID0gXCJkYXRhLXBoeC1saW5rLXN0YXRlXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVGID0gXCJkYXRhLXBoeC1yZWZcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUZfU1JDID0gXCJkYXRhLXBoeC1yZWYtc3JjXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJBQ0tfVVBMT0FEUyA9IFwidHJhY2stdXBsb2Fkc1wiXG5leHBvcnQgY29uc3QgUEhYX1VQTE9BRF9SRUYgPSBcImRhdGEtcGh4LXVwbG9hZC1yZWZcIlxuZXhwb3J0IGNvbnN0IFBIWF9QUkVGTElHSFRFRF9SRUZTID0gXCJkYXRhLXBoeC1wcmVmbGlnaHRlZC1yZWZzXCJcbmV4cG9ydCBjb25zdCBQSFhfRE9ORV9SRUZTID0gXCJkYXRhLXBoeC1kb25lLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9EUk9QX1RBUkdFVCA9IFwiZHJvcC10YXJnZXRcIlxuZXhwb3J0IGNvbnN0IFBIWF9BQ1RJVkVfRU5UUllfUkVGUyA9IFwiZGF0YS1waHgtYWN0aXZlLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCA9IFwicGh4OmxpdmUtZmlsZTp1cGRhdGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfU0tJUCA9IFwiZGF0YS1waHgtc2tpcFwiXG5leHBvcnQgY29uc3QgUEhYX1BSVU5FID0gXCJkYXRhLXBoeC1wcnVuZVwiXG5leHBvcnQgY29uc3QgUEhYX1BBR0VfTE9BRElORyA9IFwicGFnZS1sb2FkaW5nXCJcbmV4cG9ydCBjb25zdCBQSFhfQ09OTkVDVEVEX0NMQVNTID0gXCJwaHgtY29ubmVjdGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQ09OTkVDVEVEX0NMQVNTID0gXCJwaHgtbG9hZGluZ1wiXG5leHBvcnQgY29uc3QgUEhYX05PX0ZFRURCQUNLX0NMQVNTID0gXCJwaHgtbm8tZmVlZGJhY2tcIlxuZXhwb3J0IGNvbnN0IFBIWF9FUlJPUl9DTEFTUyA9IFwicGh4LWVycm9yXCJcbmV4cG9ydCBjb25zdCBQSFhfUEFSRU5UX0lEID0gXCJkYXRhLXBoeC1wYXJlbnQtaWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9NQUlOID0gXCJkYXRhLXBoeC1tYWluXCJcbmV4cG9ydCBjb25zdCBQSFhfUk9PVF9JRCA9IFwiZGF0YS1waHgtcm9vdC1pZFwiXG5leHBvcnQgY29uc3QgUEhYX1RSSUdHRVJfQUNUSU9OID0gXCJ0cmlnZ2VyLWFjdGlvblwiXG5leHBvcnQgY29uc3QgUEhYX0ZFRURCQUNLX0ZPUiA9IFwiZmVlZGJhY2stZm9yXCJcbmV4cG9ydCBjb25zdCBQSFhfSEFTX0ZPQ1VTRUQgPSBcInBoeC1oYXMtZm9jdXNlZFwiXG5leHBvcnQgY29uc3QgRk9DVVNBQkxFX0lOUFVUUyA9IFtcInRleHRcIiwgXCJ0ZXh0YXJlYVwiLCBcIm51bWJlclwiLCBcImVtYWlsXCIsIFwicGFzc3dvcmRcIiwgXCJzZWFyY2hcIiwgXCJ0ZWxcIiwgXCJ1cmxcIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsIFwiY29sb3JcIiwgXCJyYW5nZVwiXVxuZXhwb3J0IGNvbnN0IENIRUNLQUJMRV9JTlBVVFMgPSBbXCJjaGVja2JveFwiLCBcInJhZGlvXCJdXG5leHBvcnQgY29uc3QgUEhYX0hBU19TVUJNSVRURUQgPSBcInBoeC1oYXMtc3VibWl0dGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfU0VTU0lPTiA9IFwiZGF0YS1waHgtc2Vzc2lvblwiXG5leHBvcnQgY29uc3QgUEhYX1ZJRVdfU0VMRUNUT1IgPSBgWyR7UEhYX1NFU1NJT059XWBcbmV4cG9ydCBjb25zdCBQSFhfU1RJQ0tZID0gXCJkYXRhLXBoeC1zdGlja3lcIlxuZXhwb3J0IGNvbnN0IFBIWF9TVEFUSUMgPSBcImRhdGEtcGh4LXN0YXRpY1wiXG5leHBvcnQgY29uc3QgUEhYX1JFQURPTkxZID0gXCJkYXRhLXBoeC1yZWFkb25seVwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVEID0gXCJkYXRhLXBoeC1kaXNhYmxlZFwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVfV0lUSCA9IFwiZGlzYWJsZS13aXRoXCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUgPSBcImRhdGEtcGh4LWRpc2FibGUtd2l0aC1yZXN0b3JlXCJcbmV4cG9ydCBjb25zdCBQSFhfSE9PSyA9IFwiaG9va1wiXG5leHBvcnQgY29uc3QgUEhYX0RFQk9VTkNFID0gXCJkZWJvdW5jZVwiXG5leHBvcnQgY29uc3QgUEhYX1RIUk9UVExFID0gXCJ0aHJvdHRsZVwiXG5leHBvcnQgY29uc3QgUEhYX1VQREFURSA9IFwidXBkYXRlXCJcbmV4cG9ydCBjb25zdCBQSFhfS0VZID0gXCJrZXlcIlxuZXhwb3J0IGNvbnN0IFBIWF9QUklWQVRFID0gXCJwaHhQcml2YXRlXCJcbmV4cG9ydCBjb25zdCBQSFhfQVVUT19SRUNPVkVSID0gXCJhdXRvLXJlY292ZXJcIlxuZXhwb3J0IGNvbnN0IFBIWF9MVl9ERUJVRyA9IFwicGh4OmxpdmUtc29ja2V0OmRlYnVnXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfUFJPRklMRSA9IFwicGh4OmxpdmUtc29ja2V0OnByb2ZpbGluZ1wiXG5leHBvcnQgY29uc3QgUEhYX0xWX0xBVEVOQ1lfU0lNID0gXCJwaHg6bGl2ZS1zb2NrZXQ6bGF0ZW5jeS1zaW1cIlxuZXhwb3J0IGNvbnN0IFBIWF9QUk9HUkVTUyA9IFwicHJvZ3Jlc3NcIlxuZXhwb3J0IGNvbnN0IExPQURFUl9USU1FT1VUID0gMVxuZXhwb3J0IGNvbnN0IEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQgPSAyMDBcbmV4cG9ydCBjb25zdCBCSU5ESU5HX1BSRUZJWCA9IFwicGh4LVwiXG5leHBvcnQgY29uc3QgUFVTSF9USU1FT1VUID0gMzAwMDBcbmV4cG9ydCBjb25zdCBMSU5LX0hFQURFUiA9IFwieC1yZXF1ZXN0ZWQtd2l0aFwiXG5leHBvcnQgY29uc3QgUkVTUE9OU0VfVVJMX0hFQURFUiA9IFwieC1yZXNwb25zZS11cmxcIlxuZXhwb3J0IGNvbnN0IERFQk9VTkNFX1RSSUdHRVIgPSBcImRlYm91bmNlLXRyaWdnZXJcIlxuZXhwb3J0IGNvbnN0IFRIUk9UVExFRCA9IFwidGhyb3R0bGVkXCJcbmV4cG9ydCBjb25zdCBERUJPVU5DRV9QUkVWX0tFWSA9IFwiZGVib3VuY2UtcHJldi1rZXlcIlxuZXhwb3J0IGNvbnN0IERFRkFVTFRTID0ge1xuICBkZWJvdW5jZTogMzAwLFxuICB0aHJvdHRsZTogMzAwXG59XG5cbi8vIFJlbmRlcmVkXG5leHBvcnQgY29uc3QgRFlOQU1JQ1MgPSBcImRcIlxuZXhwb3J0IGNvbnN0IFNUQVRJQyA9IFwic1wiXG5leHBvcnQgY29uc3QgQ09NUE9ORU5UUyA9IFwiY1wiXG5leHBvcnQgY29uc3QgRVZFTlRTID0gXCJlXCJcbmV4cG9ydCBjb25zdCBSRVBMWSA9IFwiclwiXG5leHBvcnQgY29uc3QgVElUTEUgPSBcInRcIlxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFUyA9IFwicFwiXG4iLCAiaW1wb3J0IHtcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRyeVVwbG9hZGVyIHtcbiAgY29uc3RydWN0b3IoZW50cnksIGNodW5rU2l6ZSwgbGl2ZVNvY2tldCl7XG4gICAgdGhpcy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuICAgIHRoaXMuZW50cnkgPSBlbnRyeVxuICAgIHRoaXMub2Zmc2V0ID0gMFxuICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplXG4gICAgdGhpcy5jaHVua1RpbWVyID0gbnVsbFxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbCA9IGxpdmVTb2NrZXQuY2hhbm5lbChgbHZ1OiR7ZW50cnkucmVmfWAsIHt0b2tlbjogZW50cnkubWV0YWRhdGEoKX0pXG4gIH1cblxuICBlcnJvcihyZWFzb24pe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmNodW5rVGltZXIpXG4gICAgdGhpcy51cGxvYWRDaGFubmVsLmxlYXZlKClcbiAgICB0aGlzLmVudHJ5LmVycm9yKHJlYXNvbilcbiAgfVxuXG4gIHVwbG9hZCgpe1xuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5vbkVycm9yKHJlYXNvbiA9PiB0aGlzLmVycm9yKHJlYXNvbikpXG4gICAgdGhpcy51cGxvYWRDaGFubmVsLmpvaW4oKVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCBfZGF0YSA9PiB0aGlzLnJlYWROZXh0Q2h1bmsoKSlcbiAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgcmVhc29uID0+IHRoaXMuZXJyb3IocmVhc29uKSlcbiAgfVxuXG4gIGlzRG9uZSgpeyByZXR1cm4gdGhpcy5vZmZzZXQgPj0gdGhpcy5lbnRyeS5maWxlLnNpemUgfVxuXG4gIHJlYWROZXh0Q2h1bmsoKXtcbiAgICBsZXQgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKClcbiAgICBsZXQgYmxvYiA9IHRoaXMuZW50cnkuZmlsZS5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5jaHVua1NpemUgKyB0aGlzLm9mZnNldClcbiAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgIGlmKGUudGFyZ2V0LmVycm9yID09PSBudWxsKXtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gZS50YXJnZXQucmVzdWx0LmJ5dGVMZW5ndGhcbiAgICAgICAgdGhpcy5wdXNoQ2h1bmsoZS50YXJnZXQucmVzdWx0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvZ0Vycm9yKFwiUmVhZCBlcnJvcjogXCIgKyBlLnRhcmdldC5lcnJvcilcbiAgICAgIH1cbiAgICB9XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gIH1cblxuICBwdXNoQ2h1bmsoY2h1bmspe1xuICAgIGlmKCF0aGlzLnVwbG9hZENoYW5uZWwuaXNKb2luZWQoKSl7IHJldHVybiB9XG4gICAgdGhpcy51cGxvYWRDaGFubmVsLnB1c2goXCJjaHVua1wiLCBjaHVuaylcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmVudHJ5LnByb2dyZXNzKCh0aGlzLm9mZnNldCAvIHRoaXMuZW50cnkuZmlsZS5zaXplKSAqIDEwMClcbiAgICAgICAgaWYoIXRoaXMuaXNEb25lKCkpe1xuICAgICAgICAgIHRoaXMuY2h1bmtUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWFkTmV4dENodW5rKCksIHRoaXMubGl2ZVNvY2tldC5nZXRMYXRlbmN5U2ltKCkgfHwgMClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFBIWF9WSUVXX1NFTEVDVE9SXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBFbnRyeVVwbG9hZGVyIGZyb20gXCIuL2VudHJ5X3VwbG9hZGVyXCJcblxuZXhwb3J0IGxldCBsb2dFcnJvciA9IChtc2csIG9iaikgPT4gY29uc29sZS5lcnJvciAmJiBjb25zb2xlLmVycm9yKG1zZywgb2JqKVxuXG5leHBvcnQgbGV0IGlzQ2lkID0gKGNpZCkgPT4ge1xuICBsZXQgdHlwZSA9IHR5cGVvZihjaWQpXG4gIHJldHVybiB0eXBlID09PSBcIm51bWJlclwiIHx8ICh0eXBlID09PSBcInN0cmluZ1wiICYmIC9eKDB8WzEtOV1cXGQqKSQvLnRlc3QoY2lkKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdER1cGxpY2F0ZUlkcygpe1xuICBsZXQgaWRzID0gbmV3IFNldCgpXG4gIGxldCBlbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkXVwiKVxuICBmb3IobGV0IGkgPSAwLCBsZW4gPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgaWYoaWRzLmhhcyhlbGVtc1tpXS5pZCkpe1xuICAgICAgY29uc29sZS5lcnJvcihgTXVsdGlwbGUgSURzIGRldGVjdGVkOiAke2VsZW1zW2ldLmlkfS4gRW5zdXJlIHVuaXF1ZSBlbGVtZW50IGlkcy5gKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZHMuYWRkKGVsZW1zW2ldLmlkKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgbGV0IGRlYnVnID0gKHZpZXcsIGtpbmQsIG1zZywgb2JqKSA9PiB7XG4gIGlmKHZpZXcubGl2ZVNvY2tldC5pc0RlYnVnRW5hYmxlZCgpKXtcbiAgICBjb25zb2xlLmxvZyhgJHt2aWV3LmlkfSAke2tpbmR9OiAke21zZ30gLSBgLCBvYmopXG4gIH1cbn1cblxuLy8gd3JhcHMgdmFsdWUgaW4gY2xvc3VyZSBvciByZXR1cm5zIGNsb3N1cmVcbmV4cG9ydCBsZXQgY2xvc3VyZSA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiA/IHZhbCA6IGZ1bmN0aW9uICgpeyByZXR1cm4gdmFsIH1cblxuZXhwb3J0IGxldCBjbG9uZSA9IChvYmopID0+IHsgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkgfVxuXG5leHBvcnQgbGV0IGNsb3Nlc3RQaHhCaW5kaW5nID0gKGVsLCBiaW5kaW5nLCBib3JkZXJFbCkgPT4ge1xuICBkbyB7XG4gICAgaWYoZWwubWF0Y2hlcyhgWyR7YmluZGluZ31dYCkpeyByZXR1cm4gZWwgfVxuICAgIGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlXG4gIH0gd2hpbGUoZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEgJiYgISgoYm9yZGVyRWwgJiYgYm9yZGVyRWwuaXNTYW1lTm9kZShlbCkpIHx8IGVsLm1hdGNoZXMoUEhYX1ZJRVdfU0VMRUNUT1IpKSlcbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGxldCBpc09iamVjdCA9IChvYmopID0+IHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmICEob2JqIGluc3RhbmNlb2YgQXJyYXkpXG59XG5cbmV4cG9ydCBsZXQgaXNFcXVhbE9iaiA9IChvYmoxLCBvYmoyKSA9PiBKU09OLnN0cmluZ2lmeShvYmoxKSA9PT0gSlNPTi5zdHJpbmdpZnkob2JqMilcblxuZXhwb3J0IGxldCBpc0VtcHR5ID0gKG9iaikgPT4ge1xuICBmb3IobGV0IHggaW4gb2JqKXsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0IGxldCBtYXliZSA9IChlbCwgY2FsbGJhY2spID0+IGVsICYmIGNhbGxiYWNrKGVsKVxuXG5leHBvcnQgbGV0IGNoYW5uZWxVcGxvYWRlciA9IGZ1bmN0aW9uIChlbnRyaWVzLCBvbkVycm9yLCByZXNwLCBsaXZlU29ja2V0KXtcbiAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICBsZXQgZW50cnlVcGxvYWRlciA9IG5ldyBFbnRyeVVwbG9hZGVyKGVudHJ5LCByZXNwLmNvbmZpZy5jaHVua19zaXplLCBsaXZlU29ja2V0KVxuICAgIGVudHJ5VXBsb2FkZXIudXBsb2FkKClcbiAgfSlcbn1cbiIsICJsZXQgQnJvd3NlciA9IHtcbiAgY2FuUHVzaFN0YXRlKCl7IHJldHVybiAodHlwZW9mIChoaXN0b3J5LnB1c2hTdGF0ZSkgIT09IFwidW5kZWZpbmVkXCIpIH0sXG5cbiAgZHJvcExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpe1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KSlcbiAgfSxcblxuICB1cGRhdGVMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5LCBpbml0aWFsLCBmdW5jKXtcbiAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0TG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSlcbiAgICBsZXQga2V5ID0gdGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSlcbiAgICBsZXQgbmV3VmFsID0gY3VycmVudCA9PT0gbnVsbCA/IGluaXRpYWwgOiBmdW5jKGN1cnJlbnQpXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShuZXdWYWwpKVxuICAgIHJldHVybiBuZXdWYWxcbiAgfSxcblxuICBnZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KXtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KSkpXG4gIH0sXG5cbiAgdXBkYXRlQ3VycmVudFN0YXRlKGNhbGxiYWNrKXtcbiAgICBpZighdGhpcy5jYW5QdXNoU3RhdGUoKSl7IHJldHVybiB9XG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY2FsbGJhY2soaGlzdG9yeS5zdGF0ZSB8fCB7fSksIFwiXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICB9LFxuXG4gIHB1c2hTdGF0ZShraW5kLCBtZXRhLCB0byl7XG4gICAgaWYodGhpcy5jYW5QdXNoU3RhdGUoKSl7XG4gICAgICBpZih0byAhPT0gd2luZG93LmxvY2F0aW9uLmhyZWYpe1xuICAgICAgICBpZihtZXRhLnR5cGUgPT0gXCJyZWRpcmVjdFwiICYmIG1ldGEuc2Nyb2xsKXtcbiAgICAgICAgICAvLyBJZiB3ZSdyZSByZWRpcmVjdGluZyBzdG9yZSB0aGUgY3VycmVudCBzY3JvbGxZIGZvciB0aGUgY3VycmVudCBoaXN0b3J5IHN0YXRlLlxuICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSBoaXN0b3J5LnN0YXRlIHx8IHt9XG4gICAgICAgICAgY3VycmVudFN0YXRlLnNjcm9sbCA9IG1ldGEuc2Nyb2xsXG4gICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY3VycmVudFN0YXRlLCBcIlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBtZXRhLnNjcm9sbCAvLyBPbmx5IHN0b3JlIHRoZSBzY3JvbGwgaW4gdGhlIHJlZGlyZWN0IGNhc2UuXG4gICAgICAgIGhpc3Rvcnlba2luZCArIFwiU3RhdGVcIl0obWV0YSwgXCJcIiwgdG8gfHwgbnVsbCkgLy8gSUUgd2lsbCBjb2VyY2UgdW5kZWZpbmVkIHRvIHN0cmluZ1xuICAgICAgICBsZXQgaGFzaEVsID0gdGhpcy5nZXRIYXNoVGFyZ2V0RWwod2luZG93LmxvY2F0aW9uLmhhc2gpXG5cbiAgICAgICAgaWYoaGFzaEVsKXtcbiAgICAgICAgICBoYXNoRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICB9IGVsc2UgaWYobWV0YS50eXBlID09PSBcInJlZGlyZWN0XCIpe1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgMClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZGlyZWN0KHRvKVxuICAgIH1cbiAgfSxcblxuICBzZXRDb29raWUobmFtZSwgdmFsdWUpe1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke25hbWV9PSR7dmFsdWV9YFxuICB9LFxuXG4gIGdldENvb2tpZShuYW1lKXtcbiAgICByZXR1cm4gZG9jdW1lbnQuY29va2llLnJlcGxhY2UobmV3IFJlZ0V4cChgKD86KD86XnwuKjtcXHMqKSR7bmFtZX1cXHMqXFw9XFxzKihbXjtdKikuKiQpfF4uKiRgKSwgXCIkMVwiKVxuICB9LFxuXG4gIHJlZGlyZWN0KHRvVVJMLCBmbGFzaCl7XG4gICAgaWYoZmxhc2gpeyBCcm93c2VyLnNldENvb2tpZShcIl9fcGhvZW5peF9mbGFzaF9fXCIsIGZsYXNoICsgXCI7IG1heC1hZ2U9NjAwMDA7IHBhdGg9L1wiKSB9XG4gICAgd2luZG93LmxvY2F0aW9uID0gdG9VUkxcbiAgfSxcblxuICBsb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSl7IHJldHVybiBgJHtuYW1lc3BhY2V9LSR7c3Via2V5fWAgfSxcblxuICBnZXRIYXNoVGFyZ2V0RWwobWF5YmVIYXNoKXtcbiAgICBsZXQgaGFzaCA9IG1heWJlSGFzaC50b1N0cmluZygpLnN1YnN0cmluZygxKVxuICAgIGlmKGhhc2ggPT09IFwiXCIpeyByZXR1cm4gfVxuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKSB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBhW25hbWU9XCIke2hhc2h9XCJdYClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCcm93c2VyXG4iLCAiaW1wb3J0IHtcbiAgQ0hFQ0tBQkxFX0lOUFVUUyxcbiAgREVCT1VOQ0VfUFJFVl9LRVksXG4gIERFQk9VTkNFX1RSSUdHRVIsXG4gIEZPQ1VTQUJMRV9JTlBVVFMsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9FVkVOVF9DTEFTU0VTLFxuICBQSFhfSEFTX0ZPQ1VTRUQsXG4gIFBIWF9IQVNfU1VCTUlUVEVELFxuICBQSFhfTUFJTixcbiAgUEhYX05PX0ZFRURCQUNLX0NMQVNTLFxuICBQSFhfUEFSRU5UX0lELFxuICBQSFhfUFJJVkFURSxcbiAgUEhYX1JFRixcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX1NUQVRJQyxcbiAgUEhYX1VQTE9BRF9SRUYsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfU1RJQ0tZLFxuICBUSFJPVFRMRURcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5sZXQgRE9NID0ge1xuICBieUlkKGlkKXsgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSB8fCBsb2dFcnJvcihgbm8gaWQgZm91bmQgZm9yICR7aWR9YCkgfSxcblxuICByZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKXtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSlcbiAgICBpZihlbC5jbGFzc0xpc3QubGVuZ3RoID09PSAwKXsgZWwucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIikgfVxuICB9LFxuXG4gIGFsbChub2RlLCBxdWVyeSwgY2FsbGJhY2spe1xuICAgIGlmKCFub2RlKXsgcmV0dXJuIFtdIH1cbiAgICBsZXQgYXJyYXkgPSBBcnJheS5mcm9tKG5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSkpXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gYXJyYXkuZm9yRWFjaChjYWxsYmFjaykgOiBhcnJheVxuICB9LFxuXG4gIGNoaWxkTm9kZUxlbmd0aChodG1sKXtcbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sXG4gICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuY2hpbGRFbGVtZW50Q291bnRcbiAgfSxcblxuICBpc1VwbG9hZElucHV0KGVsKXsgcmV0dXJuIGVsLnR5cGUgPT09IFwiZmlsZVwiICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRikgIT09IG51bGwgfSxcblxuICBmaW5kVXBsb2FkSW5wdXRzKG5vZGUpeyByZXR1cm4gdGhpcy5hbGwobm9kZSwgYGlucHV0W3R5cGU9XCJmaWxlXCJdWyR7UEhYX1VQTE9BRF9SRUZ9XWApIH0sXG5cbiAgZmluZENvbXBvbmVudE5vZGVMaXN0KG5vZGUsIGNpZCl7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KHRoaXMuYWxsKG5vZGUsIGBbJHtQSFhfQ09NUE9ORU5UfT1cIiR7Y2lkfVwiXWApLCBub2RlKVxuICB9LFxuXG4gIGlzUGh4RGVzdHJveWVkKG5vZGUpe1xuICAgIHJldHVybiBub2RlLmlkICYmIERPTS5wcml2YXRlKG5vZGUsIFwiZGVzdHJveWVkXCIpID8gdHJ1ZSA6IGZhbHNlXG4gIH0sXG5cbiAgbWFya1BoeENoaWxkRGVzdHJveWVkKGVsKXtcbiAgICBpZih0aGlzLmlzUGh4Q2hpbGQoZWwpKXsgZWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBcIlwiKSB9XG4gICAgdGhpcy5wdXRQcml2YXRlKGVsLCBcImRlc3Ryb3llZFwiLCB0cnVlKVxuICB9LFxuXG4gIGZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQoaHRtbCwgcGFyZW50SWQpe1xuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcbiAgICByZXR1cm4gdGhpcy5maW5kUGh4Q2hpbGRyZW4odGVtcGxhdGUuY29udGVudCwgcGFyZW50SWQpXG4gIH0sXG5cbiAgaXNJZ25vcmVkKGVsLCBwaHhVcGRhdGUpe1xuICAgIHJldHVybiAoZWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkgfHwgZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtdXBkYXRlXCIpKSA9PT0gXCJpZ25vcmVcIlxuICB9LFxuXG4gIGlzUGh4VXBkYXRlKGVsLCBwaHhVcGRhdGUsIHVwZGF0ZVR5cGVzKXtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICYmIHVwZGF0ZVR5cGVzLmluZGV4T2YoZWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkpID49IDBcbiAgfSxcblxuICBmaW5kUGh4U3RpY2t5KGVsKXsgcmV0dXJuIHRoaXMuYWxsKGVsLCBgWyR7UEhYX1NUSUNLWX1dYCkgfSxcblxuICBmaW5kUGh4Q2hpbGRyZW4oZWwsIHBhcmVudElkKXtcbiAgICByZXR1cm4gdGhpcy5hbGwoZWwsIGAke1BIWF9WSUVXX1NFTEVDVE9SfVske1BIWF9QQVJFTlRfSUR9PVwiJHtwYXJlbnRJZH1cIl1gKVxuICB9LFxuXG4gIGZpbmRQYXJlbnRDSURzKG5vZGUsIGNpZHMpe1xuICAgIGxldCBpbml0aWFsID0gbmV3IFNldChjaWRzKVxuICAgIHJldHVybiBjaWRzLnJlZHVjZSgoYWNjLCBjaWQpID0+IHtcbiAgICAgIGxldCBzZWxlY3RvciA9IGBbJHtQSFhfQ09NUE9ORU5UfT1cIiR7Y2lkfVwiXSBbJHtQSFhfQ09NUE9ORU5UfV1gXG5cbiAgICAgIHRoaXMuZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KHRoaXMuYWxsKG5vZGUsIHNlbGVjdG9yKSwgbm9kZSlcbiAgICAgICAgLm1hcChlbCA9PiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkpKVxuICAgICAgICAuZm9yRWFjaChjaGlsZENJRCA9PiBhY2MuZGVsZXRlKGNoaWxkQ0lEKSlcblxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIGluaXRpYWwpXG4gIH0sXG5cbiAgZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KG5vZGVzLCBwYXJlbnQpe1xuICAgIGlmKHBhcmVudC5xdWVyeVNlbGVjdG9yKFBIWF9WSUVXX1NFTEVDVE9SKSl7XG4gICAgICByZXR1cm4gbm9kZXMuZmlsdGVyKGVsID0+IHRoaXMud2l0aGluU2FtZUxpdmVWaWV3KGVsLCBwYXJlbnQpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gIH0sXG5cbiAgd2l0aGluU2FtZUxpdmVWaWV3KG5vZGUsIHBhcmVudCl7XG4gICAgd2hpbGUobm9kZSA9IG5vZGUucGFyZW50Tm9kZSl7XG4gICAgICBpZihub2RlLmlzU2FtZU5vZGUocGFyZW50KSl7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmKG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSAhPT0gbnVsbCl7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICB9LFxuXG4gIHByaXZhdGUoZWwsIGtleSl7IHJldHVybiBlbFtQSFhfUFJJVkFURV0gJiYgZWxbUEhYX1BSSVZBVEVdW2tleV0gfSxcblxuICBkZWxldGVQcml2YXRlKGVsLCBrZXkpeyBlbFtQSFhfUFJJVkFURV0gJiYgZGVsZXRlIChlbFtQSFhfUFJJVkFURV1ba2V5XSkgfSxcblxuICBwdXRQcml2YXRlKGVsLCBrZXksIHZhbHVlKXtcbiAgICBpZighZWxbUEhYX1BSSVZBVEVdKXsgZWxbUEhYX1BSSVZBVEVdID0ge30gfVxuICAgIGVsW1BIWF9QUklWQVRFXVtrZXldID0gdmFsdWVcbiAgfSxcblxuICB1cGRhdGVQcml2YXRlKGVsLCBrZXksIGRlZmF1bHRWYWwsIHVwZGF0ZUZ1bmMpe1xuICAgIGxldCBleGlzdGluZyA9IHRoaXMucHJpdmF0ZShlbCwga2V5KVxuICAgIGlmKGV4aXN0aW5nID09PSB1bmRlZmluZWQpe1xuICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHVwZGF0ZUZ1bmMoZGVmYXVsdFZhbCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB1cGRhdGVGdW5jKGV4aXN0aW5nKSlcbiAgICB9XG4gIH0sXG5cbiAgY29weVByaXZhdGVzKHRhcmdldCwgc291cmNlKXtcbiAgICBpZihzb3VyY2VbUEhYX1BSSVZBVEVdKXtcbiAgICAgIHRhcmdldFtQSFhfUFJJVkFURV0gPSBzb3VyY2VbUEhYX1BSSVZBVEVdXG4gICAgfVxuICB9LFxuXG4gIHB1dFRpdGxlKHN0cil7XG4gICAgbGV0IHRpdGxlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGl0bGVcIilcbiAgICBsZXQge3ByZWZpeCwgc3VmZml4fSA9IHRpdGxlRWwuZGF0YXNldFxuICAgIGRvY3VtZW50LnRpdGxlID0gYCR7cHJlZml4IHx8IFwiXCJ9JHtzdHJ9JHtzdWZmaXggfHwgXCJcIn1gXG4gIH0sXG5cbiAgZGVib3VuY2UoZWwsIGV2ZW50LCBwaHhEZWJvdW5jZSwgZGVmYXVsdERlYm91bmNlLCBwaHhUaHJvdHRsZSwgZGVmYXVsdFRocm90dGxlLCBhc3luY0ZpbHRlciwgY2FsbGJhY2spe1xuICAgIGxldCBkZWJvdW5jZSA9IGVsLmdldEF0dHJpYnV0ZShwaHhEZWJvdW5jZSlcbiAgICBsZXQgdGhyb3R0bGUgPSBlbC5nZXRBdHRyaWJ1dGUocGh4VGhyb3R0bGUpXG4gICAgaWYoZGVib3VuY2UgPT09IFwiXCIpeyBkZWJvdW5jZSA9IGRlZmF1bHREZWJvdW5jZSB9XG4gICAgaWYodGhyb3R0bGUgPT09IFwiXCIpeyB0aHJvdHRsZSA9IGRlZmF1bHRUaHJvdHRsZSB9XG4gICAgbGV0IHZhbHVlID0gZGVib3VuY2UgfHwgdGhyb3R0bGVcbiAgICBzd2l0Y2godmFsdWUpe1xuICAgICAgY2FzZSBudWxsOiByZXR1cm4gY2FsbGJhY2soKVxuXG4gICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICBpZih0aGlzLm9uY2UoZWwsIFwiZGVib3VuY2UtYmx1clwiKSl7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gY2FsbGJhY2soKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGV0IHRpbWVvdXQgPSBwYXJzZUludCh2YWx1ZSlcbiAgICAgICAgbGV0IHRyaWdnZXIgPSAoKSA9PiB0aHJvdHRsZSA/IHRoaXMuZGVsZXRlUHJpdmF0ZShlbCwgVEhST1RUTEVEKSA6IGNhbGxiYWNrKClcbiAgICAgICAgbGV0IGN1cnJlbnRDeWNsZSA9IHRoaXMuaW5jQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIsIHRyaWdnZXIpXG4gICAgICAgIGlmKGlzTmFOKHRpbWVvdXQpKXsgcmV0dXJuIGxvZ0Vycm9yKGBpbnZhbGlkIHRocm90dGxlL2RlYm91bmNlIHZhbHVlOiAke3ZhbHVlfWApIH1cbiAgICAgICAgaWYodGhyb3R0bGUpe1xuICAgICAgICAgIGxldCBuZXdLZXlEb3duID0gZmFsc2VcbiAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImtleWRvd25cIil7XG4gICAgICAgICAgICBsZXQgcHJldktleSA9IHRoaXMucHJpdmF0ZShlbCwgREVCT1VOQ0VfUFJFVl9LRVkpXG4gICAgICAgICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZLCBldmVudC5rZXkpXG4gICAgICAgICAgICBuZXdLZXlEb3duID0gcHJldktleSAhPT0gZXZlbnQua2V5XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIW5ld0tleURvd24gJiYgdGhpcy5wcml2YXRlKGVsLCBUSFJPVFRMRUQpKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIFRIUk9UVExFRCwgdHJ1ZSlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZihhc3luY0ZpbHRlcigpKXsgdGhpcy50cmlnZ2VyQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIpIH1cbiAgICAgICAgICAgIH0sIHRpbWVvdXQpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYoYXN5bmNGaWx0ZXIoKSl7IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCBjdXJyZW50Q3ljbGUpIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvcm0gPSBlbC5mb3JtXG4gICAgICAgIGlmKGZvcm0gJiYgdGhpcy5vbmNlKGZvcm0sIFwiYmluZC1kZWJvdW5jZVwiKSl7XG4gICAgICAgICAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsICgpID0+IHtcbiAgICAgICAgICAgIEFycmF5LmZyb20oKG5ldyBGb3JtRGF0YShmb3JtKSkuZW50cmllcygpLCAoW25hbWVdKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpbnB1dCA9IGZvcm0ucXVlcnlTZWxlY3RvcihgW25hbWU9XCIke25hbWV9XCJdYClcbiAgICAgICAgICAgICAgdGhpcy5pbmNDeWNsZShpbnB1dCwgREVCT1VOQ0VfVFJJR0dFUilcbiAgICAgICAgICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBUSFJPVFRMRUQpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5vbmNlKGVsLCBcImJpbmQtZGVib3VuY2VcIikpe1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSlcbiAgICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0cmlnZ2VyQ3ljbGUoZWwsIGtleSwgY3VycmVudEN5Y2xlKXtcbiAgICBsZXQgW2N5Y2xlLCB0cmlnZ2VyXSA9IHRoaXMucHJpdmF0ZShlbCwga2V5KVxuICAgIGlmKCFjdXJyZW50Q3ljbGUpeyBjdXJyZW50Q3ljbGUgPSBjeWNsZSB9XG4gICAgaWYoY3VycmVudEN5Y2xlID09PSBjeWNsZSl7XG4gICAgICB0aGlzLmluY0N5Y2xlKGVsLCBrZXkpXG4gICAgICB0cmlnZ2VyKClcbiAgICB9XG4gIH0sXG5cbiAgb25jZShlbCwga2V5KXtcbiAgICBpZih0aGlzLnByaXZhdGUoZWwsIGtleSkgPT09IHRydWUpeyByZXR1cm4gZmFsc2UgfVxuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB0cnVlKVxuICAgIHJldHVybiB0cnVlXG4gIH0sXG5cbiAgaW5jQ3ljbGUoZWwsIGtleSwgdHJpZ2dlciA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICBsZXQgW2N1cnJlbnRDeWNsZV0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSkgfHwgWzAsIHRyaWdnZXJdXG4gICAgY3VycmVudEN5Y2xlKytcbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgW2N1cnJlbnRDeWNsZSwgdHJpZ2dlcl0pXG4gICAgcmV0dXJuIGN1cnJlbnRDeWNsZVxuICB9LFxuXG4gIGRpc2NhcmRFcnJvcihjb250YWluZXIsIGVsLCBwaHhGZWVkYmFja0Zvcil7XG4gICAgbGV0IGZpZWxkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhGZWVkYmFja0ZvcilcbiAgICAvLyBUT0RPOiBSZW1vdmUgaWQgbG9va3VwIGFmdGVyIHdlIHVwZGF0ZSBQaG9lbml4IHRvIHVzZSBpbnB1dF9uYW1lIGluc3RlYWQgb2YgaW5wdXRfaWRcbiAgICBsZXQgaW5wdXQgPSBmaWVsZCAmJiBjb250YWluZXIucXVlcnlTZWxlY3RvcihgW2lkPVwiJHtmaWVsZH1cIl0sIFtuYW1lPVwiJHtmaWVsZH1cIl1gKVxuICAgIGlmKCFpbnB1dCl7IHJldHVybiB9XG5cbiAgICBpZighKHRoaXMucHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VEKSB8fCB0aGlzLnByaXZhdGUoaW5wdXQuZm9ybSwgUEhYX0hBU19TVUJNSVRURUQpKSl7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKFBIWF9OT19GRUVEQkFDS19DTEFTUylcbiAgICB9XG4gIH0sXG5cbiAgc2hvd0Vycm9yKGlucHV0RWwsIHBoeEZlZWRiYWNrRm9yKXtcbiAgICBpZihpbnB1dEVsLmlkIHx8IGlucHV0RWwubmFtZSl7XG4gICAgICB0aGlzLmFsbChpbnB1dEVsLmZvcm0sIGBbJHtwaHhGZWVkYmFja0Zvcn09XCIke2lucHV0RWwuaWR9XCJdLCBbJHtwaHhGZWVkYmFja0Zvcn09XCIke2lucHV0RWwubmFtZX1cIl1gLCAoZWwpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcyhlbCwgUEhYX05PX0ZFRURCQUNLX0NMQVNTKVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgaXNQaHhDaGlsZChub2RlKXtcbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRClcbiAgfSxcblxuICBpc1BoeFN0aWNreShub2RlKXtcbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1NUSUNLWSkgIT09IG51bGxcbiAgfSxcblxuICBmaXJzdFBoeENoaWxkKGVsKXtcbiAgICByZXR1cm4gdGhpcy5pc1BoeENoaWxkKGVsKSA/IGVsIDogdGhpcy5hbGwoZWwsIGBbJHtQSFhfUEFSRU5UX0lEfV1gKVswXVxuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCBuYW1lLCBvcHRzID0ge30pe1xuICAgIGxldCBidWJibGVzID0gb3B0cy5idWJibGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFvcHRzLmJ1YmJsZXNcbiAgICBsZXQgZXZlbnRPcHRzID0ge2J1YmJsZXM6IGJ1YmJsZXMsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbDogb3B0cy5kZXRhaWwgfHwge319XG4gICAgbGV0IGV2ZW50ID0gbmFtZSA9PT0gXCJjbGlja1wiID8gbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiLCBldmVudE9wdHMpIDogbmV3IEN1c3RvbUV2ZW50KG5hbWUsIGV2ZW50T3B0cylcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudClcbiAgfSxcblxuICBjbG9uZU5vZGUobm9kZSwgaHRtbCl7XG4gICAgaWYodHlwZW9mIChodG1sKSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNsb25lZCA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKVxuICAgICAgY2xvbmVkLmlubmVySFRNTCA9IGh0bWxcbiAgICAgIHJldHVybiBjbG9uZWRcbiAgICB9XG4gIH0sXG5cbiAgbWVyZ2VBdHRycyh0YXJnZXQsIHNvdXJjZSwgb3B0cyA9IHt9KXtcbiAgICBsZXQgZXhjbHVkZSA9IG9wdHMuZXhjbHVkZSB8fCBbXVxuICAgIGxldCBpc0lnbm9yZWQgPSBvcHRzLmlzSWdub3JlZFxuICAgIGxldCBzb3VyY2VBdHRycyA9IHNvdXJjZS5hdHRyaWJ1dGVzXG4gICAgZm9yKGxldCBpID0gc291cmNlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgbGV0IG5hbWUgPSBzb3VyY2VBdHRyc1tpXS5uYW1lXG4gICAgICBpZihleGNsdWRlLmluZGV4T2YobmFtZSkgPCAwKXsgdGFyZ2V0LnNldEF0dHJpYnV0ZShuYW1lLCBzb3VyY2UuZ2V0QXR0cmlidXRlKG5hbWUpKSB9XG4gICAgfVxuXG4gICAgbGV0IHRhcmdldEF0dHJzID0gdGFyZ2V0LmF0dHJpYnV0ZXNcbiAgICBmb3IobGV0IGkgPSB0YXJnZXRBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICBsZXQgbmFtZSA9IHRhcmdldEF0dHJzW2ldLm5hbWVcbiAgICAgIGlmKGlzSWdub3JlZCl7XG4gICAgICAgIGlmKG5hbWUuc3RhcnRzV2l0aChcImRhdGEtXCIpICYmICFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpKXsgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZighc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSl7IHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtZXJnZUZvY3VzZWRJbnB1dCh0YXJnZXQsIHNvdXJjZSl7XG4gICAgLy8gc2tpcCBzZWxlY3RzIGJlY2F1c2UgRkYgd2lsbCByZXNldCBoaWdobGlnaHRlZCBpbmRleCBmb3IgYW55IHNldEF0dHJpYnV0ZVxuICAgIGlmKCEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpKXsgRE9NLm1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIHtleGNsdWRlOiBbXCJ2YWx1ZVwiXX0pIH1cbiAgICBpZihzb3VyY2UucmVhZE9ubHkpe1xuICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJyZWFkb25seVwiKVxuICAgIH1cbiAgfSxcblxuICBoYXNTZWxlY3Rpb25SYW5nZShlbCl7XG4gICAgcmV0dXJuIGVsLnNldFNlbGVjdGlvblJhbmdlICYmIChlbC50eXBlID09PSBcInRleHRcIiB8fCBlbC50eXBlID09PSBcInRleHRhcmVhXCIpXG4gIH0sXG5cbiAgcmVzdG9yZUZvY3VzKGZvY3VzZWQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpe1xuICAgIGlmKCFET00uaXNUZXh0dWFsSW5wdXQoZm9jdXNlZCkpeyByZXR1cm4gfVxuICAgIGxldCB3YXNGb2N1c2VkID0gZm9jdXNlZC5tYXRjaGVzKFwiOmZvY3VzXCIpXG4gICAgaWYoZm9jdXNlZC5yZWFkT25seSl7IGZvY3VzZWQuYmx1cigpIH1cbiAgICBpZighd2FzRm9jdXNlZCl7IGZvY3VzZWQuZm9jdXMoKSB9XG4gICAgaWYodGhpcy5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSl7XG4gICAgICBmb2N1c2VkLnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpXG4gICAgfVxuICB9LFxuXG4gIGlzRm9ybUlucHV0KGVsKXsgcmV0dXJuIC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KGVsLnRhZ05hbWUpICYmIGVsLnR5cGUgIT09IFwiYnV0dG9uXCIgfSxcblxuICBzeW5jQXR0cnNUb1Byb3BzKGVsKXtcbiAgICBpZihlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgQ0hFQ0tBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSkgPj0gMCl7XG4gICAgICBlbC5jaGVja2VkID0gZWwuZ2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiKSAhPT0gbnVsbFxuICAgIH1cbiAgfSxcblxuICBpc1RleHR1YWxJbnB1dChlbCl7IHJldHVybiBGT0NVU0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCB9LFxuXG4gIGlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKXtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhUcmlnZ2VyRXh0ZXJuYWwpICE9PSBudWxsXG4gIH0sXG5cbiAgc3luY1BlbmRpbmdSZWYoZnJvbUVsLCB0b0VsLCBkaXNhYmxlV2l0aCl7XG4gICAgbGV0IHJlZiA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1JFRilcbiAgICBpZihyZWYgPT09IG51bGwpeyByZXR1cm4gdHJ1ZSB9XG4gICAgbGV0IHJlZlNyYyA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG5cbiAgICBpZihET00uaXNGb3JtSW5wdXQoZnJvbUVsKSB8fCBmcm9tRWwuZ2V0QXR0cmlidXRlKGRpc2FibGVXaXRoKSAhPT0gbnVsbCl7XG4gICAgICBpZihET00uaXNVcGxvYWRJbnB1dChmcm9tRWwpKXsgRE9NLm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7aXNJZ25vcmVkOiB0cnVlfSkgfVxuICAgICAgRE9NLnB1dFByaXZhdGUoZnJvbUVsLCBQSFhfUkVGLCB0b0VsKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIFBIWF9FVkVOVF9DTEFTU0VTLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICAgICAgZnJvbUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpICYmIHRvRWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICB9KVxuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRiwgcmVmKVxuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHJlZlNyYylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9LFxuXG4gIGNsZWFuQ2hpbGROb2Rlcyhjb250YWluZXIsIHBoeFVwZGF0ZSl7XG4gICAgaWYoRE9NLmlzUGh4VXBkYXRlKGNvbnRhaW5lciwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSl7XG4gICAgICBsZXQgdG9SZW1vdmUgPSBbXVxuICAgICAgY29udGFpbmVyLmNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICBpZighY2hpbGROb2RlLmlkKXtcbiAgICAgICAgICAvLyBTa2lwIHdhcm5pbmcgaWYgaXQncyBhbiBlbXB0eSB0ZXh0IG5vZGUgKGUuZy4gYSBuZXctbGluZSlcbiAgICAgICAgICBsZXQgaXNFbXB0eVRleHROb2RlID0gY2hpbGROb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiBjaGlsZE5vZGUubm9kZVZhbHVlLnRyaW0oKSA9PT0gXCJcIlxuICAgICAgICAgIGlmKCFpc0VtcHR5VGV4dE5vZGUpe1xuICAgICAgICAgICAgbG9nRXJyb3IoXCJvbmx5IEhUTUwgZWxlbWVudCB0YWdzIHdpdGggYW4gaWQgYXJlIGFsbG93ZWQgaW5zaWRlIGNvbnRhaW5lcnMgd2l0aCBwaHgtdXBkYXRlLlxcblxcblwiICtcbiAgICAgICAgICAgICAgYHJlbW92aW5nIGlsbGVnYWwgbm9kZTogXCIkeyhjaGlsZE5vZGUub3V0ZXJIVE1MIHx8IGNoaWxkTm9kZS5ub2RlVmFsdWUpLnRyaW0oKX1cIlxcblxcbmApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRvUmVtb3ZlLnB1c2goY2hpbGROb2RlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdG9SZW1vdmUuZm9yRWFjaChjaGlsZE5vZGUgPT4gY2hpbGROb2RlLnJlbW92ZSgpKVxuICAgIH1cbiAgfSxcblxuICByZXBsYWNlUm9vdENvbnRhaW5lcihjb250YWluZXIsIHRhZ05hbWUsIGF0dHJzKXtcbiAgICBsZXQgcmV0YWluZWRBdHRycyA9IG5ldyBTZXQoW1wiaWRcIiwgUEhYX1NFU1NJT04sIFBIWF9TVEFUSUMsIFBIWF9NQUlOLCBQSFhfUk9PVF9JRF0pXG4gICAgaWYoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpKXtcbiAgICAgIEFycmF5LmZyb20oY29udGFpbmVyLmF0dHJpYnV0ZXMpXG4gICAgICAgIC5maWx0ZXIoYXR0ciA9PiAhcmV0YWluZWRBdHRycy5oYXMoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAuZm9yRWFjaChhdHRyID0+IGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKSlcblxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpXG4gICAgICAgIC5maWx0ZXIobmFtZSA9PiAhcmV0YWluZWRBdHRycy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgLmZvckVhY2goYXR0ciA9PiBjb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSlcblxuICAgICAgcmV0dXJuIGNvbnRhaW5lclxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpXG4gICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChhdHRyID0+IG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pKVxuICAgICAgcmV0YWluZWRBdHRycy5mb3JFYWNoKGF0dHIgPT4gbmV3Q29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBjb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHIpKSlcbiAgICAgIG5ld0NvbnRhaW5lci5pbm5lckhUTUwgPSBjb250YWluZXIuaW5uZXJIVE1MXG4gICAgICBjb250YWluZXIucmVwbGFjZVdpdGgobmV3Q29udGFpbmVyKVxuICAgICAgcmV0dXJuIG5ld0NvbnRhaW5lclxuICAgIH1cbiAgfSxcblxuICBnZXRTdGlja3koZWwsIG5hbWUsIGRlZmF1bHRWYWwpe1xuICAgIGxldCBvcCA9IChET00ucHJpdmF0ZShlbCwgXCJzdGlja3lcIikgfHwgW10pLmZpbmQoKFtleGlzdGluZ05hbWUsIF0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSlcbiAgICBpZihvcCl7XG4gICAgICBsZXQgW19uYW1lLCBfb3AsIHN0YXNoZWRSZXN1bHRdID0gb3BcbiAgICAgIHJldHVybiBzdGFzaGVkUmVzdWx0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0eXBlb2YoZGVmYXVsdFZhbCkgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWwoKSA6IGRlZmF1bHRWYWxcbiAgICB9XG4gIH0sXG5cbiAgZGVsZXRlU3RpY2t5KGVsLCBuYW1lKXtcbiAgICB0aGlzLnVwZGF0ZVByaXZhdGUoZWwsIFwic3RpY2t5XCIsIFtdLCBvcHMgPT4ge1xuICAgICAgcmV0dXJuIG9wcy5maWx0ZXIoKFtleGlzdGluZ05hbWUsIF9dKSA9PiBleGlzdGluZ05hbWUgIT09IG5hbWUpXG4gICAgfSlcbiAgfSxcblxuICBwdXRTdGlja3koZWwsIG5hbWUsIG9wKXtcbiAgICBsZXQgc3Rhc2hlZFJlc3VsdCA9IG9wKGVsKVxuICAgIHRoaXMudXBkYXRlUHJpdmF0ZShlbCwgXCJzdGlja3lcIiwgW10sIG9wcyA9PiB7XG4gICAgICBsZXQgZXhpc3RpbmdJbmRleCA9IG9wcy5maW5kSW5kZXgoKFtleGlzdGluZ05hbWUsIF0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSlcbiAgICAgIGlmKGV4aXN0aW5nSW5kZXggPj0gMCl7XG4gICAgICAgIG9wc1tleGlzdGluZ0luZGV4XSA9IFtuYW1lLCBvcCwgc3Rhc2hlZFJlc3VsdF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wcy5wdXNoKFtuYW1lLCBvcCwgc3Rhc2hlZFJlc3VsdF0pXG4gICAgICB9XG4gICAgICByZXR1cm4gb3BzXG4gICAgfSlcbiAgfSxcblxuICBhcHBseVN0aWNreU9wZXJhdGlvbnMoZWwpe1xuICAgIGxldCBvcHMgPSBET00ucHJpdmF0ZShlbCwgXCJzdGlja3lcIilcbiAgICBpZighb3BzKXsgcmV0dXJuIH1cblxuICAgIG9wcy5mb3JFYWNoKChbbmFtZSwgb3AsIF9zdGFzaGVkXSkgPT4gdGhpcy5wdXRTdGlja3koZWwsIG5hbWUsIG9wKSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBET01cbiIsICJpbXBvcnQge1xuICBQSFhfQUNUSVZFX0VOVFJZX1JFRlMsXG4gIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2hhbm5lbFVwbG9hZGVyLFxuICBsb2dFcnJvclxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwbG9hZEVudHJ5IHtcbiAgc3RhdGljIGlzQWN0aXZlKGZpbGVFbCwgZmlsZSl7XG4gICAgbGV0IGlzTmV3ID0gZmlsZS5fcGh4UmVmID09PSB1bmRlZmluZWRcbiAgICBsZXQgYWN0aXZlUmVmcyA9IGZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKS5zcGxpdChcIixcIilcbiAgICBsZXQgaXNBY3RpdmUgPSBhY3RpdmVSZWZzLmluZGV4T2YoTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSkpID49IDBcbiAgICByZXR1cm4gZmlsZS5zaXplID4gMCAmJiAoaXNOZXcgfHwgaXNBY3RpdmUpXG4gIH1cblxuICBzdGF0aWMgaXNQcmVmbGlnaHRlZChmaWxlRWwsIGZpbGUpe1xuICAgIGxldCBwcmVmbGlnaHRlZFJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKS5zcGxpdChcIixcIilcbiAgICBsZXQgaXNQcmVmbGlnaHRlZCA9IHByZWZsaWdodGVkUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwXG4gICAgcmV0dXJuIGlzUHJlZmxpZ2h0ZWQgJiYgdGhpcy5pc0FjdGl2ZShmaWxlRWwsIGZpbGUpXG4gIH1cblxuICBjb25zdHJ1Y3RvcihmaWxlRWwsIGZpbGUsIHZpZXcpe1xuICAgIHRoaXMucmVmID0gTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSlcbiAgICB0aGlzLmZpbGVFbCA9IGZpbGVFbFxuICAgIHRoaXMuZmlsZSA9IGZpbGVcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5tZXRhID0gbnVsbFxuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2VcbiAgICB0aGlzLl9pc0RvbmUgPSBmYWxzZVxuICAgIHRoaXMuX3Byb2dyZXNzID0gMFxuICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSAtMVxuICAgIHRoaXMuX29uRG9uZSA9IGZ1bmN0aW9uICgpeyB9XG4gICAgdGhpcy5fb25FbFVwZGF0ZWQgPSB0aGlzLm9uRWxVcGRhdGVkLmJpbmQodGhpcylcbiAgICB0aGlzLmZpbGVFbC5hZGRFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpXG4gIH1cblxuICBtZXRhZGF0YSgpeyByZXR1cm4gdGhpcy5tZXRhIH1cblxuICBwcm9ncmVzcyhwcm9ncmVzcyl7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSBNYXRoLmZsb29yKHByb2dyZXNzKVxuICAgIGlmKHRoaXMuX3Byb2dyZXNzID4gdGhpcy5fbGFzdFByb2dyZXNzU2VudCl7XG4gICAgICBpZih0aGlzLl9wcm9ncmVzcyA+PSAxMDApe1xuICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDEwMFxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gMTAwXG4gICAgICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCAxMDAsICgpID0+IHtcbiAgICAgICAgICBMaXZlVXBsb2FkZXIudW50cmFja0ZpbGUodGhpcy5maWxlRWwsIHRoaXMuZmlsZSlcbiAgICAgICAgICB0aGlzLl9vbkRvbmUoKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IHRoaXMuX3Byb2dyZXNzXG4gICAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgdGhpcy5fcHJvZ3Jlc3MpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2FuY2VsKCl7XG4gICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlXG4gICAgdGhpcy5faXNEb25lID0gdHJ1ZVxuICAgIHRoaXMuX29uRG9uZSgpXG4gIH1cblxuICBpc0RvbmUoKXsgcmV0dXJuIHRoaXMuX2lzRG9uZSB9XG5cbiAgZXJyb3IocmVhc29uID0gXCJmYWlsZWRcIil7XG4gICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCB7ZXJyb3I6IHJlYXNvbn0pXG4gICAgTGl2ZVVwbG9hZGVyLmNsZWFyRmlsZXModGhpcy5maWxlRWwpXG4gIH1cblxuICAvL3ByaXZhdGVcblxuICBvbkRvbmUoY2FsbGJhY2spe1xuICAgIHRoaXMuX29uRG9uZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuZmlsZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZClcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICBvbkVsVXBkYXRlZCgpe1xuICAgIGxldCBhY3RpdmVSZWZzID0gdGhpcy5maWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgaWYoYWN0aXZlUmVmcy5pbmRleE9mKHRoaXMucmVmKSA9PT0gLTEpeyB0aGlzLmNhbmNlbCgpIH1cbiAgfVxuXG4gIHRvUHJlZmxpZ2h0UGF5bG9hZCgpe1xuICAgIHJldHVybiB7XG4gICAgICBsYXN0X21vZGlmaWVkOiB0aGlzLmZpbGUubGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZTogdGhpcy5maWxlLm5hbWUsXG4gICAgICBzaXplOiB0aGlzLmZpbGUuc2l6ZSxcbiAgICAgIHR5cGU6IHRoaXMuZmlsZS50eXBlLFxuICAgICAgcmVmOiB0aGlzLnJlZlxuICAgIH1cbiAgfVxuXG4gIHVwbG9hZGVyKHVwbG9hZGVycyl7XG4gICAgaWYodGhpcy5tZXRhLnVwbG9hZGVyKXtcbiAgICAgIGxldCBjYWxsYmFjayA9IHVwbG9hZGVyc1t0aGlzLm1ldGEudXBsb2FkZXJdIHx8IGxvZ0Vycm9yKGBubyB1cGxvYWRlciBjb25maWd1cmVkIGZvciAke3RoaXMubWV0YS51cGxvYWRlcn1gKVxuICAgICAgcmV0dXJuIHtuYW1lOiB0aGlzLm1ldGEudXBsb2FkZXIsIGNhbGxiYWNrOiBjYWxsYmFja31cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtuYW1lOiBcImNoYW5uZWxcIiwgY2FsbGJhY2s6IGNoYW5uZWxVcGxvYWRlcn1cbiAgICB9XG4gIH1cblxuICB6aXBQb3N0RmxpZ2h0KHJlc3Ape1xuICAgIHRoaXMubWV0YSA9IHJlc3AuZW50cmllc1t0aGlzLnJlZl1cbiAgICBpZighdGhpcy5tZXRhKXsgbG9nRXJyb3IoYG5vIHByZWZsaWdodCB1cGxvYWQgcmVzcG9uc2UgcmV0dXJuZWQgd2l0aCByZWYgJHt0aGlzLnJlZn1gLCB7aW5wdXQ6IHRoaXMuZmlsZUVsLCByZXNwb25zZTogcmVzcH0pIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFBIWF9ET05FX1JFRlMsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTLFxuICBQSFhfVVBMT0FEX1JFRlxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBVcGxvYWRFbnRyeSBmcm9tIFwiLi91cGxvYWRfZW50cnlcIlxuXG5sZXQgbGl2ZVVwbG9hZGVyRmlsZVJlZiA9IDBcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVVwbG9hZGVyIHtcbiAgc3RhdGljIGdlbkZpbGVSZWYoZmlsZSl7XG4gICAgbGV0IHJlZiA9IGZpbGUuX3BoeFJlZlxuICAgIGlmKHJlZiAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiByZWZcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsZS5fcGh4UmVmID0gKGxpdmVVcGxvYWRlckZpbGVSZWYrKykudG9TdHJpbmcoKVxuICAgICAgcmV0dXJuIGZpbGUuX3BoeFJlZlxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRFbnRyeURhdGFVUkwoaW5wdXRFbCwgcmVmLCBjYWxsYmFjayl7XG4gICAgbGV0IGZpbGUgPSB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpLmZpbmQoZmlsZSA9PiB0aGlzLmdlbkZpbGVSZWYoZmlsZSkgPT09IHJlZilcbiAgICBjYWxsYmFjayhVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpKVxuICB9XG5cbiAgc3RhdGljIGhhc1VwbG9hZHNJblByb2dyZXNzKGZvcm1FbCl7XG4gICAgbGV0IGFjdGl2ZSA9IDBcbiAgICBET00uZmluZFVwbG9hZElucHV0cyhmb3JtRWwpLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgaWYoaW5wdXQuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKSAhPT0gaW5wdXQuZ2V0QXR0cmlidXRlKFBIWF9ET05FX1JFRlMpKXtcbiAgICAgICAgYWN0aXZlKytcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBhY3RpdmUgPiAwXG4gIH1cblxuICBzdGF0aWMgc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKXtcbiAgICBsZXQgZmlsZXMgPSB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpXG4gICAgbGV0IGZpbGVEYXRhID0ge31cbiAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgbGV0IGVudHJ5ID0ge3BhdGg6IGlucHV0RWwubmFtZX1cbiAgICAgIGxldCB1cGxvYWRSZWYgPSBpbnB1dEVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRilcbiAgICAgIGZpbGVEYXRhW3VwbG9hZFJlZl0gPSBmaWxlRGF0YVt1cGxvYWRSZWZdIHx8IFtdXG4gICAgICBlbnRyeS5yZWYgPSB0aGlzLmdlbkZpbGVSZWYoZmlsZSlcbiAgICAgIGVudHJ5Lm5hbWUgPSBmaWxlLm5hbWUgfHwgZW50cnkucmVmXG4gICAgICBlbnRyeS50eXBlID0gZmlsZS50eXBlXG4gICAgICBlbnRyeS5zaXplID0gZmlsZS5zaXplXG4gICAgICBmaWxlRGF0YVt1cGxvYWRSZWZdLnB1c2goZW50cnkpXG4gICAgfSlcbiAgICByZXR1cm4gZmlsZURhdGFcbiAgfVxuXG4gIHN0YXRpYyBjbGVhckZpbGVzKGlucHV0RWwpe1xuICAgIGlucHV0RWwudmFsdWUgPSBudWxsXG4gICAgaW5wdXRFbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpXG4gICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBbXSlcbiAgfVxuXG4gIHN0YXRpYyB1bnRyYWNrRmlsZShpbnB1dEVsLCBmaWxlKXtcbiAgICBET00ucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIERPTS5wcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIikuZmlsdGVyKGYgPT4gIU9iamVjdC5pcyhmLCBmaWxlKSkpXG4gIH1cblxuICBzdGF0aWMgdHJhY2tGaWxlcyhpbnB1dEVsLCBmaWxlcyl7XG4gICAgaWYoaW5wdXRFbC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAhPT0gbnVsbCl7XG4gICAgICBsZXQgbmV3RmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiAhdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKGYgPT4gT2JqZWN0LmlzKGYsIGZpbGUpKSlcbiAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5jb25jYXQobmV3RmlsZXMpKVxuICAgICAgaW5wdXRFbC52YWx1ZSA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBmaWxlcylcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYWN0aXZlRmlsZUlucHV0cyhmb3JtRWwpe1xuICAgIGxldCBmaWxlSW5wdXRzID0gRE9NLmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGZpbGVJbnB1dHMpLmZpbHRlcihlbCA9PiBlbC5maWxlcyAmJiB0aGlzLmFjdGl2ZUZpbGVzKGVsKS5sZW5ndGggPiAwKVxuICB9XG5cbiAgc3RhdGljIGFjdGl2ZUZpbGVzKGlucHV0KXtcbiAgICByZXR1cm4gKERPTS5wcml2YXRlKGlucHV0LCBcImZpbGVzXCIpIHx8IFtdKS5maWx0ZXIoZiA9PiBVcGxvYWRFbnRyeS5pc0FjdGl2ZShpbnB1dCwgZikpXG4gIH1cblxuICBzdGF0aWMgaW5wdXRzQXdhaXRpbmdQcmVmbGlnaHQoZm9ybUVsKXtcbiAgICBsZXQgZmlsZUlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoaW5wdXQgPT4gdGhpcy5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KS5sZW5ndGggPiAwKVxuICB9XG5cbiAgc3RhdGljIGZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXQpe1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0KS5maWx0ZXIoZiA9PiAhVXBsb2FkRW50cnkuaXNQcmVmbGlnaHRlZChpbnB1dCwgZikpXG4gIH1cblxuICBjb25zdHJ1Y3RvcihpbnB1dEVsLCB2aWV3LCBvbkNvbXBsZXRlKXtcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZVxuICAgIHRoaXMuX2VudHJpZXMgPVxuICAgICAgQXJyYXkuZnJvbShMaXZlVXBsb2FkZXIuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dEVsKSB8fCBbXSlcbiAgICAgICAgLm1hcChmaWxlID0+IG5ldyBVcGxvYWRFbnRyeShpbnB1dEVsLCBmaWxlLCB2aWV3KSlcblxuICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPSB0aGlzLl9lbnRyaWVzLmxlbmd0aFxuICB9XG5cbiAgZW50cmllcygpeyByZXR1cm4gdGhpcy5fZW50cmllcyB9XG5cbiAgaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgbGl2ZVNvY2tldCl7XG4gICAgdGhpcy5fZW50cmllcyA9XG4gICAgICB0aGlzLl9lbnRyaWVzLm1hcChlbnRyeSA9PiB7XG4gICAgICAgIGVudHJ5LnppcFBvc3RGbGlnaHQocmVzcClcbiAgICAgICAgZW50cnkub25Eb25lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzLS1cbiAgICAgICAgICBpZih0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID09PSAwKXsgdGhpcy5vbkNvbXBsZXRlKCkgfVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gZW50cnlcbiAgICAgIH0pXG5cbiAgICBsZXQgZ3JvdXBlZEVudHJpZXMgPSB0aGlzLl9lbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgICAgbGV0IHtuYW1lLCBjYWxsYmFja30gPSBlbnRyeS51cGxvYWRlcihsaXZlU29ja2V0LnVwbG9hZGVycylcbiAgICAgIGFjY1tuYW1lXSA9IGFjY1tuYW1lXSB8fCB7Y2FsbGJhY2s6IGNhbGxiYWNrLCBlbnRyaWVzOiBbXX1cbiAgICAgIGFjY1tuYW1lXS5lbnRyaWVzLnB1c2goZW50cnkpXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwge30pXG5cbiAgICBmb3IobGV0IG5hbWUgaW4gZ3JvdXBlZEVudHJpZXMpe1xuICAgICAgbGV0IHtjYWxsYmFjaywgZW50cmllc30gPSBncm91cGVkRW50cmllc1tuYW1lXVxuICAgICAgY2FsbGJhY2soZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldClcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfQUNUSVZFX0VOVFJZX1JFRlMsXG4gIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5cbmxldCBIb29rcyA9IHtcbiAgTGl2ZUZpbGVVcGxvYWQ6IHtcbiAgICBhY3RpdmVSZWZzKCl7IHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpIH0sXG5cbiAgICBwcmVmbGlnaHRlZFJlZnMoKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKSB9LFxuXG4gICAgbW91bnRlZCgpeyB0aGlzLnByZWZsaWdodGVkV2FzID0gdGhpcy5wcmVmbGlnaHRlZFJlZnMoKSB9LFxuXG4gICAgdXBkYXRlZCgpe1xuICAgICAgbGV0IG5ld1ByZWZsaWdodHMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpXG4gICAgICBpZih0aGlzLnByZWZsaWdodGVkV2FzICE9PSBuZXdQcmVmbGlnaHRzKXtcbiAgICAgICAgdGhpcy5wcmVmbGlnaHRlZFdhcyA9IG5ld1ByZWZsaWdodHNcbiAgICAgICAgaWYobmV3UHJlZmxpZ2h0cyA9PT0gXCJcIil7XG4gICAgICAgICAgdGhpcy5fX3ZpZXcuY2FuY2VsU3VibWl0KHRoaXMuZWwuZm9ybSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZih0aGlzLmFjdGl2ZVJlZnMoKSA9PT0gXCJcIil7IHRoaXMuZWwudmFsdWUgPSBudWxsIH1cbiAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoUEhYX0xJVkVfRklMRV9VUERBVEVEKSlcbiAgICB9XG4gIH0sXG5cbiAgTGl2ZUltZ1ByZXZpZXc6IHtcbiAgICBtb3VudGVkKCl7XG4gICAgICB0aGlzLnJlZiA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZW50cnktcmVmXCIpXG4gICAgICB0aGlzLmlucHV0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRikpXG4gICAgICBMaXZlVXBsb2FkZXIuZ2V0RW50cnlEYXRhVVJMKHRoaXMuaW5wdXRFbCwgdGhpcy5yZWYsIHVybCA9PiB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsXG4gICAgICAgIHRoaXMuZWwuc3JjID0gdXJsXG4gICAgICB9KVxuICAgIH0sXG4gICAgZGVzdHJveWVkKCl7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMudXJsKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBIb29rc1xuIiwgImltcG9ydCB7XG4gIG1heWJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01Qb3N0TW9ycGhSZXN0b3JlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lckJlZm9yZSwgY29udGFpbmVyQWZ0ZXIsIHVwZGF0ZVR5cGUpe1xuICAgIGxldCBpZHNCZWZvcmUgPSBuZXcgU2V0KClcbiAgICBsZXQgaWRzQWZ0ZXIgPSBuZXcgU2V0KFsuLi5jb250YWluZXJBZnRlci5jaGlsZHJlbl0ubWFwKGNoaWxkID0+IGNoaWxkLmlkKSlcblxuICAgIGxldCBlbGVtZW50c1RvTW9kaWZ5ID0gW11cblxuICAgIEFycmF5LmZyb20oY29udGFpbmVyQmVmb3JlLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmKGNoaWxkLmlkKXsgLy8gYWxsIG9mIG91ciBjaGlsZHJlbiBzaG91bGQgYmUgZWxlbWVudHMgd2l0aCBpZHNcbiAgICAgICAgaWRzQmVmb3JlLmFkZChjaGlsZC5pZClcbiAgICAgICAgaWYoaWRzQWZ0ZXIuaGFzKGNoaWxkLmlkKSl7XG4gICAgICAgICAgbGV0IHByZXZpb3VzRWxlbWVudElkID0gY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkXG4gICAgICAgICAgZWxlbWVudHNUb01vZGlmeS5wdXNoKHtlbGVtZW50SWQ6IGNoaWxkLmlkLCBwcmV2aW91c0VsZW1lbnRJZDogcHJldmlvdXNFbGVtZW50SWR9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuY29udGFpbmVySWQgPSBjb250YWluZXJBZnRlci5pZFxuICAgIHRoaXMudXBkYXRlVHlwZSA9IHVwZGF0ZVR5cGVcbiAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkgPSBlbGVtZW50c1RvTW9kaWZ5XG4gICAgdGhpcy5lbGVtZW50SWRzVG9BZGQgPSBbLi4uaWRzQWZ0ZXJdLmZpbHRlcihpZCA9PiAhaWRzQmVmb3JlLmhhcyhpZCkpXG4gIH1cblxuICAvLyBXZSBkbyB0aGUgZm9sbG93aW5nIHRvIG9wdGltaXplIGFwcGVuZC9wcmVwZW5kIG9wZXJhdGlvbnM6XG4gIC8vICAgMSkgVHJhY2sgaWRzIG9mIG1vZGlmaWVkIGVsZW1lbnRzICYgb2YgbmV3IGVsZW1lbnRzXG4gIC8vICAgMikgQWxsIHRoZSBtb2RpZmllZCBlbGVtZW50cyBhcmUgcHV0IGJhY2sgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIERPTSB0cmVlXG4gIC8vICAgICAgYnkgc3RvcmluZyB0aGUgaWQgb2YgdGhlaXIgcHJldmlvdXMgc2libGluZ1xuICAvLyAgIDMpIE5ldyBlbGVtZW50cyBhcmUgZ29pbmcgdG8gYmUgcHV0IGluIHRoZSByaWdodCBwbGFjZSBieSBtb3JwaGRvbSBkdXJpbmcgYXBwZW5kLlxuICAvLyAgICAgIEZvciBwcmVwZW5kLCB3ZSBtb3ZlIHRoZW0gdG8gdGhlIGZpcnN0IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXJcbiAgcGVyZm9ybSgpe1xuICAgIGxldCBjb250YWluZXIgPSBET00uYnlJZCh0aGlzLmNvbnRhaW5lcklkKVxuICAgIHRoaXMuZWxlbWVudHNUb01vZGlmeS5mb3JFYWNoKGVsZW1lbnRUb01vZGlmeSA9PiB7XG4gICAgICBpZihlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpe1xuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpLCBwcmV2aW91c0VsZW0gPT4ge1xuICAgICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCBlbGVtID0+IHtcbiAgICAgICAgICAgIGxldCBpc0luUmlnaHRQbGFjZSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWQgPT0gcHJldmlvdXNFbGVtLmlkXG4gICAgICAgICAgICBpZighaXNJblJpZ2h0UGxhY2Upe1xuICAgICAgICAgICAgICBwcmV2aW91c0VsZW0uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgZWxlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgY29udGFpbmVyXG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCBlbGVtID0+IHtcbiAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT0gbnVsbFxuICAgICAgICAgIGlmKCFpc0luUmlnaHRQbGFjZSl7XG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBlbGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYodGhpcy51cGRhdGVUeXBlID09IFwicHJlcGVuZFwiKXtcbiAgICAgIHRoaXMuZWxlbWVudElkc1RvQWRkLnJldmVyc2UoKS5mb3JFYWNoKGVsZW1JZCA9PiB7XG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1JZCksIGVsZW0gPT4gY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSkpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuIiwgInZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbmZ1bmN0aW9uIG1vcnBoQXR0cnMoZnJvbU5vZGUsIHRvTm9kZSkge1xuICAgIHZhciB0b05vZGVBdHRycyA9IHRvTm9kZS5hdHRyaWJ1dGVzO1xuICAgIHZhciBhdHRyO1xuICAgIHZhciBhdHRyTmFtZTtcbiAgICB2YXIgYXR0ck5hbWVzcGFjZVVSSTtcbiAgICB2YXIgYXR0clZhbHVlO1xuICAgIHZhciBmcm9tVmFsdWU7XG5cbiAgICAvLyBkb2N1bWVudC1mcmFnbWVudHMgZG9udCBoYXZlIGF0dHJpYnV0ZXMgc28gbGV0cyBub3QgZG8gYW55dGhpbmdcbiAgICBpZiAodG9Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IGZyb21Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnRcbiAgICBmb3IgKHZhciBpID0gdG9Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXR0ciA9IHRvTm9kZUF0dHJzW2ldO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgICBhdHRyVmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoZnJvbVZhbHVlICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5wcmVmaXggPT09ICd4bWxucycpe1xuICAgICAgICAgICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTsgLy8gSXQncyBub3QgYWxsb3dlZCB0byBzZXQgYW4gYXR0cmlidXRlIHdpdGggdGhlIFhNTE5TIG5hbWVzcGFjZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGB4bWxuc2AgcHJlZml4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBleHRyYSBhdHRyaWJ1dGVzIGZvdW5kIG9uIHRoZSBvcmlnaW5hbCBET00gZWxlbWVudCB0aGF0XG4gICAgLy8gd2VyZW4ndCBmb3VuZCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgdmFyIGZyb21Ob2RlQXR0cnMgPSBmcm9tTm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgZCA9IGZyb21Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgYXR0ciA9IGZyb21Ob2RlQXR0cnNbZF07XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICBhdHRyTmFtZXNwYWNlVVJJID0gYXR0ci5uYW1lc3BhY2VVUkk7XG5cbiAgICAgICAgaWYgKGF0dHJOYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG5cbiAgICAgICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgcmFuZ2U7IC8vIENyZWF0ZSBhIHJhbmdlIG9iamVjdCBmb3IgZWZmaWNlbnRseSByZW5kZXJpbmcgc3RyaW5ncyB0byBlbGVtZW50cy5cbnZhciBOU19YSFRNTCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcblxudmFyIGRvYyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBkb2N1bWVudDtcbnZhciBIQVNfVEVNUExBVEVfU1VQUE9SVCA9ICEhZG9jICYmICdjb250ZW50JyBpbiBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbnZhciBIQVNfUkFOR0VfU1VQUE9SVCA9ICEhZG9jICYmIGRvYy5jcmVhdGVSYW5nZSAmJiAnY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50JyBpbiBkb2MuY3JlYXRlUmFuZ2UoKTtcblxuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cikge1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShkb2MuYm9keSk7XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50ID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHN0cik7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2JvZHknKTtcbiAgICBmcmFnbWVudC5pbm5lckhUTUwgPSBzdHI7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbi8qKlxuICogVGhpcyBpcyBhYm91dCB0aGUgc2FtZVxuICogdmFyIGh0bWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHN0ciwgJ3RleHQvaHRtbCcpO1xuICogcmV0dXJuIGh0bWwuYm9keS5maXJzdENoaWxkO1xuICpcbiAqIEBtZXRob2QgdG9FbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHRvRWxlbWVudChzdHIpIHtcbiAgICBzdHIgPSBzdHIudHJpbSgpO1xuICAgIGlmIChIQVNfVEVNUExBVEVfU1VQUE9SVCkge1xuICAgICAgLy8gYXZvaWQgcmVzdHJpY3Rpb25zIG9uIGNvbnRlbnQgZm9yIHRoaW5ncyBsaWtlIGA8dHI+PHRoPkhpPC90aD48L3RyPmAgd2hpY2hcbiAgICAgIC8vIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCBkb2Vzbid0IHN1cHBvcnRcbiAgICAgIC8vIDx0ZW1wbGF0ZT4gc3VwcG9ydCBub3QgYXZhaWxhYmxlIGluIElFXG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKTtcbiAgICB9IGVsc2UgaWYgKEhBU19SQU5HRV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tUmFuZ2Uoc3RyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tV3JhcChzdHIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0d28gbm9kZSdzIG5hbWVzIGFyZSB0aGUgc2FtZS5cbiAqXG4gKiBOT1RFOiBXZSBkb24ndCBib3RoZXIgY2hlY2tpbmcgYG5hbWVzcGFjZVVSSWAgYmVjYXVzZSB5b3Ugd2lsbCBuZXZlciBmaW5kIHR3byBIVE1MIGVsZW1lbnRzIHdpdGggdGhlIHNhbWVcbiAqICAgICAgIG5vZGVOYW1lIGFuZCBkaWZmZXJlbnQgbmFtZXNwYWNlIFVSSXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGIgVGhlIHRhcmdldCBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb21wYXJlTm9kZU5hbWVzKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBmcm9tTm9kZU5hbWUgPSBmcm9tRWwubm9kZU5hbWU7XG4gICAgdmFyIHRvTm9kZU5hbWUgPSB0b0VsLm5vZGVOYW1lO1xuICAgIHZhciBmcm9tQ29kZVN0YXJ0LCB0b0NvZGVTdGFydDtcblxuICAgIGlmIChmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnJvbUNvZGVTdGFydCA9IGZyb21Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuICAgIHRvQ29kZVN0YXJ0ID0gdG9Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuXG4gICAgLy8gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgdmlydHVhbCBET00gbm9kZSBvciBTVkcgbm9kZSB0aGVuIHdlIG1heVxuICAgIC8vIG5lZWQgdG8gbm9ybWFsaXplIHRoZSB0YWcgbmFtZSBiZWZvcmUgY29tcGFyaW5nLiBOb3JtYWwgSFRNTCBlbGVtZW50cyB0aGF0IGFyZVxuICAgIC8vIGluIHRoZSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIlxuICAgIC8vIGFyZSBjb252ZXJ0ZWQgdG8gdXBwZXIgY2FzZVxuICAgIGlmIChmcm9tQ29kZVN0YXJ0IDw9IDkwICYmIHRvQ29kZVN0YXJ0ID49IDk3KSB7IC8vIGZyb20gaXMgdXBwZXIgYW5kIHRvIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiBmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKHRvQ29kZVN0YXJ0IDw9IDkwICYmIGZyb21Db2RlU3RhcnQgPj0gOTcpIHsgLy8gdG8gaXMgdXBwZXIgYW5kIGZyb20gaXMgbG93ZXJcbiAgICAgICAgcmV0dXJuIHRvTm9kZU5hbWUgPT09IGZyb21Ob2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVsZW1lbnQsIG9wdGlvbmFsbHkgd2l0aCBhIGtub3duIG5hbWVzcGFjZSBVUkkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGVsZW1lbnQgbmFtZSwgZS5nLiAnZGl2JyBvciAnc3ZnJ1xuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lc3BhY2VVUkldIHRoZSBlbGVtZW50J3MgbmFtZXNwYWNlIFVSSSwgaS5lLiB0aGUgdmFsdWUgb2ZcbiAqIGl0cyBgeG1sbnNgIGF0dHJpYnV0ZSBvciBpdHMgaW5mZXJyZWQgbmFtZXNwYWNlLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lLCBuYW1lc3BhY2VVUkkpIHtcbiAgICByZXR1cm4gIW5hbWVzcGFjZVVSSSB8fCBuYW1lc3BhY2VVUkkgPT09IE5TX1hIVE1MID9cbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSkgOlxuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgbmFtZSk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSBjaGlsZHJlbiBvZiBvbmUgRE9NIGVsZW1lbnQgdG8gYW5vdGhlciBET00gZWxlbWVudFxuICovXG5mdW5jdGlvbiBtb3ZlQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKSB7XG4gICAgdmFyIGN1ckNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgdG9FbC5hcHBlbmRDaGlsZChjdXJDaGlsZCk7XG4gICAgICAgIGN1ckNoaWxkID0gbmV4dENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gdG9FbDtcbn1cblxuZnVuY3Rpb24gc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIG5hbWUpIHtcbiAgICBpZiAoZnJvbUVsW25hbWVdICE9PSB0b0VsW25hbWVdKSB7XG4gICAgICAgIGZyb21FbFtuYW1lXSA9IHRvRWxbbmFtZV07XG4gICAgICAgIGlmIChmcm9tRWxbbmFtZV0pIHtcbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHNwZWNpYWxFbEhhbmRsZXJzID0ge1xuICAgIE9QVElPTjogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZnJvbUVsLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lID09PSAnT1BUR1JPVVAnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBwYXJlbnROYW1lID0gcGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ1NFTEVDVCcgJiYgIXBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21FbC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgJiYgIXRvRWwuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgTVMgRWRnZSBidWcgd2hlcmUgdGhlICdzZWxlY3RlZCcgYXR0cmlidXRlIGNhbiBvbmx5IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZWQgaWYgc2V0IHRvIGEgbm9uLWVtcHR5IHZhbHVlOlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMjA4NzY3OS9cbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byByZXNldCBzZWxlY3QgZWxlbWVudCdzIHNlbGVjdGVkSW5kZXggdG8gLTEsIG90aGVyd2lzZSBzZXR0aW5nXG4gICAgICAgICAgICAgICAgLy8gZnJvbUVsLnNlbGVjdGVkIHVzaW5nIHRoZSBzeW5jQm9vbGVhbkF0dHJQcm9wIGJlbG93IGhhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvcnJlY3Qgc2VsZWN0ZWRJbmRleCB3aWxsIGJlIHNldCBpbiB0aGUgU0VMRUNUIHNwZWNpYWwgaGFuZGxlciBiZWxvdy5cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ3NlbGVjdGVkJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgXCJ2YWx1ZVwiIGF0dHJpYnV0ZSBpcyBzcGVjaWFsIGZvciB0aGUgPGlucHV0PiBlbGVtZW50IHNpbmNlIGl0IHNldHNcbiAgICAgKiB0aGUgaW5pdGlhbCB2YWx1ZS4gQ2hhbmdpbmcgdGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgd2l0aG91dCBjaGFuZ2luZyB0aGVcbiAgICAgKiBcInZhbHVlXCIgcHJvcGVydHkgd2lsbCBoYXZlIG5vIGVmZmVjdCBzaW5jZSBpdCBpcyBvbmx5IHVzZWQgdG8gdGhlIHNldCB0aGVcbiAgICAgKiBpbml0aWFsIHZhbHVlLiAgU2ltaWxhciBmb3IgdGhlIFwiY2hlY2tlZFwiIGF0dHJpYnV0ZSwgYW5kIFwiZGlzYWJsZWRcIi5cbiAgICAgKi9cbiAgICBJTlBVVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnY2hlY2tlZCcpO1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2Rpc2FibGVkJyk7XG5cbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gdG9FbC52YWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgVEVYVEFSRUE6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgLy8gTmVlZGVkIGZvciBJRS4gQXBwYXJlbnRseSBJRSBzZXRzIHRoZSBwbGFjZWhvbGRlciBhcyB0aGVcbiAgICAgICAgICAgIC8vIG5vZGUgdmFsdWUgYW5kIHZpc2UgdmVyc2EuIFRoaXMgaWdub3JlcyBhbiBlbXB0eSB1cGRhdGUuXG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBmaXJzdENoaWxkLm5vZGVWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlID09IG5ld1ZhbHVlIHx8ICghbmV3VmFsdWUgJiYgb2xkVmFsdWUgPT0gZnJvbUVsLnBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgU0VMRUNUOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgaWYgKCF0b0VsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbG9vcCB0aHJvdWdoIGNoaWxkcmVuIG9mIGZyb21FbCwgbm90IHRvRWwgc2luY2Ugbm9kZXMgY2FuIGJlIG1vdmVkXG4gICAgICAgICAgICAvLyBmcm9tIHRvRWwgdG8gZnJvbUVsIGRpcmVjdGx5IHdoZW4gbW9ycGhpbmcuXG4gICAgICAgICAgICAvLyBBdCB0aGUgdGltZSB0aGlzIHNwZWNpYWwgaGFuZGxlciBpcyBpbnZva2VkLCBhbGwgY2hpbGRyZW4gaGF2ZSBhbHJlYWR5IGJlZW4gbW9ycGhlZFxuICAgICAgICAgICAgLy8gYW5kIGFwcGVuZGVkIHRvIC8gcmVtb3ZlZCBmcm9tIGZyb21FbCwgc28gdXNpbmcgZnJvbUVsIGhlcmUgaXMgc2FmZSBhbmQgY29ycmVjdC5cbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdmFyIG9wdGdyb3VwO1xuICAgICAgICAgICAgdmFyIG5vZGVOYW1lO1xuICAgICAgICAgICAgd2hpbGUoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBub2RlTmFtZSA9IGN1ckNoaWxkLm5vZGVOYW1lICYmIGN1ckNoaWxkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUR1JPVVAnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gY3VyQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdPUFRJT04nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJDaGlsZCAmJiBvcHRncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBvcHRncm91cC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbUVsLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxID0gMTE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZGVmYXVsdEdldE5vZGVLZXkobm9kZSkge1xuICBpZiAobm9kZSkge1xuICAgICAgcmV0dXJuIChub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSkgfHwgbm9kZS5pZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3JwaGRvbUZhY3RvcnkobW9ycGhBdHRycykge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1vcnBoZG9tKGZyb21Ob2RlLCB0b05vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRvTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCcgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09ICdIVE1MJyB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvTm9kZUh0bWwgPSB0b05vZGU7XG4gICAgICAgICAgICAgICAgdG9Ob2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICAgICAgICAgICAgICB0b05vZGUuaW5uZXJIVE1MID0gdG9Ob2RlSHRtbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9Ob2RlID0gdG9FbGVtZW50KHRvTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0Tm9kZUtleSA9IG9wdGlvbnMuZ2V0Tm9kZUtleSB8fCBkZWZhdWx0R2V0Tm9kZUtleTtcbiAgICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25Ob2RlQWRkZWQgPSBvcHRpb25zLm9uTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkJlZm9yZUVsVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uRWxVcGRhdGVkID0gb3B0aW9ucy5vbkVsVXBkYXRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVOb2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25Ob2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBjaGlsZHJlbk9ubHkgPSBvcHRpb25zLmNoaWxkcmVuT25seSA9PT0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIG9iamVjdCBpcyB1c2VkIGFzIGEgbG9va3VwIHRvIHF1aWNrbHkgZmluZCBhbGwga2V5ZWQgZWxlbWVudHMgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLlxuICAgICAgICB2YXIgZnJvbU5vZGVzTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdmFyIGtleWVkUmVtb3ZhbExpc3QgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBhZGRLZXllZFJlbW92YWwoa2V5KSB7XG4gICAgICAgICAgICBrZXllZFJlbW92YWxMaXN0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBLZXllZE5vZGVzICYmIChrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBza2lwcGluZyBrZXllZCBub2RlcyB0aGVuIHdlIGFkZCB0aGUga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhIGxpc3Qgc28gdGhhdCBpdCBjYW4gYmUgaGFuZGxlZCBhdCB0aGUgdmVyeSBlbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVwb3J0IHRoZSBub2RlIGFzIGRpc2NhcmRlZCBpZiBpdCBpcyBub3Qga2V5ZWQuIFdlIGRvIHRoaXMgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXQgdGhlIGVuZCB3ZSBsb29wIHRocm91Z2ggYWxsIGtleWVkIGVsZW1lbnRzIHRoYXQgd2VyZSB1bm1hdGNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVuIGRpc2NhcmQgdGhlbSBpbiBvbmUgZmluYWwgcGFzcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKGN1ckNoaWxkLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgRE9NIG5vZGUgb3V0IG9mIHRoZSBvcmlnaW5hbCBET01cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAgICAgICAgICogQHBhcmFtICB7Tm9kZX0gcGFyZW50Tm9kZSBUaGUgbm9kZXMgcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHNraXBLZXllZE5vZGVzIElmIHRydWUgdGhlbiBlbGVtZW50cyB3aXRoIGtleXMgd2lsbCBiZSBza2lwcGVkIGFuZCBub3QgZGlzY2FyZGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUsIHBhcmVudE5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlRGlzY2FyZGVkKG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQobm9kZSk7XG4gICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAvLyBUcmVlV2Fsa2VyIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAvLyBmdW5jdGlvbiBpbmRleFRyZWUocm9vdCkge1xuICAgICAgICAvLyAgICAgdmFyIHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgICAvLyAgICAgICAgIHJvb3QsXG4gICAgICAgIC8vICAgICAgICAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgdmFyIGVsO1xuICAgICAgICAvLyAgICAgd2hpbGUoKGVsID0gdHJlZVdhbGtlci5uZXh0Tm9kZSgpKSkge1xuICAgICAgICAvLyAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGVsKTtcbiAgICAgICAgLy8gICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gZWw7XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gLy8gTm9kZUl0ZXJhdG9yIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAvL1xuICAgICAgICAvLyBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgICAvLyAgICAgdmFyIG5vZGVJdGVyYXRvciA9IGRvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcihub2RlLCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgICAgIC8vICAgICB2YXIgZWw7XG4gICAgICAgIC8vICAgICB3aGlsZSgoZWwgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2FsayByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgICAgICBpbmRleFRyZWUoY3VyQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXhUcmVlKGZyb21Ob2RlKTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVOb2RlQWRkZWQoZWwpIHtcbiAgICAgICAgICAgIG9uTm9kZUFkZGVkKGVsKTtcblxuICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVubWF0Y2hlZEZyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIGEgZHVwbGljYXRlICNpZCBub2RlIGluIGNhY2hlLCByZXBsYWNlIGBlbGAgd2l0aCBjYWNoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbW9ycGggaXQgdG8gdGhlIGNoaWxkIG5vZGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1bm1hdGNoZWRGcm9tRWwgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJDaGlsZCwgdW5tYXRjaGVkRnJvbUVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgY2FsbCBmb3IgY3VyQ2hpbGQgYW5kIGl0J3MgY2hpbGRyZW4gdG8gc2VlIGlmIHdlIGZpbmQgc29tZXRoaW5nIGluXG4gICAgICAgICAgICAgICAgICAvLyBmcm9tTm9kZXNMb29rdXBcbiAgICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBuZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG9mIHRoZSBcInRvIG5vZGVzXCIuIElmIGN1ckZyb21Ob2RlQ2hpbGQgaXNcbiAgICAgICAgICAgIC8vIG5vbi1udWxsIHRoZW4gd2Ugc3RpbGwgaGF2ZSBzb21lIGZyb20gbm9kZXMgbGVmdCBvdmVyIHRoYXQgbmVlZFxuICAgICAgICAgICAgLy8gdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAoKGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3JwaEVsKGZyb21FbCwgdG9FbCwgY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICB2YXIgdG9FbEtleSA9IGdldE5vZGVLZXkodG9FbCk7XG5cbiAgICAgICAgICAgIGlmICh0b0VsS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gZWxlbWVudCB3aXRoIGFuIElEIGlzIGJlaW5nIG1vcnBoZWQgdGhlbiBpdCB3aWxsIGJlIGluIHRoZSBmaW5hbFxuICAgICAgICAgICAgICAgIC8vIERPTSBzbyBjbGVhciBpdCBvdXQgb2YgdGhlIHNhdmVkIGVsZW1lbnRzIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBkZWxldGUgZnJvbU5vZGVzTG9va3VwW3RvRWxLZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuT25seSkge1xuICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlRWxVcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYXR0cmlidXRlcyBvbiBvcmlnaW5hbCBET00gZWxlbWVudCBmaXJzdFxuICAgICAgICAgICAgICAgIG1vcnBoQXR0cnMoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICAgICAgICAgIG9uRWxVcGRhdGVkKGZyb21FbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZChmcm9tRWwsIHRvRWwpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZnJvbUVsLm5vZGVOYW1lICE9PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgICAgIG1vcnBoQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNwZWNpYWxFbEhhbmRsZXJzLlRFWFRBUkVBKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgICAgICAgICAgdmFyIGN1clRvTm9kZUNoaWxkID0gdG9FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBjdXJUb05vZGVLZXk7XG4gICAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVLZXk7XG5cbiAgICAgICAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB2YXIgdG9OZXh0U2libGluZztcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ0Zyb21FbDtcblxuICAgICAgICAgICAgLy8gd2FsayB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIG91dGVyOiB3aGlsZSAoY3VyVG9Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0b05leHRTaWJsaW5nID0gY3VyVG9Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY3VyVG9Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJUb05vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAvLyB3YWxrIHRoZSBmcm9tTm9kZSBjaGlsZHJlbiBhbGwgdGhlIHdheSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZSAmJiBjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlVHlwZSA9IGN1ckZyb21Ob2RlQ2hpbGQubm9kZVR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtZWFucyBpZiB0aGUgY3VyRnJvbU5vZGVDaGlsZCBkb2VzbnQgaGF2ZSBhIG1hdGNoIHdpdGggdGhlIGN1clRvTm9kZUNoaWxkXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0NvbXBhdGlibGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIEVsZW1lbnQgbm9kZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBub2RlIGhhcyBhIGtleSBzbyB3ZSB3YW50IHRvIG1hdGNoIGl0IHVwIHdpdGggdGhlIGNvcnJlY3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSAhPT0gY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlIGRvZXMgbm90IGhhdmUgYSBtYXRjaGluZyBrZXkgc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGNoZWNrIG91ciBsb29rdXAgdG8gc2VlIGlmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21OZXh0U2libGluZyA9PT0gbWF0Y2hpbmdGcm9tRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBzaW5nbGUgZWxlbWVudCByZW1vdmFscy4gVG8gYXZvaWQgcmVtb3ZpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERPTSBub2RlIG91dCBvZiB0aGUgdHJlZSAoc2luY2UgdGhhdCBjYW4gYnJlYWsgQ1NTIHRyYW5zaXRpb25zLCBldGMuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBpbnN0ZWFkIGRpc2NhcmQgdGhlIGN1cnJlbnQgbm9kZSBhbmQgd2FpdCB1bnRpbCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24gdG8gcHJvcGVybHkgbWF0Y2ggdXAgdGhlIGtleWVkIHRhcmdldCBlbGVtZW50IHdpdGggaXRzIG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBtYXRjaGluZyBrZXllZCBlbGVtZW50IHNvbWV3aGVyZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIG1vdmUgdGhlIG9yaWdpbmFsIERPTSBub2RlIGludG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIG1vcnBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIHVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiByZXBsYWNlQ2hpbGQgYmVjYXVzZSB3ZSB3YW50IHRvIGdvIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGByZW1vdmVOb2RlKClgIGZ1bmN0aW9uIGZvciB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRpc2NhcmRlZCBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBsaWZlY3ljbGUgaG9va3MgYXJlIGNvcnJlY3RseSBpbnZva2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5pbnNlcnRCZWZvcmUobWF0Y2hpbmdGcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBtYXRjaGluZ0Zyb21FbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBub2RlcyBhcmUgbm90IGNvbXBhdGlibGUgc2luY2UgdGhlIFwidG9cIiBub2RlIGhhcyBhIGtleSBhbmQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBubyBtYXRjaGluZyBrZXllZCBub2RlIGluIHRoZSBzb3VyY2UgdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgaGFzIGEga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGlzQ29tcGF0aWJsZSAhPT0gZmFsc2UgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBjb21wYXRpYmxlIERPTSBlbGVtZW50cyBzbyB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgXCJmcm9tXCIgbm9kZSB0byBtYXRjaCB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgRE9NIG5vZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1PUlBIXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoRWwoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBjdXJGcm9tTm9kZVR5cGUgPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQm90aCBub2RlcyBiZWluZyBjb21wYXJlZCBhcmUgVGV4dCBvciBDb21tZW50IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbHkgdXBkYXRlIG5vZGVWYWx1ZSBvbiB0aGUgb3JpZ2luYWwgbm9kZSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgdGV4dCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSAhPT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlID0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBib3RoIHRoZSBcInRvXCIgY2hpbGQgYW5kIHRoZSBcImZyb21cIiBjaGlsZCBzaW5jZSB3ZSBmb3VuZCBhIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGVsc2UgdG8gZG8gYXMgd2UgYWxyZWFkeSByZWN1cnNpdmVseSBjYWxsZWQgbW9ycGhDaGlsZHJlbiBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY29tcGF0aWJsZSBtYXRjaCBzbyByZW1vdmUgdGhlIG9sZCBub2RlIGZyb20gdGhlIERPTSBhbmQgY29udGludWUgdHJ5aW5nIHRvIGZpbmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCBpbiB0aGUgb3JpZ2luYWwgRE9NLiBIb3dldmVyLCB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIGZyb20gbm9kZSBpcyBub3Qga2V5ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXQgaXMgcG9zc2libGUgdGhhdCBhIGtleWVkIG5vZGUgbWlnaHQgbWF0Y2ggdXAgd2l0aCBhIG5vZGUgc29tZXdoZXJlIGVsc2UgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhcmdldCB0cmVlIGFuZCB3ZSBkb24ndCB3YW50IHRvIGRpc2NhcmQgaXQganVzdCB5ZXQgc2luY2UgaXQgc3RpbGwgbWlnaHQgZmluZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGhvbWUgaW4gdGhlIGZpbmFsIERPTSB0cmVlLiBBZnRlciBldmVyeXRoaW5nIGlzIGRvbmUgd2Ugd2lsbCByZW1vdmUgYW55IGtleWVkIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgZGlkbid0IGZpbmQgYSBob21lXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH0gLy8gRU5EOiB3aGlsZShjdXJGcm9tTm9kZUNoaWxkKSB7fVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHRoZW4gd2UgZGlkIG5vdCBmaW5kIGEgY2FuZGlkYXRlIG1hdGNoIGZvclxuICAgICAgICAgICAgICAgIC8vIG91ciBcInRvIG5vZGVcIiBhbmQgd2UgZXhoYXVzdGVkIGFsbCBvZiB0aGUgY2hpbGRyZW4gXCJmcm9tXCJcbiAgICAgICAgICAgICAgICAvLyBub2Rlcy4gVGhlcmVmb3JlLCB3ZSB3aWxsIGp1c3QgYXBwZW5kIHRoZSBjdXJyZW50IFwidG9cIiBub2RlXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIGVuZFxuICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgJiYgKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pICYmIGNvbXBhcmVOb2RlTmFtZXMobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tRWwuYXBwZW5kQ2hpbGQobWF0Y2hpbmdGcm9tRWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBNT1JQSFxuICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ID0gb25CZWZvcmVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBjdXJUb05vZGVDaGlsZC5hY3R1YWxpemUoZnJvbUVsLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5hcHBlbmRDaGlsZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSk7XG5cbiAgICAgICAgICAgIHZhciBzcGVjaWFsRWxIYW5kbGVyID0gc3BlY2lhbEVsSGFuZGxlcnNbZnJvbUVsLm5vZGVOYW1lXTtcbiAgICAgICAgICAgIGlmIChzcGVjaWFsRWxIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbEVsSGFuZGxlcihmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIEVORDogbW9ycGhDaGlsZHJlbiguLi4pXG5cbiAgICAgICAgdmFyIG1vcnBoZWROb2RlID0gZnJvbU5vZGU7XG4gICAgICAgIHZhciBtb3JwaGVkTm9kZVR5cGUgPSBtb3JwaGVkTm9kZS5ub2RlVHlwZTtcbiAgICAgICAgdmFyIHRvTm9kZVR5cGUgPSB0b05vZGUubm9kZVR5cGU7XG5cbiAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBhcmUgZ2l2ZW4gdHdvIERPTSBub2RlcyB0aGF0IGFyZSBub3RcbiAgICAgICAgICAgIC8vIGNvbXBhdGlibGUgKGUuZy4gPGRpdj4gLS0+IDxzcGFuPiBvciA8ZGl2PiAtLT4gVEVYVClcbiAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIGlmICh0b05vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlTm9kZU5hbWVzKGZyb21Ob2RlLCB0b05vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3ZlQ2hpbGRyZW4oZnJvbU5vZGUsIGNyZWF0ZUVsZW1lbnROUyh0b05vZGUubm9kZU5hbWUsIHRvTm9kZS5uYW1lc3BhY2VVUkkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdvaW5nIGZyb20gYW4gZWxlbWVudCBub2RlIHRvIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBURVhUX05PREUgfHwgbW9ycGhlZE5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHsgLy8gVGV4dCBvciBjb21tZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gbW9ycGhlZE5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZS5ub2RlVmFsdWUgIT09IHRvTm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlLm5vZGVWYWx1ZSA9IHRvTm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGV4dCBub2RlIHRvIHNvbWV0aGluZyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3JwaGVkTm9kZSA9PT0gdG9Ob2RlKSB7XG4gICAgICAgICAgICAvLyBUaGUgXCJ0byBub2RlXCIgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIFwiZnJvbSBub2RlXCIgc28gd2UgaGFkIHRvXG4gICAgICAgICAgICAvLyB0b3NzIG91dCB0aGUgXCJmcm9tIG5vZGVcIiBhbmQgdXNlIHRoZSBcInRvIG5vZGVcIlxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b05vZGUuaXNTYW1lTm9kZSAmJiB0b05vZGUuaXNTYW1lTm9kZShtb3JwaGVkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vcnBoRWwobW9ycGhlZE5vZGUsIHRvTm9kZSwgY2hpbGRyZW5Pbmx5KTtcblxuICAgICAgICAgICAgLy8gV2Ugbm93IG5lZWQgdG8gbG9vcCBvdmVyIGFueSBrZXllZCBub2RlcyB0aGF0IG1pZ2h0IG5lZWQgdG8gYmVcbiAgICAgICAgICAgIC8vIHJlbW92ZWQuIFdlIG9ubHkgZG8gdGhlIHJlbW92YWwgaWYgd2Uga25vdyB0aGF0IHRoZSBrZXllZCBub2RlXG4gICAgICAgICAgICAvLyBuZXZlciBmb3VuZCBhIG1hdGNoLiBXaGVuIGEga2V5ZWQgbm9kZSBpcyBtYXRjaGVkIHVwIHdlIHJlbW92ZVxuICAgICAgICAgICAgLy8gaXQgb3V0IG9mIGZyb21Ob2Rlc0xvb2t1cCBhbmQgd2UgdXNlIGZyb21Ob2Rlc0xvb2t1cCB0byBkZXRlcm1pbmVcbiAgICAgICAgICAgIC8vIGlmIGEga2V5ZWQgbm9kZSBoYXMgYmVlbiBtYXRjaGVkIHVwIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGtleWVkUmVtb3ZhbExpc3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1rZXllZFJlbW92YWxMaXN0Lmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxUb1JlbW92ZSA9IGZyb21Ob2Rlc0xvb2t1cFtrZXllZFJlbW92YWxMaXN0W2ldXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsVG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoZWxUb1JlbW92ZSwgZWxUb1JlbW92ZS5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoaWxkcmVuT25seSAmJiBtb3JwaGVkTm9kZSAhPT0gZnJvbU5vZGUgJiYgZnJvbU5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKG1vcnBoZWROb2RlLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW9ycGhlZE5vZGUuYWN0dWFsaXplKGZyb21Ob2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhZCB0byBzd2FwIG91dCB0aGUgZnJvbSBub2RlIHdpdGggYSBuZXcgbm9kZSBiZWNhdXNlIHRoZSBvbGRcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIHRhcmdldCBub2RlIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgb2xkIERPTSBub2RlIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS4gVGhpcyBpcyBvbmx5XG4gICAgICAgICAgICAvLyBwb3NzaWJsZSBpZiB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgd2FzIHBhcnQgb2YgYSBET00gdHJlZSB3aGljaFxuICAgICAgICAgICAgLy8gd2Uga25vdyBpcyB0aGUgY2FzZSBpZiBpdCBoYXMgYSBwYXJlbnQgbm9kZS5cbiAgICAgICAgICAgIGZyb21Ob2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG1vcnBoZWROb2RlLCBmcm9tTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgfTtcbn1cblxudmFyIG1vcnBoZG9tID0gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpO1xuXG5leHBvcnQgZGVmYXVsdCBtb3JwaGRvbTtcbiIsICJpbXBvcnQge1xuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfRElTQUJMRV9XSVRILFxuICBQSFhfRkVFREJBQ0tfRk9SLFxuICBQSFhfUFJVTkUsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX1NLSVAsXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9UUklHR0VSX0FDVElPTixcbiAgUEhYX1VQREFURVxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBkZXRlY3REdXBsaWNhdGVJZHMsXG4gIGlzQ2lkXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IERPTVBvc3RNb3JwaFJlc3RvcmVyIGZyb20gXCIuL2RvbV9wb3N0X21vcnBoX3Jlc3RvcmVyXCJcbmltcG9ydCBtb3JwaGRvbSBmcm9tIFwibW9ycGhkb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01QYXRjaCB7XG4gIHN0YXRpYyBwYXRjaEVsKGZyb21FbCwgdG9FbCwgYWN0aXZlRWxlbWVudCl7XG4gICAgbW9ycGhkb20oZnJvbUVsLCB0b0VsLCB7XG4gICAgICBjaGlsZHJlbk9ubHk6IGZhbHNlLFxuICAgICAgb25CZWZvcmVFbFVwZGF0ZWQ6IChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgICAgaWYoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LmlzU2FtZU5vZGUoZnJvbUVsKSAmJiBET00uaXNGb3JtSW5wdXQoZnJvbUVsKSl7XG4gICAgICAgICAgRE9NLm1lcmdlRm9jdXNlZElucHV0KGZyb21FbCwgdG9FbClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjb25zdHJ1Y3Rvcih2aWV3LCBjb250YWluZXIsIGlkLCBodG1sLCB0YXJnZXRDSUQpe1xuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgICB0aGlzLmxpdmVTb2NrZXQgPSB2aWV3LmxpdmVTb2NrZXRcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lclxuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMucm9vdElEID0gdmlldy5yb290LmlkXG4gICAgdGhpcy5odG1sID0gaHRtbFxuICAgIHRoaXMudGFyZ2V0Q0lEID0gdGFyZ2V0Q0lEXG4gICAgdGhpcy5jaWRQYXRjaCA9IGlzQ2lkKHRoaXMudGFyZ2V0Q0lEKVxuICAgIHRoaXMuY2FsbGJhY2tzID0ge1xuICAgICAgYmVmb3JlYWRkZWQ6IFtdLCBiZWZvcmV1cGRhdGVkOiBbXSwgYmVmb3JlcGh4Q2hpbGRBZGRlZDogW10sXG4gICAgICBhZnRlcmFkZGVkOiBbXSwgYWZ0ZXJ1cGRhdGVkOiBbXSwgYWZ0ZXJkaXNjYXJkZWQ6IFtdLCBhZnRlcnBoeENoaWxkQWRkZWQ6IFtdLFxuICAgICAgYWZ0ZXJ0cmFuc2l0aW9uc0Rpc2NhcmRlZDogW11cbiAgICB9XG4gIH1cblxuICBiZWZvcmUoa2luZCwgY2FsbGJhY2speyB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLnB1c2goY2FsbGJhY2spIH1cbiAgYWZ0ZXIoa2luZCwgY2FsbGJhY2speyB0aGlzLmNhbGxiYWNrc1tgYWZ0ZXIke2tpbmR9YF0ucHVzaChjYWxsYmFjaykgfVxuXG4gIHRyYWNrQmVmb3JlKGtpbmQsIC4uLmFyZ3Mpe1xuICAgIHRoaXMuY2FsbGJhY2tzW2BiZWZvcmUke2tpbmR9YF0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayguLi5hcmdzKSlcbiAgfVxuXG4gIHRyYWNrQWZ0ZXIoa2luZCwgLi4uYXJncyl7XG4gICAgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soLi4uYXJncykpXG4gIH1cblxuICBtYXJrUHJ1bmFibGVDb250ZW50Rm9yUmVtb3ZhbCgpe1xuICAgIERPTS5hbGwodGhpcy5jb250YWluZXIsIFwiW3BoeC11cGRhdGU9YXBwZW5kXSA+ICosIFtwaHgtdXBkYXRlPXByZXBlbmRdID4gKlwiLCBlbCA9PiB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1BSVU5FLCBcIlwiKVxuICAgIH0pXG4gIH1cblxuICBwZXJmb3JtKCl7XG4gICAgbGV0IHt2aWV3LCBsaXZlU29ja2V0LCBjb250YWluZXIsIGh0bWx9ID0gdGhpc1xuICAgIGxldCB0YXJnZXRDb250YWluZXIgPSB0aGlzLmlzQ0lEUGF0Y2goKSA/IHRoaXMudGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpIDogY29udGFpbmVyXG4gICAgaWYodGhpcy5pc0NJRFBhdGNoKCkgJiYgIXRhcmdldENvbnRhaW5lcil7IHJldHVybiB9XG5cbiAgICBsZXQgZm9jdXNlZCA9IGxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpXG4gICAgbGV0IHtzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kfSA9IGZvY3VzZWQgJiYgRE9NLmhhc1NlbGVjdGlvblJhbmdlKGZvY3VzZWQpID8gZm9jdXNlZCA6IHt9XG4gICAgbGV0IHBoeFVwZGF0ZSA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVVBEQVRFKVxuICAgIGxldCBwaHhGZWVkYmFja0ZvciA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKVxuICAgIGxldCBkaXNhYmxlV2l0aCA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKVxuICAgIGxldCBwaHhUcmlnZ2VyRXh0ZXJuYWwgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1RSSUdHRVJfQUNUSU9OKVxuICAgIGxldCBwaHhSZW1vdmUgPSBsaXZlU29ja2V0LmJpbmRpbmcoXCJyZW1vdmVcIilcbiAgICBsZXQgYWRkZWQgPSBbXVxuICAgIGxldCB1cGRhdGVzID0gW11cbiAgICBsZXQgYXBwZW5kUHJlcGVuZFVwZGF0ZXMgPSBbXVxuICAgIGxldCBwZW5kaW5nUmVtb3ZlcyA9IFtdXG4gICAgbGV0IGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IG51bGxcblxuICAgIGxldCBkaWZmSFRNTCA9IGxpdmVTb2NrZXQudGltZShcInByZW1vcnBoIGNvbnRhaW5lciBwcmVwXCIsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmJ1aWxkRGlmZkhUTUwoY29udGFpbmVyLCBodG1sLCBwaHhVcGRhdGUsIHRhcmdldENvbnRhaW5lcilcbiAgICB9KVxuXG4gICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGNvbnRhaW5lcilcbiAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBjb250YWluZXIsIGNvbnRhaW5lcilcblxuICAgIGxpdmVTb2NrZXQudGltZShcIm1vcnBoZG9tXCIsICgpID0+IHtcbiAgICAgIG1vcnBoZG9tKHRhcmdldENvbnRhaW5lciwgZGlmZkhUTUwsIHtcbiAgICAgICAgY2hpbGRyZW5Pbmx5OiB0YXJnZXRDb250YWluZXIuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpID09PSBudWxsLFxuICAgICAgICBnZXROb2RlS2V5OiAobm9kZSkgPT4ge1xuICAgICAgICAgIHJldHVybiBET00uaXNQaHhEZXN0cm95ZWQobm9kZSkgPyBudWxsIDogbm9kZS5pZFxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZU5vZGVBZGRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGVsKVxuICAgICAgICAgIHJldHVybiBlbFxuICAgICAgICB9LFxuICAgICAgICBvbk5vZGVBZGRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgLy8gaGFjayB0byBmaXggU2FmYXJpIGhhbmRsaW5nIG9mIGltZyBzcmNzZXQgYW5kIHZpZGVvIHRhZ3NcbiAgICAgICAgICBpZihlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgZWwuc3Jjc2V0KXtcbiAgICAgICAgICAgIGVsLnNyY3NldCA9IGVsLnNyY3NldFxuICAgICAgICAgIH0gZWxzZSBpZihlbCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgJiYgZWwuYXV0b3BsYXkpe1xuICAgICAgICAgICAgZWwucGxheSgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKERPTS5pc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCkpe1xuICAgICAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gZWxcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9pbnB1dCBoYW5kbGluZ1xuICAgICAgICAgIERPTS5kaXNjYXJkRXJyb3IodGFyZ2V0Q29udGFpbmVyLCBlbCwgcGh4RmVlZGJhY2tGb3IpXG4gICAgICAgICAgLy8gbmVzdGVkIHZpZXcgaGFuZGxpbmdcbiAgICAgICAgICBpZigoRE9NLmlzUGh4Q2hpbGQoZWwpICYmIHZpZXcub3duc0VsZW1lbnQoZWwpKSB8fCBET00uaXNQaHhTdGlja3koZWwpICYmIHZpZXcub3duc0VsZW1lbnQoZWwucGFyZW50Tm9kZSkpe1xuICAgICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwicGh4Q2hpbGRBZGRlZFwiLCBlbClcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkZWQucHVzaChlbClcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob2RlRGlzY2FyZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgICAgICAgIGlmKERPTS5pc1BoeENoaWxkKGVsKSB8fCBET00uaXNQaHhTdGlja3koZWwpKXsgbGl2ZVNvY2tldC5kZXN0cm95Vmlld0J5RWwoZWwpIH1cbiAgICAgICAgICB0aGlzLnRyYWNrQWZ0ZXIoXCJkaXNjYXJkZWRcIiwgZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfUFJVTkUpICE9PSBudWxsKXsgcmV0dXJuIHRydWUgfVxuICAgICAgICAgIGlmKGVsLnBhcmVudE5vZGUgIT09IG51bGwgJiYgRE9NLmlzUGh4VXBkYXRlKGVsLnBhcmVudE5vZGUsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkgJiYgZWwuaWQpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUocGh4UmVtb3ZlKSl7XG4gICAgICAgICAgICBwZW5kaW5nUmVtb3Zlcy5wdXNoKGVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRoaXMuc2tpcENJRFNpYmxpbmcoZWwpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBvbkVsVXBkYXRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgaWYoRE9NLmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSl7XG4gICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbFxuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVzLnB1c2goZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICAgICAgRE9NLmNsZWFuQ2hpbGROb2Rlcyh0b0VsLCBwaHhVcGRhdGUpXG4gICAgICAgICAgaWYodGhpcy5za2lwQ0lEU2libGluZyh0b0VsKSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgaWYoRE9NLmlzUGh4U3RpY2t5KGZyb21FbCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKERPTS5pc0lnbm9yZWQoZnJvbUVsLCBwaHhVcGRhdGUpKXtcbiAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbClcbiAgICAgICAgICAgIERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwge2lzSWdub3JlZDogdHJ1ZX0pXG4gICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZnJvbUVsLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgKGZyb21FbC52YWxpZGl0eSAmJiBmcm9tRWwudmFsaWRpdHkuYmFkSW5wdXQpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZighRE9NLnN5bmNQZW5kaW5nUmVmKGZyb21FbCwgdG9FbCwgZGlzYWJsZVdpdGgpKXtcbiAgICAgICAgICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGZyb21FbCkpe1xuICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYoRE9NLmlzUGh4Q2hpbGQodG9FbCkpe1xuICAgICAgICAgICAgbGV0IHByZXZTZXNzaW9uID0gZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTilcbiAgICAgICAgICAgIERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwge2V4Y2x1ZGU6IFtQSFhfU1RBVElDXX0pXG4gICAgICAgICAgICBpZihwcmV2U2Vzc2lvbiAhPT0gXCJcIil7IGZyb21FbC5zZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04sIHByZXZTZXNzaW9uKSB9XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3RJRClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaW5wdXQgaGFuZGxpbmdcbiAgICAgICAgICBET00uY29weVByaXZhdGVzKHRvRWwsIGZyb21FbClcbiAgICAgICAgICBET00uZGlzY2FyZEVycm9yKHRhcmdldENvbnRhaW5lciwgdG9FbCwgcGh4RmVlZGJhY2tGb3IpXG5cbiAgICAgICAgICBsZXQgaXNGb2N1c2VkRm9ybUVsID0gZm9jdXNlZCAmJiBmcm9tRWwuaXNTYW1lTm9kZShmb2N1c2VkKSAmJiBET00uaXNGb3JtSW5wdXQoZnJvbUVsKVxuICAgICAgICAgIGlmKGlzRm9jdXNlZEZvcm1FbCl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VGb2N1c2VkSW5wdXQoZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgRE9NLnN5bmNBdHRyc1RvUHJvcHMoZnJvbUVsKVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKERPTS5pc1BoeFVwZGF0ZSh0b0VsLCBwaHhVcGRhdGUsIFtcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pKXtcbiAgICAgICAgICAgICAgYXBwZW5kUHJlcGVuZFVwZGF0ZXMucHVzaChuZXcgRE9NUG9zdE1vcnBoUmVzdG9yZXIoZnJvbUVsLCB0b0VsLCB0b0VsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIERPTS5zeW5jQXR0cnNUb1Byb3BzKHRvRWwpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKHRvRWwpXG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYobGl2ZVNvY2tldC5pc0RlYnVnRW5hYmxlZCgpKXsgZGV0ZWN0RHVwbGljYXRlSWRzKCkgfVxuXG4gICAgaWYoYXBwZW5kUHJlcGVuZFVwZGF0ZXMubGVuZ3RoID4gMCl7XG4gICAgICBsaXZlU29ja2V0LnRpbWUoXCJwb3N0LW1vcnBoIGFwcGVuZC9wcmVwZW5kIHJlc3RvcmF0aW9uXCIsICgpID0+IHtcbiAgICAgICAgYXBwZW5kUHJlcGVuZFVwZGF0ZXMuZm9yRWFjaCh1cGRhdGUgPT4gdXBkYXRlLnBlcmZvcm0oKSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgbGl2ZVNvY2tldC5zaWxlbmNlRXZlbnRzKCgpID0+IERPTS5yZXN0b3JlRm9jdXMoZm9jdXNlZCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCkpXG4gICAgRE9NLmRpc3BhdGNoRXZlbnQoZG9jdW1lbnQsIFwicGh4OnVwZGF0ZVwiKVxuICAgIGFkZGVkLmZvckVhY2goZWwgPT4gdGhpcy50cmFja0FmdGVyKFwiYWRkZWRcIiwgZWwpKVxuICAgIHVwZGF0ZXMuZm9yRWFjaChlbCA9PiB0aGlzLnRyYWNrQWZ0ZXIoXCJ1cGRhdGVkXCIsIGVsKSlcblxuICAgIGlmKHBlbmRpbmdSZW1vdmVzLmxlbmd0aCA+IDApe1xuICAgICAgbGl2ZVNvY2tldC50cmFuc2l0aW9uUmVtb3ZlcyhwZW5kaW5nUmVtb3ZlcylcbiAgICAgIGxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIHBlbmRpbmdSZW1vdmVzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGxldCBjaGlsZCA9IERPTS5maXJzdFBoeENoaWxkKGVsKVxuICAgICAgICAgIGlmKGNoaWxkKXsgbGl2ZVNvY2tldC5kZXN0cm95Vmlld0J5RWwoY2hpbGQpIH1cbiAgICAgICAgICBlbC5yZW1vdmUoKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnRyYWNrQWZ0ZXIoXCJ0cmFuc2l0aW9uc0Rpc2NhcmRlZFwiLCBwZW5kaW5nUmVtb3ZlcylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkKXtcbiAgICAgIGxpdmVTb2NrZXQuZGlzY29ubmVjdCgpXG4gICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQuc3VibWl0KClcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlzQ0lEUGF0Y2goKXsgcmV0dXJuIHRoaXMuY2lkUGF0Y2ggfVxuXG4gIHNraXBDSURTaWJsaW5nKGVsKXtcbiAgICByZXR1cm4gZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfU0tJUCkgIT09IG51bGxcbiAgfVxuXG4gIHRhcmdldENJRENvbnRhaW5lcihodG1sKXtcbiAgICBpZighdGhpcy5pc0NJRFBhdGNoKCkpeyByZXR1cm4gfVxuICAgIGxldCBbZmlyc3QsIC4uLnJlc3RdID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmNvbnRhaW5lciwgdGhpcy50YXJnZXRDSUQpXG4gICAgaWYocmVzdC5sZW5ndGggPT09IDAgJiYgRE9NLmNoaWxkTm9kZUxlbmd0aChodG1sKSA9PT0gMSl7XG4gICAgICByZXR1cm4gZmlyc3RcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnBhcmVudE5vZGVcbiAgICB9XG4gIH1cblxuICAvLyBidWlsZHMgSFRNTCBmb3IgbW9ycGhkb20gcGF0Y2hcbiAgLy8gLSBmb3IgZnVsbCBwYXRjaGVzIG9mIExpdmVWaWV3IG9yIGEgY29tcG9uZW50IHdpdGggYSBzaW5nbGVcbiAgLy8gICByb290IG5vZGUsIHNpbXBseSByZXR1cm5zIHRoZSBIVE1MXG4gIC8vIC0gZm9yIHBhdGNoZXMgb2YgYSBjb21wb25lbnQgd2l0aCBtdWx0aXBsZSByb290IG5vZGVzLCB0aGVcbiAgLy8gICBwYXJlbnQgbm9kZSBiZWNvbWVzIHRoZSB0YXJnZXQgY29udGFpbmVyIGFuZCBub24tY29tcG9uZW50XG4gIC8vICAgc2libGluZ3MgYXJlIG1hcmtlZCBhcyBza2lwLlxuICBidWlsZERpZmZIVE1MKGNvbnRhaW5lciwgaHRtbCwgcGh4VXBkYXRlLCB0YXJnZXRDb250YWluZXIpe1xuICAgIGxldCBpc0NJRFBhdGNoID0gdGhpcy5pc0NJRFBhdGNoKClcbiAgICBsZXQgaXNDSURXaXRoU2luZ2xlUm9vdCA9IGlzQ0lEUGF0Y2ggJiYgdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gdGhpcy50YXJnZXRDSUQudG9TdHJpbmcoKVxuICAgIGlmKCFpc0NJRFBhdGNoIHx8IGlzQ0lEV2l0aFNpbmdsZVJvb3Qpe1xuICAgICAgcmV0dXJuIGh0bWxcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcG9uZW50IHBhdGNoIHdpdGggbXVsdGlwbGUgQ0lEIHJvb3RzXG4gICAgICBsZXQgZGlmZkNvbnRhaW5lciA9IG51bGxcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgICAgZGlmZkNvbnRhaW5lciA9IERPTS5jbG9uZU5vZGUodGFyZ2V0Q29udGFpbmVyKVxuICAgICAgbGV0IFtmaXJzdENvbXBvbmVudCwgLi4ucmVzdF0gPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KGRpZmZDb250YWluZXIsIHRoaXMudGFyZ2V0Q0lEKVxuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgICAgcmVzdC5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKVxuICAgICAgQXJyYXkuZnJvbShkaWZmQ29udGFpbmVyLmNoaWxkTm9kZXMpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAvLyB3ZSBjYW4gb25seSBza2lwIHRyYWNrYWJsZSBub2RlcyB3aXRoIGFuIElEXG4gICAgICAgIGlmKGNoaWxkLmlkICYmIGNoaWxkLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkgIT09IHRoaXMudGFyZ2V0Q0lELnRvU3RyaW5nKCkpe1xuICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShQSFhfU0tJUCwgXCJcIilcbiAgICAgICAgICBjaGlsZC5pbm5lckhUTUwgPSBcIlwiXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBBcnJheS5mcm9tKHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2RlcykuZm9yRWFjaChlbCA9PiBkaWZmQ29udGFpbmVyLmluc2VydEJlZm9yZShlbCwgZmlyc3RDb21wb25lbnQpKVxuICAgICAgZmlyc3RDb21wb25lbnQucmVtb3ZlKClcbiAgICAgIHJldHVybiBkaWZmQ29udGFpbmVyLm91dGVySFRNTFxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIENPTVBPTkVOVFMsXG4gIERZTkFNSUNTLFxuICBURU1QTEFURVMsXG4gIEVWRU5UUyxcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX1NLSVAsXG4gIFJFUExZLFxuICBTVEFUSUMsXG4gIFRJVExFXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGlzT2JqZWN0LFxuICBsb2dFcnJvcixcbiAgaXNDaWQsXG59IGZyb20gXCIuL3V0aWxzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyZWQge1xuICBzdGF0aWMgZXh0cmFjdChkaWZmKXtcbiAgICBsZXQge1tSRVBMWV06IHJlcGx5LCBbRVZFTlRTXTogZXZlbnRzLCBbVElUTEVdOiB0aXRsZX0gPSBkaWZmXG4gICAgZGVsZXRlIGRpZmZbUkVQTFldXG4gICAgZGVsZXRlIGRpZmZbRVZFTlRTXVxuICAgIGRlbGV0ZSBkaWZmW1RJVExFXVxuICAgIHJldHVybiB7ZGlmZiwgdGl0bGUsIHJlcGx5OiByZXBseSB8fCBudWxsLCBldmVudHM6IGV2ZW50cyB8fCBbXX1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHZpZXdJZCwgcmVuZGVyZWQpe1xuICAgIHRoaXMudmlld0lkID0gdmlld0lkXG4gICAgdGhpcy5yZW5kZXJlZCA9IHt9XG4gICAgdGhpcy5tZXJnZURpZmYocmVuZGVyZWQpXG4gIH1cblxuICBwYXJlbnRWaWV3SWQoKXsgcmV0dXJuIHRoaXMudmlld0lkIH1cblxuICB0b1N0cmluZyhvbmx5Q2lkcyl7XG4gICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlVG9TdHJpbmcodGhpcy5yZW5kZXJlZCwgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSwgb25seUNpZHMpXG4gIH1cblxuICByZWN1cnNpdmVUb1N0cmluZyhyZW5kZXJlZCwgY29tcG9uZW50cyA9IHJlbmRlcmVkW0NPTVBPTkVOVFNdLCBvbmx5Q2lkcyl7XG4gICAgb25seUNpZHMgPSBvbmx5Q2lkcyA/IG5ldyBTZXQob25seUNpZHMpIDogbnVsbFxuICAgIGxldCBvdXRwdXQgPSB7YnVmZmVyOiBcIlwiLCBjb21wb25lbnRzOiBjb21wb25lbnRzLCBvbmx5Q2lkczogb25seUNpZHN9XG4gICAgdGhpcy50b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgbnVsbCwgb3V0cHV0KVxuICAgIHJldHVybiBvdXRwdXQuYnVmZmVyXG4gIH1cblxuICBjb21wb25lbnRDSURzKGRpZmYpeyByZXR1cm4gT2JqZWN0LmtleXMoZGlmZltDT01QT05FTlRTXSB8fCB7fSkubWFwKGkgPT4gcGFyc2VJbnQoaSkpIH1cblxuICBpc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpe1xuICAgIGlmKCFkaWZmW0NPTVBPTkVOVFNdKXsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGlmZikubGVuZ3RoID09PSAxXG4gIH1cblxuICBnZXRDb21wb25lbnQoZGlmZiwgY2lkKXsgcmV0dXJuIGRpZmZbQ09NUE9ORU5UU11bY2lkXSB9XG5cbiAgbWVyZ2VEaWZmKGRpZmYpe1xuICAgIGxldCBuZXdjID0gZGlmZltDT01QT05FTlRTXVxuICAgIGxldCBjYWNoZSA9IHt9XG4gICAgZGVsZXRlIGRpZmZbQ09NUE9ORU5UU11cbiAgICB0aGlzLnJlbmRlcmVkID0gdGhpcy5tdXRhYmxlTWVyZ2UodGhpcy5yZW5kZXJlZCwgZGlmZilcbiAgICB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdID0gdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSB8fCB7fVxuXG4gICAgaWYobmV3Yyl7XG4gICAgICBsZXQgb2xkYyA9IHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU11cblxuICAgICAgZm9yKGxldCBjaWQgaW4gbmV3Yyl7XG4gICAgICAgIG5ld2NbY2lkXSA9IHRoaXMuY2FjaGVkRmluZENvbXBvbmVudChjaWQsIG5ld2NbY2lkXSwgb2xkYywgbmV3YywgY2FjaGUpXG4gICAgICB9XG5cbiAgICAgIGZvcihsZXQgY2lkIGluIG5ld2MpeyBvbGRjW2NpZF0gPSBuZXdjW2NpZF0gfVxuICAgICAgZGlmZltDT01QT05FTlRTXSA9IG5ld2NcbiAgICB9XG4gIH1cblxuICBjYWNoZWRGaW5kQ29tcG9uZW50KGNpZCwgY2RpZmYsIG9sZGMsIG5ld2MsIGNhY2hlKXtcbiAgICBpZihjYWNoZVtjaWRdKXtcbiAgICAgIHJldHVybiBjYWNoZVtjaWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZGlmZiwgc3RhdCwgc2NpZCA9IGNkaWZmW1NUQVRJQ11cblxuICAgICAgaWYoaXNDaWQoc2NpZCkpe1xuICAgICAgICBsZXQgdGRpZmZcblxuICAgICAgICBpZihzY2lkID4gMCl7XG4gICAgICAgICAgdGRpZmYgPSB0aGlzLmNhY2hlZEZpbmRDb21wb25lbnQoc2NpZCwgbmV3Y1tzY2lkXSwgb2xkYywgbmV3YywgY2FjaGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGRpZmYgPSBvbGRjWy1zY2lkXVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdCA9IHRkaWZmW1NUQVRJQ11cbiAgICAgICAgbmRpZmYgPSB0aGlzLmNsb25lTWVyZ2UodGRpZmYsIGNkaWZmKVxuICAgICAgICBuZGlmZltTVEFUSUNdID0gc3RhdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmRpZmYgPSBjZGlmZltTVEFUSUNdICE9PSB1bmRlZmluZWQgPyBjZGlmZiA6IHRoaXMuY2xvbmVNZXJnZShvbGRjW2NpZF0gfHwge30sIGNkaWZmKVxuICAgICAgfVxuXG4gICAgICBjYWNoZVtjaWRdID0gbmRpZmZcbiAgICAgIHJldHVybiBuZGlmZlxuICAgIH1cbiAgfVxuXG4gIG11dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSl7XG4gICAgaWYoc291cmNlW1NUQVRJQ10gIT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gc291cmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2UpXG4gICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfVxuICB9XG5cbiAgZG9NdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2Upe1xuICAgIGZvcihsZXQga2V5IGluIHNvdXJjZSl7XG4gICAgICBsZXQgdmFsID0gc291cmNlW2tleV1cbiAgICAgIGxldCB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XVxuICAgICAgaWYoaXNPYmplY3QodmFsKSAmJiB2YWxbU1RBVElDXSA9PT0gdW5kZWZpbmVkICYmIGlzT2JqZWN0KHRhcmdldFZhbCkpe1xuICAgICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldFZhbCwgdmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbG9uZU1lcmdlKHRhcmdldCwgc291cmNlKXtcbiAgICBsZXQgbWVyZ2VkID0gey4uLnRhcmdldCwgLi4uc291cmNlfVxuICAgIGZvcihsZXQga2V5IGluIG1lcmdlZCl7XG4gICAgICBsZXQgdmFsID0gc291cmNlW2tleV1cbiAgICAgIGxldCB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XVxuICAgICAgaWYoaXNPYmplY3QodmFsKSAmJiB2YWxbU1RBVElDXSA9PT0gdW5kZWZpbmVkICYmIGlzT2JqZWN0KHRhcmdldFZhbCkpe1xuICAgICAgICBtZXJnZWRba2V5XSA9IHRoaXMuY2xvbmVNZXJnZSh0YXJnZXRWYWwsIHZhbClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZFxuICB9XG5cbiAgY29tcG9uZW50VG9TdHJpbmcoY2lkKXsgcmV0dXJuIHRoaXMucmVjdXJzaXZlQ0lEVG9TdHJpbmcodGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSwgY2lkKSB9XG5cbiAgcHJ1bmVDSURzKGNpZHMpe1xuICAgIGNpZHMuZm9yRWFjaChjaWQgPT4gZGVsZXRlIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU11bY2lkXSlcbiAgfVxuXG4gIC8vIHByaXZhdGVcblxuICBnZXQoKXsgcmV0dXJuIHRoaXMucmVuZGVyZWQgfVxuXG4gIGlzTmV3RmluZ2VycHJpbnQoZGlmZiA9IHt9KXsgcmV0dXJuICEhZGlmZltTVEFUSUNdIH1cblxuICB0ZW1wbGF0ZVN0YXRpYyhwYXJ0LCB0ZW1wbGF0ZXMpe1xuICAgIGlmKHR5cGVvZiAocGFydCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZXNbcGFydF1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnRcbiAgICB9XG4gIH1cblxuICB0b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGlmKHJlbmRlcmVkW0RZTkFNSUNTXSl7IHJldHVybiB0aGlzLmNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpIH1cbiAgICBsZXQge1tTVEFUSUNdOiBzdGF0aWNzfSA9IHJlbmRlcmVkXG4gICAgc3RhdGljcyA9IHRoaXMudGVtcGxhdGVTdGF0aWMoc3RhdGljcywgdGVtcGxhdGVzKVxuXG4gICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzWzBdXG4gICAgZm9yKGxldCBpID0gMTsgaSA8IHN0YXRpY3MubGVuZ3RoOyBpKyspe1xuICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIocmVuZGVyZWRbaSAtIDFdLCB0ZW1wbGF0ZXMsIG91dHB1dClcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXVxuICAgIH1cbiAgfVxuXG4gIGNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGxldCB7W0RZTkFNSUNTXTogZHluYW1pY3MsIFtTVEFUSUNdOiBzdGF0aWNzfSA9IHJlbmRlcmVkXG4gICAgc3RhdGljcyA9IHRoaXMudGVtcGxhdGVTdGF0aWMoc3RhdGljcywgdGVtcGxhdGVzKVxuICAgIGxldCBjb21wVGVtcGxhdGVzID0gdGVtcGxhdGVzIHx8IHJlbmRlcmVkW1RFTVBMQVRFU11cblxuICAgIGZvcihsZXQgZCA9IDA7IGQgPCBkeW5hbWljcy5sZW5ndGg7IGQrKyl7XG4gICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNzW2RdXG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF1cbiAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIoZHluYW1pY1tpIC0gMV0sIGNvbXBUZW1wbGF0ZXMsIG91dHB1dClcbiAgICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCl7XG4gICAgaWYodHlwZW9mIChyZW5kZXJlZCkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgb3V0cHV0LmJ1ZmZlciArPSB0aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKG91dHB1dC5jb21wb25lbnRzLCByZW5kZXJlZCwgb3V0cHV0Lm9ubHlDaWRzKVxuICAgIH0gZWxzZSBpZihpc09iamVjdChyZW5kZXJlZCkpe1xuICAgICAgdGhpcy50b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gcmVuZGVyZWRcbiAgICB9XG4gIH1cblxuICByZWN1cnNpdmVDSURUb1N0cmluZyhjb21wb25lbnRzLCBjaWQsIG9ubHlDaWRzKXtcbiAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdIHx8IGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm9yIENJRCAke2NpZH1gLCBjb21wb25lbnRzKVxuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRoaXMucmVjdXJzaXZlVG9TdHJpbmcoY29tcG9uZW50LCBjb21wb25lbnRzLCBvbmx5Q2lkcylcbiAgICBsZXQgY29udGFpbmVyID0gdGVtcGxhdGUuY29udGVudFxuICAgIGxldCBza2lwID0gb25seUNpZHMgJiYgIW9ubHlDaWRzLmhhcyhjaWQpXG5cbiAgICBsZXQgW2hhc0NoaWxkTm9kZXMsIGhhc0NoaWxkQ29tcG9uZW50c10gPVxuICAgICAgQXJyYXkuZnJvbShjb250YWluZXIuY2hpbGROb2RlcykucmVkdWNlKChbaGFzTm9kZXMsIGhhc0NvbXBvbmVudHNdLCBjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZihjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpe1xuICAgICAgICAgIGlmKGNoaWxkLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSl7XG4gICAgICAgICAgICByZXR1cm4gW2hhc05vZGVzLCB0cnVlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCwgY2lkKVxuICAgICAgICAgIGlmKCFjaGlsZC5pZCl7IGNoaWxkLmlkID0gYCR7dGhpcy5wYXJlbnRWaWV3SWQoKX0tJHtjaWR9LSR7aX1gIH1cbiAgICAgICAgICBpZihza2lwKXtcbiAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShQSFhfU0tJUCwgXCJcIilcbiAgICAgICAgICAgIGNoaWxkLmlubmVySFRNTCA9IFwiXCJcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFt0cnVlLCBoYXNDb21wb25lbnRzXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKGNoaWxkLm5vZGVWYWx1ZS50cmltKCkgIT09IFwiXCIpe1xuICAgICAgICAgICAgbG9nRXJyb3IoXCJvbmx5IEhUTUwgZWxlbWVudCB0YWdzIGFyZSBhbGxvd2VkIGF0IHRoZSByb290IG9mIGNvbXBvbmVudHMuXFxuXFxuXCIgK1xuICAgICAgICAgICAgICBgZ290OiBcIiR7Y2hpbGQubm9kZVZhbHVlLnRyaW0oKX1cIlxcblxcbmAgK1xuICAgICAgICAgICAgICBcIndpdGhpbjpcXG5cIiwgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSlcbiAgICAgICAgICAgIGNoaWxkLnJlcGxhY2VXaXRoKHRoaXMuY3JlYXRlU3BhbihjaGlsZC5ub2RlVmFsdWUsIGNpZCkpXG4gICAgICAgICAgICByZXR1cm4gW3RydWUsIGhhc0NvbXBvbmVudHNdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpXG4gICAgICAgICAgICByZXR1cm4gW2hhc05vZGVzLCBoYXNDb21wb25lbnRzXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgW2ZhbHNlLCBmYWxzZV0pXG5cbiAgICBpZighaGFzQ2hpbGROb2RlcyAmJiAhaGFzQ2hpbGRDb21wb25lbnRzKXtcbiAgICAgIGxvZ0Vycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgdGhlIGNvbXBvbmVudCBpcyBlbXB0eTpcXG5cIixcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSlcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNwYW4oXCJcIiwgY2lkKS5vdXRlckhUTUxcbiAgICB9IGVsc2UgaWYoIWhhc0NoaWxkTm9kZXMgJiYgaGFzQ2hpbGRDb21wb25lbnRzKXtcbiAgICAgIGxvZ0Vycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgZGlyZWN0bHkgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgb25seSBzdWJjb21wb25lbnRzIHdlcmUgZm91bmQuIEEgY29tcG9uZW50IG11c3QgcmVuZGVyIGF0IGxlYXN0IG9uZSBIVE1MIHRhZyBkaXJlY3RseSBpbnNpZGUgaXRzZWxmLlwiLFxuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwudHJpbSgpKVxuICAgICAgcmV0dXJuIHRlbXBsYXRlLmlubmVySFRNTFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGUuaW5uZXJIVE1MXG4gICAgfVxuICB9XG5cbiAgY3JlYXRlU3Bhbih0ZXh0LCBjaWQpe1xuICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIilcbiAgICBzcGFuLmlubmVyVGV4dCA9IHRleHRcbiAgICBzcGFuLnNldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5ULCBjaWQpXG4gICAgcmV0dXJuIHNwYW5cbiAgfVxufVxuIiwgImxldCB2aWV3SG9va0lEID0gMVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld0hvb2sge1xuICBzdGF0aWMgbWFrZUlEKCl7IHJldHVybiB2aWV3SG9va0lEKysgfVxuICBzdGF0aWMgZWxlbWVudElEKGVsKXsgcmV0dXJuIGVsLnBoeEhvb2tJZCB9XG5cbiAgY29uc3RydWN0b3IodmlldywgZWwsIGNhbGxiYWNrcyl7XG4gICAgdGhpcy5fX3ZpZXcgPSB2aWV3XG4gICAgdGhpcy5saXZlU29ja2V0ID0gdmlldy5saXZlU29ja2V0XG4gICAgdGhpcy5fX2NhbGxiYWNrcyA9IGNhbGxiYWNrc1xuICAgIHRoaXMuX19saXN0ZW5lcnMgPSBuZXcgU2V0KClcbiAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMuZWwgPSBlbFxuICAgIHRoaXMuZWwucGh4SG9va0lkID0gdGhpcy5jb25zdHJ1Y3Rvci5tYWtlSUQoKVxuICAgIGZvcihsZXQga2V5IGluIHRoaXMuX19jYWxsYmFja3MpeyB0aGlzW2tleV0gPSB0aGlzLl9fY2FsbGJhY2tzW2tleV0gfVxuICB9XG5cbiAgX19tb3VudGVkKCl7IHRoaXMubW91bnRlZCAmJiB0aGlzLm1vdW50ZWQoKSB9XG4gIF9fdXBkYXRlZCgpeyB0aGlzLnVwZGF0ZWQgJiYgdGhpcy51cGRhdGVkKCkgfVxuICBfX2JlZm9yZVVwZGF0ZSgpeyB0aGlzLmJlZm9yZVVwZGF0ZSAmJiB0aGlzLmJlZm9yZVVwZGF0ZSgpIH1cbiAgX19kZXN0cm95ZWQoKXsgdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5kZXN0cm95ZWQoKSB9XG4gIF9fcmVjb25uZWN0ZWQoKXtcbiAgICBpZih0aGlzLl9faXNEaXNjb25uZWN0ZWQpe1xuICAgICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgIHRoaXMucmVjb25uZWN0ZWQgJiYgdGhpcy5yZWNvbm5lY3RlZCgpXG4gICAgfVxuICB9XG4gIF9fZGlzY29ubmVjdGVkKCl7XG4gICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gdHJ1ZVxuICAgIHRoaXMuZGlzY29ubmVjdGVkICYmIHRoaXMuZGlzY29ubmVjdGVkKClcbiAgfVxuXG4gIHB1c2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy5wdXNoSG9va0V2ZW50KG51bGwsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KVxuICB9XG5cbiAgcHVzaEV2ZW50VG8ocGh4VGFyZ2V0LCBldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgcmV0dXJuIHZpZXcucHVzaEhvb2tFdmVudCh0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVFdmVudChldmVudCwgY2FsbGJhY2spe1xuICAgIGxldCBjYWxsYmFja1JlZiA9IChjdXN0b21FdmVudCwgYnlwYXNzKSA9PiBieXBhc3MgPyBldmVudCA6IGNhbGxiYWNrKGN1c3RvbUV2ZW50LmRldGFpbClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpXG4gICAgdGhpcy5fX2xpc3RlbmVycy5hZGQoY2FsbGJhY2tSZWYpXG4gICAgcmV0dXJuIGNhbGxiYWNrUmVmXG4gIH1cblxuICByZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZil7XG4gICAgbGV0IGV2ZW50ID0gY2FsbGJhY2tSZWYobnVsbCwgdHJ1ZSlcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpXG4gICAgdGhpcy5fX2xpc3RlbmVycy5kZWxldGUoY2FsbGJhY2tSZWYpXG4gIH1cblxuICB1cGxvYWQobmFtZSwgZmlsZXMpe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy5kaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXMpXG4gIH1cblxuICB1cGxvYWRUbyhwaHhUYXJnZXQsIG5hbWUsIGZpbGVzKXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIHZpZXcgPT4gdmlldy5kaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXMpKVxuICB9XG5cbiAgX19jbGVhbnVwX18oKXtcbiAgICB0aGlzLl9fbGlzdGVuZXJzLmZvckVhY2goY2FsbGJhY2tSZWYgPT4gdGhpcy5yZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikpXG4gIH1cbn1cbiIsICJpbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5cbmxldCBKUyA9IHtcbiAgZXhlYyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZGVmYXVsdHMpe1xuICAgIGxldCBbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXSA9IGRlZmF1bHRzIHx8IFtudWxsLCB7fV1cbiAgICBsZXQgY29tbWFuZHMgPSBwaHhFdmVudC5jaGFyQXQoMCkgPT09IFwiW1wiID9cbiAgICAgIEpTT04ucGFyc2UocGh4RXZlbnQpIDogW1tkZWZhdWx0S2luZCwgZGVmYXVsdEFyZ3NdXVxuXG4gICAgY29tbWFuZHMuZm9yRWFjaCgoW2tpbmQsIGFyZ3NdKSA9PiB7XG4gICAgICBpZihraW5kID09PSBkZWZhdWx0S2luZCAmJiBkZWZhdWx0QXJncy5kYXRhKXtcbiAgICAgICAgYXJncy5kYXRhID0gT2JqZWN0LmFzc2lnbihhcmdzLmRhdGEgfHwge30sIGRlZmF1bHRBcmdzLmRhdGEpXG4gICAgICB9XG4gICAgICB0aGlzLmZpbHRlclRvRWxzKHNvdXJjZUVsLCBhcmdzKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgdGhpc1tgZXhlY18ke2tpbmR9YF0oZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCBhcmdzKVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIGlzVmlzaWJsZShlbCl7XG4gICAgcmV0dXJuICEhKGVsLm9mZnNldFdpZHRoIHx8IGVsLm9mZnNldEhlaWdodCB8fCBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDApXG4gIH0sXG5cbiAgLy8gcHJpdmF0ZVxuXG4gIC8vIGNvbW1hbmRzXG5cbiAgZXhlY19kaXNwYXRjaChldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHt0bywgZXZlbnQsIGRldGFpbCwgYnViYmxlc30pe1xuICAgIGRldGFpbCA9IGRldGFpbCB8fCB7fVxuICAgIGRldGFpbC5kaXNwYXRjaGVyID0gc291cmNlRWxcbiAgICBET00uZGlzcGF0Y2hFdmVudChlbCwgZXZlbnQsIHtkZXRhaWwsIGJ1YmJsZXN9KVxuICB9LFxuXG4gIGV4ZWNfcHVzaChldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIGFyZ3Mpe1xuICAgIGlmKCF2aWV3LmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuXG4gICAgbGV0IHtldmVudCwgZGF0YSwgdGFyZ2V0LCBwYWdlX2xvYWRpbmcsIGxvYWRpbmcsIHZhbHVlLCBkaXNwYXRjaGVyfSA9IGFyZ3NcbiAgICBsZXQgcHVzaE9wdHMgPSB7bG9hZGluZywgdmFsdWUsIHRhcmdldCwgcGFnZV9sb2FkaW5nOiAhIXBhZ2VfbG9hZGluZ31cbiAgICBsZXQgdGFyZ2V0U3JjID0gZXZlbnRUeXBlID09PSBcImNoYW5nZVwiICYmIGRpc3BhdGNoZXIgPyBkaXNwYXRjaGVyIDogc291cmNlRWxcbiAgICBsZXQgcGh4VGFyZ2V0ID0gdGFyZ2V0IHx8IHRhcmdldFNyYy5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFwidGFyZ2V0XCIpKSB8fCB0YXJnZXRTcmNcbiAgICB2aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodGFyZ2V0VmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICBpZihldmVudFR5cGUgPT09IFwiY2hhbmdlXCIpe1xuICAgICAgICBsZXQge25ld0NpZCwgX3RhcmdldCwgY2FsbGJhY2t9ID0gYXJnc1xuICAgICAgICBfdGFyZ2V0ID0gX3RhcmdldCB8fCAoc291cmNlRWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ID8gc291cmNlRWwubmFtZSA6IHVuZGVmaW5lZClcbiAgICAgICAgaWYoX3RhcmdldCl7IHB1c2hPcHRzLl90YXJnZXQgPSBfdGFyZ2V0IH1cbiAgICAgICAgdGFyZ2V0Vmlldy5wdXNoSW5wdXQoc291cmNlRWwsIHRhcmdldEN0eCwgbmV3Q2lkLCBldmVudCB8fCBwaHhFdmVudCwgcHVzaE9wdHMsIGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIGlmKGV2ZW50VHlwZSA9PT0gXCJzdWJtaXRcIil7XG4gICAgICAgIHRhcmdldFZpZXcuc3VibWl0Rm9ybShzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgcHVzaE9wdHMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRWaWV3LnB1c2hFdmVudChldmVudFR5cGUsIHNvdXJjZUVsLCB0YXJnZXRDdHgsIGV2ZW50IHx8IHBoeEV2ZW50LCBkYXRhLCBwdXNoT3B0cylcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuXG4gIGV4ZWNfYWRkX2NsYXNzKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge25hbWVzLCB0cmFuc2l0aW9uLCB0aW1lfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG5hbWVzLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldylcbiAgfSxcblxuICBleGVjX3JlbW92ZV9jbGFzcyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtuYW1lcywgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgbmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcpXG4gIH0sXG5cbiAgZXhlY190cmFuc2l0aW9uKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge3RpbWUsIHRyYW5zaXRpb259KXtcbiAgICBsZXQgW3RyYW5zaXRpb25fc3RhcnQsIHJ1bm5pbmcsIHRyYW5zaXRpb25fZW5kXSA9IHRyYW5zaXRpb25cbiAgICBsZXQgb25TdGFydCA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uX3N0YXJ0LmNvbmNhdChydW5uaW5nKSwgW10pXG4gICAgbGV0IG9uRG9uZSA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uX2VuZCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQocnVubmluZykpXG4gICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfSxcblxuICBleGVjX3RvZ2dsZShldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWV9KXtcbiAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWUpXG4gIH0sXG5cbiAgZXhlY19zaG93KGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2Rpc3BsYXksIHRyYW5zaXRpb24sIHRpbWV9KXtcbiAgICB0aGlzLnNob3coZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSlcbiAgfSxcblxuICBleGVjX2hpZGUoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7ZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKVxuICB9LFxuXG4gIGV4ZWNfc2V0X2F0dHIoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7YXR0cjogW2F0dHIsIHZhbF19KXtcbiAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtbYXR0ciwgdmFsXV0sIFtdKVxuICB9LFxuXG4gIGV4ZWNfcmVtb3ZlX2F0dHIoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7YXR0cn0pe1xuICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW10sIFthdHRyXSlcbiAgfSxcblxuICAvLyB1dGlscyBmb3IgY29tbWFuZHNcblxuICBzaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpe1xuICAgIGlmKCF0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgdGhpcy50b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgbnVsbCwgdGltZSlcbiAgICB9XG4gIH0sXG5cbiAgaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKXtcbiAgICBpZih0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgdGhpcy50b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgbnVsbCwgdHJhbnNpdGlvbiwgdGltZSlcbiAgICB9XG4gIH0sXG5cbiAgdG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIGlucywgb3V0cywgdGltZSl7XG4gICAgbGV0IFtpbkNsYXNzZXMsIGluU3RhcnRDbGFzc2VzLCBpbkVuZENsYXNzZXNdID0gaW5zIHx8IFtbXSwgW10sIFtdXVxuICAgIGxldCBbb3V0Q2xhc3Nlcywgb3V0U3RhcnRDbGFzc2VzLCBvdXRFbmRDbGFzc2VzXSA9IG91dHMgfHwgW1tdLCBbXSwgW11dXG4gICAgaWYoaW5DbGFzc2VzLmxlbmd0aCA+IDAgfHwgb3V0Q2xhc3Nlcy5sZW5ndGggPiAwKXtcbiAgICAgIGlmKHRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRTdGFydENsYXNzZXMsIGluQ2xhc3Nlcy5jb25jYXQoaW5TdGFydENsYXNzZXMpLmNvbmNhdChpbkVuZENsYXNzZXMpKVxuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dENsYXNzZXMsIFtdKVxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgb3V0RW5kQ2xhc3Nlcywgb3V0U3RhcnRDbGFzc2VzKSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtc3RhcnRcIikpXG4gICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBvdXRDbGFzc2VzLmNvbmNhdChvdXRFbmRDbGFzc2VzKSlcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIilcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKGV2ZW50VHlwZSA9PT0gXCJyZW1vdmVcIil7IHJldHVybiB9XG4gICAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpblN0YXJ0Q2xhc3Nlcywgb3V0Q2xhc3Nlcy5jb25jYXQob3V0U3RhcnRDbGFzc2VzKS5jb25jYXQob3V0RW5kQ2xhc3NlcykpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gKGRpc3BsYXkgfHwgXCJibG9ja1wiKSlcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpbkNsYXNzZXMsIFtdKVxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5FbmRDbGFzc2VzLCBpblN0YXJ0Q2xhc3NlcykpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LXN0YXJ0XCIpKVxuICAgICAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgaW5DbGFzc2VzLmNvbmNhdChpbkVuZENsYXNzZXMpKVxuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctZW5kXCIpKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZih0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLXN0YXJ0XCIpKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKVxuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtZW5kXCIpKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1zdGFydFwiKSlcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5IHx8IFwiYmxvY2tcIilcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBhZGRzLCByZW1vdmVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KXtcbiAgICBsZXQgW3RyYW5zaXRpb25fcnVuLCB0cmFuc2l0aW9uX3N0YXJ0LCB0cmFuc2l0aW9uX2VuZF0gPSB0cmFuc2l0aW9uIHx8IFtbXSwgW10sIFtdXVxuICAgIGlmKHRyYW5zaXRpb25fcnVuLmxlbmd0aCA+IDApe1xuICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQodHJhbnNpdGlvbl9ydW4pLCBbXSlcbiAgICAgIGxldCBvbkRvbmUgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgYWRkcy5jb25jYXQodHJhbnNpdGlvbl9lbmQpLCByZW1vdmVzLmNvbmNhdCh0cmFuc2l0aW9uX3J1bikuY29uY2F0KHRyYW5zaXRpb25fc3RhcnQpKVxuICAgICAgcmV0dXJuIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gICAgfVxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgbGV0IFtwcmV2QWRkcywgcHJldlJlbW92ZXNdID0gRE9NLmdldFN0aWNreShlbCwgXCJjbGFzc2VzXCIsIFtbXSwgW11dKVxuICAgICAgbGV0IGtlZXBBZGRzID0gYWRkcy5maWx0ZXIobmFtZSA9PiBwcmV2QWRkcy5pbmRleE9mKG5hbWUpIDwgMCAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgbGV0IGtlZXBSZW1vdmVzID0gcmVtb3Zlcy5maWx0ZXIobmFtZSA9PiBwcmV2UmVtb3Zlcy5pbmRleE9mKG5hbWUpIDwgMCAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpXG4gICAgICBsZXQgbmV3QWRkcyA9IHByZXZBZGRzLmZpbHRlcihuYW1lID0+IHJlbW92ZXMuaW5kZXhPZihuYW1lKSA8IDApLmNvbmNhdChrZWVwQWRkcylcbiAgICAgIGxldCBuZXdSZW1vdmVzID0gcHJldlJlbW92ZXMuZmlsdGVyKG5hbWUgPT4gYWRkcy5pbmRleE9mKG5hbWUpIDwgMCkuY29uY2F0KGtlZXBSZW1vdmVzKVxuXG4gICAgICBET00ucHV0U3RpY2t5KGVsLCBcImNsYXNzZXNcIiwgY3VycmVudEVsID0+IHtcbiAgICAgICAgY3VycmVudEVsLmNsYXNzTGlzdC5yZW1vdmUoLi4ubmV3UmVtb3ZlcylcbiAgICAgICAgY3VycmVudEVsLmNsYXNzTGlzdC5hZGQoLi4ubmV3QWRkcylcbiAgICAgICAgcmV0dXJuIFtuZXdBZGRzLCBuZXdSZW1vdmVzXVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIHNldE9yUmVtb3ZlQXR0cnMoZWwsIHNldHMsIHJlbW92ZXMpe1xuICAgIGxldCBbcHJldlNldHMsIHByZXZSZW1vdmVzXSA9IERPTS5nZXRTdGlja3koZWwsIFwiYXR0cnNcIiwgW1tdLCBbXV0pXG5cbiAgICBsZXQgYWx0ZXJlZEF0dHJzID0gc2V0cy5tYXAoKFthdHRyLCBfdmFsXSkgPT4gYXR0cikuY29uY2F0KHJlbW92ZXMpO1xuICAgIGxldCBuZXdTZXRzID0gcHJldlNldHMuZmlsdGVyKChbYXR0ciwgX3ZhbF0pID0+ICFhbHRlcmVkQXR0cnMuaW5jbHVkZXMoYXR0cikpLmNvbmNhdChzZXRzKTtcbiAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcigoYXR0cikgPT4gIWFsdGVyZWRBdHRycy5pbmNsdWRlcyhhdHRyKSkuY29uY2F0KHJlbW92ZXMpO1xuXG4gICAgRE9NLnB1dFN0aWNreShlbCwgXCJhdHRyc1wiLCBjdXJyZW50RWwgPT4ge1xuICAgICAgbmV3UmVtb3Zlcy5mb3JFYWNoKGF0dHIgPT4gY3VycmVudEVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKSlcbiAgICAgIG5ld1NldHMuZm9yRWFjaCgoW2F0dHIsIHZhbF0pID0+IGN1cnJlbnRFbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsKSlcbiAgICAgIHJldHVybiBbbmV3U2V0cywgbmV3UmVtb3Zlc11cbiAgICB9KVxuICB9LFxuXG4gIGhhc0FsbENsYXNzZXMoZWwsIGNsYXNzZXMpeyByZXR1cm4gY2xhc3Nlcy5ldmVyeShuYW1lID0+IGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSkgfSxcblxuICBpc1RvZ2dsZWRPdXQoZWwsIG91dENsYXNzZXMpe1xuICAgIHJldHVybiAhdGhpcy5pc1Zpc2libGUoZWwpIHx8IHRoaXMuaGFzQWxsQ2xhc3NlcyhlbCwgb3V0Q2xhc3NlcylcbiAgfSxcblxuICBmaWx0ZXJUb0Vscyhzb3VyY2VFbCwge3RvfSl7XG4gICAgcmV0dXJuIHRvID8gRE9NLmFsbChkb2N1bWVudCwgdG8pIDogW3NvdXJjZUVsXVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEpTXG4iLCAiaW1wb3J0IHtcbiAgQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCxcbiAgQ0hFQ0tBQkxFX0lOUFVUUyxcbiAgQ09OU0VDVVRJVkVfUkVMT0FEUyxcbiAgUEhYX0FVVE9fUkVDT1ZFUixcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX0NPTk5FQ1RFRF9DTEFTUyxcbiAgUEhYX0RJU0FCTEVfV0lUSCxcbiAgUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLFxuICBQSFhfRElTQUJMRUQsXG4gIFBIWF9ESVNDT05ORUNURURfQ0xBU1MsXG4gIFBIWF9FVkVOVF9DTEFTU0VTLFxuICBQSFhfRVJST1JfQ0xBU1MsXG4gIFBIWF9GRUVEQkFDS19GT1IsXG4gIFBIWF9IQVNfU1VCTUlUVEVELFxuICBQSFhfSE9PSyxcbiAgUEhYX1BBR0VfTE9BRElORyxcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1BST0dSRVNTLFxuICBQSFhfUkVBRE9OTFksXG4gIFBIWF9SRUYsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9UUkFDS19TVEFUSUMsXG4gIFBIWF9UUkFDS19VUExPQURTLFxuICBQSFhfVVBEQVRFLFxuICBQSFhfVVBMT0FEX1JFRixcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBVU0hfVElNRU9VVCxcbiAgUEhYX01BSU4sXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNsb25lLFxuICBjbG9zZXN0UGh4QmluZGluZyxcbiAgaXNFbXB0eSxcbiAgaXNFcXVhbE9iaixcbiAgbG9nRXJyb3IsXG4gIG1heWJlLFxuICBpc0NpZCxcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQnJvd3NlciBmcm9tIFwiLi9icm93c2VyXCJcbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBET01QYXRjaCBmcm9tIFwiLi9kb21fcGF0Y2hcIlxuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCJcbmltcG9ydCBSZW5kZXJlZCBmcm9tIFwiLi9yZW5kZXJlZFwiXG5pbXBvcnQgVmlld0hvb2sgZnJvbSBcIi4vdmlld19ob29rXCJcbmltcG9ydCBKUyBmcm9tIFwiLi9qc1wiXG5cbmxldCBzZXJpYWxpemVGb3JtID0gKGZvcm0sIG1ldGEsIG9ubHlOYW1lcyA9IFtdKSA9PiB7XG4gIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKVxuICBsZXQgdG9SZW1vdmUgPSBbXVxuXG4gIGZvcm1EYXRhLmZvckVhY2goKHZhbCwga2V5LCBfaW5kZXgpID0+IHtcbiAgICBpZih2YWwgaW5zdGFuY2VvZiBGaWxlKXsgdG9SZW1vdmUucHVzaChrZXkpIH1cbiAgfSlcblxuICAvLyBDbGVhbnVwIGFmdGVyIGJ1aWxkaW5nIGZpbGVEYXRhXG4gIHRvUmVtb3ZlLmZvckVhY2goa2V5ID0+IGZvcm1EYXRhLmRlbGV0ZShrZXkpKVxuXG4gIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgZm9yKGxldCBba2V5LCB2YWxdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSl7XG4gICAgaWYob25seU5hbWVzLmxlbmd0aCA9PT0gMCB8fCBvbmx5TmFtZXMuaW5kZXhPZihrZXkpID49IDApe1xuICAgICAgcGFyYW1zLmFwcGVuZChrZXksIHZhbClcbiAgICB9XG4gIH1cbiAgZm9yKGxldCBtZXRhS2V5IGluIG1ldGEpeyBwYXJhbXMuYXBwZW5kKG1ldGFLZXksIG1ldGFbbWV0YUtleV0pIH1cblxuICByZXR1cm4gcGFyYW1zLnRvU3RyaW5nKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlldyB7XG4gIGNvbnN0cnVjdG9yKGVsLCBsaXZlU29ja2V0LCBwYXJlbnRWaWV3LCBmbGFzaCl7XG4gICAgdGhpcy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuICAgIHRoaXMuZmxhc2ggPSBmbGFzaFxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50Vmlld1xuICAgIHRoaXMucm9vdCA9IHBhcmVudFZpZXcgPyBwYXJlbnRWaWV3LnJvb3QgOiB0aGlzXG4gICAgdGhpcy5lbCA9IGVsXG4gICAgdGhpcy5pZCA9IHRoaXMuZWwuaWRcbiAgICB0aGlzLnJlZiA9IDBcbiAgICB0aGlzLmNoaWxkSm9pbnMgPSAwXG4gICAgdGhpcy5sb2FkZXJUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgdGhpcy5wcnVuaW5nQ0lEcyA9IFtdXG4gICAgdGhpcy5yZWRpcmVjdCA9IGZhbHNlXG4gICAgdGhpcy5ocmVmID0gbnVsbFxuICAgIHRoaXMuam9pbkNvdW50ID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5qb2luQ291bnQgLSAxIDogMFxuICAgIHRoaXMuam9pblBlbmRpbmcgPSB0cnVlXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIHRoaXMuam9pbkNhbGxiYWNrID0gZnVuY3Rpb24ob25Eb25lKXsgb25Eb25lICYmIG9uRG9uZSgpIH1cbiAgICB0aGlzLnN0b3BDYWxsYmFjayA9IGZ1bmN0aW9uKCl7IH1cbiAgICB0aGlzLnBlbmRpbmdKb2luT3BzID0gdGhpcy5wYXJlbnQgPyBudWxsIDogW11cbiAgICB0aGlzLnZpZXdIb29rcyA9IHt9XG4gICAgdGhpcy51cGxvYWRlcnMgPSB7fVxuICAgIHRoaXMuZm9ybVN1Ym1pdHMgPSBbXVxuICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLnBhcmVudCA/IG51bGwgOiB7fVxuICAgIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSA9IHt9XG4gICAgdGhpcy5jaGFubmVsID0gdGhpcy5saXZlU29ja2V0LmNoYW5uZWwoYGx2OiR7dGhpcy5pZH1gLCAoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWRpcmVjdDogdGhpcy5yZWRpcmVjdCA/IHRoaXMuaHJlZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgdXJsOiB0aGlzLnJlZGlyZWN0ID8gdW5kZWZpbmVkIDogdGhpcy5ocmVmIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyYW1zOiB0aGlzLmNvbm5lY3RQYXJhbXMoKSxcbiAgICAgICAgc2Vzc2lvbjogdGhpcy5nZXRTZXNzaW9uKCksXG4gICAgICAgIHN0YXRpYzogdGhpcy5nZXRTdGF0aWMoKSxcbiAgICAgICAgZmxhc2g6IHRoaXMuZmxhc2hcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuc2hvd0xvYWRlcih0aGlzLmxpdmVTb2NrZXQubG9hZGVyVGltZW91dClcbiAgICB0aGlzLmJpbmRDaGFubmVsKClcbiAgfVxuXG4gIHNldEhyZWYoaHJlZil7IHRoaXMuaHJlZiA9IGhyZWYgfVxuXG4gIHNldFJlZGlyZWN0KGhyZWYpe1xuICAgIHRoaXMucmVkaXJlY3QgPSB0cnVlXG4gICAgdGhpcy5ocmVmID0gaHJlZlxuICB9XG5cbiAgaXNNYWluKCl7IHJldHVybiB0aGlzLmVsLmhhc0F0dHJpYnV0ZShQSFhfTUFJTikgfVxuXG4gIGNvbm5lY3RQYXJhbXMoKXtcbiAgICBsZXQgcGFyYW1zID0gdGhpcy5saXZlU29ja2V0LnBhcmFtcyh0aGlzLmVsKVxuICAgIGxldCBtYW5pZmVzdCA9XG4gICAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9UUkFDS19TVEFUSUMpfV1gKVxuICAgICAgICAubWFwKG5vZGUgPT4gbm9kZS5zcmMgfHwgbm9kZS5ocmVmKS5maWx0ZXIodXJsID0+IHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIilcblxuICAgIGlmKG1hbmlmZXN0Lmxlbmd0aCA+IDApeyBwYXJhbXNbXCJfdHJhY2tfc3RhdGljXCJdID0gbWFuaWZlc3QgfVxuICAgIHBhcmFtc1tcIl9tb3VudHNcIl0gPSB0aGlzLmpvaW5Db3VudFxuXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuY2hhbm5lbC5jYW5QdXNoKCkgfVxuXG4gIGdldFNlc3Npb24oKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSB9XG5cbiAgZ2V0U3RhdGljKCl7XG4gICAgbGV0IHZhbCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9TVEFUSUMpXG4gICAgcmV0dXJuIHZhbCA9PT0gXCJcIiA/IG51bGwgOiB2YWxcbiAgfVxuXG4gIGRlc3Ryb3koY2FsbGJhY2sgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgIGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1cbiAgICBpZih0aGlzLnBhcmVudCl7IGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5wYXJlbnQuaWRdW3RoaXMuaWRdIH1cbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICBsZXQgb25GaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3Mpe1xuICAgICAgICB0aGlzLmRlc3Ryb3lIb29rKHRoaXMudmlld0hvb2tzW2lkXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBET00ubWFya1BoeENoaWxkRGVzdHJveWVkKHRoaXMuZWwpXG5cbiAgICB0aGlzLmxvZyhcImRlc3Ryb3llZFwiLCAoKSA9PiBbXCJ0aGUgY2hpbGQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnRcIl0pXG4gICAgdGhpcy5jaGFubmVsLmxlYXZlKClcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgb25GaW5pc2hlZClcbiAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgb25GaW5pc2hlZClcbiAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCBvbkZpbmlzaGVkKVxuICB9XG5cbiAgc2V0Q29udGFpbmVyQ2xhc3NlcyguLi5jbGFzc2VzKXtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICBQSFhfQ09OTkVDVEVEX0NMQVNTLFxuICAgICAgUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUyxcbiAgICAgIFBIWF9FUlJPUl9DTEFTU1xuICAgIClcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3NlcylcbiAgfVxuXG4gIHNob3dMb2FkZXIodGltZW91dCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpXG4gICAgaWYodGltZW91dCl7XG4gICAgICB0aGlzLmxvYWRlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNob3dMb2FkZXIoKSwgdGltZW91dClcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcyl7IHRoaXMudmlld0hvb2tzW2lkXS5fX2Rpc2Nvbm5lY3RlZCgpIH1cbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfRElTQ09OTkVDVEVEX0NMQVNTKVxuICAgIH1cbiAgfVxuXG4gIGhpZGVMb2FkZXIoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0NPTk5FQ1RFRF9DTEFTUylcbiAgfVxuXG4gIHRyaWdnZXJSZWNvbm5lY3RlZCgpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpeyB0aGlzLnZpZXdIb29rc1tpZF0uX19yZWNvbm5lY3RlZCgpIH1cbiAgfVxuXG4gIGxvZyhraW5kLCBtc2dDYWxsYmFjayl7XG4gICAgdGhpcy5saXZlU29ja2V0LmxvZyh0aGlzLCBraW5kLCBtc2dDYWxsYmFjaylcbiAgfVxuXG4gIHRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lID0gZnVuY3Rpb24oKXt9KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gIH1cblxuICB3aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgY2FsbGJhY2spe1xuICAgIGlmKHBoeFRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHBoeFRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpe1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5vd25lcihwaHhUYXJnZXQsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgcGh4VGFyZ2V0KSlcbiAgICB9XG5cbiAgICBpZihpc0NpZChwaHhUYXJnZXQpKXtcbiAgICAgIGxldCB0YXJnZXRzID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBwaHhUYXJnZXQpXG4gICAgICBpZih0YXJnZXRzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm91bmQgbWF0Y2hpbmcgcGh4LXRhcmdldCBvZiAke3BoeFRhcmdldH1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcywgcGFyc2VJbnQocGh4VGFyZ2V0KSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRhcmdldHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocGh4VGFyZ2V0KSlcbiAgICAgIGlmKHRhcmdldHMubGVuZ3RoID09PSAwKXsgbG9nRXJyb3IoYG5vdGhpbmcgZm91bmQgbWF0Y2hpbmcgdGhlIHBoeC10YXJnZXQgc2VsZWN0b3IgXCIke3BoeFRhcmdldH1cImApIH1cbiAgICAgIHRhcmdldHMuZm9yRWFjaCh0YXJnZXQgPT4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHRhcmdldCwgdmlldyA9PiBjYWxsYmFjayh2aWV3LCB0YXJnZXQpKSlcbiAgICB9XG4gIH1cblxuICBhcHBseURpZmYodHlwZSwgcmF3RGlmZiwgY2FsbGJhY2spe1xuICAgIHRoaXMubG9nKHR5cGUsICgpID0+IFtcIlwiLCBjbG9uZShyYXdEaWZmKV0pXG4gICAgbGV0IHtkaWZmLCByZXBseSwgZXZlbnRzLCB0aXRsZX0gPSBSZW5kZXJlZC5leHRyYWN0KHJhd0RpZmYpXG4gICAgaWYodGl0bGUpeyBET00ucHV0VGl0bGUodGl0bGUpIH1cblxuICAgIGNhbGxiYWNrKHtkaWZmLCByZXBseSwgZXZlbnRzfSlcbiAgICByZXR1cm4gcmVwbHlcbiAgfVxuXG4gIG9uSm9pbihyZXNwKXtcbiAgICBsZXQge3JlbmRlcmVkLCBjb250YWluZXJ9ID0gcmVzcFxuICAgIGlmKGNvbnRhaW5lcil7XG4gICAgICBsZXQgW3RhZywgYXR0cnNdID0gY29udGFpbmVyXG4gICAgICB0aGlzLmVsID0gRE9NLnJlcGxhY2VSb290Q29udGFpbmVyKHRoaXMuZWwsIHRhZywgYXR0cnMpXG4gICAgfVxuICAgIHRoaXMuY2hpbGRKb2lucyA9IDBcbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXMuZmxhc2ggPSBudWxsXG5cbiAgICBCcm93c2VyLmRyb3BMb2NhbCh0aGlzLmxpdmVTb2NrZXQubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMpXG4gICAgdGhpcy5hcHBseURpZmYoXCJtb3VudFwiLCByZW5kZXJlZCwgKHtkaWZmLCBldmVudHN9KSA9PiB7XG4gICAgICB0aGlzLnJlbmRlcmVkID0gbmV3IFJlbmRlcmVkKHRoaXMuaWQsIGRpZmYpXG4gICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyQ29udGFpbmVyKG51bGwsIFwiam9pblwiKVxuICAgICAgdGhpcy5kcm9wUGVuZGluZ1JlZnMoKVxuICAgICAgbGV0IGZvcm1zID0gdGhpcy5mb3Jtc0ZvclJlY292ZXJ5KGh0bWwpXG4gICAgICB0aGlzLmpvaW5Db3VudCsrXG5cbiAgICAgIGlmKGZvcm1zLmxlbmd0aCA+IDApe1xuICAgICAgICBmb3Jtcy5mb3JFYWNoKChbZm9ybSwgbmV3Rm9ybSwgbmV3Q2lkXSwgaSkgPT4ge1xuICAgICAgICAgIHRoaXMucHVzaEZvcm1SZWNvdmVyeShmb3JtLCBuZXdDaWQsIHJlc3AgPT4ge1xuICAgICAgICAgICAgaWYoaSA9PT0gZm9ybXMubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcCwgaHRtbCwgZXZlbnRzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uSm9pbkNvbXBsZXRlKHJlc3AsIGh0bWwsIGV2ZW50cylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZHJvcFBlbmRpbmdSZWZzKCl7XG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske1BIWF9SRUZfU1JDfT1cIiR7dGhpcy5pZH1cIl1bJHtQSFhfUkVGfV1gLCBlbCA9PiB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRilcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX1NSQylcbiAgICB9KVxuICB9XG5cbiAgb25Kb2luQ29tcGxldGUoe2xpdmVfcGF0Y2h9LCBodG1sLCBldmVudHMpe1xuICAgIC8vIEluIG9yZGVyIHRvIHByb3ZpZGUgYSBiZXR0ZXIgZXhwZXJpZW5jZSwgd2Ugd2FudCB0byBqb2luXG4gICAgLy8gYWxsIExpdmVWaWV3cyBmaXJzdCBhbmQgb25seSB0aGVuIGFwcGx5IHRoZWlyIHBhdGNoZXMuXG4gICAgaWYodGhpcy5qb2luQ291bnQgPiAxIHx8ICh0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQuaXNKb2luUGVuZGluZygpKSl7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXG4gICAgfVxuXG4gICAgLy8gT25lIGRvd25zaWRlIG9mIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB3ZSBuZWVkIHRvIGZpbmQgcGh4Q2hpbGRyZW5cbiAgICAvLyBpbiB0aGUgaHRtbCBmcmFnbWVudCwgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgRE9NLiBUaGUgZnJhZ21lbnRcbiAgICAvLyBhbHNvIGRvZXMgbm90IGluY2x1ZGUgUEhYX1NUQVRJQywgc28gd2UgbmVlZCB0byBjb3B5IGl0IG92ZXIgZnJvbVxuICAgIC8vIHRoZSBET00uXG4gICAgbGV0IG5ld0NoaWxkcmVuID0gRE9NLmZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQoaHRtbCwgdGhpcy5pZCkuZmlsdGVyKHRvRWwgPT4ge1xuICAgICAgbGV0IGZyb21FbCA9IHRvRWwuaWQgJiYgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKGBbaWQ9XCIke3RvRWwuaWR9XCJdYClcbiAgICAgIGxldCBwaHhTdGF0aWMgPSBmcm9tRWwgJiYgZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKVxuICAgICAgaWYocGh4U3RhdGljKXsgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQywgcGh4U3RhdGljKSB9XG4gICAgICByZXR1cm4gdGhpcy5qb2luQ2hpbGQodG9FbClcbiAgICB9KVxuXG4gICAgaWYobmV3Q2hpbGRyZW4ubGVuZ3RoID09PSAwKXtcbiAgICAgIGlmKHRoaXMucGFyZW50KXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKV0pXG4gICAgICAgIHRoaXMucGFyZW50LmFja0pvaW4odGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKVxuICAgICAgICB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKV0pXG4gICAgfVxuICB9XG5cbiAgYXR0YWNoVHJ1ZURvY0VsKCl7XG4gICAgdGhpcy5lbCA9IERPTS5ieUlkKHRoaXMuaWQpXG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZClcbiAgfVxuXG4gIGFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cyl7XG4gICAgdGhpcy5hdHRhY2hUcnVlRG9jRWwoKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBudWxsKVxuICAgIHBhdGNoLm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKClcbiAgICB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgZmFsc2UpXG4gICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKVxuICAgIERPTS5hbGwodGhpcy5lbCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XSwgW2RhdGEtcGh4LSR7UEhYX0hPT0t9XWAsIGhvb2tFbCA9PiB7XG4gICAgICBsZXQgaG9vayA9IHRoaXMuYWRkSG9vayhob29rRWwpXG4gICAgICBpZihob29rKXsgaG9vay5fX21vdW50ZWQoKSB9XG4gICAgfSlcblxuICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZVxuICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpXG4gICAgdGhpcy5hcHBseVBlbmRpbmdVcGRhdGVzKClcblxuICAgIGlmKGxpdmVfcGF0Y2gpe1xuICAgICAgbGV0IHtraW5kLCB0b30gPSBsaXZlX3BhdGNoXG4gICAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKVxuICAgIH1cbiAgICB0aGlzLmhpZGVMb2FkZXIoKVxuICAgIGlmKHRoaXMuam9pbkNvdW50ID4gMSl7IHRoaXMudHJpZ2dlclJlY29ubmVjdGVkKCkgfVxuICAgIHRoaXMuc3RvcENhbGxiYWNrKClcbiAgfVxuXG4gIHRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbCl7XG4gICAgdGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbkJlZm9yZUVsVXBkYXRlZFwiLCBbZnJvbUVsLCB0b0VsXSlcbiAgICBsZXQgaG9vayA9IHRoaXMuZ2V0SG9vayhmcm9tRWwpXG4gICAgbGV0IGlzSWdub3JlZCA9IGhvb2sgJiYgRE9NLmlzSWdub3JlZChmcm9tRWwsIHRoaXMuYmluZGluZyhQSFhfVVBEQVRFKSlcbiAgICBpZihob29rICYmICFmcm9tRWwuaXNFcXVhbE5vZGUodG9FbCkgJiYgIShpc0lnbm9yZWQgJiYgaXNFcXVhbE9iaihmcm9tRWwuZGF0YXNldCwgdG9FbC5kYXRhc2V0KSkpe1xuICAgICAgaG9vay5fX2JlZm9yZVVwZGF0ZSgpXG4gICAgICByZXR1cm4gaG9va1xuICAgIH1cbiAgfVxuXG4gIHBlcmZvcm1QYXRjaChwYXRjaCwgcHJ1bmVDaWRzKXtcbiAgICBsZXQgcmVtb3ZlZEVscyA9IFtdXG4gICAgbGV0IHBoeENoaWxkcmVuQWRkZWQgPSBmYWxzZVxuICAgIGxldCB1cGRhdGVkSG9va0lkcyA9IG5ldyBTZXQoKVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJhZGRlZFwiLCBlbCA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uTm9kZUFkZGVkXCIsIFtlbF0pXG5cbiAgICAgIGxldCBuZXdIb29rID0gdGhpcy5hZGRIb29rKGVsKVxuICAgICAgaWYobmV3SG9vayl7IG5ld0hvb2suX19tb3VudGVkKCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwgPT4ge1xuICAgICAgaWYoRE9NLmlzUGh4U3RpY2t5KGVsKSl7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5qb2luUm9vdFZpZXdzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHBhdGNoLmJlZm9yZShcInVwZGF0ZWRcIiwgKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbClcbiAgICAgIGlmKGhvb2speyB1cGRhdGVkSG9va0lkcy5hZGQoZnJvbUVsLmlkKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidXBkYXRlZFwiLCBlbCA9PiB7XG4gICAgICBpZih1cGRhdGVkSG9va0lkcy5oYXMoZWwuaWQpKXsgdGhpcy5nZXRIb29rKGVsKS5fX3VwZGF0ZWQoKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwiZGlzY2FyZGVkXCIsIChlbCkgPT4ge1xuICAgICAgaWYoZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKXsgcmVtb3ZlZEVscy5wdXNoKGVsKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgZWxzID0+IHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQoZWxzLCBwcnVuZUNpZHMpKVxuICAgIHBhdGNoLnBlcmZvcm0oKVxuICAgIHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQocmVtb3ZlZEVscywgcHJ1bmVDaWRzKVxuXG4gICAgcmV0dXJuIHBoeENoaWxkcmVuQWRkZWRcbiAgfVxuXG4gIGFmdGVyRWxlbWVudHNSZW1vdmVkKGVsZW1lbnRzLCBwcnVuZUNpZHMpe1xuICAgIGxldCBkZXN0cm95ZWRDSURzID0gW11cbiAgICBlbGVtZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICBsZXQgY29tcG9uZW50cyA9IERPTS5hbGwocGFyZW50LCBgWyR7UEhYX0NPTVBPTkVOVH1dYClcbiAgICAgIGxldCBob29rcyA9IERPTS5hbGwocGFyZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9IT09LKX1dYClcbiAgICAgIGNvbXBvbmVudHMuY29uY2F0KHBhcmVudCkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGxldCBjaWQgPSB0aGlzLmNvbXBvbmVudElEKGVsKVxuICAgICAgICBpZihpc0NpZChjaWQpICYmIGRlc3Ryb3llZENJRHMuaW5kZXhPZihjaWQpID09PSAtMSl7IGRlc3Ryb3llZENJRHMucHVzaChjaWQpIH1cbiAgICAgIH0pXG4gICAgICBob29rcy5jb25jYXQocGFyZW50KS5mb3JFYWNoKGhvb2tFbCA9PiB7XG4gICAgICAgIGxldCBob29rID0gdGhpcy5nZXRIb29rKGhvb2tFbClcbiAgICAgICAgaG9vayAmJiB0aGlzLmRlc3Ryb3lIb29rKGhvb2spXG4gICAgICB9KVxuICAgIH0pXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcnVuZUNpZHMgb24gam9pbnMuIE90aGVyd2lzZSwgaW4gY2FzZSBvZlxuICAgIC8vIHJlam9pbnMsIHdlIG1heSBub3RpZnkgY2lkcyB0aGF0IG5vIGxvbmdlciBiZWxvbmcgdG8gdGhlXG4gICAgLy8gY3VycmVudCBMaXZlVmlldyB0byBiZSByZW1vdmVkLlxuICAgIGlmKHBydW5lQ2lkcyl7XG4gICAgICB0aGlzLm1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWQoZGVzdHJveWVkQ0lEcylcbiAgICB9XG4gIH1cblxuICBqb2luTmV3Q2hpbGRyZW4oKXtcbiAgICBET00uZmluZFBoeENoaWxkcmVuKHRoaXMuZWwsIHRoaXMuaWQpLmZvckVhY2goZWwgPT4gdGhpcy5qb2luQ2hpbGQoZWwpKVxuICB9XG5cbiAgZ2V0Q2hpbGRCeUlkKGlkKXsgcmV0dXJuIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXVtpZF0gfVxuXG4gIGdldERlc2NlbmRlbnRCeUVsKGVsKXtcbiAgICBpZihlbC5pZCA9PT0gdGhpcy5pZCl7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCldW2VsLmlkXVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lEZXNjZW5kZW50KGlkKXtcbiAgICBmb3IobGV0IHBhcmVudElkIGluIHRoaXMucm9vdC5jaGlsZHJlbil7XG4gICAgICBmb3IobGV0IGNoaWxkSWQgaW4gdGhpcy5yb290LmNoaWxkcmVuW3BhcmVudElkXSl7XG4gICAgICAgIGlmKGNoaWxkSWQgPT09IGlkKXsgcmV0dXJuIHRoaXMucm9vdC5jaGlsZHJlbltwYXJlbnRJZF1bY2hpbGRJZF0uZGVzdHJveSgpIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBqb2luQ2hpbGQoZWwpe1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRCeUlkKGVsLmlkKVxuICAgIGlmKCFjaGlsZCl7XG4gICAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLmxpdmVTb2NrZXQsIHRoaXMpXG4gICAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bdmlldy5pZF0gPSB2aWV3XG4gICAgICB2aWV3LmpvaW4oKVxuICAgICAgdGhpcy5jaGlsZEpvaW5zKytcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgaXNKb2luUGVuZGluZygpeyByZXR1cm4gdGhpcy5qb2luUGVuZGluZyB9XG5cbiAgYWNrSm9pbihfY2hpbGQpe1xuICAgIHRoaXMuY2hpbGRKb2lucy0tXG5cbiAgICBpZih0aGlzLmNoaWxkSm9pbnMgPT09IDApe1xuICAgICAgaWYodGhpcy5wYXJlbnQpe1xuICAgICAgICB0aGlzLnBhcmVudC5hY2tKb2luKHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpe1xuICAgIHRoaXMuam9pbkNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMuZm9yRWFjaCgoW3ZpZXcsIG9wXSkgPT4ge1xuICAgICAgICBpZighdmlldy5pc0Rlc3Ryb3llZCgpKXsgb3AoKSB9XG4gICAgICB9KVxuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IFtdXG4gICAgfSlcbiAgfVxuXG4gIHVwZGF0ZShkaWZmLCBldmVudHMpe1xuICAgIGlmKHRoaXMuaXNKb2luUGVuZGluZygpIHx8ICh0aGlzLmxpdmVTb2NrZXQuaGFzUGVuZGluZ0xpbmsoKSAmJiAhRE9NLmlzUGh4U3RpY2t5KHRoaXMuZWwpKSl7XG4gICAgICByZXR1cm4gdGhpcy5wZW5kaW5nRGlmZnMucHVzaCh7ZGlmZiwgZXZlbnRzfSlcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihkaWZmKVxuICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2VcblxuICAgIC8vIFdoZW4gdGhlIGRpZmYgb25seSBjb250YWlucyBjb21wb25lbnQgZGlmZnMsIHRoZW4gd2FsayBjb21wb25lbnRzXG4gICAgLy8gYW5kIHBhdGNoIG9ubHkgdGhlIHBhcmVudCBjb21wb25lbnQgY29udGFpbmVycyBmb3VuZCBpbiB0aGUgZGlmZi5cbiAgICAvLyBPdGhlcndpc2UsIHBhdGNoIGVudGlyZSBMViBjb250YWluZXIuXG4gICAgaWYodGhpcy5yZW5kZXJlZC5pc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiY29tcG9uZW50IHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgbGV0IHBhcmVudENpZHMgPSBET00uZmluZFBhcmVudENJRHModGhpcy5lbCwgdGhpcy5yZW5kZXJlZC5jb21wb25lbnRDSURzKGRpZmYpKVxuICAgICAgICBwYXJlbnRDaWRzLmZvckVhY2gocGFyZW50Q0lEID0+IHtcbiAgICAgICAgICBpZih0aGlzLmNvbXBvbmVudFBhdGNoKHRoaXMucmVuZGVyZWQuZ2V0Q29tcG9uZW50KGRpZmYsIHBhcmVudENJRCksIHBhcmVudENJRCkpeyBwaHhDaGlsZHJlbkFkZGVkID0gdHJ1ZSB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZighaXNFbXB0eShkaWZmKSl7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImZ1bGwgcGF0Y2ggY29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyQ29udGFpbmVyKGRpZmYsIFwidXBkYXRlXCIpXG4gICAgICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBudWxsKVxuICAgICAgICBwaHhDaGlsZHJlbkFkZGVkID0gdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIHRydWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpXG4gICAgaWYocGh4Q2hpbGRyZW5BZGRlZCl7IHRoaXMuam9pbk5ld0NoaWxkcmVuKCkgfVxuICB9XG5cbiAgcmVuZGVyQ29udGFpbmVyKGRpZmYsIGtpbmQpe1xuICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQudGltZShgdG9TdHJpbmcgZGlmZiAoJHtraW5kfSlgLCAoKSA9PiB7XG4gICAgICBsZXQgdGFnID0gdGhpcy5lbC50YWdOYW1lXG4gICAgICAvLyBEb24ndCBza2lwIGFueSBjb21wb25lbnQgaW4gdGhlIGRpZmYgbm9yIGFueSBtYXJrZWQgYXMgcHJ1bmVkXG4gICAgICAvLyAoYXMgdGhleSBtYXkgaGF2ZSBiZWVuIGFkZGVkIGJhY2spXG4gICAgICBsZXQgY2lkcyA9IGRpZmYgPyB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudENJRHMoZGlmZikuY29uY2F0KHRoaXMucHJ1bmluZ0NJRHMpIDogbnVsbFxuICAgICAgbGV0IGh0bWwgPSB0aGlzLnJlbmRlcmVkLnRvU3RyaW5nKGNpZHMpXG4gICAgICByZXR1cm4gYDwke3RhZ30+JHtodG1sfTwvJHt0YWd9PmBcbiAgICB9KVxuICB9XG5cbiAgY29tcG9uZW50UGF0Y2goZGlmZiwgY2lkKXtcbiAgICBpZihpc0VtcHR5KGRpZmYpKSByZXR1cm4gZmFsc2VcbiAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyZWQuY29tcG9uZW50VG9TdHJpbmcoY2lkKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBjaWQpXG4gICAgbGV0IGNoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSlcbiAgICByZXR1cm4gY2hpbGRyZW5BZGRlZFxuICB9XG5cbiAgZ2V0SG9vayhlbCl7IHJldHVybiB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoZWwpXSB9XG5cbiAgYWRkSG9vayhlbCl7XG4gICAgaWYoVmlld0hvb2suZWxlbWVudElEKGVsKSB8fCAhZWwuZ2V0QXR0cmlidXRlKXsgcmV0dXJuIH1cbiAgICBsZXQgaG9va05hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoYGRhdGEtcGh4LSR7UEhYX0hPT0t9YCkgfHwgZWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfSE9PSykpXG4gICAgaWYoaG9va05hbWUgJiYgIXRoaXMub3duc0VsZW1lbnQoZWwpKXsgcmV0dXJuIH1cbiAgICBsZXQgY2FsbGJhY2tzID0gdGhpcy5saXZlU29ja2V0LmdldEhvb2tDYWxsYmFja3MoaG9va05hbWUpXG5cbiAgICBpZihjYWxsYmFja3Mpe1xuICAgICAgaWYoIWVsLmlkKXsgbG9nRXJyb3IoYG5vIERPTSBJRCBmb3IgaG9vayBcIiR7aG9va05hbWV9XCIuIEhvb2tzIHJlcXVpcmUgYSB1bmlxdWUgSUQgb24gZWFjaCBlbGVtZW50LmAsIGVsKSB9XG4gICAgICBsZXQgaG9vayA9IG5ldyBWaWV3SG9vayh0aGlzLCBlbCwgY2FsbGJhY2tzKVxuICAgICAgdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGhvb2suZWwpXSA9IGhvb2tcbiAgICAgIHJldHVybiBob29rXG4gICAgfSBlbHNlIGlmKGhvb2tOYW1lICE9PSBudWxsKXtcbiAgICAgIGxvZ0Vycm9yKGB1bmtub3duIGhvb2sgZm91bmQgZm9yIFwiJHtob29rTmFtZX1cImAsIGVsKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lIb29rKGhvb2spe1xuICAgIGhvb2suX19kZXN0cm95ZWQoKVxuICAgIGhvb2suX19jbGVhbnVwX18oKVxuICAgIGRlbGV0ZSB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoaG9vay5lbCldXG4gIH1cblxuICBhcHBseVBlbmRpbmdVcGRhdGVzKCl7XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICB9XG5cbiAgb25DaGFubmVsKGV2ZW50LCBjYil7XG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIGV2ZW50LCByZXNwID0+IHtcbiAgICAgIGlmKHRoaXMuaXNKb2luUGVuZGluZygpKXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IGNiKHJlc3ApXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IGNiKHJlc3ApKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBiaW5kQ2hhbm5lbCgpe1xuICAgIC8vIFRoZSBkaWZmIGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSByZWd1bGFyIHVwZGF0ZSBvcGVyYXRpb25zLlxuICAgIC8vIEFsbCBvdGhlciBvcGVyYXRpb25zIGFyZSBxdWV1ZWQgdG8gYmUgYXBwbGllZCBvbmx5IGFmdGVyIGpvaW4uXG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIFwiZGlmZlwiLCAocmF3RGlmZikgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByYXdEaWZmLCAoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJyZWRpcmVjdFwiLCAoe3RvLCBmbGFzaH0pID0+IHRoaXMub25SZWRpcmVjdCh7dG8sIGZsYXNofSkpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3BhdGNoXCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVQYXRjaChyZWRpcikpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZWRpcikpXG4gICAgdGhpcy5jaGFubmVsLm9uRXJyb3IocmVhc29uID0+IHRoaXMub25FcnJvcihyZWFzb24pKVxuICAgIHRoaXMuY2hhbm5lbC5vbkNsb3NlKHJlYXNvbiA9PiB0aGlzLm9uQ2xvc2UocmVhc29uKSlcbiAgfVxuXG4gIGRlc3Ryb3lBbGxDaGlsZHJlbigpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdKXtcbiAgICAgIHRoaXMuZ2V0Q2hpbGRCeUlkKGlkKS5kZXN0cm95KClcbiAgICB9XG4gIH1cblxuICBvbkxpdmVSZWRpcmVjdChyZWRpcil7XG4gICAgbGV0IHt0bywga2luZCwgZmxhc2h9ID0gcmVkaXJcbiAgICBsZXQgdXJsID0gdGhpcy5leHBhbmRVUkwodG8pXG4gICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlSZWRpcmVjdCh1cmwsIGtpbmQsIGZsYXNoKVxuICB9XG5cbiAgb25MaXZlUGF0Y2gocmVkaXIpe1xuICAgIGxldCB7dG8sIGtpbmR9ID0gcmVkaXJcbiAgICB0aGlzLmhyZWYgPSB0aGlzLmV4cGFuZFVSTCh0bylcbiAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKVxuICB9XG5cbiAgZXhwYW5kVVJMKHRvKXtcbiAgICByZXR1cm4gdG8uc3RhcnRzV2l0aChcIi9cIikgPyBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0fSR7dG99YCA6IHRvXG4gIH1cblxuICBvblJlZGlyZWN0KHt0bywgZmxhc2h9KXsgdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHRvLCBmbGFzaCkgfVxuXG4gIGlzRGVzdHJveWVkKCl7IHJldHVybiB0aGlzLmRlc3Ryb3llZCB9XG5cbiAgam9pbihjYWxsYmFjayl7XG4gICAgaWYodGhpcy5pc01haW4oKSl7XG4gICAgICB0aGlzLnN0b3BDYWxsYmFjayA9IHRoaXMubGl2ZVNvY2tldC53aXRoUGFnZUxvYWRpbmcoe3RvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiaW5pdGlhbFwifSlcbiAgICB9XG4gICAgdGhpcy5qb2luQ2FsbGJhY2sgPSAob25Eb25lKSA9PiB7XG4gICAgICBvbkRvbmUgPSBvbkRvbmUgfHwgZnVuY3Rpb24oKXt9XG4gICAgICBjYWxsYmFjayA/IGNhbGxiYWNrKHRoaXMuam9pbkNvdW50LCBvbkRvbmUpIDogb25Eb25lKClcbiAgICB9XG4gICAgdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMsIHt0aW1lb3V0OiBmYWxzZX0sICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwuam9pbigpXG4gICAgICAgIC5yZWNlaXZlKFwib2tcIiwgZGF0YSA9PiB7XG4gICAgICAgICAgaWYoIXRoaXMuaXNEZXN0cm95ZWQoKSl7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB0aGlzLm9uSm9pbihkYXRhKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgcmVzcCA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIHRoaXMub25Kb2luRXJyb3IocmVzcCkpXG4gICAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIHRoaXMub25Kb2luRXJyb3Ioe3JlYXNvbjogXCJ0aW1lb3V0XCJ9KSlcbiAgICB9KVxuICB9XG5cbiAgb25Kb2luRXJyb3IocmVzcCl7XG4gICAgaWYocmVzcC5yZWFzb24gPT09IFwidW5hdXRob3JpemVkXCIgfHwgcmVzcC5yZWFzb24gPT09IFwic3RhbGVcIil7XG4gICAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInVuYXV0aG9yaXplZCBsaXZlX3JlZGlyZWN0LiBGYWxsaW5nIGJhY2sgdG8gcGFnZSByZXF1ZXN0XCIsIHJlc3BdKVxuICAgICAgcmV0dXJuIHRoaXMub25SZWRpcmVjdCh7dG86IHRoaXMuaHJlZn0pXG4gICAgfVxuICAgIGlmKHJlc3AucmVkaXJlY3QgfHwgcmVzcC5saXZlX3JlZGlyZWN0KXtcbiAgICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZVxuICAgICAgdGhpcy5jaGFubmVsLmxlYXZlKClcbiAgICB9XG4gICAgaWYocmVzcC5yZWRpcmVjdCl7IHJldHVybiB0aGlzLm9uUmVkaXJlY3QocmVzcC5yZWRpcmVjdCkgfVxuICAgIGlmKHJlc3AubGl2ZV9yZWRpcmVjdCl7IHJldHVybiB0aGlzLm9uTGl2ZVJlZGlyZWN0KHJlc3AubGl2ZV9yZWRpcmVjdCkgfVxuICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hYmxlIHRvIGpvaW5cIiwgcmVzcF0pXG4gICAgaWYodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLmxpdmVTb2NrZXQucmVsb2FkV2l0aEppdHRlcih0aGlzKSB9XG4gIH1cblxuICBvbkNsb3NlKHJlYXNvbil7XG4gICAgaWYodGhpcy5pc0Rlc3Ryb3llZCgpKXsgcmV0dXJuIH1cbiAgICBpZih0aGlzLmxpdmVTb2NrZXQuaGFzUGVuZGluZ0xpbmsoKSAmJiByZWFzb24gIT09IFwibGVhdmVcIil7XG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcylcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKVxuICAgIHRoaXMubGl2ZVNvY2tldC5kcm9wQWN0aXZlRWxlbWVudCh0aGlzKVxuICAgIC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIGJlIG51bGwgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbiAgICBpZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KXsgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCkgfVxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpe1xuICAgICAgdGhpcy5zaG93TG9hZGVyKEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQpXG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihyZWFzb24pe1xuICAgIHRoaXMub25DbG9zZShyZWFzb24pXG4gICAgaWYodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInZpZXcgY3Jhc2hlZFwiLCByZWFzb25dKSB9XG4gICAgaWYoIXRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpeyB0aGlzLmRpc3BsYXlFcnJvcigpIH1cbiAgfVxuXG4gIGRpc3BsYXlFcnJvcigpe1xuICAgIGlmKHRoaXMuaXNNYWluKCkpeyBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7ZGV0YWlsOiB7dG86IHRoaXMuaHJlZiwga2luZDogXCJlcnJvclwifX0pIH1cbiAgICB0aGlzLnNob3dMb2FkZXIoKVxuICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfRElTQ09OTkVDVEVEX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MpXG4gIH1cblxuICBwdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7IHJldHVybiB9XG5cbiAgICBsZXQgW3JlZiwgW2VsXSwgb3B0c10gPSByZWZHZW5lcmF0b3IgPyByZWZHZW5lcmF0b3IoKSA6IFtudWxsLCBbXSwge31dXG4gICAgbGV0IG9uTG9hZGluZ0RvbmUgPSBmdW5jdGlvbigpeyB9XG4gICAgaWYob3B0cy5wYWdlX2xvYWRpbmcgfHwgKGVsICYmIChlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9QQUdFX0xPQURJTkcpKSAhPT0gbnVsbCkpKXtcbiAgICAgIG9uTG9hZGluZ0RvbmUgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHtraW5kOiBcImVsZW1lbnRcIiwgdGFyZ2V0OiBlbH0pXG4gICAgfVxuXG4gICAgaWYodHlwZW9mIChwYXlsb2FkLmNpZCkgIT09IFwibnVtYmVyXCIpeyBkZWxldGUgcGF5bG9hZC5jaWQgfVxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcywge3RpbWVvdXQ6IHRydWV9LCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwucHVzaChldmVudCwgcGF5bG9hZCwgUFVTSF9USU1FT1VUKS5yZWNlaXZlKFwib2tcIiwgcmVzcCA9PiB7XG4gICAgICAgICAgaWYocmVmICE9PSBudWxsKXsgdGhpcy51bmRvUmVmcyhyZWYpIH1cbiAgICAgICAgICBsZXQgZmluaXNoID0gKGhvb2tSZXBseSkgPT4ge1xuICAgICAgICAgICAgaWYocmVzcC5yZWRpcmVjdCl7IHRoaXMub25SZWRpcmVjdChyZXNwLnJlZGlyZWN0KSB9XG4gICAgICAgICAgICBpZihyZXNwLmxpdmVfcGF0Y2gpeyB0aGlzLm9uTGl2ZVBhdGNoKHJlc3AubGl2ZV9wYXRjaCkgfVxuICAgICAgICAgICAgaWYocmVzcC5saXZlX3JlZGlyZWN0KXsgdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpIH1cbiAgICAgICAgICAgIG9uTG9hZGluZ0RvbmUoKVxuICAgICAgICAgICAgb25SZXBseShyZXNwLCBob29rUmVwbHkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlc3AuZGlmZil7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBob29rUmVwbHkgPSB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByZXNwLmRpZmYsICh7ZGlmZiwgZXZlbnRzfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgZmluaXNoKGhvb2tSZXBseSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbmlzaChudWxsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgdW5kb1JlZnMocmVmKXtcbiAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7UEhYX1JFRl9TUkN9PVwiJHt0aGlzLmlkfVwiXVske1BIWF9SRUZ9PVwiJHtyZWZ9XCJdYCwgZWwgPT4ge1xuICAgICAgbGV0IGRpc2FibGVkVmFsID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRClcbiAgICAgIC8vIHJlbW92ZSByZWZzXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRilcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX1NSQylcbiAgICAgIC8vIHJlc3RvcmUgaW5wdXRzXG4gICAgICBpZihlbC5nZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZKSAhPT0gbnVsbCl7XG4gICAgICAgIGVsLnJlYWRPbmx5ID0gZmFsc2VcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUFET05MWSlcbiAgICAgIH1cbiAgICAgIGlmKGRpc2FibGVkVmFsICE9PSBudWxsKXtcbiAgICAgICAgZWwuZGlzYWJsZWQgPSBkaXNhYmxlZFZhbCA9PT0gXCJ0cnVlXCIgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9ESVNBQkxFRClcbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSBjbGFzc2VzXG4gICAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKGNsYXNzTmFtZSA9PiBET00ucmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSkpXG4gICAgICAvLyByZXN0b3JlIGRpc2FibGVzXG4gICAgICBsZXQgZGlzYWJsZVJlc3RvcmUgPSBlbC5nZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFKVxuICAgICAgaWYoZGlzYWJsZVJlc3RvcmUgIT09IG51bGwpe1xuICAgICAgICBlbC5pbm5lclRleHQgPSBkaXNhYmxlUmVzdG9yZVxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFKVxuICAgICAgfVxuICAgICAgbGV0IHRvRWwgPSBET00ucHJpdmF0ZShlbCwgUEhYX1JFRilcbiAgICAgIGlmKHRvRWwpe1xuICAgICAgICBsZXQgaG9vayA9IHRoaXMudHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZWwsIHRvRWwpXG4gICAgICAgIERPTVBhdGNoLnBhdGNoRWwoZWwsIHRvRWwsIHRoaXMubGl2ZVNvY2tldC5nZXRBY3RpdmVFbGVtZW50KCkpXG4gICAgICAgIGlmKGhvb2speyBob29rLl9fdXBkYXRlZCgpIH1cbiAgICAgICAgRE9NLmRlbGV0ZVByaXZhdGUoZWwsIFBIWF9SRUYpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHB1dFJlZihlbGVtZW50cywgZXZlbnQsIG9wdHMgPSB7fSl7XG4gICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmKytcbiAgICBsZXQgZGlzYWJsZVdpdGggPSB0aGlzLmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSClcbiAgICBpZihvcHRzLmxvYWRpbmcpeyBlbGVtZW50cyA9IGVsZW1lbnRzLmNvbmNhdChET00uYWxsKGRvY3VtZW50LCBvcHRzLmxvYWRpbmcpKX1cblxuICAgIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChgcGh4LSR7ZXZlbnR9LWxvYWRpbmdgKVxuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9SRUYsIG5ld1JlZilcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGX1NSQywgdGhpcy5lbC5pZClcbiAgICAgIGxldCBkaXNhYmxlVGV4dCA9IGVsLmdldEF0dHJpYnV0ZShkaXNhYmxlV2l0aClcbiAgICAgIGlmKGRpc2FibGVUZXh0ICE9PSBudWxsKXtcbiAgICAgICAgaWYoIWVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpKXtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLCBlbC5pbm5lclRleHQpXG4gICAgICAgIH1cbiAgICAgICAgaWYoZGlzYWJsZVRleHQgIT09IFwiXCIpeyBlbC5pbm5lclRleHQgPSBkaXNhYmxlVGV4dCB9XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gW25ld1JlZiwgZWxlbWVudHMsIG9wdHNdXG4gIH1cblxuICBjb21wb25lbnRJRChlbCl7XG4gICAgbGV0IGNpZCA9IGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVClcbiAgICByZXR1cm4gY2lkID8gcGFyc2VJbnQoY2lkKSA6IG51bGxcbiAgfVxuXG4gIHRhcmdldENvbXBvbmVudElEKHRhcmdldCwgdGFyZ2V0Q3R4LCBvcHRzID0ge30pe1xuICAgIGlmKGlzQ2lkKHRhcmdldEN0eCkpeyByZXR1cm4gdGFyZ2V0Q3R4IH1cblxuICAgIGxldCBjaWRPclNlbGVjdG9yID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJ0YXJnZXRcIikpXG4gICAgaWYoaXNDaWQoY2lkT3JTZWxlY3Rvcikpe1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGNpZE9yU2VsZWN0b3IpXG4gICAgfSBlbHNlIGlmKHRhcmdldEN0eCAmJiAoY2lkT3JTZWxlY3RvciAhPT0gbnVsbCB8fCBvcHRzLnRhcmdldCkpe1xuICAgICAgcmV0dXJuIHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBjbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KXtcbiAgICBpZihpc0NpZCh0YXJnZXRDdHgpKXtcbiAgICAgIHJldHVybiB0YXJnZXRDdHhcbiAgICB9IGVsc2UgaWYodGFyZ2V0Q3R4KXtcbiAgICAgIHJldHVybiBtYXliZSh0YXJnZXRDdHguY2xvc2VzdChgWyR7UEhYX0NPTVBPTkVOVH1dYCksIGVsID0+IHRoaXMub3duc0VsZW1lbnQoZWwpICYmIHRoaXMuY29tcG9uZW50SUQoZWwpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHB1c2hIb29rRXZlbnQodGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgb25SZXBseSl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7XG4gICAgICB0aGlzLmxvZyhcImhvb2tcIiwgKCkgPT4gW1widW5hYmxlIHRvIHB1c2ggaG9vayBldmVudC4gTGl2ZVZpZXcgbm90IGNvbm5lY3RlZFwiLCBldmVudCwgcGF5bG9hZF0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgbGV0IFtyZWYsIGVscywgb3B0c10gPSB0aGlzLnB1dFJlZihbXSwgXCJob29rXCIpXG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KCgpID0+IFtyZWYsIGVscywgb3B0c10sIFwiZXZlbnRcIiwge1xuICAgICAgdHlwZTogXCJob29rXCIsXG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICB2YWx1ZTogcGF5bG9hZCxcbiAgICAgIGNpZDogdGhpcy5jbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KVxuICAgIH0sIChyZXNwLCByZXBseSkgPT4gb25SZXBseShyZXBseSwgcmVmKSlcblxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIGV4dHJhY3RNZXRhKGVsLCBtZXRhLCB2YWx1ZSl7XG4gICAgbGV0IHByZWZpeCA9IHRoaXMuYmluZGluZyhcInZhbHVlLVwiKVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBlbC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmKCFtZXRhKXsgbWV0YSA9IHt9IH1cbiAgICAgIGxldCBuYW1lID0gZWwuYXR0cmlidXRlc1tpXS5uYW1lXG4gICAgICBpZihuYW1lLnN0YXJ0c1dpdGgocHJlZml4KSl7IG1ldGFbbmFtZS5yZXBsYWNlKHByZWZpeCwgXCJcIildID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpIH1cbiAgICB9XG4gICAgaWYoZWwudmFsdWUgIT09IHVuZGVmaW5lZCl7XG4gICAgICBpZighbWV0YSl7IG1ldGEgPSB7fSB9XG4gICAgICBtZXRhLnZhbHVlID0gZWwudmFsdWVcblxuICAgICAgaWYoZWwudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIENIRUNLQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlKSA+PSAwICYmICFlbC5jaGVja2VkKXtcbiAgICAgICAgZGVsZXRlIG1ldGEudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYodmFsdWUpe1xuICAgICAgaWYoIW1ldGEpeyBtZXRhID0ge30gfVxuICAgICAgZm9yKGxldCBrZXkgaW4gdmFsdWUpeyBtZXRhW2tleV0gPSB2YWx1ZVtrZXldIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ldGFcbiAgfVxuXG4gIHB1c2hFdmVudCh0eXBlLCBlbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgbWV0YSwgb3B0cyA9IHt9KXtcbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkoKCkgPT4gdGhpcy5wdXRSZWYoW2VsXSwgdHlwZSwgb3B0cyksIFwiZXZlbnRcIiwge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgIHZhbHVlOiB0aGlzLmV4dHJhY3RNZXRhKGVsLCBtZXRhLCBvcHRzLnZhbHVlKSxcbiAgICAgIGNpZDogdGhpcy50YXJnZXRDb21wb25lbnRJRChlbCwgdGFyZ2V0Q3R4LCBvcHRzKVxuICAgIH0pXG4gIH1cblxuICBwdXNoRmlsZVByb2dyZXNzKGZpbGVFbCwgZW50cnlSZWYsIHByb2dyZXNzLCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHRoaXMubGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZmlsZUVsLmZvcm0sICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIHZpZXcucHVzaFdpdGhSZXBseShudWxsLCBcInByb2dyZXNzXCIsIHtcbiAgICAgICAgZXZlbnQ6IGZpbGVFbC5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFBIWF9QUk9HUkVTUykpLFxuICAgICAgICByZWY6IGZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpLFxuICAgICAgICBlbnRyeV9yZWY6IGVudHJ5UmVmLFxuICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3MsXG4gICAgICAgIGNpZDogdmlldy50YXJnZXRDb21wb25lbnRJRChmaWxlRWwuZm9ybSwgdGFyZ2V0Q3R4KVxuICAgICAgfSwgb25SZXBseSlcbiAgICB9KVxuICB9XG5cbiAgcHVzaElucHV0KGlucHV0RWwsIHRhcmdldEN0eCwgZm9yY2VDaWQsIHBoeEV2ZW50LCBvcHRzLCBjYWxsYmFjayl7XG4gICAgbGV0IHVwbG9hZHNcbiAgICBsZXQgY2lkID0gaXNDaWQoZm9yY2VDaWQpID8gZm9yY2VDaWQgOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4KVxuICAgIGxldCByZWZHZW5lcmF0b3IgPSAoKSA9PiB0aGlzLnB1dFJlZihbaW5wdXRFbCwgaW5wdXRFbC5mb3JtXSwgXCJjaGFuZ2VcIiwgb3B0cylcbiAgICBsZXQgZm9ybURhdGFcbiAgICBpZihpbnB1dEVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpKXtcbiAgICAgIGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHtfdGFyZ2V0OiBvcHRzLl90YXJnZXR9LCBbaW5wdXRFbC5uYW1lXSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGlucHV0RWwuZm9ybSwge190YXJnZXQ6IG9wdHMuX3RhcmdldH0pXG4gICAgfVxuICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGlucHV0RWwpICYmIGlucHV0RWwuZmlsZXMgJiYgaW5wdXRFbC5maWxlcy5sZW5ndGggPiAwKXtcbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKGlucHV0RWwsIEFycmF5LmZyb20oaW5wdXRFbC5maWxlcykpXG4gICAgfVxuICAgIHVwbG9hZHMgPSBMaXZlVXBsb2FkZXIuc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKVxuICAgIGxldCBldmVudCA9IHtcbiAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgdXBsb2FkczogdXBsb2FkcyxcbiAgICAgIGNpZDogY2lkXG4gICAgfVxuICAgIHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIFwiZXZlbnRcIiwgZXZlbnQsIHJlc3AgPT4ge1xuICAgICAgRE9NLnNob3dFcnJvcihpbnB1dEVsLCB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKSlcbiAgICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGlucHV0RWwpICYmIGlucHV0RWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtYXV0by11cGxvYWRcIikgIT09IG51bGwpe1xuICAgICAgICBpZihMaXZlVXBsb2FkZXIuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dEVsKS5sZW5ndGggPiAwKXtcbiAgICAgICAgICBsZXQgW3JlZiwgX2Vsc10gPSByZWZHZW5lcmF0b3IoKVxuICAgICAgICAgIHRoaXMudXBsb2FkRmlsZXMoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgsIHJlZiwgY2lkLCAoX3VwbG9hZHMpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3ApXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJBd2FpdGluZ1N1Ym1pdChpbnB1dEVsLmZvcm0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdHJpZ2dlckF3YWl0aW5nU3VibWl0KGZvcm1FbCl7XG4gICAgbGV0IGF3YWl0aW5nU3VibWl0ID0gdGhpcy5nZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKVxuICAgIGlmKGF3YWl0aW5nU3VibWl0KXtcbiAgICAgIGxldCBbX2VsLCBfcmVmLCBfb3B0cywgY2FsbGJhY2tdID0gYXdhaXRpbmdTdWJtaXRcbiAgICAgIHRoaXMuY2FuY2VsU3VibWl0KGZvcm1FbClcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICBnZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKXtcbiAgICByZXR1cm4gdGhpcy5mb3JtU3VibWl0cy5maW5kKChbZWwsIF9yZWYsIF9vcHRzLCBfY2FsbGJhY2tdKSA9PiBlbC5pc1NhbWVOb2RlKGZvcm1FbCkpXG4gIH1cblxuICBzY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCkpeyByZXR1cm4gdHJ1ZSB9XG4gICAgdGhpcy5mb3JtU3VibWl0cy5wdXNoKFtmb3JtRWwsIHJlZiwgb3B0cywgY2FsbGJhY2tdKVxuICB9XG5cbiAgY2FuY2VsU3VibWl0KGZvcm1FbCl7XG4gICAgdGhpcy5mb3JtU3VibWl0cyA9IHRoaXMuZm9ybVN1Ym1pdHMuZmlsdGVyKChbZWwsIHJlZiwgX2NhbGxiYWNrXSkgPT4ge1xuICAgICAgaWYoZWwuaXNTYW1lTm9kZShmb3JtRWwpKXtcbiAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCBvblJlcGx5KXtcbiAgICBsZXQgZmlsdGVySWdub3JlZCA9IGVsID0+IHtcbiAgICAgIGxldCB1c2VySWdub3JlZCA9IGNsb3Nlc3RQaHhCaW5kaW5nKGVsLCBgJHt0aGlzLmJpbmRpbmcoUEhYX1VQREFURSl9PWlnbm9yZWAsIGVsLmZvcm0pXG4gICAgICByZXR1cm4gISh1c2VySWdub3JlZCB8fCBjbG9zZXN0UGh4QmluZGluZyhlbCwgXCJkYXRhLXBoeC11cGRhdGU9aWdub3JlXCIsIGVsLmZvcm0pKVxuICAgIH1cbiAgICBsZXQgZmlsdGVyRGlzYWJsZXMgPSBlbCA9PiB7XG4gICAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKSlcbiAgICB9XG4gICAgbGV0IGZpbHRlckJ1dHRvbiA9IGVsID0+IGVsLnRhZ05hbWUgPT0gXCJCVVRUT05cIlxuXG4gICAgbGV0IGZpbHRlcklucHV0ID0gZWwgPT4gW1wiSU5QVVRcIiwgXCJURVhUQVJFQVwiLCBcIlNFTEVDVFwiXS5pbmNsdWRlcyhlbC50YWdOYW1lKVxuXG4gICAgbGV0IHJlZkdlbmVyYXRvciA9ICgpID0+IHtcbiAgICAgIGxldCBmb3JtRWxlbWVudHMgPSBBcnJheS5mcm9tKGZvcm1FbC5lbGVtZW50cylcbiAgICAgIGxldCBkaXNhYmxlcyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyRGlzYWJsZXMpXG4gICAgICBsZXQgYnV0dG9ucyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyQnV0dG9uKS5maWx0ZXIoZmlsdGVySWdub3JlZClcbiAgICAgIGxldCBpbnB1dHMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlcklucHV0KS5maWx0ZXIoZmlsdGVySWdub3JlZClcblxuICAgICAgYnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBidXR0b24uZGlzYWJsZWQpXG4gICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IHRydWVcbiAgICAgIH0pXG4gICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFksIGlucHV0LnJlYWRPbmx5KVxuICAgICAgICBpbnB1dC5yZWFkT25seSA9IHRydWVcbiAgICAgICAgaWYoaW5wdXQuZmlsZXMpe1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQsIGlucHV0LmRpc2FibGVkKVxuICAgICAgICAgIGlucHV0LmRpc2FibGVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgZm9ybUVsLnNldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX1BBR0VfTE9BRElORyksIFwiXCIpXG4gICAgICByZXR1cm4gdGhpcy5wdXRSZWYoW2Zvcm1FbF0uY29uY2F0KGRpc2FibGVzKS5jb25jYXQoYnV0dG9ucykuY29uY2F0KGlucHV0cyksIFwic3VibWl0XCIsIG9wdHMpXG4gICAgfVxuXG4gICAgbGV0IGNpZCA9IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZm9ybUVsLCB0YXJnZXRDdHgpXG4gICAgaWYoTGl2ZVVwbG9hZGVyLmhhc1VwbG9hZHNJblByb2dyZXNzKGZvcm1FbCkpe1xuICAgICAgbGV0IFtyZWYsIF9lbHNdID0gcmVmR2VuZXJhdG9yKClcbiAgICAgIGxldCBwdXNoID0gKCkgPT4gdGhpcy5wdXNoRm9ybVN1Ym1pdChmb3JtRWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG9wdHMsIG9uUmVwbHkpXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgcHVzaClcbiAgICB9IGVsc2UgaWYoTGl2ZVVwbG9hZGVyLmlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCkubGVuZ3RoID4gMCl7XG4gICAgICBsZXQgW3JlZiwgZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHJveHlSZWZHZW4gPSAoKSA9PiBbcmVmLCBlbHMsIG9wdHNdXG4gICAgICB0aGlzLnVwbG9hZEZpbGVzKGZvcm1FbCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgIGxldCBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oZm9ybUVsLCB7fSlcbiAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHByb3h5UmVmR2VuLCBcImV2ZW50XCIsIHtcbiAgICAgICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgICAgIGNpZDogY2lkXG4gICAgICAgIH0sIG9uUmVwbHkpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGZvcm1FbCwge30pXG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIHtcbiAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgICBjaWQ6IGNpZFxuICAgICAgfSwgb25SZXBseSlcbiAgICB9XG4gIH1cblxuICB1cGxvYWRGaWxlcyhmb3JtRWwsIHRhcmdldEN0eCwgcmVmLCBjaWQsIG9uQ29tcGxldGUpe1xuICAgIGxldCBqb2luQ291bnRBdFVwbG9hZCA9IHRoaXMuam9pbkNvdW50XG4gICAgbGV0IGlucHV0RWxzID0gTGl2ZVVwbG9hZGVyLmFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKVxuICAgIGxldCBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcyA9IGlucHV0RWxzLmxlbmd0aFxuXG4gICAgLy8gZ2V0IGVhY2ggZmlsZSBpbnB1dFxuICAgIGlucHV0RWxzLmZvckVhY2goaW5wdXRFbCA9PiB7XG4gICAgICBsZXQgdXBsb2FkZXIgPSBuZXcgTGl2ZVVwbG9hZGVyKGlucHV0RWwsIHRoaXMsICgpID0+IHtcbiAgICAgICAgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MtLVxuICAgICAgICBpZihudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcyA9PT0gMCl7IG9uQ29tcGxldGUoKSB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy51cGxvYWRlcnNbaW5wdXRFbF0gPSB1cGxvYWRlclxuICAgICAgbGV0IGVudHJpZXMgPSB1cGxvYWRlci5lbnRyaWVzKCkubWFwKGVudHJ5ID0+IGVudHJ5LnRvUHJlZmxpZ2h0UGF5bG9hZCgpKVxuXG4gICAgICBsZXQgcGF5bG9hZCA9IHtcbiAgICAgICAgcmVmOiBpbnB1dEVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgICAgIGNpZDogdGhpcy50YXJnZXRDb21wb25lbnRJRChpbnB1dEVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW1wic2VuZGluZyBwcmVmbGlnaHQgcmVxdWVzdFwiLCBwYXlsb2FkXSlcblxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiYWxsb3dfdXBsb2FkXCIsIHBheWxvYWQsIHJlc3AgPT4ge1xuICAgICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbXCJnb3QgcHJlZmxpZ2h0IHJlc3BvbnNlXCIsIHJlc3BdKVxuICAgICAgICBpZihyZXNwLmVycm9yKXtcbiAgICAgICAgICB0aGlzLnVuZG9SZWZzKHJlZilcbiAgICAgICAgICBsZXQgW2VudHJ5X3JlZiwgcmVhc29uXSA9IHJlc3AuZXJyb3JcbiAgICAgICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbYGVycm9yIGZvciBlbnRyeSAke2VudHJ5X3JlZn1gLCByZWFzb25dKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBvbkVycm9yID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwub25FcnJvcigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmKHRoaXMuam9pbkNvdW50ID09PSBqb2luQ291bnRBdFVwbG9hZCl7IGNhbGxiYWNrKCkgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBsb2FkZXIuaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgdGhpcy5saXZlU29ja2V0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBkaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXNPckJsb2JzKXtcbiAgICBsZXQgaW5wdXRzID0gRE9NLmZpbmRVcGxvYWRJbnB1dHModGhpcy5lbCkuZmlsdGVyKGVsID0+IGVsLm5hbWUgPT09IG5hbWUpXG4gICAgaWYoaW5wdXRzLmxlbmd0aCA9PT0gMCl7IGxvZ0Vycm9yKGBubyBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCkgfVxuICAgIGVsc2UgaWYoaW5wdXRzLmxlbmd0aCA+IDEpeyBsb2dFcnJvcihgZHVwbGljYXRlIGxpdmUgZmlsZSBpbnB1dHMgZm91bmQgbWF0Y2hpbmcgdGhlIG5hbWUgXCIke25hbWV9XCJgKSB9XG4gICAgZWxzZSB7IERPTS5kaXNwYXRjaEV2ZW50KGlucHV0c1swXSwgUEhYX1RSQUNLX1VQTE9BRFMsIHtkZXRhaWw6IHtmaWxlczogZmlsZXNPckJsb2JzfX0pIH1cbiAgfVxuXG4gIHB1c2hGb3JtUmVjb3ZlcnkoZm9ybSwgbmV3Q2lkLCBjYWxsYmFjayl7XG4gICAgdGhpcy5saXZlU29ja2V0LndpdGhpbk93bmVycyhmb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICBsZXQgaW5wdXQgPSBmb3JtLmVsZW1lbnRzWzBdXG4gICAgICBsZXQgcGh4RXZlbnQgPSBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0FVVE9fUkVDT1ZFUikpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcImNoYW5nZVwiKSlcblxuICAgICAgSlMuZXhlYyhcImNoYW5nZVwiLCBwaHhFdmVudCwgdmlldywgaW5wdXQsIFtcInB1c2hcIiwge190YXJnZXQ6IGlucHV0Lm5hbWUsIG5ld0NpZDogbmV3Q2lkLCBjYWxsYmFjazogY2FsbGJhY2t9XSlcbiAgICB9KVxuICB9XG5cbiAgcHVzaExpbmtQYXRjaChocmVmLCB0YXJnZXRFbCwgY2FsbGJhY2spe1xuICAgIGxldCBsaW5rUmVmID0gdGhpcy5saXZlU29ja2V0LnNldFBlbmRpbmdMaW5rKGhyZWYpXG4gICAgbGV0IHJlZkdlbiA9IHRhcmdldEVsID8gKCkgPT4gdGhpcy5wdXRSZWYoW3RhcmdldEVsXSwgXCJjbGlja1wiKSA6IG51bGxcbiAgICBsZXQgZmFsbGJhY2sgPSAoKSA9PiB0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3Qod2luZG93LmxvY2F0aW9uLmhyZWYpXG5cbiAgICBsZXQgcHVzaCA9IHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW4sIFwibGl2ZV9wYXRjaFwiLCB7dXJsOiBocmVmfSwgcmVzcCA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmKHJlc3AubGlua19yZWRpcmVjdCl7XG4gICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcGxhY2VNYWluKGhyZWYsIG51bGwsIGNhbGxiYWNrLCBsaW5rUmVmKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKHRoaXMubGl2ZVNvY2tldC5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSl7XG4gICAgICAgICAgICB0aGlzLmhyZWYgPSBocmVmXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpXG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobGlua1JlZilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYocHVzaCl7XG4gICAgICBwdXNoLnJlY2VpdmUoXCJ0aW1lb3V0XCIsIGZhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBmYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgZm9ybXNGb3JSZWNvdmVyeShodG1sKXtcbiAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gMCl7IHJldHVybiBbXSB9XG5cbiAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuXG4gICAgcmV0dXJuIChcbiAgICAgIERPTS5hbGwodGhpcy5lbCwgYGZvcm1bJHtwaHhDaGFuZ2V9XWApXG4gICAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmlkICYmIHRoaXMub3duc0VsZW1lbnQoZm9ybSkpXG4gICAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmVsZW1lbnRzLmxlbmd0aCA+IDApXG4gICAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0FVVE9fUkVDT1ZFUikpICE9PSBcImlnbm9yZVwiKVxuICAgICAgICAubWFwKGZvcm0gPT4ge1xuICAgICAgICAgIGxldCBuZXdGb3JtID0gdGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yKGBmb3JtW2lkPVwiJHtmb3JtLmlkfVwiXVske3BoeENoYW5nZX09XCIke2Zvcm0uZ2V0QXR0cmlidXRlKHBoeENoYW5nZSl9XCJdYClcbiAgICAgICAgICBpZihuZXdGb3JtKXtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybSwgbmV3Rm9ybSwgdGhpcy50YXJnZXRDb21wb25lbnRJRChuZXdGb3JtKV1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtmb3JtLCBudWxsLCBudWxsXVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmZpbHRlcigoW2Zvcm0sIG5ld0Zvcm0sIG5ld0NpZF0pID0+IG5ld0Zvcm0pXG4gICAgKVxuICB9XG5cbiAgbWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChkZXN0cm95ZWRDSURzKXtcbiAgICBsZXQgd2lsbERlc3Ryb3lDSURzID0gZGVzdHJveWVkQ0lEcy5maWx0ZXIoY2lkID0+IHtcbiAgICAgIHJldHVybiBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsIGNpZCkubGVuZ3RoID09PSAwXG4gICAgfSlcbiAgICBpZih3aWxsRGVzdHJveUNJRHMubGVuZ3RoID4gMCl7XG4gICAgICB0aGlzLnBydW5pbmdDSURzLnB1c2goLi4ud2lsbERlc3Ryb3lDSURzKVxuXG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJjaWRzX3dpbGxfZGVzdHJveVwiLCB7Y2lkczogd2lsbERlc3Ryb3lDSURzfSwgKCkgPT4ge1xuICAgICAgICAvLyBUaGUgY2lkcyBhcmUgZWl0aGVyIGJhY2sgb24gdGhlIHBhZ2Ugb3IgdGhleSB3aWxsIGJlIGZ1bGx5IHJlbW92ZWQsXG4gICAgICAgIC8vIHNvIHdlIGNhbiByZW1vdmUgdGhlbSBmcm9tIHRoZSBwcnVuaW5nQ0lEcy5cbiAgICAgICAgdGhpcy5wcnVuaW5nQ0lEcyA9IHRoaXMucHJ1bmluZ0NJRHMuZmlsdGVyKGNpZCA9PiB3aWxsRGVzdHJveUNJRHMuaW5kZXhPZihjaWQpICE9PSAtMSlcblxuICAgICAgICAvLyBTZWUgaWYgYW55IG9mIHRoZSBjaWRzIHdlIHdhbnRlZCB0byBkZXN0cm95IHdlcmUgYWRkZWQgYmFjayxcbiAgICAgICAgLy8gaWYgdGhleSB3ZXJlIGFkZGVkIGJhY2ssIHdlIGRvbid0IGFjdHVhbGx5IGRlc3Ryb3kgdGhlbS5cbiAgICAgICAgbGV0IGNvbXBsZXRlbHlEZXN0cm95Q0lEcyA9IHdpbGxEZXN0cm95Q0lEcy5maWx0ZXIoY2lkID0+IHtcbiAgICAgICAgICByZXR1cm4gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBjaWQpLmxlbmd0aCA9PT0gMFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmKGNvbXBsZXRlbHlEZXN0cm95Q0lEcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJjaWRzX2Rlc3Ryb3llZFwiLCB7Y2lkczogY29tcGxldGVseURlc3Ryb3lDSURzfSwgKHJlc3ApID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWQucHJ1bmVDSURzKHJlc3AuY2lkcylcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIG93bnNFbGVtZW50KGVsKXtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpID09PSB0aGlzLmlkIHx8XG4gICAgICBtYXliZShlbC5jbG9zZXN0KFBIWF9WSUVXX1NFTEVDVE9SKSwgbm9kZSA9PiBub2RlLmlkKSA9PT0gdGhpcy5pZFxuICB9XG5cbiAgc3VibWl0Rm9ybShmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzID0ge30pe1xuICAgIERPTS5wdXRQcml2YXRlKGZvcm0sIFBIWF9IQVNfU1VCTUlUVEVELCB0cnVlKVxuICAgIGxldCBwaHhGZWVkYmFjayA9IHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9GRUVEQkFDS19GT1IpXG4gICAgbGV0IGlucHV0cyA9IEFycmF5LmZyb20oZm9ybS5lbGVtZW50cylcbiAgICB0aGlzLmxpdmVTb2NrZXQuYmx1ckFjdGl2ZUVsZW1lbnQodGhpcylcbiAgICB0aGlzLnB1c2hGb3JtU3VibWl0KGZvcm0sIHRhcmdldEN0eCwgcGh4RXZlbnQsIG9wdHMsICgpID0+IHtcbiAgICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IERPTS5zaG93RXJyb3IoaW5wdXQsIHBoeEZlZWRiYWNrKSlcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKClcbiAgICB9KVxuICB9XG5cbiAgYmluZGluZyhraW5kKXsgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKGtpbmQpIH1cbn1cbiIsICIvKiogSW5pdGlhbGl6ZXMgdGhlIExpdmVTb2NrZXRcbiAqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuZFBvaW50IC0gVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBgXCJ3c3M6Ly9leGFtcGxlLmNvbS9saXZlXCJgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIi9saXZlXCJgIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICogQHBhcmFtIHtQaG9lbml4LlNvY2tldH0gc29ja2V0IC0gdGhlIHJlcXVpcmVkIFBob2VuaXggU29ja2V0IGNsYXNzIGltcG9ydGVkIGZyb20gXCJwaG9lbml4XCIuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuICogICAgIGltcG9ydCB7TGl2ZVNvY2tldH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcbiAqICAgICBsZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7Li4ufSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbi4gT3V0c2lkZSBvZiBrZXlzIGxpc3RlZCBiZWxvdywgYWxsXG4gKiBjb25maWd1cmF0aW9uIGlzIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgUGhvZW5peCBTb2NrZXQgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMuZGVmYXVsdHNdIC0gVGhlIG9wdGlvbmFsIGRlZmF1bHRzIHRvIHVzZSBmb3IgdmFyaW91cyBiaW5kaW5ncyxcbiAqIHN1Y2ggYXMgYHBoeC1kZWJvdW5jZWAuIFN1cHBvcnRzIHRoZSBmb2xsb3dpbmcga2V5czpcbiAqXG4gKiAgIC0gZGVib3VuY2UgLSB0aGUgbWlsbGlzZWNvbmQgcGh4LWRlYm91bmNlIHRpbWUuIERlZmF1bHRzIDMwMFxuICogICAtIHRocm90dGxlIC0gdGhlIG1pbGxpc2Vjb25kIHBoeC10aHJvdHRsZSB0aW1lLiBEZWZhdWx0cyAzMDBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5wYXJhbXNdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBwYXNzaW5nIGNvbm5lY3QgcGFyYW1zLlxuICogVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIExpdmVWaWV3LiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgKGVsKSA9PiB7dmlldzogZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1teS12aWV3LW5hbWVcIiwgdG9rZW46IHdpbmRvdy5teVRva2VufVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iaW5kaW5nUHJlZml4XSAtIFRoZSBvcHRpb25hbCBwcmVmaXggdG8gdXNlIGZvciBhbGwgcGh4IERPTSBhbm5vdGF0aW9ucy5cbiAqIERlZmF1bHRzIHRvIFwicGh4LVwiLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmhvb2tzXSAtIFRoZSBvcHRpb25hbCBvYmplY3QgZm9yIHJlZmVyZW5jaW5nIExpdmVWaWV3IGhvb2sgY2FsbGJhY2tzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnVwbG9hZGVyc10gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IGZvciByZWZlcmVuY2luZyBMaXZlVmlldyB1cGxvYWRlciBjYWxsYmFja3MuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLmxvYWRlclRpbWVvdXRdIC0gVGhlIG9wdGlvbmFsIGRlbGF5IGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhcHBseVxuICogbG9hZGluZyBzdGF0ZXMuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLm1heFJlbG9hZHNdIC0gVGhlIG1heGltdW0gcmVsb2FkcyBiZWZvcmUgZW50ZXJpbmcgZmFpbHNhZmUgbW9kZS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMucmVsb2FkSml0dGVyTWluXSAtIFRoZSBtaW5pbXVtIHRpbWUgYmV0d2VlbiBub3JtYWwgcmVsb2FkIGF0dGVtcHRzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5yZWxvYWRKaXR0ZXJNYXhdIC0gVGhlIG1heGltdW0gdGltZSBiZXR3ZWVuIG5vcm1hbCByZWxvYWQgYXR0ZW1wdHMuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLmZhaWxzYWZlSml0dGVyXSAtIFRoZSB0aW1lIGJldHdlZW4gcmVsb2FkIGF0dGVtcHRzIGluIGZhaWxzYWZlIG1vZGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy52aWV3TG9nZ2VyXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0byBsb2cgZGVidWcgaW5mb3JtYXRpb24uIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAodmlldywga2luZCwgbXNnLCBvYmopID0+IGNvbnNvbGUubG9nKGAke3ZpZXcuaWR9ICR7a2luZH06ICR7bXNnfSAtIGAsIG9iailcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubWV0YWRhdGFdIC0gVGhlIG9wdGlvbmFsIG9iamVjdCBtYXBwaW5nIGV2ZW50IG5hbWVzIHRvIGZ1bmN0aW9ucyBmb3JcbiAqIHBvcHVsYXRpbmcgZXZlbnQgbWV0YWRhdGEuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBtZXRhZGF0YToge1xuICogICAgICAgY2xpY2s6IChlLCBlbCkgPT4ge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAqICAgICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gKiAgICAgICAgICAgZGV0YWlsOiBlLmRldGFpbCB8fCAxLFxuICogICAgICAgICB9XG4gKiAgICAgICB9LFxuICogICAgICAga2V5ZG93bjogKGUsIGVsKSA9PiB7XG4gKiAgICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgICAga2V5OiBlLmtleSxcbiAqICAgICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gKiAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICogICAgICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMuc2Vzc2lvblN0b3JhZ2VdIC0gQW4gb3B0aW9uYWwgU3RvcmFnZSBjb21wYXRpYmxlIG9iamVjdFxuICogVXNlZnVsIHdoZW4gTGl2ZVZpZXcgd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gYHNlc3Npb25TdG9yYWdlYC4gIEZvciBleGFtcGxlLCBUaGlzIGNvdWxkXG4gKiBoYXBwZW4gaWYgYSBzaXRlIGxvYWRzIGEgY3Jvc3MtZG9tYWluIExpdmVWaWV3IGluIGFuIGlmcmFtZS4gIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICAgIGNsYXNzIEluTWVtb3J5U3RvcmFnZSB7XG4gKiAgICAgICBjb25zdHJ1Y3RvcigpIHsgdGhpcy5zdG9yYWdlID0ge30gfVxuICogICAgICAgZ2V0SXRlbShrZXlOYW1lKSB7IHJldHVybiB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfVxuICogICAgICAgcmVtb3ZlSXRlbShrZXlOYW1lKSB7IGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfVxuICogICAgICAgc2V0SXRlbShrZXlOYW1lLCBrZXlWYWx1ZSkgeyB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gPSBrZXlWYWx1ZSB9XG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5sb2NhbFN0b3JhZ2VdIC0gQW4gb3B0aW9uYWwgU3RvcmFnZSBjb21wYXRpYmxlIG9iamVjdFxuICogVXNlZnVsIGZvciB3aGVuIExpdmVWaWV3IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBsb2NhbFN0b3JhZ2VgLlxuICogU2VlIGBvcHRzLnNlc3Npb25TdG9yYWdlYCBmb3IgZXhhbXBsZXMuXG4qL1xuXG5pbXBvcnQge1xuICBCSU5ESU5HX1BSRUZJWCxcbiAgQ09OU0VDVVRJVkVfUkVMT0FEUyxcbiAgREVGQVVMVFMsXG4gIEZBSUxTQUZFX0pJVFRFUixcbiAgTE9BREVSX1RJTUVPVVQsXG4gIE1BWF9SRUxPQURTLFxuICBQSFhfREVCT1VOQ0UsXG4gIFBIWF9EUk9QX1RBUkdFVCxcbiAgUEhYX0hBU19GT0NVU0VELFxuICBQSFhfS0VZLFxuICBQSFhfTElOS19TVEFURSxcbiAgUEhYX0xJVkVfTElOSyxcbiAgUEhYX0xWX0RFQlVHLFxuICBQSFhfTFZfTEFURU5DWV9TSU0sXG4gIFBIWF9MVl9QUk9GSUxFLFxuICBQSFhfTUFJTixcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfVEhST1RUTEUsXG4gIFBIWF9UUkFDS19VUExPQURTLFxuICBQSFhfU0VTU0lPTixcbiAgUkVMT0FEX0pJVFRFUl9NSU4sXG4gIFJFTE9BRF9KSVRURVJfTUFYLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9uZSxcbiAgY2xvc2VzdFBoeEJpbmRpbmcsXG4gIGNsb3N1cmUsXG4gIGRlYnVnLFxuICBpc09iamVjdCxcbiAgbWF5YmVcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQnJvd3NlciBmcm9tIFwiLi9icm93c2VyXCJcbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBIb29rcyBmcm9tIFwiLi9ob29rc1wiXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuaW1wb3J0IFZpZXcgZnJvbSBcIi4vdmlld1wiXG5pbXBvcnQgSlMgZnJvbSBcIi4vanNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXZlU29ja2V0IHtcbiAgY29uc3RydWN0b3IodXJsLCBwaHhTb2NrZXQsIG9wdHMgPSB7fSl7XG4gICAgdGhpcy51bmxvYWRlZCA9IGZhbHNlXG4gICAgaWYoIXBoeFNvY2tldCB8fCBwaHhTb2NrZXQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIil7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgYSBwaG9lbml4IFNvY2tldCBtdXN0IGJlIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIExpdmVTb2NrZXQgY29uc3RydWN0b3IuIEZvciBleGFtcGxlOlxuXG4gICAgICAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAgICAgICAgICBpbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG4gICAgICAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXG4gICAgICBgKVxuICAgIH1cbiAgICB0aGlzLnNvY2tldCA9IG5ldyBwaHhTb2NrZXQodXJsLCBvcHRzKVxuICAgIHRoaXMuYmluZGluZ1ByZWZpeCA9IG9wdHMuYmluZGluZ1ByZWZpeCB8fCBCSU5ESU5HX1BSRUZJWFxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pXG4gICAgdGhpcy52aWV3TG9nZ2VyID0gb3B0cy52aWV3TG9nZ2VyXG4gICAgdGhpcy5tZXRhZGF0YUNhbGxiYWNrcyA9IG9wdHMubWV0YWRhdGEgfHwge31cbiAgICB0aGlzLmRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihjbG9uZShERUZBVUxUUyksIG9wdHMuZGVmYXVsdHMgfHwge30pXG4gICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gbnVsbFxuICAgIHRoaXMucHJldkFjdGl2ZSA9IG51bGxcbiAgICB0aGlzLnNpbGVuY2VkID0gZmFsc2VcbiAgICB0aGlzLm1haW4gPSBudWxsXG4gICAgdGhpcy5vdXRnb2luZ01haW5FbCA9IG51bGxcbiAgICB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gbnVsbFxuICAgIHRoaXMubGlua1JlZiA9IDFcbiAgICB0aGlzLnJvb3RzID0ge31cbiAgICB0aGlzLmhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgIHRoaXMucGVuZGluZ0xpbmsgPSBudWxsXG4gICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZSh3aW5kb3cubG9jYXRpb24pXG4gICAgdGhpcy5ob29rcyA9IG9wdHMuaG9va3MgfHwge31cbiAgICB0aGlzLnVwbG9hZGVycyA9IG9wdHMudXBsb2FkZXJzIHx8IHt9XG4gICAgdGhpcy5sb2FkZXJUaW1lb3V0ID0gb3B0cy5sb2FkZXJUaW1lb3V0IHx8IExPQURFUl9USU1FT1VUXG4gICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIgPSBudWxsXG4gICAgdGhpcy5tYXhSZWxvYWRzID0gb3B0cy5tYXhSZWxvYWRzIHx8IE1BWF9SRUxPQURTXG4gICAgdGhpcy5yZWxvYWRKaXR0ZXJNaW4gPSBvcHRzLnJlbG9hZEppdHRlck1pbiB8fCBSRUxPQURfSklUVEVSX01JTlxuICAgIHRoaXMucmVsb2FkSml0dGVyTWF4ID0gb3B0cy5yZWxvYWRKaXR0ZXJNYXggfHwgUkVMT0FEX0pJVFRFUl9NQVhcbiAgICB0aGlzLmZhaWxzYWZlSml0dGVyID0gb3B0cy5mYWlsc2FmZUppdHRlciB8fCBGQUlMU0FGRV9KSVRURVJcbiAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IG9wdHMubG9jYWxTdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2VcbiAgICB0aGlzLnNlc3Npb25TdG9yYWdlID0gb3B0cy5zZXNzaW9uU3RvcmFnZSB8fCB3aW5kb3cuc2Vzc2lvblN0b3JhZ2VcbiAgICB0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMgPSBmYWxzZVxuICAgIHRoaXMuZG9tQ2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbih7b25Ob2RlQWRkZWQ6IGNsb3N1cmUoKSwgb25CZWZvcmVFbFVwZGF0ZWQ6IGNsb3N1cmUoKX0sIG9wdHMuZG9tIHx8IHt9KVxuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgVHJhbnNpdGlvblNldCgpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfZSA9PiB7XG4gICAgICB0aGlzLnVubG9hZGVkID0gdHJ1ZVxuICAgIH0pXG4gICAgdGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuaXNVbmxvYWRlZCgpKXtcbiAgICAgICAgLy8gcmVsb2FkIHBhZ2UgaWYgYmVpbmcgcmVzdG9yZWQgZnJvbSBiYWNrL2ZvcndhcmQgY2FjaGUgYW5kIGJyb3dzZXIgZG9lcyBub3QgZW1pdCBcInBhZ2VzaG93XCJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIHB1YmxpY1xuXG4gIGlzUHJvZmlsZUVuYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfUFJPRklMRSkgPT09IFwidHJ1ZVwiIH1cblxuICBpc0RlYnVnRW5hYmxlZCgpeyByZXR1cm4gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9ERUJVRykgPT09IFwidHJ1ZVwiIH1cblxuICBpc0RlYnVnRGlzYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfREVCVUcpID09PSBcImZhbHNlXCIgfVxuXG4gIGVuYWJsZURlYnVnKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwidHJ1ZVwiKSB9XG5cbiAgZW5hYmxlUHJvZmlsaW5nKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfUFJPRklMRSwgXCJ0cnVlXCIpIH1cblxuICBkaXNhYmxlRGVidWcoKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ERUJVRywgXCJmYWxzZVwiKSB9XG5cbiAgZGlzYWJsZVByb2ZpbGluZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEhYX0xWX1BST0ZJTEUpIH1cblxuICBlbmFibGVMYXRlbmN5U2ltKHVwcGVyQm91bmRNcyl7XG4gICAgdGhpcy5lbmFibGVEZWJ1ZygpXG4gICAgY29uc29sZS5sb2coXCJsYXRlbmN5IHNpbXVsYXRvciBlbmFibGVkIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBicm93c2VyIHNlc3Npb24uIENhbGwgZGlzYWJsZUxhdGVuY3lTaW0oKSB0byBkaXNhYmxlXCIpXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSwgdXBwZXJCb3VuZE1zKVxuICB9XG5cbiAgZGlzYWJsZUxhdGVuY3lTaW0oKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSkgfVxuXG4gIGdldExhdGVuY3lTaW0oKXtcbiAgICBsZXQgc3RyID0gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSlcbiAgICByZXR1cm4gc3RyID8gcGFyc2VJbnQoc3RyKSA6IG51bGxcbiAgfVxuXG4gIGdldFNvY2tldCgpeyByZXR1cm4gdGhpcy5zb2NrZXQgfVxuXG4gIGNvbm5lY3QoKXtcbiAgICAvLyBlbmFibGUgZGVidWcgYnkgZGVmYXVsdCBpZiBvbiBsb2NhbGhvc3QgYW5kIG5vdCBleHBsaWNpdGx5IGRpc2FibGVkXG4gICAgaWYod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09PSBcImxvY2FsaG9zdFwiICYmICF0aGlzLmlzRGVidWdEaXNhYmxlZCgpKXsgdGhpcy5lbmFibGVEZWJ1ZygpIH1cbiAgICBsZXQgZG9Db25uZWN0ID0gKCkgPT4ge1xuICAgICAgaWYodGhpcy5qb2luUm9vdFZpZXdzKCkpe1xuICAgICAgICB0aGlzLmJpbmRUb3BMZXZlbEV2ZW50cygpXG4gICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKVxuICAgICAgfSBlbHNlIGlmKHRoaXMubWFpbil7XG4gICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihbXCJjb21wbGV0ZVwiLCBcImxvYWRlZFwiLCBcImludGVyYWN0aXZlXCJdLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSkgPj0gMCl7XG4gICAgICBkb0Nvbm5lY3QoKVxuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiBkb0Nvbm5lY3QoKSlcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0KGNhbGxiYWNrKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIpXG4gICAgdGhpcy5zb2NrZXQuZGlzY29ubmVjdChjYWxsYmFjaylcbiAgfVxuXG4gIHJlcGxhY2VUcmFuc3BvcnQodHJhbnNwb3J0KXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIpXG4gICAgdGhpcy5zb2NrZXQucmVwbGFjZVRyYW5zcG9ydCh0cmFuc3BvcnQpXG4gICAgdGhpcy5jb25uZWN0KClcbiAgfVxuXG4gIGV4ZWNKUyhlbCwgZW5jb2RlZEpTLCBldmVudFR5cGUgPSBudWxsKXtcbiAgICB0aGlzLm93bmVyKGVsLCB2aWV3ID0+IEpTLmV4ZWMoZXZlbnRUeXBlLCBlbmNvZGVkSlMsIHZpZXcsIGVsKSlcbiAgfVxuXG4gIC8vIHByaXZhdGVcblxuICB0cmlnZ2VyRE9NKGtpbmQsIGFyZ3MpeyB0aGlzLmRvbUNhbGxiYWNrc1traW5kXSguLi5hcmdzKSB9XG5cbiAgdGltZShuYW1lLCBmdW5jKXtcbiAgICBpZighdGhpcy5pc1Byb2ZpbGVFbmFibGVkKCkgfHwgIWNvbnNvbGUudGltZSl7IHJldHVybiBmdW5jKCkgfVxuICAgIGNvbnNvbGUudGltZShuYW1lKVxuICAgIGxldCByZXN1bHQgPSBmdW5jKClcbiAgICBjb25zb2xlLnRpbWVFbmQobmFtZSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBsb2codmlldywga2luZCwgbXNnQ2FsbGJhY2spe1xuICAgIGlmKHRoaXMudmlld0xvZ2dlcil7XG4gICAgICBsZXQgW21zZywgb2JqXSA9IG1zZ0NhbGxiYWNrKClcbiAgICAgIHRoaXMudmlld0xvZ2dlcih2aWV3LCBraW5kLCBtc2csIG9iailcbiAgICB9IGVsc2UgaWYodGhpcy5pc0RlYnVnRW5hYmxlZCgpKXtcbiAgICAgIGxldCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKVxuICAgICAgZGVidWcodmlldywga2luZCwgbXNnLCBvYmopXG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdERPTVVwZGF0ZShjYWxsYmFjayl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZnRlcihjYWxsYmFjaylcbiAgfVxuXG4gIHRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lID0gZnVuY3Rpb24oKXt9KXtcbiAgICB0aGlzLnRyYW5zaXRpb25zLmFkZFRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKVxuICB9XG5cbiAgb25DaGFubmVsKGNoYW5uZWwsIGV2ZW50LCBjYil7XG4gICAgY2hhbm5lbC5vbihldmVudCwgZGF0YSA9PiB7XG4gICAgICBsZXQgbGF0ZW5jeSA9IHRoaXMuZ2V0TGF0ZW5jeVNpbSgpXG4gICAgICBpZighbGF0ZW5jeSl7XG4gICAgICAgIGNiKGRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgc2ltdWxhdGluZyAke2xhdGVuY3l9bXMgb2YgbGF0ZW5jeSBmcm9tIHNlcnZlciB0byBjbGllbnRgKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGNiKGRhdGEpLCBsYXRlbmN5KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB3cmFwUHVzaCh2aWV3LCBvcHRzLCBwdXNoKXtcbiAgICBsZXQgbGF0ZW5jeSA9IHRoaXMuZ2V0TGF0ZW5jeVNpbSgpXG4gICAgbGV0IG9sZEpvaW5Db3VudCA9IHZpZXcuam9pbkNvdW50XG4gICAgaWYoIWxhdGVuY3kpe1xuICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpICYmIG9wdHMudGltZW91dCl7XG4gICAgICAgIHJldHVybiBwdXNoKCkucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICAgIGlmKHZpZXcuam9pbkNvdW50ID09PSBvbGRKb2luQ291bnQgJiYgIXZpZXcuaXNEZXN0cm95ZWQoKSl7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXIodmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZyh2aWV3LCBcInRpbWVvdXRcIiwgKCkgPT4gW1wicmVjZWl2ZWQgdGltZW91dCB3aGlsZSBjb21tdW5pY2F0aW5nIHdpdGggc2VydmVyLiBGYWxsaW5nIGJhY2sgdG8gaGFyZCByZWZyZXNoIGZvciByZWNvdmVyeVwiXSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHB1c2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBzaW11bGF0aW5nICR7bGF0ZW5jeX1tcyBvZiBsYXRlbmN5IGZyb20gY2xpZW50IHRvIHNlcnZlcmApXG4gICAgbGV0IGZha2VQdXNoID0ge1xuICAgICAgcmVjZWl2ZXM6IFtdLFxuICAgICAgcmVjZWl2ZShraW5kLCBjYil7IHRoaXMucmVjZWl2ZXMucHVzaChba2luZCwgY2JdKSB9XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYodmlldy5pc0Rlc3Ryb3llZCgpKXsgcmV0dXJuIH1cbiAgICAgIGZha2VQdXNoLnJlY2VpdmVzLnJlZHVjZSgoYWNjLCBba2luZCwgY2JdKSA9PiBhY2MucmVjZWl2ZShraW5kLCBjYiksIHB1c2goKSlcbiAgICB9LCBsYXRlbmN5KVxuICAgIHJldHVybiBmYWtlUHVzaFxuICB9XG5cbiAgcmVsb2FkV2l0aEppdHRlcih2aWV3LCBsb2cpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lcilcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIGxldCBtaW5NcyA9IHRoaXMucmVsb2FkSml0dGVyTWluXG4gICAgbGV0IG1heE1zID0gdGhpcy5yZWxvYWRKaXR0ZXJNYXhcbiAgICBsZXQgYWZ0ZXJNcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXhNcyAtIG1pbk1zICsgMSkpICsgbWluTXNcbiAgICBsZXQgdHJpZXMgPSBCcm93c2VyLnVwZGF0ZUxvY2FsKHRoaXMubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMsIDAsIGNvdW50ID0+IGNvdW50ICsgMSlcbiAgICBpZih0cmllcyA+IHRoaXMubWF4UmVsb2Fkcyl7XG4gICAgICBhZnRlck1zID0gdGhpcy5mYWlsc2FmZUppdHRlclxuICAgIH1cbiAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gaWYgdmlldyBoYXMgcmVjb3ZlcmVkLCBzdWNoIGFzIHRyYW5zcG9ydCByZXBsYWNlZCwgdGhlbiBjYW5jZWxcbiAgICAgIGlmKHZpZXcuaXNEZXN0cm95ZWQoKSB8fCB2aWV3LmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuICAgICAgdmlldy5kZXN0cm95KClcbiAgICAgIGxvZyA/IGxvZygpIDogdGhpcy5sb2codmlldywgXCJqb2luXCIsICgpID0+IFtgZW5jb3VudGVyZWQgJHt0cmllc30gY29uc2VjdXRpdmUgcmVsb2Fkc2BdKVxuICAgICAgaWYodHJpZXMgPiB0aGlzLm1heFJlbG9hZHMpe1xuICAgICAgICB0aGlzLmxvZyh2aWV3LCBcImpvaW5cIiwgKCkgPT4gW2BleGNlZWRlZCAke3RoaXMubWF4UmVsb2Fkc30gY29uc2VjdXRpdmUgcmVsb2Fkcy4gRW50ZXJpbmcgZmFpbHNhZmUgbW9kZWBdKVxuICAgICAgfVxuICAgICAgaWYodGhpcy5oYXNQZW5kaW5nTGluaygpKXtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gdGhpcy5wZW5kaW5nTGlua1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgfSwgYWZ0ZXJNcylcbiAgfVxuXG4gIGdldEhvb2tDYWxsYmFja3MobmFtZSl7XG4gICAgcmV0dXJuIG5hbWUgJiYgbmFtZS5zdGFydHNXaXRoKFwiUGhvZW5peC5cIikgPyBIb29rc1tuYW1lLnNwbGl0KFwiLlwiKVsxXV0gOiB0aGlzLmhvb2tzW25hbWVdXG4gIH1cblxuICBpc1VubG9hZGVkKCl7IHJldHVybiB0aGlzLnVubG9hZGVkIH1cblxuICBpc0Nvbm5lY3RlZCgpeyByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSB9XG5cbiAgZ2V0QmluZGluZ1ByZWZpeCgpeyByZXR1cm4gdGhpcy5iaW5kaW5nUHJlZml4IH1cblxuICBiaW5kaW5nKGtpbmQpeyByZXR1cm4gYCR7dGhpcy5nZXRCaW5kaW5nUHJlZml4KCl9JHtraW5kfWAgfVxuXG4gIGNoYW5uZWwodG9waWMsIHBhcmFtcyl7IHJldHVybiB0aGlzLnNvY2tldC5jaGFubmVsKHRvcGljLCBwYXJhbXMpIH1cblxuICBqb2luUm9vdFZpZXdzKCl7XG4gICAgbGV0IHJvb3RzRm91bmQgPSBmYWxzZVxuICAgIERPTS5hbGwoZG9jdW1lbnQsIGAke1BIWF9WSUVXX1NFTEVDVE9SfTpub3QoWyR7UEhYX1BBUkVOVF9JRH1dKWAsIHJvb3RFbCA9PiB7XG4gICAgICBpZighdGhpcy5nZXRSb290QnlJZChyb290RWwuaWQpKXtcbiAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5ld1Jvb3RWaWV3KHJvb3RFbClcbiAgICAgICAgdmlldy5zZXRIcmVmKHRoaXMuZ2V0SHJlZigpKVxuICAgICAgICB2aWV3LmpvaW4oKVxuICAgICAgICBpZihyb290RWwuaGFzQXR0cmlidXRlKFBIWF9NQUlOKSl7IHRoaXMubWFpbiA9IHZpZXcgfVxuICAgICAgfVxuICAgICAgcm9vdHNGb3VuZCA9IHRydWVcbiAgICB9KVxuICAgIHJldHVybiByb290c0ZvdW5kXG4gIH1cblxuICByZWRpcmVjdCh0bywgZmxhc2gpe1xuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgQnJvd3Nlci5yZWRpcmVjdCh0bywgZmxhc2gpXG4gIH1cblxuICByZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgY2FsbGJhY2sgPSBudWxsLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSl7XG4gICAgdGhpcy5vdXRnb2luZ01haW5FbCA9IHRoaXMub3V0Z29pbmdNYWluRWwgfHwgdGhpcy5tYWluLmVsXG4gICAgbGV0IG5ld01haW5FbCA9IERPTS5jbG9uZU5vZGUodGhpcy5vdXRnb2luZ01haW5FbCwgXCJcIilcbiAgICB0aGlzLm1haW4uc2hvd0xvYWRlcih0aGlzLmxvYWRlclRpbWVvdXQpXG4gICAgdGhpcy5tYWluLmRlc3Ryb3koKVxuXG4gICAgdGhpcy5tYWluID0gdGhpcy5uZXdSb290VmlldyhuZXdNYWluRWwsIGZsYXNoKVxuICAgIHRoaXMubWFpbi5zZXRSZWRpcmVjdChocmVmKVxuICAgIHRoaXMudHJhbnNpdGlvblJlbW92ZXMoKVxuICAgIHRoaXMubWFpbi5qb2luKChqb2luQ291bnQsIG9uRG9uZSkgPT4ge1xuICAgICAgaWYoam9pbkNvdW50ID09PSAxICYmIHRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpe1xuICAgICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIERPTS5maW5kUGh4U3RpY2t5KGRvY3VtZW50KS5mb3JFYWNoKGVsID0+IG5ld01haW5FbC5hcHBlbmRDaGlsZChlbCkpXG4gICAgICAgICAgdGhpcy5vdXRnb2luZ01haW5FbC5yZXBsYWNlV2l0aChuZXdNYWluRWwpXG4gICAgICAgICAgdGhpcy5vdXRnb2luZ01haW5FbCA9IG51bGxcbiAgICAgICAgICBjYWxsYmFjayAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spXG4gICAgICAgICAgb25Eb25lKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdHJhbnNpdGlvblJlbW92ZXMoZWxlbWVudHMpe1xuICAgIGxldCByZW1vdmVBdHRyID0gdGhpcy5iaW5kaW5nKFwicmVtb3ZlXCIpXG4gICAgZWxlbWVudHMgPSBlbGVtZW50cyB8fCBET00uYWxsKGRvY3VtZW50LCBgWyR7cmVtb3ZlQXR0cn1dYClcbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGlmKGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpKXsgLy8gc2tpcCBjaGlsZHJlbiBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgdGhpcy5leGVjSlMoZWwsIGVsLmdldEF0dHJpYnV0ZShyZW1vdmVBdHRyKSwgXCJyZW1vdmVcIilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaXNQaHhWaWV3KGVsKXsgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsIH1cblxuICBuZXdSb290VmlldyhlbCwgZmxhc2gpe1xuICAgIGxldCB2aWV3ID0gbmV3IFZpZXcoZWwsIHRoaXMsIG51bGwsIGZsYXNoKVxuICAgIHRoaXMucm9vdHNbdmlldy5pZF0gPSB2aWV3XG4gICAgcmV0dXJuIHZpZXdcbiAgfVxuXG4gIG93bmVyKGNoaWxkRWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgdmlldyA9IG1heWJlKGNoaWxkRWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIGVsID0+IHRoaXMuZ2V0Vmlld0J5RWwoZWwpKSB8fCB0aGlzLm1haW5cbiAgICBpZih2aWV3KXsgY2FsbGJhY2sodmlldykgfVxuICB9XG5cbiAgd2l0aGluT3duZXJzKGNoaWxkRWwsIGNhbGxiYWNrKXtcbiAgICB0aGlzLm93bmVyKGNoaWxkRWwsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgY2hpbGRFbCkpXG4gIH1cblxuICBnZXRWaWV3QnlFbChlbCl7XG4gICAgbGV0IHJvb3RJZCA9IGVsLmdldEF0dHJpYnV0ZShQSFhfUk9PVF9JRClcbiAgICByZXR1cm4gbWF5YmUodGhpcy5nZXRSb290QnlJZChyb290SWQpLCByb290ID0+IHJvb3QuZ2V0RGVzY2VuZGVudEJ5RWwoZWwpKVxuICB9XG5cbiAgZ2V0Um9vdEJ5SWQoaWQpeyByZXR1cm4gdGhpcy5yb290c1tpZF0gfVxuXG4gIGRlc3Ryb3lBbGxWaWV3cygpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy5yb290cyl7XG4gICAgICB0aGlzLnJvb3RzW2lkXS5kZXN0cm95KClcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW2lkXVxuICAgIH1cbiAgICB0aGlzLm1haW4gPSBudWxsXG4gIH1cblxuICBkZXN0cm95Vmlld0J5RWwoZWwpe1xuICAgIGxldCByb290ID0gdGhpcy5nZXRSb290QnlJZChlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpKVxuICAgIGlmKHJvb3QgJiYgcm9vdC5pZCA9PT0gZWwuaWQpe1xuICAgICAgcm9vdC5kZXN0cm95KClcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW3Jvb3QuaWRdXG4gICAgfSBlbHNlIGlmKHJvb3Qpe1xuICAgICAgcm9vdC5kZXN0cm95RGVzY2VuZGVudChlbC5pZClcbiAgICB9XG4gIH1cblxuICBzZXRBY3RpdmVFbGVtZW50KHRhcmdldCl7XG4gICAgaWYodGhpcy5hY3RpdmVFbGVtZW50ID09PSB0YXJnZXQpeyByZXR1cm4gfVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IHRhcmdldFxuICAgIGxldCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBpZih0YXJnZXQgPT09IHRoaXMuYWN0aXZlRWxlbWVudCl7IHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGwgfVxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMpXG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMpXG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBjYW5jZWwpXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBjYW5jZWwpXG4gIH1cblxuICBnZXRBY3RpdmVFbGVtZW50KCl7XG4gICAgaWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSl7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gYmUgbnVsbCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMVxuICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keVxuICAgIH1cbiAgfVxuXG4gIGRyb3BBY3RpdmVFbGVtZW50KHZpZXcpe1xuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAmJiB2aWV3Lm93bnNFbGVtZW50KHRoaXMucHJldkFjdGl2ZSkpe1xuICAgICAgdGhpcy5wcmV2QWN0aXZlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJlc3RvcmVQcmV2aW91c2x5QWN0aXZlRm9jdXMoKXtcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgJiYgdGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5KXtcbiAgICAgIHRoaXMucHJldkFjdGl2ZS5mb2N1cygpXG4gICAgfVxuICB9XG5cbiAgYmx1ckFjdGl2ZUVsZW1lbnQoKXtcbiAgICB0aGlzLnByZXZBY3RpdmUgPSB0aGlzLmdldEFjdGl2ZUVsZW1lbnQoKVxuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAhPT0gZG9jdW1lbnQuYm9keSl7IHRoaXMucHJldkFjdGl2ZS5ibHVyKCkgfVxuICB9XG5cbiAgYmluZFRvcExldmVsRXZlbnRzKCl7XG4gICAgaWYodGhpcy5ib3VuZFRvcExldmVsRXZlbnRzKXsgcmV0dXJuIH1cblxuICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IHRydWVcbiAgICAvLyBlbnRlciBmYWlsc2FmZSByZWxvYWQgaWYgc2VydmVyIGhhcyBnb25lIGF3YXkgaW50ZW50aW9uYWxseSwgc3VjaCBhcyBcImRpc2Nvbm5lY3RcIiBicm9hZGNhc3RcbiAgICB0aGlzLnNvY2tldC5vbkNsb3NlKGV2ZW50ID0+IHtcbiAgICAgIGlmKGV2ZW50ICYmIGV2ZW50LmNvZGUgPT09IDEwMDAgJiYgdGhpcy5tYWluKXtcbiAgICAgICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyKHRoaXMubWFpbilcbiAgICAgIH1cbiAgICB9KVxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpeyB9KSAvLyBlbnN1cmUgYWxsIGNsaWNrIGV2ZW50cyBidWJibGUgZm9yIG1vYmlsZSBTYWZhcmlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIGUgPT4ge1xuICAgICAgaWYoZS5wZXJzaXN0ZWQpeyAvLyByZWxvYWQgcGFnZSBpZiBiZWluZyByZXN0b3JlZCBmcm9tIGJhY2svZm9yd2FyZCBjYWNoZVxuICAgICAgICB0aGlzLmdldFNvY2tldCgpLmRpc2Nvbm5lY3QoKVxuICAgICAgICB0aGlzLndpdGhQYWdlTG9hZGluZyh7dG86IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBraW5kOiBcInJlZGlyZWN0XCJ9KVxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICB9LCB0cnVlKVxuICAgIHRoaXMuYmluZE5hdigpXG4gICAgdGhpcy5iaW5kQ2xpY2tzKClcbiAgICB0aGlzLmJpbmRGb3JtcygpXG4gICAgdGhpcy5iaW5kKHtrZXl1cDogXCJrZXl1cFwiLCBrZXlkb3duOiBcImtleWRvd25cIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIGV2ZW50VGFyZ2V0KSA9PiB7XG4gICAgICBsZXQgbWF0Y2hLZXkgPSB0YXJnZXRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9LRVkpKVxuICAgICAgbGV0IHByZXNzZWRLZXkgPSBlLmtleSAmJiBlLmtleS50b0xvd2VyQ2FzZSgpIC8vIGNocm9tZSBjbGlja2VkIGF1dG9jb21wbGV0ZXMgc2VuZCBhIGtleWRvd24gd2l0aG91dCBrZXlcbiAgICAgIGlmKG1hdGNoS2V5ICYmIG1hdGNoS2V5LnRvTG93ZXJDYXNlKCkgIT09IHByZXNzZWRLZXkpeyByZXR1cm4gfVxuXG4gICAgICBsZXQgZGF0YSA9IHtrZXk6IGUua2V5LCAuLi50aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbCl9XG4gICAgICBKUy5leGVjKHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgIH0pXG4gICAgdGhpcy5iaW5kKHtibHVyOiBcImZvY3Vzb3V0XCIsIGZvY3VzOiBcImZvY3VzaW5cIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIGV2ZW50VGFyZ2V0KSA9PiB7XG4gICAgICBpZighZXZlbnRUYXJnZXQpe1xuICAgICAgICBsZXQgZGF0YSA9IHtrZXk6IGUua2V5LCAuLi50aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbCl9XG4gICAgICAgIEpTLmV4ZWModHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHtkYXRhfV0pXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmJpbmQoe2JsdXI6IFwiYmx1clwiLCBmb2N1czogXCJmb2N1c1wifSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBwaHhUYXJnZXQpID0+IHtcbiAgICAgIC8vIGJsdXIgYW5kIGZvY3VzIGFyZSB0cmlnZ2VyZWQgb24gZG9jdW1lbnQgYW5kIHdpbmRvdy4gRGlzY2FyZCBvbmUgdG8gYXZvaWQgZHVwc1xuICAgICAgaWYocGh4VGFyZ2V0ID09PSBcIndpbmRvd1wiKXtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbClcbiAgICAgICAgSlMuZXhlYyh0eXBlLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0RWwsIFtcInB1c2hcIiwge2RhdGF9XSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgZSA9PiBlLnByZXZlbnREZWZhdWx0KCkpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBsZXQgZHJvcFRhcmdldElkID0gbWF5YmUoY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKSwgdHJ1ZVRhcmdldCA9PiB7XG4gICAgICAgIHJldHVybiB0cnVlVGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSlcbiAgICAgIH0pXG4gICAgICBsZXQgZHJvcFRhcmdldCA9IGRyb3BUYXJnZXRJZCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcm9wVGFyZ2V0SWQpXG4gICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGF0YVRyYW5zZmVyLmZpbGVzIHx8IFtdKVxuICAgICAgaWYoIWRyb3BUYXJnZXQgfHwgZHJvcFRhcmdldC5kaXNhYmxlZCB8fCBmaWxlcy5sZW5ndGggPT09IDAgfHwgIShkcm9wVGFyZ2V0LmZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpKXsgcmV0dXJuIH1cblxuICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXMoZHJvcFRhcmdldCwgZmlsZXMpXG4gICAgICBkcm9wVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIiwge2J1YmJsZXM6IHRydWV9KSlcbiAgICB9KVxuICAgIHRoaXMub24oUEhYX1RSQUNLX1VQTE9BRFMsIGUgPT4ge1xuICAgICAgbGV0IHVwbG9hZFRhcmdldCA9IGUudGFyZ2V0XG4gICAgICBpZighRE9NLmlzVXBsb2FkSW5wdXQodXBsb2FkVGFyZ2V0KSl7IHJldHVybiB9XG4gICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGV0YWlsLmZpbGVzIHx8IFtdKS5maWx0ZXIoZiA9PiBmIGluc3RhbmNlb2YgRmlsZSB8fCBmIGluc3RhbmNlb2YgQmxvYilcbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKHVwbG9hZFRhcmdldCwgZmlsZXMpXG4gICAgICB1cGxvYWRUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7YnViYmxlczogdHJ1ZX0pKVxuICAgIH0pXG4gIH1cblxuICBldmVudE1ldGEoZXZlbnROYW1lLCBlLCB0YXJnZXRFbCl7XG4gICAgbGV0IGNhbGxiYWNrID0gdGhpcy5tZXRhZGF0YUNhbGxiYWNrc1tldmVudE5hbWVdXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soZSwgdGFyZ2V0RWwpIDoge31cbiAgfVxuXG4gIHNldFBlbmRpbmdMaW5rKGhyZWYpe1xuICAgIHRoaXMubGlua1JlZisrXG4gICAgdGhpcy5wZW5kaW5nTGluayA9IGhyZWZcbiAgICByZXR1cm4gdGhpcy5saW5rUmVmXG4gIH1cblxuICBjb21taXRQZW5kaW5nTGluayhsaW5rUmVmKXtcbiAgICBpZih0aGlzLmxpbmtSZWYgIT09IGxpbmtSZWYpe1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaHJlZiA9IHRoaXMucGVuZGluZ0xpbmtcbiAgICAgIHRoaXMucGVuZGluZ0xpbmsgPSBudWxsXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGdldEhyZWYoKXsgcmV0dXJuIHRoaXMuaHJlZiB9XG5cbiAgaGFzUGVuZGluZ0xpbmsoKXsgcmV0dXJuICEhdGhpcy5wZW5kaW5nTGluayB9XG5cbiAgYmluZChldmVudHMsIGNhbGxiYWNrKXtcbiAgICBmb3IobGV0IGV2ZW50IGluIGV2ZW50cyl7XG4gICAgICBsZXQgYnJvd3NlckV2ZW50TmFtZSA9IGV2ZW50c1tldmVudF1cblxuICAgICAgdGhpcy5vbihicm93c2VyRXZlbnROYW1lLCBlID0+IHtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmcoZXZlbnQpXG4gICAgICAgIGxldCB3aW5kb3dCaW5kaW5nID0gdGhpcy5iaW5kaW5nKGB3aW5kb3ctJHtldmVudH1gKVxuICAgICAgICBsZXQgdGFyZ2V0UGh4RXZlbnQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgZS50YXJnZXQuZ2V0QXR0cmlidXRlKGJpbmRpbmcpXG4gICAgICAgIGlmKHRhcmdldFBoeEV2ZW50KXtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKGUudGFyZ2V0LCBlLCBicm93c2VyRXZlbnROYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGV2ZW50LCB2aWV3LCBlLnRhcmdldCwgdGFyZ2V0UGh4RXZlbnQsIG51bGwpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NLmFsbChkb2N1bWVudCwgYFske3dpbmRvd0JpbmRpbmd9XWAsIGVsID0+IHtcbiAgICAgICAgICAgIGxldCBwaHhFdmVudCA9IGVsLmdldEF0dHJpYnV0ZSh3aW5kb3dCaW5kaW5nKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZShlbCwgZSwgYnJvd3NlckV2ZW50TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlbCwgdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZXZlbnQsIHZpZXcsIGVsLCBwaHhFdmVudCwgXCJ3aW5kb3dcIilcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBiaW5kQ2xpY2tzKCl7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZSA9PiB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gZS50YXJnZXQpXG4gICAgdGhpcy5iaW5kQ2xpY2soXCJjbGlja1wiLCBcImNsaWNrXCIsIGZhbHNlKVxuICAgIHRoaXMuYmluZENsaWNrKFwibW91c2Vkb3duXCIsIFwiY2FwdHVyZS1jbGlja1wiLCB0cnVlKVxuICB9XG5cbiAgYmluZENsaWNrKGV2ZW50TmFtZSwgYmluZGluZ05hbWUsIGNhcHR1cmUpe1xuICAgIGxldCBjbGljayA9IHRoaXMuYmluZGluZyhiaW5kaW5nTmFtZSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGUgPT4ge1xuICAgICAgbGV0IHRhcmdldCA9IG51bGxcbiAgICAgIGlmKGNhcHR1cmUpe1xuICAgICAgICB0YXJnZXQgPSBlLnRhcmdldC5tYXRjaGVzKGBbJHtjbGlja31dYCkgPyBlLnRhcmdldCA6IGUudGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoYFske2NsaWNrfV1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCB8fCBlLnRhcmdldFxuICAgICAgICB0YXJnZXQgPSBjbG9zZXN0UGh4QmluZGluZyhjbGlja1N0YXJ0ZWRBdFRhcmdldCwgY2xpY2spXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hDbGlja0F3YXkoZSwgY2xpY2tTdGFydGVkQXRUYXJnZXQpXG4gICAgICAgIHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgPSBudWxsXG4gICAgICB9XG4gICAgICBsZXQgcGh4RXZlbnQgPSB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShjbGljaylcbiAgICAgIGlmKCFwaHhFdmVudCl7IHJldHVybiB9XG4gICAgICBpZih0YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIpeyBlLnByZXZlbnREZWZhdWx0KCkgfVxuXG4gICAgICB0aGlzLmRlYm91bmNlKHRhcmdldCwgZSwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMud2l0aGluT3duZXJzKHRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgICAgSlMuZXhlYyhcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXQsIFtcInB1c2hcIiwge2RhdGE6IHRoaXMuZXZlbnRNZXRhKFwiY2xpY2tcIiwgZSwgdGFyZ2V0KX1dKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9LCBjYXB0dXJlKVxuICB9XG5cbiAgZGlzcGF0Y2hDbGlja0F3YXkoZSwgY2xpY2tTdGFydGVkQXQpe1xuICAgIGxldCBwaHhDbGlja0F3YXkgPSB0aGlzLmJpbmRpbmcoXCJjbGljay1hd2F5XCIpXG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske3BoeENsaWNrQXdheX1dYCwgZWwgPT4ge1xuICAgICAgaWYoIShlbC5pc1NhbWVOb2RlKGNsaWNrU3RhcnRlZEF0KSB8fCBlbC5jb250YWlucyhjbGlja1N0YXJ0ZWRBdCkpKXtcbiAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgIGxldCBwaHhFdmVudCA9IGVsLmdldEF0dHJpYnV0ZShwaHhDbGlja0F3YXkpXG4gICAgICAgICAgaWYoSlMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICAgICAgICBKUy5leGVjKFwiY2xpY2tcIiwgcGh4RXZlbnQsIHZpZXcsIGVsLCBbXCJwdXNoXCIsIHtkYXRhOiB0aGlzLmV2ZW50TWV0YShcImNsaWNrXCIsIGUsIGUudGFyZ2V0KX1dKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYmluZE5hdigpe1xuICAgIGlmKCFCcm93c2VyLmNhblB1c2hTdGF0ZSgpKXsgcmV0dXJuIH1cbiAgICBpZihoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uKXsgaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCIgfVxuICAgIGxldCBzY3JvbGxUaW1lciA9IG51bGxcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBfZSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsVGltZXIpXG4gICAgICBzY3JvbGxUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBCcm93c2VyLnVwZGF0ZUN1cnJlbnRTdGF0ZShzdGF0ZSA9PiBPYmplY3QuYXNzaWduKHN0YXRlLCB7c2Nyb2xsOiB3aW5kb3cuc2Nyb2xsWX0pKVxuICAgICAgfSwgMTAwKVxuICAgIH0pXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBldmVudCA9PiB7XG4gICAgICBpZighdGhpcy5yZWdpc3Rlck5ld0xvY2F0aW9uKHdpbmRvdy5sb2NhdGlvbikpeyByZXR1cm4gfVxuICAgICAgbGV0IHt0eXBlLCBpZCwgcm9vdCwgc2Nyb2xsfSA9IGV2ZW50LnN0YXRlIHx8IHt9XG4gICAgICBsZXQgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG5cbiAgICAgIHRoaXMucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmKHRoaXMubWFpbi5pc0Nvbm5lY3RlZCgpICYmICh0eXBlID09PSBcInBhdGNoXCIgJiYgaWQgPT09IHRoaXMubWFpbi5pZCkpe1xuICAgICAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGhyZWYsIG51bGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZXBsYWNlTWFpbihocmVmLCBudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICBpZihyb290KXsgdGhpcy5yZXBsYWNlUm9vdEhpc3RvcnkoKSB9XG4gICAgICAgICAgICBpZih0eXBlb2Yoc2Nyb2xsKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzY3JvbGwpXG4gICAgICAgICAgICAgIH0sIDApIC8vIHRoZSBib2R5IG5lZWRzIHRvIHJlbmRlciBiZWZvcmUgd2Ugc2Nyb2xsLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSwgZmFsc2UpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlID0+IHtcbiAgICAgIGxldCB0YXJnZXQgPSBjbG9zZXN0UGh4QmluZGluZyhlLnRhcmdldCwgUEhYX0xJVkVfTElOSylcbiAgICAgIGxldCB0eXBlID0gdGFyZ2V0ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoUEhYX0xJVkVfTElOSylcbiAgICAgIGxldCB3YW50c05ld1RhYiA9IGUubWV0YUtleSB8fCBlLmN0cmxLZXkgfHwgZS5idXR0b24gPT09IDFcbiAgICAgIGlmKCF0eXBlIHx8ICF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMubWFpbiB8fCB3YW50c05ld1RhYil7IHJldHVybiB9XG5cbiAgICAgIGxldCBocmVmID0gdGFyZ2V0LmhyZWZcbiAgICAgIGxldCBsaW5rU3RhdGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSU5LX1NUQVRFKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIC8vIGRvIG5vdCBidWJibGUgY2xpY2sgdG8gcmVndWxhciBwaHgtY2xpY2sgYmluZGluZ3NcbiAgICAgIGlmKHRoaXMucGVuZGluZ0xpbmsgPT09IGhyZWYpeyByZXR1cm4gfVxuXG4gICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZih0eXBlID09PSBcInBhdGNoXCIpe1xuICAgICAgICAgIHRoaXMucHVzaEhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIHRhcmdldClcbiAgICAgICAgfSBlbHNlIGlmKHR5cGUgPT09IFwicmVkaXJlY3RcIil7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5UmVkaXJlY3QoaHJlZiwgbGlua1N0YXRlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHtQSFhfTElWRV9MSU5LfSB0byBiZSBcInBhdGNoXCIgb3IgXCJyZWRpcmVjdFwiLCBnb3Q6ICR7dHlwZX1gKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICB9XG5cbiAgZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9KXtcbiAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIGBwaHg6JHtldmVudH1gLCB7ZGV0YWlsOiBwYXlsb2FkfSlcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnRzKGV2ZW50cyl7XG4gICAgZXZlbnRzLmZvckVhY2goKFtldmVudCwgcGF5bG9hZF0pID0+IHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCkpXG4gIH1cblxuICB3aXRoUGFnZUxvYWRpbmcoaW5mbywgY2FsbGJhY2spe1xuICAgIERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIHtkZXRhaWw6IGluZm99KVxuICAgIGxldCBkb25lID0gKCkgPT4gRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLCB7ZGV0YWlsOiBpbmZvfSlcbiAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhkb25lKSA6IGRvbmVcbiAgfVxuXG4gIHB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXRFbCl7XG4gICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiBocmVmLCBraW5kOiBcInBhdGNoXCJ9LCBkb25lID0+IHtcbiAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGhyZWYsIHRhcmdldEVsLCBsaW5rUmVmID0+IHtcbiAgICAgICAgdGhpcy5oaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmKVxuICAgICAgICBkb25lKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIGxpbmtSZWYgPSB0aGlzLnNldFBlbmRpbmdMaW5rKGhyZWYpKXtcbiAgICBpZighdGhpcy5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSl7IHJldHVybiB9XG5cbiAgICBCcm93c2VyLnB1c2hTdGF0ZShsaW5rU3RhdGUsIHt0eXBlOiBcInBhdGNoXCIsIGlkOiB0aGlzLm1haW4uaWR9LCBocmVmKVxuICAgIHRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pXG4gIH1cblxuICBoaXN0b3J5UmVkaXJlY3QoaHJlZiwgbGlua1N0YXRlLCBmbGFzaCl7XG4gICAgbGV0IHNjcm9sbCA9IHdpbmRvdy5zY3JvbGxZXG4gICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiBocmVmLCBraW5kOiBcInJlZGlyZWN0XCJ9LCBkb25lID0+IHtcbiAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsICgpID0+IHtcbiAgICAgICAgQnJvd3Nlci5wdXNoU3RhdGUobGlua1N0YXRlLCB7dHlwZTogXCJyZWRpcmVjdFwiLCBpZDogdGhpcy5tYWluLmlkLCBzY3JvbGw6IHNjcm9sbH0sIGhyZWYpXG4gICAgICAgIHRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pXG4gICAgICAgIGRvbmUoKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmVwbGFjZVJvb3RIaXN0b3J5KCl7XG4gICAgQnJvd3Nlci5wdXNoU3RhdGUoXCJyZXBsYWNlXCIsIHtyb290OiB0cnVlLCB0eXBlOiBcInBhdGNoXCIsIGlkOiB0aGlzLm1haW4uaWR9KVxuICB9XG5cbiAgcmVnaXN0ZXJOZXdMb2NhdGlvbihuZXdMb2NhdGlvbil7XG4gICAgbGV0IHtwYXRobmFtZSwgc2VhcmNofSA9IHRoaXMuY3VycmVudExvY2F0aW9uXG4gICAgaWYocGF0aG5hbWUgKyBzZWFyY2ggPT09IG5ld0xvY2F0aW9uLnBhdGhuYW1lICsgbmV3TG9jYXRpb24uc2VhcmNoKXtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGNsb25lKG5ld0xvY2F0aW9uKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBiaW5kRm9ybXMoKXtcbiAgICBsZXQgaXRlcmF0aW9ucyA9IDBcbiAgICB0aGlzLm9uKFwic3VibWl0XCIsIGUgPT4ge1xuICAgICAgbGV0IHBoeEV2ZW50ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInN1Ym1pdFwiKSlcbiAgICAgIGlmKCFwaHhFdmVudCl7IHJldHVybiB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUudGFyZ2V0LmRpc2FibGVkID0gdHJ1ZVxuICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICBKUy5leGVjKFwic3VibWl0XCIsIHBoeEV2ZW50LCB2aWV3LCBlLnRhcmdldCwgW1wicHVzaFwiLCB7fV0pXG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuXG4gICAgZm9yKGxldCB0eXBlIG9mIFtcImNoYW5nZVwiLCBcImlucHV0XCJdKXtcbiAgICAgIHRoaXMub24odHlwZSwgZSA9PiB7XG4gICAgICAgIGxldCBwaHhDaGFuZ2UgPSB0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIilcbiAgICAgICAgbGV0IGlucHV0ID0gZS50YXJnZXRcbiAgICAgICAgbGV0IGlucHV0RXZlbnQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKVxuICAgICAgICBsZXQgZm9ybUV2ZW50ID0gaW5wdXQuZm9ybSAmJiBpbnB1dC5mb3JtLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpXG4gICAgICAgIGxldCBwaHhFdmVudCA9IGlucHV0RXZlbnQgfHwgZm9ybUV2ZW50XG4gICAgICAgIGlmKCFwaHhFdmVudCl7IHJldHVybiB9XG4gICAgICAgIGlmKGlucHV0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5wdXQudmFsaWRpdHkgJiYgaW5wdXQudmFsaWRpdHkuYmFkSW5wdXQpeyByZXR1cm4gfVxuXG4gICAgICAgIGxldCBkaXNwYXRjaGVyID0gaW5wdXRFdmVudCA/IGlucHV0IDogaW5wdXQuZm9ybVxuICAgICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zXG4gICAgICAgIGl0ZXJhdGlvbnMrK1xuICAgICAgICBsZXQge2F0OiBhdCwgdHlwZTogbGFzdFR5cGV9ID0gRE9NLnByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIikgfHwge31cbiAgICAgICAgLy8gZGV0ZWN0IGR1cCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgZGlzcGF0Y2ggYm90aCBcImlucHV0XCIgYW5kIFwiY2hhbmdlXCJcbiAgICAgICAgaWYoYXQgPT09IGN1cnJlbnRJdGVyYXRpb25zIC0gMSAmJiB0eXBlICE9PSBsYXN0VHlwZSl7IHJldHVybiB9XG5cbiAgICAgICAgRE9NLnB1dFByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIiwge2F0OiBjdXJyZW50SXRlcmF0aW9ucywgdHlwZTogdHlwZX0pXG5cbiAgICAgICAgdGhpcy5kZWJvdW5jZShpbnB1dCwgZSwgdHlwZSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGRpc3BhdGNoZXIsIHZpZXcgPT4ge1xuICAgICAgICAgICAgRE9NLnB1dFByaXZhdGUoaW5wdXQsIFBIWF9IQVNfRk9DVVNFRCwgdHJ1ZSlcbiAgICAgICAgICAgIGlmKCFET00uaXNUZXh0dWFsSW5wdXQoaW5wdXQpKXtcbiAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVFbGVtZW50KGlucHV0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSlMuZXhlYyhcImNoYW5nZVwiLCBwaHhFdmVudCwgdmlldywgaW5wdXQsIFtcInB1c2hcIiwge190YXJnZXQ6IGUudGFyZ2V0Lm5hbWUsIGRpc3BhdGNoZXI6IGRpc3BhdGNoZXJ9XSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSwgZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgZGVib3VuY2UoZWwsIGV2ZW50LCBldmVudFR5cGUsIGNhbGxiYWNrKXtcbiAgICBpZihldmVudFR5cGUgPT09IFwiYmx1clwiIHx8IGV2ZW50VHlwZSA9PT0gXCJmb2N1c291dFwiKXsgcmV0dXJuIGNhbGxiYWNrKCkgfVxuXG4gICAgbGV0IHBoeERlYm91bmNlID0gdGhpcy5iaW5kaW5nKFBIWF9ERUJPVU5DRSlcbiAgICBsZXQgcGh4VGhyb3R0bGUgPSB0aGlzLmJpbmRpbmcoUEhYX1RIUk9UVExFKVxuICAgIGxldCBkZWZhdWx0RGVib3VuY2UgPSB0aGlzLmRlZmF1bHRzLmRlYm91bmNlLnRvU3RyaW5nKClcbiAgICBsZXQgZGVmYXVsdFRocm90dGxlID0gdGhpcy5kZWZhdWx0cy50aHJvdHRsZS50b1N0cmluZygpXG5cbiAgICB0aGlzLndpdGhpbk93bmVycyhlbCwgdmlldyA9PiB7XG4gICAgICBsZXQgYXN5bmNGaWx0ZXIgPSAoKSA9PiAhdmlldy5pc0Rlc3Ryb3llZCgpICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpXG4gICAgICBET00uZGVib3VuY2UoZWwsIGV2ZW50LCBwaHhEZWJvdW5jZSwgZGVmYXVsdERlYm91bmNlLCBwaHhUaHJvdHRsZSwgZGVmYXVsdFRocm90dGxlLCBhc3luY0ZpbHRlciwgKCkgPT4ge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBzaWxlbmNlRXZlbnRzKGNhbGxiYWNrKXtcbiAgICB0aGlzLnNpbGVuY2VkID0gdHJ1ZVxuICAgIGNhbGxiYWNrKClcbiAgICB0aGlzLnNpbGVuY2VkID0gZmFsc2VcbiAgfVxuXG4gIG9uKGV2ZW50LCBjYWxsYmFjayl7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGUgPT4ge1xuICAgICAgaWYoIXRoaXMuc2lsZW5jZWQpeyBjYWxsYmFjayhlKSB9XG4gICAgfSlcbiAgfVxufVxuXG5jbGFzcyBUcmFuc2l0aW9uU2V0IHtcbiAgY29uc3RydWN0b3IoKXtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFNldCgpXG4gICAgdGhpcy5wZW5kaW5nT3BzID0gW11cbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIHJlc2V0KCl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5mb3JFYWNoKHRpbWVyID0+IHtcbiAgICAgIGNhbmNlbFRpbWVvdXQodGltZXIpXG4gICAgICB0aGlzLnRyYW5zaXRpb25zLmRlbGV0ZSh0aW1lcilcbiAgICB9KVxuICAgIHRoaXMuZmx1c2hQZW5kaW5nT3BzKClcbiAgfVxuXG4gIGFmdGVyKGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLnNpemUoKSA9PT0gMCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaFBlbmRpbmdPcChjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBhZGRUcmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSl7XG4gICAgb25TdGFydCgpXG4gICAgbGV0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25zLmRlbGV0ZSh0aW1lcilcbiAgICAgIG9uRG9uZSgpXG4gICAgICBpZih0aGlzLnNpemUoKSA9PT0gMCl7IHRoaXMuZmx1c2hQZW5kaW5nT3BzKCkgfVxuICAgIH0sIHRpbWUpXG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZGQodGltZXIpXG4gIH1cblxuICBwdXNoUGVuZGluZ09wKG9wKXsgdGhpcy5wZW5kaW5nT3BzLnB1c2gob3ApIH1cblxuICBzaXplKCl7IHJldHVybiB0aGlzLnRyYW5zaXRpb25zLnNpemUgfVxuXG4gIGZsdXNoUGVuZGluZ09wcygpe1xuICAgIHRoaXMucGVuZGluZ09wcy5mb3JFYWNoKG9wID0+IG9wKCkpXG4gICAgdGhpcy5wZW5kaW5nT3BzID0gW11cbiAgfVxufVxuIiwgImNsYXNzIEFic3RyYWN0RXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcblxuICAgIHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XG4gIH1cblxuICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jYW5jZWxhYmxlO1xuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuX2NhbmNlbGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNhbmNlbGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW5jZWxlZDtcbiAgfVxuXG4gIGNsb25lKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Ioe1xuICAgICAgLi4udGhpcy5kYXRhLFxuICAgICAgLi4uZGF0YVxuICAgIH0pO1xuICB9XG59XG5cbkFic3RyYWN0RXZlbnQudHlwZSA9ICdldmVudCc7XG5cbkFic3RyYWN0RXZlbnQuY2FuY2VsYWJsZSA9IGZhbHNlO1xuXG5leHBvcnQgeyBBYnN0cmFjdEV2ZW50IH07XG4iLCAiY2xhc3MgQWJzdHJhY3RQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIHRoaXMuZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuXG5leHBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9O1xuIiwgImNvbnN0IGRlZmF1bHREZWxheSA9IHtcbiAgbW91c2U6IDAsXG4gIGRyYWc6IDAsXG4gIHRvdWNoOiAxMDBcbn07XG5cbmNsYXNzIFNlbnNvciB7XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcblxuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi5jb250YWluZXJzXTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcblxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcblxuICAgIHRoaXMuZGVsYXkgPSBjYWxjRGVsYXkob3B0aW9ucy5kZWxheSk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRDb250YWluZXIoLi4uY29udGFpbmVycykge1xuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi50aGlzLmNvbnRhaW5lcnMsIC4uLmNvbnRhaW5lcnNdO1xuICB9XG5cbiAgcmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSB0aGlzLmNvbnRhaW5lcnMuZmlsdGVyKGNvbnRhaW5lciA9PiAhY29udGFpbmVycy5pbmNsdWRlcyhjb250YWluZXIpKTtcbiAgfVxuXG4gIHRyaWdnZXIoZWxlbWVudCwgc2Vuc29yRXZlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmRldGFpbCA9IHNlbnNvckV2ZW50O1xuICAgIGV2ZW50LmluaXRFdmVudChzZW5zb3JFdmVudC50eXBlLCB0cnVlLCB0cnVlKTtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHRoaXMubGFzdEV2ZW50ID0gc2Vuc29yRXZlbnQ7XG4gICAgcmV0dXJuIHNlbnNvckV2ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGNEZWxheShvcHRpb25zRGVsYXkpIHtcbiAgY29uc3QgZGVsYXkgPSB7fTtcbiAgaWYgKG9wdGlvbnNEZWxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHREZWxheVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zRGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdERlbGF5KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmF1bHREZWxheSwga2V5KSkge1xuICAgICAgICBkZWxheVtrZXldID0gb3B0aW9uc0RlbGF5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdERlbGF5KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZhdWx0RGVsYXksIGtleSkpIHtcbiAgICAgIGlmIChvcHRpb25zRGVsYXlba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGF5W2tleV0gPSBkZWZhdWx0RGVsYXlba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGF5W2tleV0gPSBvcHRpb25zRGVsYXlba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlbGF5O1xufVxuXG5leHBvcnQgeyBTZW5zb3IgYXMgZGVmYXVsdCB9O1xuIiwgImZ1bmN0aW9uIGNsb3Nlc3Qobm9kZSwgdmFsdWUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNvbmRpdGlvbkZuKGN1cnJlbnROb2RlKSB7XG4gICAgaWYgKGN1cnJlbnROb2RlID09IG51bGwgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNTZWxlY3Rvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzLmNhbGwoY3VycmVudE5vZGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTm9kZUxpc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gWy4uLnZhbHVlXS5pbmNsdWRlcyhjdXJyZW50Tm9kZSk7XG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZShjdXJyZW50Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgbGV0IGN1cnJlbnQgPSBub2RlO1xuICBkbyB7XG4gICAgY3VycmVudCA9IGN1cnJlbnQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQgfHwgY3VycmVudC5jb3JyZXNwb25kaW5nRWxlbWVudCB8fCBjdXJyZW50O1xuICAgIGlmIChjb25kaXRpb25GbihjdXJyZW50KSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQgPSBjdXJyZW50Py5wYXJlbnROb2RlIHx8IG51bGw7XG4gIH0gd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50KTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1NlbGVjdG9yKHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpO1xufVxuZnVuY3Rpb24gaXNOb2RlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlIGluc3RhbmNlb2YgTm9kZSk7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCB7IGNsb3Nlc3QgYXMgZGVmYXVsdCB9O1xuIiwgImZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICoqIDIgKyAoeTIgLSB5MSkgKiogMik7XG59XG5cbmV4cG9ydCB7IGRpc3RhbmNlIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdEV2ZW50IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL0Fic3RyYWN0RXZlbnQvQWJzdHJhY3RFdmVudC5tanMnO1xuXG5jbGFzcyBTZW5zb3JFdmVudCBleHRlbmRzIEFic3RyYWN0RXZlbnQge1xuXG4gIGdldCBvcmlnaW5hbEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxFdmVudDtcbiAgfVxuXG4gIGdldCBjbGllbnRYKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY2xpZW50WDtcbiAgfVxuXG4gIGdldCBjbGllbnRZKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY2xpZW50WTtcbiAgfVxuXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS50YXJnZXQ7XG4gIH1cblxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY29udGFpbmVyO1xuICB9XG5cbiAgZ2V0IG9yaWdpbmFsU291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxTb3VyY2U7XG4gIH1cblxuICBnZXQgcHJlc3N1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wcmVzc3VyZTtcbiAgfVxufVxuXG5jbGFzcyBEcmFnU3RhcnRTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XG5cbkRyYWdTdGFydFNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpzdGFydCc7XG5jbGFzcyBEcmFnTW92ZVNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cblxuRHJhZ01vdmVTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6bW92ZSc7XG5jbGFzcyBEcmFnU3RvcFNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cblxuRHJhZ1N0b3BTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6c3RvcCc7XG5jbGFzcyBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XG5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6cHJlc3N1cmUnO1xuXG5leHBvcnQgeyBEcmFnTW92ZVNlbnNvckV2ZW50LCBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudCwgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQsIERyYWdTdG9wU2Vuc29yRXZlbnQsIFNlbnNvckV2ZW50IH07XG4iLCAiaW1wb3J0IGNsb3Nlc3QgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2Nsb3Nlc3QvY2xvc2VzdC5tanMnO1xuaW1wb3J0IGRpc3RhbmNlIGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy9kaXN0YW5jZS9kaXN0YW5jZS5tanMnO1xuaW1wb3J0IFNlbnNvciBmcm9tICcuLi9TZW5zb3IvU2Vuc29yLm1qcyc7XG5pbXBvcnQgeyBEcmFnU3RhcnRTZW5zb3JFdmVudCwgRHJhZ01vdmVTZW5zb3JFdmVudCwgRHJhZ1N0b3BTZW5zb3JFdmVudCB9IGZyb20gJy4uL1NlbnNvckV2ZW50L1NlbnNvckV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nID0gU3ltYm9sKCdvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZycpO1xuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XG5jb25zdCBvbk1vdXNlTW92ZSA9IFN5bWJvbCgnb25Nb3VzZU1vdmUnKTtcbmNvbnN0IG9uTW91c2VVcCA9IFN5bWJvbCgnb25Nb3VzZVVwJyk7XG5jb25zdCBzdGFydERyYWcgPSBTeW1ib2woJ3N0YXJ0RHJhZycpO1xuY29uc3Qgb25EaXN0YW5jZUNoYW5nZSA9IFN5bWJvbCgnb25EaXN0YW5jZUNoYW5nZScpO1xuXG5jbGFzcyBNb3VzZVNlbnNvciBleHRlbmRzIFNlbnNvciB7XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcblxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IG51bGw7XG5cbiAgICB0aGlzLnBhZ2VYID0gbnVsbDtcblxuICAgIHRoaXMucGFnZVkgPSBudWxsO1xuICAgIHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddID0gdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlTW92ZV0gPSB0aGlzW29uTW91c2VNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Nb3VzZVVwXSA9IHRoaXNbb25Nb3VzZVVwXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbc3RhcnREcmFnXSA9IHRoaXNbc3RhcnREcmFnXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0gPSB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcbiAgfVxuXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBjbG9zZXN0KGV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZSAmJiBldmVudC50YXJnZXQgJiYgIWNsb3Nlc3QoZXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuaGFuZGxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbFNvdXJjZSA9IGNsb3Nlc3QoZXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICBpZiAoIW9yaWdpbmFsU291cmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRlbGF5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSBldmVudDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9KTtcbiAgICB0aGlzLm9uTW91c2VEb3duQXQgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gb3JpZ2luYWxTb3VyY2U7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcHJldmVudE5hdGl2ZURyYWdTdGFydCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSh7XG4gICAgICAgIHBhZ2VYOiB0aGlzLnBhZ2VYLFxuICAgICAgICBwYWdlWTogdGhpcy5wYWdlWVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkubW91c2UpO1xuICB9XG5cbiAgW3N0YXJ0RHJhZ10oKSB7XG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IHRoaXMuc3RhcnRFdmVudDtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XG4gICAgY29uc3Qgb3JpZ2luYWxTb3VyY2UgPSB0aGlzLm9yaWdpbmFsU291cmNlO1xuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IERyYWdTdGFydFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IHN0YXJ0RXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IHN0YXJ0RXZlbnQuY2xpZW50WSxcbiAgICAgIHRhcmdldDogc3RhcnRFdmVudC50YXJnZXQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IHN0YXJ0RXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddLCB0cnVlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcbiAgICB9XG4gIH1cblxuICBbb25EaXN0YW5jZUNoYW5nZV0oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSQxXG4gICAgfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBzdGFydEV2ZW50LFxuICAgICAgZGVsYXlcbiAgICB9ID0gdGhpcztcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuY3VycmVudENvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aW1lRWxhcHNlZCA9IERhdGUubm93KCkgLSB0aGlzLm9uTW91c2VEb3duQXQ7XG4gICAgY29uc3QgZGlzdGFuY2VUcmF2ZWxsZWQgPSBkaXN0YW5jZShzdGFydEV2ZW50LnBhZ2VYLCBzdGFydEV2ZW50LnBhZ2VZLCBwYWdlWCwgcGFnZVkpIHx8IDA7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XG4gICAgaWYgKHRpbWVFbGFwc2VkIDwgZGVsYXkubW91c2UpIHtcblxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZVRyYXZlbGxlZCA+PSBkaXN0YW5jZSQxKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcbiAgICAgIHRoaXNbc3RhcnREcmFnXSgpO1xuICAgIH1cbiAgfVxuXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IERyYWdNb3ZlU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XG4gIH1cblxuICBbb25Nb3VzZVVwXShldmVudCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdXNlRG93blRpbWVvdXQpO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcHJldmVudE5hdGl2ZURyYWdTdGFydCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBEcmFnU3RvcFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10sIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xuICB9XG5cbiAgW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXZlbnROYXRpdmVEcmFnU3RhcnQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZXhwb3J0IHsgTW91c2VTZW5zb3IgYXMgZGVmYXVsdCB9O1xuIiwgImZ1bmN0aW9uIHRvdWNoQ29vcmRzKGV2ZW50KSB7XG4gIGNvbnN0IHtcbiAgICB0b3VjaGVzLFxuICAgIGNoYW5nZWRUb3VjaGVzXG4gIH0gPSBldmVudDtcbiAgcmV0dXJuIHRvdWNoZXMgJiYgdG91Y2hlc1swXSB8fCBjaGFuZ2VkVG91Y2hlcyAmJiBjaGFuZ2VkVG91Y2hlc1swXTtcbn1cblxuZXhwb3J0IHsgdG91Y2hDb29yZHMgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCBjbG9zZXN0IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy9jbG9zZXN0L2Nsb3Nlc3QubWpzJztcbmltcG9ydCBkaXN0YW5jZSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMvZGlzdGFuY2UvZGlzdGFuY2UubWpzJztcbmltcG9ydCB0b3VjaENvb3JkcyBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMvdG91Y2hDb29yZHMvdG91Y2hDb29yZHMubWpzJztcbmltcG9ydCBTZW5zb3IgZnJvbSAnLi4vU2Vuc29yL1NlbnNvci5tanMnO1xuaW1wb3J0IHsgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQsIERyYWdNb3ZlU2Vuc29yRXZlbnQsIERyYWdTdG9wU2Vuc29yRXZlbnQgfSBmcm9tICcuLi9TZW5zb3JFdmVudC9TZW5zb3JFdmVudC5tanMnO1xuXG5jb25zdCBvblRvdWNoU3RhcnQgPSBTeW1ib2woJ29uVG91Y2hTdGFydCcpO1xuY29uc3Qgb25Ub3VjaEVuZCA9IFN5bWJvbCgnb25Ub3VjaEVuZCcpO1xuY29uc3Qgb25Ub3VjaE1vdmUgPSBTeW1ib2woJ29uVG91Y2hNb3ZlJyk7XG5jb25zdCBzdGFydERyYWcgPSBTeW1ib2woJ3N0YXJ0RHJhZycpO1xuY29uc3Qgb25EaXN0YW5jZUNoYW5nZSA9IFN5bWJvbCgnb25EaXN0YW5jZUNoYW5nZScpO1xuXG5sZXQgcHJldmVudFNjcm9sbGluZyA9IGZhbHNlO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZXZlbnQgPT4ge1xuICBpZiAoIXByZXZlbnRTY3JvbGxpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufSwge1xuICBwYXNzaXZlOiBmYWxzZVxufSk7XG5cbmNsYXNzIFRvdWNoU2Vuc29yIGV4dGVuZHMgU2Vuc29yIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jdXJyZW50U2Nyb2xsYWJsZVBhcmVudCA9IG51bGw7XG5cbiAgICB0aGlzLnRhcFRpbWVvdXQgPSBudWxsO1xuXG4gICAgdGhpcy50b3VjaE1vdmVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnBhZ2VYID0gbnVsbDtcblxuICAgIHRoaXMucGFnZVkgPSBudWxsO1xuICAgIHRoaXNbb25Ub3VjaFN0YXJ0XSA9IHRoaXNbb25Ub3VjaFN0YXJ0XS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Ub3VjaEVuZF0gPSB0aGlzW29uVG91Y2hFbmRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvblRvdWNoTW92ZV0gPSB0aGlzW29uVG91Y2hNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbc3RhcnREcmFnXSA9IHRoaXNbc3RhcnREcmFnXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0gPSB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XG4gIH1cblxuICBbb25Ub3VjaFN0YXJ0XShldmVudCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNsb3Nlc3QoZXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlICYmIGV2ZW50LnRhcmdldCAmJiAhY2xvc2VzdChldmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5oYW5kbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gY2xvc2VzdChldmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIGlmICghb3JpZ2luYWxTb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGlzdGFuY2UgPSAwXG4gICAgfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBkZWxheVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdG91Y2hDb29yZHMoZXZlbnQpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0pO1xuICAgIHRoaXMub25Ub3VjaFN0YXJ0QXQgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gb3JpZ2luYWxTb3VyY2U7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzW29uVG91Y2hFbmRdKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUpO1xuICAgIGlmIChkaXN0YW5jZSkge1xuICAgICAgcHJldmVudFNjcm9sbGluZyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMudGFwVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0oe1xuICAgICAgICB0b3VjaGVzOiBbe1xuICAgICAgICAgIHBhZ2VYOiB0aGlzLnBhZ2VYLFxuICAgICAgICAgIHBhZ2VZOiB0aGlzLnBhZ2VZXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICB9LCBkZWxheS50b3VjaCk7XG4gIH1cblxuICBbc3RhcnREcmFnXSgpIHtcbiAgICBjb25zdCBzdGFydEV2ZW50ID0gdGhpcy5zdGFydEV2ZW50O1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcbiAgICBjb25zdCB0b3VjaCA9IHRvdWNoQ29vcmRzKHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gdGhpcy5vcmlnaW5hbFNvdXJjZTtcbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBEcmFnU3RhcnRTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiB0b3VjaC5wYWdlWCxcbiAgICAgIGNsaWVudFk6IHRvdWNoLnBhZ2VZLFxuICAgICAgdGFyZ2V0OiBzdGFydEV2ZW50LnRhcmdldCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgb3JpZ2luYWxFdmVudDogc3RhcnRFdmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25Ub3VjaE1vdmVdKTtcbiAgICB9XG4gICAgcHJldmVudFNjcm9sbGluZyA9IHRoaXMuZHJhZ2dpbmc7XG4gIH1cblxuICBbb25EaXN0YW5jZUNoYW5nZV0oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2UkMVxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRFdmVudCxcbiAgICAgIGRlbGF5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3RhcnQgPSB0b3VjaENvb3JkcyhzdGFydEV2ZW50KTtcbiAgICBjb25zdCBjdXJyZW50ID0gdG91Y2hDb29yZHMoZXZlbnQpO1xuICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gRGF0ZS5ub3coKSAtIHRoaXMub25Ub3VjaFN0YXJ0QXQ7XG4gICAgY29uc3QgZGlzdGFuY2VUcmF2ZWxsZWQgPSBkaXN0YW5jZShzdGFydC5wYWdlWCwgc3RhcnQucGFnZVksIGN1cnJlbnQucGFnZVgsIGN1cnJlbnQucGFnZVkpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY3VycmVudCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGFwVGltZW91dCk7XG4gICAgaWYgKHRpbWVFbGFwc2VkIDwgZGVsYXkudG91Y2gpIHtcblxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZVRyYXZlbGxlZCA+PSBkaXN0YW5jZSQxKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcbiAgICAgIHRoaXNbc3RhcnREcmFnXSgpO1xuICAgIH1cbiAgfVxuXG4gIFtvblRvdWNoTW92ZV0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB0b3VjaENvb3JkcyhldmVudCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwYWdlWCAtIHdpbmRvdy5zY3JvbGxYLCBwYWdlWSAtIHdpbmRvdy5zY3JvbGxZKTtcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IERyYWdNb3ZlU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogcGFnZVgsXG4gICAgICBjbGllbnRZOiBwYWdlWSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcbiAgfVxuXG4gIFtvblRvdWNoRW5kXShldmVudCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRhcFRpbWVvdXQpO1xuICAgIHByZXZlbnRTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpc1tvblRvdWNoRW5kXSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XG4gICAgaWYgKHRoaXMuY3VycmVudENvbnRhaW5lcikge1xuICAgICAgdGhpcy5jdXJyZW50Q29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uVG91Y2hNb3ZlXSk7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB0b3VjaENvb3JkcyhldmVudCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwYWdlWCAtIHdpbmRvdy5zY3JvbGxYLCBwYWdlWSAtIHdpbmRvdy5zY3JvbGxZKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgRHJhZ1N0b3BTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiBwYWdlWCxcbiAgICAgIGNsaWVudFk6IHBhZ2VZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmV4cG9ydCB7IFRvdWNoU2Vuc29yIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgY2xvc2VzdCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMvY2xvc2VzdC9jbG9zZXN0Lm1qcyc7XG5pbXBvcnQgU2Vuc29yIGZyb20gJy4uL1NlbnNvci9TZW5zb3IubWpzJztcbmltcG9ydCB7IERyYWdTdGFydFNlbnNvckV2ZW50LCBEcmFnTW92ZVNlbnNvckV2ZW50LCBEcmFnU3RvcFNlbnNvckV2ZW50IH0gZnJvbSAnLi4vU2Vuc29yRXZlbnQvU2Vuc29yRXZlbnQubWpzJztcblxuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XG5jb25zdCBvbkRyYWdFbmQgPSBTeW1ib2woJ29uRHJhZ0VuZCcpO1xuY29uc3Qgb25Ecm9wID0gU3ltYm9sKCdvbkRyb3AnKTtcbmNvbnN0IHJlc2V0ID0gU3ltYm9sKCdyZXNldCcpO1xuXG5jbGFzcyBEcmFnU2Vuc29yIGV4dGVuZHMgU2Vuc29yIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gbnVsbDtcblxuICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ0VuZF0gPSB0aGlzW29uRHJhZ0VuZF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJvcF0gPSB0aGlzW29uRHJvcF0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xuICB9XG5cbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xuXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQnLCAnJyk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSB0aGlzLm9wdGlvbnMudHlwZTtcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gdGhpcy5kcmFnZ2FibGVFbGVtZW50O1xuICAgIGlmICghb3JpZ2luYWxTb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xuICAgICAgaWYgKGRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH1cblxuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBEcmFnTW92ZVNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcbiAgICBpZiAoIWRyYWdNb3ZlRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gdGhpcy5vcHRpb25zLnR5cGU7XG4gICAgfVxuICB9XG5cbiAgW29uRHJhZ0VuZF0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBEcmFnU3RvcFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcbiAgICB0aGlzW3Jlc2V0XSgpO1xuICB9XG5cbiAgW29uRHJvcF0oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgW29uTW91c2VEb3duXShldmVudCkge1xuXG4gICAgaWYgKGV2ZW50LnRhcmdldCAmJiAoZXZlbnQudGFyZ2V0LmZvcm0gfHwgZXZlbnQudGFyZ2V0LmNvbnRlbnRlZGl0YWJsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNsb3Nlc3QodGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xuICAgIGlmICghdGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlICYmIHRhcmdldCAmJiAhY2xvc2VzdCh0YXJnZXQsIHRoaXMub3B0aW9ucy5oYW5kbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gY2xvc2VzdCh0YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIGlmICghb3JpZ2luYWxTb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IGNsb3Nlc3QoZXZlbnQudGFyZ2V0LCBlbGVtZW50ID0+IGVsZW1lbnQuZHJhZ2dhYmxlKTtcbiAgICBpZiAobmF0aXZlRHJhZ2dhYmxlRWxlbWVudCkge1xuICAgICAgbmF0aXZlRHJhZ2dhYmxlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQ7XG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzW29uRHJhZ092ZXJdLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXNbb25EcmFnRW5kXSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzW29uRHJvcF0sIGZhbHNlKTtcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBldmVudDtcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG9yaWdpbmFsU291cmNlLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQgPSBvcmlnaW5hbFNvdXJjZTtcbiAgICB9LCB0aGlzLmRlbGF5LmRyYWcpO1xuICB9XG5cbiAgW29uTW91c2VVcF0oKSB7XG4gICAgdGhpc1tyZXNldF0oKTtcbiAgfVxuXG4gIFtyZXNldF0oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpc1tvbkRyYWdFbmRdLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXNbb25Ecm9wXSwgZmFsc2UpO1xuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZHJhZ2dhYmxlRWxlbWVudCkge1xuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgRHJhZ1NlbnNvciBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IGNsb3Nlc3QgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2Nsb3Nlc3QvY2xvc2VzdC5tanMnO1xuaW1wb3J0IFNlbnNvciBmcm9tICcuLi9TZW5zb3IvU2Vuc29yLm1qcyc7XG5pbXBvcnQgeyBEcmFnU3RhcnRTZW5zb3JFdmVudCwgRHJhZ1N0b3BTZW5zb3JFdmVudCwgRHJhZ01vdmVTZW5zb3JFdmVudCwgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgfSBmcm9tICcuLi9TZW5zb3JFdmVudC9TZW5zb3JFdmVudC5tanMnO1xuXG5jb25zdCBvbk1vdXNlRm9yY2VXaWxsQmVnaW4gPSBTeW1ib2woJ29uTW91c2VGb3JjZVdpbGxCZWdpbicpO1xuY29uc3Qgb25Nb3VzZUZvcmNlRG93biA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlRG93bicpO1xuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XG5jb25zdCBvbk1vdXNlRm9yY2VDaGFuZ2UgPSBTeW1ib2woJ29uTW91c2VGb3JjZUNoYW5nZScpO1xuY29uc3Qgb25Nb3VzZU1vdmUgPSBTeW1ib2woJ29uTW91c2VNb3ZlJyk7XG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xuY29uc3Qgb25Nb3VzZUZvcmNlR2xvYmFsQ2hhbmdlID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2UnKTtcblxuY2xhc3MgRm9yY2VUb3VjaFNlbnNvciBleHRlbmRzIFNlbnNvciB7XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcblxuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XG4gICAgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dID0gdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSA9IHRoaXNbb25Nb3VzZUZvcmNlRG93bl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdID0gdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlTW92ZV0gPSB0aGlzW29uTW91c2VNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Nb3VzZVVwXSA9IHRoaXNbb25Nb3VzZVVwXS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIGZvciAoY29uc3QgY29udGFpbmVyIG9mIHRoaXMuY29udGFpbmVycykge1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLCB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0sIGZhbHNlKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlZG93bicsIHRoaXNbb25Nb3VzZUZvcmNlRG93bl0sIGZhbHNlKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWNoYW5nZWQnLCB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0sIGZhbHNlKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIGZvciAoY29uc3QgY29udGFpbmVyIG9mIHRoaXMuY29udGFpbmVycykge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLCB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0sIGZhbHNlKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlZG93bicsIHRoaXNbb25Nb3VzZUZvcmNlRG93bl0sIGZhbHNlKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWNoYW5nZWQnLCB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0sIGZhbHNlKTtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xuICB9XG5cbiAgW29uTW91c2VGb3JjZVdpbGxCZWdpbl0oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMubWlnaHREcmFnID0gdHJ1ZTtcbiAgfVxuXG4gIFtvbk1vdXNlRm9yY2VEb3duXShldmVudCkge1xuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgY29uc3QgY29udGFpbmVyID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZSAmJiB0YXJnZXQgJiYgIWNsb3Nlc3QodGFyZ2V0LCB0aGlzLm9wdGlvbnMuaGFuZGxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbFNvdXJjZSA9IGNsb3Nlc3QodGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICBpZiAoIW9yaWdpbmFsU291cmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IERyYWdTdGFydFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XG4gIH1cblxuICBbb25Nb3VzZVVwXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IERyYWdTdG9wU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5taWdodERyYWcgPSBmYWxzZTtcbiAgfVxuXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMubWlnaHREcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IERyYWdNb3ZlU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XG4gIH1cblxuICBbb25Nb3VzZUZvcmNlQ2hhbmdlXShldmVudCkge1xuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IERyYWdQcmVzc3VyZVNlbnNvckV2ZW50KHtcbiAgICAgIHByZXNzdXJlOiBldmVudC53ZWJraXRGb3JjZSxcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnUHJlc3N1cmVFdmVudCk7XG4gIH1cblxuICBbb25Nb3VzZUZvcmNlR2xvYmFsQ2hhbmdlXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQoe1xuICAgICAgcHJlc3N1cmU6IGV2ZW50LndlYmtpdEZvcmNlLFxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1ByZXNzdXJlRXZlbnQpO1xuICB9XG59XG5cbmV4cG9ydCB7IEZvcmNlVG91Y2hTZW5zb3IgYXMgZGVmYXVsdCB9O1xuIiwgImV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sbGlkYWJsZSB9IGZyb20gJy4vQ29sbGlkYWJsZS9Db2xsaWRhYmxlLm1qcyc7XG5pbXBvcnQgJy4vQ29sbGlkYWJsZS9Db2xsaWRhYmxlRXZlbnQvQ29sbGlkYWJsZUV2ZW50Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlc2l6ZU1pcnJvciwgZGVmYXVsdE9wdGlvbnMgYXMgZGVmYXVsdFJlc2l6ZU1pcnJvck9wdGlvbnMgfSBmcm9tICcuL1Jlc2l6ZU1pcnJvci9SZXNpemVNaXJyb3IubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU25hcHBhYmxlIH0gZnJvbSAnLi9TbmFwcGFibGUvU25hcHBhYmxlLm1qcyc7XG5pbXBvcnQgJy4vU25hcHBhYmxlL1NuYXBwYWJsZUV2ZW50L1NuYXBwYWJsZUV2ZW50Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN3YXBBbmltYXRpb24sIGRlZmF1bHRPcHRpb25zIGFzIGRlZmF1bHRTd2FwQW5pbWF0aW9uT3B0aW9ucyB9IGZyb20gJy4vU3dhcEFuaW1hdGlvbi9Td2FwQW5pbWF0aW9uLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNvcnRBbmltYXRpb24sIGRlZmF1bHRPcHRpb25zIGFzIGRlZmF1bHRTb3J0QW5pbWF0aW9uT3B0aW9ucyB9IGZyb20gJy4vU29ydEFuaW1hdGlvbi9Tb3J0QW5pbWF0aW9uLm1qcyc7XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RFdmVudCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9BYnN0cmFjdEV2ZW50L0Fic3RyYWN0RXZlbnQubWpzJztcblxuY2xhc3MgQ29sbGlkYWJsZUV2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5Db2xsaWRhYmxlRXZlbnQudHlwZSA9ICdjb2xsaWRhYmxlJztcblxuY2xhc3MgQ29sbGlkYWJsZUluRXZlbnQgZXh0ZW5kcyBDb2xsaWRhYmxlRXZlbnQge1xuXG4gIGdldCBjb2xsaWRpbmdFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY29sbGlkaW5nRWxlbWVudDtcbiAgfVxufVxuQ29sbGlkYWJsZUluRXZlbnQudHlwZSA9ICdjb2xsaWRhYmxlOmluJztcblxuY2xhc3MgQ29sbGlkYWJsZU91dEV2ZW50IGV4dGVuZHMgQ29sbGlkYWJsZUV2ZW50IHtcblxuICBnZXQgY29sbGlkaW5nRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNvbGxpZGluZ0VsZW1lbnQ7XG4gIH1cbn1cbkNvbGxpZGFibGVPdXRFdmVudC50eXBlID0gJ2NvbGxpZGFibGU6b3V0JztcblxuZXhwb3J0IHsgQ29sbGlkYWJsZUV2ZW50LCBDb2xsaWRhYmxlSW5FdmVudCwgQ29sbGlkYWJsZU91dEV2ZW50IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RQbHVnaW4gfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RQbHVnaW4vQWJzdHJhY3RQbHVnaW4ubWpzJztcbmltcG9ydCBjbG9zZXN0IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy9jbG9zZXN0L2Nsb3Nlc3QubWpzJztcbmltcG9ydCB7IENvbGxpZGFibGVJbkV2ZW50LCBDb2xsaWRhYmxlT3V0RXZlbnQgfSBmcm9tICcuL0NvbGxpZGFibGVFdmVudC9Db2xsaWRhYmxlRXZlbnQubWpzJztcblxuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuY29uc3Qgb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBTeW1ib2woJ29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XG5cbmNsYXNzIENvbGxpZGFibGUgZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvblJlcXVlc3RBbmltYXRpb25GcmFtZV0gPSB0aGlzW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgZ2V0Q29sbGlkYWJsZXMoKSB7XG4gICAgY29uc3QgY29sbGlkYWJsZXMgPSB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLmNvbGxpZGFibGVzO1xuICAgIGlmICh0eXBlb2YgY29sbGlkYWJsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjb2xsaWRhYmxlcykpO1xuICAgIH0gZWxzZSBpZiAoY29sbGlkYWJsZXMgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBjb2xsaWRhYmxlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29sbGlkYWJsZXMpO1xuICAgIH0gZWxzZSBpZiAoY29sbGlkYWJsZXMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgcmV0dXJuIFtjb2xsaWRhYmxlc107XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29sbGlkYWJsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjb2xsaWRhYmxlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgW29uRHJhZ01vdmVdKGV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuc2Vuc29yRXZlbnQudGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdKHRhcmdldCkpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQpIHtcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgIH1cbiAgICBjb25zdCBjb2xsaWRhYmxlSW5FdmVudCA9IG5ldyBDb2xsaWRhYmxlSW5FdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgY29sbGlkaW5nRWxlbWVudDogdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50XG4gICAgfSk7XG4gICAgY29uc3QgY29sbGlkYWJsZU91dEV2ZW50ID0gbmV3IENvbGxpZGFibGVPdXRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgY29sbGlkaW5nRWxlbWVudDogdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudFxuICAgIH0pO1xuICAgIGNvbnN0IGVudGVyaW5nQ29sbGlkYWJsZSA9IEJvb2xlYW4odGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ICYmIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgIT09IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCk7XG4gICAgY29uc3QgbGVhdmluZ0NvbGxpZGFibGUgPSBCb29sZWFuKCF0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgJiYgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudCk7XG4gICAgaWYgKGVudGVyaW5nQ29sbGlkYWJsZSkge1xuICAgICAgaWYgKHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlSW5FdmVudCk7XG4gICAgfSBlbHNlIGlmIChsZWF2aW5nQ29sbGlkYWJsZSkge1xuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ID0gdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50O1xuICB9XG5cbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XG4gICAgY29uc3QgbGFzdENvbGxpZGluZ0VsZW1lbnQgPSB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgfHwgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudDtcbiAgICBjb25zdCBjb2xsaWRhYmxlT3V0RXZlbnQgPSBuZXcgQ29sbGlkYWJsZU91dEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBjb2xsaWRpbmdFbGVtZW50OiBsYXN0Q29sbGlkaW5nRWxlbWVudFxuICAgIH0pO1xuICAgIGlmIChsYXN0Q29sbGlkaW5nRWxlbWVudCkge1xuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xuICB9XG5cbiAgW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXSh0YXJnZXQpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY29sbGlkYWJsZXMgPSB0aGlzLmdldENvbGxpZGFibGVzKCk7XG4gICAgICB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgPSBjbG9zZXN0KHRhcmdldCwgZWxlbWVudCA9PiBjb2xsaWRhYmxlcy5pbmNsdWRlcyhlbGVtZW50KSk7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgeyBDb2xsaWRhYmxlIGFzIGRlZmF1bHQgfTtcbiIsICJmdW5jdGlvbiBjcmVhdGVBZGRJbml0aWFsaXplck1ldGhvZChlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAocikge1xuICAgIGFzc2VydE5vdEZpbmlzaGVkKHQsIFwiYWRkSW5pdGlhbGl6ZXJcIiksIGFzc2VydENhbGxhYmxlKHIsIFwiQW4gaW5pdGlhbGl6ZXJcIiksIGUucHVzaChyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFzc2VydEluc3RhbmNlSWZQcml2YXRlKGUsIHQpIHtcbiAgaWYgKCFlKHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXR0ZW1wdGVkIHRvIGFjY2VzcyBwcml2YXRlIGVsZW1lbnQgb24gbm9uLWluc3RhbmNlXCIpO1xufVxuZnVuY3Rpb24gbWVtYmVyRGVjKGUsIHQsIHIsIGEsIG4sIGksIHMsIG8sIGMsIGwsIHUpIHtcbiAgdmFyIGY7XG4gIHN3aXRjaCAoaSkge1xuICAgIGNhc2UgMTpcbiAgICAgIGYgPSBcImFjY2Vzc29yXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBmID0gXCJtZXRob2RcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGYgPSBcImdldHRlclwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZiA9IFwic2V0dGVyXCI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZiA9IFwiZmllbGRcIjtcbiAgfVxuICB2YXIgZCxcbiAgICBwLFxuICAgIGggPSB7XG4gICAgICBraW5kOiBmLFxuICAgICAgbmFtZTogbyA/IFwiI1wiICsgciA6IHIsXG4gICAgICBzdGF0aWM6IHMsXG4gICAgICBwcml2YXRlOiBvLFxuICAgICAgbWV0YWRhdGE6IHVcbiAgICB9LFxuICAgIHYgPSB7XG4gICAgICB2OiAhMVxuICAgIH07XG4gIGlmICgwICE9PSBpICYmIChoLmFkZEluaXRpYWxpemVyID0gY3JlYXRlQWRkSW5pdGlhbGl6ZXJNZXRob2QobiwgdikpLCBvIHx8IDAgIT09IGkgJiYgMiAhPT0gaSkge1xuICAgIGlmICgyID09PSBpKSBkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBhc3NlcnRJbnN0YW5jZUlmUHJpdmF0ZShsLCBlKSwgYS52YWx1ZTtcbiAgICB9O2Vsc2Uge1xuICAgICAgdmFyIHkgPSAwID09PSBpIHx8IDEgPT09IGk7XG4gICAgICAoeSB8fCAzID09PSBpKSAmJiAoZCA9IG8gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gYXNzZXJ0SW5zdGFuY2VJZlByaXZhdGUobCwgZSksIGEuZ2V0LmNhbGwoZSk7XG4gICAgICB9IDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0LmNhbGwoZSk7XG4gICAgICB9KSwgKHkgfHwgNCA9PT0gaSkgJiYgKHAgPSBvID8gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgYXNzZXJ0SW5zdGFuY2VJZlByaXZhdGUobCwgZSksIGEuc2V0LmNhbGwoZSwgdCk7XG4gICAgICB9IDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgYS5zZXQuY2FsbChlLCB0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlW3JdO1xuICB9LCAwID09PSBpICYmIChwID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICBlW3JdID0gdDtcbiAgfSk7XG4gIHZhciBtID0gbyA/IGwuYmluZCgpIDogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gciBpbiBlO1xuICB9O1xuICBoLmFjY2VzcyA9IGQgJiYgcCA/IHtcbiAgICBnZXQ6IGQsXG4gICAgc2V0OiBwLFxuICAgIGhhczogbVxuICB9IDogZCA/IHtcbiAgICBnZXQ6IGQsXG4gICAgaGFzOiBtXG4gIH0gOiB7XG4gICAgc2V0OiBwLFxuICAgIGhhczogbVxuICB9O1xuICB0cnkge1xuICAgIHJldHVybiBlLmNhbGwodCwgYywgaCk7XG4gIH0gZmluYWxseSB7XG4gICAgdi52ID0gITA7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE5vdEZpbmlzaGVkKGUsIHQpIHtcbiAgaWYgKGUudikgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdGVkIHRvIGNhbGwgXCIgKyB0ICsgXCIgYWZ0ZXIgZGVjb3JhdGlvbiB3YXMgZmluaXNoZWRcIik7XG59XG5mdW5jdGlvbiBhc3NlcnRDYWxsYWJsZShlLCB0KSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHRocm93IG5ldyBUeXBlRXJyb3IodCArIFwiIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUmV0dXJuVmFsdWUoZSwgdCkge1xuICB2YXIgciA9IHR5cGVvZiB0O1xuICBpZiAoMSA9PT0gZSkge1xuICAgIGlmIChcIm9iamVjdFwiICE9PSByIHx8IG51bGwgPT09IHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhY2Nlc3NvciBkZWNvcmF0b3JzIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGdldCwgc2V0LCBvciBpbml0IHByb3BlcnRpZXMgb3Igdm9pZCAwXCIpO1xuICAgIHZvaWQgMCAhPT0gdC5nZXQgJiYgYXNzZXJ0Q2FsbGFibGUodC5nZXQsIFwiYWNjZXNzb3IuZ2V0XCIpLCB2b2lkIDAgIT09IHQuc2V0ICYmIGFzc2VydENhbGxhYmxlKHQuc2V0LCBcImFjY2Vzc29yLnNldFwiKSwgdm9pZCAwICE9PSB0LmluaXQgJiYgYXNzZXJ0Q2FsbGFibGUodC5pbml0LCBcImFjY2Vzc29yLmluaXRcIik7XG4gIH0gZWxzZSBpZiAoXCJmdW5jdGlvblwiICE9PSByKSB7XG4gICAgdmFyIGE7XG4gICAgdGhyb3cgYSA9IDAgPT09IGUgPyBcImZpZWxkXCIgOiA1ID09PSBlID8gXCJjbGFzc1wiIDogXCJtZXRob2RcIiwgbmV3IFR5cGVFcnJvcihhICsgXCIgZGVjb3JhdG9ycyBtdXN0IHJldHVybiBhIGZ1bmN0aW9uIG9yIHZvaWQgMFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gY3VycnlUaGlzMShlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGUodGhpcyk7XG4gIH07XG59XG5mdW5jdGlvbiBjdXJyeVRoaXMyKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgZSh0aGlzLCB0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFwcGx5TWVtYmVyRGVjKGUsIHQsIHIsIGEsIG4sIGksIHMsIG8sIGMsIGwsIHUpIHtcbiAgdmFyIGYsXG4gICAgZCxcbiAgICBwLFxuICAgIGgsXG4gICAgdixcbiAgICB5LFxuICAgIG0gPSByWzBdO1xuICBhIHx8IEFycmF5LmlzQXJyYXkobSkgfHwgKG0gPSBbbV0pLCBvID8gZiA9IDAgPT09IGkgfHwgMSA9PT0gaSA/IHtcbiAgICBnZXQ6IGN1cnJ5VGhpczEoclszXSksXG4gICAgc2V0OiBjdXJyeVRoaXMyKHJbNF0pXG4gIH0gOiAzID09PSBpID8ge1xuICAgIGdldDogclszXVxuICB9IDogNCA9PT0gaSA/IHtcbiAgICBzZXQ6IHJbM11cbiAgfSA6IHtcbiAgICB2YWx1ZTogclszXVxuICB9IDogMCAhPT0gaSAmJiAoZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgbikpLCAxID09PSBpID8gcCA9IHtcbiAgICBnZXQ6IGYuZ2V0LFxuICAgIHNldDogZi5zZXRcbiAgfSA6IDIgPT09IGkgPyBwID0gZi52YWx1ZSA6IDMgPT09IGkgPyBwID0gZi5nZXQgOiA0ID09PSBpICYmIChwID0gZi5zZXQpO1xuICBmb3IgKHZhciBnID0gYSA/IDIgOiAxLCBiID0gbS5sZW5ndGggLSAxOyBiID49IDA7IGIgLT0gZykge1xuICAgIHZhciBJO1xuICAgIGlmICh2b2lkIDAgIT09IChoID0gbWVtYmVyRGVjKG1bYl0sIGEgPyBtW2IgLSAxXSA6IHZvaWQgMCwgbiwgZiwgYywgaSwgcywgbywgcCwgbCwgdSkpKSBhc3NlcnRWYWxpZFJldHVyblZhbHVlKGksIGgpLCAwID09PSBpID8gSSA9IGggOiAxID09PSBpID8gKEkgPSBoLmluaXQsIHYgPSBoLmdldCB8fCBwLmdldCwgeSA9IGguc2V0IHx8IHAuc2V0LCBwID0ge1xuICAgICAgZ2V0OiB2LFxuICAgICAgc2V0OiB5XG4gICAgfSkgOiBwID0gaCwgdm9pZCAwICE9PSBJICYmICh2b2lkIDAgPT09IGQgPyBkID0gSSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZCA/IGQgPSBbZCwgSV0gOiBkLnB1c2goSSkpO1xuICB9XG4gIGlmICgwID09PSBpIHx8IDEgPT09IGkpIHtcbiAgICBpZiAodm9pZCAwID09PSBkKSBkID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH07ZWxzZSBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBkKSB7XG4gICAgICB2YXIgdyA9IGQ7XG4gICAgICBkID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IHQsIGEgPSB3Lmxlbmd0aCAtIDE7IGEgPj0gMDsgYS0tKSByID0gd1thXS5jYWxsKGUsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBNID0gZDtcbiAgICAgIGQgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICByZXR1cm4gTS5jYWxsKGUsIHQpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZS5wdXNoKGQpO1xuICB9XG4gIDAgIT09IGkgJiYgKDEgPT09IGkgPyAoZi5nZXQgPSBwLmdldCwgZi5zZXQgPSBwLnNldCkgOiAyID09PSBpID8gZi52YWx1ZSA9IHAgOiAzID09PSBpID8gZi5nZXQgPSBwIDogNCA9PT0gaSAmJiAoZi5zZXQgPSBwKSwgbyA/IDEgPT09IGkgPyAoZS5wdXNoKGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgcmV0dXJuIHAuZ2V0LmNhbGwoZSwgdCk7XG4gIH0pLCBlLnB1c2goZnVuY3Rpb24gKGUsIHQpIHtcbiAgICByZXR1cm4gcC5zZXQuY2FsbChlLCB0KTtcbiAgfSkpIDogMiA9PT0gaSA/IGUucHVzaChwKSA6IGUucHVzaChmdW5jdGlvbiAoZSwgdCkge1xuICAgIHJldHVybiBwLmNhbGwoZSwgdCk7XG4gIH0pIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4sIGYpKTtcbn1cbmZ1bmN0aW9uIGFwcGx5TWVtYmVyRGVjcyhlLCB0LCByLCBhKSB7XG4gIGZvciAodmFyIG4sIGksIHMsIG8gPSBbXSwgYyA9IG5ldyBNYXAoKSwgbCA9IG5ldyBNYXAoKSwgdSA9IDA7IHUgPCB0Lmxlbmd0aDsgdSsrKSB7XG4gICAgdmFyIGYgPSB0W3VdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGYpKSB7XG4gICAgICB2YXIgZCxcbiAgICAgICAgcCxcbiAgICAgICAgaCA9IGZbMV0sXG4gICAgICAgIHYgPSBmWzJdLFxuICAgICAgICB5ID0gZi5sZW5ndGggPiAzLFxuICAgICAgICBtID0gMTYgJiBoLFxuICAgICAgICBnID0gISEoOCAmIGgpLFxuICAgICAgICBiID0gcjtcbiAgICAgIGlmIChoICY9IDcsIGcgPyAoZCA9IGUsIDAgIT09IGggJiYgKHAgPSBpID0gaSB8fCBbXSksIHkgJiYgIXMgJiYgKHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gX2NoZWNrSW5SSFModCkgPT09IGU7XG4gICAgICB9KSwgYiA9IHMpIDogKGQgPSBlLnByb3RvdHlwZSwgMCAhPT0gaCAmJiAocCA9IG4gPSBuIHx8IFtdKSksIDAgIT09IGggJiYgIXkpIHtcbiAgICAgICAgdmFyIEkgPSBnID8gbCA6IGMsXG4gICAgICAgICAgdyA9IEkuZ2V0KHYpIHx8IDA7XG4gICAgICAgIGlmICghMCA9PT0gdyB8fCAzID09PSB3ICYmIDQgIT09IGggfHwgNCA9PT0gdyAmJiAzICE9PSBoKSB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZGVjb3JhdGUgYSBwdWJsaWMgbWV0aG9kL2FjY2Vzc29yIHRoYXQgaGFzIHRoZSBzYW1lIG5hbWUgYXMgYSBwcmV2aW91c2x5IGRlY29yYXRlZCBwdWJsaWMgbWV0aG9kL2FjY2Vzc29yLiBUaGlzIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBkZWNvcmF0b3JzIHBsdWdpbi4gUHJvcGVydHkgbmFtZSB3YXM6IFwiICsgdik7XG4gICAgICAgIEkuc2V0KHYsICEoIXcgJiYgaCA+IDIpIHx8IGgpO1xuICAgICAgfVxuICAgICAgYXBwbHlNZW1iZXJEZWMobywgZCwgZiwgbSwgdiwgaCwgZywgeSwgcCwgYiwgYSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwdXNoSW5pdGlhbGl6ZXJzKG8sIG4pLCBwdXNoSW5pdGlhbGl6ZXJzKG8sIGkpLCBvO1xufVxuZnVuY3Rpb24gcHVzaEluaXRpYWxpemVycyhlLCB0KSB7XG4gIHQgJiYgZS5wdXNoKGZ1bmN0aW9uIChlKSB7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB0W3JdLmNhbGwoZSk7XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gYXBwbHlDbGFzc0RlY3MoZSwgdCwgciwgYSkge1xuICBpZiAodC5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBuID0gW10sIGkgPSBlLCBzID0gZS5uYW1lLCBvID0gciA/IDIgOiAxLCBjID0gdC5sZW5ndGggLSAxOyBjID49IDA7IGMgLT0gbykge1xuICAgICAgdmFyIGwgPSB7XG4gICAgICAgIHY6ICExXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHUgPSB0W2NdLmNhbGwociA/IHRbYyAtIDFdIDogdm9pZCAwLCBpLCB7XG4gICAgICAgICAga2luZDogXCJjbGFzc1wiLFxuICAgICAgICAgIG5hbWU6IHMsXG4gICAgICAgICAgYWRkSW5pdGlhbGl6ZXI6IGNyZWF0ZUFkZEluaXRpYWxpemVyTWV0aG9kKG4sIGwpLFxuICAgICAgICAgIG1ldGFkYXRhOiBhXG4gICAgICAgIH0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbC52ID0gITA7XG4gICAgICB9XG4gICAgICB2b2lkIDAgIT09IHUgJiYgKGFzc2VydFZhbGlkUmV0dXJuVmFsdWUoNSwgdSksIGkgPSB1KTtcbiAgICB9XG4gICAgcmV0dXJuIFtkZWZpbmVNZXRhZGF0YShpLCBhKSwgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBuLmxlbmd0aDsgZSsrKSBuW2VdLmNhbGwoaSk7XG4gICAgfV07XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKGUsIHQpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBTeW1ib2wubWV0YWRhdGEgfHwgU3ltYm9sLmZvcihcIlN5bWJvbC5tZXRhZGF0YVwiKSwge1xuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgdmFsdWU6IHRcbiAgfSk7XG59XG5mdW5jdGlvbiBfYXBwbHlEZWNzMjMwNShlLCB0LCByLCBhLCBuLCBpKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDYpIHZhciBzID0gaVtTeW1ib2wubWV0YWRhdGEgfHwgU3ltYm9sLmZvcihcIlN5bWJvbC5tZXRhZGF0YVwiKV07XG4gIHZhciBvID0gT2JqZWN0LmNyZWF0ZSh2b2lkIDAgPT09IHMgPyBudWxsIDogcyksXG4gICAgYyA9IGFwcGx5TWVtYmVyRGVjcyhlLCB0LCBuLCBvKTtcbiAgcmV0dXJuIHIubGVuZ3RoIHx8IGRlZmluZU1ldGFkYXRhKGUsIG8pLCB7XG4gICAgZTogYyxcbiAgICBnZXQgYygpIHtcbiAgICAgIHJldHVybiBhcHBseUNsYXNzRGVjcyhlLCByLCBhLCBvKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBfY2hlY2tJblJIUyhlKSB7XG4gIGlmIChPYmplY3QoZSkgIT09IGUpIHRocm93IFR5cGVFcnJvcihcInJpZ2h0LWhhbmQgc2lkZSBvZiAnaW4nIHNob3VsZCBiZSBhbiBvYmplY3QsIGdvdCBcIiArIChudWxsICE9PSBlID8gdHlwZW9mIGUgOiBcIm51bGxcIikpO1xuICByZXR1cm4gZTtcbn1cblxuZXhwb3J0IHsgX2FwcGx5RGVjczIzMDUgYXMgYXBwbHlEZWNzMjMwNSwgX2NoZWNrSW5SSFMgYXMgY2hlY2tJblJIUyB9O1xuIiwgImZ1bmN0aW9uIEF1dG9CaW5kKG9yaWdpbmFsTWV0aG9kLCB7XG4gIG5hbWUsXG4gIGFkZEluaXRpYWxpemVyXG59KSB7XG4gIGFkZEluaXRpYWxpemVyKGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXNbbmFtZV0gPSBvcmlnaW5hbE1ldGhvZC5iaW5kKHRoaXMpO1xuXG4gIH0pO1xufVxuXG5leHBvcnQgeyBBdXRvQmluZCB9O1xuIiwgImZ1bmN0aW9uIHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0RXZlbnQgfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RFdmVudC9BYnN0cmFjdEV2ZW50Lm1qcyc7XG5cbmNsYXNzIERyYWdFdmVudCBleHRlbmRzIEFic3RyYWN0RXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcihkYXRhKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZTtcbiAgfVxuXG4gIGdldCBvcmlnaW5hbFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9yaWdpbmFsU291cmNlO1xuICB9XG5cbiAgZ2V0IG1pcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcbiAgfVxuXG4gIGdldCBzb3VyY2VDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VDb250YWluZXI7XG4gIH1cblxuICBnZXQgc2Vuc29yRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZW5zb3JFdmVudDtcbiAgfVxuXG4gIGdldCBvcmlnaW5hbEV2ZW50KCkge1xuICAgIGlmICh0aGlzLnNlbnNvckV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5EcmFnRXZlbnQudHlwZSA9ICdkcmFnJztcbmNsYXNzIERyYWdTdGFydEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XG5cbkRyYWdTdGFydEV2ZW50LnR5cGUgPSAnZHJhZzpzdGFydCc7XG5EcmFnU3RhcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcbmNsYXNzIERyYWdNb3ZlRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cblxuRHJhZ01vdmVFdmVudC50eXBlID0gJ2RyYWc6bW92ZSc7XG5cbmNsYXNzIERyYWdPdmVyRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xuXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcbiAgfVxuXG4gIGdldCBvdmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlcjtcbiAgfVxufVxuRHJhZ092ZXJFdmVudC50eXBlID0gJ2RyYWc6b3Zlcic7XG5EcmFnT3ZlckV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuZnVuY3Rpb24gaXNEcmFnT3ZlckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSBEcmFnT3ZlckV2ZW50LnR5cGU7XG59XG5cbmNsYXNzIERyYWdPdXRFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XG5cbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xuICB9XG5cbiAgZ2V0IG92ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xuICB9XG59XG5cbkRyYWdPdXRFdmVudC50eXBlID0gJ2RyYWc6b3V0JztcblxuY2xhc3MgRHJhZ092ZXJDb250YWluZXJFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XG5cbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xuICB9XG59XG5cbkRyYWdPdmVyQ29udGFpbmVyRXZlbnQudHlwZSA9ICdkcmFnOm92ZXI6Y29udGFpbmVyJztcblxuY2xhc3MgRHJhZ091dENvbnRhaW5lckV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcblxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XG4gIH1cbn1cblxuRHJhZ091dENvbnRhaW5lckV2ZW50LnR5cGUgPSAnZHJhZzpvdXQ6Y29udGFpbmVyJztcblxuY2xhc3MgRHJhZ1ByZXNzdXJlRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xuXG4gIGdldCBwcmVzc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnByZXNzdXJlO1xuICB9XG59XG5cbkRyYWdQcmVzc3VyZUV2ZW50LnR5cGUgPSAnZHJhZzpwcmVzc3VyZSc7XG5jbGFzcyBEcmFnU3RvcEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XG5cbkRyYWdTdG9wRXZlbnQudHlwZSA9ICdkcmFnOnN0b3AnO1xuRHJhZ1N0b3BFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcbmNsYXNzIERyYWdTdG9wcGVkRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cbkRyYWdTdG9wcGVkRXZlbnQudHlwZSA9ICdkcmFnOnN0b3BwZWQnO1xuXG5leHBvcnQgeyBEcmFnRXZlbnQsIERyYWdNb3ZlRXZlbnQsIERyYWdPdXRDb250YWluZXJFdmVudCwgRHJhZ091dEV2ZW50LCBEcmFnT3ZlckNvbnRhaW5lckV2ZW50LCBEcmFnT3ZlckV2ZW50LCBEcmFnUHJlc3N1cmVFdmVudCwgRHJhZ1N0YXJ0RXZlbnQsIERyYWdTdG9wRXZlbnQsIERyYWdTdG9wcGVkRXZlbnQsIGlzRHJhZ092ZXJFdmVudCB9O1xuIiwgImltcG9ydCB7IGFwcGx5RGVjczIzMDUgYXMgX2FwcGx5RGVjczIzMDUgfSBmcm9tICcuLi8uLi9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLm1qcyc7XG5pbXBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMnO1xuaW1wb3J0IHsgQXV0b0JpbmQgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMvZGVjb3JhdG9ycy9BdXRvQmluZC5tanMnO1xuaW1wb3J0IHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzL3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUvcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZS5tanMnO1xuaW1wb3J0IHsgaXNEcmFnT3ZlckV2ZW50IH0gZnJvbSAnLi4vLi4vRHJhZ2dhYmxlL0RyYWdFdmVudC9EcmFnRXZlbnQubWpzJztcblxudmFyIF9pbml0UHJvdG8sIF9jbGFzcztcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuY2xhc3MgUmVzaXplTWlycm9yIGV4dGVuZHMgQWJzdHJhY3RQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIF9pbml0UHJvdG8oc3VwZXIoZHJhZ2dhYmxlKSk7XG5cbiAgICB0aGlzLmxhc3RXaWR0aCA9IDA7XG5cbiAgICB0aGlzLmxhc3RIZWlnaHQgPSAwO1xuXG4gICAgdGhpcy5taXJyb3IgPSBudWxsO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXMub25NaXJyb3JDcmVhdGVkKS5vbignZHJhZzpvdmVyJywgdGhpcy5vbkRyYWdPdmVyKS5vbignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXMub25EcmFnT3Zlcik7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXMub25NaXJyb3JDcmVhdGVkKS5vZmYoJ21pcnJvcjpkZXN0cm95JywgdGhpcy5vbk1pcnJvckRlc3Ryb3kpLm9mZignZHJhZzpvdmVyJywgdGhpcy5vbkRyYWdPdmVyKS5vZmYoJ2RyYWc6b3Zlcjpjb250YWluZXInLCB0aGlzLm9uRHJhZ092ZXIpO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5yZXNpemVNaXJyb3IgfHwge307XG4gIH1cblxuICBvbk1pcnJvckNyZWF0ZWQoe1xuICAgIG1pcnJvclxuICB9KSB7XG4gICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XG4gIH1cblxuICBvbk1pcnJvckRlc3Ryb3koKSB7XG4gICAgdGhpcy5taXJyb3IgPSBudWxsO1xuICB9XG5cbiAgb25EcmFnT3ZlcihkcmFnRXZlbnQpIHtcbiAgICB0aGlzLnJlc2l6ZShkcmFnRXZlbnQpO1xuICB9XG5cbiAgcmVzaXplKGRyYWdFdmVudCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBsZXQgb3ZlciA9IG51bGw7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG92ZXJDb250YWluZXJcbiAgICAgIH0gPSBkcmFnRXZlbnQ7XG4gICAgICBpZiAodGhpcy5taXJyb3IgPT0gbnVsbCB8fCB0aGlzLm1pcnJvci5wYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWlycm9yLnBhcmVudE5vZGUgIT09IG92ZXJDb250YWluZXIpIHtcbiAgICAgICAgb3ZlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1pcnJvcik7XG4gICAgICB9XG4gICAgICBpZiAoaXNEcmFnT3ZlckV2ZW50KGRyYWdFdmVudCkpIHtcbiAgICAgICAgb3ZlciA9IGRyYWdFdmVudC5vdmVyO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlckVsZW1lbnQgPSBvdmVyIHx8IHRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpWzBdO1xuICAgICAgaWYgKCFvdmVyRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb3ZlclJlY3QgPSBvdmVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yID09IG51bGwgfHwgdGhpcy5sYXN0SGVpZ2h0ID09PSBvdmVyUmVjdC5oZWlnaHQgJiYgdGhpcy5sYXN0V2lkdGggPT09IG92ZXJSZWN0LndpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWlycm9yLnN0eWxlLndpZHRoID0gYCR7b3ZlclJlY3Qud2lkdGh9cHhgO1xuICAgICAgICB0aGlzLm1pcnJvci5zdHlsZS5oZWlnaHQgPSBgJHtvdmVyUmVjdC5oZWlnaHR9cHhgO1xuICAgICAgICB0aGlzLmxhc3RXaWR0aCA9IG92ZXJSZWN0LndpZHRoO1xuICAgICAgICB0aGlzLmxhc3RIZWlnaHQgPSBvdmVyUmVjdC5oZWlnaHQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuX2NsYXNzID0gUmVzaXplTWlycm9yO1xuW19pbml0UHJvdG9dID0gX2FwcGx5RGVjczIzMDUoX2NsYXNzLCBbW0F1dG9CaW5kLCAyLCBcIm9uTWlycm9yQ3JlYXRlZFwiXSwgW0F1dG9CaW5kLCAyLCBcIm9uTWlycm9yRGVzdHJveVwiXSwgW0F1dG9CaW5kLCAyLCBcIm9uRHJhZ092ZXJcIl1dLCBbXSwgMCwgdm9pZCAwLCBBYnN0cmFjdFBsdWdpbikuZTtcblxuZXhwb3J0IHsgUmVzaXplTWlycm9yIGFzIGRlZmF1bHQsIGRlZmF1bHRPcHRpb25zIH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RFdmVudCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9BYnN0cmFjdEV2ZW50L0Fic3RyYWN0RXZlbnQubWpzJztcblxuY2xhc3MgU25hcEV2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgZ2V0IGRyYWdFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudDtcbiAgfVxuXG4gIGdldCBzbmFwcGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zbmFwcGFibGU7XG4gIH1cbn1cblxuU25hcEV2ZW50LnR5cGUgPSAnc25hcCc7XG5jbGFzcyBTbmFwSW5FdmVudCBleHRlbmRzIFNuYXBFdmVudCB7fVxuXG5TbmFwSW5FdmVudC50eXBlID0gJ3NuYXA6aW4nO1xuU25hcEluRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5jbGFzcyBTbmFwT3V0RXZlbnQgZXh0ZW5kcyBTbmFwRXZlbnQge31cblNuYXBPdXRFdmVudC50eXBlID0gJ3NuYXA6b3V0JztcblNuYXBPdXRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuZXhwb3J0IHsgU25hcEV2ZW50LCBTbmFwSW5FdmVudCwgU25hcE91dEV2ZW50IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RQbHVnaW4gfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RQbHVnaW4vQWJzdHJhY3RQbHVnaW4ubWpzJztcbmltcG9ydCB7IFNuYXBJbkV2ZW50LCBTbmFwT3V0RXZlbnQgfSBmcm9tICcuL1NuYXBwYWJsZUV2ZW50L1NuYXBwYWJsZUV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xuY29uc3Qgb25EcmFnT3V0ID0gU3ltYm9sKCdvbkRyYWdPdXQnKTtcbmNvbnN0IG9uTWlycm9yQ3JlYXRlZCA9IFN5bWJvbCgnb25NaXJyb3JDcmVhdGVkJyk7XG5jb25zdCBvbk1pcnJvckRlc3Ryb3kgPSBTeW1ib2woJ29uTWlycm9yRGVzdHJveScpO1xuXG5jbGFzcyBTbmFwcGFibGUgZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIHRoaXMuZmlyc3RTb3VyY2UgPSBudWxsO1xuXG4gICAgdGhpcy5taXJyb3IgPSBudWxsO1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdPdXRdID0gdGhpc1tvbkRyYWdPdXRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1pcnJvckRlc3Ryb3ldID0gdGhpc1tvbk1pcnJvckRlc3Ryb3ldLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9uKCdkcm9wcGFibGU6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcm9wcGFibGU6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub2ZmKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vZmYoJ2RyYWc6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vZmYoJ2Ryb3BwYWJsZTpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcm9wcGFibGU6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vZmYoJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vZmYoJ21pcnJvcjpkZXN0cm95JywgdGhpc1tvbk1pcnJvckRlc3Ryb3ldKTtcbiAgfVxuXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpcnN0U291cmNlID0gZXZlbnQuc291cmNlO1xuICB9XG5cbiAgW29uRHJhZ1N0b3BdKCkge1xuICAgIHRoaXMuZmlyc3RTb3VyY2UgPSBudWxsO1xuICB9XG5cbiAgW29uRHJhZ092ZXJdKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gZXZlbnQuc291cmNlIHx8IGV2ZW50LmRyYWdFdmVudC5zb3VyY2U7XG4gICAgaWYgKHNvdXJjZSA9PT0gdGhpcy5maXJzdFNvdXJjZSkge1xuICAgICAgdGhpcy5maXJzdFNvdXJjZSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNuYXBJbkV2ZW50ID0gbmV3IFNuYXBJbkV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXG4gICAgfSk7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihzbmFwSW5FdmVudCk7XG4gICAgaWYgKHNuYXBJbkV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWlycm9yKSB7XG4gICAgICB0aGlzLm1pcnJvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICBzb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XG4gICAgc291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcbiAgICB9LCB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnBsYWNlZFRpbWVvdXQpO1xuICB9XG5cbiAgW29uRHJhZ091dF0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwgZXZlbnQuZHJhZ0V2ZW50LnNvdXJjZTtcbiAgICBjb25zdCBzbmFwT3V0RXZlbnQgPSBuZXcgU25hcE91dEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXG4gICAgfSk7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihzbmFwT3V0RXZlbnQpO1xuICAgIGlmIChzbmFwT3V0RXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5taXJyb3IpIHtcbiAgICAgIHRoaXMubWlycm9yLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9XG4gICAgc291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOmRyYWdnaW5nJykpO1xuICB9XG5cbiAgW29uTWlycm9yQ3JlYXRlZF0oe1xuICAgIG1pcnJvclxuICB9KSB7XG4gICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XG4gIH1cblxuICBbb25NaXJyb3JEZXN0cm95XSgpIHtcbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgU25hcHBhYmxlIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBhcHBseURlY3MyMzA1IGFzIF9hcHBseURlY3MyMzA1IH0gZnJvbSAnLi4vLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5tanMnO1xuaW1wb3J0IHsgQWJzdHJhY3RQbHVnaW4gfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RQbHVnaW4vQWJzdHJhY3RQbHVnaW4ubWpzJztcbmltcG9ydCB7IEF1dG9CaW5kIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzL2RlY29yYXRvcnMvQXV0b0JpbmQubWpzJztcblxudmFyIF9pbml0UHJvdG8sIF9jbGFzcztcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGR1cmF0aW9uOiAxNTAsXG4gIGVhc2luZ0Z1bmN0aW9uOiAnZWFzZS1pbi1vdXQnLFxuICBob3Jpem9udGFsOiBmYWxzZVxufTtcblxuY2xhc3MgU3dhcEFuaW1hdGlvbiBleHRlbmRzIEFic3RyYWN0UGx1Z2luIHtcblxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcbiAgICBfaW5pdFByb3RvKHN1cGVyKGRyYWdnYWJsZSkpO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi50aGlzLmdldE9wdGlvbnMoKVxuICAgIH07XG5cbiAgICB0aGlzLmxhc3RBbmltYXRpb25GcmFtZSA9IG51bGw7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ3NvcnRhYmxlOnNvcnRlZCcsIHRoaXMub25Tb3J0YWJsZVNvcnRlZCk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdzb3J0YWJsZTpzb3J0ZWQnLCB0aGlzLm9uU29ydGFibGVTb3J0ZWQpO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zd2FwQW5pbWF0aW9uIHx8IHt9O1xuICB9XG5cbiAgb25Tb3J0YWJsZVNvcnRlZCh7XG4gICAgb2xkSW5kZXgsXG4gICAgbmV3SW5kZXgsXG4gICAgZHJhZ0V2ZW50XG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2UsXG4gICAgICBvdmVyXG4gICAgfSA9IGRyYWdFdmVudDtcbiAgICBpZiAodGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAob2xkSW5kZXggPj0gbmV3SW5kZXgpIHtcbiAgICAgICAgYW5pbWF0ZShzb3VyY2UsIG92ZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRlKG92ZXIsIHNvdXJjZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5fY2xhc3MgPSBTd2FwQW5pbWF0aW9uO1xuW19pbml0UHJvdG9dID0gX2FwcGx5RGVjczIzMDUoX2NsYXNzLCBbW0F1dG9CaW5kLCAyLCBcIm9uU29ydGFibGVTb3J0ZWRcIl1dLCBbXSwgMCwgdm9pZCAwLCBBYnN0cmFjdFBsdWdpbikuZTtcbmZ1bmN0aW9uIGFuaW1hdGUoZnJvbSwgdG8sIHtcbiAgZHVyYXRpb24sXG4gIGVhc2luZ0Z1bmN0aW9uLFxuICBob3Jpem9udGFsXG59KSB7XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBbZnJvbSwgdG9dKSB7XG4gICAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICB9XG4gIGlmIChob3Jpem9udGFsKSB7XG4gICAgY29uc3Qgd2lkdGggPSBmcm9tLm9mZnNldFdpZHRoO1xuICAgIGZyb20uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7d2lkdGh9cHgsIDAsIDApYDtcbiAgICB0by5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoLSR7d2lkdGh9cHgsIDAsIDApYDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBoZWlnaHQgPSBmcm9tLm9mZnNldEhlaWdodDtcbiAgICBmcm9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwLCAke2hlaWdodH1weCwgMClgO1xuICAgIHRvLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwLCAtJHtoZWlnaHR9cHgsIDApYDtcbiAgfVxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbZnJvbSwgdG9dKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQpO1xuICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gYHRyYW5zZm9ybSAke2R1cmF0aW9ufW1zICR7ZWFzaW5nRnVuY3Rpb259YDtcbiAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRFbGVtZW50T25UcmFuc2l0aW9uRW5kKGV2ZW50KSB7XG4gIGlmIChldmVudC50YXJnZXQgPT0gbnVsbCB8fCAhaXNIVE1MRWxlbWVudChldmVudC50YXJnZXQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGV2ZW50LnRhcmdldC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gIGV2ZW50LnRhcmdldC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gIGV2ZW50LnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgcmVzZXRFbGVtZW50T25UcmFuc2l0aW9uRW5kKTtcbn1cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQoZXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIEJvb2xlYW4oJ3N0eWxlJyBpbiBldmVudFRhcmdldCk7XG59XG5cbmV4cG9ydCB7IFN3YXBBbmltYXRpb24gYXMgZGVmYXVsdCwgZGVmYXVsdE9wdGlvbnMgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMnO1xuXG5jb25zdCBvblNvcnRhYmxlU29ydGVkID0gU3ltYm9sKCdvblNvcnRhYmxlU29ydGVkJyk7XG5jb25zdCBvblNvcnRhYmxlU29ydCA9IFN5bWJvbCgnb25Tb3J0YWJsZVNvcnQnKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGR1cmF0aW9uOiAxNTAsXG4gIGVhc2luZ0Z1bmN0aW9uOiAnZWFzZS1pbi1vdXQnXG59O1xuXG5jbGFzcyBTb3J0QW5pbWF0aW9uIGV4dGVuZHMgQWJzdHJhY3RQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIHN1cGVyKGRyYWdnYWJsZSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLnRoaXMuZ2V0T3B0aW9ucygpXG4gICAgfTtcblxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICB0aGlzLmxhc3RFbGVtZW50cyA9IFtdO1xuICAgIHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0gPSB0aGlzW29uU29ydGFibGVTb3J0ZWRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvblNvcnRhYmxlU29ydF0gPSB0aGlzW29uU29ydGFibGVTb3J0XS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdzb3J0YWJsZTpzb3J0JywgdGhpc1tvblNvcnRhYmxlU29ydF0pO1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdzb3J0YWJsZTpzb3J0ZWQnLCB0aGlzW29uU29ydGFibGVTb3J0ZWRdKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ3NvcnRhYmxlOnNvcnQnLCB0aGlzW29uU29ydGFibGVTb3J0XSk7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdzb3J0YWJsZTpzb3J0ZWQnLCB0aGlzW29uU29ydGFibGVTb3J0ZWRdKTtcbiAgfVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuc29ydEFuaW1hdGlvbiB8fCB7fTtcbiAgfVxuXG4gIFtvblNvcnRhYmxlU29ydF0oe1xuICAgIGRyYWdFdmVudFxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgc291cmNlQ29udGFpbmVyXG4gICAgfSA9IGRyYWdFdmVudDtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKHNvdXJjZUNvbnRhaW5lcik7XG4gICAgdGhpcy5sYXN0RWxlbWVudHMgPSBBcnJheS5mcm9tKGVsZW1lbnRzKS5tYXAoZWwgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9tRWw6IGVsLFxuICAgICAgICBvZmZzZXRUb3A6IGVsLm9mZnNldFRvcCxcbiAgICAgICAgb2Zmc2V0TGVmdDogZWwub2Zmc2V0TGVmdFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIFtvblNvcnRhYmxlU29ydGVkXSh7XG4gICAgb2xkSW5kZXgsXG4gICAgbmV3SW5kZXhcbiAgfSkge1xuICAgIGlmIChvbGRJbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWZmZWN0ZWRFbGVtZW50cyA9IFtdO1xuICAgIGxldCBzdGFydDtcbiAgICBsZXQgZW5kO1xuICAgIGxldCBudW07XG4gICAgaWYgKG9sZEluZGV4ID4gbmV3SW5kZXgpIHtcbiAgICAgIHN0YXJ0ID0gbmV3SW5kZXg7XG4gICAgICBlbmQgPSBvbGRJbmRleCAtIDE7XG4gICAgICBudW0gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IG9sZEluZGV4ICsgMTtcbiAgICAgIGVuZCA9IG5ld0luZGV4O1xuICAgICAgbnVtID0gLTE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgZnJvbSA9IHRoaXMubGFzdEVsZW1lbnRzW2ldO1xuICAgICAgY29uc3QgdG8gPSB0aGlzLmxhc3RFbGVtZW50c1tpICsgbnVtXTtcbiAgICAgIGVmZmVjdGVkRWxlbWVudHMucHVzaCh7XG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvXG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUpO1xuXG4gICAgdGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgZWZmZWN0ZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4gYW5pbWF0ZShlbGVtZW50LCB0aGlzLm9wdGlvbnMpKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhbmltYXRlKHtcbiAgZnJvbSxcbiAgdG9cbn0sIHtcbiAgZHVyYXRpb24sXG4gIGVhc2luZ0Z1bmN0aW9uXG59KSB7XG4gIGNvbnN0IGRvbUVsID0gZnJvbS5kb21FbDtcbiAgY29uc3QgeCA9IGZyb20ub2Zmc2V0TGVmdCAtIHRvLm9mZnNldExlZnQ7XG4gIGNvbnN0IHkgPSBmcm9tLm9mZnNldFRvcCAtIHRvLm9mZnNldFRvcDtcbiAgZG9tRWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgZG9tRWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHt5fXB4LCAwKWA7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgZG9tRWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XG4gICAgZG9tRWwuc3R5bGUudHJhbnNpdGlvbiA9IGB0cmFuc2Zvcm0gJHtkdXJhdGlvbn1tcyAke2Vhc2luZ0Z1bmN0aW9ufWA7XG4gICAgZG9tRWwuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQoZXZlbnQpIHtcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgZXZlbnQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQpO1xufVxuXG5leHBvcnQgeyBTb3J0QW5pbWF0aW9uIGFzIGRlZmF1bHQsIGRlZmF1bHRPcHRpb25zIH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RQbHVnaW4gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvQWJzdHJhY3RQbHVnaW4vQWJzdHJhY3RQbHVnaW4ubWpzJztcblxuY29uc3Qgb25Jbml0aWFsaXplID0gU3ltYm9sKCdvbkluaXRpYWxpemUnKTtcbmNvbnN0IG9uRGVzdHJveSA9IFN5bWJvbCgnb25EZXN0cm95Jyk7XG5jb25zdCBhbm5vdW5jZUV2ZW50ID0gU3ltYm9sKCdhbm5vdW5jZUV2ZW50Jyk7XG5jb25zdCBhbm5vdW5jZU1lc3NhZ2UgPSBTeW1ib2woJ2Fubm91bmNlTWVzc2FnZScpO1xuY29uc3QgQVJJQV9SRUxFVkFOVCA9ICdhcmlhLXJlbGV2YW50JztcbmNvbnN0IEFSSUFfQVRPTUlDID0gJ2FyaWEtYXRvbWljJztcbmNvbnN0IEFSSUFfTElWRSA9ICdhcmlhLWxpdmUnO1xuY29uc3QgUk9MRSA9ICdyb2xlJztcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGV4cGlyZTogNzAwMFxufTtcblxuY2xhc3MgQW5ub3VuY2VtZW50IGV4dGVuZHMgQWJzdHJhY3RQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIHN1cGVyKGRyYWdnYWJsZSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLnRoaXMuZ2V0T3B0aW9ucygpXG4gICAgfTtcblxuICAgIHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kID0gdGhpcy5kcmFnZ2FibGUudHJpZ2dlcjtcbiAgICB0aGlzW29uSW5pdGlhbGl6ZV0gPSB0aGlzW29uSW5pdGlhbGl6ZV0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRGVzdHJveV0gPSB0aGlzW29uRGVzdHJveV0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9O1xuICB9XG5cbiAgW2Fubm91bmNlRXZlbnRdKGV2ZW50KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMub3B0aW9uc1tldmVudC50eXBlXTtcbiAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXNbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKGV2ZW50KSk7XG4gICAgfVxuICB9XG5cbiAgW2Fubm91bmNlTWVzc2FnZV0obWVzc2FnZSkge1xuICAgIGFubm91bmNlKG1lc3NhZ2UsIHtcbiAgICAgIGV4cGlyZTogdGhpcy5vcHRpb25zLmV4cGlyZVxuICAgIH0pO1xuICB9XG5cbiAgW29uSW5pdGlhbGl6ZV0oKSB7XG5cbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyID0gZXZlbnQgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpc1thbm5vdW5jZUV2ZW50XShldmVudCk7XG4gICAgICB9IGZpbmFsbHkge1xuXG4gICAgICAgIHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kLmNhbGwodGhpcy5kcmFnZ2FibGUsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgW29uRGVzdHJveV0oKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlciA9IHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kO1xuICB9XG59XG5cbmNvbnN0IGxpdmVSZWdpb24gPSBjcmVhdGVSZWdpb24oKTtcblxuZnVuY3Rpb24gYW5ub3VuY2UobWVzc2FnZSwge1xuICBleHBpcmVcbn0pIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgbGl2ZVJlZ2lvbi5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGxpdmVSZWdpb24ucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH0sIGV4cGlyZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZ2lvbigpIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCAnZHJhZ2dhYmxlLWxpdmUtcmVnaW9uJyk7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfUkVMRVZBTlQsICdhZGRpdGlvbnMnKTtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVJJQV9BVE9NSUMsICd0cnVlJyk7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfTElWRSwgJ2Fzc2VydGl2ZScpO1xuICBlbGVtZW50LnNldEF0dHJpYnV0ZShST0xFLCAnbG9nJyk7XG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBlbGVtZW50LnN0eWxlLndpZHRoID0gJzFweCc7XG4gIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzFweCc7XG4gIGVsZW1lbnQuc3R5bGUudG9wID0gJy0xcHgnO1xuICBlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpdmVSZWdpb24pO1xufSk7XG5cbmV4cG9ydCB7IEFubm91bmNlbWVudCBhcyBkZWZhdWx0LCBkZWZhdWx0T3B0aW9ucyB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0UGx1Z2luIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL0Fic3RyYWN0UGx1Z2luL0Fic3RyYWN0UGx1Z2luLm1qcyc7XG5cbmNvbnN0IG9uSW5pdGlhbGl6ZSA9IFN5bWJvbCgnb25Jbml0aWFsaXplJyk7XG5jb25zdCBvbkRlc3Ryb3kgPSBTeW1ib2woJ29uRGVzdHJveScpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG5jbGFzcyBGb2N1c2FibGUgZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4udGhpcy5nZXRPcHRpb25zKClcbiAgICB9O1xuICAgIHRoaXNbb25Jbml0aWFsaXplXSA9IHRoaXNbb25Jbml0aWFsaXplXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EZXN0cm95XSA9IHRoaXNbb25EZXN0cm95XS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnZ2FibGU6aW5pdGlhbGl6ZScsIHRoaXNbb25Jbml0aWFsaXplXSkub24oJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWdnYWJsZTppbml0aWFsaXplJywgdGhpc1tvbkluaXRpYWxpemVdKS5vZmYoJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcblxuICAgIHRoaXNbb25EZXN0cm95XSgpO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5mb2N1c2FibGUgfHwge307XG4gIH1cblxuICBnZXRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuZHJhZ2dhYmxlLmNvbnRhaW5lcnMsIC4uLnRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzKCldO1xuICB9XG5cbiAgW29uSW5pdGlhbGl6ZV0oKSB7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5nZXRFbGVtZW50cygpLmZvckVhY2goZWxlbWVudCA9PiBkZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCkpO1xuICAgIH0pO1xuICB9XG5cbiAgW29uRGVzdHJveV0oKSB7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5nZXRFbGVtZW50cygpLmZvckVhY2goZWxlbWVudCA9PiBzdHJpcEVsZW1lbnQoZWxlbWVudCkpO1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleCA9IFtdO1xuXG5mdW5jdGlvbiBkZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCBoYXNNaXNzaW5nVGFiSW5kZXggPSBCb29sZWFuKCFlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBlbGVtZW50LnRhYkluZGV4ID09PSAtMSk7XG4gIGlmIChoYXNNaXNzaW5nVGFiSW5kZXgpIHtcbiAgICBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXgucHVzaChlbGVtZW50KTtcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcEVsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCB0YWJJbmRleEVsZW1lbnRQb3NpdGlvbiA9IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5pbmRleE9mKGVsZW1lbnQpO1xuICBpZiAodGFiSW5kZXhFbGVtZW50UG9zaXRpb24gIT09IC0xKSB7XG4gICAgZWxlbWVudC50YWJJbmRleCA9IC0xO1xuICAgIGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5zcGxpY2UodGFiSW5kZXhFbGVtZW50UG9zaXRpb24sIDEpO1xuICB9XG59XG5cbmV4cG9ydCB7IEZvY3VzYWJsZSBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RFdmVudCB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9BYnN0cmFjdEV2ZW50L0Fic3RyYWN0RXZlbnQubWpzJztcblxuY2xhc3MgTWlycm9yRXZlbnQgZXh0ZW5kcyBBYnN0cmFjdEV2ZW50IHtcblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBzb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2U7XG4gIH1cblxuICBnZXQgb3JpZ2luYWxTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbFNvdXJjZTtcbiAgfVxuXG4gIGdldCBzb3VyY2VDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VDb250YWluZXI7XG4gIH1cblxuICBnZXQgc2Vuc29yRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZW5zb3JFdmVudDtcbiAgfVxuXG4gIGdldCBkcmFnRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XG4gIH1cblxuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcbiAgICBpZiAodGhpcy5zZW5zb3JFdmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuY2xhc3MgTWlycm9yQ3JlYXRlRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7fVxuTWlycm9yQ3JlYXRlRXZlbnQudHlwZSA9ICdtaXJyb3I6Y3JlYXRlJztcblxuY2xhc3MgTWlycm9yQ3JlYXRlZEV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xuXG4gIGdldCBtaXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XG4gIH1cbn1cbk1pcnJvckNyZWF0ZWRFdmVudC50eXBlID0gJ21pcnJvcjpjcmVhdGVkJztcblxuY2xhc3MgTWlycm9yQXR0YWNoZWRFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcblxuICBnZXQgbWlycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xuICB9XG59XG5NaXJyb3JBdHRhY2hlZEV2ZW50LnR5cGUgPSAnbWlycm9yOmF0dGFjaGVkJztcblxuY2xhc3MgTWlycm9yTW92ZUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xuXG4gIGdldCBtaXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XG4gIH1cblxuICBnZXQgcGFzc2VkVGhyZXNoWCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnBhc3NlZFRocmVzaFg7XG4gIH1cblxuICBnZXQgcGFzc2VkVGhyZXNoWSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnBhc3NlZFRocmVzaFk7XG4gIH1cbn1cbk1pcnJvck1vdmVFdmVudC50eXBlID0gJ21pcnJvcjptb3ZlJztcbk1pcnJvck1vdmVFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuY2xhc3MgTWlycm9yTW92ZWRFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcblxuICBnZXQgbWlycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xuICB9XG5cbiAgZ2V0IHBhc3NlZFRocmVzaFgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wYXNzZWRUaHJlc2hYO1xuICB9XG5cbiAgZ2V0IHBhc3NlZFRocmVzaFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wYXNzZWRUaHJlc2hZO1xuICB9XG59XG5NaXJyb3JNb3ZlZEV2ZW50LnR5cGUgPSAnbWlycm9yOm1vdmVkJztcblxuY2xhc3MgTWlycm9yRGVzdHJveUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xuXG4gIGdldCBtaXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XG4gIH1cbn1cbk1pcnJvckRlc3Ryb3lFdmVudC50eXBlID0gJ21pcnJvcjpkZXN0cm95Jztcbk1pcnJvckRlc3Ryb3lFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuZXhwb3J0IHsgTWlycm9yQXR0YWNoZWRFdmVudCwgTWlycm9yQ3JlYXRlRXZlbnQsIE1pcnJvckNyZWF0ZWRFdmVudCwgTWlycm9yRGVzdHJveUV2ZW50LCBNaXJyb3JFdmVudCwgTWlycm9yTW92ZUV2ZW50LCBNaXJyb3JNb3ZlZEV2ZW50IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RQbHVnaW4gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvQWJzdHJhY3RQbHVnaW4vQWJzdHJhY3RQbHVnaW4ubWpzJztcbmltcG9ydCB7IE1pcnJvckNyZWF0ZUV2ZW50LCBNaXJyb3JDcmVhdGVkRXZlbnQsIE1pcnJvckF0dGFjaGVkRXZlbnQsIE1pcnJvck1vdmVFdmVudCwgTWlycm9yRGVzdHJveUV2ZW50LCBNaXJyb3JNb3ZlZEV2ZW50IH0gZnJvbSAnLi9NaXJyb3JFdmVudC9NaXJyb3JFdmVudC5tanMnO1xuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IG9uTWlycm9yQ3JlYXRlZCA9IFN5bWJvbCgnb25NaXJyb3JDcmVhdGVkJyk7XG5jb25zdCBvbk1pcnJvck1vdmUgPSBTeW1ib2woJ29uTWlycm9yTW92ZScpO1xuY29uc3Qgb25TY3JvbGwgPSBTeW1ib2woJ29uU2Nyb2xsJyk7XG5jb25zdCBnZXRBcHBlbmRhYmxlQ29udGFpbmVyID0gU3ltYm9sKCdnZXRBcHBlbmRhYmxlQ29udGFpbmVyJyk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBjb25zdHJhaW5EaW1lbnNpb25zOiBmYWxzZSxcbiAgeEF4aXM6IHRydWUsXG4gIHlBeGlzOiB0cnVlLFxuICBjdXJzb3JPZmZzZXRYOiBudWxsLFxuICBjdXJzb3JPZmZzZXRZOiBudWxsLFxuICB0aHJlc2hvbGRYOiBudWxsLFxuICB0aHJlc2hvbGRZOiBudWxsXG59O1xuXG5jbGFzcyBNaXJyb3IgZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4udGhpcy5nZXRPcHRpb25zKClcbiAgICB9O1xuXG4gICAgdGhpcy5zY3JvbGxPZmZzZXQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG5cbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7XG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZXG4gICAgfTtcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25NaXJyb3JDcmVhdGVkXSA9IHRoaXNbb25NaXJyb3JDcmVhdGVkXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25NaXJyb3JNb3ZlXSA9IHRoaXNbb25NaXJyb3JNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25TY3JvbGxdID0gdGhpc1tvblNjcm9sbF0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9uKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub24oJ21pcnJvcjptb3ZlJywgdGhpc1tvbk1pcnJvck1vdmVdKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9mZignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9mZignbWlycm9yOm1vdmUnLCB0aGlzW29uTWlycm9yTW92ZV0pO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5taXJyb3IgfHwge307XG4gIH1cbiAgW29uRHJhZ1N0YXJ0XShkcmFnRXZlbnQpIHtcbiAgICBpZiAoZHJhZ0V2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpc1tvblNjcm9sbF0sIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7XG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50XG4gICAgfSA9IGRyYWdFdmVudDtcblxuICAgIHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50ID0ge1xuICAgICAgeDogc2Vuc29yRXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IHNlbnNvckV2ZW50LmNsaWVudFlcbiAgICB9O1xuICAgIGNvbnN0IG1pcnJvckNyZWF0ZUV2ZW50ID0gbmV3IE1pcnJvckNyZWF0ZUV2ZW50KHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgc291cmNlQ29udGFpbmVyLFxuICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICBkcmFnRXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckNyZWF0ZUV2ZW50KTtcbiAgICBpZiAoaXNOYXRpdmVEcmFnRXZlbnQoc2Vuc29yRXZlbnQpIHx8IG1pcnJvckNyZWF0ZUV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXBwZW5kYWJsZUNvbnRhaW5lciA9IHRoaXNbZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcl0oc291cmNlKSB8fCBzb3VyY2VDb250YWluZXI7XG4gICAgdGhpcy5taXJyb3IgPSBzb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgIGNvbnN0IG1pcnJvckNyZWF0ZWRFdmVudCA9IG5ldyBNaXJyb3JDcmVhdGVkRXZlbnQoe1xuICAgICAgc291cmNlLFxuICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICBzb3VyY2VDb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIGRyYWdFdmVudCxcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcbiAgICB9KTtcbiAgICBjb25zdCBtaXJyb3JBdHRhY2hlZEV2ZW50ID0gbmV3IE1pcnJvckF0dGFjaGVkRXZlbnQoe1xuICAgICAgc291cmNlLFxuICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICBzb3VyY2VDb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIGRyYWdFdmVudCxcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcbiAgICB9KTtcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckNyZWF0ZWRFdmVudCk7XG4gICAgYXBwZW5kYWJsZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1pcnJvcik7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JBdHRhY2hlZEV2ZW50KTtcbiAgfVxuICBbb25EcmFnTW92ZV0oZHJhZ0V2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm1pcnJvciB8fCBkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50XG4gICAgfSA9IGRyYWdFdmVudDtcbiAgICBsZXQgcGFzc2VkVGhyZXNoWCA9IHRydWU7XG4gICAgbGV0IHBhc3NlZFRocmVzaFkgPSB0cnVlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGhyZXNob2xkWCB8fCB0aGlzLm9wdGlvbnMudGhyZXNob2xkWSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4OiBsYXN0WCxcbiAgICAgICAgeTogbGFzdFlcbiAgICAgIH0gPSB0aGlzLmxhc3RNaXJyb3JNb3ZlZENsaWVudDtcbiAgICAgIGlmIChNYXRoLmFicyhsYXN0WCAtIHNlbnNvckV2ZW50LmNsaWVudFgpIDwgdGhpcy5vcHRpb25zLnRocmVzaG9sZFgpIHtcbiAgICAgICAgcGFzc2VkVGhyZXNoWCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQueCA9IHNlbnNvckV2ZW50LmNsaWVudFg7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMobGFzdFkgLSBzZW5zb3JFdmVudC5jbGllbnRZKSA8IHRoaXMub3B0aW9ucy50aHJlc2hvbGRZKSB7XG4gICAgICAgIHBhc3NlZFRocmVzaFkgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50LnkgPSBzZW5zb3JFdmVudC5jbGllbnRZO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXNzZWRUaHJlc2hYICYmICFwYXNzZWRUaHJlc2hZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWlycm9yTW92ZUV2ZW50ID0gbmV3IE1pcnJvck1vdmVFdmVudCh7XG4gICAgICBzb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgZHJhZ0V2ZW50LFxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcbiAgICAgIHBhc3NlZFRocmVzaFgsXG4gICAgICBwYXNzZWRUaHJlc2hZXG4gICAgfSk7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JNb3ZlRXZlbnQpO1xuICB9XG4gIFtvbkRyYWdTdG9wXShkcmFnRXZlbnQpIHtcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzW29uU2Nyb2xsXSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICBpZiAoIXRoaXMubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50XG4gICAgfSA9IGRyYWdFdmVudDtcbiAgICBjb25zdCBtaXJyb3JEZXN0cm95RXZlbnQgPSBuZXcgTWlycm9yRGVzdHJveUV2ZW50KHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXG4gICAgICBzb3VyY2VDb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIGRyYWdFdmVudFxuICAgIH0pO1xuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yRGVzdHJveUV2ZW50KTtcbiAgICBpZiAoIW1pcnJvckRlc3Ryb3lFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICB0aGlzLm1pcnJvci5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgW29uU2Nyb2xsXSgpIHtcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYIC0gdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0LngsXG4gICAgICB5OiB3aW5kb3cuc2Nyb2xsWSAtIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldC55XG4gICAgfTtcbiAgfVxuXG4gIFtvbk1pcnJvckNyZWF0ZWRdKHtcbiAgICBtaXJyb3IsXG4gICAgc291cmNlLFxuICAgIHNlbnNvckV2ZW50XG4gIH0pIHtcbiAgICBjb25zdCBtaXJyb3JDbGFzc2VzID0gdGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0ZvcignbWlycm9yJyk7XG4gICAgY29uc3Qgc2V0U3RhdGUgPSAoe1xuICAgICAgbWlycm9yT2Zmc2V0LFxuICAgICAgaW5pdGlhbFgsXG4gICAgICBpbml0aWFsWSxcbiAgICAgIC4uLmFyZ3NcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLm1pcnJvck9mZnNldCA9IG1pcnJvck9mZnNldDtcbiAgICAgIHRoaXMuaW5pdGlhbFggPSBpbml0aWFsWDtcbiAgICAgIHRoaXMuaW5pdGlhbFkgPSBpbml0aWFsWTtcbiAgICAgIHRoaXMubGFzdE1vdmVkWCA9IGluaXRpYWxYO1xuICAgICAgdGhpcy5sYXN0TW92ZWRZID0gaW5pdGlhbFk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaXJyb3JPZmZzZXQsXG4gICAgICAgIGluaXRpYWxYLFxuICAgICAgICBpbml0aWFsWSxcbiAgICAgICAgLi4uYXJnc1xuICAgICAgfTtcbiAgICB9O1xuICAgIG1pcnJvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICAgIG1pcnJvcixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgbWlycm9yQ2xhc3NlcyxcbiAgICAgIHNjcm9sbE9mZnNldDogdGhpcy5zY3JvbGxPZmZzZXQsXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICBwYXNzZWRUaHJlc2hYOiB0cnVlLFxuICAgICAgcGFzc2VkVGhyZXNoWTogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbml0aWFsU3RhdGUpXG5cbiAgICAudGhlbihjb21wdXRlTWlycm9yRGltZW5zaW9ucykudGhlbihjYWxjdWxhdGVNaXJyb3JPZmZzZXQpLnRoZW4ocmVzZXRNaXJyb3IpLnRoZW4oYWRkTWlycm9yQ2xhc3NlcykudGhlbihwb3NpdGlvbk1pcnJvcih7XG4gICAgICBpbml0aWFsOiB0cnVlXG4gICAgfSkpLnRoZW4ocmVtb3ZlTWlycm9ySUQpLnRoZW4oc2V0U3RhdGUpO1xuICB9XG5cbiAgW29uTWlycm9yTW92ZV0obWlycm9yRXZlbnQpIHtcbiAgICBpZiAobWlycm9yRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNldFN0YXRlID0gKHtcbiAgICAgIGxhc3RNb3ZlZFgsXG4gICAgICBsYXN0TW92ZWRZLFxuICAgICAgLi4uYXJnc1xuICAgIH0pID0+IHtcbiAgICAgIHRoaXMubGFzdE1vdmVkWCA9IGxhc3RNb3ZlZFg7XG4gICAgICB0aGlzLmxhc3RNb3ZlZFkgPSBsYXN0TW92ZWRZO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFzdE1vdmVkWCxcbiAgICAgICAgbGFzdE1vdmVkWSxcbiAgICAgICAgLi4uYXJnc1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHRyaWdnZXJNb3ZlZCA9IGFyZ3MgPT4ge1xuICAgICAgY29uc3QgbWlycm9yTW92ZWRFdmVudCA9IG5ldyBNaXJyb3JNb3ZlZEV2ZW50KHtcbiAgICAgICAgc291cmNlOiBtaXJyb3JFdmVudC5zb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiBtaXJyb3JFdmVudC5vcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBtaXJyb3JFdmVudC5zb3VyY2VDb250YWluZXIsXG4gICAgICAgIHNlbnNvckV2ZW50OiBtaXJyb3JFdmVudC5zZW5zb3JFdmVudCxcbiAgICAgICAgZHJhZ0V2ZW50OiBtaXJyb3JFdmVudC5kcmFnRXZlbnQsXG4gICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXG4gICAgICAgIHBhc3NlZFRocmVzaFg6IG1pcnJvckV2ZW50LnBhc3NlZFRocmVzaFgsXG4gICAgICAgIHBhc3NlZFRocmVzaFk6IG1pcnJvckV2ZW50LnBhc3NlZFRocmVzaFlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JNb3ZlZEV2ZW50KTtcbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH07XG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgbWlycm9yOiBtaXJyb3JFdmVudC5taXJyb3IsXG4gICAgICBzZW5zb3JFdmVudDogbWlycm9yRXZlbnQuc2Vuc29yRXZlbnQsXG4gICAgICBtaXJyb3JPZmZzZXQ6IHRoaXMubWlycm9yT2Zmc2V0LFxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgaW5pdGlhbFg6IHRoaXMuaW5pdGlhbFgsXG4gICAgICBpbml0aWFsWTogdGhpcy5pbml0aWFsWSxcbiAgICAgIHNjcm9sbE9mZnNldDogdGhpcy5zY3JvbGxPZmZzZXQsXG4gICAgICBwYXNzZWRUaHJlc2hYOiBtaXJyb3JFdmVudC5wYXNzZWRUaHJlc2hYLFxuICAgICAgcGFzc2VkVGhyZXNoWTogbWlycm9yRXZlbnQucGFzc2VkVGhyZXNoWSxcbiAgICAgIGxhc3RNb3ZlZFg6IHRoaXMubGFzdE1vdmVkWCxcbiAgICAgIGxhc3RNb3ZlZFk6IHRoaXMubGFzdE1vdmVkWVxuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbml0aWFsU3RhdGUpLnRoZW4ocG9zaXRpb25NaXJyb3Ioe1xuICAgICAgcmFmOiB0cnVlXG4gICAgfSkpLnRoZW4oc2V0U3RhdGUpLnRoZW4odHJpZ2dlck1vdmVkKTtcbiAgfVxuXG4gIFtnZXRBcHBlbmRhYmxlQ29udGFpbmVyXShzb3VyY2UpIHtcbiAgICBjb25zdCBhcHBlbmRUbyA9IHRoaXMub3B0aW9ucy5hcHBlbmRUbztcbiAgICBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXBwZW5kVG8pO1xuICAgIH0gZWxzZSBpZiAoYXBwZW5kVG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGFwcGVuZFRvO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYXBwZW5kVG8oc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNvdXJjZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlTWlycm9yRGltZW5zaW9ucyh7XG4gIHNvdXJjZSxcbiAgLi4uYXJnc1xufSkge1xuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgY29uc3Qgc291cmNlUmVjdCA9IHNvdXJjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXNvbHZlKHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNvdXJjZVJlY3QsXG4gICAgICAuLi5hcmdzXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVNaXJyb3JPZmZzZXQoe1xuICBzZW5zb3JFdmVudCxcbiAgc291cmNlUmVjdCxcbiAgb3B0aW9ucyxcbiAgLi4uYXJnc1xufSkge1xuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgY29uc3QgdG9wID0gb3B0aW9ucy5jdXJzb3JPZmZzZXRZID09PSBudWxsID8gc2Vuc29yRXZlbnQuY2xpZW50WSAtIHNvdXJjZVJlY3QudG9wIDogb3B0aW9ucy5jdXJzb3JPZmZzZXRZO1xuICAgIGNvbnN0IGxlZnQgPSBvcHRpb25zLmN1cnNvck9mZnNldFggPT09IG51bGwgPyBzZW5zb3JFdmVudC5jbGllbnRYIC0gc291cmNlUmVjdC5sZWZ0IDogb3B0aW9ucy5jdXJzb3JPZmZzZXRYO1xuICAgIGNvbnN0IG1pcnJvck9mZnNldCA9IHtcbiAgICAgIHRvcCxcbiAgICAgIGxlZnRcbiAgICB9O1xuICAgIHJlc29sdmUoe1xuICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICBzb3VyY2VSZWN0LFxuICAgICAgbWlycm9yT2Zmc2V0LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIC4uLmFyZ3NcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0TWlycm9yKHtcbiAgbWlycm9yLFxuICBzb3VyY2UsXG4gIG9wdGlvbnMsXG4gIC4uLmFyZ3Ncbn0pIHtcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGxldCBvZmZzZXRIZWlnaHQ7XG4gICAgbGV0IG9mZnNldFdpZHRoO1xuICAgIGlmIChvcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnMpIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVkU291cmNlU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShzb3VyY2UpO1xuICAgICAgb2Zmc2V0SGVpZ2h0ID0gY29tcHV0ZWRTb3VyY2VTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0Jyk7XG4gICAgICBvZmZzZXRXaWR0aCA9IGNvbXB1dGVkU291cmNlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJyk7XG4gICAgfVxuICAgIG1pcnJvci5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcbiAgICBtaXJyb3Iuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIG1pcnJvci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIG1pcnJvci5zdHlsZS50b3AgPSAwO1xuICAgIG1pcnJvci5zdHlsZS5sZWZ0ID0gMDtcbiAgICBtaXJyb3Iuc3R5bGUubWFyZ2luID0gMDtcbiAgICBpZiAob3B0aW9ucy5jb25zdHJhaW5EaW1lbnNpb25zKSB7XG4gICAgICBtaXJyb3Iuc3R5bGUuaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xuICAgICAgbWlycm9yLnN0eWxlLndpZHRoID0gb2Zmc2V0V2lkdGg7XG4gICAgfVxuICAgIHJlc29sdmUoe1xuICAgICAgbWlycm9yLFxuICAgICAgc291cmNlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIC4uLmFyZ3NcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZE1pcnJvckNsYXNzZXMoe1xuICBtaXJyb3IsXG4gIG1pcnJvckNsYXNzZXMsXG4gIC4uLmFyZ3Ncbn0pIHtcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIG1pcnJvci5jbGFzc0xpc3QuYWRkKC4uLm1pcnJvckNsYXNzZXMpO1xuICAgIHJlc29sdmUoe1xuICAgICAgbWlycm9yLFxuICAgICAgbWlycm9yQ2xhc3NlcyxcbiAgICAgIC4uLmFyZ3NcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU1pcnJvcklEKHtcbiAgbWlycm9yLFxuICAuLi5hcmdzXG59KSB7XG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBtaXJyb3IucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgIGRlbGV0ZSBtaXJyb3IuaWQ7XG4gICAgcmVzb2x2ZSh7XG4gICAgICBtaXJyb3IsXG4gICAgICAuLi5hcmdzXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvbk1pcnJvcih7XG4gIHdpdGhGcmFtZSA9IGZhbHNlLFxuICBpbml0aWFsID0gZmFsc2Vcbn0gPSB7fSkge1xuICByZXR1cm4gKHtcbiAgICBtaXJyb3IsXG4gICAgc2Vuc29yRXZlbnQsXG4gICAgbWlycm9yT2Zmc2V0LFxuICAgIGluaXRpYWxZLFxuICAgIGluaXRpYWxYLFxuICAgIHNjcm9sbE9mZnNldCxcbiAgICBvcHRpb25zLFxuICAgIHBhc3NlZFRocmVzaFgsXG4gICAgcGFzc2VkVGhyZXNoWSxcbiAgICBsYXN0TW92ZWRYLFxuICAgIGxhc3RNb3ZlZFksXG4gICAgLi4uYXJnc1xuICB9KSA9PiB7XG4gICAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBtaXJyb3IsXG4gICAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgICBtaXJyb3JPZmZzZXQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIC4uLmFyZ3NcbiAgICAgIH07XG4gICAgICBpZiAobWlycm9yT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHggPSBwYXNzZWRUaHJlc2hYID8gTWF0aC5yb3VuZCgoc2Vuc29yRXZlbnQuY2xpZW50WCAtIG1pcnJvck9mZnNldC5sZWZ0IC0gc2Nyb2xsT2Zmc2V0LngpIC8gKG9wdGlvbnMudGhyZXNob2xkWCB8fCAxKSkgKiAob3B0aW9ucy50aHJlc2hvbGRYIHx8IDEpIDogTWF0aC5yb3VuZChsYXN0TW92ZWRYKTtcbiAgICAgICAgY29uc3QgeSA9IHBhc3NlZFRocmVzaFkgPyBNYXRoLnJvdW5kKChzZW5zb3JFdmVudC5jbGllbnRZIC0gbWlycm9yT2Zmc2V0LnRvcCAtIHNjcm9sbE9mZnNldC55KSAvIChvcHRpb25zLnRocmVzaG9sZFkgfHwgMSkpICogKG9wdGlvbnMudGhyZXNob2xkWSB8fCAxKSA6IE1hdGgucm91bmQobGFzdE1vdmVkWSk7XG4gICAgICAgIGlmIChvcHRpb25zLnhBeGlzICYmIG9wdGlvbnMueUF4aXMgfHwgaW5pdGlhbCkge1xuICAgICAgICAgIG1pcnJvci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsIDApYDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnhBeGlzICYmICFvcHRpb25zLnlBeGlzKSB7XG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7aW5pdGlhbFl9cHgsIDApYDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnlBeGlzICYmICFvcHRpb25zLnhBeGlzKSB7XG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2luaXRpYWxYfXB4LCAke3l9cHgsIDApYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbCkge1xuICAgICAgICAgIHJlc3VsdC5pbml0aWFsWCA9IHg7XG4gICAgICAgICAgcmVzdWx0LmluaXRpYWxZID0geTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQubGFzdE1vdmVkWCA9IHg7XG4gICAgICAgIHJlc3VsdC5sYXN0TW92ZWRZID0geTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9LCB7XG4gICAgICBmcmFtZTogd2l0aEZyYW1lXG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHdpdGhQcm9taXNlKGNhbGxiYWNrLCB7XG4gIHJhZiA9IGZhbHNlXG59ID0ge30pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAocmFmKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNOYXRpdmVEcmFnRXZlbnQoc2Vuc29yRXZlbnQpIHtcbiAgcmV0dXJuIC9eZHJhZy8udGVzdChzZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50LnR5cGUpO1xufVxuXG5leHBvcnQgeyBNaXJyb3IgYXMgZGVmYXVsdCwgZGVmYXVsdE9wdGlvbnMsIGdldEFwcGVuZGFibGVDb250YWluZXIsIG9uRHJhZ01vdmUsIG9uRHJhZ1N0YXJ0LCBvbkRyYWdTdG9wLCBvbk1pcnJvckNyZWF0ZWQsIG9uTWlycm9yTW92ZSwgb25TY3JvbGwgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMnO1xuaW1wb3J0IGNsb3Nlc3QgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2Nsb3Nlc3QvY2xvc2VzdC5tanMnO1xuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IHNjcm9sbCA9IFN5bWJvbCgnc2Nyb2xsJyk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBzcGVlZDogNixcbiAgc2Vuc2l0aXZpdHk6IDUwLFxuICBzY3JvbGxhYmxlRWxlbWVudHM6IFtdXG59O1xuXG5jbGFzcyBTY3JvbGxhYmxlIGV4dGVuZHMgQWJzdHJhY3RQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIHN1cGVyKGRyYWdnYWJsZSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLnRoaXMuZ2V0T3B0aW9ucygpXG4gICAgfTtcblxuICAgIHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24gPSBudWxsO1xuXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IG51bGw7XG5cbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSBudWxsO1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tzY3JvbGxdID0gdGhpc1tzY3JvbGxdLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zY3JvbGxhYmxlIHx8IHt9O1xuICB9XG5cbiAgZ2V0U2Nyb2xsYWJsZUVsZW1lbnQodGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMuaGFzRGVmaW5lZFNjcm9sbGFibGVFbGVtZW50cygpKSB7XG4gICAgICByZXR1cm4gY2xvc2VzdCh0YXJnZXQsIHRoaXMub3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHMpIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNsb3Nlc3RTY3JvbGxhYmxlRWxlbWVudCh0YXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIGhhc0RlZmluZWRTY3JvbGxhYmxlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5vcHRpb25zLnNjcm9sbGFibGVFbGVtZW50cy5sZW5ndGggIT09IDApO1xuICB9XG5cbiAgW29uRHJhZ1N0YXJ0XShkcmFnRXZlbnQpIHtcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLmdldFNjcm9sbGFibGVFbGVtZW50KGRyYWdFdmVudC5zb3VyY2UpO1xuICAgIH0pO1xuICB9XG5cbiAgW29uRHJhZ01vdmVdKGRyYWdFdmVudCkge1xuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IHRoaXMuZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZHJhZ0V2ZW50LnNlbnNvckV2ZW50LnRhcmdldCk7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLnNjcm9sbGFibGVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZHJhZ0V2ZW50LnNlbnNvckV2ZW50O1xuICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgICBzY3JvbGxPZmZzZXQueSA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICBzY3JvbGxPZmZzZXQueCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgMDtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IHtcbiAgICAgIGNsaWVudFg6IHNlbnNvckV2ZW50LmNsaWVudFggLSBzY3JvbGxPZmZzZXQueCxcbiAgICAgIGNsaWVudFk6IHNlbnNvckV2ZW50LmNsaWVudFkgLSBzY3JvbGxPZmZzZXQueVxuICAgIH07XG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW3Njcm9sbF0pO1xuICB9XG5cbiAgW29uRHJhZ1N0b3BdKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUpO1xuICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24gPSBudWxsO1xuICB9XG5cbiAgW3Njcm9sbF0oKSB7XG4gICAgaWYgKCF0aGlzLnNjcm9sbGFibGVFbGVtZW50IHx8ICF0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNwZWVkLFxuICAgICAgc2Vuc2l0aXZpdHlcbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnNjcm9sbGFibGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGJvdHRvbUN1dE9mZiA9IHJlY3QuYm90dG9tID4gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGNvbnN0IHRvcEN1dE9mZiA9IHJlY3QudG9wIDwgMDtcbiAgICBjb25zdCBjdXRPZmYgPSB0b3BDdXRPZmYgfHwgYm90dG9tQ3V0T2ZmO1xuICAgIGNvbnN0IGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCA9IGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gdGhpcy5zY3JvbGxhYmxlRWxlbWVudDtcbiAgICBjb25zdCBjbGllbnRYID0gdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRYO1xuICAgIGNvbnN0IGNsaWVudFkgPSB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFk7XG4gICAgaWYgKHNjcm9sbGFibGVFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIHNjcm9sbGFibGVFbGVtZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgIWN1dE9mZikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXRIZWlnaHQsXG4gICAgICAgIG9mZnNldFdpZHRoXG4gICAgICB9ID0gc2Nyb2xsYWJsZUVsZW1lbnQ7XG4gICAgICBpZiAocmVjdC50b3AgKyBvZmZzZXRIZWlnaHQgLSBjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsVG9wICs9IHNwZWVkO1xuICAgICAgfSBlbHNlIGlmIChjbGllbnRZIC0gcmVjdC50b3AgPCBzZW5zaXRpdml0eSkge1xuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3AgLT0gc3BlZWQ7XG4gICAgICB9XG4gICAgICBpZiAocmVjdC5sZWZ0ICsgb2Zmc2V0V2lkdGggLSBjbGllbnRYIDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsTGVmdCArPSBzcGVlZDtcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50WCAtIHJlY3QubGVmdCA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbExlZnQgLT0gc3BlZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5uZXJIZWlnaHQsXG4gICAgICAgIGlubmVyV2lkdGhcbiAgICAgIH0gPSB3aW5kb3c7XG4gICAgICBpZiAoY2xpZW50WSA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgLT0gc3BlZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlubmVySGVpZ2h0IC0gY2xpZW50WSA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgKz0gc3BlZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0IC09IHNwZWVkO1xuICAgICAgfSBlbHNlIGlmIChpbm5lcldpZHRoIC0gY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ICs9IHNwZWVkO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbc2Nyb2xsXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzT3ZlcmZsb3coZWxlbWVudCkge1xuICBjb25zdCBvdmVyZmxvd1JlZ2V4ID0gLyhhdXRvfHNjcm9sbCkvO1xuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIGNvbnN0IG92ZXJmbG93ID0gY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cnKSArIGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXknKSArIGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXgnKTtcbiAgcmV0dXJuIG92ZXJmbG93UmVnZXgudGVzdChvdmVyZmxvdyk7XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljYWxseVBvc2l0aW9uZWQoZWxlbWVudCkge1xuICBjb25zdCBwb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAnc3RhdGljJztcbn1cblxuZnVuY3Rpb24gY2xvc2VzdFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpO1xuICB9XG4gIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuICBjb25zdCBleGNsdWRlU3RhdGljUGFyZW50cyA9IHBvc2l0aW9uID09PSAnYWJzb2x1dGUnO1xuICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IGNsb3Nlc3QoZWxlbWVudCwgcGFyZW50ID0+IHtcbiAgICBpZiAoZXhjbHVkZVN0YXRpY1BhcmVudHMgJiYgaXNTdGF0aWNhbGx5UG9zaXRpb25lZChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBoYXNPdmVyZmxvdyhwYXJlbnQpO1xuICB9KTtcbiAgaWYgKHBvc2l0aW9uID09PSAnZml4ZWQnIHx8ICFzY3JvbGxhYmxlRWxlbWVudCkge1xuICAgIHJldHVybiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2Nyb2xsYWJsZUVsZW1lbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCkge1xuICByZXR1cm4gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbmV4cG9ydCB7IFNjcm9sbGFibGUgYXMgZGVmYXVsdCwgZGVmYXVsdE9wdGlvbnMsIG9uRHJhZ01vdmUsIG9uRHJhZ1N0YXJ0LCBvbkRyYWdTdG9wLCBzY3JvbGwgfTtcbiIsICJjbGFzcyBFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgfVxuXG4gIG9uKHR5cGUsIC4uLmNhbGxiYWNrcykge1xuICAgIGlmICghdGhpcy5jYWxsYmFja3NbdHlwZV0pIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdID0gW107XG4gICAgfVxuICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdLnB1c2goLi4uY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9mZih0eXBlLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5jYWxsYmFja3NbdHlwZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjb3B5ID0gdGhpcy5jYWxsYmFja3NbdHlwZV0uc2xpY2UoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3B5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2FsbGJhY2sgPT09IGNvcHlbaV0pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3NbdHlwZV0uc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRyaWdnZXIoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50LnR5cGVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY2FsbGJhY2tzID0gWy4uLnRoaXMuY2FsbGJhY2tzW2V2ZW50LnR5cGVdXTtcbiAgICBjb25zdCBjYXVnaHRFcnJvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhdWdodEVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNhdWdodEVycm9ycy5sZW5ndGgpIHtcblxuICAgICAgY29uc29sZS5lcnJvcihgRHJhZ2dhYmxlIGNhdWdodCBlcnJvcnMgd2hpbGUgdHJpZ2dlcmluZyAnJHtldmVudC50eXBlfSdgLCBjYXVnaHRFcnJvcnMpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IHsgRW1pdHRlciBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RFdmVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdEV2ZW50L0Fic3RyYWN0RXZlbnQubWpzJztcblxuY2xhc3MgRHJhZ2dhYmxlRXZlbnQgZXh0ZW5kcyBBYnN0cmFjdEV2ZW50IHtcblxuICBnZXQgZHJhZ2dhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ2dhYmxlO1xuICB9XG59XG5cbkRyYWdnYWJsZUV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlJztcbmNsYXNzIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgZXh0ZW5kcyBEcmFnZ2FibGVFdmVudCB7fVxuXG5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlOmluaXRpYWxpemUnO1xuY2xhc3MgRHJhZ2dhYmxlRGVzdHJveUV2ZW50IGV4dGVuZHMgRHJhZ2dhYmxlRXZlbnQge31cbkRyYWdnYWJsZURlc3Ryb3lFdmVudC50eXBlID0gJ2RyYWdnYWJsZTpkZXN0cm95JztcblxuZXhwb3J0IHsgRHJhZ2dhYmxlRGVzdHJveUV2ZW50LCBEcmFnZ2FibGVFdmVudCwgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCB9O1xuIiwgImltcG9ydCBjbG9zZXN0IGZyb20gJy4uL3NoYXJlZC91dGlscy9jbG9zZXN0L2Nsb3Nlc3QubWpzJztcbmltcG9ydCBBbm5vdW5jZW1lbnQgZnJvbSAnLi9QbHVnaW5zL0Fubm91bmNlbWVudC9Bbm5vdW5jZW1lbnQubWpzJztcbmltcG9ydCBGb2N1c2FibGUgZnJvbSAnLi9QbHVnaW5zL0ZvY3VzYWJsZS9Gb2N1c2FibGUubWpzJztcbmltcG9ydCBNaXJyb3IgZnJvbSAnLi9QbHVnaW5zL01pcnJvci9NaXJyb3IubWpzJztcbmltcG9ydCBTY3JvbGxhYmxlIGZyb20gJy4vUGx1Z2lucy9TY3JvbGxhYmxlL1Njcm9sbGFibGUubWpzJztcbmltcG9ydCBFbWl0dGVyIGZyb20gJy4vRW1pdHRlci9FbWl0dGVyLm1qcyc7XG5pbXBvcnQgTW91c2VTZW5zb3IgZnJvbSAnLi9TZW5zb3JzL01vdXNlU2Vuc29yL01vdXNlU2Vuc29yLm1qcyc7XG5pbXBvcnQgVG91Y2hTZW5zb3IgZnJvbSAnLi9TZW5zb3JzL1RvdWNoU2Vuc29yL1RvdWNoU2Vuc29yLm1qcyc7XG5pbXBvcnQgJy4vU2Vuc29ycy9TZW5zb3JFdmVudC9TZW5zb3JFdmVudC5tanMnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCwgRHJhZ2dhYmxlRGVzdHJveUV2ZW50IH0gZnJvbSAnLi9EcmFnZ2FibGVFdmVudC9EcmFnZ2FibGVFdmVudC5tanMnO1xuaW1wb3J0IHsgRHJhZ1N0YXJ0RXZlbnQsIERyYWdNb3ZlRXZlbnQsIERyYWdPdXRFdmVudCwgRHJhZ091dENvbnRhaW5lckV2ZW50LCBEcmFnT3ZlckNvbnRhaW5lckV2ZW50LCBEcmFnT3ZlckV2ZW50LCBEcmFnU3RvcEV2ZW50LCBEcmFnU3RvcHBlZEV2ZW50LCBEcmFnUHJlc3N1cmVFdmVudCB9IGZyb20gJy4vRHJhZ0V2ZW50L0RyYWdFdmVudC5tanMnO1xuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IG9uRHJhZ1ByZXNzdXJlID0gU3ltYm9sKCdvbkRyYWdQcmVzc3VyZScpO1xuY29uc3QgZHJhZ1N0b3AgPSBTeW1ib2woJ2RyYWdTdG9wJyk7XG5cbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xuICAnZHJhZzpzdGFydCc6IGV2ZW50ID0+IGBQaWNrZWQgdXAgJHtldmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGV2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnfWAsXG4gICdkcmFnOnN0b3AnOiBldmVudCA9PiBgUmVsZWFzZWQgJHtldmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGV2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnfWBcbn07XG5jb25zdCBkZWZhdWx0Q2xhc3NlcyA9IHtcbiAgJ2NvbnRhaW5lcjpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1pcy1kcmFnZ2luZycsXG4gICdzb3VyY2U6ZHJhZ2dpbmcnOiAnZHJhZ2dhYmxlLXNvdXJjZS0taXMtZHJhZ2dpbmcnLFxuICAnc291cmNlOnBsYWNlZCc6ICdkcmFnZ2FibGUtc291cmNlLS1wbGFjZWQnLFxuICAnY29udGFpbmVyOnBsYWNlZCc6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1wbGFjZWQnLFxuICAnYm9keTpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtLWlzLWRyYWdnaW5nJyxcbiAgJ2RyYWdnYWJsZTpvdmVyJzogJ2RyYWdnYWJsZS0tb3ZlcicsXG4gICdjb250YWluZXI6b3Zlcic6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1vdmVyJyxcbiAgJ3NvdXJjZTpvcmlnaW5hbCc6ICdkcmFnZ2FibGUtLW9yaWdpbmFsJyxcbiAgbWlycm9yOiAnZHJhZ2dhYmxlLW1pcnJvcidcbn07XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZHJhZ2dhYmxlOiAnLmRyYWdnYWJsZS1zb3VyY2UnLFxuICBoYW5kbGU6IG51bGwsXG4gIGRlbGF5OiB7fSxcbiAgZGlzdGFuY2U6IDAsXG4gIHBsYWNlZFRpbWVvdXQ6IDgwMCxcbiAgcGx1Z2luczogW10sXG4gIHNlbnNvcnM6IFtdLFxuICBleGNsdWRlOiB7XG4gICAgcGx1Z2luczogW10sXG4gICAgc2Vuc29yczogW11cbiAgfVxufTtcblxuY2xhc3MgRHJhZ2dhYmxlIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW2RvY3VtZW50LmJvZHldLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmIChjb250YWluZXJzIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgY29udGFpbmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLmNvbnRhaW5lcnMgPSBbLi4uY29udGFpbmVyc107XG4gICAgfSBlbHNlIGlmIChjb250YWluZXJzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVycyA9IFtjb250YWluZXJzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcmFnZ2FibGUgY29udGFpbmVycyBhcmUgZXhwZWN0ZWQgdG8gYmUgb2YgdHlwZSBgTm9kZUxpc3RgLCBgSFRNTEVsZW1lbnRbXWAgb3IgYEhUTUxFbGVtZW50YCcpO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgIC4uLmRlZmF1bHRDbGFzc2VzLFxuICAgICAgICAuLi4ob3B0aW9ucy5jbGFzc2VzIHx8IHt9KVxuICAgICAgfSxcbiAgICAgIGFubm91bmNlbWVudHM6IHtcbiAgICAgICAgLi4uZGVmYXVsdEFubm91bmNlbWVudHMsXG4gICAgICAgIC4uLihvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXG4gICAgICB9LFxuICAgICAgZXhjbHVkZToge1xuICAgICAgICBwbHVnaW5zOiBvcHRpb25zLmV4Y2x1ZGUgJiYgb3B0aW9ucy5leGNsdWRlLnBsdWdpbnMgfHwgW10sXG4gICAgICAgIHNlbnNvcnM6IG9wdGlvbnMuZXhjbHVkZSAmJiBvcHRpb25zLmV4Y2x1ZGUuc2Vuc29ycyB8fCBbXVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5wbHVnaW5zID0gW107XG5cbiAgICB0aGlzLnNlbnNvcnMgPSBbXTtcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnUHJlc3N1cmVdID0gdGhpc1tvbkRyYWdQcmVzc3VyZV0uYmluZCh0aGlzKTtcbiAgICB0aGlzW2RyYWdTdG9wXSA9IHRoaXNbZHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnByZXNzdXJlJywgdGhpc1tvbkRyYWdQcmVzc3VyZV0sIHRydWUpO1xuICAgIGNvbnN0IGRlZmF1bHRQbHVnaW5zID0gT2JqZWN0LnZhbHVlcyhEcmFnZ2FibGUuUGx1Z2lucykuZmlsdGVyKFBsdWdpbiA9PiAhdGhpcy5vcHRpb25zLmV4Y2x1ZGUucGx1Z2lucy5pbmNsdWRlcyhQbHVnaW4pKTtcbiAgICBjb25zdCBkZWZhdWx0U2Vuc29ycyA9IE9iamVjdC52YWx1ZXMoRHJhZ2dhYmxlLlNlbnNvcnMpLmZpbHRlcihzZW5zb3IgPT4gIXRoaXMub3B0aW9ucy5leGNsdWRlLnNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yKSk7XG4gICAgdGhpcy5hZGRQbHVnaW4oLi4uWy4uLmRlZmF1bHRQbHVnaW5zLCAuLi50aGlzLm9wdGlvbnMucGx1Z2luc10pO1xuICAgIHRoaXMuYWRkU2Vuc29yKC4uLlsuLi5kZWZhdWx0U2Vuc29ycywgLi4udGhpcy5vcHRpb25zLnNlbnNvcnNdKTtcbiAgICBjb25zdCBkcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50ID0gbmV3IERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQoe1xuICAgICAgZHJhZ2dhYmxlOiB0aGlzXG4gICAgfSk7XG4gICAgdGhpcy5vbignbWlycm9yOmNyZWF0ZWQnLCAoe1xuICAgICAgbWlycm9yXG4gICAgfSkgPT4gdGhpcy5taXJyb3IgPSBtaXJyb3IpO1xuICAgIHRoaXMub24oJ21pcnJvcjpkZXN0cm95JywgKCkgPT4gdGhpcy5taXJyb3IgPSBudWxsKTtcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpwcmVzc3VyZScsIHRoaXNbb25EcmFnUHJlc3N1cmVdLCB0cnVlKTtcbiAgICBjb25zdCBkcmFnZ2FibGVEZXN0cm95RXZlbnQgPSBuZXcgRHJhZ2dhYmxlRGVzdHJveUV2ZW50KHtcbiAgICAgIGRyYWdnYWJsZTogdGhpc1xuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihkcmFnZ2FibGVEZXN0cm95RXZlbnQpO1xuICAgIHRoaXMucmVtb3ZlUGx1Z2luKC4uLnRoaXMucGx1Z2lucy5tYXAocGx1Z2luID0+IHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xuICAgIHRoaXMucmVtb3ZlU2Vuc29yKC4uLnRoaXMuc2Vuc29ycy5tYXAoc2Vuc29yID0+IHNlbnNvci5jb25zdHJ1Y3RvcikpO1xuICB9XG5cbiAgYWRkUGx1Z2luKC4uLnBsdWdpbnMpIHtcbiAgICBjb25zdCBhY3RpdmVQbHVnaW5zID0gcGx1Z2lucy5tYXAoUGx1Z2luID0+IG5ldyBQbHVnaW4odGhpcykpO1xuICAgIGFjdGl2ZVBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmF0dGFjaCgpKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBbLi4udGhpcy5wbHVnaW5zLCAuLi5hY3RpdmVQbHVnaW5zXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZVBsdWdpbiguLi5wbHVnaW5zKSB7XG4gICAgY29uc3QgcmVtb3ZlZFBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiBwbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xuICAgIHJlbW92ZWRQbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHBsdWdpbi5kZXRhY2goKSk7XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gIXBsdWdpbnMuaW5jbHVkZXMocGx1Z2luLmNvbnN0cnVjdG9yKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRTZW5zb3IoLi4uc2Vuc29ycykge1xuICAgIGNvbnN0IGFjdGl2ZVNlbnNvcnMgPSBzZW5zb3JzLm1hcChTZW5zb3IgPT4gbmV3IFNlbnNvcih0aGlzLmNvbnRhaW5lcnMsIHRoaXMub3B0aW9ucykpO1xuICAgIGFjdGl2ZVNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLmF0dGFjaCgpKTtcbiAgICB0aGlzLnNlbnNvcnMgPSBbLi4udGhpcy5zZW5zb3JzLCAuLi5hY3RpdmVTZW5zb3JzXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZVNlbnNvciguLi5zZW5zb3JzKSB7XG4gICAgY29uc3QgcmVtb3ZlZFNlbnNvcnMgPSB0aGlzLnNlbnNvcnMuZmlsdGVyKHNlbnNvciA9PiBzZW5zb3JzLmluY2x1ZGVzKHNlbnNvci5jb25zdHJ1Y3RvcikpO1xuICAgIHJlbW92ZWRTZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5kZXRhY2goKSk7XG4gICAgdGhpcy5zZW5zb3JzID0gdGhpcy5zZW5zb3JzLmZpbHRlcihzZW5zb3IgPT4gIXNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yLmNvbnN0cnVjdG9yKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRDb250YWluZXIoLi4uY29udGFpbmVycykge1xuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi50aGlzLmNvbnRhaW5lcnMsIC4uLmNvbnRhaW5lcnNdO1xuICAgIHRoaXMuc2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuYWRkQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSB7XG4gICAgdGhpcy5jb250YWluZXJzID0gdGhpcy5jb250YWluZXJzLmZpbHRlcihjb250YWluZXIgPT4gIWNvbnRhaW5lcnMuaW5jbHVkZXMoY29udGFpbmVyKSk7XG4gICAgdGhpcy5zZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5yZW1vdmVDb250YWluZXIoLi4uY29udGFpbmVycykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb24odHlwZSwgLi4uY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9uKHR5cGUsIC4uLmNhbGxiYWNrcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvZmYodHlwZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIub2ZmKHR5cGUsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRyaWdnZXIoZXZlbnQpIHtcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcihldmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRDbGFzc05hbWVGb3IobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdldENsYXNzTmFtZXNGb3IobmFtZSlbMF07XG4gIH1cblxuICBnZXRDbGFzc05hbWVzRm9yKG5hbWUpIHtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdGhpcy5vcHRpb25zLmNsYXNzZXNbbmFtZV07XG4gICAgaWYgKGNsYXNzTmFtZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZycgfHwgY2xhc3NOYW1lcyBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgcmV0dXJuIFtjbGFzc05hbWVzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIGlzRHJhZ2dpbmcoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5kcmFnZ2luZyk7XG4gIH1cblxuICBnZXREcmFnZ2FibGVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJzLnJlZHVjZSgoY3VycmVudCwgY29udGFpbmVyKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLmN1cnJlbnQsIC4uLnRoaXMuZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKV07XG4gICAgfSwgW10pO1xuICB9XG5cbiAgZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgY29uc3QgYWxsRHJhZ2dhYmxlRWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICByZXR1cm4gWy4uLmFsbERyYWdnYWJsZUVsZW1lbnRzXS5maWx0ZXIoY2hpbGRFbGVtZW50ID0+IHtcbiAgICAgIHJldHVybiBjaGlsZEVsZW1lbnQgIT09IHRoaXMub3JpZ2luYWxTb3VyY2UgJiYgY2hpbGRFbGVtZW50ICE9PSB0aGlzLm1pcnJvcjtcbiAgICB9KTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzW2RyYWdTdG9wXSgpO1xuICB9XG5cbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsU291cmNlXG4gICAgfSA9IHNlbnNvckV2ZW50O1xuICAgIGlmICghdGhpcy5jb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGUgJiYgdGFyZ2V0ICYmICFjbG9zZXN0KHRhcmdldCwgdGhpcy5vcHRpb25zLmhhbmRsZSkpIHtcbiAgICAgIHNlbnNvckV2ZW50LmNhbmNlbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gb3JpZ2luYWxTb3VyY2U7XG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgaWYgKHRoaXMubGFzdFBsYWNlZFNvdXJjZSAmJiB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBsYWNlZFRpbWVvdXRJRCk7XG4gICAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XG4gICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XG4gICAgfVxuICAgIHRoaXMuc291cmNlID0gdGhpcy5vcmlnaW5hbFNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnNvdXJjZSwgdGhpcy5vcmlnaW5hbFNvdXJjZSk7XG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IERyYWdTdGFydEV2ZW50KHtcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgc2Vuc29yRXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1N0YXJ0RXZlbnQpO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKTtcbiAgICBpZiAoZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgdGhpcy5zb3VyY2UucmVtb3ZlKCk7XG4gICAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6b3JpZ2luYWwnKSk7XG4gICAgdGhpcy5zb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOmRyYWdnaW5nJykpO1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2JvZHk6ZHJhZ2dpbmcnKSk7XG4gICAgYXBwbHlVc2VyU2VsZWN0KGRvY3VtZW50LmJvZHksICdub25lJyk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGNvbnN0IG9sZFNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xuICAgICAgY29uc3QgbmV3U2Vuc29yRXZlbnQgPSBvbGRTZW5zb3JFdmVudC5jbG9uZSh7XG4gICAgICAgIHRhcmdldDogdGhpcy5zb3VyY2VcbiAgICAgIH0pO1xuICAgICAgdGhpc1tvbkRyYWdNb3ZlXSh7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICBkZXRhaWw6IG5ld1NlbnNvckV2ZW50XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIFtvbkRyYWdNb3ZlXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXJcbiAgICB9ID0gc2Vuc29yRXZlbnQ7XG4gICAgbGV0IHRhcmdldCA9IHNlbnNvckV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IERyYWdNb3ZlRXZlbnQoe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihkcmFnTW92ZUV2ZW50KTtcbiAgICBpZiAoZHJhZ01vdmVFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICBzZW5zb3JFdmVudC5jYW5jZWwoKTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIGNvbnN0IHdpdGhpbkNvcnJlY3RDb250YWluZXIgPSBjbG9zZXN0KHNlbnNvckV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcbiAgICBjb25zdCBvdmVyQ29udGFpbmVyID0gc2Vuc29yRXZlbnQub3ZlckNvbnRhaW5lciB8fCB3aXRoaW5Db3JyZWN0Q29udGFpbmVyO1xuICAgIGNvbnN0IGlzTGVhdmluZ0NvbnRhaW5lciA9IHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgJiYgb3ZlckNvbnRhaW5lciAhPT0gdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcjtcbiAgICBjb25zdCBpc0xlYXZpbmdEcmFnZ2FibGUgPSB0aGlzLmN1cnJlbnRPdmVyICYmIHRhcmdldCAhPT0gdGhpcy5jdXJyZW50T3ZlcjtcbiAgICBjb25zdCBpc092ZXJDb250YWluZXIgPSBvdmVyQ29udGFpbmVyICYmIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgIT09IG92ZXJDb250YWluZXI7XG4gICAgY29uc3QgaXNPdmVyRHJhZ2dhYmxlID0gd2l0aGluQ29ycmVjdENvbnRhaW5lciAmJiB0YXJnZXQgJiYgdGhpcy5jdXJyZW50T3ZlciAhPT0gdGFyZ2V0O1xuICAgIGlmIChpc0xlYXZpbmdEcmFnZ2FibGUpIHtcbiAgICAgIGNvbnN0IGRyYWdPdXRFdmVudCA9IG5ldyBEcmFnT3V0RXZlbnQoe1xuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgICBvdmVyOiB0aGlzLmN1cnJlbnRPdmVyLFxuICAgICAgICBvdmVyQ29udGFpbmVyOiB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyXG4gICAgICB9KTtcbiAgICAgIHRoaXMuY3VycmVudE92ZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2RyYWdnYWJsZTpvdmVyJykpO1xuICAgICAgdGhpcy5jdXJyZW50T3ZlciA9IG51bGw7XG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ091dEV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzTGVhdmluZ0NvbnRhaW5lcikge1xuICAgICAgY29uc3QgZHJhZ091dENvbnRhaW5lckV2ZW50ID0gbmV3IERyYWdPdXRDb250YWluZXJFdmVudCh7XG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICAgIG92ZXJDb250YWluZXI6IHRoaXMuY3VycmVudE92ZXJDb250YWluZXJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOm92ZXInKSk7XG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gbnVsbDtcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3V0Q29udGFpbmVyRXZlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNPdmVyQ29udGFpbmVyKSB7XG4gICAgICBvdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6b3ZlcicpKTtcbiAgICAgIGNvbnN0IGRyYWdPdmVyQ29udGFpbmVyRXZlbnQgPSBuZXcgRHJhZ092ZXJDb250YWluZXJFdmVudCh7XG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICAgIG92ZXJDb250YWluZXJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciA9IG92ZXJDb250YWluZXI7XG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ092ZXJDb250YWluZXJFdmVudCk7XG4gICAgfVxuICAgIGlmIChpc092ZXJEcmFnZ2FibGUpIHtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJhZ2dhYmxlOm92ZXInKSk7XG4gICAgICBjb25zdCBkcmFnT3ZlckV2ZW50ID0gbmV3IERyYWdPdmVyRXZlbnQoe1xuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgICBvdmVyQ29udGFpbmVyLFxuICAgICAgICBvdmVyOiB0YXJnZXRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50T3ZlciA9IHRhcmdldDtcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3ZlckV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBbZHJhZ1N0b3BdKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IERyYWdTdG9wRXZlbnQoe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgc2Vuc29yRXZlbnQ6IGV2ZW50ID8gZXZlbnQuc2Vuc29yRXZlbnQgOiBudWxsLFxuICAgICAgc291cmNlQ29udGFpbmVyOiB0aGlzLnNvdXJjZUNvbnRhaW5lclxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihkcmFnU3RvcEV2ZW50KTtcbiAgICBpZiAoIWRyYWdTdG9wRXZlbnQuY2FuY2VsZWQoKSkgdGhpcy5zb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5vcmlnaW5hbFNvdXJjZSwgdGhpcy5zb3VyY2UpO1xuICAgIHRoaXMuc291cmNlLnJlbW92ZSgpO1xuICAgIHRoaXMub3JpZ2luYWxTb3VyY2Uuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIHRoaXMuc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOm9yaWdpbmFsJykpO1xuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpkcmFnZ2luZycpKTtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdib2R5OmRyYWdnaW5nJykpO1xuICAgIGFwcGx5VXNlclNlbGVjdChkb2N1bWVudC5ib2R5LCAnJyk7XG4gICAgaWYgKHRoaXMuY3VycmVudE92ZXIpIHtcbiAgICAgIHRoaXMuY3VycmVudE92ZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2RyYWdnYWJsZTpvdmVyJykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOm92ZXInKSk7XG4gICAgfVxuICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZSA9IHRoaXMub3JpZ2luYWxTb3VyY2U7XG4gICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyID0gdGhpcy5zb3VyY2VDb250YWluZXI7XG4gICAgdGhpcy5wbGFjZWRUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmxhc3RQbGFjZWRTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5sYXN0UGxhY2VkU291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGFzdFBsYWNlZENvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyID0gbnVsbDtcbiAgICB9LCB0aGlzLm9wdGlvbnMucGxhY2VkVGltZW91dCk7XG4gICAgY29uc3QgZHJhZ1N0b3BwZWRFdmVudCA9IG5ldyBEcmFnU3RvcHBlZEV2ZW50KHtcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNlbnNvckV2ZW50OiBldmVudCA/IGV2ZW50LnNlbnNvckV2ZW50IDogbnVsbCxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogdGhpcy5zb3VyY2VDb250YWluZXJcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1N0b3BwZWRFdmVudCk7XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudE92ZXIgPSBudWxsO1xuICAgIHRoaXMuc291cmNlQ29udGFpbmVyID0gbnVsbDtcbiAgfVxuXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xuICAgIHRoaXNbZHJhZ1N0b3BdKGV2ZW50KTtcbiAgfVxuXG4gIFtvbkRyYWdQcmVzc3VyZV0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UgfHwgY2xvc2VzdChzZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgRHJhZ1ByZXNzdXJlRXZlbnQoe1xuICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICBzb3VyY2UsXG4gICAgICBwcmVzc3VyZTogc2Vuc29yRXZlbnQucHJlc3N1cmVcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1ByZXNzdXJlRXZlbnQpO1xuICB9XG59XG5cbkRyYWdnYWJsZS5QbHVnaW5zID0ge1xuICBBbm5vdW5jZW1lbnQsXG4gIEZvY3VzYWJsZSxcbiAgTWlycm9yLFxuICBTY3JvbGxhYmxlXG59O1xuXG5EcmFnZ2FibGUuU2Vuc29ycyA9IHtcbiAgTW91c2VTZW5zb3IsXG4gIFRvdWNoU2Vuc29yXG59O1xuZnVuY3Rpb24gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmRldGFpbDtcbn1cbmZ1bmN0aW9uIGFwcGx5VXNlclNlbGVjdChlbGVtZW50LCB2YWx1ZSkge1xuICBlbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSB2YWx1ZTtcbiAgZWxlbWVudC5zdHlsZS5tb3pVc2VyU2VsZWN0ID0gdmFsdWU7XG4gIGVsZW1lbnQuc3R5bGUubXNVc2VyU2VsZWN0ID0gdmFsdWU7XG4gIGVsZW1lbnQuc3R5bGUub1VzZXJTZWxlY3QgPSB2YWx1ZTtcbiAgZWxlbWVudC5zdHlsZS51c2VyU2VsZWN0ID0gdmFsdWU7XG59XG5cbmV4cG9ydCB7IERyYWdnYWJsZSBhcyBkZWZhdWx0LCBkZWZhdWx0T3B0aW9ucyB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0RXZlbnQgfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RFdmVudC9BYnN0cmFjdEV2ZW50Lm1qcyc7XG5cbmNsYXNzIERyb3BwYWJsZUV2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5Ecm9wcGFibGVFdmVudC50eXBlID0gJ2Ryb3BwYWJsZSc7XG5cbmNsYXNzIERyb3BwYWJsZVN0YXJ0RXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XG5cbiAgZ2V0IGRyb3B6b25lKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJvcHpvbmU7XG4gIH1cbn1cbkRyb3BwYWJsZVN0YXJ0RXZlbnQudHlwZSA9ICdkcm9wcGFibGU6c3RhcnQnO1xuRHJvcHBhYmxlU3RhcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuY2xhc3MgRHJvcHBhYmxlRHJvcHBlZEV2ZW50IGV4dGVuZHMgRHJvcHBhYmxlRXZlbnQge1xuXG4gIGdldCBkcm9wem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xuICB9XG59XG5Ecm9wcGFibGVEcm9wcGVkRXZlbnQudHlwZSA9ICdkcm9wcGFibGU6ZHJvcHBlZCc7XG5Ecm9wcGFibGVEcm9wcGVkRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5cbmNsYXNzIERyb3BwYWJsZVJldHVybmVkRXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XG5cbiAgZ2V0IGRyb3B6b25lKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJvcHpvbmU7XG4gIH1cbn1cbkRyb3BwYWJsZVJldHVybmVkRXZlbnQudHlwZSA9ICdkcm9wcGFibGU6cmV0dXJuZWQnO1xuRHJvcHBhYmxlUmV0dXJuZWRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuY2xhc3MgRHJvcHBhYmxlU3RvcEV2ZW50IGV4dGVuZHMgRHJvcHBhYmxlRXZlbnQge1xuXG4gIGdldCBkcm9wem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xuICB9XG59XG5Ecm9wcGFibGVTdG9wRXZlbnQudHlwZSA9ICdkcm9wcGFibGU6c3RvcCc7XG5Ecm9wcGFibGVTdG9wRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5cbmV4cG9ydCB7IERyb3BwYWJsZURyb3BwZWRFdmVudCwgRHJvcHBhYmxlRXZlbnQsIERyb3BwYWJsZVJldHVybmVkRXZlbnQsIERyb3BwYWJsZVN0YXJ0RXZlbnQsIERyb3BwYWJsZVN0b3BFdmVudCB9O1xuIiwgImltcG9ydCBjbG9zZXN0IGZyb20gJy4uL3NoYXJlZC91dGlscy9jbG9zZXN0L2Nsb3Nlc3QubWpzJztcbmltcG9ydCBEcmFnZ2FibGUgZnJvbSAnLi4vRHJhZ2dhYmxlL0RyYWdnYWJsZS5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvRHJhZ0V2ZW50L0RyYWdFdmVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvRHJhZ2dhYmxlRXZlbnQvRHJhZ2dhYmxlRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1BsdWdpbnMvQW5ub3VuY2VtZW50L0Fubm91bmNlbWVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvUGx1Z2lucy9NaXJyb3IvTWlycm9yRXZlbnQvTWlycm9yRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1NlbnNvcnMvU2Vuc29yRXZlbnQvU2Vuc29yRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1NlbnNvcnMvVG91Y2hTZW5zb3IvVG91Y2hTZW5zb3IubWpzJztcbmltcG9ydCB7IERyb3BwYWJsZVN0YXJ0RXZlbnQsIERyb3BwYWJsZVN0b3BFdmVudCwgRHJvcHBhYmxlRHJvcHBlZEV2ZW50LCBEcm9wcGFibGVSZXR1cm5lZEV2ZW50IH0gZnJvbSAnLi9Ecm9wcGFibGVFdmVudC9Ecm9wcGFibGVFdmVudC5tanMnO1xuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IGRyb3BJbkRyb3B6b25lID0gU3ltYm9sKCdkcm9wSW5Ecm9wWm9uZScpO1xuY29uc3QgcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lID0gU3ltYm9sKCdyZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmUnKTtcbmNvbnN0IGNsb3Nlc3REcm9wem9uZSA9IFN5bWJvbCgnY2xvc2VzdERyb3B6b25lJyk7XG5jb25zdCBnZXREcm9wem9uZXMgPSBTeW1ib2woJ2dldERyb3B6b25lcycpO1xuXG5mdW5jdGlvbiBvbkRyb3BwYWJsZURyb3BwZWREZWZhdWx0QW5ub3VuY2VtZW50KHtcbiAgZHJhZ0V2ZW50LFxuICBkcm9wem9uZVxufSkge1xuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnO1xuICBjb25zdCBkcm9wem9uZVRleHQgPSBkcm9wem9uZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJvcHpvbmUuaWQgfHwgJ2Ryb3BwYWJsZSBlbGVtZW50JztcbiAgcmV0dXJuIGBEcm9wcGVkICR7c291cmNlVGV4dH0gaW50byAke2Ryb3B6b25lVGV4dH1gO1xufVxuXG5mdW5jdGlvbiBvbkRyb3BwYWJsZVJldHVybmVkRGVmYXVsdEFubm91bmNlbWVudCh7XG4gIGRyYWdFdmVudCxcbiAgZHJvcHpvbmVcbn0pIHtcbiAgY29uc3Qgc291cmNlVGV4dCA9IGRyYWdFdmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5zb3VyY2UuaWQgfHwgJ2RyYWdnYWJsZSBlbGVtZW50JztcbiAgY29uc3QgZHJvcHpvbmVUZXh0ID0gZHJvcHpvbmUudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyb3B6b25lLmlkIHx8ICdkcm9wcGFibGUgZWxlbWVudCc7XG4gIHJldHVybiBgUmV0dXJuZWQgJHtzb3VyY2VUZXh0fSBmcm9tICR7ZHJvcHpvbmVUZXh0fWA7XG59XG5cbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xuICAnZHJvcHBhYmxlOmRyb3BwZWQnOiBvbkRyb3BwYWJsZURyb3BwZWREZWZhdWx0QW5ub3VuY2VtZW50LFxuICAnZHJvcHBhYmxlOnJldHVybmVkJzogb25Ecm9wcGFibGVSZXR1cm5lZERlZmF1bHRBbm5vdW5jZW1lbnRcbn07XG5jb25zdCBkZWZhdWx0Q2xhc3NlcyA9IHtcbiAgJ2Ryb3BwYWJsZTphY3RpdmUnOiAnZHJhZ2dhYmxlLWRyb3B6b25lLS1hY3RpdmUnLFxuICAnZHJvcHBhYmxlOm9jY3VwaWVkJzogJ2RyYWdnYWJsZS1kcm9wem9uZS0tb2NjdXBpZWQnXG59O1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGRyb3B6b25lOiAnLmRyYWdnYWJsZS1kcm9wcGFibGUnXG59O1xuXG5jbGFzcyBEcm9wcGFibGUgZXh0ZW5kcyBEcmFnZ2FibGUge1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoY29udGFpbmVycywge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAuLi5kZWZhdWx0Q2xhc3NlcyxcbiAgICAgICAgLi4uKG9wdGlvbnMuY2xhc3NlcyB8fCB7fSlcbiAgICAgIH0sXG4gICAgICBhbm5vdW5jZW1lbnRzOiB7XG4gICAgICAgIC4uLmRlZmF1bHRBbm5vdW5jZW1lbnRzLFxuICAgICAgICAuLi4ob3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9KVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5kcm9wem9uZXMgPSBudWxsO1xuXG4gICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBudWxsO1xuXG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUgPSBudWxsO1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZHJvcHpvbmVzID0gWy4uLnRoaXNbZ2V0RHJvcHpvbmVzXSgpXTtcbiAgICBjb25zdCBkcm9wem9uZSA9IGNsb3Nlc3QoZXZlbnQuc2Vuc29yRXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJvcHpvbmUpO1xuICAgIGlmICghZHJvcHpvbmUpIHtcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkcm9wcGFibGVTdGFydEV2ZW50ID0gbmV3IERyb3BwYWJsZVN0YXJ0RXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIGRyb3B6b25lXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVN0YXJ0RXZlbnQpO1xuICAgIGlmIChkcm9wcGFibGVTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxEcm9wem9uZSA9IGRyb3B6b25lO1xuICAgIGZvciAoY29uc3QgZHJvcHpvbmVFbGVtZW50IG9mIHRoaXMuZHJvcHpvbmVzKSB7XG4gICAgICBpZiAoZHJvcHpvbmVFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmdldENsYXNzTmFtZUZvcignZHJvcHBhYmxlOm9jY3VwaWVkJykpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZHJvcHpvbmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6YWN0aXZlJykpO1xuICAgIH1cbiAgfVxuXG4gIFtvbkRyYWdNb3ZlXShldmVudCkge1xuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRyb3B6b25lID0gdGhpc1tjbG9zZXN0RHJvcHpvbmVdKGV2ZW50LnNlbnNvckV2ZW50LnRhcmdldCk7XG4gICAgY29uc3Qgb3ZlckVtcHR5RHJvcHpvbmUgPSBkcm9wem9uZSAmJiAhZHJvcHpvbmUuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSk7XG4gICAgaWYgKG92ZXJFbXB0eURyb3B6b25lICYmIHRoaXNbZHJvcEluRHJvcHpvbmVdKGV2ZW50LCBkcm9wem9uZSkpIHtcbiAgICAgIHRoaXMubGFzdERyb3B6b25lID0gZHJvcHpvbmU7XG4gICAgfSBlbHNlIGlmICgoIWRyb3B6b25lIHx8IGRyb3B6b25lID09PSB0aGlzLmluaXRpYWxEcm9wem9uZSkgJiYgdGhpcy5sYXN0RHJvcHpvbmUpIHtcbiAgICAgIHRoaXNbcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lXShldmVudCk7XG4gICAgICB0aGlzLmxhc3REcm9wem9uZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XG4gICAgY29uc3QgZHJvcHBhYmxlU3RvcEV2ZW50ID0gbmV3IERyb3BwYWJsZVN0b3BFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgZHJvcHpvbmU6IHRoaXMubGFzdERyb3B6b25lIHx8IHRoaXMuaW5pdGlhbERyb3B6b25lXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVN0b3BFdmVudCk7XG4gICAgY29uc3Qgb2NjdXBpZWRDbGFzc2VzID0gdGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKTtcbiAgICBmb3IgKGNvbnN0IGRyb3B6b25lIG9mIHRoaXMuZHJvcHpvbmVzKSB7XG4gICAgICBkcm9wem9uZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJvcHBhYmxlOmFjdGl2ZScpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFzdERyb3B6b25lICYmIHRoaXMubGFzdERyb3B6b25lICE9PSB0aGlzLmluaXRpYWxEcm9wem9uZSkge1xuICAgICAgdGhpcy5pbml0aWFsRHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSguLi5vY2N1cGllZENsYXNzZXMpO1xuICAgIH1cbiAgICB0aGlzLmRyb3B6b25lcyA9IG51bGw7XG4gICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBudWxsO1xuICAgIHRoaXMuaW5pdGlhbERyb3B6b25lID0gbnVsbDtcbiAgfVxuXG4gIFtkcm9wSW5Ecm9wem9uZV0oZXZlbnQsIGRyb3B6b25lKSB7XG4gICAgY29uc3QgZHJvcHBhYmxlRHJvcHBlZEV2ZW50ID0gbmV3IERyb3BwYWJsZURyb3BwZWRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgZHJvcHpvbmVcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlRHJvcHBlZEV2ZW50KTtcbiAgICBpZiAoZHJvcHBhYmxlRHJvcHBlZEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb2NjdXBpZWRDbGFzc2VzID0gdGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKTtcbiAgICBpZiAodGhpcy5sYXN0RHJvcHpvbmUpIHtcbiAgICAgIHRoaXMubGFzdERyb3B6b25lLmNsYXNzTGlzdC5yZW1vdmUoLi4ub2NjdXBpZWRDbGFzc2VzKTtcbiAgICB9XG4gICAgZHJvcHpvbmUuYXBwZW5kQ2hpbGQoZXZlbnQuc291cmNlKTtcbiAgICBkcm9wem9uZS5jbGFzc0xpc3QuYWRkKC4uLm9jY3VwaWVkQ2xhc3Nlcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBbcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lXShldmVudCkge1xuICAgIGNvbnN0IGRyb3BwYWJsZVJldHVybmVkRXZlbnQgPSBuZXcgRHJvcHBhYmxlUmV0dXJuZWRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgZHJvcHpvbmU6IHRoaXMubGFzdERyb3B6b25lXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVJldHVybmVkRXZlbnQpO1xuICAgIGlmIChkcm9wcGFibGVSZXR1cm5lZEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUuYXBwZW5kQ2hpbGQoZXZlbnQuc291cmNlKTtcbiAgICB0aGlzLmxhc3REcm9wem9uZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJvcHBhYmxlOm9jY3VwaWVkJykpO1xuICB9XG5cbiAgW2Nsb3Nlc3REcm9wem9uZV0odGFyZ2V0KSB7XG4gICAgaWYgKCF0aGlzLmRyb3B6b25lcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjbG9zZXN0KHRhcmdldCwgdGhpcy5kcm9wem9uZXMpO1xuICB9XG5cbiAgW2dldERyb3B6b25lc10oKSB7XG4gICAgY29uc3QgZHJvcHpvbmUgPSB0aGlzLm9wdGlvbnMuZHJvcHpvbmU7XG4gICAgaWYgKHR5cGVvZiBkcm9wem9uZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGRyb3B6b25lKTtcbiAgICB9IGVsc2UgaWYgKGRyb3B6b25lIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgZHJvcHpvbmUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcmV0dXJuIGRyb3B6b25lO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRyb3B6b25lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZHJvcHpvbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBEcm9wcGFibGUgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0RXZlbnQgfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RFdmVudC9BYnN0cmFjdEV2ZW50Lm1qcyc7XG5cbmNsYXNzIFN3YXBwYWJsZUV2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5cblN3YXBwYWJsZUV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlJztcbmNsYXNzIFN3YXBwYWJsZVN0YXJ0RXZlbnQgZXh0ZW5kcyBTd2FwcGFibGVFdmVudCB7fVxuU3dhcHBhYmxlU3RhcnRFdmVudC50eXBlID0gJ3N3YXBwYWJsZTpzdGFydCc7XG5Td2FwcGFibGVTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuXG5jbGFzcyBTd2FwcGFibGVTd2FwRXZlbnQgZXh0ZW5kcyBTd2FwcGFibGVFdmVudCB7XG5cbiAgZ2V0IG92ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xuICB9XG5cbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xuICB9XG59XG5Td2FwcGFibGVTd2FwRXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3dhcCc7XG5Td2FwcGFibGVTd2FwRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5cbmNsYXNzIFN3YXBwYWJsZVN3YXBwZWRFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHtcblxuICBnZXQgc3dhcHBlZEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zd2FwcGVkRWxlbWVudDtcbiAgfVxufVxuXG5Td2FwcGFibGVTd2FwcGVkRXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3dhcHBlZCc7XG5jbGFzcyBTd2FwcGFibGVTdG9wRXZlbnQgZXh0ZW5kcyBTd2FwcGFibGVFdmVudCB7fVxuU3dhcHBhYmxlU3RvcEV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlOnN0b3AnO1xuXG5leHBvcnQgeyBTd2FwcGFibGVFdmVudCwgU3dhcHBhYmxlU3RhcnRFdmVudCwgU3dhcHBhYmxlU3RvcEV2ZW50LCBTd2FwcGFibGVTd2FwRXZlbnQsIFN3YXBwYWJsZVN3YXBwZWRFdmVudCB9O1xuIiwgImltcG9ydCBEcmFnZ2FibGUgZnJvbSAnLi4vRHJhZ2dhYmxlL0RyYWdnYWJsZS5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvRHJhZ0V2ZW50L0RyYWdFdmVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvRHJhZ2dhYmxlRXZlbnQvRHJhZ2dhYmxlRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1BsdWdpbnMvQW5ub3VuY2VtZW50L0Fubm91bmNlbWVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvUGx1Z2lucy9NaXJyb3IvTWlycm9yRXZlbnQvTWlycm9yRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1NlbnNvcnMvU2Vuc29yRXZlbnQvU2Vuc29yRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1NlbnNvcnMvVG91Y2hTZW5zb3IvVG91Y2hTZW5zb3IubWpzJztcbmltcG9ydCB7IFN3YXBwYWJsZVN0YXJ0RXZlbnQsIFN3YXBwYWJsZVN3YXBFdmVudCwgU3dhcHBhYmxlU3dhcHBlZEV2ZW50LCBTd2FwcGFibGVTdG9wRXZlbnQgfSBmcm9tICcuL1N3YXBwYWJsZUV2ZW50L1N3YXBwYWJsZUV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuXG5mdW5jdGlvbiBvblN3YXBwYWJsZVN3YXBwZWREZWZhdWx0QW5ub3VuY2VtZW50KHtcbiAgZHJhZ0V2ZW50LFxuICBzd2FwcGVkRWxlbWVudFxufSkge1xuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnc3dhcHBhYmxlIGVsZW1lbnQnO1xuICBjb25zdCBvdmVyVGV4dCA9IHN3YXBwZWRFbGVtZW50LnRleHRDb250ZW50LnRyaW0oKSB8fCBzd2FwcGVkRWxlbWVudC5pZCB8fCAnc3dhcHBhYmxlIGVsZW1lbnQnO1xuICByZXR1cm4gYFN3YXBwZWQgJHtzb3VyY2VUZXh0fSB3aXRoICR7b3ZlclRleHR9YDtcbn1cblxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XG4gICdzd2FwcGFibGVkOnN3YXBwZWQnOiBvblN3YXBwYWJsZVN3YXBwZWREZWZhdWx0QW5ub3VuY2VtZW50XG59O1xuXG5jbGFzcyBTd2FwcGFibGUgZXh0ZW5kcyBEcmFnZ2FibGUge1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoY29udGFpbmVycywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGFubm91bmNlbWVudHM6IHtcbiAgICAgICAgLi4uZGVmYXVsdEFubm91bmNlbWVudHMsXG4gICAgICAgIC4uLihvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmxhc3RPdmVyID0gbnVsbDtcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpLm9mZignZHJhZzpvdmVyJywgdGhpcy5fb25EcmFnT3Zlcikub2ZmKCdkcmFnOnN0b3AnLCB0aGlzLl9vbkRyYWdTdG9wKTtcbiAgfVxuXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcbiAgICBjb25zdCBzd2FwcGFibGVTdGFydEV2ZW50ID0gbmV3IFN3YXBwYWJsZVN0YXJ0RXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTdGFydEV2ZW50KTtcbiAgICBpZiAoc3dhcHBhYmxlU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICBldmVudC5jYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQub3ZlciA9PT0gZXZlbnQub3JpZ2luYWxTb3VyY2UgfHwgZXZlbnQub3ZlciA9PT0gZXZlbnQuc291cmNlIHx8IGV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3dhcHBhYmxlU3dhcEV2ZW50ID0gbmV3IFN3YXBwYWJsZVN3YXBFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgb3ZlcjogZXZlbnQub3ZlcixcbiAgICAgIG92ZXJDb250YWluZXI6IGV2ZW50Lm92ZXJDb250YWluZXJcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoc3dhcHBhYmxlU3dhcEV2ZW50KTtcbiAgICBpZiAoc3dhcHBhYmxlU3dhcEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sYXN0T3ZlciAmJiB0aGlzLmxhc3RPdmVyICE9PSBldmVudC5vdmVyKSB7XG4gICAgICBzd2FwKHRoaXMubGFzdE92ZXIsIGV2ZW50LnNvdXJjZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhc3RPdmVyID09PSBldmVudC5vdmVyKSB7XG4gICAgICB0aGlzLmxhc3RPdmVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXN0T3ZlciA9IGV2ZW50Lm92ZXI7XG4gICAgfVxuICAgIHN3YXAoZXZlbnQuc291cmNlLCBldmVudC5vdmVyKTtcbiAgICBjb25zdCBzd2FwcGFibGVTd2FwcGVkRXZlbnQgPSBuZXcgU3dhcHBhYmxlU3dhcHBlZEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBzd2FwcGVkRWxlbWVudDogZXZlbnQub3ZlclxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTd2FwcGVkRXZlbnQpO1xuICB9XG5cbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XG4gICAgY29uc3Qgc3dhcHBhYmxlU3RvcEV2ZW50ID0gbmV3IFN3YXBwYWJsZVN0b3BFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHN3YXBwYWJsZVN0b3BFdmVudCk7XG4gICAgdGhpcy5sYXN0T3ZlciA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhUZW1wRWxlbWVudChjYWxsYmFjaykge1xuICBjb25zdCB0bXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNhbGxiYWNrKHRtcEVsZW1lbnQpO1xuICB0bXBFbGVtZW50LnJlbW92ZSgpO1xufVxuZnVuY3Rpb24gc3dhcChzb3VyY2UsIG92ZXIpIHtcbiAgY29uc3Qgb3ZlclBhcmVudCA9IG92ZXIucGFyZW50Tm9kZTtcbiAgY29uc3Qgc291cmNlUGFyZW50ID0gc291cmNlLnBhcmVudE5vZGU7XG4gIHdpdGhUZW1wRWxlbWVudCh0bXBFbGVtZW50ID0+IHtcbiAgICBzb3VyY2VQYXJlbnQuaW5zZXJ0QmVmb3JlKHRtcEVsZW1lbnQsIHNvdXJjZSk7XG4gICAgb3ZlclBhcmVudC5pbnNlcnRCZWZvcmUoc291cmNlLCBvdmVyKTtcbiAgICBzb3VyY2VQYXJlbnQuaW5zZXJ0QmVmb3JlKG92ZXIsIHRtcEVsZW1lbnQpO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgU3dhcHBhYmxlIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdEV2ZW50IH0gZnJvbSAnLi4vLi4vc2hhcmVkL0Fic3RyYWN0RXZlbnQvQWJzdHJhY3RFdmVudC5tanMnO1xuXG5jbGFzcyBTb3J0YWJsZUV2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5Tb3J0YWJsZUV2ZW50LnR5cGUgPSAnc29ydGFibGUnO1xuXG5jbGFzcyBTb3J0YWJsZVN0YXJ0RXZlbnQgZXh0ZW5kcyBTb3J0YWJsZUV2ZW50IHtcblxuICBnZXQgc3RhcnRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0SW5kZXg7XG4gIH1cblxuICBnZXQgc3RhcnRDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zdGFydENvbnRhaW5lcjtcbiAgfVxufVxuU29ydGFibGVTdGFydEV2ZW50LnR5cGUgPSAnc29ydGFibGU6c3RhcnQnO1xuU29ydGFibGVTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuXG5jbGFzcyBTb3J0YWJsZVNvcnRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xuXG4gIGdldCBjdXJyZW50SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jdXJyZW50SW5kZXg7XG4gIH1cblxuICBnZXQgb3ZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XG4gIH1cblxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudC5vdmVyQ29udGFpbmVyO1xuICB9XG59XG5Tb3J0YWJsZVNvcnRFdmVudC50eXBlID0gJ3NvcnRhYmxlOnNvcnQnO1xuU29ydGFibGVTb3J0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5cbmNsYXNzIFNvcnRhYmxlU29ydGVkRXZlbnQgZXh0ZW5kcyBTb3J0YWJsZUV2ZW50IHtcblxuICBnZXQgb2xkSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vbGRJbmRleDtcbiAgfVxuXG4gIGdldCBuZXdJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0luZGV4O1xuICB9XG5cbiAgZ2V0IG9sZENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZENvbnRhaW5lcjtcbiAgfVxuXG4gIGdldCBuZXdDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5uZXdDb250YWluZXI7XG4gIH1cbn1cblNvcnRhYmxlU29ydGVkRXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzb3J0ZWQnO1xuXG5jbGFzcyBTb3J0YWJsZVN0b3BFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xuXG4gIGdldCBvbGRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZEluZGV4O1xuICB9XG5cbiAgZ2V0IG5ld0luZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubmV3SW5kZXg7XG4gIH1cblxuICBnZXQgb2xkQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub2xkQ29udGFpbmVyO1xuICB9XG5cbiAgZ2V0IG5ld0NvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0NvbnRhaW5lcjtcbiAgfVxufVxuU29ydGFibGVTdG9wRXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzdG9wJztcblxuZXhwb3J0IHsgU29ydGFibGVFdmVudCwgU29ydGFibGVTb3J0RXZlbnQsIFNvcnRhYmxlU29ydGVkRXZlbnQsIFNvcnRhYmxlU3RhcnRFdmVudCwgU29ydGFibGVTdG9wRXZlbnQgfTtcbiIsICJpbXBvcnQgRHJhZ2dhYmxlIGZyb20gJy4uL0RyYWdnYWJsZS9EcmFnZ2FibGUubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL0RyYWdFdmVudC9EcmFnRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL0RyYWdnYWJsZUV2ZW50L0RyYWdnYWJsZUV2ZW50Lm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9QbHVnaW5zL0Fubm91bmNlbWVudC9Bbm5vdW5jZW1lbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1BsdWdpbnMvTWlycm9yL01pcnJvckV2ZW50L01pcnJvckV2ZW50Lm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9TZW5zb3JzL1NlbnNvckV2ZW50L1NlbnNvckV2ZW50Lm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9TZW5zb3JzL1RvdWNoU2Vuc29yL1RvdWNoU2Vuc29yLm1qcyc7XG5pbXBvcnQgeyBTb3J0YWJsZVN0YXJ0RXZlbnQsIFNvcnRhYmxlU29ydEV2ZW50LCBTb3J0YWJsZVNvcnRlZEV2ZW50LCBTb3J0YWJsZVN0b3BFdmVudCB9IGZyb20gJy4vU29ydGFibGVFdmVudC9Tb3J0YWJsZUV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xuY29uc3Qgb25EcmFnT3ZlckNvbnRhaW5lciA9IFN5bWJvbCgnb25EcmFnT3ZlckNvbnRhaW5lcicpO1xuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuXG5mdW5jdGlvbiBvblNvcnRhYmxlU29ydGVkRGVmYXVsdEFubm91bmNlbWVudCh7XG4gIGRyYWdFdmVudFxufSkge1xuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnc29ydGFibGUgZWxlbWVudCc7XG4gIGlmIChkcmFnRXZlbnQub3Zlcikge1xuICAgIGNvbnN0IG92ZXJUZXh0ID0gZHJhZ0V2ZW50Lm92ZXIudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5vdmVyLmlkIHx8ICdzb3J0YWJsZSBlbGVtZW50JztcbiAgICBjb25zdCBpc0ZvbGxvd2luZyA9IGRyYWdFdmVudC5zb3VyY2UuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZHJhZ0V2ZW50Lm92ZXIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gICAgaWYgKGlzRm9sbG93aW5nKSB7XG4gICAgICByZXR1cm4gYFBsYWNlZCAke3NvdXJjZVRleHR9IGFmdGVyICR7b3ZlclRleHR9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBQbGFjZWQgJHtzb3VyY2VUZXh0fSBiZWZvcmUgJHtvdmVyVGV4dH1gO1xuICAgIH1cbiAgfSBlbHNlIHtcblxuICAgIHJldHVybiBgUGxhY2VkICR7c291cmNlVGV4dH0gaW50byBhIGRpZmZlcmVudCBjb250YWluZXJgO1xuICB9XG59XG5cbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xuICAnc29ydGFibGU6c29ydGVkJzogb25Tb3J0YWJsZVNvcnRlZERlZmF1bHRBbm5vdW5jZW1lbnRcbn07XG5cbmNsYXNzIFNvcnRhYmxlIGV4dGVuZHMgRHJhZ2dhYmxlIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGNvbnRhaW5lcnMsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhbm5vdW5jZW1lbnRzOiB7XG4gICAgICAgIC4uLmRlZmF1bHRBbm5vdW5jZW1lbnRzLFxuICAgICAgICAuLi4ob3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9KVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5zdGFydEluZGV4ID0gbnVsbDtcblxuICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBudWxsO1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ092ZXJDb250YWluZXJdID0gdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXNbb25EcmFnT3ZlckNvbnRhaW5lcl0pLm9mZignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIGluZGV4KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0YWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGVsZW1lbnQucGFyZW50Tm9kZSkuaW5kZXhPZihlbGVtZW50KTtcbiAgfVxuXG4gIGdldFNvcnRhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgY29uc3QgYWxsU29ydGFibGVFbGVtZW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIHJldHVybiBbLi4uYWxsU29ydGFibGVFbGVtZW50c10uZmlsdGVyKGNoaWxkRWxlbWVudCA9PiB7XG4gICAgICByZXR1cm4gY2hpbGRFbGVtZW50ICE9PSB0aGlzLm9yaWdpbmFsU291cmNlICYmIGNoaWxkRWxlbWVudCAhPT0gdGhpcy5taXJyb3IgJiYgY2hpbGRFbGVtZW50LnBhcmVudE5vZGUgPT09IGNvbnRhaW5lcjtcbiAgICB9KTtcbiAgfVxuXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcbiAgICB0aGlzLnN0YXJ0Q29udGFpbmVyID0gZXZlbnQuc291cmNlLnBhcmVudE5vZGU7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gdGhpcy5pbmRleChldmVudC5zb3VyY2UpO1xuICAgIGNvbnN0IHNvcnRhYmxlU3RhcnRFdmVudCA9IG5ldyBTb3J0YWJsZVN0YXJ0RXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIHN0YXJ0SW5kZXg6IHRoaXMuc3RhcnRJbmRleCxcbiAgICAgIHN0YXJ0Q29udGFpbmVyOiB0aGlzLnN0YXJ0Q29udGFpbmVyXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU3RhcnRFdmVudCk7XG4gICAgaWYgKHNvcnRhYmxlU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICBldmVudC5jYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICBbb25EcmFnT3ZlckNvbnRhaW5lcl0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2UsXG4gICAgICBvdmVyLFxuICAgICAgb3ZlckNvbnRhaW5lclxuICAgIH0gPSBldmVudDtcbiAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuaW5kZXgoc291cmNlKTtcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRFdmVudCA9IG5ldyBTb3J0YWJsZVNvcnRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgY3VycmVudEluZGV4OiBvbGRJbmRleCxcbiAgICAgIHNvdXJjZSxcbiAgICAgIG92ZXJcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0RXZlbnQpO1xuICAgIGlmIChzb3J0YWJsZVNvcnRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRTb3J0YWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpO1xuICAgIGNvbnN0IG1vdmVzID0gbW92ZSh7XG4gICAgICBzb3VyY2UsXG4gICAgICBvdmVyLFxuICAgICAgb3ZlckNvbnRhaW5lcixcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gICAgaWYgKCFtb3Zlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvbGRDb250YWluZXIsXG4gICAgICBuZXdDb250YWluZXJcbiAgICB9ID0gbW92ZXM7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLmluZGV4KGV2ZW50LnNvdXJjZSk7XG4gICAgY29uc3Qgc29ydGFibGVTb3J0ZWRFdmVudCA9IG5ldyBTb3J0YWJsZVNvcnRlZEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBvbGRJbmRleCxcbiAgICAgIG5ld0luZGV4LFxuICAgICAgb2xkQ29udGFpbmVyLFxuICAgICAgbmV3Q29udGFpbmVyXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU29ydGVkRXZlbnQpO1xuICB9XG5cbiAgW29uRHJhZ092ZXJdKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50Lm92ZXIgPT09IGV2ZW50Lm9yaWdpbmFsU291cmNlIHx8IGV2ZW50Lm92ZXIgPT09IGV2ZW50LnNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2UsXG4gICAgICBvdmVyLFxuICAgICAgb3ZlckNvbnRhaW5lclxuICAgIH0gPSBldmVudDtcbiAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuaW5kZXgoc291cmNlKTtcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRFdmVudCA9IG5ldyBTb3J0YWJsZVNvcnRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgY3VycmVudEluZGV4OiBvbGRJbmRleCxcbiAgICAgIHNvdXJjZSxcbiAgICAgIG92ZXJcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0RXZlbnQpO1xuICAgIGlmIChzb3J0YWJsZVNvcnRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihvdmVyQ29udGFpbmVyKTtcbiAgICBjb25zdCBtb3ZlcyA9IG1vdmUoe1xuICAgICAgc291cmNlLFxuICAgICAgb3ZlcixcbiAgICAgIG92ZXJDb250YWluZXIsXG4gICAgICBjaGlsZHJlblxuICAgIH0pO1xuICAgIGlmICghbW92ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgb2xkQ29udGFpbmVyLFxuICAgICAgbmV3Q29udGFpbmVyXG4gICAgfSA9IG1vdmVzO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5pbmRleChzb3VyY2UpO1xuICAgIGNvbnN0IHNvcnRhYmxlU29ydGVkRXZlbnQgPSBuZXcgU29ydGFibGVTb3J0ZWRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgb2xkSW5kZXgsXG4gICAgICBuZXdJbmRleCxcbiAgICAgIG9sZENvbnRhaW5lcixcbiAgICAgIG5ld0NvbnRhaW5lclxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRlZEV2ZW50KTtcbiAgfVxuXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xuICAgIGNvbnN0IHNvcnRhYmxlU3RvcEV2ZW50ID0gbmV3IFNvcnRhYmxlU3RvcEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBvbGRJbmRleDogdGhpcy5zdGFydEluZGV4LFxuICAgICAgbmV3SW5kZXg6IHRoaXMuaW5kZXgoZXZlbnQuc291cmNlKSxcbiAgICAgIG9sZENvbnRhaW5lcjogdGhpcy5zdGFydENvbnRhaW5lcixcbiAgICAgIG5ld0NvbnRhaW5lcjogZXZlbnQuc291cmNlLnBhcmVudE5vZGVcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTdG9wRXZlbnQpO1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IG51bGw7XG4gICAgdGhpcy5zdGFydENvbnRhaW5lciA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZWxlbWVudC5wYXJlbnROb2RlLmNoaWxkcmVuLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIG1vdmUoe1xuICBzb3VyY2UsXG4gIG92ZXIsXG4gIG92ZXJDb250YWluZXIsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGNvbnN0IGVtcHR5T3ZlckNvbnRhaW5lciA9ICFjaGlsZHJlbi5sZW5ndGg7XG4gIGNvbnN0IGRpZmZlcmVudENvbnRhaW5lciA9IHNvdXJjZS5wYXJlbnROb2RlICE9PSBvdmVyQ29udGFpbmVyO1xuICBjb25zdCBzYW1lQ29udGFpbmVyID0gb3ZlciAmJiBzb3VyY2UucGFyZW50Tm9kZSA9PT0gb3Zlci5wYXJlbnROb2RlO1xuICBpZiAoZW1wdHlPdmVyQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG1vdmVJbnNpZGVFbXB0eUNvbnRhaW5lcihzb3VyY2UsIG92ZXJDb250YWluZXIpO1xuICB9IGVsc2UgaWYgKHNhbWVDb250YWluZXIpIHtcbiAgICByZXR1cm4gbW92ZVdpdGhpbkNvbnRhaW5lcihzb3VyY2UsIG92ZXIpO1xuICB9IGVsc2UgaWYgKGRpZmZlcmVudENvbnRhaW5lcikge1xuICAgIHJldHVybiBtb3ZlT3V0c2lkZUNvbnRhaW5lcihzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBtb3ZlSW5zaWRlRW1wdHlDb250YWluZXIoc291cmNlLCBvdmVyQ29udGFpbmVyKSB7XG4gIGNvbnN0IG9sZENvbnRhaW5lciA9IHNvdXJjZS5wYXJlbnROb2RlO1xuICBvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHNvdXJjZSk7XG4gIHJldHVybiB7XG4gICAgb2xkQ29udGFpbmVyLFxuICAgIG5ld0NvbnRhaW5lcjogb3ZlckNvbnRhaW5lclxuICB9O1xufVxuZnVuY3Rpb24gbW92ZVdpdGhpbkNvbnRhaW5lcihzb3VyY2UsIG92ZXIpIHtcbiAgY29uc3Qgb2xkSW5kZXggPSBpbmRleChzb3VyY2UpO1xuICBjb25zdCBuZXdJbmRleCA9IGluZGV4KG92ZXIpO1xuICBpZiAob2xkSW5kZXggPCBuZXdJbmRleCkge1xuICAgIHNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBzb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc291cmNlLCBvdmVyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9sZENvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGUsXG4gICAgbmV3Q29udGFpbmVyOiBzb3VyY2UucGFyZW50Tm9kZVxuICB9O1xufVxuZnVuY3Rpb24gbW92ZU91dHNpZGVDb250YWluZXIoc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyKSB7XG4gIGNvbnN0IG9sZENvbnRhaW5lciA9IHNvdXJjZS5wYXJlbnROb2RlO1xuICBpZiAob3Zlcikge1xuICAgIG92ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc291cmNlLCBvdmVyKTtcbiAgfSBlbHNlIHtcblxuICAgIG92ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoc291cmNlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9sZENvbnRhaW5lcixcbiAgICBuZXdDb250YWluZXI6IHNvdXJjZS5wYXJlbnROb2RlXG4gIH07XG59XG5cbmV4cG9ydCB7IFNvcnRhYmxlIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NoYXJ0LmpzXCI7XHJcbmltcG9ydCBDaGFydERhdGFMYWJlbHMgZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2Rpc3QvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5qc1wiO1xyXG5pbXBvcnQgXCIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMtcGx1Z2luLWxhYmVscy1kdi9kaXN0L2NoYXJ0anMtcGx1Z2luLWxhYmVscy5taW4uanNcIjtcclxuXHJcbmNvbnN0IGNvbG9ycyA9IFtcIiMzNmEyZWJcIl07XHJcbmNvbnN0IG1vbnRoID0gW1xyXG4gIFwiSmFudmllclwiLFxyXG4gIFwiRlx1MDBFOXZyaWVyXCIsXHJcbiAgXCJNYXJzXCIsXHJcbiAgXCJBdnJpbFwiLFxyXG4gIFwiTWFpXCIsXHJcbiAgXCJKdWluXCIsXHJcbiAgXCJKdWlsbGV0XCIsXHJcbiAgXCJBb1x1MDBGQnRcIixcclxuICBcIlNlcHRlbWJyZVwiLFxyXG4gIFwiT2N0b2JyZVwiLFxyXG4gIFwiTm92ZW1icmVcIixcclxuICBcIkRcdTAwRTljZW1icmVcIixcclxuXTtcclxuXHJcbmNvbnN0IFNVUlZFWSA9IFtcclxuICBcIlF1YWxpdFx1MDBFOSBkdSB0cmF2YWlsIGVmZmVjdHVcdTAwRTlcIixcclxuICBcIkdhaW4gZGUgdGVtcHMgZHUgY2xpZW50XCIsXHJcbiAgXCJSZXNwZWN0IGR1IGRcdTAwRTlsYWkgZGUgbGl2cmFpc29uXCIsXHJcbiAgXCJRdWFsaXRcdTAwRTkgZGUgbGEgY29tbXVuaWNhdGlvblwiLFxyXG5dO1xyXG5cclxuY2xhc3MgRG91Z2hOdXRDaGFydCB7XHJcbiAgY29uc3RydWN0b3IoY3R4LCBsYWJlbHMsIHZhbHVlcykge1xyXG4gICAgdGhpcy5jaGFydCA9IG5ldyBDaGFydChjdHgsIHtcclxuICAgICAgdHlwZTogXCJkb3VnaG51dFwiLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgbGFiZWxzOiBsYWJlbHMsXHJcbiAgICAgICAgZGF0YXNldHM6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbGFiZWw6IFwiTGlzdGUgZGVzIHRcdTAwRTJjaGVzXCIsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JzLFxyXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZXMsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0sXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgICAgIHBsdWdpbnM6IHtcclxuICAgICAgICAgIGxlZ2VuZDoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB0aXRsZToge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiBcIkxpc3RlIGRlcyB0XHUwMEUyY2hlcyBwYXIgY29udHJpYnV0ZXVyc1wiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICBwbHVnaW5zOiBDaGFydERhdGFMYWJlbHMsXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEhvcml6b250YWxCYXJDaGFydCB7XHJcbiAgY29uc3RydWN0b3IoY3R4LCBsYWJlbHMsIHZhbHVlcykge1xyXG4gICAgdGhpcy5jaGFydCA9IG5ldyBDaGFydChjdHgsIHtcclxuICAgICAgdHlwZTogXCJiYXJcIixcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIGxhYmVsczogbGFiZWxzLFxyXG4gICAgICAgIGRhdGFzZXRzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGF4aXM6IFwieFwiLFxyXG4gICAgICAgICAgICBsYWJlbDogXCJMaXN0ZSBkZXMgdFx1MDBFMmNoZXNcIixcclxuICAgICAgICAgICAgZGF0YTogdmFsdWVzLFxyXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNvbG9ycyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMsXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxyXG4gICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0sXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBpbmRleEF4aXM6IFwieFwiLFxyXG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICAgICAgcGx1Z2luczoge1xyXG4gICAgICAgICAgbGFiZWxzOiB7XHJcbiAgICAgICAgICAgIHJlbmRlcjogXCJ2YWx1ZVwiLFxyXG4gICAgICAgICAgICBmb250Q29sb3I6IFwiIzVjNWM1Y1wiLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJvdXRzaWRlXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbGVnZW5kOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHQ6IFwiTGlzdGUgZGVzIHRcdTAwRTJjaGVzIHBhciBjb250cmlidXRldXJzXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZGF0YWxhYmVsczoge1xyXG4gICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFN0YWNrZWRCYXJDaGFydCB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBjdHgsXHJcbiAgICB0b2RvX3Rhc2tzLFxyXG4gICAgYmxvY2tlZF90YXNrcyxcclxuICAgIHRhc2tzX2luX3Byb2dyZXNzLFxyXG4gICAgdGFza3NfaW5fY29udHJvbCxcclxuICAgIGFjaGlldmVkX3Rhc2tzXHJcbiAgKSB7XHJcbiAgICB0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0KGN0eCwge1xyXG4gICAgICB0eXBlOiBcImJhclwiLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgbGFiZWxzOiBtb250aCxcclxuICAgICAgICBkYXRhc2V0czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBsYWJlbDogXCJUXHUwMEUyY2hlcyBcdTAwRTAgZmFpcmVcIixcclxuICAgICAgICAgICAgZGF0YTogdG9kb190YXNrcyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzNmEyZWJcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIGVuIGJsb2NhZ2VcIixcclxuICAgICAgICAgICAgZGF0YTogYmxvY2tlZF90YXNrcyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlNjdlMjJcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIGVuIGNvdXJzXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHRhc2tzX2luX3Byb2dyZXNzLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzI3YWU2MFwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgZW4gY29udHJcdTAwRjRsZVwiLFxyXG4gICAgICAgICAgICBkYXRhOiB0YXNrc19pbl9jb250cm9sLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzhlNDRhZFwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgYWNoZXZcdTAwRTllc1wiLFxyXG4gICAgICAgICAgICBkYXRhOiBhY2hpZXZlZF90YXNrcyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZjYzODRcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSxcclxuICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgIHBsdWdpbnM6IHtcclxuICAgICAgICAgIGxhYmVsczoge1xyXG4gICAgICAgICAgICByZW5kZXI6IFwidmFsdWVcIixcclxuICAgICAgICAgICAgZm9udENvbG9yOiBcIiM1YzVjNWNcIixcclxuICAgICAgICAgICAgcG9zaXRpb246IFwib3V0c2lkZVwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGxlZ2VuZDoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJib3R0b21cIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB0aXRsZToge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiBcIlRcdTAwRTJjaGVzIHBhciBtb2lzXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgTGluZUNoYXJ0IHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGN0eCxcclxuICAgIHRvZG9fdGFza3MsXHJcbiAgICBibG9ja2VkX3Rhc2tzLFxyXG4gICAgdGFza3NfaW5fcHJvZ3Jlc3MsXHJcbiAgICB0YXNrc19pbl9jb250cm9sLFxyXG4gICAgYWNoaWV2ZWRfdGFza3NcclxuICApIHtcclxuICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCB7XHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBsYWJlbHM6IG1vbnRoLFxyXG4gICAgICAgIGRhdGFzZXRzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiYmFyXCIsXHJcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIFx1MDBFMCBmYWlyZVwiLFxyXG4gICAgICAgICAgICBkYXRhOiB0b2RvX3Rhc2tzLFxyXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogXCJtb25vdG9uZVwiLFxyXG4gICAgICAgICAgICB0ZW5zaW9uOiAwLjQsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiNmZjYzODRcIixcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZjYzODRcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiYmFyXCIsXHJcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIGVuIGJsb2NrYWdlXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IGJsb2NrZWRfdGFza3MsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcIm1vbm90b25lXCIsXHJcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogXCJiYXJcIixcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgZW4gY291cnNcIixcclxuICAgICAgICAgICAgZGF0YTogdGFza3NfaW5fcHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcIm1vbm90b25lXCIsXHJcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogXCJiYXJcIixcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgZW4gY29udHJcdTAwRjRsZVwiLFxyXG4gICAgICAgICAgICBkYXRhOiB0YXNrc19pbl9jb250cm9sLFxyXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogXCJtb25vdG9uZVwiLFxyXG4gICAgICAgICAgICB0ZW5zaW9uOiAwLjQsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMzNmEyZWJcIixcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzNmEyZWJcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiYmFyXCIsXHJcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIGFjaGV2XHUwMEU5ZXNcIixcclxuICAgICAgICAgICAgZGF0YTogYWNoaWV2ZWRfdGFza3MsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcIm1vbm90b25lXCIsXHJcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9LFxyXG4gICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuICAgICAgICBwbHVnaW5zOiB7XHJcbiAgICAgICAgICBsZWdlbmQ6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dDogXCJUXHUwMEUyY2hlcyBwYXIgbW9pc1wiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBTdXJ2ZXlDaGFydCB7XHJcbiAgY29uc3RydWN0b3IoY3R4LCB2YWx1ZXMpIHtcclxuICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCB7XHJcbiAgICAgIHR5cGU6IFwiYmFyXCIsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBsYWJlbHM6IFNVUlZFWSxcclxuICAgICAgICBkYXRhc2V0czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBheGlzOiBcInhcIixcclxuICAgICAgICAgICAgbGFiZWw6IFwiUG91cmNlbnRhZ2UgZGUgc2F0aXNmYWN0aW9uIGVuICVcIixcclxuICAgICAgICAgICAgZGF0YTogdmFsdWVzLFxyXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNvbG9ycyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMsXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAyLFxyXG4gICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0sXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuICAgICAgICBpbmRleEF4aXM6IFwieVwiLFxyXG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICAgICAgcGx1Z2luczoge1xyXG4gICAgICAgICAgbGFiZWxzOiB7XHJcbiAgICAgICAgICAgIHJlbmRlcjogXCJ2YWx1ZVwiLFxyXG4gICAgICAgICAgICBmb250Q29sb3I6IFwiIzVjNWM1Y1wiLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJvdXRzaWRlXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbGVnZW5kOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHQ6IFwiVGF1eCBkZSBzYXRpc2ZhY3Rpb24gZHUgY2xpZW50XCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZGF0YWxhYmVsczoge1xyXG4gICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCB7XHJcbiAgRG91Z2hOdXRDaGFydCxcclxuICBIb3Jpem9udGFsQmFyQ2hhcnQsXHJcbiAgU3RhY2tlZEJhckNoYXJ0LFxyXG4gIExpbmVDaGFydCxcclxuICBTdXJ2ZXlDaGFydFxyXG59O1xyXG4iLCAiIWZ1bmN0aW9uKHQpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6dCgpfSgoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtcbi8qKlxuICAgKiBbY2hhcnRqcy1wbHVnaW4tbGFiZWxzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRlVmlvbGFudGUvY2hhcnRqcy1wbHVnaW4tbGFiZWxzfVxuICAgKlxuICAgKiBAdmVyc2lvbiAzLjEuMFxuICAgKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXSwgRGF2aWRlIFZpb2xhbnRlLCBZb3VzZWYgQWx0YWhlclxuICAgKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTctMjAxOFxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovIWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIENoYXJ0KXJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgZmluZCBDaGFydCBvYmplY3QuXCIpO2NvbnN0IHQ9Q2hhcnQuaGVscGVycztcImZ1bmN0aW9uXCIhPXR5cGVvZiBPYmplY3QuYXNzaWduJiYoT2JqZWN0LmFzc2lnbj1mdW5jdGlvbih0KXtpZighdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO2NvbnN0IGU9T2JqZWN0KHQpO2ZvcihsZXQgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe2NvbnN0IG89YXJndW1lbnRzW3RdO2lmKG8pZm9yKGNvbnN0IHQgaW4gbylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyx0KSYmKGVbdF09b1t0XSl9cmV0dXJuIGV9KTtjb25zdCBlPXt9O2Z1bmN0aW9uIG8oKXt0aGlzLnJlbmRlclRvRGF0YXNldD10aGlzLnJlbmRlclRvRGF0YXNldC5iaW5kKHRoaXMpfWZ1bmN0aW9uIG4odCl7Y29uc3QgZT10Ll9jb250ZXh0LmNoYXJ0LmNvbmZpZy5fY29uZmlnO3JldHVybiEoIWUub3B0aW9uc3x8IWUub3B0aW9ucy5wbHVnaW5zKSYmISFlLm9wdGlvbnMucGx1Z2lucy5sYWJlbHN9W1wicGllXCIsXCJkb3VnaG51dFwiLFwicG9sYXJBcmVhXCIsXCJiYXJcIl0uZm9yRWFjaCgoZnVuY3Rpb24odCl7ZVt0XT0hMH0pKSxvLnByb3RvdHlwZS5zZXR1cD1mdW5jdGlvbih0LGUpe3RoaXMuY2hhcnQ9dCx0aGlzLmN0eD10LmN0eCx0aGlzLmFyZ3M9e30sdGhpcy5iYXJUb3RhbD17fTtjb25zdCBvPXQuY29uZmlnLm9wdGlvbnM7dGhpcy5vcHRpb25zPU9iamVjdC5hc3NpZ24oe3Bvc2l0aW9uOlwiZGVmYXVsdFwiLHByZWNpc2lvbjowLGZvbnRTaXplOm8uZm9udD9vLmZvbnQuc2l6ZToxMixmb250Q29sb3I6by5jb2xvcnx8XCIjMzMzMzMzXCIsZm9udFN0eWxlOm8uZm9udD9vLmZvbnQuc3R5bGU6XCJub3JtYWxcIixmb250RmFtaWx5Om8uZm9udD9vLmZvbnQuZmFtaWx5OlwiJ0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWZcIixzaGFkb3dPZmZzZXRYOjMsc2hhZG93T2Zmc2V0WTozLHNoYWRvd0NvbG9yOlwicmdiYSgwLDAsMCwwLjMpXCIsc2hhZG93Qmx1cjo2LGltYWdlczpbXSxvdXRzaWRlUGFkZGluZzoyLHRleHRNYXJnaW46MixvdmVybGFwOiEwfSxlKSxcImJhclwiPT09dC5jb25maWcudHlwZSYmKHRoaXMub3B0aW9ucy5wb3NpdGlvbj1cImRlZmF1bHRcIix0aGlzLm9wdGlvbnMuYXJjPSExLHRoaXMub3B0aW9ucy5vdmVybGFwPSEwKX0sby5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7dGhpcy5sYWJlbEJvdW5kcz1bXSx0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCh0aGlzLnJlbmRlclRvRGF0YXNldCl9LG8ucHJvdG90eXBlLnJlbmRlclRvRGF0YXNldD1mdW5jdGlvbih0LGUpe3RoaXMudG90YWxQZXJjZW50YWdlPTAsdGhpcy50b3RhbD1udWxsO2NvbnN0IG89dGhpcy5hcmdzW2VdO28ubWV0YS5kYXRhLmZvckVhY2goZnVuY3Rpb24oZSxuKXt0aGlzLnJlbmRlclRvRWxlbWVudCh0LG8sZSxuKX0uYmluZCh0aGlzKSl9LG8ucHJvdG90eXBlLnJlbmRlclRvRWxlbWVudD1mdW5jdGlvbihlLG8sbixpKXtpZighdGhpcy5zaG91bGRSZW5kZXJUb0VsZW1lbnQoby5tZXRhLG4pKXJldHVybjt0aGlzLnBlcmNlbnRhZ2U9bnVsbDtjb25zdCBzPXRoaXMuZ2V0TGFiZWwoZSxuLGkpO2lmKCFzKXJldHVybjtjb25zdCByPXRoaXMuY3R4O3Iuc2F2ZSgpLHIuZm9udD10LmZvbnRTdHJpbmcodGhpcy5vcHRpb25zLmZvbnRTaXplLHRoaXMub3B0aW9ucy5mb250U3R5bGUsdGhpcy5vcHRpb25zLmZvbnRGYW1pbHkpO2NvbnN0IGE9dGhpcy5nZXRSZW5kZXJJbmZvKG4scyk7dGhpcy5kcmF3YWJsZShuLHMsYSk/KHIuYmVnaW5QYXRoKCksci5maWxsU3R5bGU9dGhpcy5nZXRGb250Q29sb3IoZSxuLGkpLHRoaXMucmVuZGVyTGFiZWwocyxhKSxyLnJlc3RvcmUoKSk6ci5yZXN0b3JlKCl9LG8ucHJvdG90eXBlLnJlbmRlckxhYmVsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMub3B0aW9ucy5hcmM/dGhpcy5yZW5kZXJBcmNMYWJlbCh0LGUpOnRoaXMucmVuZGVyQmFzZUxhYmVsKHQsZSl9LG8ucHJvdG90eXBlLnJlbmRlckJhc2VMYWJlbD1mdW5jdGlvbih0LGUpe2NvbnN0IG89dGhpcy5jdHg7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpby5kcmF3SW1hZ2UodCxlLngtdC53aWR0aC8yLGUueS10LmhlaWdodC8yLHQud2lkdGgsdC5oZWlnaHQpO2Vsc2V7by5zYXZlKCksby50ZXh0QmFzZWxpbmU9XCJ0b3BcIixvLnRleHRBbGlnbj1cImNlbnRlclwiLHRoaXMub3B0aW9ucy50ZXh0U2hhZG93JiYoby5zaGFkb3dPZmZzZXRYPXRoaXMub3B0aW9ucy5zaGFkb3dPZmZzZXRYLG8uc2hhZG93T2Zmc2V0WT10aGlzLm9wdGlvbnMuc2hhZG93T2Zmc2V0WSxvLnNoYWRvd0NvbG9yPXRoaXMub3B0aW9ucy5zaGFkb3dDb2xvcixvLnNoYWRvd0JsdXI9dGhpcy5vcHRpb25zLnNoYWRvd0JsdXIpO2NvbnN0IG49dC5zcGxpdChcIlxcblwiKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3QgaT1lLnktdGhpcy5vcHRpb25zLmZvbnRTaXplLzIqbi5sZW5ndGgrdGhpcy5vcHRpb25zLmZvbnRTaXplKnQ7by5maWxsVGV4dChuW3RdLGUueCxpKX1vLnJlc3RvcmUoKX19LG8ucHJvdG90eXBlLnJlbmRlckFyY0xhYmVsPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbz10aGlzLmN0eCxuPWUucmFkaXVzLGk9ZS52aWV3O2lmKG8uc2F2ZSgpLG8udHJhbnNsYXRlKGkueCxpLnkpLFwic3RyaW5nXCI9PXR5cGVvZiB0KXtvLnJvdGF0ZShlLnN0YXJ0QW5nbGUpLG8udGV4dEJhc2VsaW5lPVwibWlkZGxlXCIsby50ZXh0QWxpZ249XCJsZWZ0XCI7Y29uc3QgaT10LnNwbGl0KFwiXFxuXCIpO2xldCBzPTA7Y29uc3Qgcj1bXTtsZXQgYSxoPTA7XCJib3JkZXJcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbiYmKGg9KGkubGVuZ3RoLTEpKnRoaXMub3B0aW9ucy5mb250U2l6ZS8yKTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoOysrdClhPW8ubWVhc3VyZVRleHQoaVt0XSksYS53aWR0aD5zJiYocz1hLndpZHRoKSxyLnB1c2goYS53aWR0aCk7Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDsrK3Qpe2NvbnN0IGU9aVt0XSxsPShpLmxlbmd0aC0xLXQpKi10aGlzLm9wdGlvbnMuZm9udFNpemUraDtvLnNhdmUoKTtjb25zdCBjPShzLXJbdF0pLzI7by5yb3RhdGUoYy9uKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3QgaT1lLmNoYXJBdCh0KTthPW8ubWVhc3VyZVRleHQoaSksby5zYXZlKCksby50cmFuc2xhdGUoMCwtMSpuKSxvLmZpbGxUZXh0KGksMCxsKSxvLnJlc3RvcmUoKSxvLnJvdGF0ZShhLndpZHRoL24pfW8ucmVzdG9yZSgpfX1lbHNlIG8ucm90YXRlKChpLnN0YXJ0QW5nbGUrTWF0aC5QSS8yK2UuZW5kQW5nbGUpLzIpLG8udHJhbnNsYXRlKDAsLTEqbiksdGhpcy5yZW5kZXJMYWJlbCh0LHt4OjAseTowfSk7by5yZXN0b3JlKCl9LG8ucHJvdG90eXBlLnNob3VsZFJlbmRlclRvRWxlbWVudD1mdW5jdGlvbih0LGUpe3JldHVybiF0LmhpZGRlbiYmKHRoaXMub3B0aW9ucy5zaG93WmVyb3x8XCJwb2xhckFyZWFcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGU/MCE9PWUub3V0ZXJSYWRpdXM6MCE9PWUuY2lyY3VtZmVyZW5jZSl9LG8ucHJvdG90eXBlLmdldExhYmVsPWZ1bmN0aW9uKHQsZSxvKXtsZXQgbjtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMucmVuZGVyKW49dGhpcy5vcHRpb25zLnJlbmRlcih7bGFiZWw6dGhpcy5jaGFydC5jb25maWcuZGF0YS5sYWJlbHNbb10sdmFsdWU6dC5kYXRhW29dLHBlcmNlbnRhZ2U6dGhpcy5nZXRQZXJjZW50YWdlKHQsZSxvKSxkYXRhc2V0OnQsaW5kZXg6b30pO2Vsc2Ugc3dpdGNoKHRoaXMub3B0aW9ucy5yZW5kZXIpe2Nhc2VcInZhbHVlXCI6bj10LmRhdGFbb107YnJlYWs7Y2FzZVwibGFiZWxcIjpuPXRoaXMuY2hhcnQuY29uZmlnLmRhdGEubGFiZWxzW29dO2JyZWFrO2Nhc2VcImltYWdlXCI6bj10aGlzLm9wdGlvbnMuaW1hZ2VzW29dP3RoaXMubG9hZEltYWdlKHRoaXMub3B0aW9ucy5pbWFnZXNbb10pOlwiXCI7YnJlYWs7ZGVmYXVsdDpuPXRoaXMuZ2V0UGVyY2VudGFnZSh0LGUsbykrXCIlXCJ9cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIG4/bj10aGlzLmxvYWRJbWFnZShuKTpuJiYobj1uLnRvU3RyaW5nKCkpLG59LG8ucHJvdG90eXBlLmdldEZvbnRDb2xvcj1mdW5jdGlvbih0LGUsbyl7bGV0IG49dGhpcy5vcHRpb25zLmZvbnRDb2xvcjtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP249bih7bGFiZWw6dGhpcy5jaGFydC5jb25maWcuZGF0YS5sYWJlbHNbb10sdmFsdWU6dC5kYXRhW29dLHBlcmNlbnRhZ2U6dGhpcy5nZXRQZXJjZW50YWdlKHQsZSxvKSxiYWNrZ3JvdW5kQ29sb3I6dC5iYWNrZ3JvdW5kQ29sb3Jbb10sZGF0YXNldDp0LGluZGV4Om99KTpcInN0cmluZ1wiIT10eXBlb2YgbiYmKG49bltvXXx8dGhpcy5jaGFydC5jb25maWcub3B0aW9ucy5jb2xvciksbn0sby5wcm90b3R5cGUuZ2V0UGVyY2VudGFnZT1mdW5jdGlvbih0LGUsbyl7aWYodGhpcy5wZXJjZW50YWdlKXJldHVybiB0aGlzLnBlcmNlbnRhZ2U7bGV0IG47aWYoXCJwb2xhckFyZWFcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGV8fFwiZG91Z2hudXRcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGV8fFwicGllXCI9PT10aGlzLmNoYXJ0LmNvbmZpZy50eXBlKXtpZighdGhpcy50b3RhbCl7dGhpcy50b3RhbD0wO2ZvcihsZXQgZT0wO2U8dC5kYXRhLmxlbmd0aDsrK2UpdGhpcy50b3RhbCs9dC5kYXRhW2VdfW49dC5kYXRhW29dL3RoaXMudG90YWwqMTAwfWVsc2UgaWYoXCJiYXJcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGUpe2lmKCF0aGlzLmJhclRvdGFsW29dKXt0aGlzLmJhclRvdGFsW29dPTA7Zm9yKGxldCB0PTA7dDx0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOysrdCl0aGlzLmJhclRvdGFsW29dKz10aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdF0uZGF0YVtvXX1uPXQuZGF0YVtvXS90aGlzLmJhclRvdGFsW29dKjEwMH1lbHNlIG49ZS5jaXJjdW1mZXJlbmNlL3RoaXMuY2hhcnQuY29uZmlnLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSoxMDA7cmV0dXJuIG49cGFyc2VGbG9hdChuLnRvRml4ZWQodGhpcy5vcHRpb25zLnByZWNpc2lvbikpLHRoaXMub3B0aW9ucy5zaG93QWN0dWFsUGVyY2VudGFnZXN8fChcImJhclwiPT09dGhpcy5jaGFydC5jb25maWcudHlwZSYmKHRoaXMudG90YWxQZXJjZW50YWdlPXRoaXMuYmFyVG90YWxQZXJjZW50YWdlW29dfHwwKSx0aGlzLnRvdGFsUGVyY2VudGFnZSs9bix0aGlzLnRvdGFsUGVyY2VudGFnZT4xMDAmJihuLT10aGlzLnRvdGFsUGVyY2VudGFnZS0xMDAsbj1wYXJzZUZsb2F0KG4udG9GaXhlZCh0aGlzLm9wdGlvbnMucHJlY2lzaW9uKSkpLFwiYmFyXCI9PT10aGlzLmNoYXJ0LmNvbmZpZy50eXBlJiYodGhpcy5iYXJUb3RhbFBlcmNlbnRhZ2Vbb109dGhpcy50b3RhbFBlcmNlbnRhZ2UpKSx0aGlzLnBlcmNlbnRhZ2U9bixufSxvLnByb3RvdHlwZS5nZXRSZW5kZXJJbmZvPWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJiYXJcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGU/dGhpcy5nZXRCYXJSZW5kZXJJbmZvKHQsZSk6dGhpcy5vcHRpb25zLmFyYz90aGlzLmdldEFyY1JlbmRlckluZm8odCxlKTp0aGlzLmdldEJhc2VSZW5kZXJJbmZvKHQsZSl9LG8ucHJvdG90eXBlLmdldEJhc2VSZW5kZXJJbmZvPWZ1bmN0aW9uKHQsZSl7aWYoXCJvdXRzaWRlXCI9PT10aGlzLm9wdGlvbnMucG9zaXRpb258fFwiYm9yZGVyXCI9PT10aGlzLm9wdGlvbnMucG9zaXRpb24pe2xldCBvLG49e307Y29uc3QgaT10LHM9aS5zdGFydEFuZ2xlKyhpLmVuZEFuZ2xlLWkuc3RhcnRBbmdsZSkvMixyPWkub3V0ZXJSYWRpdXMvMjtpZihcImJvcmRlclwiPT09dGhpcy5vcHRpb25zLnBvc2l0aW9uP289KGkub3V0ZXJSYWRpdXMtcikvMityOlwib3V0c2lkZVwiPT09dGhpcy5vcHRpb25zLnBvc2l0aW9uJiYobz1pLm91dGVyUmFkaXVzLXIrcit0aGlzLm9wdGlvbnMudGV4dE1hcmdpbiksbj17eDppLngrTWF0aC5jb3Mocykqbyx5OmkueStNYXRoLnNpbihzKSpvfSxcIm91dHNpZGVcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbil7Y29uc3QgdD10aGlzLm9wdGlvbnMudGV4dE1hcmdpbit0aGlzLm1lYXN1cmVMYWJlbChlKS53aWR0aC8yO24ueCs9bi54PGkueD8tdDp0fXJldHVybiBufXJldHVybiB0LnRvb2x0aXBQb3NpdGlvbigpfSxvLnByb3RvdHlwZS5nZXRBcmNSZW5kZXJJbmZvPWZ1bmN0aW9uKHQsZSl7bGV0IG87Y29uc3Qgbj10O289XCJvdXRzaWRlXCI9PT10aGlzLm9wdGlvbnMucG9zaXRpb24/bi5vdXRlclJhZGl1cyt0aGlzLm9wdGlvbnMuZm9udFNpemUrdGhpcy5vcHRpb25zLnRleHRNYXJnaW46XCJib3JkZXJcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbj8obi5vdXRlclJhZGl1cy8yK24ub3V0ZXJSYWRpdXMpLzI6KG4uaW5uZXJSYWRpdXMrbi5vdXRlclJhZGl1cykvMjtsZXQgaT1uLnN0YXJ0QW5nbGUscz1uLmVuZEFuZ2xlO2NvbnN0IHI9cy1pO2krPU1hdGguUEkvMixzKz1NYXRoLlBJLzI7cmV0dXJuIGkrPShzLSh0aGlzLm1lYXN1cmVMYWJlbChlKS53aWR0aC9vK2kpKS8yLHtyYWRpdXM6byxzdGFydEFuZ2xlOmksZW5kQW5nbGU6cyx0b3RhbEFuZ2xlOnIsdmlldzpufX0sby5wcm90b3R5cGUuZ2V0QmFyUmVuZGVySW5mbz1mdW5jdGlvbih0LGUpe2NvbnN0IG89dC50b29sdGlwUG9zaXRpb24oKTtyZXR1cm4gby55LT10aGlzLm1lYXN1cmVMYWJlbChlKS5oZWlnaHQvMit0aGlzLm9wdGlvbnMudGV4dE1hcmdpbixvfSxvLnByb3RvdHlwZS5kcmF3YWJsZT1mdW5jdGlvbih0LGUsbyl7aWYodGhpcy5vcHRpb25zLm92ZXJsYXApcmV0dXJuITA7aWYodGhpcy5vcHRpb25zLmFyYylyZXR1cm4gby5lbmRBbmdsZS1vLnN0YXJ0QW5nbGU8PW8udG90YWxBbmdsZTt7Y29uc3Qgbj10aGlzLm1lYXN1cmVMYWJlbChlKSxpPW8ueC1uLndpZHRoLzIscz1vLngrbi53aWR0aC8yLHI9by55LW4uaGVpZ2h0LzIsYT1vLnkrbi5oZWlnaHQvMjtyZXR1cm5cIm91dHNpZGVcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbj90aGlzLm91dHNpZGVJblJhbmdlKGkscyxyLGEpOnQuaW5SYW5nZShpLHIpJiZ0LmluUmFuZ2UoaSxhKSYmdC5pblJhbmdlKHMscikmJnQuaW5SYW5nZShzLGEpfX0sby5wcm90b3R5cGUub3V0c2lkZUluUmFuZ2U9ZnVuY3Rpb24odCxlLG8sbil7Y29uc3QgaT10aGlzLmxhYmVsQm91bmRzO2ZvcihsZXQgcz0wO3M8aS5sZW5ndGg7KytzKXtjb25zdCByPWlbc107bGV0IGE9W1t0LG9dLFt0LG5dLFtlLG9dLFtlLG5dXTtmb3IobGV0IHQ9MDt0PGEubGVuZ3RoOysrdCl7Y29uc3QgZT1hW3RdWzBdLG89YVt0XVsxXTtpZihlPj1yLmxlZnQmJmU8PXIucmlnaHQmJm8+PXIudG9wJiZvPD1yLmJvdHRvbSlyZXR1cm4hMX1hPVtbci5sZWZ0LHIudG9wXSxbci5sZWZ0LHIuYm90dG9tXSxbci5yaWdodCxyLnRvcF0sW3IucmlnaHQsci5ib3R0b21dXTtmb3IobGV0IGk9MDtpPGEubGVuZ3RoOysraSl7Y29uc3Qgcz1hW2ldWzBdLHI9YVtpXVsxXTtpZihzPj10JiZzPD1lJiZyPj1vJiZyPD1uKXJldHVybiExfX1yZXR1cm4gaS5wdXNoKHtsZWZ0OnQscmlnaHQ6ZSx0b3A6byxib3R0b206bn0pLCEwfSxvLnByb3RvdHlwZS5tZWFzdXJlTGFiZWw9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpcmV0dXJue3dpZHRoOnQud2lkdGgsaGVpZ2h0OnQuaGVpZ2h0fTt7bGV0IGU9MDtjb25zdCBvPXQuc3BsaXQoXCJcXG5cIik7Zm9yKGxldCB0PTA7dDxvLmxlbmd0aDsrK3Qpe2NvbnN0IG49dGhpcy5jdHgubWVhc3VyZVRleHQob1t0XSk7bi53aWR0aD5lJiYoZT1uLndpZHRoKX1yZXR1cm57d2lkdGg6ZSxoZWlnaHQ6dGhpcy5vcHRpb25zLmZvbnRTaXplKm8ubGVuZ3RofX19LG8ucHJvdG90eXBlLmxvYWRJbWFnZT1mdW5jdGlvbih0KXtjb25zdCBlPW5ldyBJbWFnZTtyZXR1cm4gZS5zcmM9dC5zcmMsZS53aWR0aD10LndpZHRoLGUuaGVpZ2h0PXQuaGVpZ2h0LGV9LENoYXJ0LnJlZ2lzdGVyKHtpZDpcImxhYmVsc1wiLGJlZm9yZURhdGFzZXRzVXBkYXRlOmZ1bmN0aW9uKHQsaSxzKXtpZighZVt0LmNvbmZpZy50eXBlXXx8IW4ocykpcmV0dXJuO3MubGVuZ3RofHwocz1bc10pO2NvbnN0IHI9cy5sZW5ndGg7dC5fbGFiZWxzJiZyPT09dC5fbGFiZWxzLmxlbmd0aHx8KHQuX2xhYmVscz1zLm1hcCgoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG99KSkpO2xldCBhPSExLGg9MDtmb3IobGV0IGU9MDtlPHI7KytlKXtjb25zdCBvPXQuX2xhYmVsc1tlXTtpZihvLnNldHVwKHQsc1tlXSksXCJvdXRzaWRlXCI9PT1vLm9wdGlvbnMucG9zaXRpb24pe2E9ITA7Y29uc3QgdD0xLjUqby5vcHRpb25zLmZvbnRTaXplK28ub3B0aW9ucy5vdXRzaWRlUGFkZGluZzt0PmgmJihoPXQpfX1hJiYodC5jaGFydEFyZWEudG9wKz1oLHQuY2hhcnRBcmVhLmJvdHRvbS09aCl9LGFmdGVyRGF0YXNldFVwZGF0ZTpmdW5jdGlvbih0LG8saSl7ZVt0LmNvbmZpZy50eXBlXSYmbihpKSYmdC5fbGFiZWxzPy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmFyZ3Nbby5pbmRleF09b30pKX0sYmVmb3JlRHJhdzpmdW5jdGlvbih0LG8saSl7ZVt0LmNvbmZpZy50eXBlXSYmbihpKSYmdC5fbGFiZWxzPy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmJhclRvdGFsUGVyY2VudGFnZT17fX0pKX0sYWZ0ZXJEYXRhc2V0c0RyYXc6ZnVuY3Rpb24odCxvLGkpe2VbdC5jb25maWcudHlwZV0mJm4oaSkmJnQuX2xhYmVscz8uZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5yZW5kZXIoKX0pKX19KX0oKX0pKTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsMkJBQW1CLFFBQWMsVUFBNkI7QUFDN0QsaUJBQU8sTUFBTSxPQUFPLFFBQVMsV0FBUztBQUNyQyxxQkFBUzs7O0FBSUkseUJBQWdCO1VBSTlCLGNBQWE7QUFBQSxpQkFGTixVQUFPO0FBR2IsaUJBQUssVUFBVTs7VUFHaEIsR0FBRyxRQUFlLEtBQWM7QUFDL0Isc0JBQVUsUUFBUSxXQUFVO0FBQzNCLG9CQUFNLGNBQWMsS0FBSyxRQUFRLFVBQVU7QUFDM0MsMEJBQVksS0FBSztBQUNqQixtQkFBSyxRQUFRLFNBQVM7OztVQUl4QixJQUFJLFFBQWUsS0FBYztBQUNoQyxnQkFBSSxJQUFJLFVBQVU7QUFDbEIsZ0JBQUksTUFBTSxHQUFHO0FBQ1osbUJBQUssVUFBVTtBQUNmOztBQUdELHNCQUFVLFFBQVEsV0FBVTtBQUUzQixrQkFBSSxNQUFNLEdBQUU7QUFDWCx1QkFBTyxLQUFLLFFBQVE7QUFDcEI7O0FBR0Qsb0JBQU0sY0FBYyxLQUFLLFFBQVE7QUFDakMsa0JBQUksZ0JBQWdCO0FBQVk7QUFFaEMsMEJBQVksT0FBTyxZQUFZLFFBQVEsTUFBTTtBQUM3QyxtQkFBSyxRQUFRLFNBQVM7OztVQUl4QixRQUFRLFdBQWtCLE1BQVM7QUFDbEMsZ0JBQUksUUFBTztBQUVYLHNCQUFVLFFBQVEsV0FBVTtBQUMzQixvQkFBTSxjQUFjLE1BQUssUUFBUTtBQUNqQyxrQkFBSSxnQkFBZ0I7QUFBWTtBQUNoQywwQkFBWSxRQUFRLFNBQU87QUFDMUIsb0JBQUksTUFBTSxPQUFNOzs7OztBQ2xDTCw2QkFBcUIsV0FBZ0I7QUFFbkQsb0JBQVUsVUFBVTtBQUVwQixpQkFBTyxjQUFjLFVBQVM7WUFBQSxlQUFBLE1BQUE7QUFBQSxvQkFBQSxHQUFBO0FBQUEsbUJBRXRCLFVBQW1CO2dCQUN6QixPQUFZO2dCQUNaLFVBQVk7Z0JBQ1osV0FBWTtnQkFDWixRQUFZOzs7bUJBUU4sT0FBTyxNQUFhLElBQXNDO0FBQ2hFLHdCQUFVLFFBQVEsUUFBUTtnQkFDekIsUUFBUztnQkFDVCxNQUFTOzs7WUFvQlgsa0JBQWtCLFNBQTRDO0FBQzdELGtCQUFJLEtBQUs7QUFDVCxvQkFBTSxRQUFRO0FBQ2Qsb0JBQU0sUUFBaUI7QUFFdkIsa0JBQUksTUFBTSxRQUFRLFVBQVU7QUFDM0Isd0JBQVEsUUFBUyxZQUE0QjtBQUM1QyxzQkFBSSxPQUFPLFdBQVcsVUFBVTtBQUMvQiwwQkFBTSxLQUFLO3lCQUNMO0FBQ04sMEJBQUssUUFBUSxTQUFTLE9BQU8sUUFBUSxPQUFPO0FBQzVDLDBCQUFNLEtBQUssT0FBTzs7O3lCQUdWLFNBQVM7QUFDbkIscUJBQUssT0FBTyxTQUFTO0FBQ3BCLHNCQUFJLFFBQVEsZUFBZSxNQUFNO0FBQ2hDLDBCQUFLLFFBQVEsU0FBUyxPQUFPLFFBQVE7QUFDckMsMEJBQU0sS0FBSzs7OztBQUtkLHFCQUFPLE9BQU8sTUFBTSxTQUFTO0FBQzVCLHNCQUFLLFFBQVE7OztZQUlmLFdBQVcsTUFBYTtBQUN2QixrQkFBSSxRQUFVO0FBQ2Qsa0JBQUksVUFBVSxNQUFLO0FBQ25CLGtCQUFJLFNBQVUsVUFBVSxRQUFRO0FBRWhDLGtCQUFJLENBQUMsVUFBVSxRQUFRLGVBQWUsT0FBTztBQUM1QyxzQkFBTSxJQUFJLE1BQU0scUJBQXNCLE9BQU87O0FBRzlDLHNCQUFRLFVBQVUsUUFBUTtBQUMxQixzQkFBUSxPQUFPLFFBQVEsT0FBTyxHQUFHLE1BQU0sT0FBTSxDQUFDLE1BQUssUUFBUSxTQUFTLFNBQVM7QUFDN0Usc0JBQVEsTUFBTSxLQUFLOztZQU9wQixRQUFRLE1BQWE7QUFDcEIsa0JBQUksUUFBTztBQUNYLGtCQUFJLFVBQVUsTUFBSztBQUVuQixrQkFBSSxDQUFDLE1BQUssUUFBUSxPQUFPLGVBQWUsT0FBTztBQUM5QyxvQkFBSSxRQUFRLFVBQVUsT0FBTztBQUM1Qix3QkFBTSxJQUFJLE1BQU0sc0NBQXNDLE9BQU87O0FBRTlELHNCQUFLLFdBQVc7O0FBR2pCLHFCQUFPLFFBQVEsT0FBTzs7OztBQ25JekIsQUFRQSxjQUFNLGlCQUFpQixXQUFTO0FBQzlCLGtCQUFRLE1BQU0sT0FBTztBQUVyQixjQUFJLE1BQU0sU0FBUyxHQUFHO0FBQ3BCLG1CQUFPLE1BQU0sTUFBTTs7QUFHckIsaUJBQU8sZUFBZSxVQUFVLElBQUksTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFFBQVEsTUFBTSxLQUFLLE9BQU87O0FBTzdGLGNBQU0sa0JBQWtCLFdBQVM7QUFDL0IsY0FBSSxDQUFDLGNBQWMsUUFBUTtBQUN6QixtQkFBTyxNQUFNLEtBQUs7O0FBR3BCLGNBQUksVUFBVTtBQUNkLGNBQUksa0JBQWtCO0FBRXRCLGdCQUFNLGVBQWUsTUFBTTtBQUN6QixnQkFBSSxrQkFBa0IsR0FBRztBQUN2Qix5QkFBVyxNQUFNLGtCQUFrQjs7O0FBSXZDLGdCQUFNLFFBQVEsQ0FBQyxNQUFNLE1BQU07QUFDekIsZ0JBQUksU0FBUyxNQUFNLElBQUksSUFBSTtBQUN6QjtBQUNBOztBQUdGO0FBQ0EsdUJBQVc7QUFDWCw4QkFBa0I7O0FBRXBCO0FBQ0EsaUJBQU87O0FBVVQsY0FBTSxlQUFlLFdBQVM7QUFDNUIsY0FBSSxRQUFRLFFBQVE7QUFDcEIsaUJBQU8sZUFBZTs7QUFReEIsY0FBTSxnQkFBZ0IsV0FBUztBQUM3QixpQkFBTyxJQUFJLElBQUksT0FBTyxTQUFTLE1BQU07O0FBUXZDLGNBQU0sZUFBZSxTQUFPO0FBQzFCLGlCQUFRLE9BQU0sSUFBSSxRQUFRLHNDQUFzQzs7QUFRbEUsY0FBTSxpQkFBaUIsV0FBUztBQUM5QixpQkFBTyxNQUFNLE9BQU8sQ0FBQyxTQUFTLFVBQVUsS0FBSyxJQUFJLFNBQVMsY0FBYyxTQUFTOztBQU1uRixjQUFNLGdCQUFnQixTQUFPO0FBQzNCLGlCQUFPLFFBQVEsS0FBSzs7QUFPdEIsY0FBTSxVQUFVLE9BQUssTUFBTSxLQUFLO0FDcEdoQyxBQU9BLGNBQU0sZ0JBQWdCLFdBQVM7QUFDN0IsY0FBSSxNQUFNLFdBQVc7QUFBRyxtQkFBTyxDQUFDLENBQUM7QUFHakMsY0FBSSxTQUFTO0FBQ2IsZ0JBQU0sUUFBUSxNQUFNLFVBQVU7QUFDOUIsZ0JBQU0sT0FBTyxjQUFjO0FBQzNCLGVBQUssUUFBUSxTQUFVLFdBQVc7QUFDaEMsZ0JBQUksTUFBTSxVQUFVLE1BQU07QUFDMUIsZ0JBQUksS0FBSyxNQUFNLE9BQU8sS0FBSyxJQUFJO0FBQy9CLG1CQUFPLEtBQUs7QUFDWixrQkFBTSxVQUFVLE1BQU07QUFDdEIsZ0JBQUksUUFBUSxNQUFNLE9BQU87QUFDekIsbUJBQU8sS0FBSzs7QUFFZCxpQkFBTzs7QUN0QlQsQUFjQSxjQUFNLGNBQWMsQ0FBQyxDQUFDLEdBQUc7QUFDekIsY0FBTSxhQUFhO0FBR25CLFlBQUk7QUFHSixZQUFJO0FBQ0osY0FBTSxrQkFBa0I7QUFHeEIsY0FBTSxnQkFBZ0I7QUFHdEIsY0FBTSxrQkFBa0I7VUFDdEIsS0FBSztVQUNMLEtBQUs7VUFDTCxLQUFLO1VBQ0wsTUFBTTtVQUNOLE1BQU07VUFDTixNQUFNO1VBQ04sTUFBTTtVQUNOLE1BQU07VUFDTixNQUFNO1VBQ04sS0FBSztVQUNMLEtBQUs7VUFDTCxLQUFLO1VBQ0wsS0FBSztVQUNMLEtBQUs7VUFDTCxLQUFLO1VBQ0wsS0FBSztVQUNMLEtBQUs7VUFDTCxLQUFLO1VBQ0wsS0FBSztVQUNMLEtBQUs7VUFDTCxLQUFLO1VBQ0wsS0FBSztVQUNMLEtBQUs7VUFDTCxNQUFNO1VBQ04sTUFBTTtVQUNOLE1BQU07VUFDTixNQUFNO1VBQ04sS0FBSztVQUNMLEtBQUs7VUFDTCxLQUFLO1VBQ0wsS0FBSztVQUNMLEtBQUs7VUFDTCxNQUFNO1VBQ04sTUFBTTtVQUNOLEtBQUs7VUFDTCxLQUFLO1VBQ0wsTUFBTTtVQUNOLEtBQUs7VUFDTCxLQUFLO1VBQ0wsS0FBSztVQUNMLE1BQU07O0FBR1IsaUJBQVMsU0FBUyxpQkFBaUI7QUFDakMsY0FBSSxVQUFVLGdCQUFnQixVQUFVO0FBRXhDLG1CQUFTLElBQUksR0FBRyxJQUFJLFFBQVEsUUFBUSxLQUFLO0FBQ3ZDLGdCQUFJLE9BQU8sUUFBUSxVQUFVLEdBQUcsSUFBSTtBQUNwQywwQkFBYyxRQUFROzs7QUFJMUIsY0FBTSxjQUFjLElBQUksT0FBTyxPQUFPLEtBQUssZUFBZSxLQUFLLE9BQU8sTUFBTSxZQUFZO0FBT3hGLGNBQU0sYUFBYSxrQkFBZ0I7QUFDakMsY0FBSSxnQkFBZ0I7QUFBVztBQUMvQix3QkFBYyxZQUFZLGdCQUFnQjs7QUFTNUMsY0FBTSxZQUFZLENBQUMsS0FBSyxPQUFPLFdBQVcsSUFBSSxVQUFVO0FBU3hELGNBQU0sWUFBWSxTQUFPO0FBQ3ZCLGlCQUFPLFFBQVEsS0FBSyxPQUtwQixDQUFDLFFBQVEsU0FBUztBQUNoQixtQkFBTyxTQUFTLFdBQVc7YUFDMUI7O0FBT0wsY0FBTSxhQUFhLFNBQU87QUFDeEIsZ0JBQU0sVUFBVSxLQUFLLGNBQWMsUUFBUSxhQUFhLENBRXhELFNBQVM7QUFDUCxtQkFBTyxjQUFjLFNBQVM7O0FBR2hDLGlCQUFPLFVBQVUsS0FBSzs7QUFReEIsNEJBQW9CLGNBQWE7QUFDL0IscUJBQVcsQ0FBQyxnQkFBZ0IsbUJBQW1CLGNBQWE7QUFDMUQscUJBQVMsSUFBSSxnQkFBZ0IsS0FBSyxnQkFBZ0IsS0FBSztBQUNyRCxrQkFBSSxXQUFXLE9BQU8sYUFBYTtBQUNuQyxrQkFBSSxTQUFTLFVBQVU7QUFFdkIsa0JBQUksVUFBVSxTQUFTLGVBQWU7QUFDcEM7O0FBUUYsa0JBQUksT0FBTyxTQUFTLGlCQUFpQjtBQUNuQzs7QUFHRixrQkFBSSxPQUFPLFVBQVUsR0FBRztBQUN0Qjs7QUFHRixvQkFBTTtnQkFDSjtnQkFDQTtnQkFDQSxZQUFZOzs7OztBQVdwQixjQUFNLGVBQWUsa0JBQWU7QUFFbEMsZ0JBQU0sZUFBZTtBQU1yQixnQkFBTSxjQUFjLENBQUMsUUFBUSxXQUFXO0FBRXRDLGtCQUFNLGFBQWEsYUFBYSxXQUFXLG9CQUFJO0FBQy9DLGtCQUFNLE9BQU8sSUFBSSxPQUFPLE1BQU0sYUFBYSxjQUFjLEtBQUs7QUFFOUQsZ0JBQUksT0FBTyxNQUFNLE9BQU87QUFDdEI7O0FBR0YsdUJBQVcsSUFBSSxhQUFhO0FBQzVCLHlCQUFhLFVBQVU7O0FBR3pCLG1CQUFTLFNBQVMsVUFBVSxlQUFjO0FBQ3hDLHdCQUFZLE1BQU0sUUFBUSxNQUFNO0FBQ2hDLHdCQUFZLE1BQU0sUUFBUSxNQUFNOztBQUdsQyxpQkFBTzs7QUFVVCxjQUFNLGNBQWMsa0JBQWU7QUFFakMsZ0JBQU0sZUFBZSxhQUFhO0FBR2xDLGdCQUFNLGVBQWM7QUFHcEIsY0FBSSxhQUFhO0FBRWpCLG1CQUFTLFVBQVUsY0FBYztBQUMvQixnQkFBSSxNQUFNLGFBQWE7QUFFdkIsZ0JBQUksS0FBSztBQUNQLDJCQUFZLFVBQVUsYUFBYTs7QUFHckMsZ0JBQUksT0FBTyxTQUFTLEdBQUc7QUFDckIseUJBQVcsS0FBSyxhQUFhOzs7QUFJakMscUJBQVcsS0FBSyxDQUFDLEdBQUcsTUFBTSxFQUFFLFNBQVMsRUFBRTtBQUN2QyxnQkFBTSxrQkFBa0IsZUFBZTtBQUN2QywyQkFBaUIsSUFBSSxPQUFPLE1BQU0saUJBQWlCO0FBQ25ELGlCQUFPOztBQVNULGNBQU0sY0FBYyxDQUFDLFNBQVMsa0JBQWtCLE1BQU07QUFDcEQsY0FBSSxpQkFBaUI7QUFDckIsb0JBQVUsUUFBUSxJQUFJLFNBQU87QUFDM0IsZ0JBQUksWUFBWSxNQUFNO0FBQ3BCLGdDQUFrQixJQUFJOztBQUd4QixtQkFBTyxZQUFZLFFBQVE7O0FBRzdCLGNBQUksa0JBQWtCLGlCQUFpQjtBQUNyQyxtQkFBTyxnQkFBZ0I7O0FBR3pCLGlCQUFPOztBQWdCVCxjQUFNLHNCQUFzQixDQUFDLEtBQUssa0JBQWtCLE1BQU07QUFDeEQsNEJBQWtCLEtBQUssSUFBSSxpQkFBaUIsSUFBSSxTQUFTO0FBQ3pELGlCQUFPLGVBQWUsY0FBYyxLQUFLLElBQUksYUFBVztBQUN0RCxtQkFBTyxZQUFZLFNBQVM7OztBQVdoQyxjQUFNLHFCQUFxQixDQUFDLFdBQVcsTUFBTSxTQUFTO0FBQ3BELGNBQUksa0JBQWtCLFVBQVUsU0FBUyxJQUFJLElBQUk7QUFDakQsaUJBQU8sZUFBZSxVQUFVLElBQUksY0FBWTtBQUM5QyxnQkFBSSxNQUFNO0FBQ1Ysa0JBQU0sTUFBTSxNQUFNLFNBQVMsV0FBVyxTQUFTLFdBQVc7QUFFMUQscUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLO0FBQzVCLGtCQUFJLEtBQUssb0JBQW9CLFNBQVMsUUFBUSxNQUFNLElBQUk7O0FBRzFELG1CQUFPLGdCQUFnQjs7O0FBVTNCLGNBQU0sY0FBYyxDQUFDLFlBQVksY0FBYztBQUM3QyxxQkFBVyxPQUFPLFdBQVc7QUFDM0IsZ0JBQUksSUFBSSxTQUFTLFdBQVcsU0FBUyxJQUFJLE9BQU8sV0FBVyxLQUFLO0FBQzlEOztBQUdGLGdCQUFJLElBQUksUUFBUSxLQUFLLFFBQVEsV0FBVyxRQUFRLEtBQUssS0FBSztBQUN4RDs7QUFHRixnQkFBSSxlQUFlLFdBQVc7QUFLOUIsa0JBQU0sU0FBUyxVQUFRO0FBQ3JCLHlCQUFXLGVBQWUsY0FBYztBQUN0QyxvQkFBSSxZQUFZLFVBQVUsS0FBSyxTQUFTLFlBQVksV0FBVyxLQUFLLFFBQVE7QUFDMUUseUJBQU87O0FBR1Qsb0JBQUksS0FBSyxVQUFVLEtBQUssWUFBWSxVQUFVLEdBQUc7QUFDL0M7O0FBUUYsb0JBQUksS0FBSyxRQUFRLFlBQVksU0FBUyxLQUFLLE1BQU0sWUFBWSxPQUFPO0FBQ2xFLHlCQUFPOztBQUdULG9CQUFJLFlBQVksUUFBUSxLQUFLLFNBQVMsWUFBWSxNQUFNLEtBQUssT0FBTztBQUNsRSx5QkFBTzs7O0FBSVgscUJBQU87O0FBR1QsZ0JBQUksV0FBVyxJQUFJLE1BQU0sT0FBTztBQUVoQyxnQkFBSSxTQUFTLFNBQVMsR0FBRztBQUN2Qjs7QUFHRixtQkFBTzs7QUFHVCxpQkFBTzs7QUFHVCx1QkFBZTtVQUNiLGNBQWM7QUFFWixpQkFBSyxRQUFRO0FBR2IsaUJBQUssVUFBVTtBQUNmLGlCQUFLLFFBQVE7QUFDYixpQkFBSyxNQUFNOztVQU9iLElBQUksTUFBTTtBQUNSLGdCQUFJLE1BQU07QUFDUixtQkFBSyxNQUFNLEtBQUs7QUFDaEIsbUJBQUssUUFBUSxLQUFLLEtBQUs7QUFDdkIsbUJBQUssUUFBUSxLQUFLLElBQUksS0FBSyxPQUFPLEtBQUs7QUFDdkMsbUJBQUssTUFBTSxLQUFLLElBQUksS0FBSyxLQUFLLEtBQUs7OztVQUl2QyxPQUFPO0FBQ0wsbUJBQU8sS0FBSyxNQUFNLEtBQUssTUFBTSxTQUFTOztVQUd4QyxTQUFTO0FBQ1AsbUJBQU8sS0FBSyxNQUFNOztVQVFwQixNQUFNLFVBQVUsWUFBWTtBQUMxQixnQkFBSSxTQUFRLElBQUk7QUFDaEIsZ0JBQUksUUFBUSxLQUFLLE1BQU0sS0FBSyxVQUFVLEtBQUs7QUFDM0MsZ0JBQUksWUFBWSxNQUFNO0FBRXRCLHVCQUFXLFFBQVEsT0FBTztBQUN4QixxQkFBTSxJQUFJOztBQUdaLGdCQUFJLGNBQWMsV0FBVyxPQUFPLFVBQVUsR0FBRyxXQUFXLFVBQVU7QUFDdEUsZ0JBQUksaUJBQWlCLFlBQVk7QUFDakMsbUJBQU0sSUFBSTtjQUNSLE9BQU8sVUFBVTtjQUNqQixLQUFLLFVBQVUsUUFBUTtjQUN2QixRQUFRO2NBQ1IsUUFBUTs7QUFFVixtQkFBTzs7O0FBcUJYLGNBQU0sYUFBYSxTQUFPO0FBQ3hCO0FBQ0EsZ0JBQU0sVUFBVTtBQUNoQixjQUFJLFVBQVU7QUFDZCxjQUFJLFlBQVksQ0FBQyxJQUFJO0FBRXJCLG1CQUFTLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxLQUFLO0FBQ25DLGdCQUFJLFNBQVMsSUFBSSxVQUFVO0FBQzNCLGdCQUFJLFFBQVEsT0FBTyxNQUFNO0FBQ3pCLGtCQUFNLE9BQU8sSUFBSSxVQUFVLEdBQUcsSUFBSTtBQUNsQyxrQkFBTSxZQUFZLFFBQVEsTUFBTSxLQUFLO0FBR3JDLGdCQUFJLGNBQWM7QUFDbEIsZ0JBQUksY0FBYyxvQkFBSTtBQUV0Qix1QkFBVyxZQUFZLFdBQVc7QUFDaEMsb0JBQU0sYUFBYSxTQUFTO0FBRTVCLGtCQUFJLENBQUMsY0FBYyxXQUFXLFVBQVUsS0FBSyxXQUFXLE9BQU8sR0FBRztBQUVoRSxvQkFBSSxXQUFXO0FBQ2Isd0JBQU0sTUFBTSxVQUFVO0FBQ3RCLDJCQUFTLElBQUk7b0JBQ1gsT0FBTztvQkFDUCxLQUFLLElBQUk7b0JBQ1QsUUFBUTtvQkFDUixRQUFROztBQUVWLDhCQUFZLElBQUk7dUJBQ1g7QUFDTCwyQkFBUyxJQUFJO29CQUNYLE9BQU87b0JBQ1AsS0FBSyxJQUFJO29CQUNULFFBQVE7b0JBQ1IsUUFBUTs7QUFFViw4QkFBWSxJQUFJOzt5QkFFVCxXQUFXO0FBQ3BCLG9CQUFJLFNBQVEsU0FBUyxNQUFNLEdBQUc7QUFDOUIsc0JBQU0sTUFBTSxVQUFVO0FBQ3RCLHVCQUFNLElBQUk7a0JBQ1IsT0FBTztrQkFDUCxLQUFLLElBQUk7a0JBQ1QsUUFBUTtrQkFDUixRQUFROztBQUVWLDRCQUFZLEtBQUs7cUJBQ1o7QUFHTCw0QkFBWSxJQUFJOzs7QUFLcEIsZ0JBQUksWUFBWSxTQUFTLEdBQUc7QUFFMUIsNEJBQWMsWUFBWSxLQUFLLENBQUMsR0FBRyxNQUFNO0FBQ3ZDLHVCQUFPLEVBQUUsV0FBVyxFQUFFOztBQUd4Qix1QkFBUyxVQUFTLGFBQWE7QUFFN0Isb0JBQUksWUFBWSxRQUFPLFlBQVk7QUFDakM7O0FBR0YsMEJBQVUsS0FBSzs7QUFHakI7O0FBT0YsZ0JBQUksSUFBSSxLQUFLLFlBQVksUUFBUSxLQUFLLENBQUMsWUFBWSxJQUFJLE1BQU07QUFDM0QseUJBQVcsbUJBQW1CLFdBQVc7QUFDekMsa0JBQUksVUFBVSxJQUFJO0FBQ2xCLG9CQUFNLFVBQVUsVUFBVTtBQUUxQixrQkFBSSxTQUFTO0FBQ1gsd0JBQVEsSUFBSSxRQUFROztBQUd0QiwwQkFBWSxDQUFDOzs7QUFJakIscUJBQVcsbUJBQW1CLFdBQVc7QUFDekMsaUJBQU87O0FDbmhCVCxBQVNBLGNBQU0sVUFBVSxDQUFDLEtBQUssU0FBUztBQUM3QixjQUFJLENBQUM7QUFBSztBQUNWLGlCQUFPLElBQUk7O0FBU2IsY0FBTSxpQkFBaUIsQ0FBQyxLQUFLLFNBQVM7QUFDcEMsY0FBSSxDQUFDO0FBQUs7QUFDVixjQUFJLE1BQ0EsUUFBUSxLQUFLLE1BQU07QUFFdkIsaUJBQVEsUUFBTyxNQUFNLFlBQWEsT0FBTSxJQUFJO0FBQU87QUFFbkQsaUJBQU87O0FBUVQsY0FBTSxhQUFhLENBQUMsT0FBTyxPQUFPLFdBQVc7QUFDM0MsY0FBSSxPQUFPO0FBQ1gsY0FBSSxDQUFDO0FBQU8sbUJBQU87QUFDbkIsa0JBQVEsUUFBUTtBQUNoQixjQUFJLE1BQU0sU0FBUztBQUFNLG1CQUFPO0FBQ2hDLGdCQUFNLE1BQU0sT0FBTyxNQUFNO0FBQ3pCLGNBQUksUUFBUTtBQUFJLG1CQUFPO0FBQ3ZCLGtCQUFRLE1BQU0sT0FBTyxTQUFTLE1BQU07QUFDcEMsY0FBSSxRQUFRO0FBQUcscUJBQVM7QUFDeEIsaUJBQU8sUUFBUTs7QUFPakIsY0FBTSxjQUFjLENBQUMsS0FBSyxRQUFRO0FBQ2hDLGNBQUksUUFBUSxJQUFJO0FBQ2hCLGNBQUksT0FBTyxTQUFTO0FBQVksbUJBQU87QUFFdkMsY0FBSSxTQUFTLENBQUMsTUFBTSxRQUFRLFFBQVE7QUFDbEMsZ0JBQUksT0FBTyxDQUFDOzs7QUFjaEIsY0FBTSxZQUFVLENBQUMsUUFBUSxhQUFhO0FBQ3BDLGNBQUksTUFBTSxRQUFRLFNBQVM7QUFDekIsbUJBQU8sUUFBUTtpQkFDVjtBQUNMLHFCQUFTLE9BQU8sUUFBUTtBQUN0QixrQkFBSSxPQUFPLGVBQWUsTUFBTTtBQUM5Qix5QkFBUyxPQUFPLE1BQU07Ozs7O0FBSzlCLGNBQU0sTUFBTSxDQUFDLEdBQUcsTUFBTTtBQUNwQixjQUFJLE9BQU8sTUFBTSxZQUFZLE9BQU8sTUFBTSxVQUFVO0FBQ2xELG1CQUFPLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxLQUFLOztBQUdsQyxjQUFJLFVBQVUsSUFBSSxJQUFJO0FBQ3RCLGNBQUksVUFBVSxJQUFJLElBQUk7QUFDdEIsY0FBSSxJQUFJO0FBQUcsbUJBQU87QUFDbEIsY0FBSSxJQUFJO0FBQUcsbUJBQU87QUFDbEIsaUJBQU87O0FDMUZULEFBc0JBLHFCQUFhO1VBU1gsWUFBWSxPQUFPLFVBQVU7QUFDM0IsaUJBQUssUUFBUTtBQUNiLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssUUFBUTtBQUNiLGlCQUFLLFdBQVcsWUFBWTtjQUMxQixZQUFZOzs7VUFTaEIsU0FBUyxPQUFPLHlCQUF5QixTQUFTO0FBQ2hELGdCQUFJLENBQUMsU0FBUyxDQUFDLE1BQU07QUFBUSxxQkFBTztBQUNwQyxrQkFBTSxTQUFTO0FBQ2Ysa0JBQU0sUUFBUSxNQUFNLE1BQU07QUFDMUIsZ0JBQUk7QUFFSixnQkFBSSxTQUFTO0FBQ1gsNEJBQWMsSUFBSSxPQUFPLE9BQU8sT0FBTyxLQUFLLFNBQVMsSUFBSSxjQUFjLEtBQUssT0FBTzs7QUFHckYsa0JBQU0sUUFBUSxVQUFRO0FBQ3BCLGtCQUFJO0FBQ0osa0JBQUksUUFBUTtBQUNaLGtCQUFJLFFBQVE7QUFFWixrQkFBSSxlQUFnQixlQUFjLEtBQUssTUFBTSxlQUFlO0FBQzFELHdCQUFRLFlBQVk7QUFDcEIsdUJBQU8sWUFBWTs7QUFHckIsa0JBQUksS0FBSyxTQUFTLEdBQUc7QUFDbkIsb0JBQUksS0FBSyxTQUFTLFlBQVk7QUFDNUIsMEJBQVEsV0FBVyxTQUFTO3VCQUN2QjtBQUNMLDBCQUFRLGFBQWE7O0FBR3ZCLG9CQUFJLFNBQVM7QUFBeUIsMEJBQVEsUUFBUTs7QUFHeEQscUJBQU8sS0FBSztnQkFDVixRQUFRO2dCQUNSLE9BQU8sUUFBUSxJQUFJLE9BQU8sT0FBTyxRQUFRO2dCQUN6Qzs7O0FBR0osbUJBQU87O1VBV1QsaUJBQWlCLE9BQU8sU0FBUztBQUMvQixnQkFBSSxTQUFTLEtBQUssY0FBYyxPQUFPO0FBQ3ZDLG1CQUFPLEtBQUssa0JBQWtCOztVQVFoQyxrQkFBa0IsUUFBUTtBQUN4QixrQkFBTSxTQUFTLE9BQU8sUUFDaEIsY0FBYyxPQUFPO0FBRTNCLGdCQUFJLENBQUMsYUFBYTtBQUNoQixxQkFBTyxXQUFZO0FBQ2pCLHVCQUFPOzs7QUFJWCxrQkFBTSxTQUFTLE9BQU8sUUFBUSxRQUN4QixVQUFVLE9BQU8sU0FDakIsY0FBYyxPQUFPLFFBQ3JCLFlBQVksT0FBTztBQUV6QixnQkFBSSxDQUFDLGFBQWE7QUFDaEIscUJBQU8sV0FBWTtBQUNqQix1QkFBTzs7O0FBVVgsa0JBQU0sY0FBYyxXQUFZO0FBQzlCLGtCQUFJLGdCQUFnQixHQUFHO0FBQ3JCLHVCQUFPLFNBQVUsT0FBTyxNQUFNO0FBQzVCLHdCQUFNLFFBQVEsT0FBTyxHQUFHO0FBQ3hCLHlCQUFPLFdBQVcsVUFBVSxNQUFNLFFBQVEsT0FBTyxRQUFRLFVBQVU7OztBQUl2RSxxQkFBTyxTQUFVLE9BQU8sTUFBTTtBQUM1QixvQkFBSSxNQUFNO0FBRVYsb0JBQUksTUFBTSxPQUFPO0FBQ2Ysd0JBQU0sUUFBUSxVQUFVLE1BQU0sTUFBTTtBQUVwQyxzQkFBSSxDQUFDLE1BQU0sU0FBUyxPQUFPO0FBQ3pCLDJCQUFPLElBQUk7eUJBQ047QUFDTCwyQkFBTyxXQUFXLE9BQU8sT0FBTzs7dUJBRTdCO0FBQ0wsNEJBQVEsU0FBUyxDQUFDLFFBQVEsVUFBVTtBQUNsQywyQkFBTyxXQUFXLFVBQVUsTUFBTSxRQUFRLE9BQU87OztBQUlyRCx1QkFBTyxNQUFNOzs7QUFJakIsZ0JBQUksZ0JBQWdCLEdBQUc7QUFDckIscUJBQU8sU0FBVSxNQUFNO0FBQ3JCLHVCQUFPLFlBQVksT0FBTyxJQUFJOzs7QUFJbEMsZ0JBQUksT0FBTyxRQUFRLGdCQUFnQixPQUFPO0FBQ3hDLHFCQUFPLFNBQVUsTUFBTTtBQUNyQixvQkFBSSxPQUNBLE1BQU07QUFFVix5QkFBUyxTQUFTLFFBQVE7QUFDeEIsMEJBQVEsWUFBWSxPQUFPO0FBQzNCLHNCQUFJLFNBQVM7QUFBRywyQkFBTztBQUN2Qix5QkFBTzs7QUFHVCx1QkFBTyxNQUFNOzttQkFFVjtBQUNMLHFCQUFPLFNBQVUsTUFBTTtBQUNyQixvQkFBSSxNQUFNO0FBQ1YsMEJBQVEsUUFBUSxXQUFTO0FBQ3ZCLHlCQUFPLFlBQVksT0FBTzs7QUFFNUIsdUJBQU8sTUFBTTs7OztVQVluQixnQkFBZ0IsT0FBTyxTQUFTO0FBQzlCLGdCQUFJLFNBQVMsS0FBSyxjQUFjLE9BQU87QUFDdkMsbUJBQU8sS0FBSyxpQkFBaUI7O1VBRy9CLGlCQUFpQixRQUFRO0FBQ3ZCLGdCQUFJLGdCQUNBLFlBQVk7QUFDaEIsa0JBQU0sUUFBTyxNQUNQLFVBQVUsT0FBTyxTQUNqQixPQUFPLENBQUMsT0FBTyxTQUFTLFFBQVEsYUFBYSxRQUFRLGFBQWEsUUFBUTtBQUVoRixnQkFBSSxPQUFPLFFBQVEsWUFBWTtBQUM3QixxQkFBTyxLQUFLLEtBQUs7O0FBU25CLGtCQUFNLFlBQVksb0JBQW1CLE1BQU0sUUFBUTtBQUNqRCxrQkFBSSxTQUFTO0FBQVUsdUJBQU8sT0FBTztBQUNyQyxxQkFBTyxPQUFPLFVBQVUsTUFBSyxNQUFNLE9BQU8sS0FBSzs7QUFJakQsZ0JBQUksTUFBTTtBQUNSLHVCQUFTLEtBQUssTUFBTTtBQUNsQixvQkFBSSxPQUFPLFNBQVMsRUFBRSxVQUFVLFVBQVU7QUFDeEMsNEJBQVUsS0FBSzs7OztBQU9yQixnQkFBSSxPQUFPLE9BQU87QUFDaEIsK0JBQWlCO0FBRWpCLHVCQUFTLE9BQU8sV0FBVztBQUN6QixvQkFBSSxJQUFJLFVBQVUsVUFBVTtBQUMxQixtQ0FBaUI7QUFDakI7OztBQUlKLGtCQUFJLGdCQUFnQjtBQUNsQiwwQkFBVSxRQUFRO2tCQUNoQixPQUFPO2tCQUNQLFdBQVc7OzttQkFJVjtBQUNMLDBCQUFZLFVBQVUsT0FBTyxTQUFPLElBQUksVUFBVTs7QUFJcEQsa0JBQU0sa0JBQWtCLFVBQVU7QUFFbEMsZ0JBQUksQ0FBQyxpQkFBaUI7QUFDcEIscUJBQU87O0FBR1QsbUJBQU8sU0FBVSxHQUFHLEdBQUc7QUFDckIsa0JBQUksUUFBUTtBQUVaLHVCQUFTLFlBQVksV0FBVztBQUM5Qix3QkFBUSxTQUFTO0FBQ2pCLG9CQUFJLGFBQWEsU0FBUyxjQUFjLFNBQVMsS0FBSztBQUN0RCx5QkFBUyxhQUFhLElBQUksVUFBVSxPQUFPLElBQUksVUFBVSxPQUFPO0FBQ2hFLG9CQUFJO0FBQVEseUJBQU87O0FBR3JCLHFCQUFPOzs7VUFVWCxjQUFjLE9BQU8sVUFBVTtBQUM3QixrQkFBTSxVQUFVO0FBQ2hCLGdCQUFJLFVBQVUsT0FBTyxPQUFPLElBQUk7QUFDaEMsd0JBQVksU0FBUztBQUNyQix3QkFBWSxTQUFTO0FBRXJCLGdCQUFJLFFBQVEsUUFBUTtBQUNsQiwwQkFBWSxTQUFTO0FBQ3JCLG9CQUFNLFNBQVM7QUFDZixzQkFBUSxPQUFPLFFBQVEsV0FBUztBQUM5QixvQkFBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QiwwQkFBUTtvQkFDTjtvQkFDQSxRQUFROzs7QUFJWix1QkFBTyxLQUFLO0FBQ1osd0JBQVEsTUFBTSxTQUFTLFlBQVksUUFBUSxNQUFNLFNBQVM7O0FBRTVELHNCQUFRLFNBQVM7O0FBR25CLG1CQUFPO2NBQ0w7Y0FDQSxPQUFPLE1BQU0sY0FBYztjQUMzQixRQUFRLEtBQUssU0FBUyxPQUFPLFFBQVEseUJBQXlCO2NBQzlELE9BQU87Y0FDUCxPQUFPO2NBQ1A7Y0FDQSxXQUFXLFFBQVEsVUFBVSxpQkFBaUI7OztVQVFsRCxPQUFPLE9BQU8sU0FBUztBQUNyQixnQkFBSSxRQUFPLE1BQ1AsT0FDQTtBQUNKLHFCQUFTLEtBQUssY0FBYyxPQUFPO0FBQ25DLHNCQUFVLE9BQU87QUFDakIsb0JBQVEsT0FBTztBQUVmLGtCQUFNLFdBQVcsUUFBUSxTQUFTLE1BQUssa0JBQWtCO0FBR3pELGdCQUFJLE1BQU0sUUFBUTtBQUNoQix3QkFBUSxNQUFLLE9BQU8sQ0FBQyxNQUFNLE9BQU87QUFDaEMsd0JBQVEsU0FBUztBQUVqQixvQkFBSSxRQUFRLFdBQVcsU0FBUyxRQUFRLEdBQUc7QUFDekMseUJBQU8sTUFBTSxLQUFLO29CQUNoQixTQUFTO29CQUNULE1BQU07Ozs7bUJBSVA7QUFDTCx3QkFBUSxNQUFLLE9BQU8sQ0FBQyxHQUFHLE9BQU87QUFDN0IsdUJBQU8sTUFBTSxLQUFLO2tCQUNoQixTQUFTO2tCQUNULE1BQU07Ozs7QUFLWixrQkFBTSxVQUFVLE1BQUssaUJBQWlCO0FBRXRDLGdCQUFJO0FBQVMscUJBQU8sTUFBTSxLQUFLO0FBRS9CLG1CQUFPLFFBQVEsT0FBTyxNQUFNO0FBRTVCLGdCQUFJLE9BQU8sUUFBUSxVQUFVLFVBQVU7QUFDckMscUJBQU8sUUFBUSxPQUFPLE1BQU0sTUFBTSxHQUFHLFFBQVE7O0FBRy9DLG1CQUFPOzs7QUM1UkosY0FBTSxVQUFVLENBQUMsUUFBOEIsYUFBc0M7QUFFM0YsY0FBSyxNQUFNLFFBQVEsU0FBUztBQUMzQixtQkFBTyxRQUFRO2lCQUVYO0FBRUoscUJBQVMsT0FBTyxRQUFRO0FBQ3ZCLGtCQUFJLE9BQU8sZUFBZSxNQUFNO0FBQy9CLHlCQUFTLE9BQU8sTUFBTTs7Ozs7QUM1RW5CLGNBQU0sU0FBVyxXQUEyQjtBQUVsRCxjQUFJLE1BQU0sUUFBUTtBQUNqQixtQkFBTyxNQUFNOztBQUdkLGNBQUksaUJBQWlCLGFBQWE7QUFDakMsbUJBQU87O0FBR1IsY0FBSSxhQUFhLFFBQVE7QUFDeEIsZ0JBQUksTUFBTSxTQUFTLGNBQWM7QUFDakMsZ0JBQUksWUFBWSxNQUFNO0FBQ3RCLG1CQUFPLElBQUksUUFBUTs7QUFHcEIsaUJBQU8sU0FBUyxjQUFjOztBQUd4QixjQUFNLGVBQWdCLFNBQXFCO0FBQ2pELGNBQUksT0FBTyxRQUFRLFlBQVksSUFBSSxRQUFRLE9BQU8sSUFBSTtBQUNyRCxtQkFBTzs7QUFFUixpQkFBTzs7QUFHRCxjQUFNLGNBQWUsV0FBd0I7QUFDbkQsaUJBQU8sTUFBTSxRQUFRLFdBQVc7O0FBTzFCLGNBQU0sZUFBZSxDQUFFLFFBQW9CLGVBQTRCO0FBQzdFLGNBQUksUUFBUSxTQUFTLFlBQVk7QUFDakMsZ0JBQU0sVUFBVSxZQUFZLE1BQU07QUFDbEMsaUJBQU8sY0FBYzs7QUFPZixjQUFNLFdBQVcsQ0FBRSxRQUFvQixRQUE4QztBQUMzRixpQkFBTyxPQUFPLE9BQU8sT0FBTzs7QUFRdEIsY0FBTSxhQUFhLENBQUUsVUFBb0MsWUFBaUM7QUFFaEcsY0FBSSxlQUFnQixhQUFhO0FBQ2pDLGtCQUFXLFlBQVk7QUFFdkIsZ0JBQU0sSUFBSyxRQUFNO0FBQ2hCLHlCQUFhLElBQUssU0FBTztBQUN4QixpQkFBRyxVQUFVLElBQUs7Ozs7QUFTYixjQUFNLGdCQUFnQixDQUFFLFVBQW9DLFlBQWlDO0FBRW5HLGNBQUksZUFBZ0IsYUFBYTtBQUNsQyxrQkFBVyxZQUFZO0FBRXZCLGdCQUFNLElBQUssUUFBTTtBQUNoQix5QkFBYSxJQUFJLFNBQU87QUFDdEIsaUJBQUcsVUFBVSxPQUFROzs7O0FBVWxCLGNBQU0sZUFBZ0IsVUFBc0M7QUFDbEUsY0FBSSxVQUFtQjtBQUN2QixrQkFBUyxNQUFPLGNBQVk7QUFDM0IsZ0JBQUksT0FBTyxhQUFhLFVBQVU7QUFDakMseUJBQVcsU0FBUyxPQUFPLE1BQU07O0FBRWxDLGdCQUFJLE1BQU0sUUFBUSxXQUFXO0FBQzVCLHdCQUFVLFFBQVEsT0FBTzs7O0FBSTNCLGlCQUFPLFFBQVEsT0FBTzs7QUFRaEIsY0FBTSxjQUFlLFNBQXVCO0FBQ2xELGNBQUksQ0FBQyxNQUFNLFFBQVEsTUFBTTtBQUN2QixrQkFBTSxDQUFDOztBQUVULGlCQUFPOztBQVNELGNBQU0sY0FBYyxDQUFFLFFBQXlCLFVBQWlCLFlBQTJDO0FBRWpILGNBQUksV0FBVyxDQUFDLFFBQVEsU0FBUyxTQUFTO0FBQ3pDOztBQUdELGlCQUFPLFVBQVUsT0FBTyxTQUFTO0FBRWhDLGdCQUFJLE9BQU8sUUFBUSxXQUFXO0FBQzdCLHFCQUFPOztBQUdSLHFCQUFTLE9BQU87OztBQVlYLGNBQU0sVUFBVSxDQUFFLE1BQTBCLFlBQWlCLE1BQVc7QUFFOUUsY0FBSSxZQUFZLEdBQUc7QUFDbEIsbUJBQU8sS0FBSyxLQUFLLFNBQU87O0FBR3pCLGlCQUFPLEtBQUs7O0FBT04sY0FBTSxnQkFBaUIsU0FBdUI7QUFDcEQsaUJBQVEsT0FBTyxLQUFLLEtBQUssV0FBVzs7QUFROUIsY0FBTSxZQUFZLENBQUUsSUFBaUIsWUFBNEI7QUFDdkUsY0FBSSxDQUFDO0FBQUksbUJBQU87QUFFaEIsb0JBQVUsV0FBVyxHQUFHO0FBRXhCLGNBQUksSUFBSTtBQUNSLGlCQUFPLEtBQUssR0FBRyx3QkFBd0I7QUFFdEMsZ0JBQUksR0FBRyxRQUFRLFVBQVU7QUFDeEI7OztBQUdGLGlCQUFPOztBQVFELGNBQU0sVUFBVSxDQUFDLElBQVcsVUFBZ0Q7QUFDbEYsa0JBQVMsT0FBTSxDQUFDLEtBQUksU0FBUztBQUM1QixnQkFBSSxPQUFPLE1BQU07QUFDaEIsaUJBQUcsZ0JBQWdCO21CQUNmO0FBQ0osaUJBQUcsYUFBYSxNQUFnQixLQUFHOzs7O0FBUy9CLGNBQU0sY0FBYyxDQUFFLFVBQWUsZ0JBQXNCO0FBQ2pFLGNBQUksU0FBUztBQUFhLHFCQUFTLFdBQVcsYUFBYSxhQUFhOztBQ3JNbEUsY0FBTSxZQUFZLENBQUMsU0FBcUIsVUFBd0I7QUFFdEUsY0FBSSxVQUFVO0FBQU87QUFHckIsY0FBSSxPQUFPLFVBQVUsVUFBVTtBQUU5QixnQkFBSSxDQUFDLE1BQU07QUFBUztBQUNwQixvQkFBUSxJQUFJLE9BQU8sT0FBTzs7QUFNM0IsZ0JBQU0sZ0JBQWtCLFVBQXNCO0FBRTdDLGdCQUFJLFFBQVEsS0FBSyxLQUFLLE1BQU07QUFDNUIsZ0JBQUksU0FBUyxLQUFLLEtBQUssU0FBUyxHQUFHO0FBQ2xDLGtCQUFJLFdBQVksU0FBUyxjQUFjO0FBQ3ZDLHVCQUFTLFlBQVk7QUFDckIsa0JBQUksWUFBYSxLQUFLLFVBQVUsTUFBTTtBQUV0Qyx3QkFBVSxVQUFVLE1BQU0sR0FBSTtBQUM5QixrQkFBSSxjQUFlLFVBQVUsVUFBVTtBQUV2Qyx1QkFBUyxZQUFZO0FBQ3JCLDBCQUFZLFdBQVc7QUFDdkIscUJBQU87O0FBR1IsbUJBQU87O0FBS1IsZ0JBQU0sb0JBQXNCLFVBQXVCO0FBQ2xELGdCQUFJLEtBQUssYUFBYSxLQUFLLEtBQUssY0FBYyxDQUFDLGtCQUFrQixLQUFLLEtBQUssWUFBYyxNQUFLLGNBQWMsZUFBZSxLQUFLLFlBQVksU0FBVTtBQUNySixvQkFBTSxLQUFLLEtBQUssWUFBWSxRQUFRLGNBQVc7QUFDOUMsbUNBQW1COzs7O0FBTXRCLGdCQUFNLHFCQUF1QixVQUE4QjtBQUUxRCxnQkFBSSxLQUFLLGFBQWEsR0FBRztBQUN4QixxQkFBTyxjQUFjOztBQUd0Qiw4QkFBa0I7QUFFbEIsbUJBQU87O0FBR1IsNkJBQW9COztBQU9kLGNBQU0sa0JBQW1CLFFBQW1CO0FBQ2xELGNBQUksV0FBVyxHQUFHLGlCQUFpQjtBQUNuQyxnQkFBTSxVQUFVLFFBQVEsS0FBSyxVQUFVLFNBQVMsS0FBZTtBQUM5RCxnQkFBSSxTQUFTLElBQUc7QUFDaEIsbUJBQU8sYUFBYSxJQUFHLFlBQW9CO0FBQzNDLG1CQUFPOzs7QUM5RUYsY0FBTSxRQUFXO0FBQ2pCLGNBQU0sYUFBZTtBQUNyQixjQUFNLFVBQVk7QUFDbEIsY0FBTSxXQUFhO0FBQ25CLGNBQU0sU0FBWTtBQUNsQixjQUFNLFlBQWM7QUFDcEIsY0FBTSxXQUFhO0FBQ25CLGNBQU0sZ0JBQWlCO0FBQ3ZCLGNBQU0sYUFBZTtBQUNyQixjQUFNLFVBQVk7QUFFbEIsY0FBTSxTQUFnQixPQUFPLGNBQWMsY0FBYyxRQUFRLE1BQU0sS0FBSyxVQUFVO0FBQ3RGLGNBQU0sZUFBZ0IsU0FBUyxZQUFZO0FDWGxELFlBQUEsV0FBZTtVQUNkLFNBQVM7VUFDVCxXQUFXO1VBRVgsU0FBUztVQUNULFdBQVc7VUFDWCxTQUFTO1VBQ1QsU0FBUztVQUNULFlBQVk7VUFDWixRQUFRO1VBQ1IsY0FBYztVQUNkLGNBQWM7VUFDZCxXQUFXO1VBQ1gsYUFBYTtVQUNiLFlBQVk7VUFDWixZQUFZO1VBQ1osVUFBVTtVQUNWLGNBQWM7VUFDZCxZQUFZO1VBQ1osZUFBZTtVQUNmLGFBQWE7VUFDYixTQUFTO1VBQ1Qsa0JBQWtCO1VBRWxCLGlCQUFpQjtVQUdqQixjQUFjO1VBQ2QsY0FBYztVQUVkLFVBQVU7VUFDVixlQUFlO1VBQ2YsWUFBWTtVQUNaLFlBQVk7VUFDWixlQUFlO1VBQ2Ysb0JBQW9CO1VBQ3BCLG9CQUFvQjtVQUNwQixtQkFBbUI7VUFFbkIsV0FBVztVQUNYLGFBQWEsQ0FBQztVQUNkLG1CQUFtQjtVQUVuQixNQUFNO1VBQ04sY0FBYztVQUNkLGNBQWM7VUFDZCxlQUFlO1VBQ2Ysc0JBQXNCO1VBQ3RCLFdBQVc7VUFDWCxhQUFhO1VBRWIsZ0JBQWdCO1VBQ2hCLGNBQWM7VUFFZCx1QkFBdUI7VUFFdkIsYUFBYTtVQUNiLGlCQUFpQjtVQUVqQixZQUFZLFNBQVMsT0FBcUI7QUFDekMsbUJBQU8sTUFBTSxTQUFTOztVQXVCdkIsUUFBUTs7QUNqRUYsY0FBTSxXQUFZLFdBQTJEO0FBQ25GLGNBQUksT0FBTyxVQUFVLGVBQWUsVUFBVTtBQUFNLG1CQUFPO0FBQzNELGlCQUFPLFNBQVM7O0FBR1YsY0FBTSxXQUFZLFdBQXVDO0FBQy9ELGNBQUksT0FBTyxVQUFVO0FBQVcsbUJBQU8sUUFBUSxNQUFNO0FBQ3JELGlCQUFPLFFBQVE7O0FBT1QsY0FBTSxjQUFlLFNBQXNCO0FBQ2pELGlCQUFRLE9BQU0sSUFDWixRQUFRLE1BQU0sU0FDZCxRQUFRLE1BQU0sUUFDZCxRQUFRLE1BQU0sUUFDZCxRQUFRLE1BQU07O0FBT1YsY0FBTSxVQUFVLENBQUMsSUFBWSxhQUFtQjtBQUN0RCxjQUFJLFdBQVUsR0FBRztBQUNoQixtQkFBTyxXQUFXLElBQUc7O0FBR3RCLGFBQUcsS0FBSztBQUNSLGlCQUFPOztBQU9ELGNBQU0sZUFBZSxDQUFDLElBQW1ELFVBQWlCO0FBQ2hHLGNBQUk7QUFDSixpQkFBTyxTQUF5QixPQUFhLFVBQTBCO0FBQ3RFLGdCQUFJLFFBQU87QUFFWCxnQkFBSSxVQUFTO0FBQ1osb0JBQUssVUFBVSxLQUFLLElBQUksTUFBSyxVQUFVLEdBQUc7QUFDMUMsMkJBQWE7O0FBRWQsdUJBQVUsV0FBVyxXQUFXO0FBQy9CLHlCQUFVO0FBQ1Ysb0JBQUssZUFBZSxTQUFTO0FBQzdCLGlCQUFHLEtBQUssT0FBTSxPQUFPO2VBRW5COzs7QUFVRSxjQUFNLGtCQUFrQixDQUFFLE9BQWdCLE9BQWdCLE9BQW1CO0FBQ25GLGNBQUk7QUFDSixjQUFJLFVBQVUsTUFBSztBQUNuQixjQUFJLGFBQW9DO0FBR3hDLGdCQUFLLFVBQVUsV0FBVTtBQUN4QixnQkFBSSxRQUFPLFVBQVU7QUFDckIsZ0JBQUksTUFBTSxRQUFRLFdBQVUsSUFBSTtBQUMvQix5QkFBVyxTQUFRO21CQUNiO0FBQ04scUJBQU8sUUFBUSxNQUFNLE9BQU07OztBQUs3QixhQUFHLE1BQU0sT0FBTTtBQUNmLGdCQUFLLFVBQVU7QUFHZixlQUFLLFFBQVEsT0FBTztBQUNuQixnQkFBSSxRQUFRLFlBQVk7QUFDdkIsc0JBQVEsTUFBTSxPQUFNLFdBQVc7Ozs7QUFlM0IsY0FBTSxlQUFnQixXQUE2RDtBQUN6RixpQkFBTztZQUNOLE9BQVEsTUFBTSxrQkFBa0I7WUFDaEMsUUFBVSxPQUFNLGdCQUFjLEtBQU0sT0FBTSxrQkFBZ0I7OztBQVNyRCxjQUFNLGlCQUFpQixDQUFDLEtBQVksT0FBYSxVQUFlO0FBQ3RFLGNBQUksS0FBSztBQUNSLGdCQUFJO0FBQ0osZ0JBQUksTUFBTTtBQUNULGtCQUFJOzs7O0FBVUEsY0FBTSxXQUFXLENBQUMsUUFBb0IsTUFBYSxVQUE2QyxZQUF5QjtBQUMvSCxpQkFBTyxpQkFBaUIsTUFBSyxVQUFTOztBQVVoQyxjQUFNLFlBQVksQ0FBRSxVQUEyQyxRQUFtQztBQUV4RyxjQUFJLENBQUMsS0FBSztBQUNULG1CQUFPOztBQUdSLGNBQUksQ0FBQyxJQUFJLFdBQVc7QUFDbkIsbUJBQU87O0FBR1IsY0FBSSxRQUFTLEtBQUksU0FBTyxJQUFFLEtBQU0sS0FBSSxVQUFRLElBQUUsS0FBTSxLQUFJLFdBQVMsSUFBRSxLQUFNLEtBQUksVUFBUSxJQUFFO0FBRXZGLGNBQUksVUFBVSxHQUFHO0FBQ2hCLG1CQUFPOztBQUdSLGlCQUFPOztBQVNELGNBQU0sUUFBUSxDQUFDLElBQVcsT0FBYztBQUM5QyxnQkFBTSxjQUFjLEdBQUcsYUFBYTtBQUNwQyxjQUFJLGFBQWE7QUFDaEIsbUJBQU87O0FBR1IsYUFBRyxhQUFhLE1BQUs7QUFDckIsaUJBQU87O0FBT0QsY0FBTSxhQUFjLFNBQXNCO0FBQ2hELGlCQUFPLElBQUksUUFBUSxXQUFXOztBQU14QixjQUFNLFNBQVMsQ0FBRSxRQUFpQyxTQUEwQztBQUNsRyxjQUFJO0FBQU8sbUJBQU8sT0FBTzs7QUNwTVgsNkJBQXNCLE9BQWdCLGVBQXdEO0FBQzVHLGNBQUksV0FBdUIsT0FBTyxPQUFPLElBQUksVUFBVTtBQUV2RCxjQUFJLFlBQWUsU0FBUztBQUM1QixjQUFJLGNBQWlCLFNBQVM7QUFDOUIsY0FBSSxjQUFpQixTQUFTO0FBQzlCLGNBQUksaUJBQW1CLFNBQVM7QUFDaEMsY0FBSSxpQkFBbUIsU0FBUztBQUNoQyxjQUFJLHVCQUF1QixTQUFTO0FBQ3BDLGNBQUksdUJBQXVCLFNBQVM7QUFFcEMsY0FBSSxXQUFjLE1BQU0sUUFBUTtBQUNoQyxjQUFJLGNBQWlCLE1BQU0sYUFBYSxrQkFBa0IsTUFBTSxhQUFhO0FBRTdFLGNBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxrQkFBa0I7QUFDL0MsZ0JBQUksU0FBVSxNQUFNLGNBQWM7QUFDbEMsZ0JBQUksUUFBUTtBQUNYLDRCQUFjLE9BQU87OztBQUt2QixjQUFJLG1CQU1BO1lBQ0g7WUFDQSxTQUFXO1lBQ1gsV0FBWTtZQUNaLE9BQVM7WUFDVCxVQUFXOztBQVFaLGNBQUksY0FBYyxNQUFNO0FBQ3ZCLGdCQUFJO0FBQ0osZ0JBQUksVUFBVSxpQkFBaUI7QUFDL0IsZ0JBQUksYUFBZ0M7QUFDcEMsZ0JBQUksY0FBYztBQUNsQixnQkFBSSxTQUFTO0FBRWIsZ0JBQUksV0FBWSxRQUE2QjtBQUU1QyxrQkFBSSxPQUFPLE9BQU8sT0FBTyxJQUFHLEdBQUc7QUFDL0Isa0JBQUksT0FBTyxhQUFhLEtBQUs7QUFFN0Isa0JBQUksT0FBTyxTQUFTLFlBQVksS0FBSyxRQUFRO0FBQzVDLHVCQUFPLE9BQU8sT0FBTyxNQUFLLEtBQUssTUFBTTs7QUFHdEMscUJBQU87O0FBR1IsZ0JBQUksWUFBWSxDQUFDLFFBQTBCLFVBQWtCO0FBRTVELGtCQUFJLFFBQVEsU0FBUyxPQUFPO0FBQzVCLGtCQUFLLFNBQVM7QUFBTztBQUNyQixrQkFBSyxDQUFDLFNBQVMsQ0FBQyxTQUFTO0FBQWtCO0FBTTNDLGtCQUFJLFdBQVcsZUFBZSxRQUFRO0FBQ3JDLG9CQUFJLE9BQU87QUFDVixzQkFBSSxNQUFNLFdBQVcsT0FBTztBQUM1QixzQkFBSSxDQUFDLEtBQUs7QUFDVCwrQkFBVyxPQUFPLGtCQUFrQjs2QkFDMUIsQ0FBQyxNQUFNLFFBQVEsTUFBTTtBQUMvQiwrQkFBVyxPQUFPLGtCQUFrQixDQUFDLEtBQUs7eUJBQ3BDO0FBQ04sd0JBQUksS0FBSzs7O3FCQUlQO0FBRUosb0JBQUksY0FBMEIsU0FBUztBQUN2Qyw0QkFBWSxlQUFrQixZQUFZLGdCQUFnQixPQUFPO0FBQ2pFLDRCQUFZLGVBQWtCLFlBQVksZ0JBQWdCO0FBQzFELDRCQUFZLGtCQUFrQixZQUFZLG1CQUFtQixPQUFPO0FBQ3BFLDRCQUFZLGtCQUFrQixZQUFZLG1CQUFtQjtBQUM3RCw0QkFBWSxVQUFZO0FBQ3hCLDRCQUFZLFNBQVcsWUFBWSxVQUFVLEVBQUU7QUFFL0MsMkJBQVcsU0FBUztBQUNwQix3QkFBUSxLQUFLOztBQUdkLGtCQUFJLE9BQU8sVUFBVTtBQUNwQixpQ0FBaUIsTUFBTSxLQUFLOzs7QUFJOUIsZ0JBQUksV0FBYSxjQUFrQztBQUNsRCxrQkFBSSxJQUFXO0FBRWYsOEJBQXNCLFNBQVM7QUFDL0IsNEJBQWMsd0JBQXlCLGNBQWMseUJBQXlCLFNBQVMsYUFBYSxZQUFZO0FBQ2hILDRCQUFjLHdCQUF5QixjQUFjLHlCQUF5QjtBQUM5RSw0QkFBYyxrQkFBb0IsY0FBYyxtQkFBbUIsU0FBUztBQUM1RSw0QkFBYyxTQUFhLGNBQWMsVUFBVSxFQUFFO0FBRXJELCtCQUFpQixVQUFVLEtBQUs7QUFFaEMsbUJBQUssY0FBYztBQUVuQixzQkFBUSxTQUFTLFVBQVcsWUFBUztBQUNwQywwQkFBVSxRQUE2Qjs7O0FBS3pDLDZCQUFpQixXQUFXLE1BQU0sYUFBYSxjQUFjLE9BQU87QUFFcEUsb0JBQVEsTUFBTSxVQUFVLFdBQVE7QUFDL0Isd0JBQVUsTUFBTSxRQUFRO0FBQ3hCLGtCQUFJLFlBQVksWUFBWTtBQUMzQix5QkFBUzt5QkFDQyxZQUFZLFVBQVU7QUFDaEMsMEJBQVU7Ozs7QUFXYixjQUFJLGVBQWUsTUFBTTtBQUN4QixrQkFBTSxXQUFXLE1BQU0sYUFBYTtBQUVwQyxnQkFBSSxDQUFDLFVBQVU7QUFDZCxrQkFBSSxRQUFRLE1BQU0sTUFBTSxVQUFVO0FBQ2xDLGtCQUFJLENBQUMsU0FBUyxvQkFBb0IsQ0FBQyxNQUFNO0FBQVE7QUFDakQsb0JBQU0sU0FBUyxNQUFNLE1BQU0sU0FBUztBQUVwQyxzQkFBUyxRQUFTLFlBQVU7QUFDM0Isc0JBQU0sU0FBbUI7QUFDekIsdUJBQU8sZUFBZTtBQUN0Qix1QkFBTyxlQUFlO0FBQ3RCLGlDQUFpQixRQUFRLEtBQUs7O0FBRS9CLCtCQUFpQixRQUFRO21CQUNuQjtBQUNOLCtCQUFpQixVQUFVLEtBQUssTUFBTTtBQUN0QyxzQkFBUyxpQkFBaUIsU0FBVSxTQUFRO0FBQzNDLGlDQUFpQixNQUFNLEtBQUssSUFBSTs7OztBQU1uQyxjQUFJLGFBQWEsVUFBVTtBQUMxQjtpQkFDTTtBQUNOOztBQUdELGlCQUFPLE9BQU8sT0FBUSxJQUFJLFVBQVUsa0JBQWtCOztBQ3RJdkQsWUFBSSxhQUFhO0FBRUYsaUNBQXdCLFlBQVksWUFBVztVQW1EN0QsWUFBYSxXQUE0QixlQUE2QztBQUNyRjtBQUFRLGlCQWxERixnQkFBYTtBQUFBLGlCQUNiLFVBQU87QUFBQSxpQkFDUCxXQUFRO0FBQUEsaUJBQ1IsVUFBTztBQUFBLGlCQUNQLG1CQUFnQjtBQUFBLGlCQUNoQixhQUFVO0FBQUEsaUJBRVYsUUFBcUI7QUFBQyxpQkFDdEIsV0FBUTtBQUFBLGlCQUNSLFFBQUs7QUFBQSxpQkFDTCxXQUFRO0FBQUEsaUJBQ1IsZ0JBQWE7QUFBQSxpQkFDYixNQUFHO0FBQUEsaUJBQ0YsVUFBTztBQUFBLGlCQUVQLFdBQVE7QUFBQSxpQkFDVCxTQUFNO0FBQUEsaUJBR04sU0FBdUI7QUFBSyxpQkFDNUIsYUFBMEI7QUFBSyxpQkFDL0IsYUFBMEI7QUFBSyxpQkFDL0IsYUFBVTtBQUFBLGlCQUNWLFlBQXlCO0FBQU8saUJBQ2hDLFVBQXdCO0FBQUksaUJBQzVCLFdBQXlCO0FBQUssaUJBQzlCLFlBQXlCO0FBQUssaUJBQzlCLGdCQUE0QjtBQUFLLGlCQUNqQyxVQUF3QjtBQUFLLGlCQUM3QixjQUEyQjtBQUFLLGlCQUNoQyxjQUEyQjtBQUFLLGlCQUNoQyxhQUEwQjtBQUFLLGlCQUMvQixpQkFBYztBQUFBLGlCQUNkLFlBQXdCO0FBQUUsaUJBQzFCLFdBQXdCO0FBQUMsaUJBQ3pCLFVBQXVCO0FBQUMsaUJBQ3hCLGlCQUFnRDtBQUFFLGlCQUVsRCxlQUFxQztBQUFJLGlCQUN6QyxjQUE2QjtBQUFFLGlCQUUvQixZQUE0QjtBQUFFLGlCQUM5QixVQUEyQjtBQUFFLGlCQUM3QixjQUEwQztBQUFFLGlCQUM1QyxRQUF1QjtBQUFFLGlCQUV4QixpQkFBd0Q7QUFNL0Q7QUFFQSxnQkFBSTtBQUNKLGdCQUFJLFFBQVcsT0FBUTtBQUV2QixnQkFBSSxNQUFNLFdBQVc7QUFDcEIsb0JBQU0sSUFBSSxNQUFNOztBQUlqQixrQkFBTSxZQUFjO0FBSXBCLGdCQUFJLGdCQUFpQixPQUFPLG9CQUFvQixPQUFPLGlCQUFpQixPQUFPO0FBQy9FLGtCQUFXLGNBQWMsaUJBQWlCO0FBRzFDLGtCQUFNLFdBQWEsWUFBYSxPQUFPO0FBQ3ZDLGlCQUFLLFdBQWE7QUFDbEIsaUJBQUssUUFBVztBQUNoQixpQkFBSyxXQUFhLE1BQU0sWUFBWTtBQUNwQyxpQkFBSyxnQkFBaUIsTUFBTSxRQUFRLGtCQUFrQjtBQUN0RCxpQkFBSyxNQUFTLE9BQU8sS0FBSztBQUMxQixpQkFBSyxVQUFZLE1BQU0sT0FBTyxlQUFhO0FBQzNDLGlCQUFLLGFBQWUsTUFBTTtBQUkxQixpQkFBSyxTQUFTLElBQUksT0FBTyxLQUFLLFNBQVM7Y0FBQyxZQUFZLFNBQVM7O0FBRzdELHFCQUFTLE9BQU8sU0FBUyxRQUFTLFVBQVMsYUFBYSxJQUFJLFdBQVc7QUFDdkUsZ0JBQUksT0FBTyxTQUFTLGlCQUFpQixXQUFXO0FBQy9DLHVCQUFTLGVBQWUsU0FBUyxTQUFTOztBQUczQyxnQkFBSSxPQUFPLFNBQVMsb0JBQW9CLFdBQVc7QUFDbEQsdUJBQVMsa0JBQWtCLFNBQVMsU0FBUzs7QUFJOUMsZ0JBQUksU0FBUyxTQUFTO0FBQ3RCLGdCQUFJLE9BQU8sV0FBVyxZQUFZO0FBRWpDLGtCQUFJLE9BQU8sV0FBVyxVQUFVO0FBQy9CLHlCQUFTLElBQUksT0FBTzs7QUFHckIsa0JBQUksa0JBQWtCLFFBQVE7QUFDN0IseUJBQVMsZUFBZ0IsWUFBVyxPQUFrQixLQUFLO3FCQUN2RDtBQUNKLHlCQUFTLGVBQWdCLFdBQVU7QUFDbEMseUJBQU8sS0FBSyxTQUFTLGNBQWMsQ0FBQyxLQUFLLFFBQVE7Ozs7QUFNcEQsaUJBQUssa0JBQWtCLFNBQVM7QUFDaEMsaUJBQUs7QUFDTCxpQkFBSztBQUlMLGtCQUFNLFVBQVksT0FBTztBQUN6QixrQkFBTSxVQUFZLE9BQU87QUFDekIsa0JBQU0sV0FBYSxLQUFLLFFBQVE7QUFDaEMsa0JBQU0sbUJBQW1CLE9BQVE7QUFFakMsa0JBQU0sVUFBWSxLQUFLLE1BQU0sYUFBYSxZQUFZO0FBQ3RELGtCQUFNLFlBQWMsU0FBUztBQUU3QixnQkFBSTtBQUdKLHVCQUFZLFNBQVMsU0FBUyxjQUFjLFNBQVM7QUFHckQsdUJBQVcsU0FBUSxTQUFTO0FBQzVCLG1CQUFRLFNBQVM7QUFHakIsdUJBQVcsVUFBVSxTQUFTLGVBQWU7QUFDN0MsZ0JBQUksU0FBUyx1QkFBdUI7QUFDbkMseUJBQVksVUFBVTs7QUFJdkIsdUJBQVcsa0JBQWtCLFNBQVM7QUFDdEMsbUJBQVEsVUFBVTtBQUVsQixtQkFBUSxTQUFTLGtCQUFrQixTQUFVLFlBQWE7QUFJMUQsZ0JBQUksYUFBYSxTQUFTLGVBQWU7QUFDeEMsOEJBQWlCLE9BQU8sU0FBUztBQUdqQyxrQkFBSSxRQUFRLENBQUMsZUFBYyxrQkFBaUIsZ0JBQWU7QUFDM0Qsd0JBQVEsT0FBTyxVQUFnQjtBQUM5QixvQkFBSSxNQUFNLGFBQWEsT0FBTztBQUM3QiwwQkFBUSxlQUFjO3FCQUFFLE9BQU0sTUFBTSxhQUFhOzs7O0FBSW5ELDRCQUFjLFdBQVc7QUFDekIsc0JBQVEsWUFBYTtBQUNyQixtQkFBSyxhQUFjO3VCQUdWLFNBQVMsY0FBYztBQUNoQyw4QkFBaUIsT0FBUSxTQUFTO0FBQ2xDLG1CQUFLLGFBQWM7bUJBRWY7QUFDSiw4QkFBaUIsT0FBTztBQUN4QixtQkFBSyxhQUFjOztBQUdwQixpQkFBSyxVQUFZO0FBQ2pCLGlCQUFLLFdBQWE7QUFDbEIsaUJBQUssbUJBQW1CO0FBQ3hCLGlCQUFLLFVBQWE7QUFDbEIsaUJBQUssZ0JBQWlCO0FBRXRCLGlCQUFLOztVQU9OLFFBQU87QUFFTixrQkFBTSxRQUFPO0FBQ2Isa0JBQU0sV0FBYyxNQUFLO0FBQ3pCLGtCQUFNLGdCQUFrQixNQUFLO0FBQzdCLGtCQUFNLFdBQWMsTUFBSztBQUN6QixrQkFBTSxtQkFBb0IsTUFBSztBQUMvQixrQkFBTSxVQUFhLE1BQUs7QUFDeEIsa0JBQU0sVUFBYSxNQUFLO0FBQ3hCLGtCQUFNLFFBQVksTUFBSztBQUN2QixrQkFBTSxhQUFlLE1BQUs7QUFDMUIsa0JBQU0sZ0JBQWtCO2NBQUUsU0FBUzs7QUFDbkMsa0JBQU0sWUFBZSxNQUFLLFVBQVM7QUFHbkMsb0JBQVEsa0JBQWlCO2NBQ3hCLElBQUk7O0FBR0wsb0JBQVEsWUFBVztjQUNsQixNQUFLO2NBQ0wsaUJBQWdCO2NBQ2hCLGlCQUFnQjtjQUNoQixpQkFBZ0I7O0FBR2pCLGtCQUFNLGFBQWEsTUFBTSxZQUFXLE1BQUssVUFBVTtBQUNuRCxrQkFBTSxRQUFVLGdCQUFjLFlBQVksTUFBSyxXQUFTO0FBQ3hELGtCQUFNLFFBQVUsU0FBUyxjQUFjO0FBQ3ZDLGtCQUFNLGNBQWMsTUFBSyxNQUFNLEtBQUs7QUFDcEMsZ0JBQUksT0FBTztBQUNWLHVCQUFTLE9BQU0sU0FBUztBQUN4QixzQkFBUSxPQUFNO2dCQUFDLEtBQUk7O0FBQ25CLG9CQUFNLFdBQVcsTUFBTSxPQUFNLE1BQUssVUFBUTtBQUMxQyxzQkFBUSxZQUFXO2dCQUFDLG1CQUFrQjs7QUFDdEMsc0JBQVEsa0JBQWlCO2dCQUFDLG1CQUFrQjs7O0FBRzdDLG9CQUFRLE1BQU0sUUFBUSxNQUFNLE1BQU07QUFFbEMsZ0JBQUksTUFBSyxRQUFRLE1BQU0sUUFBUTtBQUM5QixvQkFBTSxrQkFBa0IsWUFBWSxNQUFLLFFBQVEsTUFBTSxLQUFLO0FBQzVELHlCQUFZLENBQUMsU0FBUSxXQUFXOztBQUdqQyxnQkFBSyxVQUFTLGFBQWEsUUFBUSxTQUFTLFdBQVcsTUFBTSxNQUFLLGVBQWU7QUFDaEYsc0JBQVEsT0FBTTtnQkFBQyxVQUFTOzs7QUFHekIsZ0JBQUksU0FBUyxhQUFhO0FBQ3pCLHNCQUFRLGVBQWM7Z0JBQUMsYUFBWSxTQUFTOzs7QUFJN0MsZ0JBQUksQ0FBQyxTQUFTLFdBQVcsU0FBUyxXQUFXO0FBQzVDLHVCQUFTLFVBQVUsSUFBSSxPQUFPLFNBQVMsYUFBYSxTQUFTLGFBQWE7O0FBSzNFLGdCQUFJLFNBQVMsUUFBUSxTQUFTLGNBQWM7QUFDM0MsdUJBQVMsT0FBTyxhQUFhLFNBQVMsTUFBSyxTQUFTOztBQUdyRCxxQkFBUyxVQUFTLGFBQWEsTUFBTTtBQUNwQyxvQkFBSyxjQUFjOztBQUdwQixxQkFBUyxVQUFTLGNBQWUsT0FBTTtBQUV0QyxrQkFBSSxlQUFlLFlBQVksRUFBRSxRQUF1QixxQkFBcUI7QUFDN0Usa0JBQUk7QUFBZSxzQkFBSyxjQUFlLEdBQWlCO2VBRXREO2NBQUMsU0FBUTs7QUFHWixxQkFBUyxVQUFTLFNBQVMsU0FBUTtBQUNsQyxvQkFBTSxTQUFTLFlBQVksSUFBSSxRQUF1QjtBQUN0RCxrQkFBSSxRQUFRO0FBQ1gsc0JBQUssZUFBZ0IsS0FBbUI7QUFDeEMsK0JBQWUsS0FBSTs7O0FBSXJCLHFCQUFTLFNBQVEsU0FBVSxTQUFRO0FBRWxDLGtCQUFJLGVBQWUsWUFBYSxJQUFJLFFBQXVCLGtCQUFrQjtBQUM3RSxrQkFBSSxnQkFBZ0IsTUFBSyxhQUFhLEtBQW1CLGVBQTBCO0FBQ2xGLCtCQUFlLEtBQUk7QUFDbkI7O0FBSUQsa0JBQUksY0FBYyxTQUFTLElBQUk7QUFDOUI7O0FBR0Qsb0JBQUs7QUFDTCw2QkFBZSxLQUFJOztBQUtwQixxQkFBUyxZQUFXLFdBQWEsT0FBTSxNQUFLLFVBQVU7QUFHdEQscUJBQVMsZUFBYyxZQUFhLE9BQU0sTUFBSyxXQUFXO0FBQzFELHFCQUFTLGVBQWMsU0FBVyxPQUFNLE1BQUssUUFBUTtBQUNyRCxxQkFBUyxZQUFXLFFBQVcsT0FBTSxNQUFLLE9BQU87QUFDakQscUJBQVMsWUFBVyxTQUFXLE9BQU0sTUFBSyxRQUFRO0FBQ2xELHFCQUFTLGVBQWMsU0FBVyxPQUFNLE1BQUssUUFBUTtBQUdyRCxrQkFBTSxnQkFBaUIsU0FBYztBQUlwQyxvQkFBTSxTQUFTLElBQUksZUFBZTtBQUNsQyxrQkFBSSxDQUFDLFFBQVEsU0FBUyxXQUEwQixDQUFDLFNBQVMsU0FBUyxTQUF3QjtBQUMxRixvQkFBSSxNQUFLLFdBQVc7QUFDbkIsd0JBQUs7O0FBRU4sc0JBQUs7QUFDTDs7QUFRRCxrQkFBSSxVQUFVLGlCQUFpQixNQUFLLFFBQVE7QUFDM0Msb0JBQUk7cUJBR0E7QUFDSiwrQkFBZSxLQUFJOzs7QUFLckIsa0JBQU0sYUFBYSxNQUFNO0FBQ3hCLGtCQUFJLE1BQUssUUFBUTtBQUNoQixzQkFBSzs7O0FBS1AscUJBQVMsVUFBUyxhQUFhO0FBQy9CLHFCQUFTLFFBQU8sVUFBVSxZQUFZO0FBQ3RDLHFCQUFTLFFBQU8sVUFBVSxZQUFZO0FBRXRDLGlCQUFLLFdBQVcsTUFBTTtBQUNyQix1QkFBUyxvQkFBb0IsYUFBWTtBQUN6QyxxQkFBTyxvQkFBb0IsVUFBUztBQUNwQyxxQkFBTyxvQkFBb0IsVUFBUztBQUNwQyxrQkFBSTtBQUFRLHNCQUFNLG9CQUFvQixTQUFROztBQUsvQyxpQkFBSyxpQkFBaUI7Y0FDckIsV0FBWSxNQUFNO2NBQ2xCLFVBQVcsTUFBTTs7QUFJbEIsa0JBQU0sV0FBVztBQUNqQixrQkFBTSxzQkFBc0IsWUFBWSxNQUFLO0FBRTdDLGtCQUFLLEtBQUs7QUFDVixxQkFBUyxRQUFRO0FBQ2pCLG1CQUFPLFNBQVM7QUFDaEIsbUJBQU8sU0FBUztBQUVoQixxQkFBUyxPQUFNLFdBQVcsTUFBTTtBQUMvQixrQkFBSSxNQUFLLFNBQVM7QUFDakIsc0JBQUssVUFBVTtBQUNmLHNCQUFLLFlBQVk7QUFDakIsc0JBQUs7OztBQUlQLGtCQUFLO0FBQ0wsa0JBQUs7QUFDTCxrQkFBSyxNQUFNO0FBQ1gsa0JBQUs7QUFDTCxrQkFBSyxVQUFVO0FBRWYsZ0JBQUksTUFBTSxVQUFVO0FBQ25CLG9CQUFLO3VCQUNJLE1BQU0sVUFBVTtBQUN6QixvQkFBSyxZQUFZO21CQUNiO0FBQ0osb0JBQUs7O0FBR04sa0JBQUssR0FBRyxVQUFVLEtBQUs7QUFFdkIsdUJBQVcsT0FBTSxlQUFjO0FBQy9CLGtCQUFLLFFBQVE7QUFHYixnQkFBSSxTQUFTLFlBQVksTUFBTTtBQUM5QixvQkFBSzs7O1VBVVAsYUFBYSxVQUFzQixJQUFJLFlBQXdCLElBQUc7QUFHakUsaUJBQUssV0FBVztBQUloQixzQkFBUyxXQUFZLGNBQXVCO0FBQzNDLG1CQUFLLG9CQUFvQjs7O1VBTzNCLGlCQUFpQjtBQUNoQixnQkFBSSxRQUFPO0FBQ1gsZ0JBQUksY0FBYyxNQUFLLFNBQVM7QUFDaEMsZ0JBQUksaUJBQWlCLE1BQUssU0FBUztBQUVuQyxnQkFBSSxZQUFZO2NBQ2YsWUFBYSxVQUFtQjtBQUMvQixvQkFBSSxXQUFXLFNBQVMsY0FBYztBQUN0Qyx5QkFBUyxZQUFZO0FBQ3JCLHlCQUFTLFlBQVksS0FBSztBQUMxQix1QkFBTzs7Y0FHUixtQkFBbUIsQ0FBQyxNQUFnQixXQUE4QjtBQUNqRSx1QkFBTyxrQ0FBa0MsT0FBTyxLQUFLLG1CQUFtQjs7Y0FFekUsVUFBVSxDQUFDLE1BQWdCLFdBQThCO0FBQ3hELHVCQUFPLFVBQVUsT0FBTyxLQUFLLGdCQUFnQjs7Y0FFOUMsUUFBUSxDQUFDLE1BQWdCLFdBQThCO0FBQ3RELHVCQUFPLFVBQVUsT0FBTyxLQUFLLGdCQUFnQjs7Y0FFOUMsaUJBQWlCLENBQUMsTUFBZ0IsV0FBOEI7QUFDL0QsdUJBQU8scUNBQXFDLE9BQU8sS0FBSyxTQUFTOztjQUVsRSxjQUFhLE1BQU07QUFDbEIsdUJBQU87O2NBRVIsV0FBVSxNQUFNO0FBQ2YsdUJBQU87O2NBRVIsZUFBYyxNQUFNOztjQUNwQixZQUFXLE1BQU07QUFDaEIsdUJBQU87OztBQUtULGtCQUFLLFNBQVMsU0FBUyxPQUFPLE9BQU8sSUFBSSxXQUFXLE1BQUssU0FBUzs7VUFPbkUsaUJBQWlCO0FBQ2hCLGdCQUFJLEtBQUs7QUFDVCxnQkFBSSxZQUFrQztjQUNyQyxjQUFvQjtjQUNwQixVQUFvQjtjQUNwQixZQUFvQjtjQUNwQixlQUFvQjtjQUNwQixlQUFvQjtjQUNwQixTQUFvQjtjQUNwQixjQUFvQjtjQUNwQixpQkFBb0I7Y0FDcEIsZ0JBQW9CO2NBQ3BCLGdCQUFvQjtjQUNwQixtQkFBb0I7Y0FDcEIsa0JBQW9CO2NBQ3BCLGlCQUFvQjtjQUNwQixrQkFBb0I7Y0FDcEIsUUFBb0I7Y0FDcEIsUUFBb0I7Y0FDcEIsU0FBb0I7Y0FDcEIsUUFBb0I7O0FBR3JCLGlCQUFLLE9BQU8sV0FBVztBQUV0QixtQkFBSyxLQUFLLFNBQVMsVUFBVTtBQUM3QixrQkFBSTtBQUFJLHFCQUFLLEdBQUcsS0FBSzs7O1VBU3ZCLEtBQUssZUFBcUIsTUFBVTtBQUNuQyxrQkFBTSxRQUFRO0FBQ2Qsa0JBQU0sV0FBVyxlQUFlLFlBQWEsTUFBSyxPQUFPO2NBQUMsV0FBVSxNQUFLLFNBQVM7aUJBQWdELE1BQUs7QUFFdkksa0JBQUssYUFBYSxTQUFTLFNBQVEsU0FBUztBQUU1QyxrQkFBSyxTQUFTLFNBQVMsU0FBTyxJQUFHO0FBRWpDLGtCQUFLLFlBQVk7O1VBUWxCLFVBQWU7QUFDZCxnQkFBSSxRQUFPO0FBRVgsZ0JBQUksTUFBSyxZQUFZLFNBQVMsR0FBRztBQUNoQyxvQkFBSztBQUNMLG9CQUFLO0FBQ0w7O0FBR0QsZ0JBQUksTUFBSyxhQUFhLE1BQUssUUFBUTtBQUNsQyxvQkFBSzttQkFDQztBQUNOLG9CQUFLOzs7VUFRUCxjQUFtQjs7VUFPbkIsV0FBVztBQUNWLHlCQUFhLEtBQUssT0FBTztBQUN6Qix5QkFBYSxLQUFLLE9BQU87O1VBTzFCLFFBQVEsR0FBaUM7QUFDeEMsZ0JBQUksUUFBTztBQUVYLGdCQUFJLE1BQUssaUJBQWlCLE1BQUssVUFBVTtBQUN4Qyw2QkFBZTtBQUNmOztBQUtELGdCQUFJLENBQUMsTUFBSyxTQUFTLFNBQVM7QUFDM0I7O0FBSUQsdUJBQVcsTUFBTTtBQUNoQixrQkFBSSxhQUFhLE1BQUs7QUFDdEIsa0JBQUksQ0FBQyxXQUFXLE1BQU0sTUFBSyxTQUFTLFVBQVM7QUFDNUM7O0FBR0Qsa0JBQUksYUFBYSxXQUFXLE9BQU8sTUFBTSxNQUFLLFNBQVM7QUFDdkQsd0JBQVMsWUFBYSxXQUFpQjtBQUV0QyxzQkFBTSxPQUFPLFNBQVM7QUFDdEIsb0JBQUksTUFBTTtBQUNULHNCQUFJLEtBQUssUUFBUSxRQUFRO0FBQ3hCLDBCQUFLLFFBQVE7eUJBQ1Q7QUFDSiwwQkFBSyxXQUFXOzs7O2VBSWpCOztVQVFKLFdBQVcsR0FBc0I7QUFDaEMsZ0JBQUksUUFBTztBQUNYLGdCQUFHLE1BQUssVUFBUztBQUNoQiw2QkFBZTtBQUNmOztBQUVELGdCQUFJLFlBQVksT0FBTyxhQUFhLEVBQUUsV0FBVyxFQUFFO0FBQ25ELGdCQUFJLE1BQUssU0FBUyxVQUFVLE1BQUssU0FBUyxTQUFTLFdBQVcsY0FBYyxNQUFLLFNBQVMsV0FBVztBQUNwRyxvQkFBSztBQUNMLDZCQUFlO0FBQ2Y7OztVQVFGLFVBQVUsR0FBc0I7QUFDL0IsZ0JBQUksUUFBTztBQUVYLGtCQUFLLGNBQWM7QUFFbkIsZ0JBQUksTUFBSyxVQUFVO0FBQ2xCLGtCQUFJLEVBQUUsWUFBWSxTQUFtQjtBQUNwQywrQkFBZTs7QUFFaEI7O0FBR0Qsb0JBQVEsRUFBRTttQkFHSjtBQUNKLG9CQUFJLFVBQVUsY0FBdUIsSUFBSTtBQUN4QyxzQkFBSSxNQUFLLGNBQWMsU0FBUyxJQUFJO0FBQ25DLG1DQUFlO0FBQ2YsMEJBQUs7QUFDTDs7O0FBR0Y7bUJBR0k7QUFDSixvQkFBSSxNQUFLLFFBQVE7QUFDaEIsaUNBQWUsR0FBRTtBQUNqQix3QkFBSzs7QUFFTixzQkFBSztBQUNMO21CQUdJO0FBQ0osb0JBQUksQ0FBQyxNQUFLLFVBQVUsTUFBSyxZQUFZO0FBQ3BDLHdCQUFLOzJCQUNLLE1BQUssY0FBYztBQUM3QixzQkFBSSxPQUFPLE1BQUssWUFBWSxNQUFLLGNBQWM7QUFDL0Msc0JBQUk7QUFBTSwwQkFBSyxnQkFBZ0I7O0FBRWhDLCtCQUFlO0FBQ2Y7bUJBR0k7QUFDSixvQkFBSSxNQUFLLGNBQWM7QUFDdEIsc0JBQUksT0FBTyxNQUFLLFlBQVksTUFBSyxjQUFjO0FBQy9DLHNCQUFJO0FBQU0sMEJBQUssZ0JBQWdCOztBQUVoQywrQkFBZTtBQUNmO21CQUdJO0FBQ0osb0JBQUksTUFBSyxVQUFVLE1BQUssZUFBZTtBQUN0Qyx3QkFBSyxlQUFlLEdBQUUsTUFBSztBQUMzQixpQ0FBZTsyQkFHTixNQUFLLFNBQVMsVUFBVSxNQUFLLGNBQWM7QUFDcEQsaUNBQWU7MkJBR04sU0FBUyxpQkFBaUIsTUFBSyxpQkFBaUIsTUFBSyxRQUFRO0FBQ3RFLGlDQUFlOztBQUdoQjttQkFHSTtBQUNKLHNCQUFLLGlCQUFpQixJQUFJO0FBQzFCO21CQUdJO0FBQ0osc0JBQUssaUJBQWlCLEdBQUc7QUFDekI7bUJBR0k7QUFFSixvQkFBSSxNQUFLLFNBQVMsYUFBYTtBQUM5QixzQkFBSSxNQUFLLFVBQVUsTUFBSyxlQUFlO0FBQ3RDLDBCQUFLLGVBQWUsR0FBRSxNQUFLO0FBSTNCLG1DQUFlOztBQUVoQixzQkFBSSxNQUFLLFNBQVMsVUFBVSxNQUFLLGNBQWM7QUFDOUMsbUNBQWU7OztBQUdqQjttQkFHSTttQkFDQTtBQUNKLHNCQUFLLGdCQUFnQjtBQUNyQjs7QUFJRixnQkFBSSxNQUFLLGlCQUFpQixDQUFDLFVBQVUsY0FBdUIsSUFBSTtBQUMvRCw2QkFBZTs7O1VBUWpCLFFBQVEsR0FBaUM7QUFFeEMsZ0JBQUksS0FBSyxVQUFVO0FBQ2xCOztBQUdELGtCQUFNLFFBQVEsS0FBSztBQUNuQixnQkFBSSxLQUFLLGNBQWM7QUFBUTtBQUMvQixpQkFBSyxZQUFZO0FBRWpCLGdCQUFJLFNBQVMsSUFBSTtBQUNoQixtQkFBSztBQUNMOztBQUdELGdCQUFJLEtBQUssZ0JBQWdCO0FBQ3hCLDJCQUFhLEtBQUs7O0FBR25CLGlCQUFLLGlCQUFpQixRQUFRLE1BQUs7QUFDbEMsbUJBQUssaUJBQWlCO0FBQ3RCLG1CQUFLO2VBQ0gsS0FBSyxTQUFTOztVQUdsQixXQUFnQjtBQUNmLGtCQUFNLFFBQVEsS0FBSztBQUVuQixnQkFBSSxLQUFLLFNBQVMsV0FBVyxLQUFLLE1BQUssUUFBUTtBQUM5QyxtQkFBSyxLQUFLOztBQUdYLGlCQUFLO0FBQ0wsaUJBQUssUUFBUSxRQUFROztVQVF0QixjQUFlLEtBQThCLFFBQXlCO0FBQ3JFLGdCQUFJLEtBQUs7QUFBYztBQUN2QixpQkFBSyxnQkFBZ0IsUUFBUTs7VUFPOUIsUUFBUSxHQUFrQztBQUN6QyxnQkFBSSxRQUFPO0FBQ1gsZ0JBQUksYUFBYSxNQUFLO0FBRXRCLGdCQUFJLE1BQUssY0FBYyxNQUFLLFlBQVk7QUFDdkMsb0JBQUs7QUFDTCw2QkFBZTtBQUNmOztBQUdELGdCQUFJLE1BQUs7QUFBYTtBQUN0QixrQkFBSyxZQUFZO0FBQ2pCLGdCQUFJLE1BQUssU0FBUyxZQUFZO0FBQVUsb0JBQUs7QUFFN0MsZ0JBQUksQ0FBQztBQUFZLG9CQUFLLFFBQVE7QUFFOUIsZ0JBQUksQ0FBQyxNQUFLLFlBQVksUUFBUTtBQUM3QixvQkFBSztBQUNMLG9CQUFLLGVBQWUsQ0FBQyxDQUFDLE1BQUssU0FBUzs7QUFHckMsa0JBQUs7O1VBT04sT0FBTyxHQUFvQjtBQUUxQixnQkFBSSxTQUFTLGVBQWU7QUFBUTtBQUVwQyxnQkFBSSxRQUFPO0FBQ1gsZ0JBQUksQ0FBQyxNQUFLO0FBQVc7QUFDckIsa0JBQUssWUFBWTtBQUNqQixrQkFBSyxjQUFjO0FBRW5CLGdCQUFJLGFBQWEsTUFBTTtBQUN0QixvQkFBSztBQUNMLG9CQUFLO0FBQ0wsb0JBQUssU0FBUyxNQUFLLE1BQU07QUFDekIsb0JBQUssUUFBUTs7QUFHZCxnQkFBSSxNQUFLLFNBQVMsVUFBVSxNQUFLLFNBQVMsY0FBYztBQUN2RCxvQkFBSyxXQUFXLE1BQU07bUJBQ2hCO0FBQ047OztVQVVGLGVBQWdCLEtBQThCLFFBQW9CO0FBQ2pFLGdCQUFJLE9BQU8sUUFBTztBQUlsQixnQkFBSSxPQUFPLGlCQUFpQixPQUFPLGNBQWMsUUFBUSxvQkFBb0I7QUFDNUU7O0FBSUQsZ0JBQUksT0FBTyxVQUFVLFNBQVMsV0FBVztBQUN4QyxvQkFBSyxXQUFXLE1BQU0sTUFBTTtBQUMzQixvQkFBSSxNQUFLLFNBQVMsa0JBQWtCO0FBQ25DLHdCQUFLOzs7bUJBR0Q7QUFDTixzQkFBUSxPQUFPLFFBQVE7QUFDdkIsa0JBQUksT0FBTyxVQUFVLGFBQWE7QUFDakMsc0JBQUssWUFBWTtBQUNqQixzQkFBSyxRQUFRO0FBQ2Isb0JBQUksTUFBSyxTQUFTLGtCQUFrQjtBQUNuQyx3QkFBSzs7QUFHTixvQkFBSSxDQUFDLE1BQUssU0FBUyxnQkFBZ0IsSUFBSSxRQUFRLFFBQVEsS0FBSyxJQUFJLE9BQU87QUFDdEUsd0JBQUssZ0JBQWdCOzs7OztVQVV6QixVQUFVLFFBQWdDO0FBRXpDLGdCQUFJLEtBQUssVUFBVSxVQUFVLEtBQUssaUJBQWlCLFNBQVMsU0FBVTtBQUNyRSxxQkFBTzs7QUFFUixtQkFBTzs7VUFRUixhQUFjLEtBQWlCLE1BQXVCO0FBQ3JELGdCQUFJLFFBQU87QUFFWCxnQkFBSSxDQUFDLE1BQUssWUFBWSxNQUFLLFNBQVMsU0FBUyxTQUFTO0FBQ3JELDZCQUFlO0FBQ2Ysb0JBQUssY0FBYyxNQUFNO0FBQ3pCLHFCQUFPOztBQUVSLG1CQUFPOztVQW1CUixRQUFRLE9BQXFCO0FBRTVCLGdCQUFJLENBQUMsS0FBSyxTQUFTO0FBQU8scUJBQU87QUFDakMsZ0JBQUksS0FBSyxlQUFlLGVBQWU7QUFBUyxxQkFBTztBQUV2RCxtQkFBTzs7VUFPUixLQUFLLE9BQW1CO0FBQ3ZCLGtCQUFNLFFBQU87QUFFYixnQkFBSSxDQUFDLE1BQUssUUFBUTtBQUFTO0FBRTNCLHVCQUFXLE1BQUssU0FBUSxNQUFLLFNBQVM7QUFDdEMsa0JBQUs7QUFFTCxrQkFBTSxXQUFXLE1BQUssYUFBYSxLQUFLO0FBQ3hDLGtCQUFLLFNBQVMsS0FBSyxLQUFLLE9BQU0sT0FBTzs7VUFPdEMsYUFBYyxTQUFxQixXQUE0QjtBQUM5RCxrQkFBTSxRQUFPO0FBQ2Isa0JBQUssVUFBVSxLQUFLLElBQUksTUFBSyxVQUFVLEdBQUc7QUFDMUMsa0JBQUssWUFBWTtBQUVqQixrQkFBSztBQUNMLGtCQUFLLGFBQWEsU0FBUTtBQUUxQixrQkFBSyxlQUFlLE1BQUssYUFBYSxDQUFDLE1BQUs7QUFFNUMsZ0JBQUksQ0FBQyxNQUFLLFNBQVM7QUFDbEIsNEJBQWMsTUFBSyxTQUFRLE1BQUssU0FBUzs7QUFHMUMsa0JBQUssUUFBUSxRQUFRLFNBQVM7O1VBRy9CLFVBQWM7QUFDYixnQkFBSSxZQUFZLEtBQUssUUFBUTtBQUM3QixnQkFBSSxVQUFVLFNBQVM7QUFBZTtBQUN0QyxzQkFBVSxJQUFJO0FBQ2QsaUJBQUssS0FBSzs7VUFRWCxnQkFBZ0IsUUFBZSxJQUFJO0FBQ2xDLGdCQUFJLFFBQVEsS0FBSztBQUNqQixnQkFBSSxVQUFVLE1BQU0sVUFBVTtBQUM5QixnQkFBSSxTQUFTO0FBQ1osb0JBQU0sUUFBUTtBQUNkLDJCQUFhLE9BQU07QUFDbkIsbUJBQUssWUFBWTs7O1VBV25CLFdBQTJCO0FBRTFCLGdCQUFJLEtBQUssaUJBQWlCLEtBQUssTUFBTSxhQUFhLGFBQWE7QUFDOUQscUJBQU8sS0FBSzs7QUFHYixtQkFBTyxLQUFLLE1BQU0sS0FBSyxLQUFLLFNBQVM7O1VBT3RDLFNBQVUsT0FBdUIsUUFBc0I7QUFDdEQsZ0JBQUksU0FBUyxTQUFTLEtBQUssQ0FBQztBQUU1Qiw0QkFBZ0IsTUFBTSxRQUFPLE1BQU07QUFDbEMsbUJBQUssTUFBTTtBQUNYLG1CQUFLLFNBQVMsT0FBTzs7O1VBU3ZCLFlBQVksT0FBa0I7QUFDN0IsZ0JBQUcsVUFBVTtBQUFHLHNCQUFRO0FBQ3hCLGlCQUFLLFNBQVMsV0FBVztBQUN6QixpQkFBSzs7VUFPTixjQUFlLE1BQWUsR0FBNkI7QUFDMUQsZ0JBQUksUUFBTztBQUNYLGdCQUFJO0FBQ0osZ0JBQUksR0FBRyxPQUFPLEtBQUs7QUFDbkIsZ0JBQUk7QUFFSixnQkFBSSxNQUFLLFNBQVMsU0FBUztBQUFVO0FBR3JDLGdCQUFJLENBQUMsTUFBTTtBQUNWLG9CQUFLO0FBQ0wsa0JBQUksTUFBSyxXQUFXO0FBQ25CLHNCQUFLOztBQUVOOztBQUlELHdCQUFZLEtBQUssRUFBRSxLQUFLO0FBRXhCLGdCQUFJLGNBQWMsV0FBVyxVQUFVLFlBQVcsTUFBTSxNQUFLLFlBQVksUUFBUTtBQUNoRixxQkFBTyxNQUFLO0FBQ1osc0JBQVEsTUFBTSxVQUFVLFFBQVEsS0FBSyxNQUFLLFFBQVEsVUFBVTtBQUM1RCxvQkFBTyxNQUFNLFVBQVUsUUFBUSxLQUFLLE1BQUssUUFBUSxVQUFVO0FBRTNELGtCQUFJLFFBQVEsS0FBSztBQUNoQix1QkFBUTtBQUNSLHdCQUFRO0FBQ1Isc0JBQVE7O0FBRVQsbUJBQUssSUFBSSxPQUFPLEtBQUssS0FBSyxLQUFLO0FBQzlCLHVCQUFPLE1BQUssUUFBUSxTQUFTO0FBQzdCLG9CQUFJLE1BQUssWUFBWSxRQUFRLFVBQVUsSUFBSTtBQUMxQyx3QkFBSyxtQkFBbUI7OztBQUcxQiw2QkFBZTt1QkFDSixjQUFjLFdBQVcsVUFBVSxjQUF1QixNQUFTLGNBQWMsYUFBYSxVQUFVLFlBQVcsSUFBSztBQUNuSSxrQkFBSSxLQUFLLFVBQVUsU0FBUyxXQUFXO0FBQ3RDLHNCQUFLLGlCQUFrQjtxQkFDakI7QUFDTixzQkFBSyxtQkFBbUI7O21CQUVuQjtBQUNOLG9CQUFLO0FBQ0wsb0JBQUssbUJBQW1COztBQUl6QixrQkFBSztBQUNMLGdCQUFJLENBQUMsTUFBSyxXQUFXO0FBQ3BCLG9CQUFLOzs7VUFRUCxtQkFBb0IsTUFBYztBQUNqQyxrQkFBTSxRQUFPO0FBQ2Isa0JBQU0sY0FBYyxNQUFLLFFBQVEsY0FBYztBQUMvQyxnQkFBSTtBQUFjLDRCQUFjLGFBQTJCO0FBRTNELHVCQUFXLE1BQUs7QUFDaEIsa0JBQUssUUFBUSxlQUFlO0FBQzVCLGdCQUFJLE1BQUssWUFBWSxRQUFRLFNBQVMsSUFBSTtBQUN6QyxvQkFBSyxZQUFZLEtBQU07OztVQVF6QixpQkFBa0IsTUFBYztBQUMvQixnQkFBSSxNQUFNLEtBQUssWUFBWSxRQUFRO0FBQ25DLGlCQUFLLFlBQVksT0FBTyxLQUFLO0FBQzdCLDBCQUFjLE1BQUs7O1VBT3BCLG1CQUFrQjtBQUNqQiwwQkFBYyxLQUFLLGFBQVk7QUFDL0IsaUJBQUssY0FBYzs7VUFRcEIsZ0JBQWlCLFFBQXdCLFVBQWUsTUFBVztBQUVsRSxnQkFBSSxXQUFXLEtBQUssY0FBYztBQUNqQzs7QUFHRCxpQkFBSztBQUNMLGdCQUFJLENBQUM7QUFBUztBQUVkLGlCQUFLLGVBQWU7QUFDcEIsb0JBQVEsS0FBSyxZQUFXO2NBQUMseUJBQXdCLE9BQU8sYUFBYTs7QUFDckUsb0JBQVEsUUFBTztjQUFDLGlCQUFnQjs7QUFDaEMsdUJBQVcsUUFBTztBQUNsQixnQkFBSTtBQUFTLG1CQUFLLGVBQWU7O1VBT2xDLGVBQWdCLFFBQXlCLFVBQXVCO0FBRS9ELGdCQUFJLENBQUM7QUFBUztBQUVkLGtCQUFNLFVBQVcsS0FBSztBQUN0QixrQkFBTSxjQUFjLFFBQVE7QUFDNUIsa0JBQU0sWUFBYSxRQUFRLGFBQWE7QUFDeEMsa0JBQU0sY0FBYyxPQUFPO0FBQzNCLGtCQUFNLElBQU8sT0FBTyx3QkFBd0IsTUFBTSxRQUFRLHdCQUF3QixNQUFNO0FBRXhGLGdCQUFJLElBQUksY0FBYyxjQUFjLFdBQVc7QUFDOUMsbUJBQUssT0FBTyxJQUFJLGNBQWMsYUFBYTt1QkFFakMsSUFBSSxXQUFXO0FBQ3pCLG1CQUFLLE9BQU8sR0FBRzs7O1VBUWpCLE9BQVEsV0FBa0IsVUFBdUI7QUFDaEQsa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGdCQUFJLFVBQVU7QUFDYixzQkFBUSxNQUFNLGlCQUFpQjs7QUFFaEMsb0JBQVEsWUFBWTtBQUNwQixvQkFBUSxNQUFNLGlCQUFpQjs7VUFPaEMsb0JBQW1CO0FBQ2xCLGdCQUFJLEtBQUssY0FBYztBQUN0Qiw0QkFBYyxLQUFLLGNBQWE7QUFDaEMsc0JBQVEsS0FBSyxjQUFhO2dCQUFDLGlCQUFnQjs7O0FBRTVDLGlCQUFLLGVBQWU7QUFDcEIsb0JBQVEsS0FBSyxZQUFXO2NBQUMseUJBQXdCOzs7VUFPbEQsWUFBWTtBQUNYLGtCQUFNLFFBQU87QUFFYixnQkFBSSxNQUFLLFNBQVMsU0FBUztBQUFVO0FBRXJDLGtCQUFNLGNBQWMsTUFBSztBQUV6QixnQkFBSSxDQUFDLFlBQVk7QUFBUztBQUUxQixrQkFBSztBQUNMLGtCQUFLO0FBRUwsa0JBQUssY0FBYztBQUNuQixzQkFBUyxhQUFjLFVBQWlCO0FBQ3ZDLG9CQUFLLG1CQUFtQjs7O1VBUzFCLGFBQVk7QUFDWCxnQkFBSSxRQUFPO0FBRVgsZ0JBQUksQ0FBQyxNQUFLLFFBQVEsU0FBUyxNQUFLO0FBQWlCO0FBRWpELG9CQUFRLE1BQUssZUFBYztjQUFDLGFBQVksTUFBSyxTQUFTOztBQUV0RCxnQkFBSSxNQUFLLFlBQVksU0FBUyxLQUFNLENBQUMsTUFBSyxhQUFhLE1BQUssU0FBUyxtQkFBbUIsTUFBSyxNQUFNLFNBQVMsR0FBSTtBQUMvRyxvQkFBSztBQUNMLG9CQUFLLGdCQUFnQjttQkFFakI7QUFFSixrQkFBSSxNQUFLLFNBQVMsbUJBQW1CLE1BQUssTUFBTSxTQUFTLEdBQUc7QUFDM0Qsd0JBQVEsTUFBSyxlQUFjO2tCQUFDLGFBQVk7OztBQUV6QyxvQkFBSyxnQkFBZ0I7O0FBR3RCLGtCQUFLLFFBQVEsVUFBVSxPQUFPLGdCQUFnQixNQUFLOztVQU1wRCxhQUFZO0FBQ1gsbUJBQU8sS0FBSyxjQUFjLE1BQU07O1VBTWpDLFFBQVE7QUFDUCxnQkFBSSxRQUFPO0FBQ1gsZ0JBQUksTUFBSyxjQUFjLE1BQUs7QUFBWTtBQUV4QyxrQkFBSyxjQUFjO0FBRW5CLGdCQUFJLE1BQUssY0FBYyxhQUFhO0FBQ25DLG9CQUFLLGNBQWM7bUJBQ2Y7QUFDSixvQkFBSyxXQUFXOztBQUdqQix1QkFBVyxNQUFNO0FBQ2hCLG9CQUFLLGNBQWM7QUFDbkIsb0JBQUs7ZUFDSDs7VUFPSixPQUFZO0FBQ1gsaUJBQUssV0FBVztBQUNoQixpQkFBSzs7VUFVTixpQkFBaUIsT0FBYztBQUM5QixtQkFBTyxLQUFLLE9BQU8saUJBQWlCLE9BQU8sS0FBSzs7VUFVakQsbUJBQW1CO0FBQ2xCLGdCQUFJLFdBQVcsS0FBSztBQUNwQixnQkFBSSxPQUFPLFNBQVM7QUFDcEIsZ0JBQUksT0FBTyxTQUFTLGNBQWMsVUFBVTtBQUMzQyxxQkFBTyxDQUFDO2dCQUFDLE9BQU8sU0FBUzs7O0FBRzFCLG1CQUFPO2NBQ04sUUFBYyxTQUFTO2NBQ3ZCLGFBQWMsU0FBUztjQUN2QjtjQUNBLFNBQWMsU0FBUzs7O1VBU3pCLE9BQU8sT0FBNEM7QUFDbEQsZ0JBQUksUUFBUTtBQUNaLGdCQUFJLFFBQVc7QUFDZixnQkFBSSxVQUFXLEtBQUs7QUFHcEIsZ0JBQUssTUFBSyxTQUFTLE9BQU87QUFDekIsK0JBQWlCLE1BQUssU0FBUyxNQUFNLEtBQUssT0FBSztBQUMvQyxrQkFBSSxPQUFPLG1CQUFtQixZQUFZO0FBQ3pDLHNCQUFNLElBQUksTUFBTTs7O0FBS2xCLGdCQUFJLFVBQVUsTUFBSyxXQUFXO0FBQzdCLG9CQUFLLFlBQWM7QUFDbkIsdUJBQWEsTUFBSyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sU0FBUztnQkFBQyxPQUFPOztBQUN0RSxvQkFBSyxpQkFBa0I7bUJBQ2pCO0FBQ04sdUJBQWEsT0FBTyxPQUFRLElBQUksTUFBSzs7QUFJdEMsZ0JBQUksTUFBSyxTQUFTLGNBQWM7QUFDL0IscUJBQU8sUUFBUSxPQUFPLE1BQU0sT0FBUSxVQUFTO0FBQzVDLG9CQUFJLFNBQVMsU0FBUyxLQUFLO0FBQzNCLHVCQUFPLENBQUUsV0FBVSxNQUFLLE1BQU0sUUFBUSxZQUFZOzs7QUFJcEQsbUJBQU87O1VBUVIsZUFBZ0Isa0JBQTBCLE1BQU07QUFDL0MsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxVQUFVLFdBQVcsTUFBdUIsbUJBQW1CO0FBQy9FLGdCQUFJO0FBR0osa0JBQU0sU0FBZ0M7QUFDdEMsa0JBQU0sZUFBdUI7QUFFN0IsZ0JBQUksUUFBVztBQUNmLGdCQUFJLFFBQVksTUFBSztBQUNyQixrQkFBTSxhQUFlLFVBQVUsTUFBSyxhQUFjLFNBQVMsTUFBTSxNQUFLLGFBQWE7QUFDbkYsZ0JBQUksVUFBYyxNQUFLLE9BQU87QUFDOUIsZ0JBQUksZ0JBQWlDO0FBQ3JDLGdCQUFJLGdCQUFrQixNQUFLLFNBQVMsY0FBYztBQUNsRCxnQkFBSSxtQkFBb0IsTUFBSztBQUc3QixnQkFBSSxZQUFZO0FBQ2YsOEJBQWtCLE1BQUs7QUFFdkIsa0JBQUksZUFBZTtBQUNsQiwrQkFBZSxjQUFjLFFBQVE7OztBQUt2QyxnQkFBSSxRQUFRLE1BQU07QUFDbEIsZ0JBQUksT0FBTyxNQUFLLFNBQVMsZUFBZSxVQUFVO0FBQ2pELGtCQUFJLEtBQUssSUFBSSxHQUFHLE1BQUssU0FBUzs7QUFHL0IsZ0JBQUksSUFBSSxHQUFHO0FBQ1YsOEJBQWdCOztBQUlqQixrQkFBTSxtQkFBbUIsQ0FBQyxXQUFnQixVQUEyQztBQUVwRixrQkFBSSxnQkFBZ0IsT0FBTztBQUUzQixrQkFBSSxrQkFBa0IsUUFBVztBQUNoQyxvQkFBSSxjQUFjLGFBQWE7QUFDL0Isb0JBQUksZ0JBQWdCLFFBQVc7QUFDOUIseUJBQU8sQ0FBQyxlQUFjLFlBQVk7OztBQUlwQyxrQkFBSSxpQkFBaUIsU0FBUztBQUM5Qiw4QkFBZ0IsYUFBYTtBQUM3QiwyQkFBYSxLQUFLO2dCQUFDLFVBQVM7Z0JBQWU7Z0JBQU07O0FBRWpELHFCQUFPLENBQUMsZUFBYzs7QUFJdkIsaUJBQUssSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLO0FBR3ZCLGtCQUFJLE9BQVMsUUFBUSxNQUFNO0FBQzNCLGtCQUFJLENBQUM7QUFBTztBQUVaLGtCQUFJLFlBQWEsS0FBSztBQUN0QixrQkFBSSxTQUFXLE1BQUssUUFBUTtBQUU1QixrQkFBSSxXQUFXO0FBQVk7QUFFM0Isa0JBQUksV0FBWSxTQUFTO0FBQ3pCLGtCQUFJLFlBQWEsTUFBSyxVQUFVLFVBQVM7QUFHekMsa0JBQUksQ0FBQyxNQUFLLFNBQVMsY0FBYztBQUNoQywwQkFBVSxVQUFVLE9BQU8sWUFBWSxNQUFLLE1BQU0sU0FBUzs7QUFHNUQseUJBQWMsT0FBTyxNQUFLLFNBQVMsa0JBQWtCO0FBQ3JELDBCQUFjLE1BQU0sUUFBUSxZQUFZLFdBQVcsQ0FBQztBQUdwRCxtQkFBSyxJQUFJLEdBQUcsSUFBSSxhQUFhLFVBQVUsUUFBUSxJQUFJLEdBQUcsS0FBSztBQUMxRCwyQkFBVyxVQUFVO0FBRXJCLG9CQUFJLFFBQVEsT0FBTztBQUNuQixvQkFBSSxnQkFBZ0IsTUFBSyxVQUFVO0FBQ25DLG9CQUFJLGtCQUFrQixRQUFXO0FBQ2hDLDZCQUFXO3VCQUNQO0FBQ0osMEJBQVEsY0FBYzs7QUFHdkIsc0JBQU0sQ0FBQyxlQUFjLGtCQUFrQixpQkFBaUIsVUFBUztBQUlqRSxvQkFBSSxJQUFJLEdBQUc7QUFDViw4QkFBWSxVQUFVLFVBQVU7QUFDaEMsMEJBQVEsV0FBVTtvQkFBQyxJQUFJLE9BQU8sTUFBSSxZQUFVO29CQUFFLGlCQUFnQjs7QUFDOUQsNEJBQVUsVUFBVSxJQUFJO0FBQ3hCLGdDQUFjLFdBQVU7QUFJeEIsc0JBQUksTUFBSyxnQkFBZ0IsTUFBSyxhQUFhLFFBQVEsU0FBUyxXQUFXO0FBQ3RFLHdCQUFJLGdCQUFnQixhQUFhLFFBQVEsVUFBVSxTQUFTLFlBQVk7QUFDdkUsc0NBQWdCOzs7O0FBS25CLCtCQUFlLFlBQVk7QUFDM0Isb0JBQUksWUFBWSxJQUFJO0FBQ25CLHlCQUFPLFlBQVk7Ozs7QUFNdEIsZ0JBQUksTUFBSyxTQUFTLG1CQUFtQjtBQUNwQywyQkFBYSxLQUFLLENBQUMsR0FBRyxNQUFNO0FBQzNCLHVCQUFPLEVBQUUsUUFBUSxFQUFFOzs7QUFLckIsbUJBQU8sU0FBUztBQUNoQixzQkFBUyxjQUFlLGlCQUFzQjtBQUU3QyxrQkFBSSxpQkFBaUIsWUFBWTtBQUNqQyxrQkFBSSxZQUFXLFlBQVk7QUFFM0Isa0JBQUksQ0FBQyxrQkFBa0IsQ0FBQyxlQUFlLFNBQVM7QUFBUztBQUV6RCxrQkFBSSxnQkFBZ0IsTUFBSyxVQUFVO0FBRW5DLGtCQUFJLGtCQUFrQixRQUFXO0FBRWhDLG9CQUFJLGdCQUFnQixTQUFTO0FBQzdCLG9CQUFJLFNBQVMsTUFBSyxPQUFPLG1CQUFtQjtBQUM1Qyx1QkFBUSxlQUFlO0FBQ3ZCLHVCQUFRLGVBQWU7QUFFdkIsb0JBQUksYUFBYSxNQUFLLE9BQU8sWUFBWTtrQkFBQyxPQUFNO2tCQUFjLFNBQVE7O0FBRXRFLHVCQUFRLE1BQU07cUJBRVI7QUFDTix1QkFBUSxNQUFNOzs7QUFJaEIsNkJBQWlCLFlBQVk7QUFDN0IsbUJBQVEsa0JBQWtCO0FBRzFCLGdCQUFJLE1BQUssU0FBUyxXQUFXO0FBQzVCLDhCQUFpQjtBQUNqQixrQkFBSSxRQUFRLE1BQU0sVUFBVSxRQUFRLE9BQU8sUUFBUTtBQUNsRCwwQkFBUyxRQUFRLFFBQVMsU0FBUTtBQUNqQyw0QkFBVyxrQkFBa0IsSUFBSTs7OztBQU1wQyxnQkFBSSxlQUFnQixjQUE4QjtBQUNqRCxrQkFBSSxVQUFVLE1BQUssT0FBTyxVQUFTO2dCQUFDLE9BQU07O0FBQzFDLGtCQUFJLFNBQVM7QUFDWixnQ0FBZ0I7QUFDaEIsaUNBQWlCLGFBQWEsU0FBUyxpQkFBaUI7O0FBRXpELHFCQUFPOztBQUtSLGdCQUFJLE1BQUssU0FBUztBQUNqQiwyQkFBYTt1QkFHSixDQUFDLE1BQUssU0FBUyxXQUFXLEtBQUssT0FBSyxRQUFRO0FBQ3JELDJCQUFhO3VCQUdKLFFBQVEsTUFBTSxXQUFXLEdBQUc7QUFDckMsMkJBQWE7O0FBT2QsZ0NBQW9CLE1BQUssVUFBVTtBQUNuQyxnQkFBSSxtQkFBbUI7QUFDdEIsdUJBQVMsYUFBYTs7QUFLdkIsa0JBQUssYUFBYSxRQUFRLE1BQU0sU0FBUyxLQUFLO0FBQzlDLGdCQUFJLGVBQWU7QUFFbEIsa0JBQUksUUFBUSxNQUFNLFNBQVMsR0FBRztBQUU3QixvQkFBSSxDQUFDLGlCQUFpQixNQUFLLFNBQVMsU0FBUyxZQUFZLE1BQUssTUFBTSxNQUFNLFFBQVc7QUFDcEYsa0NBQWdCLE1BQUssVUFBVSxNQUFLLE1BQU07O0FBRzNDLG9CQUFJLENBQUMsaUJBQWlCLFNBQVMsZ0JBQWlCO0FBRS9DLHNCQUFJLGVBQWU7QUFDbkIsc0JBQUksVUFBVSxDQUFDLE1BQUssU0FBUyxlQUFlO0FBQzNDLG1DQUFlOztBQUVoQixrQ0FBZ0IsTUFBSyxhQUFhOzt5QkFHMUIsUUFBUTtBQUNqQixnQ0FBZ0I7O0FBR2pCLGtCQUFJLG1CQUFtQixDQUFDLE1BQUssUUFBUTtBQUNwQyxzQkFBSztBQUNMLHNCQUFLLGVBQWUsZUFBYzs7QUFFbkMsb0JBQUssZ0JBQWdCO21CQUVqQjtBQUNKLG9CQUFLO0FBQ0wsa0JBQUksbUJBQW1CLE1BQUssUUFBUTtBQUNuQyxzQkFBSyxNQUFNOzs7O1VBU2QsYUFBcUI7QUFDcEIsbUJBQU8sS0FBSyxpQkFBaUIsaUJBQWlCOztVQWdCL0MsVUFBVyxNQUFnQixlQUFlLE9BQXFCO0FBQzlELGtCQUFNLFFBQU87QUFJYixnQkFBSSxNQUFNLFFBQVEsT0FBTztBQUN4QixvQkFBSyxXQUFZLE1BQU07QUFDdkIscUJBQU87O0FBR1Isa0JBQU0sTUFBTSxTQUFTLEtBQUssTUFBSyxTQUFTO0FBQ3hDLGdCQUFJLFFBQVEsUUFBUSxNQUFLLFFBQVEsZUFBZSxNQUFNO0FBQ3JELHFCQUFPOztBQUdSLGlCQUFLLFNBQVcsS0FBSyxVQUFVLEVBQUUsTUFBSztBQUN0QyxpQkFBSyxNQUFRLE1BQUssVUFBVSxVQUFVLEtBQUs7QUFDM0Msa0JBQUssUUFBUSxPQUFPO0FBQ3BCLGtCQUFLLFlBQWE7QUFFbEIsZ0JBQUksY0FBYztBQUNqQixvQkFBSyxZQUFZLE9BQU87QUFDeEIsb0JBQUssUUFBUSxjQUFjLEtBQUs7O0FBR2pDLG1CQUFPOztVQU9SLFdBQVksTUFBa0IsZUFBZSxPQUFZO0FBQ3hELHNCQUFTLE1BQU8sU0FBa0I7QUFDakMsbUJBQUssVUFBVSxLQUFLOzs7VUFPdEIsZUFBZ0IsTUFBOEI7QUFDN0MsbUJBQU8sS0FBSyxVQUFVOztVQVF2QixvQkFBb0IsTUFBZ0I7QUFDbkMsZ0JBQUksTUFBTSxTQUFTLEtBQUssS0FBSyxTQUFTO0FBRXRDLGdCQUFLLFFBQVE7QUFBTyxxQkFBTztBQUUzQixpQkFBSyxTQUFTLEtBQUssVUFBVSxFQUFFLEtBQUs7QUFDcEMsaUJBQUssVUFBVSxPQUFPO0FBQ3RCLG1CQUFPOztVQVFSLGVBQWUsSUFBVyxNQUFnQjtBQUN6QyxnQkFBSTtBQUNKLGlCQUFLLEtBQUssU0FBUyxzQkFBc0I7QUFFekMsZ0JBQUksWUFBWSxLQUFLLG9CQUFvQixPQUFPO0FBQy9DLG1CQUFLLFFBQVEsZ0JBQWdCLFdBQVc7OztVQVExQyxrQkFBa0IsSUFBVztBQUM1QixnQkFBSSxLQUFLLFVBQVUsZUFBZSxLQUFLO0FBQ3RDLHFCQUFPLEtBQUssVUFBVTtBQUN0QixtQkFBSztBQUNMLG1CQUFLLFFBQVEsbUJBQW1COzs7VUFPbEMsb0JBQW9CO0FBQ25CLGlCQUFLLFlBQVk7QUFDakIsaUJBQUs7QUFDTCxpQkFBSyxRQUFROztVQVNkLGFBQWEsT0FBYyxNQUFnQjtBQUMxQyxrQkFBTSxRQUFPO0FBQ2IsZ0JBQUk7QUFDSixnQkFBSTtBQUVKLGtCQUFNLFlBQWEsU0FBUztBQUM1QixrQkFBTSxZQUFhLFNBQVMsS0FBSyxNQUFLLFNBQVM7QUFHL0MsZ0JBQUksY0FBYztBQUFPO0FBRXpCLGtCQUFNLFdBQVksTUFBSyxRQUFRO0FBRS9CLGdCQUFJLFlBQVk7QUFBWTtBQUM1QixnQkFBSSxPQUFPLGNBQWM7QUFBVyxvQkFBTSxJQUFJLE1BQU07QUFHcEQsa0JBQU0sU0FBVSxNQUFLLFVBQVU7QUFDL0Isa0JBQU0sT0FBUyxNQUFLLFFBQVE7QUFHNUIsaUJBQUssU0FBUyxLQUFLLFVBQVUsU0FBUztBQUN0QyxtQkFBTyxNQUFLLFFBQVE7QUFJcEIsa0JBQUssYUFBYTtBQUVsQixrQkFBSyxRQUFRLGFBQWE7QUFHMUIsZ0JBQUksUUFBUTtBQUNYLGtCQUFJLE1BQUssaUJBQWlCLFNBQVMsU0FBUztBQUUzQyxzQkFBTSxhQUFhLE1BQUssUUFBUSxVQUFVO0FBQzFDLDRCQUFZLFFBQVE7QUFFcEIsb0JBQUksTUFBSyxpQkFBaUIsUUFBUTtBQUNqQyx3QkFBSyxnQkFBZ0I7OztBQUd2QixxQkFBTzs7QUFJUixnQkFBSSxNQUFNO0FBQ1QsMkJBQWEsTUFBSyxNQUFNLFFBQVE7QUFDaEMsa0JBQUksZUFBZSxJQUFJO0FBQ3RCLHNCQUFLLE1BQU0sT0FBTyxZQUFZLEdBQUc7O0FBR2xDLHlCQUFXLE1BQUssUUFBUSxRQUFRO0FBRWhDLGtCQUFJLEtBQUssVUFBVSxTQUFTO0FBQVksMkJBQVcsVUFBUztBQUU1RCwwQkFBYSxNQUFNOztBQUlwQixrQkFBSyxZQUFZOztVQU9sQixhQUFhLE9BQWMsUUFBc0I7QUFDaEQsa0JBQU0sUUFBTztBQUNiLG9CQUFRLFNBQVM7QUFFakIsa0JBQUssYUFBYTtBQUVsQixtQkFBTyxNQUFLLFlBQVk7QUFDeEIsbUJBQU8sTUFBSyxRQUFRO0FBQ3BCLGtCQUFLLFlBQVk7QUFDakIsa0JBQUssUUFBUSxpQkFBaUI7QUFDOUIsa0JBQUssV0FBVyxPQUFPOztVQU14QixhQUFhLFFBQXlCO0FBRXJDLGtCQUFNLGNBQWUsV0FBVSxLQUFLLGFBQWEsS0FBSztBQUV0RCxpQkFBSyxpQkFBa0I7QUFDdkIsaUJBQUssY0FBZTtBQUNwQixpQkFBSztBQUVMLGtCQUFNLFdBQXNCO0FBQzVCLHNCQUFRLEtBQUssU0FBUSxDQUFDLFFBQWlCLFFBQWE7QUFDbkQsa0JBQUksWUFBWSxRQUFPLE1BQWdCO0FBQ3RDLHlCQUFTLE9BQU87OztBQUlsQixpQkFBSyxVQUFVLEtBQUssT0FBTyxRQUFRO0FBQ25DLGlCQUFLLFlBQVk7QUFDakIsaUJBQUssUUFBUTs7VUFRZCxZQUFZLFFBQWlCLE9BQWE7QUFDekMsZ0JBQUksS0FBSyxNQUFNLFFBQVEsVUFBVSxHQUFHO0FBQ25DLHFCQUFPOztBQUVSLG1CQUFPOztVQVFSLFVBQVUsT0FBNEMsU0FBZSxPQUF3QjtBQUU1RixrQkFBTSxTQUFTLFNBQVM7QUFDeEIsZ0JBQUksV0FBVztBQUFPLHFCQUFPO0FBRTdCLGtCQUFNLFNBQVMsS0FBSyxRQUFRO0FBQzVCLGdCQUFJLFVBQVUsUUFBVztBQUV4QixrQkFBSSxPQUFPLE1BQU07QUFDaEIsdUJBQU8sT0FBTzs7QUFHZixrQkFBSSxRQUFRO0FBQ1gsdUJBQU8sS0FBSyxRQUFRLFVBQVU7OztBQUloQyxtQkFBTzs7VUFRUixZQUFhLFFBQXlCLFdBQWtCLE9BQWMsVUFBNkI7QUFDbEcsZ0JBQUksUUFBTyxNQUFNO0FBRWpCLGdCQUFJLENBQUMsUUFBUTtBQUNaLHFCQUFPOztBQUdSLGdCQUFJLFFBQVEsUUFBUTtBQUNuQixvQkFBUSxNQUFLO21CQUNUO0FBQ0osb0JBQVEsTUFBSyxpQkFBaUIsaUJBQWlCOztBQUdoRCxxQkFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsS0FBSztBQUNwQyxrQkFBSSxJQUFJLE1BQU0sUUFBUTtBQUNyQjs7QUFHRCxrQkFBSSxZQUFZLEdBQUc7QUFDbEIsdUJBQU8sSUFBSSxJQUFFOztBQUdkLHFCQUFPLElBQUksSUFBRTs7QUFFZCxtQkFBTzs7VUFTUixRQUFRLE1BQXVDO0FBRTlDLGdCQUFJLE9BQU8sUUFBUSxVQUFVO0FBQzVCLHFCQUFPOztBQUdSLGdCQUFJLFFBQVEsU0FBUztBQUNyQixtQkFBTyxVQUFVLE9BQ2QsS0FBSyxRQUFRLGNBQWUsZ0JBQWUsV0FBVyxjQUN0RDs7VUFRSixTQUFVLFFBQXdCLFFBQXNCO0FBQ3ZELGdCQUFJLFFBQU87QUFFWCxnQkFBSSxRQUFRLE1BQU0sUUFBUSxVQUFVLFNBQVMsQ0FBQztBQUM5QyxvQkFBUSxNQUFNLE9BQU8sT0FBSyxNQUFLLE1BQU0sUUFBUSxPQUFPO0FBQ3BELGtCQUFNLFlBQVksTUFBTSxNQUFNLFNBQVM7QUFDdkMsa0JBQU0sUUFBUSxVQUFRO0FBQ3JCLG9CQUFLLFlBQWEsU0FBUztBQUMzQixvQkFBSyxRQUFRLE1BQU07OztVQVNyQixRQUFTLE9BQWMsUUFBc0I7QUFDNUMsZ0JBQUksU0FBUyxTQUFTLEtBQUssQ0FBQyxVQUFTO0FBRXJDLDRCQUFnQixNQUFNLFFBQVEsTUFBTTtBQUNuQyxrQkFBSSxNQUFNO0FBQ1Ysb0JBQU0sUUFBTztBQUNaLG9CQUFNLFlBQVksTUFBSyxTQUFTO0FBQ2pDLG9CQUFNLFNBQVMsU0FBUztBQUV4QixrQkFBSSxVQUFVLE1BQUssTUFBTSxRQUFRLFlBQVksSUFBSTtBQUVoRCxvQkFBSSxjQUFjLFVBQVU7QUFDM0Isd0JBQUs7O0FBR04sb0JBQUksY0FBYyxZQUFZLENBQUMsTUFBSyxTQUFTLFlBQVk7QUFDeEQ7OztBQUlGLGtCQUFJLFdBQVcsUUFBUSxDQUFDLE1BQUssUUFBUSxlQUFlO0FBQVM7QUFDN0Qsa0JBQUksY0FBYztBQUFVLHNCQUFLLE1BQU07QUFDdkMsa0JBQUksY0FBYyxXQUFXLE1BQUs7QUFBVTtBQUU1QyxxQkFBTyxNQUFLLFFBQVEsUUFBUSxNQUFLLFFBQVE7QUFFekMsa0JBQUksTUFBSyxRQUFRLFNBQVMsT0FBTztBQUNoQyx1QkFBTyxLQUFLLFVBQVU7O0FBR3ZCLHdCQUFVLE1BQUs7QUFDZixvQkFBSyxNQUFNLE9BQU8sTUFBSyxVQUFVLEdBQUc7QUFDcEMsb0JBQUssY0FBYztBQUVuQixrQkFBSSxNQUFLLFNBQVM7QUFHakIsb0JBQUksQ0FBQyxNQUFLLGFBQWEsTUFBSyxTQUFTLGNBQWM7QUFDbEQsc0JBQUksU0FBUyxNQUFLLFVBQVU7QUFDNUIsc0JBQUksT0FBTyxNQUFLLFlBQVksUUFBUTtBQUNwQyxzQkFBSSxNQUFNO0FBQ1QsMEJBQUssZ0JBQWdCOzs7QUFNdkIsb0JBQUksQ0FBQyxNQUFLLGFBQWEsQ0FBQyxNQUFLLFNBQVMsa0JBQWtCO0FBQ3ZELHdCQUFLLGVBQWUsTUFBSyxhQUFhLGNBQWM7O0FBSXJELG9CQUFJLE1BQUssU0FBUyxvQkFBb0IsU0FBUyxNQUFLLFVBQVU7QUFDN0Qsd0JBQUs7MkJBQ0ssQ0FBQyxNQUFLLFdBQVc7QUFDM0Isd0JBQUs7O0FBR04sc0JBQUssUUFBUSxZQUFZLFFBQVE7QUFFakMsb0JBQUksQ0FBQyxNQUFLLFdBQVc7QUFDcEIsd0JBQUssb0JBQW9CO29CQUFDOzs7O0FBSTVCLGtCQUFJLENBQUMsTUFBSyxhQUFjLENBQUMsV0FBVyxNQUFLLFVBQVc7QUFDbkQsc0JBQUs7QUFDTCxzQkFBSzs7OztVQVdSLFdBQVksT0FBeUIsTUFBTSxRQUFpQjtBQUMzRCxrQkFBTSxRQUFRO0FBQ2QsbUJBQVMsTUFBSyxRQUFRO0FBRXRCLGdCQUFJLENBQUM7QUFBTztBQUVaLGdCQUFJLEdBQUU7QUFDTixrQkFBTSxRQUFRLEtBQUssUUFBUTtBQUMzQixnQkFBSSxVQUFVO0FBRWQsaUJBQUs7QUFDTCxnQkFBSSxLQUFLLFVBQVUsU0FBUyxXQUFXO0FBQ3RDLG9CQUFNLE1BQUssWUFBWSxRQUFRO0FBQy9CLG9CQUFLLFlBQVksT0FBTyxLQUFLO0FBQzdCLDRCQUFjLE1BQUs7O0FBR3BCLGtCQUFLLE1BQU0sT0FBTyxHQUFHO0FBQ3JCLGtCQUFLLFlBQVk7QUFDakIsZ0JBQUksQ0FBQyxNQUFLLFNBQVMsV0FBVyxNQUFLLFlBQVksZUFBZSxRQUFRO0FBQ3JFLG9CQUFLLGFBQWEsT0FBTzs7QUFHMUIsZ0JBQUksSUFBSSxNQUFLLFVBQVU7QUFDdEIsb0JBQUssU0FBUyxNQUFLLFdBQVc7O0FBRy9CLGtCQUFLLG9CQUFvQjtjQUFDOztBQUMxQixrQkFBSztBQUNMLGtCQUFLO0FBQ0wsa0JBQUssUUFBUSxlQUFlLE9BQU87O1VBYXBDLFdBQVksUUFBa0IsTUFBTSxXQUE2QixNQUFJO2FBQVk7QUFHaEYsZ0JBQUksVUFBVSxXQUFXLEdBQUc7QUFDM0IseUJBQVcsVUFBVTs7QUFFdEIsZ0JBQUksT0FBTyxZQUFZLFlBQVk7QUFDbEMseUJBQVcsTUFBTTs7O0FBR2xCLGdCQUFJLFFBQVE7QUFDWixnQkFBSSxRQUFRLE1BQUs7QUFDakIsZ0JBQUk7QUFDSixvQkFBUSxTQUFTLE1BQUs7QUFFdEIsZ0JBQUksQ0FBQyxNQUFLLFVBQVUsUUFBUTtBQUMzQjtBQUNBLHFCQUFPOztBQUdSLGtCQUFLO0FBRUwsZ0JBQUksVUFBVTtBQUNkLGdCQUFJLFNBQVUsVUFBNEI7QUFDekMsb0JBQUs7QUFFTCxrQkFBSSxDQUFDLFFBQVEsT0FBTyxTQUFTO0FBQVUsdUJBQU87QUFDOUMsa0JBQUksUUFBUSxTQUFTLEtBQUssTUFBSyxTQUFTO0FBQ3hDLGtCQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzlCLHVCQUFPOztBQUdSLG9CQUFLO0FBQ0wsb0JBQUssVUFBVSxNQUFLO0FBQ3BCLG9CQUFLLFNBQVM7QUFDZCxvQkFBSyxRQUFRO0FBQ2IsdUJBQVM7QUFDVCx3QkFBVTs7QUFHWCxnQkFBSSxPQUFPLE1BQUssU0FBUyxXQUFXLFlBQVk7QUFDL0MsdUJBQVMsTUFBSyxTQUFTLE9BQU8sS0FBSyxNQUFNLE9BQU87bUJBQzVDO0FBQ0osdUJBQVM7aUJBQ1AsTUFBSyxTQUFTLGFBQWE7aUJBQzNCLE1BQUssU0FBUyxhQUFhOzs7QUFJOUIsZ0JBQUksQ0FBQyxTQUFTO0FBQ2IscUJBQU87O0FBR1IsbUJBQU87O1VBTVIsZUFBZTtBQUNkLGdCQUFJLFFBQU87QUFDWCxrQkFBSyxZQUFZO0FBRWpCLGdCQUFJLE1BQUssU0FBUztBQUNqQixvQkFBSyxTQUFTLE1BQUs7O0FBR3BCLGtCQUFLO0FBQ0wsa0JBQUs7O1VBT04sZUFBZTtBQUNkLGtCQUFNLFFBQVc7QUFFakIsa0JBQUs7QUFFTCxrQkFBTSxTQUFTLE1BQUs7QUFDcEIsa0JBQU0sV0FBVyxNQUFLO0FBRXRCLGtCQUFLLFFBQVEsVUFBVSxPQUFPLE9BQU0sTUFBSztBQUd6QyxrQkFBTSxpQkFBaUIsTUFBSyxRQUFRO0FBRXBDLDJCQUFlLE9BQU8sU0FBUyxNQUFLO0FBQ3BDLDJCQUFlLE9BQU8sWUFBWSxNQUFLO0FBQ3ZDLDJCQUFlLE9BQU8sWUFBWSxNQUFLO0FBQ3ZDLDJCQUFlLE9BQU8sWUFBWSxNQUFLO0FBQ3ZDLDJCQUFlLE9BQU8sV0FBVyxDQUFDLE1BQUs7QUFDdkMsMkJBQWUsT0FBTyxVQUFVO0FBQ2hDLDJCQUFlLE9BQU8sUUFBUTtBQUM5QiwyQkFBZSxPQUFPLGdCQUFnQixNQUFLLGFBQWEsQ0FBQyxNQUFLO0FBQzlELDJCQUFlLE9BQU8sbUJBQW1CLE1BQUs7QUFDOUMsMkJBQWUsT0FBTyxlQUFlLGNBQWMsTUFBSztBQUN4RCwyQkFBZSxPQUFPLGFBQWEsTUFBSyxNQUFNLFNBQVM7O1VBYXhELHVCQUF1QjtBQUN0QixnQkFBSSxRQUFPO0FBRVgsZ0JBQUksQ0FBQyxNQUFLLE1BQU0sVUFBVTtBQUN6Qjs7QUFHRCxrQkFBSyxVQUFVLE1BQUssTUFBTSxTQUFTO0FBQ25DLGtCQUFLLFlBQVksQ0FBQyxNQUFLOztVQVN4QixTQUFTO0FBQ1IsbUJBQU8sS0FBSyxTQUFTLGFBQWEsUUFBUSxLQUFLLE1BQU0sVUFBVSxLQUFLLFNBQVM7O1VBUTlFLG9CQUFxQixPQUFvQixJQUFJO0FBQzVDLGtCQUFNLFFBQU87QUFDYixnQkFBSSxRQUFRO0FBRVosa0JBQU0sZUFBZSxNQUFLLE1BQU0sY0FBYztBQUU5QyxnQkFBSSxNQUFLLGVBQWU7QUFLdkIsa0JBQVMsY0FBVCxTQUFxQixXQUFrQyxPQUFjLFFBQStCO0FBRW5HLG9CQUFJLENBQUMsV0FBVztBQUNmLDhCQUFZLE9BQU8sb0JBQW9CLFlBQVksU0FBUyxPQUFPLFlBQVksVUFBUzs7QUFLekYsb0JBQUksYUFBYSxjQUFjO0FBQzlCLHdCQUFLLE1BQU0sT0FBTzs7QUFHbkIseUJBQVMsS0FBSztBQUlkLG9CQUFJLGFBQWEsZ0JBQWdCLGVBQWUsR0FBRztBQUNsRCw0QkFBVSxXQUFXOztBQUd0Qix1QkFBTzs7QUF2QlIsb0JBQU0sV0FBZ0M7QUFDdEMsb0JBQU0sZUFBeUIsTUFBSyxNQUFNLGlCQUFpQixrQkFBa0I7QUEwQjdFLG9CQUFLLE1BQU0saUJBQWlCLGtCQUFrQixRQUFTLGVBQXNCO0FBQ3hELDBCQUFXLFdBQVc7O0FBSzNDLGtCQUFJLE1BQUssTUFBTSxVQUFVLEtBQUssTUFBSyxTQUFTLFFBQVEsVUFBVTtBQUU3RCw0QkFBWSxjQUFjLElBQUk7cUJBRzFCO0FBRUosc0JBQUssTUFBTSxRQUFTLFdBQVE7QUFDM0IsMkJBQVcsTUFBSyxRQUFRO0FBQ3hCLDBCQUFVLE9BQU8sTUFBSyxTQUFTLGVBQWU7QUFFOUMsc0JBQUksU0FBUyxTQUFTLE9BQU8sVUFBVTtBQUN0QywwQkFBTSxZQUFZLE1BQUssTUFBTSxjQUFlLGlCQUFnQixXQUFXO0FBQ3ZFLGdDQUFZLFdBQVcsT0FBTzt5QkFDMUI7QUFDSiwyQkFBTyxVQUFVLFlBQVksT0FBTyxTQUFTLE9BQU87Ozs7bUJBTWpEO0FBQ04sb0JBQUssTUFBTSxRQUFRLE1BQUs7O0FBR3pCLGdCQUFJLE1BQUssU0FBUztBQUNqQixrQkFBSSxDQUFDLEtBQUssUUFBUTtBQUNqQixzQkFBSyxRQUFRLFVBQVUsTUFBSzs7OztVQVMvQixPQUFPO0FBQ04sZ0JBQUksUUFBTztBQUVYLGdCQUFJLE1BQUssWUFBWSxNQUFLLFVBQVcsTUFBSyxTQUFTLFNBQVMsV0FBVyxNQUFLO0FBQVc7QUFDdkYsa0JBQUssU0FBUztBQUNkLG9CQUFRLE1BQUssWUFBVztjQUFDLGlCQUFpQjs7QUFDMUMsa0JBQUs7QUFDTCxxQkFBUyxNQUFLLFVBQVM7Y0FBQyxZQUFZO2NBQVUsU0FBUzs7QUFDdkQsa0JBQUs7QUFDTCxxQkFBUyxNQUFLLFVBQVM7Y0FBQyxZQUFZO2NBQVcsU0FBUzs7QUFDeEQsa0JBQUs7QUFDTCxrQkFBSyxRQUFRLGlCQUFpQixNQUFLOztVQU1wQyxNQUFNLGtCQUFnQixNQUFNO0FBQzNCLGdCQUFJLFFBQU87QUFDWCxnQkFBSSxVQUFVLE1BQUs7QUFFbkIsZ0JBQUksaUJBQWlCO0FBR3BCLG9CQUFLO0FBRUwsa0JBQUksTUFBSyxTQUFTLFNBQVMsWUFBWSxNQUFLLE1BQU0sUUFBUTtBQUN6RCxzQkFBSzs7O0FBSVAsa0JBQUssU0FBUztBQUNkLG9CQUFRLE1BQUssWUFBVztjQUFDLGlCQUFpQjs7QUFDMUMscUJBQVMsTUFBSyxVQUFTO2NBQUMsU0FBUzs7QUFDakMsZ0JBQUksTUFBSyxTQUFTLGNBQWM7QUFDL0Isb0JBQUs7O0FBRU4sa0JBQUs7QUFFTCxnQkFBSTtBQUFTLG9CQUFLLFFBQVEsa0JBQWtCLE1BQUs7O1VBUWxELG1CQUFrQjtBQUVqQixnQkFBSSxLQUFLLFNBQVMsbUJBQW1CLFFBQVE7QUFDNUM7O0FBR0QsZ0JBQUksVUFBWSxLQUFLO0FBQ3JCLGdCQUFJLE9BQVMsUUFBUTtBQUNyQixnQkFBSSxNQUFTLFFBQVEsZUFBZSxLQUFLLE1BQU8sT0FBTztBQUN2RCxnQkFBSSxPQUFTLEtBQUssT0FBTyxPQUFPO0FBR2hDLHFCQUFTLEtBQUssVUFBUztjQUN0QixPQUFRLEtBQUssUUFBUTtjQUNyQixLQUFRLE1BQU07Y0FDZCxNQUFRLE9BQU87OztVQVVqQixNQUFNLFFBQWlCO0FBQ3RCLGdCQUFJLFFBQU87QUFFWCxnQkFBSSxDQUFDLE1BQUssTUFBTTtBQUFRO0FBRXhCLGdCQUFJLFFBQVEsTUFBSztBQUNqQixzQkFBUSxPQUFPLFVBQWU7QUFDN0Isb0JBQUssV0FBVyxNQUFLOztBQUd0QixrQkFBSztBQUNMLGdCQUFJLENBQUM7QUFBUyxvQkFBSztBQUNuQixrQkFBSyxRQUFROztVQVFkLGNBQWMsSUFBZ0I7QUFDN0Isa0JBQU0sUUFBUTtBQUNkLGtCQUFNLFFBQVMsTUFBSztBQUNwQixrQkFBTSxTQUFTLE1BQUs7QUFFcEIsbUJBQU8sYUFBYSxJQUFJLE9BQU8sU0FBUyxVQUFVO0FBQ2xELGtCQUFLLFNBQVMsUUFBUTs7VUFPdkIsZ0JBQWdCLEdBQXlCO0FBQ3hDLGdCQUFJLFdBQVcsV0FBVyxPQUFPO0FBQ2pDLGdCQUFJLFFBQU87QUFFWCx3QkFBYSxLQUFLLEVBQUUsWUFBWSxnQkFBMkIsS0FBSztBQUNoRSx3QkFBWSxhQUFhLE1BQUs7QUFJOUIsa0JBQU0sV0FBcUI7QUFFM0IsZ0JBQUksTUFBSyxZQUFZLFFBQVE7QUFFNUIscUJBQU8sUUFBUSxNQUFLLGFBQWE7QUFDakMsc0JBQVEsVUFBVTtBQUVsQixrQkFBSSxZQUFZLEdBQUc7QUFBRTs7QUFFckIsd0JBQVEsTUFBSyxhQUFjLFVBQWlCLFNBQVMsS0FBSzt1QkFFL0MsT0FBSyxhQUFhLE1BQUssU0FBUyxTQUFTLGFBQWEsTUFBSyxNQUFNLFFBQVE7QUFDcEYsb0JBQU0sUUFBUSxNQUFLO0FBQ25CLGtCQUFJO0FBQ0osa0JBQUksWUFBWSxLQUFLLFVBQVUsVUFBVSxLQUFLLFVBQVUsV0FBVyxHQUFHO0FBQ3JFLDBCQUFVLE1BQU0sTUFBSyxXQUFXO3lCQUV2QixZQUFZLEtBQUssVUFBVSxVQUFVLE1BQUssYUFBYSxRQUFRO0FBQ3hFLDBCQUFVLE1BQU0sTUFBSzs7QUFHdEIsa0JBQUksWUFBWSxRQUFXO0FBQzFCLHlCQUFTLEtBQU07OztBQUlqQixnQkFBSSxDQUFDLE1BQUssYUFBYSxVQUFTLElBQUk7QUFDbkMscUJBQU87O0FBR1IsMkJBQWUsR0FBRTtBQUdqQixnQkFBSSxPQUFPLFVBQVUsYUFBYTtBQUNqQyxvQkFBSyxTQUFTOztBQUdmLG1CQUFPLFNBQVMsUUFBUTtBQUN2QixvQkFBSyxXQUFXLFNBQVM7O0FBRzFCLGtCQUFLO0FBQ0wsa0JBQUs7QUFDTCxrQkFBSyxlQUFlO0FBRXBCLG1CQUFPOztVQU1SLGFBQWEsT0FBZ0IsS0FBNkI7QUFFekQsa0JBQU0sU0FBUyxNQUFNLElBQUksVUFBUSxLQUFLLFFBQVE7QUFHOUMsZ0JBQUksQ0FBQyxPQUFPLFVBQVcsT0FBTyxLQUFLLFNBQVMsYUFBYSxjQUFjLEtBQUssU0FBUyxTQUFTLFFBQU8sU0FBUyxPQUFRO0FBQ3JILHFCQUFPOztBQUdSLG1CQUFPOztVQVVSLGlCQUFpQixXQUFrQixHQUE2QjtBQUMvRCxnQkFBSSxhQUFhLFVBQVUsUUFBTztBQUVsQyxnQkFBSSxNQUFLO0FBQUssMkJBQWE7QUFDM0IsZ0JBQUksTUFBSyxhQUFhO0FBQVM7QUFJL0IsZ0JBQUksVUFBVSxjQUF1QixNQUFNLFVBQVUsWUFBVyxJQUFJO0FBRW5FLDRCQUFnQixNQUFLLGNBQWM7QUFDbkMsa0JBQUksYUFBYTtBQUVoQixvQkFBSSxDQUFDLFlBQVksVUFBVSxTQUFTLFdBQVc7QUFDOUMsNkJBQWE7dUJBQ1Q7QUFDSiw2QkFBYSxNQUFLLFlBQVksYUFBWSxXQUFVOzt5QkFJNUMsWUFBWSxHQUFHO0FBQ3hCLDJCQUFhLE1BQUssY0FBYztxQkFDNUI7QUFDSiwyQkFBYSxNQUFLLGNBQWM7O0FBSWpDLGtCQUFJLFVBQVU7QUFDYixvQkFBSSxTQUFTLFVBQVUsU0FBUyxXQUFXO0FBQzFDLHdCQUFLLGlCQUFpQjs7QUFFdkIsc0JBQUssbUJBQW1COzttQkFJckI7QUFDSixvQkFBSyxVQUFVOzs7VUFJakIsVUFBVSxXQUFpQjs7VUFNM0IsY0FBYyxXQUFrQjtBQUUvQixnQkFBSSxjQUFjLEtBQUssUUFBUSxjQUFjO0FBQzdDLGdCQUFJLGFBQWE7QUFDaEIscUJBQU87O0FBSVIsZ0JBQUksU0FBUyxLQUFLLFFBQVEsaUJBQWlCO0FBQzNDLGdCQUFJLFFBQVE7QUFDWCxxQkFBTyxRQUFRLFFBQU87OztVQWF4QixTQUFTLFNBQWdCO0FBQ3hCLGlCQUFLLFdBQVcsS0FBSyxNQUFNOztVQU81QixrQkFBMkI7QUFDMUIsbUJBQU8sTUFBTSxLQUFNLEtBQUssUUFBUSxpQkFBaUI7O1VBT2xELE9BQU87QUFDTixpQkFBSyxVQUFVOztVQU1oQixTQUFTO0FBQ1IsaUJBQUssVUFBVTs7VUFNaEIsVUFBVyxPQUFlLEtBQUssY0FBYyxLQUFLLFlBQVk7QUFDN0QsaUJBQUssV0FBVztBQUNoQixpQkFBSzs7VUFPTixVQUFVO0FBQ1QsaUJBQUssWUFBWTtBQUNqQixpQkFBSzs7VUFPTixTQUFTO0FBQ1IsaUJBQUssWUFBWTs7VUFHbEIsWUFBWSxVQUFpQjtBQUM1QixpQkFBSyxXQUFXLFdBQVksV0FBVyxLQUFLLEtBQUs7QUFDakQsaUJBQUssYUFBaUI7QUFDdEIsaUJBQUssTUFBTSxXQUFjO0FBQ3pCLGlCQUFLLGNBQWMsV0FBWTtBQUMvQixpQkFBSzs7VUFHTixZQUFZLFlBQW1CO0FBQzlCLGlCQUFLLGFBQWlCO0FBQ3RCLGlCQUFLLE1BQU0sV0FBYztBQUN6QixpQkFBSyxjQUFjLFdBQVk7QUFDL0IsaUJBQUs7O1VBUU4sVUFBVTtBQUNULGdCQUFJLFFBQU87QUFDWCxnQkFBSSxpQkFBaUIsTUFBSztBQUUxQixrQkFBSyxRQUFRO0FBQ2Isa0JBQUs7QUFDTCxrQkFBSyxRQUFRO0FBQ2Isa0JBQUssU0FBUztBQUVkLGtCQUFLLE1BQU0sWUFBWSxlQUFlO0FBQ3RDLGtCQUFLLE1BQU0sV0FBVyxlQUFlO0FBRXJDLDBCQUFjLE1BQUssT0FBTSxlQUFjO0FBRXZDLGtCQUFLO0FBRUwsbUJBQU8sTUFBSyxNQUFNOztVQVFuQixPQUFRLGNBQStCLE1BQTRCO0FBQ2xFLGdCQUFJLElBQUk7QUFDUixrQkFBTSxRQUFPO0FBRWIsZ0JBQUksT0FBTyxLQUFLLFNBQVMsT0FBTyxrQkFBa0IsWUFBWTtBQUM3RCxxQkFBTzs7QUFJUixtQkFBTyxNQUFLLFNBQVMsT0FBTyxjQUFjLEtBQUssTUFBTSxNQUFNO0FBRTNELGdCQUFJLENBQUMsTUFBTTtBQUNWLHFCQUFPOztBQUdSLG1CQUFPLE9BQVE7QUFHZixnQkFBSSxpQkFBaUIsWUFBWSxpQkFBaUIsaUJBQWlCO0FBRWxFLGtCQUFJLEtBQUssTUFBSyxTQUFTLGdCQUFnQjtBQUN0Qyx3QkFBUSxNQUFLO2tCQUFDLGlCQUFnQjs7cUJBQzFCO0FBQ0osd0JBQVEsTUFBSztrQkFBQyxtQkFBbUI7Ozt1QkFHekIsaUJBQWlCLFlBQVk7QUFDdEMsbUJBQUssS0FBSyxNQUFNLE1BQUssU0FBUztBQUM5QixzQkFBUSxNQUFLO2dCQUFDLGNBQWM7O0FBQzVCLGtCQUFHLEtBQUssTUFBTSxNQUFLLFNBQVMsZ0JBQWdCO0FBQzNDLHdCQUFRLE1BQUs7a0JBQUMsaUJBQWlCOzs7O0FBSWpDLGdCQUFJLGlCQUFpQixZQUFZLGlCQUFpQixRQUFRO0FBQ3pELG9CQUFNLFFBQVEsU0FBUyxLQUFLLE1BQUssU0FBUztBQUMxQyxzQkFBUSxNQUFLO2dCQUFDLGNBQWM7O0FBSTVCLGtCQUFJLGlCQUFpQixRQUFRO0FBQzVCLDJCQUFXLE1BQUssTUFBSyxTQUFTO0FBQzlCLHdCQUFRLE1BQUs7a0JBQUMsZ0JBQWU7O3FCQUN6QjtBQUNKLDJCQUFXLE1BQUssTUFBSyxTQUFTO0FBQzlCLHdCQUFRLE1BQUs7a0JBQ1osTUFBSztrQkFDTCxJQUFHLEtBQUs7O0FBSVQscUJBQUssT0FBTztBQUNaLHNCQUFLLFFBQVEsU0FBUzs7O0FBTXhCLG1CQUFPOztVQVNSLFFBQVMsY0FBK0IsTUFBdUI7QUFDOUQsa0JBQU0sT0FBTyxLQUFLLE9BQU8sY0FBYztBQUV2QyxnQkFBSSxRQUFRLE1BQU07QUFDakIsb0JBQU07O0FBRVAsbUJBQU87O1VBVVIsYUFBaUI7QUFFaEIsc0JBQVEsS0FBSyxTQUFVLFlBQW1CO0FBQ3pDLGtCQUFJLE9BQU8sTUFBTTtBQUNoQix1QkFBTyxLQUFLO0FBQ1osdUJBQU8sT0FBTzs7OztVQVVqQixhQUFhLE9BQWE7QUFFekIsa0JBQU0sWUFBYyxLQUFLLFVBQVU7QUFDbkMsZ0JBQUk7QUFBWSx3QkFBVTs7VUFTM0IsVUFBVyxPQUF1QjtBQUNqQyxtQkFBTyxLQUFLLFNBQVMsVUFBVyxNQUFNLFNBQVMsS0FBTyxLQUFLLFNBQVMsYUFBa0MsS0FBSyxNQUFNOztVQVdsSCxLQUFNLE1BQWEsUUFBZSxRQUFZO0FBQzdDLGdCQUFJLFFBQU87QUFDWCxnQkFBSSxjQUFjLE1BQUs7QUFHdkIsa0JBQUssVUFBVSxXQUFVO0FBQ3hCLGtCQUFJLFFBQVE7QUFFWixrQkFBSSxTQUFTLFNBQVM7QUFDckIseUJBQVMsWUFBWSxNQUFNLE9BQU07O0FBR2xDLDJCQUFhLE9BQU8sTUFBTSxPQUFNO0FBRWhDLGtCQUFJLFNBQVMsV0FBVztBQUN2Qix1QkFBTzs7QUFHUixrQkFBSSxTQUFTLFVBQVU7QUFDdEIseUJBQVMsWUFBWSxNQUFNLE9BQU07O0FBR2xDLHFCQUFPOzs7O0FDcnNGSyxtQ0FBeUI7QUFDdkMsbUJBQVMsS0FBSyxPQUFNLFVBQVMsTUFBSTtBQUNoQyxpQkFBSzs7O0FDQ1Esa0NBQXlCLGFBQXVCO0FBQzlELGNBQUksUUFBTztBQUNYLGNBQUksc0JBQXNCLE1BQUs7QUFFL0IsZ0JBQUssU0FBUyxlQUFlO0FBRTdCLGdCQUFNLFlBQXdCLE9BQU8sT0FBTztZQUUzQyxXQUF3QjtZQUd4QixtQkFBd0I7WUFDeEIscUJBQXdCO2FBQ3RCO0FBR0gsY0FBSSxnQkFBZ0Isd0JBQVMsVUFBMkIsU0FBbUI7QUFDMUUsZ0JBQUksU0FBUztBQUNaLHVCQUFTLFVBQVU7QUFDbkIsa0JBQUksVUFBVSxxQkFBcUI7QUFDbEMseUJBQVMsVUFBVSxPQUFPLEdBQUcsVUFBVTs7QUFFeEMsa0JBQUksVUFBVSxtQkFBbUI7QUFDaEMseUJBQVMsVUFBVSxJQUFJLEdBQUcsVUFBVTs7bUJBRWpDO0FBQ0osdUJBQVMsVUFBVTtBQUNuQixrQkFBSSxVQUFVLG1CQUFtQjtBQUNoQyx5QkFBUyxVQUFVLE9BQU8sR0FBRyxVQUFVOztBQUV4QyxrQkFBSSxVQUFVLHFCQUFxQjtBQUNsQyx5QkFBUyxVQUFVLElBQUksR0FBRyxVQUFVOzs7O0FBTXZDLGNBQUksaUJBQWlCLHlCQUFTLFFBQW1CO0FBQ2hELHVCQUFXLE1BQUk7QUFDZCxrQkFBSSxXQUFXLE9BQU8sY0FBYyxXQUFXLFVBQVU7QUFDekQsa0JBQUksb0JBQW9CLGtCQUFrQjtBQUN6Qyw4QkFBYyxVQUFVLE9BQU8sVUFBVSxTQUFTOztlQUVsRDs7QUFJSCxnQkFBSyxLQUFLLFNBQVEsa0JBQWlCLE1BQU07QUFFeEMsZ0JBQUkscUJBQXFCLE1BQUssU0FBUyxPQUFPO0FBRTlDLGtCQUFLLFNBQVMsT0FBTyxTQUFTLENBQUMsTUFBTSxpQkFBZ0I7QUFDcEQsa0JBQUksV0FBVyxPQUFPLG1CQUFtQixLQUFLLE9BQU0sTUFBTTtBQUMxRCxrQkFBSSxXQUFXLFNBQVMsY0FBYztBQUN0QyxrQkFBSSxVQUFVLFdBQVc7QUFDeEIseUJBQVMsVUFBVSxJQUFJLFVBQVU7O0FBRWxDLHVCQUFTLGlCQUFpQixTQUFRLFNBQVMsS0FBSTtBQUM5QywrQkFBZTs7QUFHaEIsdUJBQVMsT0FBTztBQUNoQixvQkFBTSxTQUFTLFNBQVMsS0FBSyxNQUFLLFNBQVM7QUFFM0MsNEJBQWMsVUFBVSxDQUFDLENBQUUsV0FBVSxNQUFLLE1BQU0sUUFBUSxVQUFVO0FBRWxFLHVCQUFTLFFBQVE7QUFDakIscUJBQU87OztBQUtULGdCQUFLLEdBQUcsZUFBZSxXQUFpQjtBQUN2QyxnQkFBSSxTQUFTLE1BQUssVUFBVTtBQUU1QixnQkFBSSxRQUFRO0FBQ1gscUJBQU8sVUFBVSxPQUFPO0FBQ3hCLDZCQUFlOzs7QUFLakIsZ0JBQUssR0FBRyxZQUFZLFdBQWlCO0FBQ3BDLGdCQUFJLFNBQVMsTUFBSyxVQUFVO0FBRTVCLGdCQUFJLFFBQVE7QUFDWCw2QkFBZTs7O0FBTWpCLGdCQUFLLEtBQUssV0FBVSxrQkFBaUIsQ0FBRSxLQUFtQixXQUFzQjtBQUUvRSxnQkFBSSxPQUFPLFVBQVUsU0FBUyxhQUFhO0FBQzFDLHFCQUFPLFVBQVUsT0FBTztBQUN4QixvQkFBSyxXQUFXLE9BQU8sUUFBUTtBQUMvQixvQkFBSztBQUNMLDZCQUFlLEtBQUk7QUFDbkI7O0FBR0QsZ0NBQW9CLEtBQUssT0FBTSxLQUFLO0FBRXBDLDJCQUFlOzs7QUMxR0YsOEJBQXlCLGFBQXVCO0FBQzlELGdCQUFNLFFBQU87QUFFYixnQkFBTSxVQUFVLE9BQU8sT0FBTztZQUM3QixXQUFXO1lBQ1gsT0FBTztZQUNQLE1BQU8sVUFBbUI7QUFDekIscUJBQVEsZUFBYyxLQUFLLHFCQUFxQixLQUFLOzthQUVwRDtBQUVILGdCQUFLLEdBQUcsY0FBYSxNQUFJO0FBQ3hCLGdCQUFJLFNBQVMsT0FBTyxRQUFRLEtBQUs7QUFDakMsbUJBQU8saUJBQWlCLFNBQVMsU0FBTTtBQUV0QyxrQkFBSSxNQUFLO0FBQVc7QUFFcEIsb0JBQUs7QUFFTCxrQkFBSSxNQUFLLFNBQVMsU0FBUyxZQUFZLE1BQUssU0FBUyxrQkFBa0I7QUFDdEUsc0JBQUssUUFBUTs7QUFHZCxrQkFBSTtBQUNKLGtCQUFJOztBQUVMLGtCQUFLLFFBQVEsWUFBWTs7O0FDeEIzQixjQUFNLGNBQWMsQ0FBQyxlQUF1QixZQUFvQjtBQUFBLGNBQUE7QUFDL0QsVUFBQSx5QkFBQSxjQUFjLGVBQWQsUUFBQSxzQkFBMEIsYUFBYSxTQUFTLGNBQWM7O0FBRy9ELGNBQU0sZUFBZSxDQUFDLGVBQXVCLFlBQW9CO0FBQUEsY0FBQTtBQUNoRSxVQUFBLDBCQUFBLGNBQWMsZUFBVSxRQUF4Qix1QkFBMEIsYUFBYSxTQUFTOztBQUdqRCxjQUFNLFdBQVcsQ0FBQyxlQUFzQyxZQUFrQztBQUV6RixhQUFFO0FBQUEsZ0JBQUE7QUFDRCxzQkFBTyxZQUFHLFlBQUEsT0FBQSxTQUFBLFNBQVM7QUFFbkIsZ0JBQUksaUJBQWlCLFNBQVM7QUFDN0IscUJBQU87O21CQUdELFdBQVcsUUFBUTtBQUUzQixpQkFBTzs7QUFHTyw2QkFBeUI7QUFDdkMsY0FBSSxRQUFPO0FBQ1gsY0FBSSxNQUFLLFNBQVMsU0FBUztBQUFTO0FBRXBDLGNBQUksWUFBYSxNQUFLO0FBQ3RCLGNBQUksY0FBZSxNQUFLO0FBQ3hCLGNBQUksV0FBVztBQUNkLGNBQUk7QUFNTCxnQkFBSyxLQUFLLFNBQVEsa0JBQWlCLE1BQU07QUFFeEMsZ0JBQUksbUJBQW1CLE1BQUssU0FBUyxPQUFPO0FBRTVDLGtCQUFLLFNBQVMsT0FBTyxPQUFPLENBQUMsTUFBZ0IsV0FBOEI7QUFDMUUsb0JBQU0sT0FBTyxPQUFPLGlCQUFpQixLQUFLLE9BQU0sTUFBTTtBQUN0RCxzQkFBUSxNQUFLO2dCQUFDLGFBQVk7O0FBSTFCLG9CQUFNLFlBQWEsU0FBYztBQUNoQyxvQkFBSSxDQUFDO0FBQVcsaUNBQWU7QUFDL0Isb0JBQUk7O0FBR0wsb0JBQU0sWUFBYSxTQUFjO0FBQ2hDLDRCQUFZO0FBRVosMkJBQVcsTUFBTTtBQUNoQix1QkFBSyxVQUFVLElBQUk7bUJBQ2pCOztBQUlKLG9CQUFNLFdBQVksU0FBYTtBQUM5QixvQkFBSTtBQUNKLHFCQUFLLFVBQVUsSUFBSTtBQUNuQix5QkFBUyxNQUFLOztBQUdmLG9CQUFNLFlBQVksTUFBTTtBQUN2QixxQkFBSyxVQUFVLE9BQU87O0FBR3ZCLG9CQUFNLFdBQVcsQ0FBQyxZQUFvQixhQUErQjtBQUNwRSxvQkFBSSxhQUFhO0FBQVk7QUFFN0Isb0JBQUksU0FBUyxVQUFTLE9BQU87QUFDNUIsOEJBQVksWUFBVzt1QkFDbkI7QUFDSiwrQkFBYSxZQUFXOzs7QUFJMUIsb0JBQU0sVUFBVSxNQUFNO0FBQUEsb0JBQUE7QUFDckIseUJBQVMsaUJBQWlCLGlCQUFpQixRQUFRLFFBQUssR0FBRyxVQUFVLE9BQU87QUFDNUUsZ0JBQUEsY0FBQSxjQUFBLFFBQUEsV0FBVyxVQUFVLE9BQU87QUFDNUIsNEJBQVk7QUFFWixvQkFBSSxTQUFrQjtBQUN0QixzQkFBSyxRQUFRLGlCQUFrQixnQkFBZSxRQUFTLFFBQWM7QUFDcEUsc0JBQXdCLEdBQUksUUFBUSxPQUFPO0FBQzFDLHdCQUFJLFFBQTRCLEdBQUksUUFBUTtBQUM1Qyx3QkFBSSxPQUFPO0FBQ1YsNkJBQU8sS0FBSzs7OztBQUtmLHNCQUFLLFNBQVM7O0FBSWYsdUJBQVMsTUFBSyxhQUFhO0FBQzNCLHVCQUFTLE1BQUssYUFBYTtBQUMzQix1QkFBUyxNQUFLLGFBQWE7QUFDM0IsdUJBQVMsTUFBSyxZQUFZO0FBQzFCLHVCQUFTLE1BQUssYUFBYTtBQUMzQix1QkFBUyxNQUFLLFdBQVc7QUFFekIscUJBQU87OztBQU1ULGdCQUFLLEtBQUssV0FBVSxRQUFPLE1BQUk7QUFDOUIsdUJBQVc7QUFDWCxtQkFBTyxVQUFVLEtBQUs7O0FBR3ZCLGdCQUFLLEtBQUssV0FBVSxVQUFTLE1BQUk7QUFDaEMsdUJBQVc7QUFDWCxtQkFBTyxZQUFZLEtBQUs7OztBQ3ZIWCxpQ0FBeUIsYUFBdUI7QUFDOUQsZ0JBQU0sUUFBTztBQUViLGdCQUFNLFVBQVUsT0FBTyxPQUFPO1lBQzdCLE9BQWdCO1lBQ2hCLGFBQWdCO1lBQ2hCLGVBQWdCO1lBQ2hCLFlBQWdCO1lBQ2hCLFlBQWdCO1lBRWhCLE1BQU8sVUFBbUI7QUFDekIscUJBQ0MsaUJBQWlCLEtBQUssY0FBYyxtQkFDbEIsS0FBSyxnQkFBZ0Isb0JBQ25CLEtBQUssYUFBYSxPQUFPLEtBQUssUUFBUSxzQkFDekMsS0FBSyxhQUFhOzthQUtuQztBQUVILGdCQUFLLEdBQUcsY0FBYSxNQUFJO0FBQ3hCLGdCQUFJLFNBQVMsT0FBTyxRQUFRLEtBQUs7QUFFakMsZ0JBQUksYUFBYSxPQUFPLGNBQWMsTUFBSSxRQUFRO0FBQ2xELGdCQUFJLFlBQVk7QUFDZix5QkFBVyxpQkFBaUIsU0FBUyxTQUFNO0FBQzFDLCtCQUFlLEtBQUk7QUFDbkIsc0JBQUs7OztBQUlQLGtCQUFLLFNBQVMsYUFBYSxRQUFRLE1BQUssU0FBUzs7O0FDbENwQyxrQ0FBeUI7QUFDdkMsY0FBSSxRQUFPO0FBVVgsZ0JBQUssS0FBSyxXQUFVLFlBQVksYUFBbUI7QUFFbEQsZ0JBQUksTUFBSyxTQUFTLFNBQVMsWUFBWSxDQUFDLE1BQUssUUFBUSxTQUFTLE1BQUssZ0JBQWlCO0FBQ25GLHdCQUFVLE1BQUssTUFBTTttQkFDZjtBQUNOLHdCQUFVLEtBQUssSUFBSSxHQUFHLEtBQUssSUFBSSxNQUFLLE1BQU0sUUFBUTtBQUVsRCxrQkFBSSxXQUFXLE1BQUssWUFBWSxDQUFDLE1BQUssV0FBVztBQUVoRCxzQkFBSyxrQkFBa0IsUUFBUSxDQUFDLE9BQU0sTUFBTTtBQUMzQyxzQkFBSSxJQUFJLFNBQVM7QUFDaEIsMEJBQUssY0FBYyxzQkFBc0IsZUFBZTt5QkFDbEQ7QUFDTiwwQkFBSyxRQUFRLFlBQWE7Ozs7O0FBTTlCLGtCQUFLLFdBQVc7O0FBR2pCLGdCQUFLLEtBQUssV0FBVSxhQUFhLGVBQXFCO0FBRXJELGdCQUFJLENBQUMsTUFBSztBQUFZO0FBR3RCLGtCQUFNLGNBQWUsTUFBSyxjQUFjO0FBQ3hDLGdCQUFJLGFBQWE7QUFDaEIsb0JBQU0sTUFBTSxVQUFVO0FBQ3RCLG9CQUFLLFNBQVMsWUFBWSxJQUFJLE1BQU0sSUFBRztBQUN2QyxvQkFBSztBQUNMLDRCQUFjLGFBQTJCO21CQUdyQztBQUNKLG9CQUFLLFNBQVMsTUFBSyxXQUFXOzs7O0FDN0NsQixrQ0FBeUI7QUFDdkMsZ0JBQU0sUUFBTztBQUViLGdCQUFLLFNBQVMsYUFBYTtBQUUzQixnQkFBSyxLQUFLLFVBQVMsU0FBUSxNQUFJO0FBQzlCLGtCQUFLLGFBQWMsTUFBSztBQUV4Qix1QkFBWSxNQUFLLGVBQWU7QUFFL0Isa0JBQU0sTUFBTSxPQUFPO0FBQ3BCLGdCQUFJLE9BQU8sTUFBSztBQUNoQixrQkFBSyxTQUFTLGFBQWEsS0FBSyxNQUFLLFNBQVM7QUFHOUMsa0JBQU0sY0FBYyxPQUFPO0FBQzNCLHdCQUFZLGNBQWMsTUFBSyxTQUFTLGVBQWM7QUFDdEQsa0JBQUssUUFBUSxPQUFPOztBQUtyQixnQkFBSyxHQUFHLGNBQWEsTUFBSTtBQUd4QixrQkFBSyxjQUFjLGlCQUFpQixXQUFXLFNBQXFCO0FBRW5FLHNCQUFRLElBQUk7cUJBQ047QUFDSixzQkFBSSxNQUFLLFFBQVE7QUFDaEIsbUNBQWUsS0FBSTtBQUNuQiwwQkFBSzs7QUFFTix3QkFBSztBQUNOO3FCQUNLO0FBQ0osd0JBQUssV0FBVyxXQUFXO0FBQzVCOztBQUVELHFCQUFPLE1BQUssVUFBVSxLQUFLLE9BQUs7O0FBR2pDLGtCQUFLLEdBQUcsUUFBTyxNQUFJO0FBQ2xCLG9CQUFLLFdBQVcsV0FBVyxNQUFLLGFBQWEsS0FBSyxNQUFLOztBQUt4RCxrQkFBSyxHQUFHLGlCQUFnQixNQUFLO0FBQzVCLG9CQUFLLGNBQWM7O0FBSXBCLGtCQUFNLGNBQWMsTUFBSztBQUN6QixrQkFBSyxLQUFLLFdBQVUsVUFBVSxTQUFrQjtBQUMvQyxrQkFBSSxPQUFPLElBQUksaUJBQWlCLE1BQUs7QUFBZ0I7QUFDckQscUJBQU8sWUFBWSxLQUFLOztBQUd6QixxQkFBUyxNQUFLLGVBQWMsUUFBUSxNQUFNLE1BQUs7QUFHL0Msa0JBQUssS0FBSyxVQUFTLFNBQVEsTUFBSztBQUUvQixrQkFBSSxDQUFDLE1BQUs7QUFBUztBQUNuQixvQkFBSyxXQUFXLE1BQU07Z0JBQUMsZUFBZTs7Ozs7QUNyRTFCLGtDQUF5QjtBQUN2QyxjQUFJLFFBQVc7QUFFZixnQkFBSyxHQUFHLGNBQWEsTUFBSTtBQUd4QixnQkFBSSxhQUFnQixTQUFTLGNBQWM7QUFDM0MsZ0JBQUksVUFBYyxNQUFLO0FBQ3ZCLHVCQUFXLE1BQU0sVUFBVTtBQUUzQixrQkFBSyxRQUFRLFlBQVk7QUFHekIsZ0JBQUksa0JBQW9CLENBQUUsaUJBQWlCLFlBQVksY0FBYyxjQUFjO0FBRW5GLHVCQUFXLGNBQWMsaUJBQWlCO0FBRXpDLHlCQUFXLE1BQU0sY0FBYyxRQUFRLE1BQU07O0FBUTlDLGdCQUFJLFNBQVMsTUFBSTtBQUNoQix5QkFBVyxjQUFjLFFBQVE7QUFDakMsc0JBQVEsTUFBTSxRQUFTLFdBQVcsY0FBWTs7QUFHL0M7QUFDQSxrQkFBSyxHQUFHLCtCQUE4QjtBQUN0QyxxQkFBUyxTQUFRLFNBQVM7QUFDMUIscUJBQVMsU0FBUSxTQUFTO0FBQzFCLHFCQUFTLFNBQVEsUUFBUTtBQUN6QixxQkFBUyxTQUFRLFVBQVU7OztBQ3BDZCx1Q0FBeUI7QUFDdkMsY0FBSSxRQUFPO0FBQ1gsY0FBSSx1QkFBdUIsTUFBSztBQUVoQyxlQUFLLEtBQUssV0FBVSxtQkFBbUIsU0FBc0I7QUFFNUQsZ0JBQUksTUFBSyxZQUFZLFFBQVE7QUFDNUIscUJBQU8scUJBQXFCLEtBQUssT0FBTTs7QUFHeEMsbUJBQU87OztBQ1ZNLG1DQUF5QjtBQUN2QyxlQUFLLEtBQUssV0FBVSxpQkFBZ0IsTUFBTTs7QUFDMUMsZUFBSyxLQUFLLFdBQVUsYUFBWSxNQUFNOzs7QUNDeEIsb0NBQXlCO0FBQ3ZDLGNBQUksUUFBTztBQUVYLGNBQUksZUFBZSxNQUFLO0FBRXhCLGdCQUFLLEtBQUssV0FBVSxhQUFhLFNBQW9CO0FBQ3BELGdCQUFJLFFBQU8sUUFBUSxTQUFTO0FBRTVCLGdCQUFJLENBQUMsTUFBSyxVQUFVLENBQUUsS0FBSSxZQUFZLFlBQXNCLElBQUksWUFBWSxZQUFzQjtBQUNqRyxxQkFBTyxhQUFhLEtBQUssT0FBSzs7QUFHL0Isa0JBQUssY0FBYztBQUNuQix1QkFBYSxZQUFZLE1BQUssY0FBYTtBQUMzQyxxQkFBVyxVQUFVLE1BQUssY0FBYTtBQUV2QyxnQkFBSSxDQUFDLFVBQVU7QUFDZDs7QUFHRCxnQkFBSSxJQUFJLFlBQVksVUFBb0I7QUFDdkMseUJBQVcsU0FBUzttQkFDZDtBQUNOLHlCQUFXLFNBQVM7O0FBR3JCLGdCQUFJLENBQUMsVUFBVTtBQUNkOztBQUdELHNCQUFtQyxTQUFVLGlCQUFpQjtBQUM5RCxxQkFBWSxRQUFTLEtBQUssSUFBSSxRQUFRLFNBQVMsR0FBRztBQUVsRCxnQkFBSSxRQUFRO0FBQ1gsb0JBQUssZ0JBQWdCOzs7O0FDaENULCtCQUF5QixhQUF1QjtBQUU5RCxnQkFBTSxVQUFVLE9BQU8sT0FBTztZQUM1QixPQUFZO1lBQ1osT0FBWTtZQUNaLFdBQVk7WUFDWixRQUFZO2FBQ1Y7QUFJSixjQUFJLFFBQVM7QUFHYixjQUFJLENBQUMsUUFBUSxRQUFRO0FBQ3BCOztBQUdELGNBQUksT0FBTyx5Q0FBeUMsUUFBUSxZQUFZLDRCQUE0QixZQUFZLFFBQVEsU0FBUyxPQUFPLFFBQVEsUUFBUTtBQUV4SixnQkFBSyxLQUFLLFNBQVEsa0JBQWlCLE1BQU07QUFFeEMsZ0JBQUksbUJBQW1CLE1BQUssU0FBUyxPQUFPO0FBRTVDLGtCQUFLLFNBQVMsT0FBTyxPQUFPLENBQUMsTUFBZ0IsV0FBOEI7QUFFMUUsa0JBQUksT0FBTyxPQUFPLGlCQUFpQixLQUFLLE9BQU0sTUFBTTtBQUVwRCxrQkFBSSxlQUFlLE9BQU87QUFDMUIsbUJBQUssWUFBWTtBQUVqQix1QkFBUyxjQUFhLGFBQWEsU0FBUTtBQUMxQywrQkFBZSxLQUFJOztBQUdwQix1QkFBUyxjQUFhLFNBQVMsU0FBUTtBQUV0QyxvQkFBSSxNQUFLO0FBQVc7QUFHcEIsK0JBQWUsS0FBSTtBQUVuQixvQkFBSSxNQUFLO0FBQVc7QUFDcEIsb0JBQUksQ0FBQyxNQUFLLGFBQWEsQ0FBQyxPQUFNO0FBQXFCO0FBRW5ELHNCQUFLLFdBQVc7QUFDaEIsc0JBQUssZUFBZTtBQUNwQixzQkFBSzs7QUFHTixxQkFBTzs7OztBQ2xESyxzQ0FBeUIsYUFBNEI7QUFDbkUsZ0JBQU0sUUFBTztBQUViLGdCQUFNLFVBQVUsT0FBTyxPQUFPO1lBQzdCLE1BQU8sWUFBcUI7QUFDM0IscUJBQU8sT0FBTyxNQUFLLFNBQVM7O2FBRTVCO0FBRUYsZ0JBQUssR0FBRyxlQUFjLFNBQVMsT0FBYTtBQUMzQyxnQkFBSSxDQUFDLE1BQUssV0FBVztBQUNwQjs7QUFHRCxnQkFBSSxNQUFLLGNBQWMsTUFBTSxXQUFXLElBQUk7QUFDM0Msa0JBQUksU0FBUyxNQUFLLFFBQVE7QUFDMUIsa0JBQUksUUFBUTtBQUNYLHNCQUFLLGdCQUFnQixRQUFRLEtBQUssS0FBSyxPQUFNOzs7OztBQ25CbEMsa0NBQXlCO0FBQ3ZDLGdCQUFNLFFBQWE7QUFDbkIsZ0JBQU0sZUFBbUIsTUFBSztBQUM5QixnQkFBTSx5QkFBMEIsTUFBSztBQUNyQyxnQkFBTSxvQkFBdUIsTUFBSztBQUVsQyxjQUFJLGFBQWdDO0FBQ3BDLGNBQUk7QUFDSixjQUFJLGVBQW1CO0FBQ3ZCLGNBQUk7QUFDSixjQUFJLGlCQUE0QjtBQUVoQyxjQUFJLENBQUMsTUFBSyxTQUFTLGdCQUFnQjtBQUdsQyxrQkFBSyxTQUFTLGlCQUFpQixNQUFZO0FBRTFDLG9CQUFNLGlCQUFpQixpQkFBaUIsZUFBZ0Isa0JBQWlCLGVBQWUsaUJBQWlCO0FBQ3pHLGtCQUFJLGlCQUFpQixLQUFLO0FBQ3pCLHVCQUFPOztBQUdSLGtCQUFJLE1BQUssY0FBYztBQUN0QixvQkFBSSxhQUFhLE1BQUs7QUFDdEIsb0JBQUksU0FBUyxNQUFNLEtBQUssWUFBWSxRQUFRLE1BQUs7QUFDakQsb0JBQUksVUFBVSxXQUFXLFNBQU8sR0FBSTtBQUNuQyx5QkFBTzs7O0FBSVQscUJBQU87OztBQUtULGNBQUksQ0FBQyxNQUFLLFNBQVMsVUFBVTtBQUM1QixrQkFBTTs7QUFNUCxnQkFBSyxTQUFTLFlBQWMsQ0FBQztZQUFDLE9BQU07YUFBVTtZQUFDLE9BQU07O0FBSXJELGdCQUFNLGNBQWUsV0FBeUI7QUFFN0MsZ0JBQUksT0FBTyxNQUFLLFNBQVMsZUFBZSxZQUFZLGlCQUFpQixTQUFTLFVBQVUsTUFBSyxTQUFTLFlBQVk7QUFDakgscUJBQU87O0FBR1IsZ0JBQUssU0FBUyxjQUFlLFdBQVcsUUFBUTtBQUMvQyxxQkFBTzs7QUFHUixtQkFBTzs7QUFHUixnQkFBTSxjQUFjLENBQUMsUUFBa0IsVUFBeUI7QUFDL0QsZ0JBQUksTUFBSyxNQUFNLFFBQVEsVUFBVSxLQUFLLGVBQWUsUUFBUSxVQUFVLEdBQUc7QUFDekUscUJBQU87O0FBRVIsbUJBQU87O0FBS1IsZ0JBQUssYUFBYSxDQUFDLE9BQWEsYUFBc0I7QUFDckQsdUJBQVcsU0FBUzs7QUFJckIsZ0JBQUssU0FBVSxXQUFvQjtBQUVsQyxnQkFBSSxTQUFTLFlBQVk7QUFDeEIsb0JBQU0sV0FBVyxXQUFXO0FBQzVCLHlCQUFXLFNBQVM7QUFDcEIscUJBQU87O0FBS1Isa0JBQUs7QUFFTCxtQkFBTyxNQUFLLFNBQVMsU0FBUyxLQUFLLE9BQUs7O0FBSXpDLGdCQUFLLGtCQUFrQixNQUFVO0FBQ2hDLHlCQUFhOztBQUtkLGdCQUFLLEtBQUssV0FBVSxxQkFBb0IsTUFBSTtBQUUzQyxnQkFBSSxjQUFjO0FBQ2pCOztBQUdELG1CQUFPLHVCQUF1QixLQUFLOztBQUlwQyxnQkFBSyxLQUFLLFdBQVUsV0FBVyxXQUFlO0FBRzdDLGdCQUFJLENBQUUsVUFBUyxhQUFhO0FBQzNCLHFCQUFPLGFBQWEsS0FBSyxPQUFLOztBQUcvQixtQkFBTyxZQUFZOztBQUtwQixnQkFBSyxLQUFLLFdBQVUsZ0JBQWUsQ0FBRSxTQUFxQixjQUF3QjtBQUVqRixnQkFBSSxDQUFDLGNBQWM7QUFDbEIsb0JBQUssYUFBYTt1QkFDVCxlQUFlO0FBQ3hCLG9CQUFNLGVBQWUsUUFBUTtBQUM3QixrQkFBSSxpQkFBaUIsUUFBVztBQUMvQiw4QkFBYyxRQUFRLFFBQVMsYUFBYSxNQUFLLFNBQVM7OztBQUk1RCw4QkFBa0IsS0FBTSxPQUFNLFNBQVM7QUFFdkMsMkJBQWU7O0FBT2hCLGdCQUFLLEtBQUssU0FBUSxrQkFBaUIsTUFBSTtBQUV0QyxrQkFBTSxRQUFTLE1BQUs7QUFDcEIsZ0JBQUk7QUFFSixnQkFBSSxZQUFZLFFBQVE7QUFFdkIsdUJBQVMsTUFBSyxPQUFPLGdCQUFlO2dCQUFDOztBQUNyQyxrQkFBSSxRQUFRO0FBQ1gsdUJBQU8sYUFBYSxtQkFBa0I7QUFDdEMsZ0NBQWdCOzt1QkFHUCxTQUFTLGNBQWUsQ0FBQyxpQkFBaUIsY0FBYyxnQkFBZ0I7QUFDbEYsdUJBQVMsTUFBSyxPQUFPLG1CQUFrQjtnQkFBQzs7O0FBR3pDLGdCQUFJLFFBQVE7QUFDWCx5QkFBVyxRQUFPLE1BQUssU0FBUztBQUNoQywrQkFBaUIsT0FBUTs7O0FBTzNCLGdCQUFLLEdBQUcsY0FBYSxNQUFJO0FBQ3hCLDZCQUFpQixPQUFPLEtBQUssTUFBSztBQUNsQywrQkFBbUIsTUFBSztBQUd4QixrQkFBSyxTQUFTLFNBQVMsT0FBTyxPQUFPLElBQUk7Y0FDeEMsY0FBYSxNQUFNO0FBQ2xCLHVCQUFROztjQUVULGlCQUFnQixNQUFLO0FBQ3BCLHVCQUFROztlQUVSLE1BQUssU0FBUztBQUloQiw2QkFBaUIsaUJBQWlCLFVBQVMsTUFBSTtBQUU5QyxrQkFBSSxDQUFDLE1BQUssU0FBUyxlQUFlLEtBQUssUUFBTztBQUM3Qzs7QUFJRCxrQkFBSSxDQUFDLFlBQVksTUFBSyxZQUFZO0FBQ2pDOztBQUlELGtCQUFJO0FBQWU7QUFHbkIsNkJBQWU7QUFDZixvQkFBSyxLQUFLLEtBQUssT0FBSyxNQUFLOzs7O0FDck01QixtQkFBVSxPQUFPLG1CQUFtQjtBQUNwQyxtQkFBVSxPQUFPLG9CQUFvQjtBQUNyQyxtQkFBVSxPQUFPLGdCQUFnQjtBQUNqQyxtQkFBVSxPQUFPLGFBQWE7QUFDOUIsbUJBQVUsT0FBTyxtQkFBbUI7QUFDcEMsbUJBQVUsT0FBTyxrQkFBa0I7QUFDbkMsbUJBQVUsT0FBTyxrQkFBa0I7QUFDbkMsbUJBQVUsT0FBTyxrQkFBa0I7QUFDbkMsbUJBQVUsT0FBTyx1QkFBdUI7QUFDeEMsbUJBQVUsT0FBTyxtQkFBbUI7QUFDcEMsbUJBQVUsT0FBTyxvQkFBb0I7QUFDckMsbUJBQVUsT0FBTyxpQkFBaUI7QUFDbEMsbUJBQVUsT0FBTyx3QkFBd0I7QUFDekMsbUJBQVUsT0FBTyxrQkFBa0I7Ozs7Ozs7QUM5Qm5DO0FBQUE7QUFNQSxNQUFDLFVBQVUsU0FBUSxXQUFVO0FBQzNCO0FBR0EsUUFBQyxZQUFZO0FBQ1gsY0FBSSxXQUFXO0FBQ2YsY0FBSSxVQUFVLENBQUMsTUFBTSxPQUFPLFVBQVU7QUFDdEMsbUJBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxVQUFVLENBQUMsUUFBTyx1QkFBdUIsRUFBRSxHQUFHO0FBQ3hFLG9CQUFPLHdCQUNMLFFBQU8sUUFBUSxLQUFLO0FBQ3RCLG9CQUFPLHVCQUNMLFFBQU8sUUFBUSxLQUFLLDJCQUNwQixRQUFPLFFBQVEsS0FBSztBQUFBO0FBRXhCLGNBQUksQ0FBQyxRQUFPO0FBQ1Ysb0JBQU8sd0JBQXdCLFNBQVUsVUFBVSxTQUFTO0FBQzFELGtCQUFJLFdBQVcsSUFBSSxPQUFPO0FBQzFCLGtCQUFJLGFBQWEsS0FBSyxJQUFJLEdBQUcsS0FBTSxZQUFXO0FBQzlDLGtCQUFJLEtBQUssUUFBTyxXQUFXLFdBQVk7QUFDckMseUJBQVMsV0FBVztBQUFBLGlCQUNuQjtBQUNILHlCQUFXLFdBQVc7QUFDdEIscUJBQU87QUFBQTtBQUVYLGNBQUksQ0FBQyxRQUFPO0FBQ1Ysb0JBQU8sdUJBQXVCLFNBQVUsSUFBSTtBQUMxQywyQkFBYTtBQUFBO0FBQUE7QUFJbkIsWUFBSSxRQUNGLGlCQUNBLGFBQ0EsaUJBQ0EsU0FDQSxXQUFXLFNBQVUsTUFBTSxNQUFNLFNBQVM7QUFDeEMsY0FBSSxLQUFLO0FBQWtCLGlCQUFLLGlCQUFpQixNQUFNLFNBQVM7QUFBQSxtQkFDdkQsS0FBSztBQUFhLGlCQUFLLFlBQVksT0FBTyxNQUFNO0FBQUE7QUFDcEQsaUJBQUssT0FBTyxRQUFRO0FBQUEsV0FFM0IsVUFBVTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsY0FBYztBQUFBLFVBQ2QsV0FBVztBQUFBLFlBQ1QsR0FBRztBQUFBLFlBQ0gsT0FBTztBQUFBLFlBQ1AsT0FBTztBQUFBLFlBQ1AsT0FBTztBQUFBLFlBQ1AsT0FBTztBQUFBO0FBQUEsVUFFVCxZQUFZO0FBQUEsVUFDWixhQUFhO0FBQUEsVUFDYixXQUFXO0FBQUEsV0FFYixVQUFVLFdBQVk7QUFDcEIsaUJBQU8sUUFBUSxRQUFPO0FBQ3RCLGlCQUFPLFNBQVMsUUFBUSxlQUFlO0FBRXZDLGNBQUksTUFBTSxPQUFPLFdBQVc7QUFDNUIsY0FBSSxhQUFhLFFBQVE7QUFDekIsY0FBSSxjQUFjLFFBQVE7QUFFMUIsY0FBSSxlQUFlLElBQUkscUJBQXFCLEdBQUcsR0FBRyxPQUFPLE9BQU87QUFDaEUsbUJBQVMsUUFBUSxRQUFRO0FBQ3ZCLHlCQUFhLGFBQWEsTUFBTSxRQUFRLFVBQVU7QUFDcEQsY0FBSSxZQUFZLFFBQVE7QUFDeEIsY0FBSTtBQUNKLGNBQUksT0FBTyxHQUFHLFFBQVEsZUFBZTtBQUNyQyxjQUFJLE9BQ0YsS0FBSyxLQUFLLGtCQUFrQixPQUFPLFFBQ25DLFFBQVEsZUFBZTtBQUV6QixjQUFJLGNBQWM7QUFDbEIsY0FBSTtBQUFBLFdBRU4sZUFBZSxXQUFZO0FBQ3pCLG1CQUFTLFVBQVMsY0FBYztBQUNoQyxjQUFJLFFBQVEsT0FBTztBQUNuQixnQkFBTSxXQUFXO0FBQ2pCLGdCQUFNLE1BQU0sTUFBTSxPQUFPLE1BQU0sUUFBUSxNQUFNLFNBQVMsTUFBTSxVQUFVO0FBQ3RFLGdCQUFNLFNBQVM7QUFDZixnQkFBTSxVQUFVO0FBQ2hCLGNBQUksUUFBUTtBQUFXLG1CQUFPLFVBQVUsSUFBSSxRQUFRO0FBQ3BELG9CQUFTLEtBQUssWUFBWTtBQUMxQixtQkFBUyxTQUFRLFVBQVU7QUFBQSxXQUU3QixVQUFTO0FBQUEsVUFDUCxRQUFRLFNBQVUsTUFBTTtBQUN0QixxQkFBUyxPQUFPO0FBQ2Qsa0JBQUksUUFBUSxlQUFlO0FBQU0sd0JBQVEsT0FBTyxLQUFLO0FBQUE7QUFBQSxVQUV6RCxNQUFNLFdBQVk7QUFDaEIsZ0JBQUk7QUFBUztBQUNiLHNCQUFVO0FBQ1YsZ0JBQUksZ0JBQWdCO0FBQU0sc0JBQU8scUJBQXFCO0FBQ3RELGdCQUFJLENBQUM7QUFBUTtBQUNiLG1CQUFPLE1BQU0sVUFBVTtBQUN2QixtQkFBTyxNQUFNLFVBQVU7QUFDdkIsb0JBQU8sU0FBUztBQUNoQixnQkFBSSxRQUFRLFNBQVM7QUFDbkIsY0FBQyxpQkFBZ0I7QUFDZixrQ0FBa0IsUUFBTyxzQkFBc0I7QUFDL0Msd0JBQU8sU0FDTCxNQUFNLE9BQU8sS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLGtCQUFrQjtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBSzlELFVBQVUsU0FBVSxJQUFJO0FBQ3RCLGdCQUFJLE9BQU8sT0FBTztBQUFhLHFCQUFPO0FBQ3RDLGdCQUFJLE9BQU8sT0FBTyxVQUFVO0FBQzFCLG1CQUNHLElBQUcsUUFBUSxRQUFRLEtBQUssR0FBRyxRQUFRLFFBQVEsSUFDeEMsa0JBQ0EsS0FBSyxXQUFXO0FBQUE7QUFFeEIsOEJBQWtCLEtBQUssSUFBSSxJQUFJO0FBQy9CO0FBQ0EsbUJBQU87QUFBQTtBQUFBLFVBRVQsTUFBTSxXQUFZO0FBQ2hCLGdCQUFJLENBQUM7QUFBUztBQUNkLHNCQUFVO0FBQ1YsZ0JBQUksbUJBQW1CLE1BQU07QUFDM0Isc0JBQU8scUJBQXFCO0FBQzVCLGdDQUFrQjtBQUFBO0FBRXBCLFlBQUMsaUJBQWdCO0FBQ2Ysa0JBQUksUUFBTyxTQUFTLFVBQVUsR0FBRztBQUMvQix1QkFBTyxNQUFNLFdBQVc7QUFDeEIsb0JBQUksT0FBTyxNQUFNLFdBQVcsTUFBTTtBQUNoQyx5QkFBTyxNQUFNLFVBQVU7QUFDdkIsZ0NBQWM7QUFDZDtBQUFBO0FBQUE7QUFHSiw0QkFBYyxRQUFPLHNCQUFzQjtBQUFBO0FBQUE7QUFBQTtBQUtuRCxZQUFJLE9BQU8sV0FBVyxZQUFZLE9BQU8sT0FBTyxZQUFZLFVBQVU7QUFDcEUsaUJBQU8sVUFBVTtBQUFBLG1CQUNSLE9BQU8sV0FBVyxjQUFjLE9BQU8sS0FBSztBQUNyRCxpQkFBTyxXQUFZO0FBQ2pCLG1CQUFPO0FBQUE7QUFBQSxlQUVKO0FBQ0wsZUFBSyxTQUFTO0FBQUE7QUFBQSxTQUVoQixLQUFLLFNBQU0sUUFBUTtBQUFBO0FBQUE7OztBQzVKckI7QUFBQTtBQU1BLE1BQUMsVUFBVSxTQUFRLFNBQVM7QUFDNUIsZUFBTyxZQUFZLFlBQVksT0FBTyxXQUFXLGNBQWMsT0FBTyxVQUFVLFlBQ2hGLE9BQU8sV0FBVyxjQUFjLE9BQU8sTUFBTSxPQUFPLFdBQ25ELFdBQVMsT0FBTyxlQUFlLGNBQWMsYUFBYSxXQUFVLE1BQU0sUUFBTyxRQUFRO0FBQUEsU0FDdkYsU0FBTyxXQUFZO0FBQUU7QUFFeEIseUJBQWdCO0FBQUE7QUFDaEIsY0FBTSxNQUFPLFdBQVc7QUFDdEIsY0FBSSxLQUFLO0FBQ1QsaUJBQU8sV0FBVztBQUNoQixtQkFBTztBQUFBO0FBQUE7QUFHWCwrQkFBdUIsT0FBTztBQUM1QixpQkFBTyxVQUFVLFFBQVEsT0FBTyxVQUFVO0FBQUE7QUFFNUMseUJBQWlCLE9BQU87QUFDdEIsY0FBSSxNQUFNLFdBQVcsTUFBTSxRQUFRLFFBQVE7QUFDekMsbUJBQU87QUFBQTtBQUVULGdCQUFNLE9BQU8sT0FBTyxVQUFVLFNBQVMsS0FBSztBQUM1QyxjQUFJLEtBQUssTUFBTSxHQUFHLE9BQU8sYUFBYSxLQUFLLE1BQU0sUUFBUSxVQUFVO0FBQ2pFLG1CQUFPO0FBQUE7QUFFVCxpQkFBTztBQUFBO0FBRVQsMkJBQWtCLE9BQU87QUFDdkIsaUJBQU8sVUFBVSxRQUFRLE9BQU8sVUFBVSxTQUFTLEtBQUssV0FBVztBQUFBO0FBRXJFLGNBQU0saUJBQWlCLENBQUMsVUFBVyxRQUFPLFVBQVUsWUFBWSxpQkFBaUIsV0FBVyxTQUFTLENBQUM7QUFDdEcsaUNBQXlCLE9BQU8sY0FBYztBQUM1QyxpQkFBTyxlQUFlLFNBQVMsUUFBUTtBQUFBO0FBRXpDLGdDQUF3QixPQUFPLGNBQWM7QUFDM0MsaUJBQU8sT0FBTyxVQUFVLGNBQWMsZUFBZTtBQUFBO0FBRXZELGNBQU0sZUFBZSxDQUFDLE9BQU8sY0FDM0IsT0FBTyxVQUFVLFlBQVksTUFBTSxTQUFTLE9BQzFDLFdBQVcsU0FBUyxNQUNsQixRQUFRO0FBQ2QsY0FBTSxjQUFjLENBQUMsT0FBTyxjQUMxQixPQUFPLFVBQVUsWUFBWSxNQUFNLFNBQVMsT0FDMUMsV0FBVyxTQUFTLE1BQU0sWUFDeEIsQ0FBQztBQUNQLDBCQUFrQixJQUFJLE1BQU0sU0FBUztBQUNuQyxjQUFJLE1BQU0sT0FBTyxHQUFHLFNBQVMsWUFBWTtBQUN2QyxtQkFBTyxHQUFHLE1BQU0sU0FBUztBQUFBO0FBQUE7QUFHN0Isc0JBQWMsVUFBVSxJQUFJLFNBQVMsU0FBUztBQUM1QyxjQUFJLEdBQUcsS0FBSztBQUNaLGNBQUksUUFBUSxXQUFXO0FBQ3JCLGtCQUFNLFNBQVM7QUFDZixnQkFBSSxTQUFTO0FBQ1gsbUJBQUssSUFBSSxNQUFNLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDN0IsbUJBQUcsS0FBSyxTQUFTLFNBQVMsSUFBSTtBQUFBO0FBQUEsbUJBRTNCO0FBQ0wsbUJBQUssSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLO0FBQ3hCLG1CQUFHLEtBQUssU0FBUyxTQUFTLElBQUk7QUFBQTtBQUFBO0FBQUEscUJBR3pCLFVBQVMsV0FBVztBQUM3QixtQkFBTyxPQUFPLEtBQUs7QUFDbkIsa0JBQU0sS0FBSztBQUNYLGlCQUFLLElBQUksR0FBRyxJQUFJLEtBQUssS0FBSztBQUN4QixpQkFBRyxLQUFLLFNBQVMsU0FBUyxLQUFLLEtBQUssS0FBSztBQUFBO0FBQUE7QUFBQTtBQUkvQyxnQ0FBd0IsSUFBSSxJQUFJO0FBQzlCLGNBQUksR0FBRyxNQUFNLElBQUk7QUFDakIsY0FBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsV0FBVyxHQUFHLFFBQVE7QUFDekMsbUJBQU87QUFBQTtBQUVULGVBQUssSUFBSSxHQUFHLE9BQU8sR0FBRyxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDM0MsaUJBQUssR0FBRztBQUNSLGlCQUFLLEdBQUc7QUFDUixnQkFBSSxHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLFVBQVUsR0FBRyxPQUFPO0FBQ2hFLHFCQUFPO0FBQUE7QUFBQTtBQUdYLGlCQUFPO0FBQUE7QUFFVCx5QkFBaUIsUUFBUTtBQUN2QixjQUFJLFFBQVEsU0FBUztBQUNuQixtQkFBTyxPQUFPLElBQUk7QUFBQTtBQUVwQixjQUFJLFVBQVMsU0FBUztBQUNwQixrQkFBTSxTQUFTLE9BQU8sT0FBTztBQUM3QixrQkFBTSxPQUFPLE9BQU8sS0FBSztBQUN6QixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsZ0JBQUksSUFBSTtBQUNSLG1CQUFPLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDcEIscUJBQU8sS0FBSyxNQUFNLFFBQVEsT0FBTyxLQUFLO0FBQUE7QUFFeEMsbUJBQU87QUFBQTtBQUVULGlCQUFPO0FBQUE7QUFFVCw0QkFBb0IsS0FBSztBQUN2QixpQkFBTyxDQUFDLGFBQWEsYUFBYSxlQUFlLFFBQVEsU0FBUztBQUFBO0FBRXBFLHlCQUFpQixLQUFLLFFBQVEsUUFBUSxTQUFTO0FBQzdDLGNBQUksQ0FBQyxXQUFXLE1BQU07QUFDcEI7QUFBQTtBQUVGLGdCQUFNLE9BQU8sT0FBTztBQUNwQixnQkFBTSxPQUFPLE9BQU87QUFDcEIsY0FBSSxVQUFTLFNBQVMsVUFBUyxPQUFPO0FBQ3BDLGtCQUFNLE1BQU0sTUFBTTtBQUFBLGlCQUNiO0FBQ0wsbUJBQU8sT0FBTyxRQUFRO0FBQUE7QUFBQTtBQUcxQix1QkFBZSxRQUFRLFFBQVEsU0FBUztBQUN0QyxnQkFBTSxVQUFVLFFBQVEsVUFBVSxTQUFTLENBQUM7QUFDNUMsZ0JBQU0sT0FBTyxRQUFRO0FBQ3JCLGNBQUksQ0FBQyxVQUFTLFNBQVM7QUFDckIsbUJBQU87QUFBQTtBQUVULG9CQUFVLFdBQVc7QUFDckIsZ0JBQU0sU0FBUyxRQUFRLFVBQVU7QUFDakMsbUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDN0IscUJBQVMsUUFBUTtBQUNqQixnQkFBSSxDQUFDLFVBQVMsU0FBUztBQUNyQjtBQUFBO0FBRUYsa0JBQU0sT0FBTyxPQUFPLEtBQUs7QUFDekIscUJBQVMsSUFBSSxHQUFHLE9BQU8sS0FBSyxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDakQscUJBQU8sS0FBSyxJQUFJLFFBQVEsUUFBUTtBQUFBO0FBQUE7QUFHcEMsaUJBQU87QUFBQTtBQUVULHlCQUFpQixRQUFRLFFBQVE7QUFDL0IsaUJBQU8sTUFBTSxRQUFRLFFBQVEsRUFBQyxRQUFRO0FBQUE7QUFFeEMsMkJBQW1CLEtBQUssUUFBUSxRQUFRO0FBQ3RDLGNBQUksQ0FBQyxXQUFXLE1BQU07QUFDcEI7QUFBQTtBQUVGLGdCQUFNLE9BQU8sT0FBTztBQUNwQixnQkFBTSxPQUFPLE9BQU87QUFDcEIsY0FBSSxVQUFTLFNBQVMsVUFBUyxPQUFPO0FBQ3BDLG9CQUFRLE1BQU07QUFBQSxxQkFDTCxDQUFDLE9BQU8sVUFBVSxlQUFlLEtBQUssUUFBUSxNQUFNO0FBQzdELG1CQUFPLE9BQU8sUUFBUTtBQUFBO0FBQUE7QUFHMUIsNkJBQXFCLE9BQU8sT0FBTyxVQUFVLFNBQVM7QUFDcEQsY0FBSSxVQUFVLFFBQVc7QUFDdkIsb0JBQVEsS0FBSyxRQUFRLFFBQVEsV0FDOUIsa0NBQWtDLFVBQVU7QUFBQTtBQUFBO0FBRy9DLGNBQU0sZUFBZTtBQUFBLFVBQ25CLElBQUksT0FBSztBQUFBLFVBQ1QsR0FBRyxPQUFLLEVBQUU7QUFBQSxVQUNWLEdBQUcsT0FBSyxFQUFFO0FBQUE7QUFFWixrQ0FBMEIsS0FBSyxLQUFLO0FBQ2xDLGdCQUFNLFdBQVcsYUFBYSxRQUFTLGNBQWEsT0FBTyxnQkFBZ0I7QUFDM0UsaUJBQU8sU0FBUztBQUFBO0FBRWxCLGlDQUF5QixLQUFLO0FBQzVCLGdCQUFNLE9BQU8sVUFBVTtBQUN2QixpQkFBTyxTQUFPO0FBQ1osdUJBQVcsS0FBSyxNQUFNO0FBQ3BCLGtCQUFJLE1BQU0sSUFBSTtBQUNaO0FBQUE7QUFFRixvQkFBTSxPQUFPLElBQUk7QUFBQTtBQUVuQixtQkFBTztBQUFBO0FBQUE7QUFHWCwyQkFBbUIsS0FBSztBQUN0QixnQkFBTSxRQUFRLElBQUksTUFBTTtBQUN4QixnQkFBTSxPQUFPO0FBQ2IsY0FBSSxNQUFNO0FBQ1YscUJBQVcsUUFBUSxPQUFPO0FBQ3hCLG1CQUFPO0FBQ1AsZ0JBQUksSUFBSSxTQUFTLE9BQU87QUFDdEIsb0JBQU0sSUFBSSxNQUFNLEdBQUcsTUFBTTtBQUFBLG1CQUNwQjtBQUNMLG1CQUFLLEtBQUs7QUFDVixvQkFBTTtBQUFBO0FBQUE7QUFHVixpQkFBTztBQUFBO0FBRVQsNkJBQXFCLEtBQUs7QUFDeEIsaUJBQU8sSUFBSSxPQUFPLEdBQUcsZ0JBQWdCLElBQUksTUFBTTtBQUFBO0FBRWpELGNBQU0sVUFBVSxDQUFDLFVBQVUsT0FBTyxVQUFVO0FBQzVDLGNBQU0sY0FBYSxDQUFDLFVBQVUsT0FBTyxVQUFVO0FBQy9DLGNBQU0sWUFBWSxDQUFDLEdBQUcsTUFBTTtBQUMxQixjQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU07QUFDckIsbUJBQU87QUFBQTtBQUVULHFCQUFXLFFBQVEsR0FBRztBQUNwQixnQkFBSSxDQUFDLEVBQUUsSUFBSSxPQUFPO0FBQ2hCLHFCQUFPO0FBQUE7QUFBQTtBQUdYLGlCQUFPO0FBQUE7QUFFVCwrQkFBdUIsR0FBRztBQUN4QixpQkFBTyxFQUFFLFNBQVMsYUFBYSxFQUFFLFNBQVMsV0FBVyxFQUFFLFNBQVM7QUFBQTtBQUdsRSxjQUFNLEtBQUssS0FBSztBQUNoQixjQUFNLE1BQU0sSUFBSTtBQUNoQixjQUFNLFFBQVEsTUFBTTtBQUNwQixjQUFNLFdBQVcsT0FBTztBQUN4QixjQUFNLGNBQWMsS0FBSztBQUN6QixjQUFNLFVBQVUsS0FBSztBQUNyQixjQUFNLGFBQWEsS0FBSztBQUN4QixjQUFNLGdCQUFnQixLQUFLLElBQUk7QUFDL0IsY0FBTSxRQUFRLEtBQUs7QUFDbkIsY0FBTSxPQUFPLEtBQUs7QUFDbEIseUJBQWlCLFFBQU87QUFDdEIsZ0JBQU0sZUFBZSxLQUFLLE1BQU07QUFDaEMsbUJBQVEsYUFBYSxRQUFPLGNBQWMsU0FBUSxPQUFRLGVBQWU7QUFDekUsZ0JBQU0sWUFBWSxLQUFLLElBQUksSUFBSSxLQUFLLE1BQU0sTUFBTTtBQUNoRCxnQkFBTSxXQUFXLFNBQVE7QUFDekIsZ0JBQU0sZUFBZSxZQUFZLElBQUksSUFBSSxZQUFZLElBQUksSUFBSSxZQUFZLElBQUksSUFBSTtBQUNqRixpQkFBTyxlQUFlO0FBQUE7QUFFeEIsNEJBQW9CLE9BQU87QUFDekIsZ0JBQU0sU0FBUztBQUNmLGdCQUFNLE9BQU8sS0FBSyxLQUFLO0FBQ3ZCLGNBQUk7QUFDSixlQUFLLElBQUksR0FBRyxJQUFJLE1BQU0sS0FBSztBQUN6QixnQkFBSSxRQUFRLE1BQU0sR0FBRztBQUNuQixxQkFBTyxLQUFLO0FBQ1oscUJBQU8sS0FBSyxRQUFRO0FBQUE7QUFBQTtBQUd4QixjQUFJLFNBQVUsUUFBTyxJQUFJO0FBQ3ZCLG1CQUFPLEtBQUs7QUFBQTtBQUVkLGlCQUFPLEtBQUssQ0FBQyxHQUFHLE1BQU0sSUFBSSxHQUFHO0FBQzdCLGlCQUFPO0FBQUE7QUFFVCwwQkFBa0IsR0FBRztBQUNuQixpQkFBTyxDQUFDLE1BQU0sV0FBVyxPQUFPLFNBQVM7QUFBQTtBQUUzQyw4QkFBc0IsR0FBRyxHQUFHLFNBQVM7QUFDbkMsaUJBQU8sS0FBSyxJQUFJLElBQUksS0FBSztBQUFBO0FBRTNCLDZCQUFxQixHQUFHLFNBQVM7QUFDL0IsZ0JBQU0sVUFBVSxLQUFLLE1BQU07QUFDM0IsaUJBQVMsVUFBVSxXQUFZLEtBQVEsVUFBVSxXQUFZO0FBQUE7QUFFL0Qsb0NBQTRCLE9BQU8sUUFBUSxVQUFVO0FBQ25ELGNBQUksR0FBRyxNQUFNO0FBQ2IsZUFBSyxJQUFJLEdBQUcsT0FBTyxNQUFNLFFBQVEsSUFBSSxNQUFNLEtBQUs7QUFDOUMsb0JBQVEsTUFBTSxHQUFHO0FBQ2pCLGdCQUFJLENBQUMsTUFBTSxRQUFRO0FBQ2pCLHFCQUFPLE1BQU0sS0FBSyxJQUFJLE9BQU8sS0FBSztBQUNsQyxxQkFBTyxNQUFNLEtBQUssSUFBSSxPQUFPLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFJeEMsMkJBQW1CLFNBQVM7QUFDMUIsaUJBQU8sVUFBVyxNQUFLO0FBQUE7QUFFekIsMkJBQW1CLFNBQVM7QUFDMUIsaUJBQU8sVUFBVyxPQUFNO0FBQUE7QUFFMUIsZ0NBQXdCLEdBQUc7QUFDekIsY0FBSSxDQUFDLGVBQWUsSUFBSTtBQUN0QjtBQUFBO0FBRUYsY0FBSSxJQUFJO0FBQ1IsY0FBSSxJQUFJO0FBQ1IsaUJBQU8sS0FBSyxNQUFNLElBQUksS0FBSyxNQUFNLEdBQUc7QUFDbEMsaUJBQUs7QUFDTDtBQUFBO0FBRUYsaUJBQU87QUFBQTtBQUVULG1DQUEyQixhQUFhLFlBQVk7QUFDbEQsZ0JBQU0sc0JBQXNCLFdBQVcsSUFBSSxZQUFZO0FBQ3ZELGdCQUFNLHNCQUFzQixXQUFXLElBQUksWUFBWTtBQUN2RCxnQkFBTSwyQkFBMkIsS0FBSyxLQUFLLHNCQUFzQixzQkFBc0Isc0JBQXNCO0FBQzdHLGNBQUksUUFBUSxLQUFLLE1BQU0scUJBQXFCO0FBQzVDLGNBQUksUUFBUyxPQUFPLElBQUs7QUFDdkIscUJBQVM7QUFBQTtBQUVYLGlCQUFPO0FBQUEsWUFDTDtBQUFBLFlBQ0EsVUFBVTtBQUFBO0FBQUE7QUFHZCx1Q0FBK0IsS0FBSyxLQUFLO0FBQ3ZDLGlCQUFPLEtBQUssS0FBSyxLQUFLLElBQUksSUFBSSxJQUFJLElBQUksR0FBRyxLQUFLLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSSxHQUFHO0FBQUE7QUFFeEUsNEJBQW9CLEdBQUcsR0FBRztBQUN4QixpQkFBUSxLQUFJLElBQUksU0FBUyxNQUFNO0FBQUE7QUFFakMsaUNBQXlCLEdBQUc7QUFDMUIsaUJBQVEsS0FBSSxNQUFNLE9BQU87QUFBQTtBQUUzQiwrQkFBdUIsT0FBTyxPQUFPLEtBQUssdUJBQXVCO0FBQy9ELGdCQUFNLElBQUksZ0JBQWdCO0FBQzFCLGdCQUFNLElBQUksZ0JBQWdCO0FBQzFCLGdCQUFNLElBQUksZ0JBQWdCO0FBQzFCLGdCQUFNLGVBQWUsZ0JBQWdCLElBQUk7QUFDekMsZ0JBQU0sYUFBYSxnQkFBZ0IsSUFBSTtBQUN2QyxnQkFBTSxlQUFlLGdCQUFnQixJQUFJO0FBQ3pDLGdCQUFNLGFBQWEsZ0JBQWdCLElBQUk7QUFDdkMsaUJBQU8sTUFBTSxLQUFLLE1BQU0sS0FBTSx5QkFBeUIsTUFBTSxLQUN2RCxlQUFlLGNBQWMsZUFBZTtBQUFBO0FBRXBELDZCQUFxQixPQUFPLEtBQUssS0FBSztBQUNwQyxpQkFBTyxLQUFLLElBQUksS0FBSyxLQUFLLElBQUksS0FBSztBQUFBO0FBRXJDLDZCQUFxQixPQUFPO0FBQzFCLGlCQUFPLFlBQVksT0FBTyxRQUFRO0FBQUE7QUFFcEMsNEJBQW9CLE9BQU8sT0FBTyxLQUFLLFVBQVUsTUFBTTtBQUNyRCxpQkFBTyxTQUFTLEtBQUssSUFBSSxPQUFPLE9BQU8sV0FBVyxTQUFTLEtBQUssSUFBSSxPQUFPLE9BQU87QUFBQTtBQUdwRix5QkFBaUIsT0FBTyxPQUFPLEtBQUs7QUFDbEMsZ0JBQU0sT0FBUSxFQUFDLFdBQVUsTUFBTSxVQUFTO0FBQ3hDLGNBQUksS0FBSyxNQUFNLFNBQVM7QUFDeEIsY0FBSSxLQUFLO0FBQ1QsY0FBSTtBQUNKLGlCQUFPLEtBQUssS0FBSyxHQUFHO0FBQ2xCLGtCQUFPLEtBQUssTUFBTztBQUNuQixnQkFBSSxJQUFJLE1BQU07QUFDWixtQkFBSztBQUFBLG1CQUNBO0FBQ0wsbUJBQUs7QUFBQTtBQUFBO0FBR1QsaUJBQU8sRUFBQyxJQUFJO0FBQUE7QUFFZCxjQUFNLGVBQWUsQ0FBQyxPQUFPLEtBQUssT0FBTyxTQUN2QyxRQUFRLE9BQU8sT0FBTyxPQUNsQixZQUFTLE1BQU0sUUFBTyxRQUFRLFFBQzlCLFlBQVMsTUFBTSxRQUFPLE9BQU87QUFDbkMsY0FBTSxnQkFBZ0IsQ0FBQyxPQUFPLEtBQUssVUFDakMsUUFBUSxPQUFPLE9BQU8sWUFBUyxNQUFNLFFBQU8sUUFBUTtBQUN0RCxnQ0FBd0IsUUFBUSxLQUFLLEtBQUs7QUFDeEMsY0FBSSxRQUFRO0FBQ1osY0FBSSxNQUFNLE9BQU87QUFDakIsaUJBQU8sUUFBUSxPQUFPLE9BQU8sU0FBUyxLQUFLO0FBQ3pDO0FBQUE7QUFFRixpQkFBTyxNQUFNLFNBQVMsT0FBTyxNQUFNLEtBQUssS0FBSztBQUMzQztBQUFBO0FBRUYsaUJBQU8sUUFBUSxLQUFLLE1BQU0sT0FBTyxTQUM3QixPQUFPLE1BQU0sT0FBTyxPQUNwQjtBQUFBO0FBRU4sY0FBTSxjQUFjLENBQUMsUUFBUSxPQUFPLFNBQVMsVUFBVTtBQUN2RCxtQ0FBMkIsT0FBTyxVQUFVO0FBQzFDLGNBQUksTUFBTSxVQUFVO0FBQ2xCLGtCQUFNLFNBQVMsVUFBVSxLQUFLO0FBQzlCO0FBQUE7QUFFRixpQkFBTyxlQUFlLE9BQU8sWUFBWTtBQUFBLFlBQ3ZDLGNBQWM7QUFBQSxZQUNkLFlBQVk7QUFBQSxZQUNaLE9BQU87QUFBQSxjQUNMLFdBQVcsQ0FBQztBQUFBO0FBQUE7QUFHaEIsc0JBQVksUUFBUSxDQUFDLFFBQVE7QUFDM0Isa0JBQU0sU0FBUyxZQUFZLFlBQVk7QUFDdkMsa0JBQU0sT0FBTyxNQUFNO0FBQ25CLG1CQUFPLGVBQWUsT0FBTyxLQUFLO0FBQUEsY0FDaEMsY0FBYztBQUFBLGNBQ2QsWUFBWTtBQUFBLGNBQ1osU0FBUyxNQUFNO0FBQ2Isc0JBQU0sTUFBTSxLQUFLLE1BQU0sTUFBTTtBQUM3QixzQkFBTSxTQUFTLFVBQVUsUUFBUSxDQUFDLFdBQVc7QUFDM0Msc0JBQUksT0FBTyxPQUFPLFlBQVksWUFBWTtBQUN4QywyQkFBTyxRQUFRLEdBQUc7QUFBQTtBQUFBO0FBR3RCLHVCQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLZixxQ0FBNkIsT0FBTyxVQUFVO0FBQzVDLGdCQUFNLE9BQU8sTUFBTTtBQUNuQixjQUFJLENBQUMsTUFBTTtBQUNUO0FBQUE7QUFFRixnQkFBTSxZQUFZLEtBQUs7QUFDdkIsZ0JBQU0sU0FBUSxVQUFVLFFBQVE7QUFDaEMsY0FBSSxXQUFVLElBQUk7QUFDaEIsc0JBQVUsT0FBTyxRQUFPO0FBQUE7QUFFMUIsY0FBSSxVQUFVLFNBQVMsR0FBRztBQUN4QjtBQUFBO0FBRUYsc0JBQVksUUFBUSxDQUFDLFFBQVE7QUFDM0IsbUJBQU8sTUFBTTtBQUFBO0FBRWYsaUJBQU8sTUFBTTtBQUFBO0FBRWYsOEJBQXNCLE9BQU87QUFDM0IsZ0JBQU0sT0FBTSxvQkFBSTtBQUNoQixjQUFJLEdBQUc7QUFDUCxlQUFLLElBQUksR0FBRyxPQUFPLE1BQU0sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQzlDLGlCQUFJLElBQUksTUFBTTtBQUFBO0FBRWhCLGNBQUksS0FBSSxTQUFTLE1BQU07QUFDckIsbUJBQU87QUFBQTtBQUVULGlCQUFPLE1BQU0sS0FBSztBQUFBO0FBR3BCLDRCQUFvQixXQUFXLFdBQVcsWUFBWTtBQUNwRCxpQkFBTyxZQUFZLE1BQU0sWUFBWSxRQUFRO0FBQUE7QUFFL0MsY0FBTSxtQkFBb0IsV0FBVztBQUNuQyxjQUFJLE9BQU8sV0FBVyxhQUFhO0FBQ2pDLG1CQUFPLFNBQVMsV0FBVTtBQUN4QixxQkFBTztBQUFBO0FBQUE7QUFHWCxpQkFBTyxPQUFPO0FBQUE7QUFFaEIsMkJBQW1CLElBQUksU0FBUyxVQUFVO0FBQ3hDLGdCQUFNLGFBQWEsWUFBYSxFQUFDLFVBQVMsTUFBTSxVQUFVLE1BQU0sS0FBSztBQUNyRSxjQUFJLFVBQVU7QUFDZCxjQUFJLE9BQU87QUFDWCxpQkFBTyxZQUFZLE1BQU07QUFDdkIsbUJBQU8sV0FBVztBQUNsQixnQkFBSSxDQUFDLFNBQVM7QUFDWix3QkFBVTtBQUNWLCtCQUFpQixLQUFLLFFBQVEsTUFBTTtBQUNsQywwQkFBVTtBQUNWLG1CQUFHLE1BQU0sU0FBUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSzFCLDBCQUFrQixJQUFJLE9BQU87QUFDM0IsY0FBSTtBQUNKLGlCQUFPLFlBQVksTUFBTTtBQUN2QixnQkFBSSxPQUFPO0FBQ1QsMkJBQWE7QUFDYix3QkFBVSxXQUFXLElBQUksT0FBTztBQUFBLG1CQUMzQjtBQUNMLGlCQUFHLE1BQU0sTUFBTTtBQUFBO0FBRWpCLG1CQUFPO0FBQUE7QUFBQTtBQUdYLGNBQU0scUJBQXFCLENBQUMsVUFBVSxVQUFVLFVBQVUsU0FBUyxVQUFVLFFBQVEsVUFBVTtBQUMvRixjQUFNLGlCQUFpQixDQUFDLE9BQU8sT0FBTyxRQUFRLFVBQVUsVUFBVSxRQUFRLFVBQVUsUUFBUSxNQUFPLFNBQVEsT0FBTztBQUNsSCxjQUFNLFNBQVMsQ0FBQyxPQUFPLE1BQU0sT0FBTyxRQUFRO0FBQzFDLGdCQUFNLFFBQVEsTUFBTSxTQUFTO0FBQzdCLGlCQUFPLFVBQVUsUUFBUSxRQUFRLFVBQVUsV0FBWSxRQUFPLFNBQVMsSUFBSTtBQUFBO0FBRTdFLGtEQUEwQyxNQUFNLFFBQVEsb0JBQW9CO0FBQzFFLGdCQUFNLGFBQWEsT0FBTztBQUMxQixjQUFJLFFBQVE7QUFDWixjQUFJLFFBQVE7QUFDWixjQUFJLEtBQUssU0FBUztBQUNoQixrQkFBTSxFQUFDLFFBQVEsWUFBVztBQUMxQixrQkFBTSxPQUFPLE9BQU87QUFDcEIsa0JBQU0sRUFBQyxLQUFLLEtBQUssWUFBWSxlQUFjLE9BQU87QUFDbEQsZ0JBQUksWUFBWTtBQUNkLHNCQUFRLFlBQVksS0FBSyxJQUN2QixhQUFhLFNBQVMsT0FBTyxNQUFNLEtBQUssSUFDeEMscUJBQXFCLGFBQWEsYUFBYSxRQUFRLE1BQU0sT0FBTyxpQkFBaUIsTUFBTSxLQUM3RixHQUFHLGFBQWE7QUFBQTtBQUVsQixnQkFBSSxZQUFZO0FBQ2Qsc0JBQVEsWUFBWSxLQUFLLElBQ3ZCLGFBQWEsU0FBUyxPQUFPLE1BQU0sS0FBSyxNQUFNLEtBQUssR0FDbkQscUJBQXFCLElBQUksYUFBYSxRQUFRLE1BQU0sT0FBTyxpQkFBaUIsTUFBTSxNQUFNLEtBQUssSUFDL0YsT0FBTyxjQUFjO0FBQUEsbUJBQ2hCO0FBQ0wsc0JBQVEsYUFBYTtBQUFBO0FBQUE7QUFHekIsaUJBQU8sRUFBQyxPQUFPO0FBQUE7QUFFakIscUNBQTZCLE1BQU07QUFDakMsZ0JBQU0sRUFBQyxRQUFRLFFBQVEsaUJBQWdCO0FBQ3ZDLGdCQUFNLFlBQVk7QUFBQSxZQUNoQixNQUFNLE9BQU87QUFBQSxZQUNiLE1BQU0sT0FBTztBQUFBLFlBQ2IsTUFBTSxPQUFPO0FBQUEsWUFDYixNQUFNLE9BQU87QUFBQTtBQUVmLGNBQUksQ0FBQyxjQUFjO0FBQ2pCLGlCQUFLLGVBQWU7QUFDcEIsbUJBQU87QUFBQTtBQUVULGdCQUFNLFVBQVUsYUFBYSxTQUFTLE9BQU8sT0FDMUMsYUFBYSxTQUFTLE9BQU8sT0FDN0IsYUFBYSxTQUFTLE9BQU8sT0FDN0IsYUFBYSxTQUFTLE9BQU87QUFDaEMsaUJBQU8sT0FBTyxjQUFjO0FBQzVCLGlCQUFPO0FBQUE7QUFHVCx1QkFBZTtBQUFBLFVBQ2IsY0FBYztBQUNaLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssVUFBVSxvQkFBSTtBQUNuQixpQkFBSyxXQUFXO0FBQ2hCLGlCQUFLLFlBQVk7QUFBQTtBQUFBLFVBRW5CLFFBQVEsUUFBTyxPQUFPLE1BQU0sTUFBTTtBQUNoQyxrQkFBTSxZQUFZLE1BQU0sVUFBVTtBQUNsQyxrQkFBTSxXQUFXLE1BQU07QUFDdkIsc0JBQVUsUUFBUSxRQUFNLEdBQUc7QUFBQSxjQUN6QjtBQUFBLGNBQ0EsU0FBUyxNQUFNO0FBQUEsY0FDZjtBQUFBLGNBQ0EsYUFBYSxLQUFLLElBQUksT0FBTyxNQUFNLE9BQU87QUFBQTtBQUFBO0FBQUEsVUFHOUMsV0FBVztBQUNULGdCQUFJLEtBQUssVUFBVTtBQUNqQjtBQUFBO0FBRUYsaUJBQUssV0FBVztBQUNoQixpQkFBSyxXQUFXLGlCQUFpQixLQUFLLFFBQVEsTUFBTTtBQUNsRCxtQkFBSztBQUNMLG1CQUFLLFdBQVc7QUFDaEIsa0JBQUksS0FBSyxVQUFVO0FBQ2pCLHFCQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFJWCxRQUFRLE9BQU8sS0FBSyxPQUFPO0FBQ3pCLGdCQUFJLFlBQVk7QUFDaEIsaUJBQUssUUFBUSxRQUFRLENBQUMsT0FBTyxXQUFVO0FBQ3JDLGtCQUFJLENBQUMsTUFBTSxXQUFXLENBQUMsTUFBTSxNQUFNLFFBQVE7QUFDekM7QUFBQTtBQUVGLG9CQUFNLFFBQVEsTUFBTTtBQUNwQixrQkFBSSxJQUFJLE1BQU0sU0FBUztBQUN2QixrQkFBSSxRQUFPO0FBQ1gsa0JBQUk7QUFDSixxQkFBTyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQ2xCLHVCQUFPLE1BQU07QUFDYixvQkFBSSxLQUFLLFNBQVM7QUFDaEIsc0JBQUksS0FBSyxTQUFTLE1BQU0sVUFBVTtBQUNoQywwQkFBTSxXQUFXLEtBQUs7QUFBQTtBQUV4Qix1QkFBSyxLQUFLO0FBQ1YsMEJBQU87QUFBQSx1QkFDRjtBQUNMLHdCQUFNLEtBQUssTUFBTSxNQUFNLFNBQVM7QUFDaEMsd0JBQU07QUFBQTtBQUFBO0FBR1Ysa0JBQUksT0FBTTtBQUNSLHVCQUFNO0FBQ04scUJBQUssUUFBUSxRQUFPLE9BQU8sTUFBTTtBQUFBO0FBRW5DLGtCQUFJLENBQUMsTUFBTSxRQUFRO0FBQ2pCLHNCQUFNLFVBQVU7QUFDaEIscUJBQUssUUFBUSxRQUFPLE9BQU8sTUFBTTtBQUNqQyxzQkFBTSxVQUFVO0FBQUE7QUFFbEIsMkJBQWEsTUFBTTtBQUFBO0FBRXJCLGlCQUFLLFlBQVk7QUFDakIsZ0JBQUksY0FBYyxHQUFHO0FBQ25CLG1CQUFLLFdBQVc7QUFBQTtBQUFBO0FBQUEsVUFHcEIsVUFBVSxRQUFPO0FBQ2Ysa0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGdCQUFJLFFBQVEsT0FBTyxJQUFJO0FBQ3ZCLGdCQUFJLENBQUMsT0FBTztBQUNWLHNCQUFRO0FBQUEsZ0JBQ04sU0FBUztBQUFBLGdCQUNULFNBQVM7QUFBQSxnQkFDVCxPQUFPO0FBQUEsZ0JBQ1AsV0FBVztBQUFBLGtCQUNULFVBQVU7QUFBQSxrQkFDVixVQUFVO0FBQUE7QUFBQTtBQUdkLHFCQUFPLElBQUksUUFBTztBQUFBO0FBRXBCLG1CQUFPO0FBQUE7QUFBQSxVQUVULE9BQU8sUUFBTyxPQUFPLElBQUk7QUFDdkIsaUJBQUssVUFBVSxRQUFPLFVBQVUsT0FBTyxLQUFLO0FBQUE7QUFBQSxVQUU5QyxJQUFJLFFBQU8sT0FBTztBQUNoQixnQkFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLFFBQVE7QUFDM0I7QUFBQTtBQUVGLGlCQUFLLFVBQVUsUUFBTyxNQUFNLEtBQUssR0FBRztBQUFBO0FBQUEsVUFFdEMsSUFBSSxRQUFPO0FBQ1QsbUJBQU8sS0FBSyxVQUFVLFFBQU8sTUFBTSxTQUFTO0FBQUE7QUFBQSxVQUU5QyxNQUFNLFFBQU87QUFDWCxrQkFBTSxRQUFRLEtBQUssUUFBUSxJQUFJO0FBQy9CLGdCQUFJLENBQUMsT0FBTztBQUNWO0FBQUE7QUFFRixrQkFBTSxVQUFVO0FBQ2hCLGtCQUFNLFFBQVEsS0FBSztBQUNuQixrQkFBTSxXQUFXLE1BQU0sTUFBTSxPQUFPLENBQUMsS0FBSyxRQUFRLEtBQUssSUFBSSxLQUFLLElBQUksWUFBWTtBQUNoRixpQkFBSztBQUFBO0FBQUEsVUFFUCxRQUFRLFFBQU87QUFDYixnQkFBSSxDQUFDLEtBQUssVUFBVTtBQUNsQixxQkFBTztBQUFBO0FBRVQsa0JBQU0sUUFBUSxLQUFLLFFBQVEsSUFBSTtBQUMvQixnQkFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLFdBQVcsQ0FBQyxNQUFNLE1BQU0sUUFBUTtBQUNuRCxxQkFBTztBQUFBO0FBRVQsbUJBQU87QUFBQTtBQUFBLFVBRVQsS0FBSyxRQUFPO0FBQ1Ysa0JBQU0sUUFBUSxLQUFLLFFBQVEsSUFBSTtBQUMvQixnQkFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLE1BQU0sUUFBUTtBQUNqQztBQUFBO0FBRUYsa0JBQU0sUUFBUSxNQUFNO0FBQ3BCLGdCQUFJLElBQUksTUFBTSxTQUFTO0FBQ3ZCLG1CQUFPLEtBQUssR0FBRyxFQUFFLEdBQUc7QUFDbEIsb0JBQU0sR0FBRztBQUFBO0FBRVgsa0JBQU0sUUFBUTtBQUNkLGlCQUFLLFFBQVEsUUFBTyxPQUFPLEtBQUssT0FBTztBQUFBO0FBQUEsVUFFekMsT0FBTyxRQUFPO0FBQ1osbUJBQU8sS0FBSyxRQUFRLE9BQU87QUFBQTtBQUFBO0FBRy9CLFlBQUksV0FBVyxJQUFJO0FBRW5CLEFBTUEsdUJBQWUsR0FBRztBQUNoQixpQkFBTyxJQUFJLE1BQU07QUFBQTtBQUVuQixjQUFNLE1BQU0sQ0FBQyxHQUFHLEdBQUcsTUFBTSxLQUFLLElBQUksS0FBSyxJQUFJLEdBQUcsSUFBSTtBQUNsRCxxQkFBYSxHQUFHO0FBQ2QsaUJBQU8sSUFBSSxNQUFNLElBQUksT0FBTyxHQUFHO0FBQUE7QUFFakMscUJBQWEsR0FBRztBQUNkLGlCQUFPLElBQUksTUFBTSxJQUFJLE1BQU0sR0FBRztBQUFBO0FBRWhDLHFCQUFhLEdBQUc7QUFDZCxpQkFBTyxJQUFJLE1BQU0sSUFBSSxRQUFRLEtBQUssR0FBRztBQUFBO0FBRXZDLHFCQUFhLEdBQUc7QUFDZCxpQkFBTyxJQUFJLE1BQU0sSUFBSSxNQUFNLEdBQUc7QUFBQTtBQUVoQyxjQUFNLFFBQVEsRUFBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHO0FBQzNKLGNBQU0sTUFBTSxDQUFDLEdBQUc7QUFDaEIsY0FBTSxLQUFLLE9BQUssSUFBSSxJQUFJO0FBQ3hCLGNBQU0sS0FBSyxPQUFLLElBQUssS0FBSSxRQUFTLEtBQUssSUFBSSxJQUFJO0FBQy9DLGNBQU0sS0FBSyxPQUFPLEtBQUksUUFBUyxNQUFRLEtBQUk7QUFDM0MsY0FBTSxVQUFVLE9BQUssR0FBRyxFQUFFLE1BQU0sR0FBRyxFQUFFLE1BQU0sR0FBRyxFQUFFLE1BQU0sR0FBRyxFQUFFO0FBQzNELDBCQUFrQixLQUFLO0FBQ3JCLGNBQUksTUFBTSxJQUFJO0FBQ2QsY0FBSTtBQUNKLGNBQUksSUFBSSxPQUFPLEtBQUs7QUFDbEIsZ0JBQUksUUFBUSxLQUFLLFFBQVEsR0FBRztBQUMxQixvQkFBTTtBQUFBLGdCQUNKLEdBQUcsTUFBTSxNQUFNLElBQUksTUFBTTtBQUFBLGdCQUN6QixHQUFHLE1BQU0sTUFBTSxJQUFJLE1BQU07QUFBQSxnQkFDekIsR0FBRyxNQUFNLE1BQU0sSUFBSSxNQUFNO0FBQUEsZ0JBQ3pCLEdBQUcsUUFBUSxJQUFJLE1BQU0sSUFBSSxNQUFNLEtBQUs7QUFBQTtBQUFBLHVCQUU3QixRQUFRLEtBQUssUUFBUSxHQUFHO0FBQ2pDLG9CQUFNO0FBQUEsZ0JBQ0osR0FBRyxNQUFNLElBQUksT0FBTyxJQUFJLE1BQU0sSUFBSTtBQUFBLGdCQUNsQyxHQUFHLE1BQU0sSUFBSSxPQUFPLElBQUksTUFBTSxJQUFJO0FBQUEsZ0JBQ2xDLEdBQUcsTUFBTSxJQUFJLE9BQU8sSUFBSSxNQUFNLElBQUk7QUFBQSxnQkFDbEMsR0FBRyxRQUFRLElBQUssTUFBTSxJQUFJLE9BQU8sSUFBSSxNQUFNLElBQUksTUFBTztBQUFBO0FBQUE7QUFBQTtBQUk1RCxpQkFBTztBQUFBO0FBRVQsY0FBTSxRQUFRLENBQUMsR0FBRyxNQUFNLElBQUksTUFBTSxFQUFFLEtBQUs7QUFDekMsMkJBQW1CLEdBQUc7QUFDcEIsY0FBSSxJQUFJLFFBQVEsS0FBSyxLQUFLO0FBQzFCLGlCQUFPLElBQ0gsTUFBTSxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsS0FBSyxNQUFNLEVBQUUsR0FBRyxLQUM1QztBQUFBO0FBRU4sY0FBTSxTQUFTO0FBQ2YsMEJBQWtCLEdBQUcsR0FBRyxHQUFHO0FBQ3pCLGdCQUFNLElBQUksSUFBSSxLQUFLLElBQUksR0FBRyxJQUFJO0FBQzlCLGdCQUFNLElBQUksQ0FBQyxHQUFHLElBQUssS0FBSSxJQUFJLE1BQU0sT0FBTyxJQUFJLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDcEYsaUJBQU8sQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFBQTtBQUV4QiwwQkFBa0IsR0FBRyxHQUFHLEdBQUc7QUFDekIsZ0JBQU0sSUFBSSxDQUFDLEdBQUcsSUFBSyxLQUFJLElBQUksTUFBTSxNQUFNLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSTtBQUNuRixpQkFBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUFBO0FBRXhCLDBCQUFrQixHQUFHLEdBQUcsR0FBRztBQUN6QixnQkFBTSxNQUFNLFNBQVMsR0FBRyxHQUFHO0FBQzNCLGNBQUk7QUFDSixjQUFJLElBQUksSUFBSSxHQUFHO0FBQ2IsZ0JBQUksSUFBSyxLQUFJO0FBQ2IsaUJBQUs7QUFDTCxpQkFBSztBQUFBO0FBRVAsZUFBSyxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDdEIsZ0JBQUksTUFBTSxJQUFJLElBQUk7QUFDbEIsZ0JBQUksTUFBTTtBQUFBO0FBRVosaUJBQU87QUFBQTtBQUVULDBCQUFrQixHQUFHLEdBQUcsR0FBRyxHQUFHLEtBQUs7QUFDakMsY0FBSSxNQUFNLEtBQUs7QUFDYixtQkFBUyxLQUFJLEtBQUssSUFBTSxLQUFJLElBQUksSUFBSTtBQUFBO0FBRXRDLGNBQUksTUFBTSxLQUFLO0FBQ2IsbUJBQVEsS0FBSSxLQUFLLElBQUk7QUFBQTtBQUV2QixpQkFBUSxLQUFJLEtBQUssSUFBSTtBQUFBO0FBRXZCLHlCQUFpQixHQUFHO0FBQ2xCLGdCQUFNLFNBQVE7QUFDZCxnQkFBTSxJQUFJLEVBQUUsSUFBSTtBQUNoQixnQkFBTSxJQUFJLEVBQUUsSUFBSTtBQUNoQixnQkFBTSxJQUFJLEVBQUUsSUFBSTtBQUNoQixnQkFBTSxNQUFNLEtBQUssSUFBSSxHQUFHLEdBQUc7QUFDM0IsZ0JBQU0sTUFBTSxLQUFLLElBQUksR0FBRyxHQUFHO0FBQzNCLGdCQUFNLElBQUssT0FBTSxPQUFPO0FBQ3hCLGNBQUksR0FBRyxHQUFHO0FBQ1YsY0FBSSxRQUFRLEtBQUs7QUFDZixnQkFBSSxNQUFNO0FBQ1YsZ0JBQUksSUFBSSxNQUFNLElBQUssS0FBSSxNQUFNLE9BQU8sSUFBSyxPQUFNO0FBQy9DLGdCQUFJLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUN6QixnQkFBSSxJQUFJLEtBQUs7QUFBQTtBQUVmLGlCQUFPLENBQUMsSUFBSSxHQUFHLEtBQUssR0FBRztBQUFBO0FBRXpCLHVCQUFlLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDekIsaUJBQ0UsT0FBTSxRQUFRLEtBQ1YsRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsTUFDaEIsRUFBRSxHQUFHLEdBQUcsSUFDWixJQUFJO0FBQUE7QUFFUix5QkFBaUIsR0FBRyxHQUFHLEdBQUc7QUFDeEIsaUJBQU8sTUFBTSxVQUFVLEdBQUcsR0FBRztBQUFBO0FBRS9CLHlCQUFpQixHQUFHLEdBQUcsR0FBRztBQUN4QixpQkFBTyxNQUFNLFVBQVUsR0FBRyxHQUFHO0FBQUE7QUFFL0IseUJBQWlCLEdBQUcsR0FBRyxHQUFHO0FBQ3hCLGlCQUFPLE1BQU0sVUFBVSxHQUFHLEdBQUc7QUFBQTtBQUUvQixxQkFBYSxHQUFHO0FBQ2QsaUJBQVEsS0FBSSxNQUFNLE9BQU87QUFBQTtBQUUzQiwwQkFBa0IsS0FBSztBQUNyQixnQkFBTSxJQUFJLE9BQU8sS0FBSztBQUN0QixjQUFJLElBQUk7QUFDUixjQUFJO0FBQ0osY0FBSSxDQUFDLEdBQUc7QUFDTjtBQUFBO0FBRUYsY0FBSSxFQUFFLE9BQU8sR0FBRztBQUNkLGdCQUFJLEVBQUUsS0FBSyxJQUFJLENBQUMsRUFBRSxNQUFNLElBQUksQ0FBQyxFQUFFO0FBQUE7QUFFakMsZ0JBQU0sSUFBSSxJQUFJLENBQUMsRUFBRTtBQUNqQixnQkFBTSxLQUFLLENBQUMsRUFBRSxLQUFLO0FBQ25CLGdCQUFNLEtBQUssQ0FBQyxFQUFFLEtBQUs7QUFDbkIsY0FBSSxFQUFFLE9BQU8sT0FBTztBQUNsQixnQkFBSSxRQUFRLEdBQUcsSUFBSTtBQUFBLHFCQUNWLEVBQUUsT0FBTyxPQUFPO0FBQ3pCLGdCQUFJLFFBQVEsR0FBRyxJQUFJO0FBQUEsaUJBQ2Q7QUFDTCxnQkFBSSxRQUFRLEdBQUcsSUFBSTtBQUFBO0FBRXJCLGlCQUFPO0FBQUEsWUFDTCxHQUFHLEVBQUU7QUFBQSxZQUNMLEdBQUcsRUFBRTtBQUFBLFlBQ0wsR0FBRyxFQUFFO0FBQUEsWUFDTDtBQUFBO0FBQUE7QUFHSix3QkFBZ0IsR0FBRyxLQUFLO0FBQ3RCLGNBQUksSUFBSSxRQUFRO0FBQ2hCLFlBQUUsS0FBSyxJQUFJLEVBQUUsS0FBSztBQUNsQixjQUFJLFFBQVE7QUFDWixZQUFFLElBQUksRUFBRTtBQUNSLFlBQUUsSUFBSSxFQUFFO0FBQ1IsWUFBRSxJQUFJLEVBQUU7QUFBQTtBQUVWLDJCQUFtQixHQUFHO0FBQ3BCLGNBQUksQ0FBQyxHQUFHO0FBQ047QUFBQTtBQUVGLGdCQUFNLElBQUksUUFBUTtBQUNsQixnQkFBTSxJQUFJLEVBQUU7QUFDWixnQkFBTSxJQUFJLElBQUksRUFBRTtBQUNoQixnQkFBTSxJQUFJLElBQUksRUFBRTtBQUNoQixpQkFBTyxFQUFFLElBQUksTUFDVCxRQUFRLE1BQU0sT0FBTyxPQUFPLElBQUksRUFBRSxRQUNsQyxPQUFPLE1BQU0sT0FBTztBQUFBO0FBRTFCLGNBQU0sUUFBUTtBQUFBLFVBQ1osR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBO0FBRUwsY0FBTSxVQUFVO0FBQUEsVUFDZCxRQUFRO0FBQUEsVUFDUixhQUFhO0FBQUEsVUFDYixNQUFNO0FBQUEsVUFDTixXQUFXO0FBQUEsVUFDWCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxjQUFjO0FBQUEsVUFDZCxJQUFJO0FBQUEsVUFDSixTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsVUFDTixXQUFXO0FBQUEsVUFDWCxRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxLQUFLO0FBQUEsVUFDTCxhQUFhO0FBQUEsVUFDYixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsVUFDTixLQUFLO0FBQUEsVUFDTCxPQUFPO0FBQUEsVUFDUCxTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxVQUFVO0FBQUEsVUFDVixRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxPQUFPO0FBQUEsVUFDUCxLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsVUFDVixRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxXQUFXO0FBQUEsVUFDWCxLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixLQUFLO0FBQUEsVUFDTCxLQUFLO0FBQUEsVUFDTCxPQUFPO0FBQUEsVUFDUCxLQUFLO0FBQUEsVUFDTCxTQUFTO0FBQUEsVUFDVCxRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixXQUFXO0FBQUEsVUFDWCxTQUFTO0FBQUEsVUFDVCxZQUFZO0FBQUEsVUFDWixLQUFLO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxXQUFXO0FBQUEsVUFDWCxNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxPQUFPO0FBQUEsVUFDUCxTQUFTO0FBQUEsVUFDVCxLQUFLO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixTQUFTO0FBQUEsVUFDVCxLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxZQUFZO0FBQUEsVUFDWixLQUFLO0FBQUEsVUFDTCxPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixNQUFNO0FBQUEsVUFDTixXQUFXO0FBQUEsVUFDWCxLQUFLO0FBQUEsVUFDTCxVQUFVO0FBQUEsVUFDVixZQUFZO0FBQUEsVUFDWixTQUFTO0FBQUEsVUFDVCxVQUFVO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxZQUFZO0FBQUEsVUFDWixNQUFNO0FBQUEsVUFDTixRQUFRO0FBQUEsVUFDUixNQUFNO0FBQUEsVUFD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LFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUE7QUFHQSw4QkFBc0IsU0FBUyxNQUFNLE9BQU8sV0FBVztBQUNyRCxnQkFBTSxFQUFDLFlBQVksTUFBTSxZQUFXO0FBQ3BDLGdCQUFNLFNBQVMsV0FBVyxZQUFZO0FBQ3RDLGNBQUksVUFBVSxTQUFTLE9BQU8sUUFBUSxTQUFTLE9BQU8sV0FBVyxLQUFLLFFBQVE7QUFDNUUsa0JBQU0sZUFBZSxPQUFPLGlCQUFpQixnQkFBZ0I7QUFDN0QsZ0JBQUksQ0FBQyxXQUFXO0FBQ2QscUJBQU8sYUFBYSxNQUFNLE1BQU07QUFBQSx1QkFDdkIsV0FBVyxnQkFBZ0I7QUFDcEMsb0JBQU0sS0FBSyxLQUFLO0FBQ2hCLG9CQUFNLFNBQVEsT0FBTyxHQUFHLGFBQWEsY0FBYyxHQUFHLFNBQVM7QUFDL0Qsa0JBQUksUUFBTztBQUNULHNCQUFNLFFBQVEsYUFBYSxNQUFNLE1BQU0sUUFBUTtBQUMvQyxzQkFBTSxNQUFNLGFBQWEsTUFBTSxNQUFNLFFBQVE7QUFDN0MsdUJBQU8sRUFBQyxJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUk7QUFBQTtBQUFBO0FBQUE7QUFJcEMsaUJBQU8sRUFBQyxJQUFJLEdBQUcsSUFBSSxLQUFLLFNBQVM7QUFBQTtBQUVuQywwQ0FBa0MsUUFBTyxNQUFNLFVBQVUsU0FBUyxXQUFXO0FBQzNFLGdCQUFNLFdBQVcsT0FBTTtBQUN2QixnQkFBTSxRQUFRLFNBQVM7QUFDdkIsbUJBQVMsSUFBSSxHQUFHLE9BQU8sU0FBUyxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDckQsa0JBQU0sRUFBQyxlQUFPLFNBQVEsU0FBUztBQUMvQixrQkFBTSxFQUFDLElBQUksT0FBTSxhQUFhLFNBQVMsSUFBSSxNQUFNLE9BQU87QUFDeEQscUJBQVMsSUFBSSxJQUFJLEtBQUssSUFBSSxFQUFFLEdBQUc7QUFDN0Isb0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGtCQUFJLENBQUMsUUFBUSxNQUFNO0FBQ2pCLHdCQUFRLFNBQVMsUUFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS2hDLDBDQUFrQyxNQUFNO0FBQ3RDLGdCQUFNLE9BQU8sS0FBSyxRQUFRLFNBQVM7QUFDbkMsZ0JBQU0sT0FBTyxLQUFLLFFBQVEsU0FBUztBQUNuQyxpQkFBTyxTQUFTLEtBQUssS0FBSztBQUN4QixrQkFBTSxTQUFTLE9BQU8sS0FBSyxJQUFJLElBQUksSUFBSSxJQUFJLEtBQUs7QUFDaEQsa0JBQU0sU0FBUyxPQUFPLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSSxLQUFLO0FBQ2hELG1CQUFPLEtBQUssS0FBSyxLQUFLLElBQUksUUFBUSxLQUFLLEtBQUssSUFBSSxRQUFRO0FBQUE7QUFBQTtBQUc1RCxtQ0FBMkIsUUFBTyxVQUFVLE1BQU0sa0JBQWtCLGtCQUFrQjtBQUNwRixnQkFBTSxRQUFRO0FBQ2QsY0FBSSxDQUFDLG9CQUFvQixDQUFDLE9BQU0sY0FBYyxXQUFXO0FBQ3ZELG1CQUFPO0FBQUE7QUFFVCxnQkFBTSxpQkFBaUIsU0FBUyxTQUFTLGNBQWMsUUFBTztBQUM1RCxnQkFBSSxDQUFDLG9CQUFvQixDQUFDLGVBQWUsU0FBUyxPQUFNLFdBQVcsSUFBSTtBQUNyRTtBQUFBO0FBRUYsZ0JBQUksUUFBUSxRQUFRLFNBQVMsR0FBRyxTQUFTLEdBQUcsbUJBQW1CO0FBQzdELG9CQUFNLEtBQUssRUFBQyxTQUFTLGNBQWM7QUFBQTtBQUFBO0FBR3ZDLG1DQUF5QixRQUFPLE1BQU0sVUFBVSxnQkFBZ0I7QUFDaEUsaUJBQU87QUFBQTtBQUVULHVDQUErQixRQUFPLFVBQVUsTUFBTSxrQkFBa0I7QUFDdEUsY0FBSSxRQUFRO0FBQ1osa0NBQXdCLFNBQVMsY0FBYyxRQUFPO0FBQ3BELGtCQUFNLEVBQUMsWUFBWSxhQUFZLFFBQVEsU0FBUyxDQUFDLGNBQWMsYUFBYTtBQUM1RSxrQkFBTSxFQUFDLFVBQVMsa0JBQWtCLFNBQVMsRUFBQyxHQUFHLFNBQVMsR0FBRyxHQUFHLFNBQVM7QUFDdkUsZ0JBQUksY0FBYyxPQUFPLFlBQVksV0FBVztBQUM5QyxvQkFBTSxLQUFLLEVBQUMsU0FBUyxjQUFjO0FBQUE7QUFBQTtBQUd2QyxtQ0FBeUIsUUFBTyxNQUFNLFVBQVU7QUFDaEQsaUJBQU87QUFBQTtBQUVULDBDQUFrQyxRQUFPLFVBQVUsTUFBTSxXQUFXLGtCQUFrQixrQkFBa0I7QUFDdEcsY0FBSSxRQUFRO0FBQ1osZ0JBQU0saUJBQWlCLHlCQUF5QjtBQUNoRCxjQUFJLGNBQWMsT0FBTztBQUN6QixrQ0FBd0IsU0FBUyxjQUFjLFFBQU87QUFDcEQsa0JBQU0sV0FBVSxRQUFRLFFBQVEsU0FBUyxHQUFHLFNBQVMsR0FBRztBQUN4RCxnQkFBSSxhQUFhLENBQUMsVUFBUztBQUN6QjtBQUFBO0FBRUYsa0JBQU0sU0FBUyxRQUFRLGVBQWU7QUFDdEMsa0JBQU0sY0FBYyxDQUFDLENBQUMsb0JBQW9CLE9BQU0sY0FBYztBQUM5RCxnQkFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFTO0FBQzVCO0FBQUE7QUFFRixrQkFBTSxZQUFXLGVBQWUsVUFBVTtBQUMxQyxnQkFBSSxZQUFXLGFBQWE7QUFDMUIsc0JBQVEsQ0FBQyxFQUFDLFNBQVMsY0FBYztBQUNqQyw0QkFBYztBQUFBLHVCQUNMLGNBQWEsYUFBYTtBQUNuQyxvQkFBTSxLQUFLLEVBQUMsU0FBUyxjQUFjO0FBQUE7QUFBQTtBQUd2QyxtQ0FBeUIsUUFBTyxNQUFNLFVBQVU7QUFDaEQsaUJBQU87QUFBQTtBQUVULGlDQUF5QixRQUFPLFVBQVUsTUFBTSxXQUFXLGtCQUFrQixrQkFBa0I7QUFDN0YsY0FBSSxDQUFDLG9CQUFvQixDQUFDLE9BQU0sY0FBYyxXQUFXO0FBQ3ZELG1CQUFPO0FBQUE7QUFFVCxpQkFBTyxTQUFTLE9BQU8sQ0FBQyxZQUNwQixzQkFBc0IsUUFBTyxVQUFVLE1BQU0sb0JBQzdDLHlCQUF5QixRQUFPLFVBQVUsTUFBTSxXQUFXLGtCQUFrQjtBQUFBO0FBRW5GLDhCQUFzQixRQUFPLFVBQVUsTUFBTSxXQUFXLGtCQUFrQjtBQUN4RSxnQkFBTSxRQUFRO0FBQ2QsZ0JBQU0sY0FBYyxTQUFTLE1BQU0sYUFBYTtBQUNoRCxjQUFJLGlCQUFpQjtBQUNyQixtQ0FBeUIsUUFBTyxNQUFNLFVBQVUsQ0FBQyxTQUFTLGNBQWMsV0FBVTtBQUNoRixnQkFBSSxRQUFRLGFBQWEsU0FBUyxPQUFPLG1CQUFtQjtBQUMxRCxvQkFBTSxLQUFLLEVBQUMsU0FBUyxjQUFjO0FBQ25DLCtCQUFpQixrQkFBa0IsUUFBUSxRQUFRLFNBQVMsR0FBRyxTQUFTLEdBQUc7QUFBQTtBQUFBO0FBRy9FLGNBQUksYUFBYSxDQUFDLGdCQUFnQjtBQUNoQyxtQkFBTztBQUFBO0FBRVQsaUJBQU87QUFBQTtBQUVULFlBQUksY0FBYztBQUFBLFVBQ2hCO0FBQUEsVUFDQSxPQUFPO0FBQUEsWUFDTCxNQUFNLFFBQU8sR0FBRyxTQUFTLGtCQUFrQjtBQUN6QyxvQkFBTSxXQUFXLG9CQUFvQixHQUFHO0FBQ3hDLG9CQUFNLE9BQU8sUUFBUSxRQUFRO0FBQzdCLG9CQUFNLG1CQUFtQixRQUFRLG9CQUFvQjtBQUNyRCxvQkFBTSxRQUFRLFFBQVEsWUFDbEIsa0JBQWtCLFFBQU8sVUFBVSxNQUFNLGtCQUFrQixvQkFDM0QsZ0JBQWdCLFFBQU8sVUFBVSxNQUFNLE9BQU8sa0JBQWtCO0FBQ3BFLG9CQUFNLFlBQVc7QUFDakIsa0JBQUksQ0FBQyxNQUFNLFFBQVE7QUFDakIsdUJBQU87QUFBQTtBQUVULHFCQUFNLCtCQUErQixRQUFRLENBQUMsU0FBUztBQUNyRCxzQkFBTSxTQUFRLE1BQU0sR0FBRztBQUN2QixzQkFBTSxVQUFVLEtBQUssS0FBSztBQUMxQixvQkFBSSxXQUFXLENBQUMsUUFBUSxNQUFNO0FBQzVCLDRCQUFTLEtBQUssRUFBQyxTQUFTLGNBQWMsS0FBSyxPQUFPO0FBQUE7QUFBQTtBQUd0RCxxQkFBTztBQUFBO0FBQUEsWUFFVCxRQUFRLFFBQU8sR0FBRyxTQUFTLGtCQUFrQjtBQUMzQyxvQkFBTSxXQUFXLG9CQUFvQixHQUFHO0FBQ3hDLG9CQUFNLE9BQU8sUUFBUSxRQUFRO0FBQzdCLG9CQUFNLG1CQUFtQixRQUFRLG9CQUFvQjtBQUNyRCxrQkFBSSxRQUFRLFFBQVEsWUFDaEIsa0JBQWtCLFFBQU8sVUFBVSxNQUFNLGtCQUFrQixvQkFDN0QsZ0JBQWdCLFFBQU8sVUFBVSxNQUFNLE9BQU8sa0JBQWtCO0FBQ2xFLGtCQUFJLE1BQU0sU0FBUyxHQUFHO0FBQ3BCLHNCQUFNLGVBQWUsTUFBTSxHQUFHO0FBQzlCLHNCQUFNLE9BQU8sT0FBTSxlQUFlLGNBQWM7QUFDaEQsd0JBQVE7QUFDUix5QkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsRUFBRSxHQUFHO0FBQ3BDLHdCQUFNLEtBQUssRUFBQyxTQUFTLEtBQUssSUFBSSxjQUFjLE9BQU87QUFBQTtBQUFBO0FBR3ZELHFCQUFPO0FBQUE7QUFBQSxZQUVULE1BQU0sUUFBTyxHQUFHLFNBQVMsa0JBQWtCO0FBQ3pDLG9CQUFNLFdBQVcsb0JBQW9CLEdBQUc7QUFDeEMsb0JBQU0sT0FBTyxRQUFRLFFBQVE7QUFDN0Isb0JBQU0sbUJBQW1CLFFBQVEsb0JBQW9CO0FBQ3JELHFCQUFPLGtCQUFrQixRQUFPLFVBQVUsTUFBTSxrQkFBa0I7QUFBQTtBQUFBLFlBRXBFLFFBQVEsUUFBTyxHQUFHLFNBQVMsa0JBQWtCO0FBQzNDLG9CQUFNLFdBQVcsb0JBQW9CLEdBQUc7QUFDeEMsb0JBQU0sT0FBTyxRQUFRLFFBQVE7QUFDN0Isb0JBQU0sbUJBQW1CLFFBQVEsb0JBQW9CO0FBQ3JELHFCQUFPLGdCQUFnQixRQUFPLFVBQVUsTUFBTSxRQUFRLFdBQVcsa0JBQWtCO0FBQUE7QUFBQSxZQUVyRixFQUFFLFFBQU8sR0FBRyxTQUFTLGtCQUFrQjtBQUNyQyxvQkFBTSxXQUFXLG9CQUFvQixHQUFHO0FBQ3hDLHFCQUFPLGFBQWEsUUFBTyxVQUFVLEtBQUssUUFBUSxXQUFXO0FBQUE7QUFBQSxZQUUvRCxFQUFFLFFBQU8sR0FBRyxTQUFTLGtCQUFrQjtBQUNyQyxvQkFBTSxXQUFXLG9CQUFvQixHQUFHO0FBQ3hDLHFCQUFPLGFBQWEsUUFBTyxVQUFVLEtBQUssUUFBUSxXQUFXO0FBQUE7QUFBQTtBQUFBO0FBS25FLGNBQU0sbUJBQW1CLENBQUMsUUFBUSxPQUFPLFNBQVM7QUFDbEQsa0NBQTBCLE9BQU8sVUFBVTtBQUN6QyxpQkFBTyxNQUFNLE9BQU8sT0FBSyxFQUFFLFFBQVE7QUFBQTtBQUVyQyw2Q0FBcUMsT0FBTyxNQUFNO0FBQ2hELGlCQUFPLE1BQU0sT0FBTyxPQUFLLGlCQUFpQixRQUFRLEVBQUUsU0FBUyxNQUFNLEVBQUUsSUFBSSxTQUFTO0FBQUE7QUFFcEYsOEJBQXNCLE9BQU8sU0FBUztBQUNwQyxpQkFBTyxNQUFNLEtBQUssQ0FBQyxHQUFHLE1BQU07QUFDMUIsa0JBQU0sS0FBSyxVQUFVLElBQUk7QUFDekIsa0JBQU0sS0FBSyxVQUFVLElBQUk7QUFDekIsbUJBQU8sR0FBRyxXQUFXLEdBQUcsU0FDdEIsR0FBRyxRQUFRLEdBQUcsUUFDZCxHQUFHLFNBQVMsR0FBRztBQUFBO0FBQUE7QUFHckIsMkJBQW1CLE9BQU87QUFDeEIsZ0JBQU0sY0FBYztBQUNwQixjQUFJLEdBQUcsTUFBTSxLQUFLLEtBQUssT0FBTztBQUM5QixlQUFLLElBQUksR0FBRyxPQUFRLFVBQVMsSUFBSSxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDdEQsa0JBQU0sTUFBTTtBQUNaLFlBQUMsR0FBQyxVQUFVLEtBQUssU0FBUyxFQUFDLE9BQU8sY0FBYyxRQUFNO0FBQ3RELHdCQUFZLEtBQUs7QUFBQSxjQUNmLE9BQU87QUFBQSxjQUNQO0FBQUEsY0FDQTtBQUFBLGNBQ0EsWUFBWSxJQUFJO0FBQUEsY0FDaEIsUUFBUSxJQUFJO0FBQUEsY0FDWixPQUFPLFNBQVUsTUFBTTtBQUFBLGNBQ3ZCO0FBQUE7QUFBQTtBQUdKLGlCQUFPO0FBQUE7QUFFVCw2QkFBcUIsVUFBUztBQUM1QixnQkFBTSxTQUFTO0FBQ2YscUJBQVcsUUFBUSxVQUFTO0FBQzFCLGtCQUFNLEVBQUMsT0FBTyxLQUFLLGdCQUFlO0FBQ2xDLGdCQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixTQUFTLE1BQU07QUFDN0M7QUFBQTtBQUVGLGtCQUFNLFNBQVMsT0FBTyxVQUFXLFFBQU8sU0FBUyxFQUFDLE9BQU8sR0FBRyxRQUFRLEdBQUcsUUFBUSxHQUFHLE1BQU07QUFDeEYsbUJBQU87QUFDUCxtQkFBTyxVQUFVO0FBQUE7QUFFbkIsaUJBQU87QUFBQTtBQUVULCtCQUF1QixVQUFTLFFBQVE7QUFDdEMsZ0JBQU0sU0FBUyxZQUFZO0FBQzNCLGdCQUFNLEVBQUMsY0FBYyxrQkFBaUI7QUFDdEMsY0FBSSxHQUFHLE1BQU07QUFDYixlQUFLLElBQUksR0FBRyxPQUFPLFNBQVEsUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ2hELHFCQUFTLFNBQVE7QUFDakIsa0JBQU0sRUFBQyxhQUFZLE9BQU87QUFDMUIsa0JBQU0sUUFBUSxPQUFPLE9BQU87QUFDNUIsa0JBQU0sU0FBUyxTQUFTLE9BQU8sY0FBYyxNQUFNO0FBQ25ELGdCQUFJLE9BQU8sWUFBWTtBQUNyQixxQkFBTyxRQUFRLFNBQVMsU0FBUyxlQUFlLFlBQVksT0FBTztBQUNuRSxxQkFBTyxTQUFTO0FBQUEsbUJBQ1g7QUFDTCxxQkFBTyxRQUFRO0FBQ2YscUJBQU8sU0FBUyxTQUFTLFNBQVMsZ0JBQWdCLFlBQVksT0FBTztBQUFBO0FBQUE7QUFHekUsaUJBQU87QUFBQTtBQUVULGtDQUEwQixPQUFPO0FBQy9CLGdCQUFNLGNBQWMsVUFBVTtBQUM5QixnQkFBTSxXQUFXLGFBQWEsWUFBWSxPQUFPLFVBQVEsS0FBSyxJQUFJLFdBQVc7QUFDN0UsZ0JBQU0sT0FBTyxhQUFhLGlCQUFpQixhQUFhLFNBQVM7QUFDakUsZ0JBQU0sUUFBUSxhQUFhLGlCQUFpQixhQUFhO0FBQ3pELGdCQUFNLE1BQU0sYUFBYSxpQkFBaUIsYUFBYSxRQUFRO0FBQy9ELGdCQUFNLFNBQVMsYUFBYSxpQkFBaUIsYUFBYTtBQUMxRCxnQkFBTSxtQkFBbUIsNEJBQTRCLGFBQWE7QUFDbEUsZ0JBQU0saUJBQWlCLDRCQUE0QixhQUFhO0FBQ2hFLGlCQUFPO0FBQUEsWUFDTDtBQUFBLFlBQ0EsWUFBWSxLQUFLLE9BQU87QUFBQSxZQUN4QixnQkFBZ0IsTUFBTSxPQUFPLGdCQUFnQixPQUFPLFFBQVEsT0FBTztBQUFBLFlBQ25FLFdBQVcsaUJBQWlCLGFBQWE7QUFBQSxZQUN6QyxVQUFVLEtBQUssT0FBTyxPQUFPLE9BQU87QUFBQSxZQUNwQyxZQUFZLElBQUksT0FBTyxRQUFRLE9BQU87QUFBQTtBQUFBO0FBRzFDLGdDQUF3QixZQUFZLFdBQVcsR0FBRyxHQUFHO0FBQ25ELGlCQUFPLEtBQUssSUFBSSxXQUFXLElBQUksVUFBVSxNQUFNLEtBQUssSUFBSSxXQUFXLElBQUksVUFBVTtBQUFBO0FBRW5GLGtDQUEwQixZQUFZLFlBQVk7QUFDaEQscUJBQVcsTUFBTSxLQUFLLElBQUksV0FBVyxLQUFLLFdBQVc7QUFDckQscUJBQVcsT0FBTyxLQUFLLElBQUksV0FBVyxNQUFNLFdBQVc7QUFDdkQscUJBQVcsU0FBUyxLQUFLLElBQUksV0FBVyxRQUFRLFdBQVc7QUFDM0QscUJBQVcsUUFBUSxLQUFLLElBQUksV0FBVyxPQUFPLFdBQVc7QUFBQTtBQUUzRCw0QkFBb0IsV0FBVyxRQUFRLFFBQVEsUUFBUTtBQUNyRCxnQkFBTSxFQUFDLEtBQUssUUFBTztBQUNuQixnQkFBTSxhQUFhLFVBQVU7QUFDN0IsY0FBSSxDQUFDLFVBQVMsTUFBTTtBQUNsQixnQkFBSSxPQUFPLE1BQU07QUFDZix3QkFBVSxRQUFRLE9BQU87QUFBQTtBQUUzQixrQkFBTSxRQUFRLE9BQU8sT0FBTyxVQUFVLEVBQUMsTUFBTSxHQUFHLE9BQU87QUFDdkQsa0JBQU0sT0FBTyxLQUFLLElBQUksTUFBTSxNQUFNLE9BQU8sYUFBYSxJQUFJLFNBQVMsSUFBSTtBQUN2RSxtQkFBTyxPQUFPLE1BQU0sT0FBTyxNQUFNO0FBQ2pDLHNCQUFVLFFBQVEsT0FBTztBQUFBO0FBRTNCLGNBQUksSUFBSSxZQUFZO0FBQ2xCLDZCQUFpQixZQUFZLElBQUk7QUFBQTtBQUVuQyxnQkFBTSxXQUFXLEtBQUssSUFBSSxHQUFHLE9BQU8sYUFBYSxlQUFlLFlBQVksV0FBVyxRQUFRO0FBQy9GLGdCQUFNLFlBQVksS0FBSyxJQUFJLEdBQUcsT0FBTyxjQUFjLGVBQWUsWUFBWSxXQUFXLE9BQU87QUFDaEcsZ0JBQU0sZUFBZSxhQUFhLFVBQVU7QUFDNUMsZ0JBQU0sZ0JBQWdCLGNBQWMsVUFBVTtBQUM5QyxvQkFBVSxJQUFJO0FBQ2Qsb0JBQVUsSUFBSTtBQUNkLGlCQUFPLE9BQU8sYUFDVixFQUFDLE1BQU0sY0FBYyxPQUFPLGtCQUM1QixFQUFDLE1BQU0sZUFBZSxPQUFPO0FBQUE7QUFFbkMsa0NBQTBCLFdBQVc7QUFDbkMsZ0JBQU0sYUFBYSxVQUFVO0FBQzdCLDZCQUFtQixLQUFLO0FBQ3RCLGtCQUFNLFNBQVMsS0FBSyxJQUFJLFdBQVcsT0FBTyxVQUFVLE1BQU07QUFDMUQsc0JBQVUsUUFBUTtBQUNsQixtQkFBTztBQUFBO0FBRVQsb0JBQVUsS0FBSyxVQUFVO0FBQ3pCLG9CQUFVLEtBQUssVUFBVTtBQUN6QixvQkFBVTtBQUNWLG9CQUFVO0FBQUE7QUFFWiw0QkFBb0IsWUFBWSxXQUFXO0FBQ3pDLGdCQUFNLGFBQWEsVUFBVTtBQUM3QixzQ0FBNEIsWUFBVztBQUNyQyxrQkFBTSxTQUFTLEVBQUMsTUFBTSxHQUFHLEtBQUssR0FBRyxPQUFPLEdBQUcsUUFBUTtBQUNuRCx1QkFBVSxRQUFRLENBQUMsUUFBUTtBQUN6QixxQkFBTyxPQUFPLEtBQUssSUFBSSxVQUFVLE1BQU0sV0FBVztBQUFBO0FBRXBELG1CQUFPO0FBQUE7QUFFVCxpQkFBTyxhQUNILG1CQUFtQixDQUFDLFFBQVEsWUFDNUIsbUJBQW1CLENBQUMsT0FBTztBQUFBO0FBRWpDLDBCQUFrQixPQUFPLFdBQVcsUUFBUSxRQUFRO0FBQ2xELGdCQUFNLGFBQWE7QUFDbkIsY0FBSSxHQUFHLE1BQU0sUUFBUSxLQUFLLE9BQU87QUFDakMsZUFBSyxJQUFJLEdBQUcsT0FBTyxNQUFNLFFBQVEsUUFBUSxHQUFHLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDekQscUJBQVMsTUFBTTtBQUNmLGtCQUFNLE9BQU87QUFDYixnQkFBSSxPQUNGLE9BQU8sU0FBUyxVQUFVLEdBQzFCLE9BQU8sVUFBVSxVQUFVLEdBQzNCLFdBQVcsT0FBTyxZQUFZO0FBRWhDLGtCQUFNLEVBQUMsTUFBTSxVQUFTLFdBQVcsV0FBVyxRQUFRLFFBQVE7QUFDNUQscUJBQVMsUUFBUSxXQUFXO0FBQzVCLHNCQUFVLFdBQVc7QUFDckIsZ0JBQUksQ0FBQyxJQUFJLFVBQVU7QUFDakIseUJBQVcsS0FBSztBQUFBO0FBQUE7QUFHcEIsaUJBQU8sU0FBUyxTQUFTLFlBQVksV0FBVyxRQUFRLFdBQVc7QUFBQTtBQUVyRSw0QkFBb0IsS0FBSyxNQUFNLEtBQUssT0FBTyxRQUFRO0FBQ2pELGNBQUksTUFBTTtBQUNWLGNBQUksT0FBTztBQUNYLGNBQUksUUFBUSxPQUFPO0FBQ25CLGNBQUksU0FBUyxNQUFNO0FBQ25CLGNBQUksUUFBUTtBQUNaLGNBQUksU0FBUztBQUFBO0FBRWYsNEJBQW9CLE9BQU8sV0FBVyxRQUFRLFFBQVE7QUFDcEQsZ0JBQU0sY0FBYyxPQUFPO0FBQzNCLGNBQUksRUFBQyxHQUFHLE1BQUs7QUFDYixxQkFBVyxVQUFVLE9BQU87QUFDMUIsa0JBQU0sTUFBTSxPQUFPO0FBQ25CLGtCQUFNLFFBQVEsT0FBTyxPQUFPLFVBQVUsRUFBQyxPQUFPLEdBQUcsUUFBUSxHQUFHLFFBQVE7QUFDcEUsa0JBQU0sU0FBVSxPQUFPLGNBQWMsTUFBTSxVQUFXO0FBQ3RELGdCQUFJLE9BQU8sWUFBWTtBQUNyQixvQkFBTSxRQUFRLFVBQVUsSUFBSTtBQUM1QixvQkFBTSxTQUFTLE1BQU0sUUFBUSxJQUFJO0FBQ2pDLGtCQUFJLFFBQVEsTUFBTSxRQUFRO0FBQ3hCLG9CQUFJLE1BQU07QUFBQTtBQUVaLGtCQUFJLElBQUksVUFBVTtBQUNoQiwyQkFBVyxLQUFLLFlBQVksTUFBTSxHQUFHLE9BQU8sYUFBYSxZQUFZLFFBQVEsWUFBWSxNQUFNO0FBQUEscUJBQzFGO0FBQ0wsMkJBQVcsS0FBSyxVQUFVLE9BQU8sTUFBTSxRQUFRLEdBQUcsT0FBTztBQUFBO0FBRTNELG9CQUFNLFFBQVE7QUFDZCxvQkFBTSxVQUFVO0FBQ2hCLGtCQUFJLElBQUk7QUFBQSxtQkFDSDtBQUNMLG9CQUFNLFNBQVMsVUFBVSxJQUFJO0FBQzdCLG9CQUFNLFFBQVEsTUFBTSxRQUFRLElBQUk7QUFDaEMsa0JBQUksUUFBUSxNQUFNLFFBQVE7QUFDeEIsb0JBQUksTUFBTTtBQUFBO0FBRVosa0JBQUksSUFBSSxVQUFVO0FBQ2hCLDJCQUFXLEtBQUssR0FBRyxZQUFZLEtBQUssT0FBTyxPQUFPLGNBQWMsWUFBWSxTQUFTLFlBQVk7QUFBQSxxQkFDNUY7QUFDTCwyQkFBVyxLQUFLLEdBQUcsVUFBVSxNQUFNLE1BQU0sUUFBUSxPQUFPO0FBQUE7QUFFMUQsb0JBQU0sUUFBUTtBQUNkLG9CQUFNLFVBQVU7QUFDaEIsa0JBQUksSUFBSTtBQUFBO0FBQUE7QUFHWixvQkFBVSxJQUFJO0FBQ2Qsb0JBQVUsSUFBSTtBQUFBO0FBRWhCLGlCQUFTLElBQUksVUFBVTtBQUFBLFVBQ3JCLGFBQWE7QUFBQSxVQUNiLFNBQVM7QUFBQSxZQUNQLEtBQUs7QUFBQSxZQUNMLE9BQU87QUFBQSxZQUNQLFFBQVE7QUFBQSxZQUNSLE1BQU07QUFBQTtBQUFBO0FBR1YsWUFBSSxVQUFVO0FBQUEsVUFDWixPQUFPLFFBQU8sTUFBTTtBQUNsQixnQkFBSSxDQUFDLE9BQU0sT0FBTztBQUNoQixxQkFBTSxRQUFRO0FBQUE7QUFFaEIsaUJBQUssV0FBVyxLQUFLLFlBQVk7QUFDakMsaUJBQUssV0FBVyxLQUFLLFlBQVk7QUFDakMsaUJBQUssU0FBUyxLQUFLLFVBQVU7QUFDN0IsaUJBQUssVUFBVSxLQUFLLFdBQVcsV0FBVztBQUN4QyxxQkFBTyxDQUFDO0FBQUEsZ0JBQ04sR0FBRztBQUFBLGdCQUNILEtBQUssV0FBVztBQUNkLHVCQUFLLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFJaEIsbUJBQU0sTUFBTSxLQUFLO0FBQUE7QUFBQSxVQUVuQixVQUFVLFFBQU8sWUFBWTtBQUMzQixrQkFBTSxTQUFRLE9BQU0sUUFBUSxPQUFNLE1BQU0sUUFBUSxjQUFjO0FBQzlELGdCQUFJLFdBQVUsSUFBSTtBQUNoQixxQkFBTSxNQUFNLE9BQU8sUUFBTztBQUFBO0FBQUE7QUFBQSxVQUc5QixVQUFVLFFBQU8sTUFBTSxTQUFTO0FBQzlCLGlCQUFLLFdBQVcsUUFBUTtBQUN4QixpQkFBSyxXQUFXLFFBQVE7QUFDeEIsaUJBQUssU0FBUyxRQUFRO0FBQUE7QUFBQSxVQUV4QixPQUFPLFFBQU8sT0FBTyxRQUFRLFlBQVk7QUFDdkMsZ0JBQUksQ0FBQyxRQUFPO0FBQ1Y7QUFBQTtBQUVGLGtCQUFNLFVBQVUsVUFBVSxPQUFNLFFBQVEsT0FBTztBQUMvQyxrQkFBTSxpQkFBaUIsS0FBSyxJQUFJLFFBQVEsUUFBUSxPQUFPO0FBQ3ZELGtCQUFNLGtCQUFrQixLQUFLLElBQUksU0FBUyxRQUFRLFFBQVE7QUFDMUQsa0JBQU0sUUFBUSxpQkFBaUIsT0FBTTtBQUNyQyxrQkFBTSxnQkFBZ0IsTUFBTTtBQUM1QixrQkFBTSxrQkFBa0IsTUFBTTtBQUM5QixpQkFBSyxPQUFNLE9BQU8sU0FBTztBQUN2QixrQkFBSSxPQUFPLElBQUksaUJBQWlCLFlBQVk7QUFDMUMsb0JBQUk7QUFBQTtBQUFBO0FBR1Isa0JBQU0sMEJBQTBCLGNBQWMsT0FBTyxDQUFDLE9BQU8sU0FDM0QsS0FBSyxJQUFJLFdBQVcsS0FBSyxJQUFJLFFBQVEsWUFBWSxRQUFRLFFBQVEsUUFBUSxHQUFHLE1BQU07QUFDcEYsa0JBQU0sU0FBUyxPQUFPLE9BQU87QUFBQSxjQUMzQixZQUFZO0FBQUEsY0FDWixhQUFhO0FBQUEsY0FDYjtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsY0FDQSxjQUFjLGlCQUFpQixJQUFJO0FBQUEsY0FDbkMsZUFBZSxrQkFBa0I7QUFBQTtBQUVuQyxrQkFBTSxhQUFhLE9BQU8sT0FBTyxJQUFJO0FBQ3JDLDZCQUFpQixZQUFZLFVBQVU7QUFDdkMsa0JBQU0sWUFBWSxPQUFPLE9BQU87QUFBQSxjQUM5QjtBQUFBLGNBQ0EsR0FBRztBQUFBLGNBQ0gsR0FBRztBQUFBLGNBQ0gsR0FBRyxRQUFRO0FBQUEsY0FDWCxHQUFHLFFBQVE7QUFBQSxlQUNWO0FBQ0gsa0JBQU0sU0FBUyxjQUFjLGNBQWMsT0FBTyxrQkFBa0I7QUFDcEUscUJBQVMsTUFBTSxVQUFVLFdBQVcsUUFBUTtBQUM1QyxxQkFBUyxlQUFlLFdBQVcsUUFBUTtBQUMzQyxnQkFBSSxTQUFTLGlCQUFpQixXQUFXLFFBQVEsU0FBUztBQUN4RCx1QkFBUyxlQUFlLFdBQVcsUUFBUTtBQUFBO0FBRTdDLDZCQUFpQjtBQUNqQix1QkFBVyxNQUFNLFlBQVksV0FBVyxRQUFRO0FBQ2hELHNCQUFVLEtBQUssVUFBVTtBQUN6QixzQkFBVSxLQUFLLFVBQVU7QUFDekIsdUJBQVcsTUFBTSxnQkFBZ0IsV0FBVyxRQUFRO0FBQ3BELG1CQUFNLFlBQVk7QUFBQSxjQUNoQixNQUFNLFVBQVU7QUFBQSxjQUNoQixLQUFLLFVBQVU7QUFBQSxjQUNmLE9BQU8sVUFBVSxPQUFPLFVBQVU7QUFBQSxjQUNsQyxRQUFRLFVBQVUsTUFBTSxVQUFVO0FBQUEsY0FDbEMsUUFBUSxVQUFVO0FBQUEsY0FDbEIsT0FBTyxVQUFVO0FBQUE7QUFFbkIsaUJBQUssTUFBTSxXQUFXLENBQUMsV0FBVztBQUNoQyxvQkFBTSxNQUFNLE9BQU87QUFDbkIscUJBQU8sT0FBTyxLQUFLLE9BQU07QUFDekIsa0JBQUksT0FBTyxVQUFVLEdBQUcsVUFBVSxHQUFHLEVBQUMsTUFBTSxHQUFHLEtBQUssR0FBRyxPQUFPLEdBQUcsUUFBUTtBQUFBO0FBQUE7QUFBQTtBQUsvRSwyQkFBbUI7QUFBQSxVQUNqQixlQUFlLFFBQVEsYUFBYTtBQUFBO0FBQUEsVUFDcEMsZUFBZSxTQUFTO0FBQ3RCLG1CQUFPO0FBQUE7QUFBQSxVQUVULGlCQUFpQixRQUFPLE1BQU0sVUFBVTtBQUFBO0FBQUEsVUFDeEMsb0JBQW9CLFFBQU8sTUFBTSxVQUFVO0FBQUE7QUFBQSxVQUMzQyxzQkFBc0I7QUFDcEIsbUJBQU87QUFBQTtBQUFBLFVBRVQsZUFBZSxTQUFTLE9BQU8sUUFBUSxhQUFhO0FBQ2xELG9CQUFRLEtBQUssSUFBSSxHQUFHLFNBQVMsUUFBUTtBQUNyQyxxQkFBUyxVQUFVLFFBQVE7QUFDM0IsbUJBQU87QUFBQSxjQUNMO0FBQUEsY0FDQSxRQUFRLEtBQUssSUFBSSxHQUFHLGNBQWMsS0FBSyxNQUFNLFFBQVEsZUFBZTtBQUFBO0FBQUE7QUFBQSxVQUd4RSxXQUFXLFFBQVE7QUFDakIsbUJBQU87QUFBQTtBQUFBLFVBRVQsYUFBYSxRQUFRO0FBQUE7QUFBQTtBQUl2QixvQ0FBNEIsYUFBYTtBQUFBLFVBQ3ZDLGVBQWUsTUFBTTtBQUNuQixtQkFBTyxRQUFRLEtBQUssY0FBYyxLQUFLLFdBQVcsU0FBUztBQUFBO0FBQUEsVUFFN0QsYUFBYSxRQUFRO0FBQ25CLG1CQUFPLFFBQVEsWUFBWTtBQUFBO0FBQUE7QUFJL0IsY0FBTSxjQUFjO0FBQ3BCLGNBQU0sY0FBYztBQUFBLFVBQ2xCLFlBQVk7QUFBQSxVQUNaLFdBQVc7QUFBQSxVQUNYLFVBQVU7QUFBQSxVQUNWLGNBQWM7QUFBQSxVQUNkLGFBQWE7QUFBQSxVQUNiLGFBQWE7QUFBQSxVQUNiLFdBQVc7QUFBQSxVQUNYLGNBQWM7QUFBQSxVQUNkLFlBQVk7QUFBQTtBQUVkLGNBQU0sZ0JBQWdCLFdBQVMsVUFBVSxRQUFRLFVBQVU7QUFDM0QsNEJBQW9CLFFBQVEsYUFBYTtBQUN2QyxnQkFBTSxRQUFRLE9BQU87QUFDckIsZ0JBQU0sZUFBZSxPQUFPLGFBQWE7QUFDekMsZ0JBQU0sY0FBYyxPQUFPLGFBQWE7QUFDeEMsaUJBQU8sZUFBZTtBQUFBLFlBQ3BCLFNBQVM7QUFBQSxjQUNQLFFBQVE7QUFBQSxjQUNSLE9BQU87QUFBQSxjQUNQLE9BQU87QUFBQSxnQkFDTCxTQUFTLE1BQU07QUFBQSxnQkFDZixRQUFRLE1BQU07QUFBQSxnQkFDZCxPQUFPLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFJbkIsZ0JBQU0sVUFBVSxNQUFNLFdBQVc7QUFDakMsZ0JBQU0sWUFBWSxNQUFNLGFBQWE7QUFDckMsY0FBSSxjQUFjLGNBQWM7QUFDOUIsa0JBQU0sZUFBZSxhQUFhLFFBQVE7QUFDMUMsZ0JBQUksaUJBQWlCLFFBQVc7QUFDOUIscUJBQU8sUUFBUTtBQUFBO0FBQUE7QUFHbkIsY0FBSSxjQUFjLGVBQWU7QUFDL0IsZ0JBQUksT0FBTyxNQUFNLFdBQVcsSUFBSTtBQUM5QixxQkFBTyxTQUFTLE9BQU8sUUFBUyxnQkFBZTtBQUFBLG1CQUMxQztBQUNMLG9CQUFNLGdCQUFnQixhQUFhLFFBQVE7QUFDM0Msa0JBQUksa0JBQWtCLFFBQVc7QUFDL0IsdUJBQU8sU0FBUztBQUFBO0FBQUE7QUFBQTtBQUl0QixpQkFBTztBQUFBO0FBRVQsY0FBTSx1QkFBdUIsK0JBQStCLEVBQUMsU0FBUyxTQUFRO0FBQzlFLDZCQUFxQixNQUFNLE1BQU0sVUFBVTtBQUN6QyxlQUFLLGlCQUFpQixNQUFNLFVBQVU7QUFBQTtBQUV4QyxnQ0FBd0IsUUFBTyxNQUFNLFVBQVU7QUFDN0MsaUJBQU0sT0FBTyxvQkFBb0IsTUFBTSxVQUFVO0FBQUE7QUFFbkQsaUNBQXlCLE9BQU8sUUFBTztBQUNyQyxnQkFBTSxPQUFPLFlBQVksTUFBTSxTQUFTLE1BQU07QUFDOUMsZ0JBQU0sRUFBQyxHQUFHLE1BQUssb0JBQW9CLE9BQU87QUFDMUMsaUJBQU87QUFBQSxZQUNMO0FBQUEsWUFDQTtBQUFBLFlBQ0EsUUFBUTtBQUFBLFlBQ1IsR0FBRyxNQUFNLFNBQVksSUFBSTtBQUFBLFlBQ3pCLEdBQUcsTUFBTSxTQUFZLElBQUk7QUFBQTtBQUFBO0FBRzdCLGtDQUEwQixVQUFVLFFBQVE7QUFDMUMscUJBQVcsUUFBUSxVQUFVO0FBQzNCLGdCQUFJLFNBQVMsVUFBVSxLQUFLLFNBQVMsU0FBUztBQUM1QyxxQkFBTztBQUFBO0FBQUE7QUFBQTtBQUliLHNDQUE4QixRQUFPLE1BQU0sVUFBVTtBQUNuRCxnQkFBTSxTQUFTLE9BQU07QUFDckIsZ0JBQU0sV0FBVyxJQUFJLGlCQUFpQixhQUFXO0FBQy9DLGdCQUFJLFVBQVU7QUFDZCx1QkFBVyxTQUFTLFNBQVM7QUFDM0Isd0JBQVUsV0FBVyxpQkFBaUIsTUFBTSxZQUFZO0FBQ3hELHdCQUFVLFdBQVcsQ0FBQyxpQkFBaUIsTUFBTSxjQUFjO0FBQUE7QUFFN0QsZ0JBQUksU0FBUztBQUNYO0FBQUE7QUFBQTtBQUdKLG1CQUFTLFFBQVEsVUFBVSxFQUFDLFdBQVcsTUFBTSxTQUFTO0FBQ3RELGlCQUFPO0FBQUE7QUFFVCxzQ0FBOEIsUUFBTyxNQUFNLFVBQVU7QUFDbkQsZ0JBQU0sU0FBUyxPQUFNO0FBQ3JCLGdCQUFNLFdBQVcsSUFBSSxpQkFBaUIsYUFBVztBQUMvQyxnQkFBSSxVQUFVO0FBQ2QsdUJBQVcsU0FBUyxTQUFTO0FBQzNCLHdCQUFVLFdBQVcsaUJBQWlCLE1BQU0sY0FBYztBQUMxRCx3QkFBVSxXQUFXLENBQUMsaUJBQWlCLE1BQU0sWUFBWTtBQUFBO0FBRTNELGdCQUFJLFNBQVM7QUFDWDtBQUFBO0FBQUE7QUFHSixtQkFBUyxRQUFRLFVBQVUsRUFBQyxXQUFXLE1BQU0sU0FBUztBQUN0RCxpQkFBTztBQUFBO0FBRVQsY0FBTSxxQkFBcUIsb0JBQUk7QUFDL0IsWUFBSSxzQkFBc0I7QUFDMUIsa0NBQTBCO0FBQ3hCLGdCQUFNLE1BQU0sT0FBTztBQUNuQixjQUFJLFFBQVEscUJBQXFCO0FBQy9CO0FBQUE7QUFFRixnQ0FBc0I7QUFDdEIsNkJBQW1CLFFBQVEsQ0FBQyxRQUFRLFdBQVU7QUFDNUMsZ0JBQUksT0FBTSw0QkFBNEIsS0FBSztBQUN6QztBQUFBO0FBQUE7QUFBQTtBQUlOLCtDQUF1QyxRQUFPLFFBQVE7QUFDcEQsY0FBSSxDQUFDLG1CQUFtQixNQUFNO0FBQzVCLG1CQUFPLGlCQUFpQixVQUFVO0FBQUE7QUFFcEMsNkJBQW1CLElBQUksUUFBTztBQUFBO0FBRWhDLGlEQUF5QyxRQUFPO0FBQzlDLDZCQUFtQixPQUFPO0FBQzFCLGNBQUksQ0FBQyxtQkFBbUIsTUFBTTtBQUM1QixtQkFBTyxvQkFBb0IsVUFBVTtBQUFBO0FBQUE7QUFHekMsc0NBQThCLFFBQU8sTUFBTSxVQUFVO0FBQ25ELGdCQUFNLFNBQVMsT0FBTTtBQUNyQixnQkFBTSxZQUFZLFVBQVUsZUFBZTtBQUMzQyxjQUFJLENBQUMsV0FBVztBQUNkO0FBQUE7QUFFRixnQkFBTSxTQUFTLFVBQVUsQ0FBQyxPQUFPLFdBQVc7QUFDMUMsa0JBQU0sSUFBSSxVQUFVO0FBQ3BCLHFCQUFTLE9BQU87QUFDaEIsZ0JBQUksSUFBSSxVQUFVLGFBQWE7QUFDN0I7QUFBQTtBQUFBLGFBRUQ7QUFDSCxnQkFBTSxXQUFXLElBQUksZUFBZSxhQUFXO0FBQzdDLGtCQUFNLFFBQVEsUUFBUTtBQUN0QixrQkFBTSxRQUFRLE1BQU0sWUFBWTtBQUNoQyxrQkFBTSxTQUFTLE1BQU0sWUFBWTtBQUNqQyxnQkFBSSxVQUFVLEtBQUssV0FBVyxHQUFHO0FBQy9CO0FBQUE7QUFFRixtQkFBTyxPQUFPO0FBQUE7QUFFaEIsbUJBQVMsUUFBUTtBQUNqQix3Q0FBOEIsUUFBTztBQUNyQyxpQkFBTztBQUFBO0FBRVQsaUNBQXlCLFFBQU8sTUFBTSxVQUFVO0FBQzlDLGNBQUksVUFBVTtBQUNaLHFCQUFTO0FBQUE7QUFFWCxjQUFJLFNBQVMsVUFBVTtBQUNyQiw0Q0FBZ0M7QUFBQTtBQUFBO0FBR3BDLHNDQUE4QixRQUFPLE1BQU0sVUFBVTtBQUNuRCxnQkFBTSxTQUFTLE9BQU07QUFDckIsZ0JBQU0sUUFBUSxVQUFVLENBQUMsVUFBVTtBQUNqQyxnQkFBSSxPQUFNLFFBQVEsTUFBTTtBQUN0Qix1QkFBUyxnQkFBZ0IsT0FBTztBQUFBO0FBQUEsYUFFakMsUUFBTyxDQUFDLFNBQVM7QUFDbEIsa0JBQU0sUUFBUSxLQUFLO0FBQ25CLG1CQUFPLENBQUMsT0FBTyxNQUFNLFNBQVMsTUFBTTtBQUFBO0FBRXRDLHNCQUFZLFFBQVEsTUFBTTtBQUMxQixpQkFBTztBQUFBO0FBRVQsa0NBQTBCLGFBQWE7QUFBQSxVQUNyQyxlQUFlLFFBQVEsYUFBYTtBQUNsQyxrQkFBTSxVQUFVLFVBQVUsT0FBTyxjQUFjLE9BQU8sV0FBVztBQUNqRSxnQkFBSSxXQUFXLFFBQVEsV0FBVyxRQUFRO0FBQ3hDLHlCQUFXLFFBQVE7QUFDbkIscUJBQU87QUFBQTtBQUVULG1CQUFPO0FBQUE7QUFBQSxVQUVULGVBQWUsU0FBUztBQUN0QixrQkFBTSxTQUFTLFFBQVE7QUFDdkIsZ0JBQUksQ0FBQyxPQUFPLGNBQWM7QUFDeEIscUJBQU87QUFBQTtBQUVULGtCQUFNLFVBQVUsT0FBTyxhQUFhO0FBQ3BDLGFBQUMsVUFBVSxTQUFTLFFBQVEsQ0FBQyxTQUFTO0FBQ3BDLG9CQUFNLFFBQVEsUUFBUTtBQUN0QixrQkFBSSxjQUFjLFFBQVE7QUFDeEIsdUJBQU8sZ0JBQWdCO0FBQUEscUJBQ2xCO0FBQ0wsdUJBQU8sYUFBYSxNQUFNO0FBQUE7QUFBQTtBQUc5QixrQkFBTSxRQUFRLFFBQVEsU0FBUztBQUMvQixtQkFBTyxLQUFLLE9BQU8sUUFBUSxDQUFDLFFBQVE7QUFDbEMscUJBQU8sTUFBTSxPQUFPLE1BQU07QUFBQTtBQUU1QixtQkFBTyxRQUFRLE9BQU87QUFDdEIsbUJBQU8sT0FBTztBQUNkLG1CQUFPO0FBQUE7QUFBQSxVQUVULGlCQUFpQixRQUFPLE1BQU0sVUFBVTtBQUN0QyxpQkFBSyxvQkFBb0IsUUFBTztBQUNoQyxrQkFBTSxVQUFVLE9BQU0sWUFBYSxRQUFNLFdBQVc7QUFDcEQsa0JBQU0sV0FBVztBQUFBLGNBQ2YsUUFBUTtBQUFBLGNBQ1IsUUFBUTtBQUFBLGNBQ1IsUUFBUTtBQUFBO0FBRVYsa0JBQU0sVUFBVSxTQUFTLFNBQVM7QUFDbEMsb0JBQVEsUUFBUSxRQUFRLFFBQU8sTUFBTTtBQUFBO0FBQUEsVUFFdkMsb0JBQW9CLFFBQU8sTUFBTTtBQUMvQixrQkFBTSxVQUFVLE9BQU0sWUFBYSxRQUFNLFdBQVc7QUFDcEQsa0JBQU0sUUFBUSxRQUFRO0FBQ3RCLGdCQUFJLENBQUMsT0FBTztBQUNWO0FBQUE7QUFFRixrQkFBTSxXQUFXO0FBQUEsY0FDZixRQUFRO0FBQUEsY0FDUixRQUFRO0FBQUEsY0FDUixRQUFRO0FBQUE7QUFFVixrQkFBTSxVQUFVLFNBQVMsU0FBUztBQUNsQyxvQkFBUSxRQUFPLE1BQU07QUFDckIsb0JBQVEsUUFBUTtBQUFBO0FBQUEsVUFFbEIsc0JBQXNCO0FBQ3BCLG1CQUFPLE9BQU87QUFBQTtBQUFBLFVBRWhCLGVBQWUsUUFBUSxPQUFPLFFBQVEsYUFBYTtBQUNqRCxtQkFBTyxlQUFlLFFBQVEsT0FBTyxRQUFRO0FBQUE7QUFBQSxVQUUvQyxXQUFXLFFBQVE7QUFDakIsa0JBQU0sWUFBWSxlQUFlO0FBQ2pDLG1CQUFPLENBQUMsQ0FBRSxjQUFhLFVBQVU7QUFBQTtBQUFBO0FBSXJDLGlDQUF5QixRQUFRO0FBQy9CLGNBQUksQ0FBQyxxQkFBc0IsT0FBTyxvQkFBb0IsZUFBZSxrQkFBa0IsaUJBQWtCO0FBQ3ZHLG1CQUFPO0FBQUE7QUFFVCxpQkFBTztBQUFBO0FBR1QsWUFBSSxZQUF5Qix1QkFBTyxPQUFPO0FBQUEsVUFDM0MsV0FBVztBQUFBLFVBQ1g7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQTtBQUdBLGNBQU0sY0FBYztBQUNwQixjQUFNLGdCQUFnQjtBQUFBLFVBQ3BCLFFBQVEsT0FBTSxLQUFJLFFBQVE7QUFDeEIsbUJBQU8sU0FBUyxNQUFNLE1BQUs7QUFBQTtBQUFBLFVBRTdCLE1BQU0sT0FBTSxLQUFJLFFBQVE7QUFDdEIsa0JBQU0sS0FBSyxNQUFNLFNBQVE7QUFDekIsa0JBQU0sS0FBSyxHQUFHLFNBQVMsTUFBTSxPQUFNO0FBQ25DLG1CQUFPLE1BQU0sR0FBRyxRQUNaLEdBQUcsSUFBSSxJQUFJLFFBQVEsY0FDbkI7QUFBQTtBQUFBLFVBRU4sT0FBTyxPQUFNLEtBQUksUUFBUTtBQUN2QixtQkFBTyxRQUFRLE9BQUssU0FBUTtBQUFBO0FBQUE7QUFHaEMsd0JBQWdCO0FBQUEsVUFDZCxZQUFZLEtBQUssUUFBUSxNQUFNLEtBQUk7QUFDakMsa0JBQU0sZUFBZSxPQUFPO0FBQzVCLGtCQUFLLFFBQVEsQ0FBQyxJQUFJLElBQUksS0FBSSxjQUFjLElBQUk7QUFDNUMsa0JBQU0sUUFBTyxRQUFRLENBQUMsSUFBSSxNQUFNLGNBQWM7QUFDOUMsaUJBQUssVUFBVTtBQUNmLGlCQUFLLE1BQU0sSUFBSSxNQUFNLGNBQWMsSUFBSSxRQUFRLE9BQU87QUFDdEQsaUJBQUssVUFBVSxRQUFRLElBQUksV0FBVyxRQUFRO0FBQzlDLGlCQUFLLFNBQVMsS0FBSyxNQUFNLEtBQUssUUFBUyxLQUFJLFNBQVM7QUFDcEQsaUJBQUssWUFBWSxLQUFLLFNBQVMsS0FBSyxNQUFNLElBQUk7QUFDOUMsaUJBQUssUUFBUSxDQUFDLENBQUMsSUFBSTtBQUNuQixpQkFBSyxVQUFVO0FBQ2YsaUJBQUssUUFBUTtBQUNiLGlCQUFLLFFBQVE7QUFDYixpQkFBSyxNQUFNO0FBQ1gsaUJBQUssWUFBWTtBQUFBO0FBQUEsVUFFbkIsU0FBUztBQUNQLG1CQUFPLEtBQUs7QUFBQTtBQUFBLFVBRWQsT0FBTyxLQUFLLEtBQUksTUFBTTtBQUNwQixnQkFBSSxLQUFLLFNBQVM7QUFDaEIsbUJBQUssUUFBUTtBQUNiLG9CQUFNLGVBQWUsS0FBSyxRQUFRLEtBQUs7QUFDdkMsb0JBQU0sVUFBVSxPQUFPLEtBQUs7QUFDNUIsb0JBQU0sU0FBUyxLQUFLLFlBQVk7QUFDaEMsbUJBQUssU0FBUztBQUNkLG1CQUFLLFlBQVksS0FBSyxNQUFNLEtBQUssSUFBSSxRQUFRLElBQUk7QUFDakQsbUJBQUssVUFBVTtBQUNmLG1CQUFLLFFBQVEsQ0FBQyxDQUFDLElBQUk7QUFDbkIsbUJBQUssTUFBTSxRQUFRLENBQUMsSUFBSSxJQUFJLEtBQUksY0FBYyxJQUFJO0FBQ2xELG1CQUFLLFFBQVEsUUFBUSxDQUFDLElBQUksTUFBTSxjQUFjO0FBQUE7QUFBQTtBQUFBLFVBR2xELFNBQVM7QUFDUCxnQkFBSSxLQUFLLFNBQVM7QUFDaEIsbUJBQUssS0FBSyxLQUFLO0FBQ2YsbUJBQUssVUFBVTtBQUNmLG1CQUFLLFFBQVE7QUFBQTtBQUFBO0FBQUEsVUFHakIsS0FBSyxNQUFNO0FBQ1Qsa0JBQU0sVUFBVSxPQUFPLEtBQUs7QUFDNUIsa0JBQU0sV0FBVyxLQUFLO0FBQ3RCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxRQUFPLEtBQUs7QUFDbEIsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLE1BQUssS0FBSztBQUNoQixnQkFBSTtBQUNKLGlCQUFLLFVBQVUsVUFBUyxPQUFPLFNBQVMsVUFBVTtBQUNsRCxnQkFBSSxDQUFDLEtBQUssU0FBUztBQUNqQixtQkFBSyxRQUFRLFFBQVE7QUFDckIsbUJBQUssUUFBUTtBQUNiO0FBQUE7QUFFRixnQkFBSSxVQUFVLEdBQUc7QUFDZixtQkFBSyxRQUFRLFFBQVE7QUFDckI7QUFBQTtBQUVGLHFCQUFVLFVBQVUsV0FBWTtBQUNoQyxxQkFBUyxRQUFRLFNBQVMsSUFBSSxJQUFJLFNBQVM7QUFDM0MscUJBQVMsS0FBSyxRQUFRLEtBQUssSUFBSSxHQUFHLEtBQUssSUFBSSxHQUFHO0FBQzlDLGlCQUFLLFFBQVEsUUFBUSxLQUFLLElBQUksT0FBTSxLQUFJO0FBQUE7QUFBQSxVQUUxQyxPQUFPO0FBQ0wsa0JBQU0sV0FBVyxLQUFLLGFBQWMsTUFBSyxZQUFZO0FBQ3JELG1CQUFPLElBQUksUUFBUSxDQUFDLEtBQUssUUFBUTtBQUMvQix1QkFBUyxLQUFLLEVBQUMsS0FBSztBQUFBO0FBQUE7QUFBQSxVQUd4QixRQUFRLFVBQVU7QUFDaEIsa0JBQU0sU0FBUyxXQUFXLFFBQVE7QUFDbEMsa0JBQU0sV0FBVyxLQUFLLGFBQWE7QUFDbkMscUJBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxRQUFRLEtBQUs7QUFDeEMsdUJBQVMsR0FBRztBQUFBO0FBQUE7QUFBQTtBQUtsQixjQUFNLFVBQVUsQ0FBQyxLQUFLLEtBQUssZUFBZSxVQUFVO0FBQ3BELGNBQU0sVUFBUyxDQUFDLFNBQVMsZUFBZTtBQUN4QyxpQkFBUyxJQUFJLGFBQWE7QUFBQSxVQUN4QixPQUFPO0FBQUEsVUFDUCxVQUFVO0FBQUEsVUFDVixRQUFRO0FBQUEsVUFDUixJQUFJO0FBQUEsVUFDSixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixJQUFJO0FBQUEsVUFDSixNQUFNO0FBQUE7QUFFUixjQUFNLG1CQUFtQixPQUFPLEtBQUssU0FBUztBQUM5QyxpQkFBUyxTQUFTLGFBQWE7QUFBQSxVQUM3QixXQUFXO0FBQUEsVUFDWCxZQUFZO0FBQUEsVUFDWixhQUFhLENBQUMsU0FBUyxTQUFTLGdCQUFnQixTQUFTLGdCQUFnQixTQUFTO0FBQUE7QUFFcEYsaUJBQVMsSUFBSSxjQUFjO0FBQUEsVUFDekIsUUFBUTtBQUFBLFlBQ04sTUFBTTtBQUFBLFlBQ04sWUFBWTtBQUFBO0FBQUEsVUFFZCxTQUFTO0FBQUEsWUFDUCxNQUFNO0FBQUEsWUFDTixZQUFZO0FBQUE7QUFBQTtBQUdoQixpQkFBUyxTQUFTLGNBQWM7QUFBQSxVQUM5QixXQUFXO0FBQUE7QUFFYixpQkFBUyxJQUFJLGVBQWU7QUFBQSxVQUMxQixRQUFRO0FBQUEsWUFDTixXQUFXO0FBQUEsY0FDVCxVQUFVO0FBQUE7QUFBQTtBQUFBLFVBR2QsUUFBUTtBQUFBLFlBQ04sV0FBVztBQUFBLGNBQ1QsVUFBVTtBQUFBO0FBQUE7QUFBQSxVQUdkLE1BQU07QUFBQSxZQUNKLFlBQVk7QUFBQSxjQUNWLFFBQVE7QUFBQSxnQkFDTixNQUFNO0FBQUE7QUFBQSxjQUVSLFNBQVM7QUFBQSxnQkFDUCxNQUFNO0FBQUEsZ0JBQ04sVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBSWhCLE1BQU07QUFBQSxZQUNKLFlBQVk7QUFBQSxjQUNWLFFBQVE7QUFBQSxnQkFDTixJQUFJO0FBQUE7QUFBQSxjQUVOLFNBQVM7QUFBQSxnQkFDUCxNQUFNO0FBQUEsZ0JBQ04sUUFBUTtBQUFBLGdCQUNSLElBQUksT0FBSyxJQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLckIseUJBQWlCO0FBQUEsVUFDZixZQUFZLFFBQU8sUUFBUTtBQUN6QixpQkFBSyxTQUFTO0FBQ2QsaUJBQUssY0FBYyxvQkFBSTtBQUN2QixpQkFBSyxVQUFVO0FBQUE7QUFBQSxVQUVqQixVQUFVLFFBQVE7QUFDaEIsZ0JBQUksQ0FBQyxVQUFTLFNBQVM7QUFDckI7QUFBQTtBQUVGLGtCQUFNLGdCQUFnQixLQUFLO0FBQzNCLG1CQUFPLG9CQUFvQixRQUFRLFFBQVEsU0FBTztBQUNoRCxvQkFBTSxNQUFNLE9BQU87QUFDbkIsa0JBQUksQ0FBQyxVQUFTLE1BQU07QUFDbEI7QUFBQTtBQUVGLG9CQUFNLFdBQVc7QUFDakIseUJBQVcsVUFBVSxrQkFBa0I7QUFDckMseUJBQVMsVUFBVSxJQUFJO0FBQUE7QUFFekIsY0FBQyxTQUFRLElBQUksZUFBZSxJQUFJLGNBQWMsQ0FBQyxNQUFNLFFBQVEsQ0FBQyxTQUFTO0FBQ3JFLG9CQUFJLFNBQVMsT0FBTyxDQUFDLGNBQWMsSUFBSSxPQUFPO0FBQzVDLGdDQUFjLElBQUksTUFBTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFLaEMsZ0JBQWdCLFFBQVEsUUFBUTtBQUM5QixrQkFBTSxhQUFhLE9BQU87QUFDMUIsa0JBQU0sVUFBVSxxQkFBcUIsUUFBUTtBQUM3QyxnQkFBSSxDQUFDLFNBQVM7QUFDWixxQkFBTztBQUFBO0FBRVQsa0JBQU0sYUFBYSxLQUFLLGtCQUFrQixTQUFTO0FBQ25ELGdCQUFJLFdBQVcsU0FBUztBQUN0Qix1QkFBUyxPQUFPLFFBQVEsYUFBYSxZQUFZLEtBQUssTUFBTTtBQUMxRCx1QkFBTyxVQUFVO0FBQUEsaUJBQ2hCLE1BQU07QUFBQTtBQUFBO0FBR1gsbUJBQU87QUFBQTtBQUFBLFVBRVQsa0JBQWtCLFFBQVEsUUFBUTtBQUNoQyxrQkFBTSxnQkFBZ0IsS0FBSztBQUMzQixrQkFBTSxhQUFhO0FBQ25CLGtCQUFNLFVBQVUsT0FBTyxlQUFnQixRQUFPLGNBQWM7QUFDNUQsa0JBQU0sUUFBUSxPQUFPLEtBQUs7QUFDMUIsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGdCQUFJO0FBQ0osaUJBQUssSUFBSSxNQUFNLFNBQVMsR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQ3RDLG9CQUFNLE9BQU8sTUFBTTtBQUNuQixrQkFBSSxLQUFLLE9BQU8sT0FBTyxLQUFLO0FBQzFCO0FBQUE7QUFFRixrQkFBSSxTQUFTLFdBQVc7QUFDdEIsMkJBQVcsS0FBSyxHQUFHLEtBQUssZ0JBQWdCLFFBQVE7QUFDaEQ7QUFBQTtBQUVGLG9CQUFNLFFBQVEsT0FBTztBQUNyQixrQkFBSSxZQUFZLFFBQVE7QUFDeEIsb0JBQU0sTUFBTSxjQUFjLElBQUk7QUFDOUIsa0JBQUksV0FBVztBQUNiLG9CQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzdCLDRCQUFVLE9BQU8sS0FBSyxPQUFPO0FBQzdCO0FBQUEsdUJBQ0s7QUFDTCw0QkFBVTtBQUFBO0FBQUE7QUFHZCxrQkFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLFVBQVU7QUFDekIsdUJBQU8sUUFBUTtBQUNmO0FBQUE7QUFFRixzQkFBUSxRQUFRLFlBQVksSUFBSSxVQUFVLEtBQUssUUFBUSxNQUFNO0FBQzdELHlCQUFXLEtBQUs7QUFBQTtBQUVsQixtQkFBTztBQUFBO0FBQUEsVUFFVCxPQUFPLFFBQVEsUUFBUTtBQUNyQixnQkFBSSxLQUFLLFlBQVksU0FBUyxHQUFHO0FBQy9CLHFCQUFPLE9BQU8sUUFBUTtBQUN0QjtBQUFBO0FBRUYsa0JBQU0sYUFBYSxLQUFLLGtCQUFrQixRQUFRO0FBQ2xELGdCQUFJLFdBQVcsUUFBUTtBQUNyQix1QkFBUyxJQUFJLEtBQUssUUFBUTtBQUMxQixxQkFBTztBQUFBO0FBQUE7QUFBQTtBQUliLDBCQUFrQixZQUFZLFlBQVk7QUFDeEMsZ0JBQU0sVUFBVTtBQUNoQixnQkFBTSxPQUFPLE9BQU8sS0FBSztBQUN6QixtQkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNwQyxrQkFBTSxPQUFPLFdBQVcsS0FBSztBQUM3QixnQkFBSSxRQUFRLEtBQUssVUFBVTtBQUN6QixzQkFBUSxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3RCLGlCQUFPLFFBQVEsSUFBSTtBQUFBO0FBRXJCLHNDQUE4QixRQUFRLFlBQVk7QUFDaEQsY0FBSSxDQUFDLFlBQVk7QUFDZjtBQUFBO0FBRUYsY0FBSSxVQUFVLE9BQU87QUFDckIsY0FBSSxDQUFDLFNBQVM7QUFDWixtQkFBTyxVQUFVO0FBQ2pCO0FBQUE7QUFFRixjQUFJLFFBQVEsU0FBUztBQUNuQixtQkFBTyxVQUFVLFVBQVUsT0FBTyxPQUFPLElBQUksU0FBUyxFQUFDLFNBQVMsT0FBTyxhQUFhO0FBQUE7QUFFdEYsaUJBQU87QUFBQTtBQUdULDJCQUFtQixPQUFPLGlCQUFpQjtBQUN6QyxnQkFBTSxPQUFPLFNBQVMsTUFBTSxXQUFXO0FBQ3ZDLGdCQUFNLFVBQVUsS0FBSztBQUNyQixnQkFBTSxNQUFNLEtBQUssUUFBUSxTQUFZLGtCQUFrQjtBQUN2RCxnQkFBTSxNQUFNLEtBQUssUUFBUSxTQUFZLGtCQUFrQjtBQUN2RCxpQkFBTztBQUFBLFlBQ0wsT0FBTyxVQUFVLE1BQU07QUFBQSxZQUN2QixLQUFLLFVBQVUsTUFBTTtBQUFBO0FBQUE7QUFHekIsNkJBQXFCLFFBQVEsUUFBUSxpQkFBaUI7QUFDcEQsY0FBSSxvQkFBb0IsT0FBTztBQUM3QixtQkFBTztBQUFBO0FBRVQsZ0JBQU0sSUFBSSxVQUFVLFFBQVE7QUFDNUIsZ0JBQU0sSUFBSSxVQUFVLFFBQVE7QUFDNUIsaUJBQU87QUFBQSxZQUNMLEtBQUssRUFBRTtBQUFBLFlBQ1AsT0FBTyxFQUFFO0FBQUEsWUFDVCxRQUFRLEVBQUU7QUFBQSxZQUNWLE1BQU0sRUFBRTtBQUFBO0FBQUE7QUFHWix3QkFBZ0IsT0FBTztBQUNyQixjQUFJLEdBQUcsR0FBRyxHQUFHO0FBQ2IsY0FBSSxVQUFTLFFBQVE7QUFDbkIsZ0JBQUksTUFBTTtBQUNWLGdCQUFJLE1BQU07QUFDVixnQkFBSSxNQUFNO0FBQ1YsZ0JBQUksTUFBTTtBQUFBLGlCQUNMO0FBQ0wsZ0JBQUksSUFBSSxJQUFJLElBQUk7QUFBQTtBQUVsQixpQkFBTztBQUFBLFlBQ0wsS0FBSztBQUFBLFlBQ0wsT0FBTztBQUFBLFlBQ1AsUUFBUTtBQUFBLFlBQ1IsTUFBTTtBQUFBLFlBQ04sVUFBVSxVQUFVO0FBQUE7QUFBQTtBQUd4Qix5Q0FBaUMsUUFBTyxlQUFlO0FBQ3JELGdCQUFNLE9BQU87QUFDYixnQkFBTSxXQUFXLE9BQU0sdUJBQXVCO0FBQzlDLGNBQUksR0FBRztBQUNQLGVBQUssSUFBSSxHQUFHLE9BQU8sU0FBUyxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDakQsaUJBQUssS0FBSyxTQUFTLEdBQUc7QUFBQTtBQUV4QixpQkFBTztBQUFBO0FBRVQsNEJBQW9CLE9BQU8sT0FBTyxTQUFTLFVBQVUsSUFBSTtBQUN2RCxnQkFBTSxPQUFPLE1BQU07QUFDbkIsZ0JBQU0sYUFBYSxRQUFRLFNBQVM7QUFDcEMsY0FBSSxHQUFHLE1BQU0sY0FBYztBQUMzQixjQUFJLFVBQVUsTUFBTTtBQUNsQjtBQUFBO0FBRUYsZUFBSyxJQUFJLEdBQUcsT0FBTyxLQUFLLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUM3QywyQkFBZSxDQUFDLEtBQUs7QUFDckIsZ0JBQUksaUJBQWlCLFNBQVM7QUFDNUIsa0JBQUksUUFBUSxLQUFLO0FBQ2Y7QUFBQTtBQUVGO0FBQUE7QUFFRix5QkFBYSxNQUFNLE9BQU87QUFDMUIsZ0JBQUksZUFBZSxlQUFnQixlQUFlLFdBQVUsS0FBSyxLQUFLLFdBQVcsS0FBSyxlQUFlO0FBQ25HLHVCQUFTO0FBQUE7QUFBQTtBQUdiLGlCQUFPO0FBQUE7QUFFVCwwQ0FBa0MsTUFBTTtBQUN0QyxnQkFBTSxPQUFPLE9BQU8sS0FBSztBQUN6QixnQkFBTSxRQUFRLElBQUksTUFBTSxLQUFLO0FBQzdCLGNBQUksR0FBRyxNQUFNO0FBQ2IsZUFBSyxJQUFJLEdBQUcsT0FBTyxLQUFLLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUM3QyxrQkFBTSxLQUFLO0FBQ1gsa0JBQU0sS0FBSztBQUFBLGNBQ1QsR0FBRztBQUFBLGNBQ0gsR0FBRyxLQUFLO0FBQUE7QUFBQTtBQUdaLGlCQUFPO0FBQUE7QUFFVCwyQkFBbUIsT0FBTyxNQUFNO0FBQzlCLGdCQUFNLFVBQVUsU0FBUyxNQUFNLFFBQVE7QUFDdkMsaUJBQU8sV0FBWSxZQUFZLFVBQWEsS0FBSyxVQUFVO0FBQUE7QUFFN0QsNkJBQXFCLFlBQVksWUFBWSxNQUFNO0FBQ2pELGlCQUFPLEdBQUcsV0FBVyxNQUFNLFdBQVcsTUFBTSxLQUFLLFNBQVMsS0FBSztBQUFBO0FBRWpFLCtCQUF1QixPQUFPO0FBQzVCLGdCQUFNLEVBQUMsS0FBSyxLQUFLLFlBQVksZUFBYyxNQUFNO0FBQ2pELGlCQUFPO0FBQUEsWUFDTCxLQUFLLGFBQWEsTUFBTSxPQUFPO0FBQUEsWUFDL0IsS0FBSyxhQUFhLE1BQU0sT0FBTztBQUFBO0FBQUE7QUFHbkMsa0NBQTBCLFFBQVEsVUFBVSxZQUFZO0FBQ3RELGdCQUFNLFdBQVcsT0FBTyxhQUFjLFFBQU8sWUFBWTtBQUN6RCxpQkFBTyxTQUFTLGVBQWdCLFVBQVMsY0FBYztBQUFBO0FBRXpELHFDQUE2QixPQUFPLFFBQVEsVUFBVSxNQUFNO0FBQzFELHFCQUFXLFFBQVEsT0FBTyx3QkFBd0IsTUFBTSxXQUFXO0FBQ2pFLGtCQUFNLFFBQVEsTUFBTSxLQUFLO0FBQ3pCLGdCQUFLLFlBQVksUUFBUSxLQUFPLENBQUMsWUFBWSxRQUFRLEdBQUk7QUFDdkQscUJBQU8sS0FBSztBQUFBO0FBQUE7QUFHaEIsaUJBQU87QUFBQTtBQUVULDhCQUFzQixZQUFZLFFBQVE7QUFDeEMsZ0JBQU0sRUFBQyxlQUFPLGFBQWEsU0FBUTtBQUNuQyxnQkFBTSxTQUFTLE9BQU0sV0FBWSxRQUFNLFVBQVU7QUFDakQsZ0JBQU0sRUFBQyxRQUFRLFFBQVEsT0FBTyxpQkFBZ0I7QUFDOUMsZ0JBQU0sUUFBUSxPQUFPO0FBQ3JCLGdCQUFNLFFBQVEsT0FBTztBQUNyQixnQkFBTSxNQUFNLFlBQVksUUFBUSxRQUFRO0FBQ3hDLGdCQUFNLE9BQU8sT0FBTztBQUNwQixjQUFJO0FBQ0osbUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDN0Isa0JBQU0sT0FBTyxPQUFPO0FBQ3BCLGtCQUFNLEdBQUUsUUFBUSxTQUFRLFFBQVEsVUFBUztBQUN6QyxrQkFBTSxhQUFhLEtBQUssV0FBWSxNQUFLLFVBQVU7QUFDbkQsb0JBQVEsV0FBVyxTQUFTLGlCQUFpQixRQUFRLEtBQUs7QUFDMUQsa0JBQU0sZ0JBQWdCO0FBQ3RCLGtCQUFNLE9BQU8sb0JBQW9CLE9BQU8sUUFBUSxNQUFNLEtBQUs7QUFDM0Qsa0JBQU0sVUFBVSxvQkFBb0IsT0FBTyxRQUFRLE9BQU8sS0FBSztBQUFBO0FBQUE7QUFHbkUsaUNBQXlCLFFBQU8sTUFBTTtBQUNwQyxnQkFBTSxVQUFTLE9BQU07QUFDckIsaUJBQU8sT0FBTyxLQUFLLFNBQVEsT0FBTyxTQUFPLFFBQU8sS0FBSyxTQUFTLE1BQU07QUFBQTtBQUV0RSxzQ0FBOEIsUUFBUSxRQUFPO0FBQzNDLGlCQUFPLGNBQWMsUUFDbkI7QUFBQSxZQUNFLFFBQVE7QUFBQSxZQUNSLFNBQVM7QUFBQSxZQUNULGNBQWM7QUFBQSxZQUNkO0FBQUEsWUFDQSxNQUFNO0FBQUEsWUFDTixNQUFNO0FBQUE7QUFBQTtBQUlaLG1DQUEyQixRQUFRLFFBQU8sU0FBUztBQUNqRCxpQkFBTyxjQUFjLFFBQVE7QUFBQSxZQUMzQixRQUFRO0FBQUEsWUFDUixXQUFXO0FBQUEsWUFDWCxRQUFRO0FBQUEsWUFDUixLQUFLO0FBQUEsWUFDTDtBQUFBLFlBQ0E7QUFBQSxZQUNBLE1BQU07QUFBQSxZQUNOLE1BQU07QUFBQTtBQUFBO0FBR1YsNkJBQXFCLE1BQU0sT0FBTztBQUNoQyxnQkFBTSxlQUFlLEtBQUssV0FBVztBQUNyQyxnQkFBTSxPQUFPLEtBQUssVUFBVSxLQUFLLE9BQU87QUFDeEMsY0FBSSxDQUFDLE1BQU07QUFDVDtBQUFBO0FBRUYsa0JBQVEsU0FBUyxLQUFLO0FBQ3RCLHFCQUFXLFVBQVUsT0FBTztBQUMxQixrQkFBTSxTQUFTLE9BQU87QUFDdEIsZ0JBQUksQ0FBQyxVQUFVLE9BQU8sVUFBVSxVQUFhLE9BQU8sTUFBTSxrQkFBa0IsUUFBVztBQUNyRjtBQUFBO0FBRUYsbUJBQU8sT0FBTyxNQUFNO0FBQUE7QUFBQTtBQUd4QixjQUFNLHFCQUFxQixDQUFDLFNBQVMsU0FBUyxXQUFXLFNBQVM7QUFDbEUsY0FBTSxtQkFBbUIsQ0FBQyxRQUFRLFdBQVcsU0FBUyxTQUFTLE9BQU8sT0FBTyxJQUFJO0FBQ2pGLGNBQU0sY0FBYyxDQUFDLFVBQVUsTUFBTSxXQUFVLFlBQVksQ0FBQyxLQUFLLFVBQVUsS0FBSyxZQUMzRSxFQUFDLE1BQU0sd0JBQXdCLFFBQU8sT0FBTyxRQUFRO0FBQzFELGdDQUF3QjtBQUFBLFVBQ3RCLFlBQVksUUFBTyxjQUFjO0FBQy9CLGlCQUFLLFFBQVE7QUFDYixpQkFBSyxPQUFPLE9BQU07QUFDbEIsaUJBQUssUUFBUTtBQUNiLGlCQUFLLGtCQUFrQjtBQUN2QixpQkFBSyxjQUFjLEtBQUs7QUFDeEIsaUJBQUssUUFBUSxLQUFLLFlBQVk7QUFDOUIsaUJBQUssVUFBVTtBQUNmLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssUUFBUTtBQUNiLGlCQUFLLGNBQWM7QUFDbkIsaUJBQUssaUJBQWlCO0FBQ3RCLGlCQUFLLGFBQWE7QUFDbEIsaUJBQUssYUFBYTtBQUNsQixpQkFBSyxzQkFBc0I7QUFDM0IsaUJBQUsscUJBQXFCO0FBQzFCLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssWUFBWTtBQUNqQixpQkFBSztBQUFBO0FBQUEsVUFFUCxhQUFhO0FBQ1gsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGlCQUFLO0FBQ0wsaUJBQUs7QUFDTCxpQkFBSyxXQUFXLFVBQVUsS0FBSyxRQUFRO0FBQ3ZDLGlCQUFLO0FBQUE7QUFBQSxVQUVQLFlBQVksY0FBYztBQUN4QixnQkFBSSxLQUFLLFVBQVUsY0FBYztBQUMvQiwwQkFBWSxLQUFLO0FBQUE7QUFFbkIsaUJBQUssUUFBUTtBQUFBO0FBQUEsVUFFZixhQUFhO0FBQ1gsa0JBQU0sU0FBUSxLQUFLO0FBQ25CLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxVQUFVLEtBQUs7QUFDckIsa0JBQU0sV0FBVyxDQUFDLE1BQU0sR0FBRyxHQUFHLE1BQU0sU0FBUyxNQUFNLElBQUksU0FBUyxNQUFNLElBQUk7QUFDMUUsa0JBQU0sTUFBTSxLQUFLLFVBQVUsZUFBZSxRQUFRLFNBQVMsZ0JBQWdCLFFBQU87QUFDbEYsa0JBQU0sTUFBTSxLQUFLLFVBQVUsZUFBZSxRQUFRLFNBQVMsZ0JBQWdCLFFBQU87QUFDbEYsa0JBQU0sTUFBTSxLQUFLLFVBQVUsZUFBZSxRQUFRLFNBQVMsZ0JBQWdCLFFBQU87QUFDbEYsa0JBQU0sWUFBWSxLQUFLO0FBQ3ZCLGtCQUFNLE1BQU0sS0FBSyxVQUFVLFNBQVMsV0FBVyxLQUFLLEtBQUs7QUFDekQsa0JBQU0sTUFBTSxLQUFLLFVBQVUsU0FBUyxXQUFXLEtBQUssS0FBSztBQUN6RCxpQkFBSyxTQUFTLEtBQUssY0FBYztBQUNqQyxpQkFBSyxTQUFTLEtBQUssY0FBYztBQUNqQyxpQkFBSyxTQUFTLEtBQUssY0FBYztBQUNqQyxpQkFBSyxTQUFTLEtBQUssY0FBYztBQUNqQyxpQkFBSyxTQUFTLEtBQUssY0FBYztBQUFBO0FBQUEsVUFFbkMsYUFBYTtBQUNYLG1CQUFPLEtBQUssTUFBTSxLQUFLLFNBQVMsS0FBSztBQUFBO0FBQUEsVUFFdkMsVUFBVTtBQUNSLG1CQUFPLEtBQUssTUFBTSxlQUFlLEtBQUs7QUFBQTtBQUFBLFVBRXhDLGNBQWMsU0FBUztBQUNyQixtQkFBTyxLQUFLLE1BQU0sT0FBTztBQUFBO0FBQUEsVUFFM0IsZUFBZSxPQUFPO0FBQ3BCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixtQkFBTyxVQUFVLEtBQUssU0FDbEIsS0FBSyxTQUNMLEtBQUs7QUFBQTtBQUFBLFVBRVgsUUFBUTtBQUNOLGlCQUFLLFFBQVE7QUFBQTtBQUFBLFVBRWYsV0FBVztBQUNULGtCQUFNLE9BQU8sS0FBSztBQUNsQixnQkFBSSxLQUFLLE9BQU87QUFDZCxrQ0FBb0IsS0FBSyxPQUFPO0FBQUE7QUFFbEMsZ0JBQUksS0FBSyxVQUFVO0FBQ2pCLDBCQUFZO0FBQUE7QUFBQTtBQUFBLFVBR2hCLGFBQWE7QUFDWCxrQkFBTSxVQUFVLEtBQUs7QUFDckIsa0JBQU0sT0FBTyxRQUFRLFFBQVMsU0FBUSxPQUFPO0FBQzdDLGtCQUFNLFFBQVEsS0FBSztBQUNuQixnQkFBSSxVQUFTLE9BQU87QUFDbEIsbUJBQUssUUFBUSx5QkFBeUI7QUFBQSx1QkFDN0IsVUFBVSxNQUFNO0FBQ3pCLGtCQUFJLE9BQU87QUFDVCxvQ0FBb0IsT0FBTztBQUMzQixzQkFBTSxPQUFPLEtBQUs7QUFDbEIsNEJBQVk7QUFDWixxQkFBSyxVQUFVO0FBQUE7QUFFakIsa0JBQUksUUFBUSxPQUFPLGFBQWEsT0FBTztBQUNyQyxrQ0FBa0IsTUFBTTtBQUFBO0FBRTFCLG1CQUFLLFlBQVk7QUFDakIsbUJBQUssUUFBUTtBQUFBO0FBQUE7QUFBQSxVQUdqQixjQUFjO0FBQ1osa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGlCQUFLO0FBQ0wsZ0JBQUksS0FBSyxvQkFBb0I7QUFDM0IsbUJBQUssVUFBVSxJQUFJLEtBQUs7QUFBQTtBQUFBO0FBQUEsVUFHNUIsc0JBQXNCLGtCQUFrQjtBQUN0QyxrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGdCQUFJLGVBQWU7QUFDbkIsaUJBQUs7QUFDTCxrQkFBTSxhQUFhLEtBQUs7QUFDeEIsaUJBQUssV0FBVyxVQUFVLEtBQUssUUFBUTtBQUN2QyxnQkFBSSxLQUFLLFVBQVUsUUFBUSxPQUFPO0FBQ2hDLDZCQUFlO0FBQ2YsMEJBQVk7QUFDWixtQkFBSyxRQUFRLFFBQVE7QUFBQTtBQUV2QixpQkFBSyxnQkFBZ0I7QUFDckIsZ0JBQUksZ0JBQWdCLGVBQWUsS0FBSyxVQUFVO0FBQ2hELDJCQUFhLE1BQU0sS0FBSztBQUFBO0FBQUE7QUFBQSxVQUc1QixZQUFZO0FBQ1Ysa0JBQU0sU0FBUyxLQUFLLE1BQU07QUFDMUIsa0JBQU0sWUFBWSxPQUFPLGlCQUFpQixLQUFLO0FBQy9DLGtCQUFNLFNBQVMsT0FBTyxnQkFBZ0IsS0FBSyxjQUFjLFdBQVc7QUFDcEUsaUJBQUssVUFBVSxPQUFPLGVBQWUsUUFBUSxLQUFLO0FBQ2xELGlCQUFLLFdBQVcsS0FBSyxRQUFRO0FBQzdCLGlCQUFLLGtCQUFrQjtBQUFBO0FBQUEsVUFFekIsTUFBTSxPQUFPLE9BQU87QUFDbEIsa0JBQU0sRUFBQyxhQUFhLE1BQU0sT0FBTyxTQUFRO0FBQ3pDLGtCQUFNLEVBQUMsUUFBUSxhQUFZO0FBQzNCLGtCQUFNLFFBQVEsT0FBTztBQUNyQixnQkFBSSxTQUFTLFVBQVUsS0FBSyxVQUFVLEtBQUssU0FBUyxPQUFPLEtBQUs7QUFDaEUsZ0JBQUksT0FBTyxRQUFRLEtBQUssS0FBSyxRQUFRLFFBQVE7QUFDN0MsZ0JBQUksR0FBRyxLQUFLO0FBQ1osZ0JBQUksS0FBSyxhQUFhLE9BQU87QUFDM0IsbUJBQUssVUFBVTtBQUNmLG1CQUFLLFVBQVU7QUFDZix1QkFBUztBQUFBLG1CQUNKO0FBQ0wsa0JBQUksUUFBUSxLQUFLLFNBQVM7QUFDeEIseUJBQVMsS0FBSyxlQUFlLE1BQU0sTUFBTSxPQUFPO0FBQUEseUJBQ3ZDLFVBQVMsS0FBSyxTQUFTO0FBQ2hDLHlCQUFTLEtBQUssZ0JBQWdCLE1BQU0sTUFBTSxPQUFPO0FBQUEscUJBQzVDO0FBQ0wseUJBQVMsS0FBSyxtQkFBbUIsTUFBTSxNQUFNLE9BQU87QUFBQTtBQUV0RCxvQkFBTSw2QkFBNkIsTUFBTSxJQUFJLFdBQVcsUUFBUyxRQUFRLElBQUksU0FBUyxLQUFLO0FBQzNGLG1CQUFLLElBQUksR0FBRyxJQUFJLE9BQU8sRUFBRSxHQUFHO0FBQzFCLHFCQUFLLFFBQVEsSUFBSSxTQUFTLE1BQU0sT0FBTztBQUN2QyxvQkFBSSxRQUFRO0FBQ1Ysc0JBQUksOEJBQThCO0FBQ2hDLDZCQUFTO0FBQUE7QUFFWCx5QkFBTztBQUFBO0FBQUE7QUFHWCxtQkFBSyxVQUFVO0FBQUE7QUFFakIsZ0JBQUksVUFBVTtBQUNaLDJCQUFhLE1BQU07QUFBQTtBQUFBO0FBQUEsVUFHdkIsbUJBQW1CLE1BQU0sTUFBTSxPQUFPLE9BQU87QUFDM0Msa0JBQU0sRUFBQyxRQUFRLFdBQVU7QUFDekIsa0JBQU0sUUFBUSxPQUFPO0FBQ3JCLGtCQUFNLFFBQVEsT0FBTztBQUNyQixrQkFBTSxTQUFTLE9BQU87QUFDdEIsa0JBQU0sY0FBYyxXQUFXO0FBQy9CLGtCQUFNLFNBQVMsSUFBSSxNQUFNO0FBQ3pCLGdCQUFJLEdBQUcsTUFBTTtBQUNiLGlCQUFLLElBQUksR0FBRyxPQUFPLE9BQU8sSUFBSSxNQUFNLEVBQUUsR0FBRztBQUN2Qyx1QkFBUSxJQUFJO0FBQ1oscUJBQU8sS0FBSztBQUFBLGlCQUNULFFBQVEsZUFBZSxPQUFPLE1BQU0sT0FBTyxTQUFRO0FBQUEsaUJBQ25ELFFBQVEsT0FBTyxNQUFNLEtBQUssU0FBUTtBQUFBO0FBQUE7QUFHdkMsbUJBQU87QUFBQTtBQUFBLFVBRVQsZUFBZSxNQUFNLE1BQU0sT0FBTyxPQUFPO0FBQ3ZDLGtCQUFNLEVBQUMsUUFBUSxXQUFVO0FBQ3pCLGtCQUFNLFNBQVMsSUFBSSxNQUFNO0FBQ3pCLGdCQUFJLEdBQUcsTUFBTSxRQUFPO0FBQ3BCLGlCQUFLLElBQUksR0FBRyxPQUFPLE9BQU8sSUFBSSxNQUFNLEVBQUUsR0FBRztBQUN2Qyx1QkFBUSxJQUFJO0FBQ1oscUJBQU8sS0FBSztBQUNaLHFCQUFPLEtBQUs7QUFBQSxnQkFDVixHQUFHLE9BQU8sTUFBTSxLQUFLLElBQUk7QUFBQSxnQkFDekIsR0FBRyxPQUFPLE1BQU0sS0FBSyxJQUFJO0FBQUE7QUFBQTtBQUc3QixtQkFBTztBQUFBO0FBQUEsVUFFVCxnQkFBZ0IsTUFBTSxNQUFNLE9BQU8sT0FBTztBQUN4QyxrQkFBTSxFQUFDLFFBQVEsV0FBVTtBQUN6QixrQkFBTSxFQUFDLFdBQVcsS0FBSyxXQUFXLFFBQU8sS0FBSztBQUM5QyxrQkFBTSxTQUFTLElBQUksTUFBTTtBQUN6QixnQkFBSSxHQUFHLE1BQU0sUUFBTztBQUNwQixpQkFBSyxJQUFJLEdBQUcsT0FBTyxPQUFPLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDdkMsdUJBQVEsSUFBSTtBQUNaLHFCQUFPLEtBQUs7QUFDWixxQkFBTyxLQUFLO0FBQUEsZ0JBQ1YsR0FBRyxPQUFPLE1BQU0saUJBQWlCLE1BQU0sV0FBVztBQUFBLGdCQUNsRCxHQUFHLE9BQU8sTUFBTSxpQkFBaUIsTUFBTSxXQUFXO0FBQUE7QUFBQTtBQUd0RCxtQkFBTztBQUFBO0FBQUEsVUFFVCxVQUFVLFFBQU87QUFDZixtQkFBTyxLQUFLLFlBQVksUUFBUTtBQUFBO0FBQUEsVUFFbEMsZUFBZSxRQUFPO0FBQ3BCLG1CQUFPLEtBQUssWUFBWSxLQUFLO0FBQUE7QUFBQSxVQUUvQixXQUFXLE9BQU8sUUFBUSxNQUFNO0FBQzlCLGtCQUFNLFNBQVEsS0FBSztBQUNuQixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sUUFBUSxPQUFPLE1BQU07QUFDM0Isa0JBQU0sUUFBUTtBQUFBLGNBQ1osTUFBTSx3QkFBd0IsUUFBTztBQUFBLGNBQ3JDLFFBQVEsT0FBTyxRQUFRLE1BQU07QUFBQTtBQUUvQixtQkFBTyxXQUFXLE9BQU8sT0FBTyxLQUFLLE9BQU8sRUFBQztBQUFBO0FBQUEsVUFFL0Msc0JBQXNCLFFBQU8sT0FBTyxRQUFRLE9BQU87QUFDakQsa0JBQU0sY0FBYyxPQUFPLE1BQU07QUFDakMsZ0JBQUksUUFBUSxnQkFBZ0IsT0FBTyxNQUFNO0FBQ3pDLGtCQUFNLFNBQVMsU0FBUyxPQUFPLFFBQVEsTUFBTTtBQUM3QyxnQkFBSSxTQUFTLFFBQVE7QUFDbkIsb0JBQU0sU0FBUztBQUNmLHNCQUFRLFdBQVcsT0FBTyxhQUFhLEtBQUssWUFBWTtBQUFBO0FBRTFELG1CQUFNLE1BQU0sS0FBSyxJQUFJLE9BQU0sS0FBSztBQUNoQyxtQkFBTSxNQUFNLEtBQUssSUFBSSxPQUFNLEtBQUs7QUFBQTtBQUFBLFVBRWxDLFVBQVUsT0FBTyxVQUFVO0FBQ3pCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxVQUFVLEtBQUs7QUFDckIsa0JBQU0sU0FBUyxLQUFLLFdBQVcsVUFBVSxLQUFLO0FBQzlDLGtCQUFNLE9BQU8sUUFBUTtBQUNyQixrQkFBTSxhQUFhLEtBQUssZUFBZTtBQUN2QyxrQkFBTSxRQUFRLFlBQVksVUFBVSxNQUFNLEtBQUs7QUFDL0Msa0JBQU0sU0FBUSxFQUFDLEtBQUssT0FBTyxtQkFBbUIsS0FBSyxPQUFPO0FBQzFELGtCQUFNLEVBQUMsS0FBSyxVQUFVLEtBQUssYUFBWSxjQUFjO0FBQ3JELGdCQUFJLEdBQUc7QUFDUCw2QkFBaUI7QUFDZix1QkFBUyxRQUFRO0FBQ2pCLG9CQUFNLGFBQWEsT0FBTyxXQUFXO0FBQ3JDLHFCQUFPLENBQUMsZUFBZSxPQUFPLE1BQU0sVUFBVSxXQUFXLGNBQWMsV0FBVztBQUFBO0FBRXBGLGlCQUFLLElBQUksR0FBRyxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ3pCLGtCQUFJLFNBQVM7QUFDWDtBQUFBO0FBRUYsbUJBQUssc0JBQXNCLFFBQU8sT0FBTyxRQUFRO0FBQ2pELGtCQUFJLFFBQVE7QUFDVjtBQUFBO0FBQUE7QUFHSixnQkFBSSxRQUFRO0FBQ1YsbUJBQUssSUFBSSxPQUFPLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUM5QixvQkFBSSxTQUFTO0FBQ1g7QUFBQTtBQUVGLHFCQUFLLHNCQUFzQixRQUFPLE9BQU8sUUFBUTtBQUNqRDtBQUFBO0FBQUE7QUFHSixtQkFBTztBQUFBO0FBQUEsVUFFVCxtQkFBbUIsT0FBTztBQUN4QixrQkFBTSxTQUFTLEtBQUssWUFBWTtBQUNoQyxrQkFBTSxTQUFTO0FBQ2YsZ0JBQUksR0FBRyxNQUFNO0FBQ2IsaUJBQUssSUFBSSxHQUFHLE9BQU8sT0FBTyxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDL0Msc0JBQVEsT0FBTyxHQUFHLE1BQU07QUFDeEIsa0JBQUksZUFBZSxRQUFRO0FBQ3pCLHVCQUFPLEtBQUs7QUFBQTtBQUFBO0FBR2hCLG1CQUFPO0FBQUE7QUFBQSxVQUVULGlCQUFpQjtBQUNmLG1CQUFPO0FBQUE7QUFBQSxVQUVULGlCQUFpQixRQUFPO0FBQ3RCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxTQUFTLEtBQUs7QUFDcEIsa0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGtCQUFNLFNBQVMsS0FBSyxVQUFVO0FBQzlCLG1CQUFPO0FBQUEsY0FDTCxPQUFPLFNBQVMsS0FBSyxPQUFPLGlCQUFpQixPQUFPLE9BQU8sU0FBUztBQUFBLGNBQ3BFLE9BQU8sU0FBUyxLQUFLLE9BQU8saUJBQWlCLE9BQU8sT0FBTyxTQUFTO0FBQUE7QUFBQTtBQUFBLFVBR3hFLFFBQVEsTUFBTTtBQUNaLGtCQUFNLE9BQU8sS0FBSztBQUNsQixpQkFBSyxPQUFPLFFBQVE7QUFDcEIsaUJBQUssUUFBUSxPQUFPLGVBQWUsS0FBSyxRQUFRLE1BQU0sWUFBWSxLQUFLLFFBQVEsS0FBSyxRQUFRLEtBQUs7QUFBQTtBQUFBLFVBRW5HLE9BQU8sTUFBTTtBQUFBO0FBQUEsVUFDYixPQUFPO0FBQ0wsa0JBQU0sTUFBTSxLQUFLO0FBQ2pCLGtCQUFNLFNBQVEsS0FBSztBQUNuQixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sWUFBVyxLQUFLLFFBQVE7QUFDOUIsa0JBQU0sT0FBTyxPQUFNO0FBQ25CLGtCQUFNLFNBQVM7QUFDZixrQkFBTSxRQUFRLEtBQUssY0FBYztBQUNqQyxrQkFBTSxRQUFRLEtBQUssY0FBZSxVQUFTLFNBQVM7QUFDcEQsa0JBQU0sMEJBQTBCLEtBQUssUUFBUTtBQUM3QyxnQkFBSTtBQUNKLGdCQUFJLEtBQUssU0FBUztBQUNoQixtQkFBSyxRQUFRLEtBQUssS0FBSyxNQUFNLE9BQU87QUFBQTtBQUV0QyxpQkFBSyxJQUFJLE9BQU8sSUFBSSxRQUFRLE9BQU8sRUFBRSxHQUFHO0FBQ3RDLG9CQUFNLFVBQVUsVUFBUztBQUN6QixrQkFBSSxRQUFRLFFBQVE7QUFDbEI7QUFBQTtBQUVGLGtCQUFJLFFBQVEsVUFBVSx5QkFBeUI7QUFDN0MsdUJBQU8sS0FBSztBQUFBLHFCQUNQO0FBQ0wsd0JBQVEsS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUd0QixpQkFBSyxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsRUFBRSxHQUFHO0FBQ2xDLHFCQUFPLEdBQUcsS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUFBLFVBR3hCLFNBQVMsUUFBTyxRQUFRO0FBQ3RCLGtCQUFNLE9BQU8sU0FBUyxXQUFXO0FBQ2pDLG1CQUFPLFdBQVUsVUFBYSxLQUFLLFlBQVksVUFDM0MsS0FBSyw2QkFBNkIsUUFDbEMsS0FBSywwQkFBMEIsVUFBUyxHQUFHO0FBQUE7QUFBQSxVQUVqRCxXQUFXLFFBQU8sUUFBUSxNQUFNO0FBQzlCLGtCQUFNLFVBQVUsS0FBSztBQUNyQixnQkFBSTtBQUNKLGdCQUFJLFVBQVMsS0FBSyxTQUFRLEtBQUssWUFBWSxLQUFLLFFBQVE7QUFDdEQsb0JBQU0sVUFBVSxLQUFLLFlBQVksS0FBSztBQUN0Qyx3QkFBVSxRQUFRLFlBQ2YsU0FBUSxXQUFXLGtCQUFrQixLQUFLLGNBQWMsUUFBTztBQUNsRSxzQkFBUSxTQUFTLEtBQUssVUFBVTtBQUNoQyxzQkFBUSxNQUFNLFFBQVEsS0FBSztBQUMzQixzQkFBUSxRQUFRLFFBQVEsWUFBWTtBQUFBLG1CQUMvQjtBQUNMLHdCQUFVLEtBQUssWUFDWixNQUFLLFdBQVcscUJBQXFCLEtBQUssTUFBTSxjQUFjLEtBQUs7QUFDdEUsc0JBQVEsVUFBVTtBQUNsQixzQkFBUSxRQUFRLFFBQVEsZUFBZSxLQUFLO0FBQUE7QUFFOUMsb0JBQVEsU0FBUyxDQUFDLENBQUM7QUFDbkIsb0JBQVEsT0FBTztBQUNmLG1CQUFPO0FBQUE7QUFBQSxVQUVULDZCQUE2QixNQUFNO0FBQ2pDLG1CQUFPLEtBQUssdUJBQXVCLEtBQUssbUJBQW1CLElBQUk7QUFBQTtBQUFBLFVBRWpFLDBCQUEwQixRQUFPLE1BQU07QUFDckMsbUJBQU8sS0FBSyx1QkFBdUIsS0FBSyxnQkFBZ0IsSUFBSSxNQUFNO0FBQUE7QUFBQSxVQUVwRSx1QkFBdUIsYUFBYSxPQUFPLFdBQVcsUUFBTztBQUMzRCxrQkFBTSxTQUFTLFNBQVM7QUFDeEIsa0JBQU0sUUFBUSxLQUFLO0FBQ25CLGtCQUFNLFdBQVcsY0FBYyxNQUFNO0FBQ3JDLGtCQUFNLFNBQVMsTUFBTTtBQUNyQixrQkFBTSxVQUFVLEtBQUssdUJBQXVCLFFBQVE7QUFDcEQsZ0JBQUksUUFBUTtBQUNWLHFCQUFPLGlCQUFpQixRQUFRO0FBQUE7QUFFbEMsa0JBQU0sU0FBUyxLQUFLLE1BQU07QUFDMUIsa0JBQU0sWUFBWSxPQUFPLHdCQUF3QixLQUFLLE9BQU87QUFDN0Qsa0JBQU0sV0FBVyxTQUFTLENBQUMsR0FBRyxvQkFBb0IsU0FBUyxhQUFhLE1BQU0sQ0FBQyxhQUFhO0FBQzVGLGtCQUFNLFNBQVMsT0FBTyxnQkFBZ0IsS0FBSyxjQUFjO0FBQ3pELGtCQUFNLFNBQVEsT0FBTyxLQUFLLFNBQVMsU0FBUztBQUM1QyxrQkFBTSxVQUFVLE1BQU0sS0FBSyxXQUFXLFFBQU87QUFDN0Msa0JBQU0sU0FBUyxPQUFPLG9CQUFvQixRQUFRLFFBQU8sU0FBUztBQUNsRSxnQkFBSSxPQUFPLFNBQVM7QUFDbEIscUJBQU8sVUFBVTtBQUNqQixvQkFBTSxZQUFZLE9BQU8sT0FBTyxpQkFBaUIsUUFBUTtBQUFBO0FBRTNELG1CQUFPO0FBQUE7QUFBQSxVQUVULG1CQUFtQixRQUFPLFlBQVksUUFBUTtBQUM1QyxrQkFBTSxTQUFRLEtBQUs7QUFDbkIsa0JBQU0sUUFBUSxLQUFLO0FBQ25CLGtCQUFNLFdBQVcsYUFBYTtBQUM5QixrQkFBTSxTQUFTLE1BQU07QUFDckIsZ0JBQUksUUFBUTtBQUNWLHFCQUFPO0FBQUE7QUFFVCxnQkFBSTtBQUNKLGdCQUFJLE9BQU0sUUFBUSxjQUFjLE9BQU87QUFDckMsb0JBQU0sU0FBUyxLQUFLLE1BQU07QUFDMUIsb0JBQU0sWUFBWSxPQUFPLDBCQUEwQixLQUFLLE9BQU87QUFDL0Qsb0JBQU0sU0FBUyxPQUFPLGdCQUFnQixLQUFLLGNBQWM7QUFDekQsd0JBQVUsT0FBTyxlQUFlLFFBQVEsS0FBSyxXQUFXLFFBQU8sUUFBUTtBQUFBO0FBRXpFLGtCQUFNLGFBQWEsSUFBSSxXQUFXLFFBQU8sV0FBVyxRQUFRO0FBQzVELGdCQUFJLFdBQVcsUUFBUSxZQUFZO0FBQ2pDLG9CQUFNLFlBQVksT0FBTyxPQUFPO0FBQUE7QUFFbEMsbUJBQU87QUFBQTtBQUFBLFVBRVQsaUJBQWlCLFNBQVM7QUFDeEIsZ0JBQUksQ0FBQyxRQUFRLFNBQVM7QUFDcEI7QUFBQTtBQUVGLG1CQUFPLEtBQUssa0JBQW1CLE1BQUssaUJBQWlCLE9BQU8sT0FBTyxJQUFJO0FBQUE7QUFBQSxVQUV6RSxlQUFlLE1BQU0sZUFBZTtBQUNsQyxtQkFBTyxDQUFDLGlCQUFpQixtQkFBbUIsU0FBUyxLQUFLLE1BQU07QUFBQTtBQUFBLFVBRWxFLGtCQUFrQixPQUFPLE1BQU07QUFDN0Isa0JBQU0sWUFBWSxLQUFLLDBCQUEwQixPQUFPO0FBQ3hELGtCQUFNLDBCQUEwQixLQUFLO0FBQ3JDLGtCQUFNLGdCQUFnQixLQUFLLGlCQUFpQjtBQUM1QyxrQkFBTSxpQkFBaUIsS0FBSyxlQUFlLE1BQU0sa0JBQW1CLGtCQUFrQjtBQUN0RixpQkFBSyxvQkFBb0IsZUFBZSxNQUFNO0FBQzlDLG1CQUFPLEVBQUMsZUFBZTtBQUFBO0FBQUEsVUFFekIsY0FBYyxTQUFTLFFBQU8sWUFBWSxNQUFNO0FBQzlDLGdCQUFJLG1CQUFtQixPQUFPO0FBQzVCLHFCQUFPLE9BQU8sU0FBUztBQUFBLG1CQUNsQjtBQUNMLG1CQUFLLG1CQUFtQixRQUFPLE1BQU0sT0FBTyxTQUFTO0FBQUE7QUFBQTtBQUFBLFVBR3pELG9CQUFvQixlQUFlLE1BQU0sWUFBWTtBQUNuRCxnQkFBSSxpQkFBaUIsQ0FBQyxtQkFBbUIsT0FBTztBQUM5QyxtQkFBSyxtQkFBbUIsUUFBVyxNQUFNLE9BQU8sZUFBZTtBQUFBO0FBQUE7QUFBQSxVQUduRSxVQUFVLFNBQVMsUUFBTyxNQUFNLFFBQVE7QUFDdEMsb0JBQVEsU0FBUztBQUNqQixrQkFBTSxVQUFVLEtBQUssU0FBUyxRQUFPO0FBQ3JDLGlCQUFLLG1CQUFtQixRQUFPLE1BQU0sUUFBUSxPQUFPLFNBQVM7QUFBQSxjQUMzRCxTQUFVLENBQUMsVUFBVSxLQUFLLGlCQUFpQixZQUFhO0FBQUE7QUFBQTtBQUFBLFVBRzVELGlCQUFpQixTQUFTLGNBQWMsUUFBTztBQUM3QyxpQkFBSyxVQUFVLFNBQVMsUUFBTyxVQUFVO0FBQUE7QUFBQSxVQUUzQyxjQUFjLFNBQVMsY0FBYyxRQUFPO0FBQzFDLGlCQUFLLFVBQVUsU0FBUyxRQUFPLFVBQVU7QUFBQTtBQUFBLFVBRTNDLDJCQUEyQjtBQUN6QixrQkFBTSxVQUFVLEtBQUssWUFBWTtBQUNqQyxnQkFBSSxTQUFTO0FBQ1gsbUJBQUssVUFBVSxTQUFTLFFBQVcsVUFBVTtBQUFBO0FBQUE7QUFBQSxVQUdqRCx3QkFBd0I7QUFDdEIsa0JBQU0sVUFBVSxLQUFLLFlBQVk7QUFDakMsZ0JBQUksU0FBUztBQUNYLG1CQUFLLFVBQVUsU0FBUyxRQUFXLFVBQVU7QUFBQTtBQUFBO0FBQUEsVUFHakQsZ0JBQWdCLGtCQUFrQjtBQUNoQyxrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sWUFBVyxLQUFLLFlBQVk7QUFDbEMsdUJBQVcsQ0FBQyxRQUFRLE1BQU0sU0FBUyxLQUFLLFdBQVc7QUFDakQsbUJBQUssUUFBUSxNQUFNO0FBQUE7QUFFckIsaUJBQUssWUFBWTtBQUNqQixrQkFBTSxVQUFVLFVBQVM7QUFDekIsa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGtCQUFNLFFBQVEsS0FBSyxJQUFJLFNBQVM7QUFDaEMsZ0JBQUksT0FBTztBQUNULG1CQUFLLE1BQU0sR0FBRztBQUFBO0FBRWhCLGdCQUFJLFVBQVUsU0FBUztBQUNyQixtQkFBSyxnQkFBZ0IsU0FBUyxVQUFVLFNBQVM7QUFBQSx1QkFDeEMsVUFBVSxTQUFTO0FBQzVCLG1CQUFLLGdCQUFnQixTQUFTLFVBQVU7QUFBQTtBQUFBO0FBQUEsVUFHNUMsZ0JBQWdCLE9BQU8sT0FBTyxtQkFBbUIsTUFBTTtBQUNyRCxrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLE1BQU0sUUFBUTtBQUNwQixnQkFBSTtBQUNKLGtCQUFNLFFBQU8sQ0FBQyxRQUFRO0FBQ3BCLGtCQUFJLFVBQVU7QUFDZCxtQkFBSyxJQUFJLElBQUksU0FBUyxHQUFHLEtBQUssS0FBSyxLQUFLO0FBQ3RDLG9CQUFJLEtBQUssSUFBSSxJQUFJO0FBQUE7QUFBQTtBQUdyQixrQkFBSztBQUNMLGlCQUFLLElBQUksT0FBTyxJQUFJLEtBQUssRUFBRSxHQUFHO0FBQzVCLG1CQUFLLEtBQUssSUFBSSxLQUFLO0FBQUE7QUFFckIsZ0JBQUksS0FBSyxVQUFVO0FBQ2pCLG9CQUFLLEtBQUs7QUFBQTtBQUVaLGlCQUFLLE1BQU0sT0FBTztBQUNsQixnQkFBSSxrQkFBa0I7QUFDcEIsbUJBQUssZUFBZSxNQUFNLE9BQU8sT0FBTztBQUFBO0FBQUE7QUFBQSxVQUc1QyxlQUFlLFNBQVMsT0FBTyxPQUFPLE1BQU07QUFBQTtBQUFBLFVBQzVDLGdCQUFnQixPQUFPLE9BQU87QUFDNUIsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGdCQUFJLEtBQUssVUFBVTtBQUNqQixvQkFBTSxVQUFVLEtBQUssUUFBUSxPQUFPLE9BQU87QUFDM0Msa0JBQUksS0FBSyxVQUFVO0FBQ2pCLDRCQUFZLE1BQU07QUFBQTtBQUFBO0FBR3RCLGlCQUFLLEtBQUssT0FBTyxPQUFPO0FBQUE7QUFBQSxVQUUxQixNQUFNLE1BQU07QUFDVixnQkFBSSxLQUFLLFVBQVU7QUFDakIsbUJBQUssVUFBVSxLQUFLO0FBQUEsbUJBQ2Y7QUFDTCxvQkFBTSxDQUFDLFFBQVEsTUFBTSxRQUFRO0FBQzdCLG1CQUFLLFFBQVEsTUFBTTtBQUFBO0FBRXJCLGlCQUFLLE1BQU0sYUFBYSxLQUFLLENBQUMsS0FBSyxPQUFPLEdBQUc7QUFBQTtBQUFBLFVBRS9DLGNBQWM7QUFDWixrQkFBTSxRQUFRLFVBQVU7QUFDeEIsaUJBQUssTUFBTSxDQUFDLG1CQUFtQixLQUFLLGFBQWEsS0FBSyxTQUFTLE9BQU87QUFBQTtBQUFBLFVBRXhFLGFBQWE7QUFDWCxpQkFBSyxNQUFNLENBQUMsbUJBQW1CLEtBQUssWUFBWSxLQUFLLFNBQVMsR0FBRztBQUFBO0FBQUEsVUFFbkUsZUFBZTtBQUNiLGlCQUFLLE1BQU0sQ0FBQyxtQkFBbUIsR0FBRztBQUFBO0FBQUEsVUFFcEMsY0FBYyxPQUFPLE9BQU87QUFDMUIsZ0JBQUksT0FBTztBQUNULG1CQUFLLE1BQU0sQ0FBQyxtQkFBbUIsT0FBTztBQUFBO0FBRXhDLGtCQUFNLFdBQVcsVUFBVSxTQUFTO0FBQ3BDLGdCQUFJLFVBQVU7QUFDWixtQkFBSyxNQUFNLENBQUMsbUJBQW1CLE9BQU87QUFBQTtBQUFBO0FBQUEsVUFHMUMsaUJBQWlCO0FBQ2YsaUJBQUssTUFBTSxDQUFDLG1CQUFtQixHQUFHLFVBQVU7QUFBQTtBQUFBO0FBR2hELDBCQUFrQixXQUFXO0FBQzdCLDBCQUFrQixVQUFVLHFCQUFxQjtBQUNqRCwwQkFBa0IsVUFBVSxrQkFBa0I7QUFFOUMsdUJBQWM7QUFBQSxVQUNaLGNBQWM7QUFDWixpQkFBSyxJQUFJO0FBQ1QsaUJBQUssSUFBSTtBQUNULGlCQUFLLFNBQVM7QUFDZCxpQkFBSyxVQUFVO0FBQ2YsaUJBQUssY0FBYztBQUFBO0FBQUEsVUFFckIsZ0JBQWdCLGtCQUFrQjtBQUNoQyxrQkFBTSxFQUFDLEdBQUcsTUFBSyxLQUFLLFNBQVMsQ0FBQyxLQUFLLE1BQU07QUFDekMsbUJBQU8sRUFBQyxHQUFHO0FBQUE7QUFBQSxVQUViLFdBQVc7QUFDVCxtQkFBTyxTQUFTLEtBQUssTUFBTSxTQUFTLEtBQUs7QUFBQTtBQUFBLFVBRTNDLFNBQVMsT0FBTyxPQUFPO0FBQ3JCLGtCQUFNLFFBQVEsS0FBSztBQUNuQixnQkFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPO0FBQ3BCLHFCQUFPO0FBQUE7QUFFVCxrQkFBTSxNQUFNO0FBQ1osa0JBQU0sUUFBUSxVQUFRO0FBQ3BCLGtCQUFJLFFBQVEsTUFBTSxTQUFTLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxNQUFNLEtBQUs7QUFBQTtBQUUzRSxtQkFBTztBQUFBO0FBQUE7QUFHWCxpQkFBUSxXQUFXO0FBQ25CLGlCQUFRLGdCQUFnQjtBQUV4QixjQUFNLGFBQWE7QUFBQSxVQUNqQixPQUFPLE9BQU87QUFDWixtQkFBTyxRQUFRLFNBQVMsUUFBUSxLQUFLO0FBQUE7QUFBQSxVQUV2QyxRQUFRLFdBQVcsUUFBTyxPQUFPO0FBQy9CLGdCQUFJLGNBQWMsR0FBRztBQUNuQixxQkFBTztBQUFBO0FBRVQsa0JBQU0sU0FBUyxLQUFLLE1BQU0sUUFBUTtBQUNsQyxnQkFBSTtBQUNKLGdCQUFJLFFBQVE7QUFDWixnQkFBSSxNQUFNLFNBQVMsR0FBRztBQUNwQixvQkFBTSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUksTUFBTSxHQUFHLFFBQVEsS0FBSyxJQUFJLE1BQU0sTUFBTSxTQUFTLEdBQUc7QUFDcEYsa0JBQUksVUFBVSxRQUFRLFVBQVUsTUFBTztBQUNyQywyQkFBVztBQUFBO0FBRWIsc0JBQVEsZUFBZSxXQUFXO0FBQUE7QUFFcEMsa0JBQU0sV0FBVyxNQUFNLEtBQUssSUFBSTtBQUNoQyxrQkFBTSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUksS0FBSyxLQUFLLE1BQU0sV0FBVyxLQUFLO0FBQ3JFLGtCQUFNLFVBQVUsRUFBQyxVQUFVLHVCQUF1QixZQUFZLHVCQUF1QjtBQUNyRixtQkFBTyxPQUFPLFNBQVMsS0FBSyxRQUFRLE1BQU07QUFDMUMsbUJBQU8sYUFBYSxXQUFXLFFBQVE7QUFBQTtBQUFBLFVBRXpDLFlBQVksV0FBVyxRQUFPLE9BQU87QUFDbkMsZ0JBQUksY0FBYyxHQUFHO0FBQ25CLHFCQUFPO0FBQUE7QUFFVCxrQkFBTSxTQUFTLFlBQWEsS0FBSyxJQUFJLElBQUksS0FBSyxNQUFNLE1BQU07QUFDMUQsZ0JBQUksV0FBVyxLQUFLLFdBQVcsS0FBSyxXQUFXLEdBQUc7QUFDaEQscUJBQU8sV0FBVyxRQUFRLEtBQUssTUFBTSxXQUFXLFFBQU87QUFBQTtBQUV6RCxtQkFBTztBQUFBO0FBQUE7QUFHWCxnQ0FBd0IsV0FBVyxPQUFPO0FBQ3hDLGNBQUksUUFBUSxNQUFNLFNBQVMsSUFBSSxNQUFNLEdBQUcsUUFBUSxNQUFNLEdBQUcsUUFBUSxNQUFNLEdBQUcsUUFBUSxNQUFNLEdBQUc7QUFDM0YsY0FBSSxLQUFLLElBQUksVUFBVSxLQUFLLGNBQWMsS0FBSyxNQUFNLFlBQVk7QUFDL0Qsb0JBQVEsWUFBWSxLQUFLLE1BQU07QUFBQTtBQUVqQyxpQkFBTztBQUFBO0FBRVQsWUFBSSxRQUFRLEVBQUM7QUFFYixpQkFBUyxJQUFJLFNBQVM7QUFBQSxVQUNwQixTQUFTO0FBQUEsVUFDVCxRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxhQUFhO0FBQUEsVUFDYixRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsWUFDSixTQUFTO0FBQUEsWUFDVCxXQUFXO0FBQUEsWUFDWCxZQUFZO0FBQUEsWUFDWixpQkFBaUI7QUFBQSxZQUNqQixXQUFXO0FBQUEsWUFDWCxZQUFZO0FBQUEsWUFDWixXQUFXLENBQUMsTUFBTSxZQUFZLFFBQVE7QUFBQSxZQUN0QyxXQUFXLENBQUMsTUFBTSxZQUFZLFFBQVE7QUFBQSxZQUN0QyxRQUFRO0FBQUEsWUFDUixZQUFZO0FBQUEsWUFDWixrQkFBa0I7QUFBQSxZQUNsQixhQUFhO0FBQUE7QUFBQSxVQUVmLE9BQU87QUFBQSxZQUNMLFNBQVM7QUFBQSxZQUNULE1BQU07QUFBQSxZQUNOLFNBQVM7QUFBQSxjQUNQLEtBQUs7QUFBQSxjQUNMLFFBQVE7QUFBQTtBQUFBO0FBQUEsVUFHWixPQUFPO0FBQUEsWUFDTCxhQUFhO0FBQUEsWUFDYixhQUFhO0FBQUEsWUFDYixRQUFRO0FBQUEsWUFDUixpQkFBaUI7QUFBQSxZQUNqQixpQkFBaUI7QUFBQSxZQUNqQixTQUFTO0FBQUEsWUFDVCxTQUFTO0FBQUEsWUFDVCxVQUFVO0FBQUEsWUFDVixpQkFBaUI7QUFBQSxZQUNqQixhQUFhO0FBQUEsWUFDYixVQUFVLE1BQU0sV0FBVztBQUFBLFlBQzNCLE9BQU87QUFBQSxZQUNQLE9BQU87QUFBQSxZQUNQLE9BQU87QUFBQSxZQUNQLFlBQVk7QUFBQSxZQUNaLG1CQUFtQjtBQUFBLFlBQ25CLGVBQWU7QUFBQSxZQUNmLGlCQUFpQjtBQUFBO0FBQUE7QUFHckIsaUJBQVMsTUFBTSxlQUFlLFNBQVMsSUFBSTtBQUMzQyxpQkFBUyxNQUFNLGNBQWMsU0FBUyxJQUFJO0FBQzFDLGlCQUFTLE1BQU0sY0FBYyxlQUFlLElBQUk7QUFDaEQsaUJBQVMsTUFBTSxlQUFlLFNBQVMsSUFBSTtBQUMzQyxpQkFBUyxTQUFTLFNBQVM7QUFBQSxVQUN6QixXQUFXO0FBQUEsVUFDWCxhQUFhLENBQUMsU0FBUyxDQUFDLEtBQUssV0FBVyxhQUFhLENBQUMsS0FBSyxXQUFXLFlBQVksU0FBUyxjQUFjLFNBQVM7QUFBQSxVQUNsSCxZQUFZLENBQUMsU0FBUyxTQUFTLGdCQUFnQixTQUFTO0FBQUE7QUFFMUQsaUJBQVMsU0FBUyxVQUFVO0FBQUEsVUFDMUIsV0FBVztBQUFBO0FBRWIsaUJBQVMsU0FBUyxlQUFlO0FBQUEsVUFDL0IsYUFBYSxDQUFDLFNBQVMsU0FBUyxxQkFBcUIsU0FBUztBQUFBLFVBQzlELFlBQVksQ0FBQyxTQUFTLFNBQVM7QUFBQTtBQUdqQywwQkFBa0IsT0FBTyxPQUFPO0FBQzlCLGdCQUFNLFdBQVcsTUFBTSxRQUFRO0FBQy9CLGdCQUFNLGFBQWEsU0FBUyxpQkFBaUIsa0JBQWtCO0FBQy9ELGdCQUFNLGVBQWUsU0FBUyxNQUFNLFVBQVUsZ0JBQWdCLFNBQVM7QUFDdkUsZ0JBQU0sa0JBQWtCLGFBQWE7QUFDckMsZ0JBQU0sUUFBUSxhQUFhO0FBQzNCLGdCQUFNLE9BQU8sYUFBYSxrQkFBa0I7QUFDNUMsZ0JBQU0sV0FBVztBQUNqQixjQUFJLGtCQUFrQixZQUFZO0FBQ2hDLHVCQUFXLE9BQU8sVUFBVSxjQUFjLGtCQUFrQjtBQUM1RCxtQkFBTztBQUFBO0FBRVQsZ0JBQU0sVUFBVSxpQkFBaUIsY0FBYyxPQUFPO0FBQ3RELGNBQUksa0JBQWtCLEdBQUc7QUFDdkIsZ0JBQUksR0FBRztBQUNQLGtCQUFNLGtCQUFrQixrQkFBa0IsSUFBSSxLQUFLLE1BQU8sUUFBTyxTQUFVLG1CQUFrQixNQUFNO0FBQ25HLGlCQUFLLE9BQU8sVUFBVSxTQUFTLGNBQWMsbUJBQW1CLElBQUksUUFBUSxpQkFBaUI7QUFDN0YsaUJBQUssSUFBSSxHQUFHLE9BQU8sa0JBQWtCLEdBQUcsSUFBSSxNQUFNLEtBQUs7QUFDckQsbUJBQUssT0FBTyxVQUFVLFNBQVMsYUFBYSxJQUFJLGFBQWEsSUFBSTtBQUFBO0FBRW5FLGlCQUFLLE9BQU8sVUFBVSxTQUFTLE1BQU0sY0FBYyxtQkFBbUIsTUFBTSxTQUFTLE9BQU87QUFDNUYsbUJBQU87QUFBQTtBQUVULGVBQUssT0FBTyxVQUFVO0FBQ3RCLGlCQUFPO0FBQUE7QUFFVCxtQ0FBMkIsT0FBTztBQUNoQyxnQkFBTSxTQUFTLE1BQU0sUUFBUTtBQUM3QixnQkFBTSxhQUFhLE1BQU07QUFDekIsZ0JBQU0sV0FBVyxNQUFNLFVBQVUsYUFBYyxVQUFTLElBQUk7QUFDNUQsZ0JBQU0sV0FBVyxNQUFNLGFBQWE7QUFDcEMsaUJBQU8sS0FBSyxNQUFNLEtBQUssSUFBSSxVQUFVO0FBQUE7QUFFdkMsa0NBQTBCLGNBQWMsT0FBTyxZQUFZO0FBQ3pELGdCQUFNLG1CQUFtQixlQUFlO0FBQ3hDLGdCQUFNLFVBQVUsTUFBTSxTQUFTO0FBQy9CLGNBQUksQ0FBQyxrQkFBa0I7QUFDckIsbUJBQU8sS0FBSyxJQUFJLFNBQVM7QUFBQTtBQUUzQixnQkFBTSxVQUFVLFdBQVc7QUFDM0IsbUJBQVMsSUFBSSxHQUFHLE9BQU8sUUFBUSxTQUFTLEdBQUcsSUFBSSxNQUFNLEtBQUs7QUFDeEQsa0JBQU0sU0FBUyxRQUFRO0FBQ3ZCLGdCQUFJLFNBQVMsU0FBUztBQUNwQixxQkFBTztBQUFBO0FBQUE7QUFHWCxpQkFBTyxLQUFLLElBQUksU0FBUztBQUFBO0FBRTNCLGlDQUF5QixPQUFPO0FBQzlCLGdCQUFNLFNBQVM7QUFDZixjQUFJLEdBQUc7QUFDUCxlQUFLLElBQUksR0FBRyxPQUFPLE1BQU0sUUFBUSxJQUFJLE1BQU0sS0FBSztBQUM5QyxnQkFBSSxNQUFNLEdBQUcsT0FBTztBQUNsQixxQkFBTyxLQUFLO0FBQUE7QUFBQTtBQUdoQixpQkFBTztBQUFBO0FBRVQsNEJBQW9CLE9BQU8sVUFBVSxjQUFjLFNBQVM7QUFDMUQsY0FBSSxRQUFRO0FBQ1osY0FBSSxPQUFPLGFBQWE7QUFDeEIsY0FBSTtBQUNKLG9CQUFVLEtBQUssS0FBSztBQUNwQixlQUFLLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLO0FBQ2pDLGdCQUFJLE1BQU0sTUFBTTtBQUNkLHVCQUFTLEtBQUssTUFBTTtBQUNwQjtBQUNBLHFCQUFPLGFBQWEsUUFBUTtBQUFBO0FBQUE7QUFBQTtBQUlsQyxzQkFBYyxPQUFPLFVBQVUsU0FBUyxZQUFZLFVBQVU7QUFDNUQsZ0JBQU0sUUFBUSxlQUFlLFlBQVk7QUFDekMsZ0JBQU0sTUFBTSxLQUFLLElBQUksZUFBZSxVQUFVLE1BQU0sU0FBUyxNQUFNO0FBQ25FLGNBQUksUUFBUTtBQUNaLGNBQUksUUFBUSxHQUFHO0FBQ2Ysb0JBQVUsS0FBSyxLQUFLO0FBQ3BCLGNBQUksVUFBVTtBQUNaLHFCQUFTLFdBQVc7QUFDcEIsc0JBQVUsU0FBUyxLQUFLLE1BQU0sU0FBUztBQUFBO0FBRXpDLGlCQUFPO0FBQ1AsaUJBQU8sT0FBTyxHQUFHO0FBQ2Y7QUFDQSxtQkFBTyxLQUFLLE1BQU0sUUFBUSxRQUFRO0FBQUE7QUFFcEMsZUFBSyxJQUFJLEtBQUssSUFBSSxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUs7QUFDekMsZ0JBQUksTUFBTSxNQUFNO0FBQ2QsdUJBQVMsS0FBSyxNQUFNO0FBQ3BCO0FBQ0EscUJBQU8sS0FBSyxNQUFNLFFBQVEsUUFBUTtBQUFBO0FBQUE7QUFBQTtBQUl4QyxnQ0FBd0IsS0FBSztBQUMzQixnQkFBTSxNQUFNLElBQUk7QUFDaEIsY0FBSSxHQUFHO0FBQ1AsY0FBSSxNQUFNLEdBQUc7QUFDWCxtQkFBTztBQUFBO0FBRVQsZUFBSyxPQUFPLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUUsR0FBRztBQUN2QyxnQkFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLE9BQU8sTUFBTTtBQUNoQyxxQkFBTztBQUFBO0FBQUE7QUFHWCxpQkFBTztBQUFBO0FBR1QsY0FBTSxlQUFlLENBQUMsVUFBVSxVQUFVLFNBQVMsVUFBVSxVQUFVLFVBQVUsU0FBUztBQUMxRixjQUFNLGlCQUFpQixDQUFDLE9BQU8sTUFBTSxXQUFXLFNBQVMsU0FBUyxTQUFTLFNBQVMsTUFBTSxRQUFRLFNBQVMsTUFBTSxRQUFRO0FBQ3pILHdCQUFnQixLQUFLLFVBQVU7QUFDN0IsZ0JBQU0sU0FBUztBQUNmLGdCQUFNLFlBQVksSUFBSSxTQUFTO0FBQy9CLGdCQUFNLE1BQU0sSUFBSTtBQUNoQixjQUFJLElBQUk7QUFDUixpQkFBTyxJQUFJLEtBQUssS0FBSyxXQUFXO0FBQzlCLG1CQUFPLEtBQUssSUFBSSxLQUFLLE1BQU07QUFBQTtBQUU3QixpQkFBTztBQUFBO0FBRVQscUNBQTZCLE9BQU8sUUFBTyxpQkFBaUI7QUFDMUQsZ0JBQU0sU0FBUyxNQUFNLE1BQU07QUFDM0IsZ0JBQU0sY0FBYSxLQUFLLElBQUksUUFBTyxTQUFTO0FBQzVDLGdCQUFNLFFBQVEsTUFBTTtBQUNwQixnQkFBTSxNQUFNLE1BQU07QUFDbEIsZ0JBQU0sVUFBVTtBQUNoQixjQUFJLFlBQVksTUFBTSxnQkFBZ0I7QUFDdEMsY0FBSTtBQUNKLGNBQUksaUJBQWlCO0FBQ25CLGdCQUFJLFdBQVcsR0FBRztBQUNoQix1QkFBUyxLQUFLLElBQUksWUFBWSxPQUFPLE1BQU07QUFBQSx1QkFDbEMsV0FBVSxHQUFHO0FBQ3RCLHVCQUFVLE9BQU0sZ0JBQWdCLEtBQUssYUFBYTtBQUFBLG1CQUM3QztBQUNMLHVCQUFVLGFBQVksTUFBTSxnQkFBZ0IsY0FBYSxNQUFNO0FBQUE7QUFFakUseUJBQWEsY0FBYSxTQUFRLFNBQVMsQ0FBQztBQUM1QyxnQkFBSSxZQUFZLFFBQVEsV0FBVyxZQUFZLE1BQU0sU0FBUztBQUM1RDtBQUFBO0FBQUE7QUFHSixpQkFBTztBQUFBO0FBRVQsZ0NBQXdCLFFBQVEsUUFBUTtBQUN0QyxlQUFLLFFBQVEsQ0FBQyxVQUFVO0FBQ3RCLGtCQUFNLEtBQUssTUFBTTtBQUNqQixrQkFBTSxRQUFRLEdBQUcsU0FBUztBQUMxQixnQkFBSTtBQUNKLGdCQUFJLFFBQVEsUUFBUTtBQUNsQixtQkFBSyxJQUFJLEdBQUcsSUFBSSxPQUFPLEVBQUUsR0FBRztBQUMxQix1QkFBTyxNQUFNLEtBQUssR0FBRztBQUFBO0FBRXZCLGlCQUFHLE9BQU8sR0FBRztBQUFBO0FBQUE7QUFBQTtBQUluQixtQ0FBMkIsU0FBUztBQUNsQyxpQkFBTyxRQUFRLFlBQVksUUFBUSxhQUFhO0FBQUE7QUFFbEQsZ0NBQXdCLFNBQVMsVUFBVTtBQUN6QyxjQUFJLENBQUMsUUFBUSxTQUFTO0FBQ3BCLG1CQUFPO0FBQUE7QUFFVCxnQkFBTSxPQUFPLE9BQU8sUUFBUSxNQUFNO0FBQ2xDLGdCQUFNLFVBQVUsVUFBVSxRQUFRO0FBQ2xDLGdCQUFNLFFBQVEsUUFBUSxRQUFRLFFBQVEsUUFBUSxLQUFLLFNBQVM7QUFDNUQsaUJBQVEsUUFBUSxLQUFLLGFBQWMsUUFBUTtBQUFBO0FBRTdDLG9DQUE0QixRQUFRLE9BQU87QUFDekMsaUJBQU8sY0FBYyxRQUFRO0FBQUEsWUFDM0I7QUFBQSxZQUNBLE1BQU07QUFBQTtBQUFBO0FBR1YsbUNBQTJCLFFBQVEsUUFBTyxNQUFNO0FBQzlDLGlCQUFPLGNBQWMsUUFBUTtBQUFBLFlBQzNCO0FBQUEsWUFDQTtBQUFBLFlBQ0EsTUFBTTtBQUFBO0FBQUE7QUFHViw0QkFBb0IsT0FBTyxVQUFVLFNBQVM7QUFDNUMsY0FBSSxNQUFNLG1CQUFtQjtBQUM3QixjQUFLLFdBQVcsYUFBYSxXQUFhLENBQUMsV0FBVyxhQUFhLFNBQVU7QUFDM0Usa0JBQU0sYUFBYTtBQUFBO0FBRXJCLGlCQUFPO0FBQUE7QUFFVCwyQkFBbUIsT0FBTyxRQUFRLFVBQVUsT0FBTztBQUNqRCxnQkFBTSxFQUFDLEtBQUssTUFBTSxRQUFRLE9BQU8sa0JBQVM7QUFDMUMsZ0JBQU0sRUFBQyxXQUFXLG9CQUFVO0FBQzVCLGNBQUksV0FBVztBQUNmLGNBQUksVUFBVSxRQUFRO0FBQ3RCLGdCQUFNLFNBQVMsU0FBUztBQUN4QixnQkFBTSxRQUFRLFFBQVE7QUFDdEIsY0FBSSxNQUFNLGdCQUFnQjtBQUN4QixxQkFBUyxlQUFlLE9BQU8sTUFBTTtBQUNyQyxnQkFBSSxVQUFTLFdBQVc7QUFDdEIsb0JBQU0saUJBQWlCLE9BQU8sS0FBSyxVQUFVO0FBQzdDLG9CQUFNLFFBQVEsU0FBUztBQUN2Qix1QkFBUyxRQUFPLGdCQUFnQixpQkFBaUIsU0FBUyxTQUFTO0FBQUEsdUJBQzFELGFBQWEsVUFBVTtBQUNoQyx1QkFBVSxXQUFVLFNBQVMsVUFBVSxPQUFPLElBQUksU0FBUztBQUFBLG1CQUN0RDtBQUNMLHVCQUFTLGVBQWUsT0FBTyxVQUFVO0FBQUE7QUFFM0MsdUJBQVcsUUFBUTtBQUFBLGlCQUNkO0FBQ0wsZ0JBQUksVUFBUyxXQUFXO0FBQ3RCLG9CQUFNLGlCQUFpQixPQUFPLEtBQUssVUFBVTtBQUM3QyxvQkFBTSxRQUFRLFNBQVM7QUFDdkIsdUJBQVMsUUFBTyxnQkFBZ0IsaUJBQWlCLFNBQVMsUUFBUTtBQUFBLHVCQUN6RCxhQUFhLFVBQVU7QUFDaEMsdUJBQVUsV0FBVSxPQUFPLFVBQVUsU0FBUyxJQUFJLFFBQVE7QUFBQSxtQkFDckQ7QUFDTCx1QkFBUyxlQUFlLE9BQU8sVUFBVTtBQUFBO0FBRTNDLHFCQUFTLGVBQWUsT0FBTyxRQUFRO0FBQ3ZDLHVCQUFXLGFBQWEsU0FBUyxDQUFDLFVBQVU7QUFBQTtBQUU5QyxpQkFBTyxFQUFDLFFBQVEsUUFBUSxVQUFVO0FBQUE7QUFFcEMsNEJBQW9CLFNBQVE7QUFBQSxVQUMxQixZQUFZLEtBQUs7QUFDZjtBQUNBLGlCQUFLLEtBQUssSUFBSTtBQUNkLGlCQUFLLE9BQU8sSUFBSTtBQUNoQixpQkFBSyxVQUFVO0FBQ2YsaUJBQUssTUFBTSxJQUFJO0FBQ2YsaUJBQUssUUFBUSxJQUFJO0FBQ2pCLGlCQUFLLE1BQU07QUFDWCxpQkFBSyxTQUFTO0FBQ2QsaUJBQUssT0FBTztBQUNaLGlCQUFLLFFBQVE7QUFDYixpQkFBSyxRQUFRO0FBQ2IsaUJBQUssU0FBUztBQUNkLGlCQUFLLFdBQVc7QUFBQSxjQUNkLE1BQU07QUFBQSxjQUNOLE9BQU87QUFBQSxjQUNQLEtBQUs7QUFBQSxjQUNMLFFBQVE7QUFBQTtBQUVWLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssWUFBWTtBQUNqQixpQkFBSyxhQUFhO0FBQ2xCLGlCQUFLLGdCQUFnQjtBQUNyQixpQkFBSyxjQUFjO0FBQ25CLGlCQUFLLGVBQWU7QUFDcEIsaUJBQUssT0FBTztBQUNaLGlCQUFLLGdCQUFnQjtBQUNyQixpQkFBSyxNQUFNO0FBQ1gsaUJBQUssTUFBTTtBQUNYLGlCQUFLLFNBQVM7QUFDZCxpQkFBSyxRQUFRO0FBQ2IsaUJBQUssaUJBQWlCO0FBQ3RCLGlCQUFLLGNBQWM7QUFDbkIsaUJBQUssY0FBYztBQUNuQixpQkFBSyxVQUFVO0FBQ2YsaUJBQUssYUFBYTtBQUNsQixpQkFBSyxvQkFBb0I7QUFDekIsaUJBQUssY0FBYztBQUNuQixpQkFBSyxZQUFZO0FBQ2pCLGlCQUFLLGlCQUFpQjtBQUN0QixpQkFBSyxXQUFXO0FBQ2hCLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssZ0JBQWdCO0FBQ3JCLGlCQUFLLGdCQUFnQjtBQUNyQixpQkFBSyxlQUFlO0FBQ3BCLGlCQUFLLGVBQWU7QUFDcEIsaUJBQUssU0FBUztBQUNkLGlCQUFLLG9CQUFvQjtBQUN6QixpQkFBSyxXQUFXO0FBQUE7QUFBQSxVQUVsQixLQUFLLFNBQVM7QUFDWixpQkFBSyxVQUFVLFFBQVEsV0FBVyxLQUFLO0FBQ3ZDLGlCQUFLLE9BQU8sUUFBUTtBQUNwQixpQkFBSyxXQUFXLEtBQUssTUFBTSxRQUFRO0FBQ25DLGlCQUFLLFdBQVcsS0FBSyxNQUFNLFFBQVE7QUFDbkMsaUJBQUssZ0JBQWdCLEtBQUssTUFBTSxRQUFRO0FBQ3hDLGlCQUFLLGdCQUFnQixLQUFLLE1BQU0sUUFBUTtBQUFBO0FBQUEsVUFFMUMsTUFBTSxLQUFLLFFBQU87QUFDaEIsbUJBQU87QUFBQTtBQUFBLFVBRVQsZ0JBQWdCO0FBQ2QsZ0JBQUksRUFBQyxVQUFVLFVBQVUsZUFBZSxrQkFBaUI7QUFDekQsdUJBQVcsZ0JBQWdCLFVBQVUsT0FBTztBQUM1Qyx1QkFBVyxnQkFBZ0IsVUFBVSxPQUFPO0FBQzVDLDRCQUFnQixnQkFBZ0IsZUFBZSxPQUFPO0FBQ3RELDRCQUFnQixnQkFBZ0IsZUFBZSxPQUFPO0FBQ3RELG1CQUFPO0FBQUEsY0FDTCxLQUFLLGdCQUFnQixVQUFVO0FBQUEsY0FDL0IsS0FBSyxnQkFBZ0IsVUFBVTtBQUFBLGNBQy9CLFlBQVksZUFBZTtBQUFBLGNBQzNCLFlBQVksZUFBZTtBQUFBO0FBQUE7QUFBQSxVQUcvQixVQUFVLFVBQVU7QUFDbEIsZ0JBQUksRUFBQyxLQUFLLEtBQUssWUFBWSxlQUFjLEtBQUs7QUFDOUMsZ0JBQUk7QUFDSixnQkFBSSxjQUFjLFlBQVk7QUFDNUIscUJBQU8sRUFBQyxLQUFLO0FBQUE7QUFFZixrQkFBTSxRQUFRLEtBQUs7QUFDbkIscUJBQVMsSUFBSSxHQUFHLE9BQU8sTUFBTSxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDbEQsdUJBQVEsTUFBTSxHQUFHLFdBQVcsVUFBVSxNQUFNO0FBQzVDLGtCQUFJLENBQUMsWUFBWTtBQUNmLHNCQUFNLEtBQUssSUFBSSxLQUFLLE9BQU07QUFBQTtBQUU1QixrQkFBSSxDQUFDLFlBQVk7QUFDZixzQkFBTSxLQUFLLElBQUksS0FBSyxPQUFNO0FBQUE7QUFBQTtBQUc5QixrQkFBTSxjQUFjLE1BQU0sTUFBTSxNQUFNO0FBQ3RDLGtCQUFNLGNBQWMsTUFBTSxNQUFNLE1BQU07QUFDdEMsbUJBQU87QUFBQSxjQUNMLEtBQUssZ0JBQWdCLEtBQUssZ0JBQWdCLEtBQUs7QUFBQSxjQUMvQyxLQUFLLGdCQUFnQixLQUFLLGdCQUFnQixLQUFLO0FBQUE7QUFBQTtBQUFBLFVBR25ELGFBQWE7QUFDWCxtQkFBTztBQUFBLGNBQ0wsTUFBTSxLQUFLLGVBQWU7QUFBQSxjQUMxQixLQUFLLEtBQUssY0FBYztBQUFBLGNBQ3hCLE9BQU8sS0FBSyxnQkFBZ0I7QUFBQSxjQUM1QixRQUFRLEtBQUssaUJBQWlCO0FBQUE7QUFBQTtBQUFBLFVBR2xDLFdBQVc7QUFDVCxtQkFBTyxLQUFLO0FBQUE7QUFBQSxVQUVkLFlBQVk7QUFDVixrQkFBTSxPQUFPLEtBQUssTUFBTTtBQUN4QixtQkFBTyxLQUFLLFFBQVEsVUFBVyxNQUFLLGlCQUFpQixLQUFLLFVBQVUsS0FBSyxZQUFZLEtBQUssVUFBVTtBQUFBO0FBQUEsVUFFdEcsZUFBZTtBQUNiLGlCQUFLLFNBQVM7QUFDZCxpQkFBSyxvQkFBb0I7QUFBQTtBQUFBLFVBRTNCLGVBQWU7QUFDYixxQkFBUyxLQUFLLFFBQVEsY0FBYyxDQUFDO0FBQUE7QUFBQSxVQUV2QyxPQUFPLFVBQVUsV0FBVyxTQUFTO0FBQ25DLGtCQUFNLEVBQUMsYUFBYSxPQUFPLE9BQU8sYUFBWSxLQUFLO0FBQ25ELGtCQUFNLGFBQWEsU0FBUztBQUM1QixpQkFBSztBQUNMLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssWUFBWTtBQUNqQixpQkFBSyxXQUFXLFVBQVUsT0FBTyxPQUFPO0FBQUEsY0FDdEMsTUFBTTtBQUFBLGNBQ04sT0FBTztBQUFBLGNBQ1AsS0FBSztBQUFBLGNBQ0wsUUFBUTtBQUFBLGVBQ1A7QUFDSCxpQkFBSyxRQUFRO0FBQ2IsaUJBQUssY0FBYztBQUNuQixpQkFBSyxpQkFBaUI7QUFDdEIsaUJBQUssY0FBYztBQUNuQixpQkFBSztBQUNMLGlCQUFLO0FBQ0wsaUJBQUs7QUFDTCxpQkFBSyxhQUFhLEtBQUssaUJBQ25CLEtBQUssUUFBUSxRQUFRLE9BQU8sUUFBUSxRQUNwQyxLQUFLLFNBQVMsUUFBUSxNQUFNLFFBQVE7QUFDeEMsZ0JBQUksQ0FBQyxLQUFLLG1CQUFtQjtBQUMzQixtQkFBSztBQUNMLG1CQUFLO0FBQ0wsbUJBQUs7QUFDTCxtQkFBSyxTQUFTLFVBQVUsTUFBTSxPQUFPO0FBQ3JDLG1CQUFLLG9CQUFvQjtBQUFBO0FBRTNCLGlCQUFLO0FBQ0wsaUJBQUssUUFBUSxLQUFLLGdCQUFnQjtBQUNsQyxpQkFBSztBQUNMLGtCQUFNLGtCQUFrQixhQUFhLEtBQUssTUFBTTtBQUNoRCxpQkFBSyxzQkFBc0Isa0JBQWtCLE9BQU8sS0FBSyxPQUFPLGNBQWMsS0FBSztBQUNuRixpQkFBSztBQUNMLGlCQUFLO0FBQ0wsaUJBQUs7QUFDTCxpQkFBSztBQUNMLGdCQUFJLFNBQVMsV0FBWSxVQUFTLFlBQVksU0FBUyxXQUFXLFNBQVM7QUFDekUsbUJBQUssUUFBUSxTQUFTLE1BQU0sS0FBSztBQUNqQyxtQkFBSyxjQUFjO0FBQ25CLG1CQUFLO0FBQUE7QUFFUCxnQkFBSSxpQkFBaUI7QUFDbkIsbUJBQUssc0JBQXNCLEtBQUs7QUFBQTtBQUVsQyxpQkFBSztBQUNMLGlCQUFLO0FBQ0wsaUJBQUs7QUFDTCxpQkFBSztBQUFBO0FBQUEsVUFFUCxZQUFZO0FBQ1YsZ0JBQUksZ0JBQWdCLEtBQUssUUFBUTtBQUNqQyxnQkFBSSxZQUFZO0FBQ2hCLGdCQUFJLEtBQUssZ0JBQWdCO0FBQ3ZCLDJCQUFhLEtBQUs7QUFDbEIseUJBQVcsS0FBSztBQUFBLG1CQUNYO0FBQ0wsMkJBQWEsS0FBSztBQUNsQix5QkFBVyxLQUFLO0FBQ2hCLDhCQUFnQixDQUFDO0FBQUE7QUFFbkIsaUJBQUssY0FBYztBQUNuQixpQkFBSyxZQUFZO0FBQ2pCLGlCQUFLLGlCQUFpQjtBQUN0QixpQkFBSyxVQUFVLFdBQVc7QUFDMUIsaUJBQUssaUJBQWlCLEtBQUssUUFBUTtBQUFBO0FBQUEsVUFFckMsY0FBYztBQUNaLHFCQUFTLEtBQUssUUFBUSxhQUFhLENBQUM7QUFBQTtBQUFBLFVBRXRDLHNCQUFzQjtBQUNwQixxQkFBUyxLQUFLLFFBQVEscUJBQXFCLENBQUM7QUFBQTtBQUFBLFVBRTlDLGdCQUFnQjtBQUNkLGdCQUFJLEtBQUssZ0JBQWdCO0FBQ3ZCLG1CQUFLLFFBQVEsS0FBSztBQUNsQixtQkFBSyxPQUFPO0FBQ1osbUJBQUssUUFBUSxLQUFLO0FBQUEsbUJBQ2I7QUFDTCxtQkFBSyxTQUFTLEtBQUs7QUFDbkIsbUJBQUssTUFBTTtBQUNYLG1CQUFLLFNBQVMsS0FBSztBQUFBO0FBRXJCLGlCQUFLLGNBQWM7QUFDbkIsaUJBQUssYUFBYTtBQUNsQixpQkFBSyxlQUFlO0FBQ3BCLGlCQUFLLGdCQUFnQjtBQUFBO0FBQUEsVUFFdkIscUJBQXFCO0FBQ25CLHFCQUFTLEtBQUssUUFBUSxvQkFBb0IsQ0FBQztBQUFBO0FBQUEsVUFFN0MsV0FBVyxNQUFNO0FBQ2YsaUJBQUssTUFBTSxjQUFjLE1BQU0sS0FBSztBQUNwQyxxQkFBUyxLQUFLLFFBQVEsT0FBTyxDQUFDO0FBQUE7QUFBQSxVQUVoQyxtQkFBbUI7QUFDakIsaUJBQUssV0FBVztBQUFBO0FBQUEsVUFFbEIsc0JBQXNCO0FBQUE7QUFBQSxVQUN0QixrQkFBa0I7QUFDaEIsaUJBQUssV0FBVztBQUFBO0FBQUEsVUFFbEIsbUJBQW1CO0FBQ2pCLGlCQUFLLFdBQVc7QUFBQTtBQUFBLFVBRWxCLGFBQWE7QUFDWCxtQkFBTztBQUFBO0FBQUEsVUFFVCxrQkFBa0I7QUFDaEIsaUJBQUssV0FBVztBQUFBO0FBQUEsVUFFbEIsOEJBQThCO0FBQzVCLHFCQUFTLEtBQUssUUFBUSw2QkFBNkIsQ0FBQztBQUFBO0FBQUEsVUFFdEQsbUJBQW1CLE9BQU87QUFDeEIsa0JBQU0sV0FBVyxLQUFLLFFBQVE7QUFDOUIsZ0JBQUksR0FBRyxNQUFNO0FBQ2IsaUJBQUssSUFBSSxHQUFHLE9BQU8sTUFBTSxRQUFRLElBQUksTUFBTSxLQUFLO0FBQzlDLHFCQUFPLE1BQU07QUFDYixtQkFBSyxRQUFRLFNBQVMsU0FBUyxVQUFVLENBQUMsS0FBSyxPQUFPLEdBQUcsUUFBUTtBQUFBO0FBQUE7QUFBQSxVQUdyRSw2QkFBNkI7QUFDM0IscUJBQVMsS0FBSyxRQUFRLDRCQUE0QixDQUFDO0FBQUE7QUFBQSxVQUVyRCwrQkFBK0I7QUFDN0IscUJBQVMsS0FBSyxRQUFRLDhCQUE4QixDQUFDO0FBQUE7QUFBQSxVQUV2RCx5QkFBeUI7QUFDdkIsa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGtCQUFNLFdBQVcsUUFBUTtBQUN6QixrQkFBTSxXQUFXLEtBQUssTUFBTTtBQUM1QixrQkFBTSxjQUFjLFNBQVMsZUFBZTtBQUM1QyxrQkFBTSxjQUFjLFNBQVM7QUFDN0IsZ0JBQUksZ0JBQWdCO0FBQ3BCLGdCQUFJLFdBQVcsV0FBVztBQUMxQixnQkFBSSxDQUFDLEtBQUssZ0JBQWdCLENBQUMsU0FBUyxXQUFXLGVBQWUsZUFBZSxZQUFZLEtBQUssQ0FBQyxLQUFLLGdCQUFnQjtBQUNsSCxtQkFBSyxnQkFBZ0I7QUFDckI7QUFBQTtBQUVGLGtCQUFNLGFBQWEsS0FBSztBQUN4QixrQkFBTSxnQkFBZ0IsV0FBVyxPQUFPO0FBQ3hDLGtCQUFNLGlCQUFpQixXQUFXLFFBQVE7QUFDMUMsa0JBQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxRQUFRLGVBQWUsR0FBRyxLQUFLO0FBQ3ZFLHdCQUFZLFFBQVEsU0FBUyxLQUFLLFdBQVcsV0FBVyxXQUFZLFlBQVc7QUFDL0UsZ0JBQUksZ0JBQWdCLElBQUksV0FBVztBQUNqQywwQkFBWSxXQUFZLFlBQVksU0FBUSxTQUFTLE1BQU07QUFDM0QsMEJBQVksS0FBSyxZQUFZLGtCQUFrQixRQUFRLFFBQ3ZELFNBQVMsVUFBVSxlQUFlLFFBQVEsT0FBTyxLQUFLLE1BQU0sUUFBUTtBQUNwRSxpQ0FBbUIsS0FBSyxLQUFLLGdCQUFnQixnQkFBZ0IsaUJBQWlCO0FBQzlFLDhCQUFnQixVQUFVLEtBQUssSUFDN0IsS0FBSyxLQUFLLFlBQWEsWUFBVyxRQUFRLFNBQVMsS0FBSyxXQUFXLElBQUksS0FDdkUsS0FBSyxLQUFLLFlBQVksWUFBWSxrQkFBa0IsSUFBSSxNQUFNLEtBQUssS0FBSyxZQUFZLGlCQUFpQixrQkFBa0IsSUFBSTtBQUU3SCw4QkFBZ0IsS0FBSyxJQUFJLGFBQWEsS0FBSyxJQUFJLGFBQWE7QUFBQTtBQUU5RCxpQkFBSyxnQkFBZ0I7QUFBQTtBQUFBLFVBRXZCLDhCQUE4QjtBQUM1QixxQkFBUyxLQUFLLFFBQVEsNkJBQTZCLENBQUM7QUFBQTtBQUFBLFVBRXRELGdCQUFnQjtBQUFBO0FBQUEsVUFDaEIsWUFBWTtBQUNWLHFCQUFTLEtBQUssUUFBUSxXQUFXLENBQUM7QUFBQTtBQUFBLFVBRXBDLE1BQU07QUFDSixrQkFBTSxVQUFVO0FBQUEsY0FDZCxPQUFPO0FBQUEsY0FDUCxRQUFRO0FBQUE7QUFFVixrQkFBTSxFQUFDLGVBQU8sU0FBUyxFQUFDLE9BQU8sVUFBVSxPQUFPLFdBQVcsTUFBTSxlQUFhO0FBQzlFLGtCQUFNLFVBQVUsS0FBSztBQUNyQixrQkFBTSxlQUFlLEtBQUs7QUFDMUIsZ0JBQUksU0FBUztBQUNYLG9CQUFNLGNBQWMsZUFBZSxXQUFXLE9BQU0sUUFBUTtBQUM1RCxrQkFBSSxjQUFjO0FBQ2hCLHdCQUFRLFFBQVEsS0FBSztBQUNyQix3QkFBUSxTQUFTLGtCQUFrQixZQUFZO0FBQUEscUJBQzFDO0FBQ0wsd0JBQVEsU0FBUyxLQUFLO0FBQ3RCLHdCQUFRLFFBQVEsa0JBQWtCLFlBQVk7QUFBQTtBQUVoRCxrQkFBSSxTQUFTLFdBQVcsS0FBSyxNQUFNLFFBQVE7QUFDekMsc0JBQU0sRUFBQyxPQUFPLE1BQU0sUUFBUSxZQUFXLEtBQUs7QUFDNUMsc0JBQU0sY0FBYyxTQUFTLFVBQVU7QUFDdkMsc0JBQU0sZUFBZSxVQUFVLEtBQUs7QUFDcEMsc0JBQU0sTUFBTSxLQUFLLElBQUk7QUFDckIsc0JBQU0sTUFBTSxLQUFLLElBQUk7QUFDckIsb0JBQUksY0FBYztBQUNoQix3QkFBTSxjQUFjLFNBQVMsU0FBUyxJQUFJLE1BQU0sT0FBTyxRQUFRLE1BQU0sUUFBUTtBQUM3RSwwQkFBUSxTQUFTLEtBQUssSUFBSSxLQUFLLFdBQVcsUUFBUSxTQUFTLGNBQWM7QUFBQSx1QkFDcEU7QUFDTCx3QkFBTSxhQUFhLFNBQVMsU0FBUyxJQUFJLE1BQU0sT0FBTyxRQUFRLE1BQU0sUUFBUTtBQUM1RSwwQkFBUSxRQUFRLEtBQUssSUFBSSxLQUFLLFVBQVUsUUFBUSxRQUFRLGFBQWE7QUFBQTtBQUV2RSxxQkFBSyxrQkFBa0IsT0FBTyxNQUFNLEtBQUs7QUFBQTtBQUFBO0FBRzdDLGlCQUFLO0FBQ0wsZ0JBQUksY0FBYztBQUNoQixtQkFBSyxRQUFRLEtBQUssVUFBVSxPQUFNLFFBQVEsS0FBSyxTQUFTLE9BQU8sS0FBSyxTQUFTO0FBQzdFLG1CQUFLLFNBQVMsUUFBUTtBQUFBLG1CQUNqQjtBQUNMLG1CQUFLLFFBQVEsUUFBUTtBQUNyQixtQkFBSyxTQUFTLEtBQUssVUFBVSxPQUFNLFNBQVMsS0FBSyxTQUFTLE1BQU0sS0FBSyxTQUFTO0FBQUE7QUFBQTtBQUFBLFVBR2xGLGtCQUFrQixPQUFPLE1BQU0sS0FBSyxLQUFLO0FBQ3ZDLGtCQUFNLEVBQUMsT0FBTyxFQUFDLE9BQU8sV0FBVSxhQUFZLEtBQUs7QUFDakQsa0JBQU0sWUFBWSxLQUFLLGtCQUFrQjtBQUN6QyxrQkFBTSxtQkFBbUIsYUFBYSxTQUFTLEtBQUssU0FBUztBQUM3RCxnQkFBSSxLQUFLLGdCQUFnQjtBQUN2QixvQkFBTSxhQUFhLEtBQUssZ0JBQWdCLEtBQUssS0FBSztBQUNsRCxvQkFBTSxjQUFjLEtBQUssUUFBUSxLQUFLLGdCQUFnQixLQUFLLE1BQU0sU0FBUztBQUMxRSxrQkFBSSxjQUFjO0FBQ2xCLGtCQUFJLGVBQWU7QUFDbkIsa0JBQUksV0FBVztBQUNiLG9CQUFJLGtCQUFrQjtBQUNwQixnQ0FBYyxNQUFNLE1BQU07QUFDMUIsaUNBQWUsTUFBTSxLQUFLO0FBQUEsdUJBQ3JCO0FBQ0wsZ0NBQWMsTUFBTSxNQUFNO0FBQzFCLGlDQUFlLE1BQU0sS0FBSztBQUFBO0FBQUEseUJBRW5CLFVBQVUsU0FBUztBQUM1QiwrQkFBZSxLQUFLO0FBQUEseUJBQ1gsVUFBVSxPQUFPO0FBQzFCLDhCQUFjLE1BQU07QUFBQSx5QkFDWCxVQUFVLFNBQVM7QUFDNUIsOEJBQWMsTUFBTSxRQUFRO0FBQzVCLCtCQUFlLEtBQUssUUFBUTtBQUFBO0FBRTlCLG1CQUFLLGNBQWMsS0FBSyxJQUFLLGVBQWMsYUFBYSxXQUFXLEtBQUssUUFBUyxNQUFLLFFBQVEsYUFBYTtBQUMzRyxtQkFBSyxlQUFlLEtBQUssSUFBSyxnQkFBZSxjQUFjLFdBQVcsS0FBSyxRQUFTLE1BQUssUUFBUSxjQUFjO0FBQUEsbUJBQzFHO0FBQ0wsa0JBQUksYUFBYSxLQUFLLFNBQVM7QUFDL0Isa0JBQUksZ0JBQWdCLE1BQU0sU0FBUztBQUNuQyxrQkFBSSxVQUFVLFNBQVM7QUFDckIsNkJBQWE7QUFDYixnQ0FBZ0IsTUFBTTtBQUFBLHlCQUNiLFVBQVUsT0FBTztBQUMxQiw2QkFBYSxLQUFLO0FBQ2xCLGdDQUFnQjtBQUFBO0FBRWxCLG1CQUFLLGFBQWEsYUFBYTtBQUMvQixtQkFBSyxnQkFBZ0IsZ0JBQWdCO0FBQUE7QUFBQTtBQUFBLFVBR3pDLGlCQUFpQjtBQUNmLGdCQUFJLEtBQUssVUFBVTtBQUNqQixtQkFBSyxTQUFTLE9BQU8sS0FBSyxJQUFJLEtBQUssYUFBYSxLQUFLLFNBQVM7QUFDOUQsbUJBQUssU0FBUyxNQUFNLEtBQUssSUFBSSxLQUFLLFlBQVksS0FBSyxTQUFTO0FBQzVELG1CQUFLLFNBQVMsUUFBUSxLQUFLLElBQUksS0FBSyxjQUFjLEtBQUssU0FBUztBQUNoRSxtQkFBSyxTQUFTLFNBQVMsS0FBSyxJQUFJLEtBQUssZUFBZSxLQUFLLFNBQVM7QUFBQTtBQUFBO0FBQUEsVUFHdEUsV0FBVztBQUNULHFCQUFTLEtBQUssUUFBUSxVQUFVLENBQUM7QUFBQTtBQUFBLFVBRW5DLGVBQWU7QUFDYixrQkFBTSxFQUFDLE1BQU0sYUFBWSxLQUFLO0FBQzlCLG1CQUFPLGFBQWEsU0FBUyxhQUFhLFlBQVksU0FBUztBQUFBO0FBQUEsVUFFakUsYUFBYTtBQUNYLG1CQUFPLEtBQUssUUFBUTtBQUFBO0FBQUEsVUFFdEIsc0JBQXNCLE9BQU87QUFDM0IsaUJBQUs7QUFDTCxpQkFBSyxtQkFBbUI7QUFDeEIsZ0JBQUksR0FBRztBQUNQLGlCQUFLLElBQUksR0FBRyxPQUFPLE1BQU0sUUFBUSxJQUFJLE1BQU0sS0FBSztBQUM5QyxrQkFBSSxjQUFjLE1BQU0sR0FBRyxRQUFRO0FBQ2pDLHNCQUFNLE9BQU8sR0FBRztBQUNoQjtBQUNBO0FBQUE7QUFBQTtBQUdKLGlCQUFLO0FBQUE7QUFBQSxVQUVQLGlCQUFpQjtBQUNmLGdCQUFJLGFBQWEsS0FBSztBQUN0QixnQkFBSSxDQUFDLFlBQVk7QUFDZixvQkFBTSxhQUFhLEtBQUssUUFBUSxNQUFNO0FBQ3RDLGtCQUFJLFFBQVEsS0FBSztBQUNqQixrQkFBSSxhQUFhLE1BQU0sUUFBUTtBQUM3Qix3QkFBUSxPQUFPLE9BQU87QUFBQTtBQUV4QixtQkFBSyxjQUFjLGFBQWEsS0FBSyxtQkFBbUIsT0FBTyxNQUFNO0FBQUE7QUFFdkUsbUJBQU87QUFBQTtBQUFBLFVBRVQsbUJBQW1CLE9BQU8sUUFBUTtBQUNoQyxrQkFBTSxFQUFDLEtBQUssbUJBQW1CLFdBQVU7QUFDekMsa0JBQU0sU0FBUztBQUNmLGtCQUFNLFVBQVU7QUFDaEIsZ0JBQUksa0JBQWtCO0FBQ3RCLGdCQUFJLG1CQUFtQjtBQUN2QixnQkFBSSxHQUFHLEdBQUcsTUFBTSxPQUFPLFVBQVUsYUFBWSxPQUFPLFlBQVksT0FBTyxRQUFRO0FBQy9FLGlCQUFLLElBQUksR0FBRyxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQzNCLHNCQUFRLE1BQU0sR0FBRztBQUNqQix5QkFBVyxLQUFLLHdCQUF3QjtBQUN4QyxrQkFBSSxPQUFPLGNBQWEsU0FBUztBQUNqQyxzQkFBUSxPQUFPLGVBQWMsT0FBTyxnQkFBZSxFQUFDLE1BQU0sSUFBSSxJQUFJO0FBQ2xFLDJCQUFhLFNBQVM7QUFDdEIsc0JBQVEsU0FBUztBQUNqQixrQkFBSSxDQUFDLGNBQWMsVUFBVSxDQUFDLFFBQVEsUUFBUTtBQUM1Qyx3QkFBUSxhQUFhLEtBQUssTUFBTSxNQUFNLE1BQU0sSUFBSSxPQUFPO0FBQ3ZELHlCQUFTO0FBQUEseUJBQ0EsUUFBUSxRQUFRO0FBQ3pCLHFCQUFLLElBQUksR0FBRyxPQUFPLE1BQU0sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQzlDLGdDQUFjLE1BQU07QUFDcEIsc0JBQUksQ0FBQyxjQUFjLGdCQUFnQixDQUFDLFFBQVEsY0FBYztBQUN4RCw0QkFBUSxhQUFhLEtBQUssTUFBTSxNQUFNLE1BQU0sSUFBSSxPQUFPO0FBQ3ZELDhCQUFVO0FBQUE7QUFBQTtBQUFBO0FBSWhCLHFCQUFPLEtBQUs7QUFDWixzQkFBUSxLQUFLO0FBQ2IsZ0NBQWtCLEtBQUssSUFBSSxPQUFPO0FBQ2xDLGlDQUFtQixLQUFLLElBQUksUUFBUTtBQUFBO0FBRXRDLDJCQUFlLFFBQVE7QUFDdkIsa0JBQU0sU0FBUyxPQUFPLFFBQVE7QUFDOUIsa0JBQU0sVUFBVSxRQUFRLFFBQVE7QUFDaEMsa0JBQU0sVUFBVSxDQUFDLFFBQVMsR0FBQyxPQUFPLE9BQU8sUUFBUSxHQUFHLFFBQVEsUUFBUSxRQUFRO0FBQzVFLG1CQUFPO0FBQUEsY0FDTCxPQUFPLFFBQVE7QUFBQSxjQUNmLE1BQU0sUUFBUSxTQUFTO0FBQUEsY0FDdkIsUUFBUSxRQUFRO0FBQUEsY0FDaEIsU0FBUyxRQUFRO0FBQUEsY0FDakI7QUFBQSxjQUNBO0FBQUE7QUFBQTtBQUFBLFVBR0osaUJBQWlCLE9BQU87QUFDdEIsbUJBQU87QUFBQTtBQUFBLFVBRVQsaUJBQWlCLE9BQU8sUUFBTztBQUM3QixtQkFBTztBQUFBO0FBQUEsVUFFVCxpQkFBaUIsT0FBTztBQUFBO0FBQUEsVUFDeEIsZ0JBQWdCLFFBQU87QUFDckIsa0JBQU0sUUFBUSxLQUFLO0FBQ25CLGdCQUFJLFNBQVEsS0FBSyxTQUFRLE1BQU0sU0FBUyxHQUFHO0FBQ3pDLHFCQUFPO0FBQUE7QUFFVCxtQkFBTyxLQUFLLGlCQUFpQixNQUFNLFFBQU87QUFBQTtBQUFBLFVBRTVDLG1CQUFtQixTQUFTO0FBQzFCLGdCQUFJLEtBQUssZ0JBQWdCO0FBQ3ZCLHdCQUFVLElBQUk7QUFBQTtBQUVoQixrQkFBTSxRQUFRLEtBQUssY0FBYyxVQUFVLEtBQUs7QUFDaEQsbUJBQU8sWUFBWSxLQUFLLGlCQUFpQixZQUFZLEtBQUssT0FBTyxPQUFPLEtBQUs7QUFBQTtBQUFBLFVBRS9FLG1CQUFtQixPQUFPO0FBQ3hCLGtCQUFNLFVBQVcsU0FBUSxLQUFLLGVBQWUsS0FBSztBQUNsRCxtQkFBTyxLQUFLLGlCQUFpQixJQUFJLFVBQVU7QUFBQTtBQUFBLFVBRTdDLGVBQWU7QUFDYixtQkFBTyxLQUFLLGlCQUFpQixLQUFLO0FBQUE7QUFBQSxVQUVwQyxlQUFlO0FBQ2Isa0JBQU0sRUFBQyxLQUFLLFFBQU87QUFDbkIsbUJBQU8sTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUMxQixNQUFNLEtBQUssTUFBTSxJQUFJLE1BQ3JCO0FBQUE7QUFBQSxVQUVKLFdBQVcsUUFBTztBQUNoQixrQkFBTSxRQUFRLEtBQUssU0FBUztBQUM1QixnQkFBSSxVQUFTLEtBQUssU0FBUSxNQUFNLFFBQVE7QUFDdEMsb0JBQU0sT0FBTyxNQUFNO0FBQ25CLHFCQUFPLEtBQUssWUFDYixNQUFLLFdBQVcsa0JBQWtCLEtBQUssY0FBYyxRQUFPO0FBQUE7QUFFN0QsbUJBQU8sS0FBSyxZQUNaLE1BQUssV0FBVyxtQkFBbUIsS0FBSyxNQUFNLGNBQWM7QUFBQTtBQUFBLFVBRTlELFlBQVk7QUFDVixrQkFBTSxjQUFjLEtBQUssUUFBUTtBQUNqQyxrQkFBTSxNQUFNLFVBQVUsS0FBSztBQUMzQixrQkFBTSxNQUFNLEtBQUssSUFBSSxLQUFLLElBQUk7QUFDOUIsa0JBQU0sTUFBTSxLQUFLLElBQUksS0FBSyxJQUFJO0FBQzlCLGtCQUFNLGFBQWEsS0FBSztBQUN4QixrQkFBTSxVQUFVLFlBQVksbUJBQW1CO0FBQy9DLGtCQUFNLElBQUksYUFBYSxXQUFXLE9BQU8sUUFBUSxVQUFVO0FBQzNELGtCQUFNLElBQUksYUFBYSxXQUFXLFFBQVEsU0FBUyxVQUFVO0FBQzdELG1CQUFPLEtBQUssaUJBQ1IsSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUNsQyxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJO0FBQUE7QUFBQSxVQUV4QyxhQUFhO0FBQ1gsa0JBQU0sVUFBVSxLQUFLLFFBQVE7QUFDN0IsZ0JBQUksWUFBWSxRQUFRO0FBQ3RCLHFCQUFPLENBQUMsQ0FBQztBQUFBO0FBRVgsbUJBQU8sS0FBSywwQkFBMEIsU0FBUztBQUFBO0FBQUEsVUFFakQsc0JBQXNCLFdBQVc7QUFDL0Isa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLFNBQVEsS0FBSztBQUNuQixrQkFBTSxVQUFVLEtBQUs7QUFDckIsa0JBQU0sRUFBQyxNQUFNLGFBQVk7QUFDekIsa0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGtCQUFNLGVBQWUsS0FBSztBQUMxQixrQkFBTSxRQUFRLEtBQUs7QUFDbkIsa0JBQU0sY0FBYyxNQUFNLFNBQVUsVUFBUyxJQUFJO0FBQ2pELGtCQUFNLEtBQUssa0JBQWtCO0FBQzdCLGtCQUFNLFFBQVE7QUFDZCxrQkFBTSxhQUFhLEtBQUssV0FBVyxLQUFLO0FBQ3hDLGtCQUFNLFlBQVksV0FBVyxhQUFhLFdBQVcsY0FBYztBQUNuRSxrQkFBTSxnQkFBZ0IsWUFBWTtBQUNsQyxrQkFBTSxtQkFBbUIsU0FBUyxPQUFPO0FBQ3ZDLHFCQUFPLFlBQVksUUFBTyxPQUFPO0FBQUE7QUFFbkMsZ0JBQUksYUFBYSxHQUFHLFdBQVc7QUFDL0IsZ0JBQUksS0FBSyxLQUFLLEtBQUssS0FBSyxJQUFJLElBQUksSUFBSTtBQUNwQyxnQkFBSSxhQUFhLE9BQU87QUFDdEIsNEJBQWMsaUJBQWlCLEtBQUs7QUFDcEMsb0JBQU0sS0FBSyxTQUFTO0FBQ3BCLG9CQUFNLGNBQWM7QUFDcEIsbUJBQUssaUJBQWlCLFVBQVUsT0FBTztBQUN2QyxtQkFBSyxVQUFVO0FBQUEsdUJBQ04sYUFBYSxVQUFVO0FBQ2hDLDRCQUFjLGlCQUFpQixLQUFLO0FBQ3BDLG1CQUFLLFVBQVU7QUFDZixtQkFBSyxpQkFBaUIsVUFBVSxVQUFVO0FBQzFDLG9CQUFNLGNBQWM7QUFDcEIsb0JBQU0sS0FBSyxNQUFNO0FBQUEsdUJBQ1IsYUFBYSxRQUFRO0FBQzlCLDRCQUFjLGlCQUFpQixLQUFLO0FBQ3BDLG9CQUFNLEtBQUssUUFBUTtBQUNuQixvQkFBTSxjQUFjO0FBQ3BCLG1CQUFLLGlCQUFpQixVQUFVLFFBQVE7QUFDeEMsbUJBQUssVUFBVTtBQUFBLHVCQUNOLGFBQWEsU0FBUztBQUMvQiw0QkFBYyxpQkFBaUIsS0FBSztBQUNwQyxtQkFBSyxVQUFVO0FBQ2YsbUJBQUssaUJBQWlCLFVBQVUsU0FBUztBQUN6QyxvQkFBTSxjQUFjO0FBQ3BCLG9CQUFNLEtBQUssT0FBTztBQUFBLHVCQUNULFNBQVMsS0FBSztBQUN2QixrQkFBSSxhQUFhLFVBQVU7QUFDekIsOEJBQWMsaUJBQWtCLFdBQVUsTUFBTSxVQUFVLFVBQVUsSUFBSTtBQUFBLHlCQUMvRCxVQUFTLFdBQVc7QUFDN0Isc0JBQU0saUJBQWlCLE9BQU8sS0FBSyxVQUFVO0FBQzdDLHNCQUFNLFFBQVEsU0FBUztBQUN2Qiw4QkFBYyxpQkFBaUIsS0FBSyxNQUFNLE9BQU8sZ0JBQWdCLGlCQUFpQjtBQUFBO0FBRXBGLG1CQUFLLFVBQVU7QUFDZixtQkFBSyxVQUFVO0FBQ2Ysb0JBQU0sY0FBYztBQUNwQixvQkFBTSxNQUFNO0FBQUEsdUJBQ0gsU0FBUyxLQUFLO0FBQ3ZCLGtCQUFJLGFBQWEsVUFBVTtBQUN6Qiw4QkFBYyxpQkFBa0IsV0FBVSxPQUFPLFVBQVUsU0FBUztBQUFBLHlCQUMzRCxVQUFTLFdBQVc7QUFDN0Isc0JBQU0saUJBQWlCLE9BQU8sS0FBSyxVQUFVO0FBQzdDLHNCQUFNLFFBQVEsU0FBUztBQUN2Qiw4QkFBYyxpQkFBaUIsS0FBSyxNQUFNLE9BQU8sZ0JBQWdCLGlCQUFpQjtBQUFBO0FBRXBGLG9CQUFNLGNBQWM7QUFDcEIsb0JBQU0sTUFBTTtBQUNaLG1CQUFLLFVBQVU7QUFDZixtQkFBSyxVQUFVO0FBQUE7QUFFakIsa0JBQU0sUUFBUSxlQUFlLFFBQVEsTUFBTSxlQUFlO0FBQzFELGtCQUFNLE9BQU8sS0FBSyxJQUFJLEdBQUcsS0FBSyxLQUFLLGNBQWM7QUFDakQsaUJBQUssSUFBSSxHQUFHLElBQUksYUFBYSxLQUFLLE1BQU07QUFDdEMsb0JBQU0sY0FBYyxLQUFLLFdBQVcsS0FBSyxXQUFXO0FBQ3BELG9CQUFNLFlBQVksWUFBWTtBQUM5QixvQkFBTSxZQUFZLFlBQVk7QUFDOUIsb0JBQU0sYUFBYSxZQUFZLGNBQWM7QUFDN0Msb0JBQU0sbUJBQW1CLFlBQVk7QUFDckMsb0JBQU0sWUFBWSxZQUFZO0FBQzlCLG9CQUFNLFlBQVksWUFBWTtBQUM5QixvQkFBTSxpQkFBaUIsWUFBWSxrQkFBa0I7QUFDckQsb0JBQU0sdUJBQXVCLFlBQVk7QUFDekMsMEJBQVksb0JBQW9CLE1BQU0sR0FBRztBQUN6QyxrQkFBSSxjQUFjLFFBQVc7QUFDM0I7QUFBQTtBQUVGLGlDQUFtQixZQUFZLFFBQU8sV0FBVztBQUNqRCxrQkFBSSxjQUFjO0FBQ2hCLHNCQUFNLE1BQU0sS0FBSyxLQUFLO0FBQUEscUJBQ2pCO0FBQ0wsc0JBQU0sTUFBTSxLQUFLLEtBQUs7QUFBQTtBQUV4QixvQkFBTSxLQUFLO0FBQUEsZ0JBQ1Q7QUFBQSxnQkFDQTtBQUFBLGdCQUNBO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBLGdCQUNBO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBLGdCQUNBLE9BQU87QUFBQSxnQkFDUCxPQUFPO0FBQUEsZ0JBQ1A7QUFBQSxnQkFDQTtBQUFBLGdCQUNBO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBLGdCQUNBO0FBQUE7QUFBQTtBQUdKLGlCQUFLLGVBQWU7QUFDcEIsaUJBQUssZUFBZTtBQUNwQixtQkFBTztBQUFBO0FBQUEsVUFFVCxtQkFBbUIsV0FBVztBQUM1QixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGtCQUFNLEVBQUMsVUFBVSxPQUFPLGdCQUFlO0FBQ3ZDLGtCQUFNLGVBQWUsS0FBSztBQUMxQixrQkFBTSxRQUFRLEtBQUs7QUFDbkIsa0JBQU0sRUFBQyxPQUFPLFlBQVksU0FBUyxXQUFVO0FBQzdDLGtCQUFNLEtBQUssa0JBQWtCLFFBQVE7QUFDckMsa0JBQU0saUJBQWlCLEtBQUs7QUFDNUIsa0JBQU0sa0JBQWtCLFNBQVMsQ0FBQyxVQUFVO0FBQzVDLGtCQUFNLFdBQVcsQ0FBQyxVQUFVLEtBQUs7QUFDakMsa0JBQU0sUUFBUTtBQUNkLGdCQUFJLEdBQUcsTUFBTSxNQUFNLE9BQU8sR0FBRyxHQUFHLFdBQVcsT0FBTyxNQUFNLFlBQVksV0FBVztBQUMvRSxnQkFBSSxlQUFlO0FBQ25CLGdCQUFJLGFBQWEsT0FBTztBQUN0QixrQkFBSSxLQUFLLFNBQVM7QUFDbEIsMEJBQVksS0FBSztBQUFBLHVCQUNSLGFBQWEsVUFBVTtBQUNoQyxrQkFBSSxLQUFLLE1BQU07QUFDZiwwQkFBWSxLQUFLO0FBQUEsdUJBQ1IsYUFBYSxRQUFRO0FBQzlCLG9CQUFNLE1BQU0sS0FBSyx3QkFBd0I7QUFDekMsMEJBQVksSUFBSTtBQUNoQixrQkFBSSxJQUFJO0FBQUEsdUJBQ0MsYUFBYSxTQUFTO0FBQy9CLG9CQUFNLE1BQU0sS0FBSyx3QkFBd0I7QUFDekMsMEJBQVksSUFBSTtBQUNoQixrQkFBSSxJQUFJO0FBQUEsdUJBQ0MsU0FBUyxLQUFLO0FBQ3ZCLGtCQUFJLGFBQWEsVUFBVTtBQUN6QixvQkFBTSxXQUFVLE1BQU0sVUFBVSxVQUFVLElBQUs7QUFBQSx5QkFDdEMsVUFBUyxXQUFXO0FBQzdCLHNCQUFNLGlCQUFpQixPQUFPLEtBQUssVUFBVTtBQUM3QyxzQkFBTSxRQUFRLFNBQVM7QUFDdkIsb0JBQUksS0FBSyxNQUFNLE9BQU8sZ0JBQWdCLGlCQUFpQixTQUFTO0FBQUE7QUFFbEUsMEJBQVksS0FBSztBQUFBLHVCQUNSLFNBQVMsS0FBSztBQUN2QixrQkFBSSxhQUFhLFVBQVU7QUFDekIsb0JBQU0sV0FBVSxPQUFPLFVBQVUsU0FBUyxJQUFLO0FBQUEseUJBQ3RDLFVBQVMsV0FBVztBQUM3QixzQkFBTSxpQkFBaUIsT0FBTyxLQUFLLFVBQVU7QUFDN0Msc0JBQU0sUUFBUSxTQUFTO0FBQ3ZCLG9CQUFJLEtBQUssTUFBTSxPQUFPLGdCQUFnQixpQkFBaUI7QUFBQTtBQUV6RCwwQkFBWSxLQUFLLHdCQUF3QixJQUFJO0FBQUE7QUFFL0MsZ0JBQUksU0FBUyxLQUFLO0FBQ2hCLGtCQUFJLFVBQVUsU0FBUztBQUNyQiwrQkFBZTtBQUFBLHlCQUNOLFVBQVUsT0FBTztBQUMxQiwrQkFBZTtBQUFBO0FBQUE7QUFHbkIsa0JBQU0sYUFBYSxLQUFLO0FBQ3hCLGlCQUFLLElBQUksR0FBRyxPQUFPLE1BQU0sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQzlDLHFCQUFPLE1BQU07QUFDYixzQkFBUSxLQUFLO0FBQ2Isb0JBQU0sY0FBYyxZQUFZLFdBQVcsS0FBSyxXQUFXO0FBQzNELHNCQUFRLEtBQUssZ0JBQWdCLEtBQUssWUFBWTtBQUM5QyxxQkFBTyxLQUFLLHdCQUF3QjtBQUNwQywyQkFBYSxLQUFLO0FBQ2xCLDBCQUFZLFFBQVEsU0FBUyxNQUFNLFNBQVM7QUFDNUMsb0JBQU0sWUFBWSxZQUFZO0FBQzlCLG9CQUFNLFNBQVEsWUFBWTtBQUMxQixvQkFBTSxjQUFjLFlBQVk7QUFDaEMsb0JBQU0sY0FBYyxZQUFZO0FBQ2hDLGtCQUFJLGdCQUFnQjtBQUNwQixrQkFBSSxjQUFjO0FBQ2hCLG9CQUFJO0FBQ0osb0JBQUksY0FBYyxTQUFTO0FBQ3pCLHNCQUFJLE1BQU0sT0FBTyxHQUFHO0FBQ2xCLG9DQUFnQixDQUFDLEtBQUssUUFBUSxVQUFVLFVBQVU7QUFBQSw2QkFDekMsTUFBTSxHQUFHO0FBQ2xCLG9DQUFnQixDQUFDLEtBQUssUUFBUSxVQUFVLFNBQVM7QUFBQSx5QkFDNUM7QUFDTCxvQ0FBZ0I7QUFBQTtBQUFBO0FBR3BCLG9CQUFJLGFBQWEsT0FBTztBQUN0QixzQkFBSSxlQUFlLFVBQVUsYUFBYSxHQUFHO0FBQzNDLGlDQUFhLENBQUMsWUFBWSxhQUFhLGFBQWE7QUFBQSw2QkFDM0MsZUFBZSxVQUFVO0FBQ2xDLGlDQUFhLENBQUMsV0FBVyxRQUFRLFNBQVMsSUFBSSxZQUFZLGFBQWE7QUFBQSx5QkFDbEU7QUFDTCxpQ0FBYSxDQUFDLFdBQVcsUUFBUSxTQUFTLGFBQWE7QUFBQTtBQUFBLHVCQUVwRDtBQUNMLHNCQUFJLGVBQWUsVUFBVSxhQUFhLEdBQUc7QUFDM0MsaUNBQWEsYUFBYTtBQUFBLDZCQUNqQixlQUFlLFVBQVU7QUFDbEMsaUNBQWEsV0FBVyxRQUFRLFNBQVMsSUFBSSxZQUFZO0FBQUEseUJBQ3BEO0FBQ0wsaUNBQWEsV0FBVyxRQUFRLFNBQVMsWUFBWTtBQUFBO0FBQUE7QUFHekQsb0JBQUksUUFBUTtBQUNWLGdDQUFjO0FBQUE7QUFBQSxxQkFFWDtBQUNMLG9CQUFJO0FBQ0osNkJBQWMsS0FBSSxhQUFhLGFBQWE7QUFBQTtBQUU5QyxrQkFBSTtBQUNKLGtCQUFJLFlBQVksbUJBQW1CO0FBQ2pDLHNCQUFNLGVBQWUsVUFBVSxZQUFZO0FBQzNDLHNCQUFNLFNBQVMsV0FBVyxRQUFRO0FBQ2xDLHNCQUFNLFFBQVEsV0FBVyxPQUFPO0FBQ2hDLG9CQUFJLE1BQU0sSUFBSSxhQUFhLGFBQWE7QUFDeEMsb0JBQUksT0FBTyxJQUFJLGFBQWE7QUFDNUIsd0JBQVE7QUFBQSx1QkFDSDtBQUNILDJCQUFPLFNBQVM7QUFDaEI7QUFBQSx1QkFDRztBQUNILDJCQUFPO0FBQ1A7QUFBQTtBQUVGLHdCQUFRO0FBQUEsdUJBQ0g7QUFDSCw0QkFBUSxRQUFRO0FBQ2hCO0FBQUEsdUJBQ0c7QUFDSCw0QkFBUTtBQUNSO0FBQUE7QUFFRiwyQkFBVztBQUFBLGtCQUNUO0FBQUEsa0JBQ0E7QUFBQSxrQkFDQSxPQUFPLFFBQVEsYUFBYTtBQUFBLGtCQUM1QixRQUFRLFNBQVMsYUFBYTtBQUFBLGtCQUM5QixPQUFPLFlBQVk7QUFBQTtBQUFBO0FBR3ZCLG9CQUFNLEtBQUs7QUFBQSxnQkFDVDtBQUFBLGdCQUNBO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBLGdCQUNBO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBLGdCQUNBLFdBQVc7QUFBQSxnQkFDWDtBQUFBLGdCQUNBLGFBQWEsQ0FBQyxHQUFHO0FBQUEsZ0JBQ2pCO0FBQUE7QUFBQTtBQUdKLG1CQUFPO0FBQUE7QUFBQSxVQUVULDBCQUEwQjtBQUN4QixrQkFBTSxFQUFDLFVBQVUsVUFBUyxLQUFLO0FBQy9CLGtCQUFNLFdBQVcsQ0FBQyxVQUFVLEtBQUs7QUFDakMsZ0JBQUksVUFBVTtBQUNaLHFCQUFPLGFBQWEsUUFBUSxTQUFTO0FBQUE7QUFFdkMsZ0JBQUksUUFBUTtBQUNaLGdCQUFJLE1BQU0sVUFBVSxTQUFTO0FBQzNCLHNCQUFRO0FBQUEsdUJBQ0MsTUFBTSxVQUFVLE9BQU87QUFDaEMsc0JBQVE7QUFBQSx1QkFDQyxNQUFNLFVBQVUsU0FBUztBQUNsQyxzQkFBUTtBQUFBO0FBRVYsbUJBQU87QUFBQTtBQUFBLFVBRVQsd0JBQXdCLElBQUk7QUFDMUIsa0JBQU0sRUFBQyxVQUFVLE9BQU8sRUFBQyxZQUFZLFFBQVEsY0FBWSxLQUFLO0FBQzlELGtCQUFNLGFBQWEsS0FBSztBQUN4QixrQkFBTSxpQkFBaUIsS0FBSztBQUM1QixrQkFBTSxTQUFTLFdBQVcsT0FBTztBQUNqQyxnQkFBSTtBQUNKLGdCQUFJO0FBQ0osZ0JBQUksYUFBYSxRQUFRO0FBQ3ZCLGtCQUFJLFFBQVE7QUFDVixvQkFBSSxLQUFLLFFBQVE7QUFDakIsb0JBQUksZUFBZSxRQUFRO0FBQ3pCLDhCQUFZO0FBQUEsMkJBQ0gsZUFBZSxVQUFVO0FBQ2xDLDhCQUFZO0FBQ1osdUJBQU0sU0FBUztBQUFBLHVCQUNWO0FBQ0wsOEJBQVk7QUFDWix1QkFBSztBQUFBO0FBQUEscUJBRUY7QUFDTCxvQkFBSSxLQUFLLFFBQVE7QUFDakIsb0JBQUksZUFBZSxRQUFRO0FBQ3pCLDhCQUFZO0FBQUEsMkJBQ0gsZUFBZSxVQUFVO0FBQ2xDLDhCQUFZO0FBQ1osdUJBQU0sU0FBUztBQUFBLHVCQUNWO0FBQ0wsOEJBQVk7QUFDWixzQkFBSSxLQUFLO0FBQUE7QUFBQTtBQUFBLHVCQUdKLGFBQWEsU0FBUztBQUMvQixrQkFBSSxRQUFRO0FBQ1Ysb0JBQUksS0FBSyxPQUFPO0FBQ2hCLG9CQUFJLGVBQWUsUUFBUTtBQUN6Qiw4QkFBWTtBQUFBLDJCQUNILGVBQWUsVUFBVTtBQUNsQyw4QkFBWTtBQUNaLHVCQUFNLFNBQVM7QUFBQSx1QkFDVjtBQUNMLDhCQUFZO0FBQ1osdUJBQUs7QUFBQTtBQUFBLHFCQUVGO0FBQ0wsb0JBQUksS0FBSyxPQUFPO0FBQ2hCLG9CQUFJLGVBQWUsUUFBUTtBQUN6Qiw4QkFBWTtBQUFBLDJCQUNILGVBQWUsVUFBVTtBQUNsQyw4QkFBWTtBQUNaLHVCQUFLLFNBQVM7QUFBQSx1QkFDVDtBQUNMLDhCQUFZO0FBQ1osc0JBQUksS0FBSztBQUFBO0FBQUE7QUFBQSxtQkFHUjtBQUNMLDBCQUFZO0FBQUE7QUFFZCxtQkFBTyxFQUFDLFdBQVc7QUFBQTtBQUFBLFVBRXJCLG9CQUFvQjtBQUNsQixnQkFBSSxLQUFLLFFBQVEsTUFBTSxRQUFRO0FBQzdCO0FBQUE7QUFFRixrQkFBTSxTQUFRLEtBQUs7QUFDbkIsa0JBQU0sV0FBVyxLQUFLLFFBQVE7QUFDOUIsZ0JBQUksYUFBYSxVQUFVLGFBQWEsU0FBUztBQUMvQyxxQkFBTyxFQUFDLEtBQUssR0FBRyxNQUFNLEtBQUssTUFBTSxRQUFRLE9BQU0sUUFBUSxPQUFPLEtBQUs7QUFBQTtBQUNuRSxnQkFBSSxhQUFhLFNBQVMsYUFBYSxVQUFVO0FBQ2pELHFCQUFPLEVBQUMsS0FBSyxLQUFLLEtBQUssTUFBTSxHQUFHLFFBQVEsS0FBSyxRQUFRLE9BQU8sT0FBTTtBQUFBO0FBQUE7QUFBQSxVQUd0RSxpQkFBaUI7QUFDZixrQkFBTSxFQUFDLEtBQUssU0FBUyxFQUFDLG1CQUFrQixNQUFNLEtBQUssT0FBTyxXQUFVO0FBQ3BFLGdCQUFJLGlCQUFpQjtBQUNuQixrQkFBSTtBQUNKLGtCQUFJLFlBQVk7QUFDaEIsa0JBQUksU0FBUyxNQUFNLEtBQUssT0FBTztBQUMvQixrQkFBSTtBQUFBO0FBQUE7QUFBQSxVQUdSLHFCQUFxQixPQUFPO0FBQzFCLGtCQUFNLE9BQU8sS0FBSyxRQUFRO0FBQzFCLGdCQUFJLENBQUMsS0FBSyxnQkFBZ0IsQ0FBQyxLQUFLLFNBQVM7QUFDdkMscUJBQU87QUFBQTtBQUVULGtCQUFNLFFBQVEsS0FBSztBQUNuQixrQkFBTSxTQUFRLE1BQU0sVUFBVSxPQUFLLEVBQUUsVUFBVTtBQUMvQyxnQkFBSSxVQUFTLEdBQUc7QUFDZCxvQkFBTSxPQUFPLEtBQUssV0FBVyxLQUFLLFdBQVc7QUFDN0MscUJBQU8sS0FBSztBQUFBO0FBRWQsbUJBQU87QUFBQTtBQUFBLFVBRVQsU0FBUyxXQUFXO0FBQ2xCLGtCQUFNLE9BQU8sS0FBSyxRQUFRO0FBQzFCLGtCQUFNLE1BQU0sS0FBSztBQUNqQixrQkFBTSxRQUFRLEtBQUssa0JBQW1CLE1BQUssaUJBQWlCLEtBQUssc0JBQXNCO0FBQ3ZGLGdCQUFJLEdBQUc7QUFDUCxrQkFBTSxXQUFXLENBQUMsSUFBSSxJQUFJLFVBQVU7QUFDbEMsa0JBQUksQ0FBQyxNQUFNLFNBQVMsQ0FBQyxNQUFNLE9BQU87QUFDaEM7QUFBQTtBQUVGLGtCQUFJO0FBQ0osa0JBQUksWUFBWSxNQUFNO0FBQ3RCLGtCQUFJLGNBQWMsTUFBTTtBQUN4QixrQkFBSSxZQUFZLE1BQU0sY0FBYztBQUNwQyxrQkFBSSxpQkFBaUIsTUFBTTtBQUMzQixrQkFBSTtBQUNKLGtCQUFJLE9BQU8sR0FBRyxHQUFHLEdBQUc7QUFDcEIsa0JBQUksT0FBTyxHQUFHLEdBQUcsR0FBRztBQUNwQixrQkFBSTtBQUNKLGtCQUFJO0FBQUE7QUFFTixnQkFBSSxLQUFLLFNBQVM7QUFDaEIsbUJBQUssSUFBSSxHQUFHLE9BQU8sTUFBTSxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDOUMsc0JBQU0sT0FBTyxNQUFNO0FBQ25CLG9CQUFJLEtBQUssaUJBQWlCO0FBQ3hCLDJCQUNFLEVBQUMsR0FBRyxLQUFLLElBQUksR0FBRyxLQUFLLE1BQ3JCLEVBQUMsR0FBRyxLQUFLLElBQUksR0FBRyxLQUFLLE1BQ3JCO0FBQUE7QUFHSixvQkFBSSxLQUFLLFdBQVc7QUFDbEIsMkJBQ0UsRUFBQyxHQUFHLEtBQUssS0FBSyxHQUFHLEtBQUssT0FDdEIsRUFBQyxHQUFHLEtBQUssS0FBSyxHQUFHLEtBQUssT0FDdEI7QUFBQSxvQkFDRSxPQUFPLEtBQUs7QUFBQSxvQkFDWixPQUFPLEtBQUs7QUFBQSxvQkFDWixZQUFZLEtBQUs7QUFBQSxvQkFDakIsa0JBQWtCLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFPbkMsYUFBYTtBQUNYLGtCQUFNLEVBQUMsZUFBTyxLQUFLLFNBQVMsRUFBQyxXQUFTO0FBQ3RDLGtCQUFNLGFBQWEsS0FBSyxXQUFXLEtBQUs7QUFDeEMsa0JBQU0sWUFBWSxLQUFLLGFBQWEsV0FBVyxjQUFjO0FBQzdELGdCQUFJLENBQUMsV0FBVztBQUNkO0FBQUE7QUFFRixrQkFBTSxnQkFBZ0IsS0FBSyxXQUFXLEtBQUssV0FBVyxJQUFJO0FBQzFELGtCQUFNLGNBQWMsS0FBSztBQUN6QixnQkFBSSxJQUFJLElBQUksSUFBSTtBQUNoQixnQkFBSSxLQUFLLGdCQUFnQjtBQUN2QixtQkFBSyxZQUFZLFFBQU8sS0FBSyxNQUFNLGFBQWEsWUFBWTtBQUM1RCxtQkFBSyxZQUFZLFFBQU8sS0FBSyxPQUFPLGlCQUFpQixnQkFBZ0I7QUFDckUsbUJBQUssS0FBSztBQUFBLG1CQUNMO0FBQ0wsbUJBQUssWUFBWSxRQUFPLEtBQUssS0FBSyxhQUFhLFlBQVk7QUFDM0QsbUJBQUssWUFBWSxRQUFPLEtBQUssUUFBUSxpQkFBaUIsZ0JBQWdCO0FBQ3RFLG1CQUFLLEtBQUs7QUFBQTtBQUVaLGdCQUFJO0FBQ0osZ0JBQUksWUFBWSxXQUFXO0FBQzNCLGdCQUFJLGNBQWMsV0FBVztBQUM3QixnQkFBSTtBQUNKLGdCQUFJLE9BQU8sSUFBSTtBQUNmLGdCQUFJLE9BQU8sSUFBSTtBQUNmLGdCQUFJO0FBQ0osZ0JBQUk7QUFBQTtBQUFBLFVBRU4sV0FBVyxXQUFXO0FBQ3BCLGtCQUFNLGNBQWMsS0FBSyxRQUFRO0FBQ2pDLGdCQUFJLENBQUMsWUFBWSxTQUFTO0FBQ3hCO0FBQUE7QUFFRixrQkFBTSxNQUFNLEtBQUs7QUFDakIsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGdCQUFJLE1BQU07QUFDUix1QkFBUyxLQUFLO0FBQUE7QUFFaEIsa0JBQU0sUUFBUSxLQUFLLGVBQWdCLE1BQUssY0FBYyxLQUFLLG1CQUFtQjtBQUM5RSxnQkFBSSxHQUFHO0FBQ1AsaUJBQUssSUFBSSxHQUFHLE9BQU8sTUFBTSxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDOUMsb0JBQU0sT0FBTyxNQUFNO0FBQ25CLG9CQUFNLFdBQVcsS0FBSztBQUN0QixvQkFBTSxRQUFRLEtBQUs7QUFDbkIsa0JBQUksS0FBSyxVQUFVO0FBQ2pCLG9CQUFJLFlBQVksS0FBSyxTQUFTO0FBQzlCLG9CQUFJLFNBQVMsS0FBSyxTQUFTLE1BQU0sS0FBSyxTQUFTLEtBQUssS0FBSyxTQUFTLE9BQU8sS0FBSyxTQUFTO0FBQUE7QUFFekYsa0JBQUksSUFBSSxLQUFLO0FBQ2IseUJBQVcsS0FBSyxPQUFPLEdBQUcsR0FBRyxVQUFVO0FBQUE7QUFFekMsZ0JBQUksTUFBTTtBQUNSLHlCQUFXO0FBQUE7QUFBQTtBQUFBLFVBR2YsWUFBWTtBQUNWLGtCQUFNLEVBQUMsS0FBSyxTQUFTLEVBQUMsVUFBVSxPQUFPLGNBQVk7QUFDbkQsZ0JBQUksQ0FBQyxNQUFNLFNBQVM7QUFDbEI7QUFBQTtBQUVGLGtCQUFNLE9BQU8sT0FBTyxNQUFNO0FBQzFCLGtCQUFNLFVBQVUsVUFBVSxNQUFNO0FBQ2hDLGtCQUFNLFFBQVEsTUFBTTtBQUNwQixnQkFBSSxTQUFTLEtBQUssYUFBYTtBQUMvQixnQkFBSSxhQUFhLFlBQVksYUFBYSxZQUFZLFVBQVMsV0FBVztBQUN4RSx3QkFBVSxRQUFRO0FBQ2xCLGtCQUFJLFFBQVEsTUFBTSxPQUFPO0FBQ3ZCLDBCQUFVLEtBQUssYUFBYyxPQUFNLEtBQUssU0FBUztBQUFBO0FBQUEsbUJBRTlDO0FBQ0wsd0JBQVUsUUFBUTtBQUFBO0FBRXBCLGtCQUFNLEVBQUMsUUFBUSxRQUFRLFVBQVUsYUFBWSxVQUFVLE1BQU0sUUFBUSxVQUFVO0FBQy9FLHVCQUFXLEtBQUssTUFBTSxNQUFNLEdBQUcsR0FBRyxNQUFNO0FBQUEsY0FDdEMsT0FBTyxNQUFNO0FBQUEsY0FDYjtBQUFBLGNBQ0E7QUFBQSxjQUNBLFdBQVcsV0FBVyxPQUFPLFVBQVU7QUFBQSxjQUN2QyxjQUFjO0FBQUEsY0FDZCxhQUFhLENBQUMsUUFBUTtBQUFBO0FBQUE7QUFBQSxVQUcxQixLQUFLLFdBQVc7QUFDZCxnQkFBSSxDQUFDLEtBQUssY0FBYztBQUN0QjtBQUFBO0FBRUYsaUJBQUs7QUFDTCxpQkFBSyxTQUFTO0FBQ2QsaUJBQUs7QUFDTCxpQkFBSztBQUNMLGlCQUFLLFdBQVc7QUFBQTtBQUFBLFVBRWxCLFVBQVU7QUFDUixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sS0FBSyxLQUFLLFNBQVMsS0FBSyxNQUFNLEtBQUs7QUFDekMsa0JBQU0sS0FBSyxlQUFlLEtBQUssUUFBUSxLQUFLLEtBQUssR0FBRztBQUNwRCxnQkFBSSxDQUFDLEtBQUssZ0JBQWdCLEtBQUssU0FBUyxNQUFNLFVBQVUsTUFBTTtBQUM1RCxxQkFBTyxDQUFDO0FBQUEsZ0JBQ04sR0FBRztBQUFBLGdCQUNILE1BQU0sQ0FBQyxjQUFjO0FBQ25CLHVCQUFLLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFJaEIsbUJBQU8sQ0FBQztBQUFBLGNBQ04sR0FBRztBQUFBLGNBQ0gsTUFBTSxDQUFDLGNBQWM7QUFDbkIscUJBQUs7QUFDTCxxQkFBSyxTQUFTO0FBQ2QscUJBQUs7QUFBQTtBQUFBLGVBRU47QUFBQSxjQUNELEdBQUcsS0FBSztBQUFBLGNBQ1IsTUFBTSxNQUFNO0FBQ1YscUJBQUs7QUFBQTtBQUFBLGVBRU47QUFBQSxjQUNELEdBQUc7QUFBQSxjQUNILE1BQU0sQ0FBQyxjQUFjO0FBQ25CLHFCQUFLLFdBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUl0Qix3QkFBd0IsTUFBTTtBQUM1QixrQkFBTSxRQUFRLEtBQUssTUFBTTtBQUN6QixrQkFBTSxTQUFTLEtBQUssT0FBTztBQUMzQixrQkFBTSxTQUFTO0FBQ2YsZ0JBQUksR0FBRztBQUNQLGlCQUFLLElBQUksR0FBRyxPQUFPLE1BQU0sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQzlDLG9CQUFNLE9BQU8sTUFBTTtBQUNuQixrQkFBSSxLQUFLLFlBQVksS0FBSyxNQUFPLEVBQUMsUUFBUSxLQUFLLFNBQVMsT0FBTztBQUM3RCx1QkFBTyxLQUFLO0FBQUE7QUFBQTtBQUdoQixtQkFBTztBQUFBO0FBQUEsVUFFVCx3QkFBd0IsUUFBTztBQUM3QixrQkFBTSxPQUFPLEtBQUssUUFBUSxNQUFNLFdBQVcsS0FBSyxXQUFXO0FBQzNELG1CQUFPLE9BQU8sS0FBSztBQUFBO0FBQUEsVUFFckIsYUFBYTtBQUNYLGtCQUFNLFdBQVcsS0FBSyx3QkFBd0IsR0FBRztBQUNqRCxtQkFBUSxNQUFLLGlCQUFpQixLQUFLLFFBQVEsS0FBSyxVQUFVO0FBQUE7QUFBQTtBQUk5RCw0QkFBb0I7QUFBQSxVQUNsQixZQUFZLE1BQU0sT0FBTyxVQUFVO0FBQ2pDLGlCQUFLLE9BQU87QUFDWixpQkFBSyxRQUFRO0FBQ2IsaUJBQUssV0FBVztBQUNoQixpQkFBSyxRQUFRLE9BQU8sT0FBTztBQUFBO0FBQUEsVUFFN0IsVUFBVSxNQUFNO0FBQ2QsbUJBQU8sT0FBTyxVQUFVLGNBQWMsS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLO0FBQUE7QUFBQSxVQUV2RSxTQUFTLE1BQU07QUFDYixrQkFBTSxRQUFRLE9BQU8sZUFBZTtBQUNwQyxnQkFBSTtBQUNKLGdCQUFJLGtCQUFrQixRQUFRO0FBQzVCLDRCQUFjLEtBQUssU0FBUztBQUFBO0FBRTlCLGtCQUFNLFFBQVEsS0FBSztBQUNuQixrQkFBTSxLQUFLLEtBQUs7QUFDaEIsa0JBQU0sUUFBUSxLQUFLLFFBQVEsTUFBTTtBQUNqQyxnQkFBSSxDQUFDLElBQUk7QUFDUCxvQkFBTSxJQUFJLE1BQU0sNkJBQTZCO0FBQUE7QUFFL0MsZ0JBQUksTUFBTSxPQUFPO0FBQ2YscUJBQU87QUFBQTtBQUVULGtCQUFNLE1BQU07QUFDWiw2QkFBaUIsTUFBTSxPQUFPO0FBQzlCLGdCQUFJLEtBQUssVUFBVTtBQUNqQix1QkFBUyxTQUFTLEtBQUssSUFBSSxLQUFLO0FBQUE7QUFFbEMsbUJBQU87QUFBQTtBQUFBLFVBRVQsSUFBSSxJQUFJO0FBQ04sbUJBQU8sS0FBSyxNQUFNO0FBQUE7QUFBQSxVQUVwQixXQUFXLE1BQU07QUFDZixrQkFBTSxRQUFRLEtBQUs7QUFDbkIsa0JBQU0sS0FBSyxLQUFLO0FBQ2hCLGtCQUFNLFFBQVEsS0FBSztBQUNuQixnQkFBSSxNQUFNLE9BQU87QUFDZixxQkFBTyxNQUFNO0FBQUE7QUFFZixnQkFBSSxTQUFTLE1BQU0sU0FBUyxRQUFRO0FBQ2xDLHFCQUFPLFNBQVMsT0FBTztBQUN2QixrQkFBSSxLQUFLLFVBQVU7QUFDakIsdUJBQU8sVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS3pCLGtDQUEwQixNQUFNLE9BQU8sYUFBYTtBQUNsRCxnQkFBTSxlQUFlLE1BQU0sT0FBTyxPQUFPLE9BQU87QUFBQSxZQUM5QyxjQUFjLFNBQVMsSUFBSSxlQUFlO0FBQUEsWUFDMUMsU0FBUyxJQUFJO0FBQUEsWUFDYixLQUFLO0FBQUE7QUFFUCxtQkFBUyxJQUFJLE9BQU87QUFDcEIsY0FBSSxLQUFLLGVBQWU7QUFDdEIsMEJBQWMsT0FBTyxLQUFLO0FBQUE7QUFFNUIsY0FBSSxLQUFLLGFBQWE7QUFDcEIscUJBQVMsU0FBUyxPQUFPLEtBQUs7QUFBQTtBQUFBO0FBR2xDLCtCQUF1QixPQUFPLFFBQVE7QUFDcEMsaUJBQU8sS0FBSyxRQUFRLFFBQVEsY0FBWTtBQUN0QyxrQkFBTSxnQkFBZ0IsU0FBUyxNQUFNO0FBQ3JDLGtCQUFNLGFBQWEsY0FBYztBQUNqQyxrQkFBTSxjQUFjLENBQUMsT0FBTyxPQUFPLGVBQWUsS0FBSztBQUN2RCxrQkFBTSxRQUFRLE9BQU8sVUFBVSxNQUFNO0FBQ3JDLGtCQUFNLGFBQWEsTUFBTTtBQUN6QixrQkFBTSxjQUFjLE1BQU0sS0FBSztBQUMvQixxQkFBUyxNQUFNLGFBQWEsWUFBWSxhQUFhO0FBQUE7QUFBQTtBQUd6RCxtQ0FBMkIsT0FBTztBQUNoQyxpQkFBTyxRQUFRLFNBQVMsY0FBYztBQUFBO0FBR3hDLHVCQUFlO0FBQUEsVUFDYixjQUFjO0FBQ1osaUJBQUssY0FBYyxJQUFJLGNBQWMsbUJBQW1CLFlBQVk7QUFDcEUsaUJBQUssV0FBVyxJQUFJLGNBQWMsVUFBUztBQUMzQyxpQkFBSyxVQUFVLElBQUksY0FBYyxRQUFRO0FBQ3pDLGlCQUFLLFNBQVMsSUFBSSxjQUFjLE9BQU87QUFDdkMsaUJBQUssbUJBQW1CLENBQUMsS0FBSyxhQUFhLEtBQUssUUFBUSxLQUFLO0FBQUE7QUFBQSxVQUUvRCxPQUFPLE1BQU07QUFDWCxpQkFBSyxNQUFNLFlBQVk7QUFBQTtBQUFBLFVBRXpCLFVBQVUsTUFBTTtBQUNkLGlCQUFLLE1BQU0sY0FBYztBQUFBO0FBQUEsVUFFM0Isa0JBQWtCLE1BQU07QUFDdEIsaUJBQUssTUFBTSxZQUFZLE1BQU0sS0FBSztBQUFBO0FBQUEsVUFFcEMsZUFBZSxNQUFNO0FBQ25CLGlCQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUs7QUFBQTtBQUFBLFVBRXBDLGNBQWMsTUFBTTtBQUNsQixpQkFBSyxNQUFNLFlBQVksTUFBTSxLQUFLO0FBQUE7QUFBQSxVQUVwQyxhQUFhLE1BQU07QUFDakIsaUJBQUssTUFBTSxZQUFZLE1BQU0sS0FBSztBQUFBO0FBQUEsVUFFcEMsY0FBYyxJQUFJO0FBQ2hCLG1CQUFPLEtBQUssS0FBSyxJQUFJLEtBQUssYUFBYTtBQUFBO0FBQUEsVUFFekMsV0FBVyxJQUFJO0FBQ2IsbUJBQU8sS0FBSyxLQUFLLElBQUksS0FBSyxVQUFVO0FBQUE7QUFBQSxVQUV0QyxVQUFVLElBQUk7QUFDWixtQkFBTyxLQUFLLEtBQUssSUFBSSxLQUFLLFNBQVM7QUFBQTtBQUFBLFVBRXJDLFNBQVMsSUFBSTtBQUNYLG1CQUFPLEtBQUssS0FBSyxJQUFJLEtBQUssUUFBUTtBQUFBO0FBQUEsVUFFcEMscUJBQXFCLE1BQU07QUFDekIsaUJBQUssTUFBTSxjQUFjLE1BQU0sS0FBSztBQUFBO0FBQUEsVUFFdEMsa0JBQWtCLE1BQU07QUFDdEIsaUJBQUssTUFBTSxjQUFjLE1BQU0sS0FBSztBQUFBO0FBQUEsVUFFdEMsaUJBQWlCLE1BQU07QUFDckIsaUJBQUssTUFBTSxjQUFjLE1BQU0sS0FBSztBQUFBO0FBQUEsVUFFdEMsZ0JBQWdCLE1BQU07QUFDcEIsaUJBQUssTUFBTSxjQUFjLE1BQU0sS0FBSztBQUFBO0FBQUEsVUFFdEMsTUFBTSxRQUFRLE1BQU0sZUFBZTtBQUNqQyxhQUFDLEdBQUcsTUFBTSxRQUFRLFNBQU87QUFDdkIsb0JBQU0sTUFBTSxpQkFBaUIsS0FBSyxvQkFBb0I7QUFDdEQsa0JBQUksaUJBQWlCLElBQUksVUFBVSxRQUFTLFFBQVEsS0FBSyxXQUFXLElBQUksSUFBSztBQUMzRSxxQkFBSyxNQUFNLFFBQVEsS0FBSztBQUFBLHFCQUNuQjtBQUNMLHFCQUFLLEtBQUssVUFBUTtBQUNoQix3QkFBTSxVQUFVLGlCQUFpQixLQUFLLG9CQUFvQjtBQUMxRCx1QkFBSyxNQUFNLFFBQVEsU0FBUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFLcEMsTUFBTSxRQUFRLFdBQVUsV0FBVztBQUNqQyxrQkFBTSxjQUFjLFlBQVk7QUFDaEMscUJBQVMsVUFBVSxXQUFXLGNBQWMsSUFBSTtBQUNoRCxzQkFBUyxRQUFRO0FBQ2pCLHFCQUFTLFVBQVUsVUFBVSxjQUFjLElBQUk7QUFBQTtBQUFBLFVBRWpELG9CQUFvQixNQUFNO0FBQ3hCLHFCQUFTLElBQUksR0FBRyxJQUFJLEtBQUssaUJBQWlCLFFBQVEsS0FBSztBQUNyRCxvQkFBTSxNQUFNLEtBQUssaUJBQWlCO0FBQ2xDLGtCQUFJLElBQUksVUFBVSxPQUFPO0FBQ3ZCLHVCQUFPO0FBQUE7QUFBQTtBQUdYLG1CQUFPLEtBQUs7QUFBQTtBQUFBLFVBRWQsS0FBSyxJQUFJLGVBQWUsTUFBTTtBQUM1QixrQkFBTSxPQUFPLGNBQWMsSUFBSTtBQUMvQixnQkFBSSxTQUFTLFFBQVc7QUFDdEIsb0JBQU0sSUFBSSxNQUFNLE1BQU0sS0FBSywyQkFBMkIsT0FBTztBQUFBO0FBRS9ELG1CQUFPO0FBQUE7QUFBQTtBQUdYLFlBQUksV0FBVyxJQUFJO0FBRW5CLDRCQUFvQjtBQUFBLFVBQ2xCLGNBQWM7QUFDWixpQkFBSyxRQUFRO0FBQUE7QUFBQSxVQUVmLE9BQU8sUUFBTyxNQUFNLE1BQU0sUUFBUTtBQUNoQyxnQkFBSSxTQUFTLGNBQWM7QUFDekIsbUJBQUssUUFBUSxLQUFLLG1CQUFtQixRQUFPO0FBQzVDLG1CQUFLLFFBQVEsS0FBSyxPQUFPLFFBQU87QUFBQTtBQUVsQyxrQkFBTSxlQUFjLFNBQVMsS0FBSyxhQUFhLFFBQU8sT0FBTyxVQUFVLEtBQUssYUFBYTtBQUN6RixrQkFBTSxTQUFTLEtBQUssUUFBUSxjQUFhLFFBQU8sTUFBTTtBQUN0RCxnQkFBSSxTQUFTLGdCQUFnQjtBQUMzQixtQkFBSyxRQUFRLGNBQWEsUUFBTztBQUNqQyxtQkFBSyxRQUFRLEtBQUssT0FBTyxRQUFPO0FBQUE7QUFFbEMsbUJBQU87QUFBQTtBQUFBLFVBRVQsUUFBUSxjQUFhLFFBQU8sTUFBTSxNQUFNO0FBQ3RDLG1CQUFPLFFBQVE7QUFDZix1QkFBVyxjQUFjLGNBQWE7QUFDcEMsb0JBQU0sU0FBUyxXQUFXO0FBQzFCLG9CQUFNLFNBQVMsT0FBTztBQUN0QixvQkFBTSxTQUFTLENBQUMsUUFBTyxNQUFNLFdBQVc7QUFDeEMsa0JBQUksU0FBUyxRQUFRLFFBQVEsWUFBWSxTQUFTLEtBQUssWUFBWTtBQUNqRSx1QkFBTztBQUFBO0FBQUE7QUFHWCxtQkFBTztBQUFBO0FBQUEsVUFFVCxhQUFhO0FBQ1gsZ0JBQUksQ0FBQyxjQUFjLEtBQUssU0FBUztBQUMvQixtQkFBSyxZQUFZLEtBQUs7QUFDdEIsbUJBQUssU0FBUztBQUFBO0FBQUE7QUFBQSxVQUdsQixhQUFhLFFBQU87QUFDbEIsZ0JBQUksS0FBSyxRQUFRO0FBQ2YscUJBQU8sS0FBSztBQUFBO0FBRWQsa0JBQU0sZUFBYyxLQUFLLFNBQVMsS0FBSyxtQkFBbUI7QUFDMUQsaUJBQUssb0JBQW9CO0FBQ3pCLG1CQUFPO0FBQUE7QUFBQSxVQUVULG1CQUFtQixRQUFPLEtBQUs7QUFDN0Isa0JBQU0sU0FBUyxVQUFTLE9BQU07QUFDOUIsa0JBQU0sVUFBVSxlQUFlLE9BQU8sV0FBVyxPQUFPLFFBQVEsU0FBUztBQUN6RSxrQkFBTSxXQUFVLFdBQVc7QUFDM0IsbUJBQU8sWUFBWSxTQUFTLENBQUMsTUFBTSxLQUFLLGtCQUFrQixRQUFPLFVBQVMsU0FBUztBQUFBO0FBQUEsVUFFckYsb0JBQW9CLFFBQU87QUFDekIsa0JBQU0sc0JBQXNCLEtBQUssYUFBYTtBQUM5QyxrQkFBTSxlQUFjLEtBQUs7QUFDekIsa0JBQU0sT0FBTyxDQUFDLEdBQUcsTUFBTSxFQUFFLE9BQU8sT0FBSyxDQUFDLEVBQUUsS0FBSyxPQUFLLEVBQUUsT0FBTyxPQUFPLEVBQUUsT0FBTztBQUMzRSxpQkFBSyxRQUFRLEtBQUsscUJBQXFCLGVBQWMsUUFBTztBQUM1RCxpQkFBSyxRQUFRLEtBQUssY0FBYSxzQkFBc0IsUUFBTztBQUFBO0FBQUE7QUFHaEUsNEJBQW9CLFFBQVE7QUFDMUIsZ0JBQU0sV0FBVztBQUNqQixnQkFBTSxXQUFVO0FBQ2hCLGdCQUFNLE9BQU8sT0FBTyxLQUFLLFNBQVMsUUFBUTtBQUMxQyxtQkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNwQyxxQkFBUSxLQUFLLFNBQVMsVUFBVSxLQUFLO0FBQUE7QUFFdkMsZ0JBQU0sUUFBUSxPQUFPLFdBQVc7QUFDaEMsbUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFDckMsa0JBQU0sU0FBUyxNQUFNO0FBQ3JCLGdCQUFJLFNBQVEsUUFBUSxZQUFZLElBQUk7QUFDbEMsdUJBQVEsS0FBSztBQUNiLHVCQUFTLE9BQU8sTUFBTTtBQUFBO0FBQUE7QUFHMUIsaUJBQU8sRUFBQyxtQkFBUztBQUFBO0FBRW5CLHlCQUFpQixTQUFTLEtBQUs7QUFDN0IsY0FBSSxDQUFDLE9BQU8sWUFBWSxPQUFPO0FBQzdCLG1CQUFPO0FBQUE7QUFFVCxjQUFJLFlBQVksTUFBTTtBQUNwQixtQkFBTztBQUFBO0FBRVQsaUJBQU87QUFBQTtBQUVULG1DQUEyQixRQUFPLEVBQUMsbUJBQVMsWUFBVyxTQUFTLEtBQUs7QUFDbkUsZ0JBQU0sU0FBUztBQUNmLGdCQUFNLFVBQVUsT0FBTTtBQUN0QixxQkFBVyxVQUFVLFVBQVM7QUFDNUIsa0JBQU0sS0FBSyxPQUFPO0FBQ2xCLGtCQUFNLE9BQU8sUUFBUSxRQUFRLEtBQUs7QUFDbEMsZ0JBQUksU0FBUyxNQUFNO0FBQ2pCO0FBQUE7QUFFRixtQkFBTyxLQUFLO0FBQUEsY0FDVjtBQUFBLGNBQ0EsU0FBUyxXQUFXLE9BQU0sUUFBUSxFQUFDLFFBQVEsT0FBTyxTQUFTLE9BQU0sTUFBTTtBQUFBO0FBQUE7QUFHM0UsaUJBQU87QUFBQTtBQUVULDRCQUFvQixRQUFRLEVBQUMsUUFBUSxTQUFRLE1BQU0sU0FBUztBQUMxRCxnQkFBTSxPQUFPLE9BQU8sZ0JBQWdCO0FBQ3BDLGdCQUFNLFNBQVMsT0FBTyxnQkFBZ0IsTUFBTTtBQUM1QyxjQUFJLFNBQVMsT0FBTyxVQUFVO0FBQzVCLG1CQUFPLEtBQUssT0FBTztBQUFBO0FBRXJCLGlCQUFPLE9BQU8sZUFBZSxRQUFRLFNBQVMsQ0FBQyxLQUFLO0FBQUEsWUFDbEQsWUFBWTtBQUFBLFlBQ1osV0FBVztBQUFBLFlBQ1gsU0FBUztBQUFBO0FBQUE7QUFJYiw4QkFBc0IsTUFBTSxTQUFTO0FBQ25DLGdCQUFNLGtCQUFrQixTQUFTLFNBQVMsU0FBUztBQUNuRCxnQkFBTSxpQkFBa0IsU0FBUSxZQUFZLElBQUksU0FBUztBQUN6RCxpQkFBTyxlQUFlLGFBQWEsUUFBUSxhQUFhLGdCQUFnQixhQUFhO0FBQUE7QUFFdkYsMkNBQW1DLElBQUksV0FBVztBQUNoRCxjQUFJLE9BQU87QUFDWCxjQUFJLE9BQU8sV0FBVztBQUNwQixtQkFBTztBQUFBLHFCQUNFLE9BQU8sV0FBVztBQUMzQixtQkFBTyxjQUFjLE1BQU0sTUFBTTtBQUFBO0FBRW5DLGlCQUFPO0FBQUE7QUFFVCwyQ0FBbUMsTUFBTSxXQUFXO0FBQ2xELGlCQUFPLFNBQVMsWUFBWSxZQUFZO0FBQUE7QUFFMUMsa0NBQTBCLFVBQVU7QUFDbEMsY0FBSSxhQUFhLFNBQVMsYUFBYSxVQUFVO0FBQy9DLG1CQUFPO0FBQUE7QUFFVCxjQUFJLGFBQWEsVUFBVSxhQUFhLFNBQVM7QUFDL0MsbUJBQU87QUFBQTtBQUFBO0FBR1gsK0JBQXVCLElBQUksY0FBYztBQUN2QyxjQUFJLE9BQU8sT0FBTyxPQUFPLEtBQUs7QUFDNUIsbUJBQU87QUFBQTtBQUVULGlCQUFPLGFBQWEsUUFBUSxpQkFBaUIsYUFBYSxhQUFhLEdBQUcsT0FBTyxHQUFHO0FBQUE7QUFFdEYsa0NBQTBCLFFBQVEsU0FBUztBQUN6QyxnQkFBTSxnQkFBZ0IsVUFBVSxPQUFPLFNBQVMsRUFBQyxRQUFRO0FBQ3pELGdCQUFNLGVBQWUsUUFBUSxVQUFVO0FBQ3ZDLGdCQUFNLGlCQUFpQixhQUFhLE9BQU8sTUFBTTtBQUNqRCxnQkFBTSxXQUFXLE9BQU8sT0FBTztBQUMvQixnQkFBTSxVQUFTLE9BQU8sT0FBTztBQUM3QixpQkFBTyxLQUFLLGNBQWMsUUFBUSxRQUFNO0FBQ3RDLGtCQUFNLFlBQVksYUFBYTtBQUMvQixnQkFBSSxDQUFDLFVBQVMsWUFBWTtBQUN4QixxQkFBTyxRQUFRLE1BQU0sMENBQTBDO0FBQUE7QUFFakUsZ0JBQUksVUFBVSxRQUFRO0FBQ3BCLHFCQUFPLFFBQVEsS0FBSyxrREFBa0Q7QUFBQTtBQUV4RSxrQkFBTSxPQUFPLGNBQWMsSUFBSTtBQUMvQixrQkFBTSxZQUFZLDBCQUEwQixNQUFNO0FBQ2xELGtCQUFNLHNCQUFzQixjQUFjLFVBQVU7QUFDcEQscUJBQVMsUUFBUSxTQUFTLFNBQVM7QUFDbkMsb0JBQU8sTUFBTSxRQUFRLE9BQU8sT0FBTyxPQUFPLENBQUMsRUFBQyxRQUFPLFdBQVcsb0JBQW9CLE9BQU8sb0JBQW9CO0FBQUE7QUFFL0csaUJBQU8sS0FBSyxTQUFTLFFBQVEsYUFBVztBQUN0QyxrQkFBTSxPQUFPLFFBQVEsUUFBUSxPQUFPO0FBQ3BDLGtCQUFNLFlBQVksUUFBUSxhQUFhLGFBQWEsTUFBTTtBQUMxRCxrQkFBTSxrQkFBa0IsVUFBVSxTQUFTO0FBQzNDLGtCQUFNLHNCQUFzQixnQkFBZ0IsVUFBVTtBQUN0RCxtQkFBTyxLQUFLLHFCQUFxQixRQUFRLGVBQWE7QUFDcEQsb0JBQU0sT0FBTywwQkFBMEIsV0FBVztBQUNsRCxvQkFBTSxLQUFLLFFBQVEsT0FBTyxhQUFhLFNBQVMsU0FBUztBQUN6RCxzQkFBTyxNQUFNLFFBQU8sT0FBTyxPQUFPLE9BQU87QUFDekMsc0JBQVEsUUFBTyxLQUFLLENBQUMsRUFBQyxRQUFPLGFBQWEsS0FBSyxvQkFBb0I7QUFBQTtBQUFBO0FBR3ZFLGlCQUFPLEtBQUssU0FBUSxRQUFRLFNBQU87QUFDakMsa0JBQU0sUUFBUSxRQUFPO0FBQ3JCLG9CQUFRLE9BQU8sQ0FBQyxTQUFTLE9BQU8sTUFBTSxPQUFPLFNBQVM7QUFBQTtBQUV4RCxpQkFBTztBQUFBO0FBRVQsNkJBQXFCLFFBQVE7QUFDM0IsZ0JBQU0sVUFBVSxPQUFPLFdBQVksUUFBTyxVQUFVO0FBQ3BELGtCQUFRLFVBQVUsZUFBZSxRQUFRLFNBQVM7QUFDbEQsa0JBQVEsU0FBUyxpQkFBaUIsUUFBUTtBQUFBO0FBRTVDLDBCQUFrQixNQUFNO0FBQ3RCLGlCQUFPLFFBQVE7QUFDZixlQUFLLFdBQVcsS0FBSyxZQUFZO0FBQ2pDLGVBQUssU0FBUyxLQUFLLFVBQVU7QUFDN0IsaUJBQU87QUFBQTtBQUVULDRCQUFvQixRQUFRO0FBQzFCLG1CQUFTLFVBQVU7QUFDbkIsaUJBQU8sT0FBTyxTQUFTLE9BQU87QUFDOUIsc0JBQVk7QUFDWixpQkFBTztBQUFBO0FBRVQsY0FBTSxXQUFXLG9CQUFJO0FBQ3JCLGNBQU0sYUFBYSxvQkFBSTtBQUN2Qiw0QkFBb0IsVUFBVSxVQUFVO0FBQ3RDLGNBQUksT0FBTyxTQUFTLElBQUk7QUFDeEIsY0FBSSxDQUFDLE1BQU07QUFDVCxtQkFBTztBQUNQLHFCQUFTLElBQUksVUFBVTtBQUN2Qix1QkFBVyxJQUFJO0FBQUE7QUFFakIsaUJBQU87QUFBQTtBQUVULGNBQU0sYUFBYSxDQUFDLE1BQUssS0FBSyxRQUFRO0FBQ3BDLGdCQUFNLE9BQU8saUJBQWlCLEtBQUs7QUFDbkMsY0FBSSxTQUFTLFFBQVc7QUFDdEIsaUJBQUksSUFBSTtBQUFBO0FBQUE7QUFHWixxQkFBYTtBQUFBLFVBQ1gsWUFBWSxRQUFRO0FBQ2xCLGlCQUFLLFVBQVUsV0FBVztBQUMxQixpQkFBSyxjQUFjLG9CQUFJO0FBQ3ZCLGlCQUFLLGlCQUFpQixvQkFBSTtBQUFBO0FBQUEsY0FFeEIsV0FBVztBQUNiLG1CQUFPLEtBQUssUUFBUTtBQUFBO0FBQUEsY0FFbEIsT0FBTztBQUNULG1CQUFPLEtBQUssUUFBUTtBQUFBO0FBQUEsY0FFbEIsS0FBSyxNQUFNO0FBQ2IsaUJBQUssUUFBUSxPQUFPO0FBQUE7QUFBQSxjQUVsQixPQUFPO0FBQ1QsbUJBQU8sS0FBSyxRQUFRO0FBQUE7QUFBQSxjQUVsQixLQUFLLE1BQU07QUFDYixpQkFBSyxRQUFRLE9BQU8sU0FBUztBQUFBO0FBQUEsY0FFM0IsVUFBVTtBQUNaLG1CQUFPLEtBQUssUUFBUTtBQUFBO0FBQUEsY0FFbEIsUUFBUSxTQUFTO0FBQ25CLGlCQUFLLFFBQVEsVUFBVTtBQUFBO0FBQUEsY0FFckIsVUFBVTtBQUNaLG1CQUFPLEtBQUssUUFBUTtBQUFBO0FBQUEsVUFFdEIsU0FBUztBQUNQLGtCQUFNLFNBQVMsS0FBSztBQUNwQixpQkFBSztBQUNMLHdCQUFZO0FBQUE7QUFBQSxVQUVkLGFBQWE7QUFDWCxpQkFBSyxZQUFZO0FBQ2pCLGlCQUFLLGVBQWU7QUFBQTtBQUFBLFVBRXRCLGlCQUFpQixhQUFhO0FBQzVCLG1CQUFPLFdBQVcsYUFDaEIsTUFBTSxDQUFDO0FBQUEsY0FDTCxZQUFZO0FBQUEsY0FDWjtBQUFBO0FBQUE7QUFBQSxVQUdOLDBCQUEwQixhQUFhLFlBQVk7QUFDakQsbUJBQU8sV0FBVyxHQUFHLDBCQUEwQixjQUM3QyxNQUFNO0FBQUEsY0FDSjtBQUFBLGdCQUNFLFlBQVksMkJBQTJCO0FBQUEsZ0JBQ3ZDLGVBQWU7QUFBQTtBQUFBLGNBRWpCO0FBQUEsZ0JBQ0UsWUFBWTtBQUFBLGdCQUNaO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFJUix3QkFBd0IsYUFBYSxhQUFhO0FBQ2hELG1CQUFPLFdBQVcsR0FBRyxlQUFlLGVBQ2xDLE1BQU0sQ0FBQztBQUFBLGNBQ0wsWUFBWSx3QkFBd0I7QUFBQSxjQUNwQyxZQUFZO0FBQUEsY0FDWixZQUFZO0FBQUEsY0FDWjtBQUFBO0FBQUE7QUFBQSxVQUdOLGdCQUFnQixRQUFRO0FBQ3RCLGtCQUFNLEtBQUssT0FBTztBQUNsQixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsbUJBQU8sV0FBVyxHQUFHLGVBQWUsTUFDbEMsTUFBTSxDQUFDO0FBQUEsY0FDTCxXQUFXO0FBQUEsY0FDWCxHQUFHLE9BQU8sMEJBQTBCO0FBQUE7QUFBQTtBQUFBLFVBRzFDLGNBQWMsV0FBVyxZQUFZO0FBQ25DLGtCQUFNLGNBQWMsS0FBSztBQUN6QixnQkFBSSxRQUFRLFlBQVksSUFBSTtBQUM1QixnQkFBSSxDQUFDLFNBQVMsWUFBWTtBQUN4QixzQkFBUSxvQkFBSTtBQUNaLDBCQUFZLElBQUksV0FBVztBQUFBO0FBRTdCLG1CQUFPO0FBQUE7QUFBQSxVQUVULGdCQUFnQixXQUFXLFVBQVUsWUFBWTtBQUMvQyxrQkFBTSxFQUFDLFNBQVMsU0FBUTtBQUN4QixrQkFBTSxRQUFRLEtBQUssY0FBYyxXQUFXO0FBQzVDLGtCQUFNLFNBQVMsTUFBTSxJQUFJO0FBQ3pCLGdCQUFJLFFBQVE7QUFDVixxQkFBTztBQUFBO0FBRVQsa0JBQU0sU0FBUyxvQkFBSTtBQUNuQixxQkFBUyxRQUFRLFVBQVE7QUFDdkIsa0JBQUksV0FBVztBQUNiLHVCQUFPLElBQUk7QUFDWCxxQkFBSyxRQUFRLFNBQU8sV0FBVyxRQUFRLFdBQVc7QUFBQTtBQUVwRCxtQkFBSyxRQUFRLFNBQU8sV0FBVyxRQUFRLFNBQVM7QUFDaEQsbUJBQUssUUFBUSxTQUFPLFdBQVcsUUFBUSxVQUFVLFNBQVMsSUFBSTtBQUM5RCxtQkFBSyxRQUFRLFNBQU8sV0FBVyxRQUFRLFVBQVU7QUFDakQsbUJBQUssUUFBUSxTQUFPLFdBQVcsUUFBUSxhQUFhO0FBQUE7QUFFdEQsa0JBQU0sUUFBUSxNQUFNLEtBQUs7QUFDekIsZ0JBQUksTUFBTSxXQUFXLEdBQUc7QUFDdEIsb0JBQU0sS0FBSyxPQUFPLE9BQU87QUFBQTtBQUUzQixnQkFBSSxXQUFXLElBQUksV0FBVztBQUM1QixvQkFBTSxJQUFJLFVBQVU7QUFBQTtBQUV0QixtQkFBTztBQUFBO0FBQUEsVUFFVCxvQkFBb0I7QUFDbEIsa0JBQU0sRUFBQyxTQUFTLFNBQVE7QUFDeEIsbUJBQU87QUFBQSxjQUNMO0FBQUEsY0FDQSxVQUFVLFNBQVM7QUFBQSxjQUNuQixTQUFTLFNBQVMsU0FBUztBQUFBLGNBQzNCLEVBQUM7QUFBQSxjQUNEO0FBQUEsY0FDQTtBQUFBO0FBQUE7QUFBQSxVQUdKLG9CQUFvQixRQUFRLFFBQU8sU0FBUyxXQUFXLENBQUMsS0FBSztBQUMzRCxrQkFBTSxTQUFTLEVBQUMsU0FBUztBQUN6QixrQkFBTSxFQUFDLFVBQVUsZ0JBQWUsWUFBWSxLQUFLLGdCQUFnQixRQUFRO0FBQ3pFLGdCQUFJLFVBQVU7QUFDZCxnQkFBSSxZQUFZLFVBQVUsU0FBUTtBQUNoQyxxQkFBTyxVQUFVO0FBQ2pCLHdCQUFVLFlBQVcsV0FBVyxZQUFZO0FBQzVDLG9CQUFNLGNBQWMsS0FBSyxlQUFlLFFBQVEsU0FBUztBQUN6RCx3QkFBVSxlQUFlLFVBQVUsU0FBUztBQUFBO0FBRTlDLHVCQUFXLFFBQVEsUUFBTztBQUN4QixxQkFBTyxRQUFRLFFBQVE7QUFBQTtBQUV6QixtQkFBTztBQUFBO0FBQUEsVUFFVCxlQUFlLFFBQVEsU0FBUyxXQUFXLENBQUMsS0FBSyxvQkFBb0I7QUFDbkUsa0JBQU0sRUFBQyxhQUFZLFlBQVksS0FBSyxnQkFBZ0IsUUFBUTtBQUM1RCxtQkFBTyxVQUFTLFdBQ1osZUFBZSxVQUFVLFNBQVMsUUFBVyxzQkFDN0M7QUFBQTtBQUFBO0FBR1IsNkJBQXFCLGVBQWUsUUFBUSxVQUFVO0FBQ3BELGNBQUksUUFBUSxjQUFjLElBQUk7QUFDOUIsY0FBSSxDQUFDLE9BQU87QUFDVixvQkFBUSxvQkFBSTtBQUNaLDBCQUFjLElBQUksUUFBUTtBQUFBO0FBRTVCLGdCQUFNLFdBQVcsU0FBUztBQUMxQixjQUFJLFNBQVMsTUFBTSxJQUFJO0FBQ3ZCLGNBQUksQ0FBQyxRQUFRO0FBQ1gsa0JBQU0sV0FBVyxnQkFBZ0IsUUFBUTtBQUN6QyxxQkFBUztBQUFBLGNBQ1A7QUFBQSxjQUNBLGFBQWEsU0FBUyxPQUFPLE9BQUssQ0FBQyxFQUFFLGNBQWMsU0FBUztBQUFBO0FBRTlELGtCQUFNLElBQUksVUFBVTtBQUFBO0FBRXRCLGlCQUFPO0FBQUE7QUFFVCxjQUFNLGNBQWMsV0FBUyxVQUFTLFVBQ2pDLE9BQU8sb0JBQW9CLE9BQU8sT0FBTyxDQUFDLEtBQUssUUFBUSxPQUFPLFlBQVcsTUFBTSxPQUFPO0FBQzNGLDZCQUFxQixPQUFPLFFBQU87QUFDakMsZ0JBQU0sRUFBQyxjQUFjLGdCQUFlLGFBQWE7QUFDakQscUJBQVcsUUFBUSxRQUFPO0FBQ3hCLGtCQUFNLGFBQWEsYUFBYTtBQUNoQyxrQkFBTSxZQUFZLFlBQVk7QUFDOUIsa0JBQU0sUUFBUyxjQUFhLGVBQWUsTUFBTTtBQUNqRCxnQkFBSyxjQUFlLGFBQVcsVUFBVSxZQUFZLFdBQy9DLGFBQWEsUUFBUSxRQUFTO0FBQ2xDLHFCQUFPO0FBQUE7QUFBQTtBQUdYLGlCQUFPO0FBQUE7QUFHVCxZQUFJLFVBQVU7QUFFZCxjQUFNLGtCQUFrQixDQUFDLE9BQU8sVUFBVSxRQUFRLFNBQVM7QUFDM0Qsc0NBQThCLFVBQVUsTUFBTTtBQUM1QyxpQkFBTyxhQUFhLFNBQVMsYUFBYSxZQUFhLGdCQUFnQixRQUFRLGNBQWMsTUFBTSxTQUFTO0FBQUE7QUFFOUcsK0JBQXVCLElBQUksSUFBSTtBQUM3QixpQkFBTyxTQUFTLEdBQUcsR0FBRztBQUNwQixtQkFBTyxFQUFFLFFBQVEsRUFBRSxNQUNmLEVBQUUsTUFBTSxFQUFFLE1BQ1YsRUFBRSxNQUFNLEVBQUU7QUFBQTtBQUFBO0FBR2xCLHNDQUE4QixTQUFTO0FBQ3JDLGdCQUFNLFNBQVEsUUFBUTtBQUN0QixnQkFBTSxvQkFBbUIsT0FBTSxRQUFRO0FBQ3ZDLGlCQUFNLGNBQWM7QUFDcEIsbUJBQVMscUJBQW9CLGtCQUFpQixZQUFZLENBQUMsVUFBVTtBQUFBO0FBRXZFLHFDQUE2QixTQUFTO0FBQ3BDLGdCQUFNLFNBQVEsUUFBUTtBQUN0QixnQkFBTSxvQkFBbUIsT0FBTSxRQUFRO0FBQ3ZDLG1CQUFTLHFCQUFvQixrQkFBaUIsWUFBWSxDQUFDLFVBQVU7QUFBQTtBQUV2RSwyQkFBbUIsTUFBTTtBQUN2QixjQUFJLHFCQUFxQixPQUFPLFNBQVMsVUFBVTtBQUNqRCxtQkFBTyxTQUFTLGVBQWU7QUFBQSxxQkFDdEIsUUFBUSxLQUFLLFFBQVE7QUFDOUIsbUJBQU8sS0FBSztBQUFBO0FBRWQsY0FBSSxRQUFRLEtBQUssUUFBUTtBQUN2QixtQkFBTyxLQUFLO0FBQUE7QUFFZCxpQkFBTztBQUFBO0FBRVQsY0FBTSxZQUFZO0FBQ2xCLGNBQU0sV0FBVyxDQUFDLFFBQVE7QUFDeEIsZ0JBQU0sU0FBUyxVQUFVO0FBQ3pCLGlCQUFPLE9BQU8sT0FBTyxXQUFXLE9BQU8sQ0FBQyxNQUFNLEVBQUUsV0FBVyxRQUFRO0FBQUE7QUFFckUsaUNBQXlCLEtBQUssT0FBTyxPQUFNO0FBQ3pDLGdCQUFNLE9BQU8sT0FBTyxLQUFLO0FBQ3pCLHFCQUFXLE9BQU8sTUFBTTtBQUN0QixrQkFBTSxTQUFTLENBQUM7QUFDaEIsZ0JBQUksVUFBVSxPQUFPO0FBQ25CLG9CQUFNLFFBQVEsSUFBSTtBQUNsQixxQkFBTyxJQUFJO0FBQ1gsa0JBQUksUUFBTyxLQUFLLFNBQVMsT0FBTztBQUM5QixvQkFBSSxTQUFTLFNBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUs3QixvQ0FBNEIsR0FBRyxXQUFXLGFBQWEsU0FBUztBQUM5RCxjQUFJLENBQUMsZUFBZSxFQUFFLFNBQVMsWUFBWTtBQUN6QyxtQkFBTztBQUFBO0FBRVQsY0FBSSxTQUFTO0FBQ1gsbUJBQU87QUFBQTtBQUVULGlCQUFPO0FBQUE7QUFFVCxxQkFBWTtBQUFBLFVBQ1YsWUFBWSxNQUFNLFlBQVk7QUFDNUIsa0JBQU0sU0FBUyxLQUFLLFNBQVMsSUFBSSxPQUFPO0FBQ3hDLGtCQUFNLGdCQUFnQixVQUFVO0FBQ2hDLGtCQUFNLGdCQUFnQixTQUFTO0FBQy9CLGdCQUFJLGVBQWU7QUFDakIsb0JBQU0sSUFBSSxNQUNSLDhDQUErQyxjQUFjLEtBQUssb0RBQ2xCLGNBQWMsT0FBTyxLQUFLO0FBQUE7QUFHOUUsa0JBQU0sVUFBVSxPQUFPLGVBQWUsT0FBTyxxQkFBcUIsS0FBSztBQUN2RSxpQkFBSyxXQUFXLElBQUssUUFBTyxZQUFZLGdCQUFnQjtBQUN4RCxpQkFBSyxTQUFTLGFBQWE7QUFDM0Isa0JBQU0sVUFBVSxLQUFLLFNBQVMsZUFBZSxlQUFlLFFBQVE7QUFDcEUsa0JBQU0sU0FBUyxXQUFXLFFBQVE7QUFDbEMsa0JBQU0sU0FBUyxVQUFVLE9BQU87QUFDaEMsa0JBQU0sUUFBUSxVQUFVLE9BQU87QUFDL0IsaUJBQUssS0FBSztBQUNWLGlCQUFLLE1BQU07QUFDWCxpQkFBSyxTQUFTO0FBQ2QsaUJBQUssUUFBUTtBQUNiLGlCQUFLLFNBQVM7QUFDZCxpQkFBSyxXQUFXO0FBQ2hCLGlCQUFLLGVBQWUsS0FBSztBQUN6QixpQkFBSyxVQUFVO0FBQ2YsaUJBQUssWUFBWTtBQUNqQixpQkFBSyxVQUFVO0FBQ2YsaUJBQUssUUFBUTtBQUNiLGlCQUFLLDBCQUEwQjtBQUMvQixpQkFBSyxZQUFZO0FBQ2pCLGlCQUFLLFVBQVU7QUFDZixpQkFBSyxhQUFhO0FBQ2xCLGlCQUFLLGFBQWE7QUFDbEIsaUJBQUssdUJBQXVCO0FBQzVCLGlCQUFLLGtCQUFrQjtBQUN2QixpQkFBSyxTQUFTO0FBQ2QsaUJBQUssV0FBVyxJQUFJO0FBQ3BCLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssaUJBQWlCO0FBQ3RCLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssc0JBQXNCO0FBQzNCLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssWUFBWSxTQUFTLFVBQVEsS0FBSyxPQUFPLE9BQU8sUUFBUSxlQUFlO0FBQzVFLGlCQUFLLGVBQWU7QUFDcEIsc0JBQVUsS0FBSyxNQUFNO0FBQ3JCLGdCQUFJLENBQUMsV0FBVyxDQUFDLFFBQVE7QUFDdkIsc0JBQVEsTUFBTTtBQUNkO0FBQUE7QUFFRixxQkFBUyxPQUFPLE1BQU0sWUFBWTtBQUNsQyxxQkFBUyxPQUFPLE1BQU0sWUFBWTtBQUNsQyxpQkFBSztBQUNMLGdCQUFJLEtBQUssVUFBVTtBQUNqQixtQkFBSztBQUFBO0FBQUE7QUFBQSxjQUdMLGNBQWM7QUFDaEIsa0JBQU0sRUFBQyxTQUFTLEVBQUMsYUFBYSx1QkFBc0IsT0FBTyxRQUFRLGlCQUFnQjtBQUNuRixnQkFBSSxDQUFDLGNBQWMsY0FBYztBQUMvQixxQkFBTztBQUFBO0FBRVQsZ0JBQUksdUJBQXVCLGNBQWM7QUFDdkMscUJBQU87QUFBQTtBQUVULG1CQUFPLFNBQVMsUUFBUSxTQUFTO0FBQUE7QUFBQSxjQUUvQixPQUFPO0FBQ1QsbUJBQU8sS0FBSyxPQUFPO0FBQUE7QUFBQSxjQUVqQixLQUFLLE1BQU07QUFDYixpQkFBSyxPQUFPLE9BQU87QUFBQTtBQUFBLGNBRWpCLFVBQVU7QUFDWixtQkFBTyxLQUFLO0FBQUE7QUFBQSxjQUVWLFFBQVEsU0FBUztBQUNuQixpQkFBSyxPQUFPLFVBQVU7QUFBQTtBQUFBLFVBRXhCLGNBQWM7QUFDWixpQkFBSyxjQUFjO0FBQ25CLGdCQUFJLEtBQUssUUFBUSxZQUFZO0FBQzNCLG1CQUFLO0FBQUEsbUJBQ0E7QUFDTCwwQkFBWSxNQUFNLEtBQUssUUFBUTtBQUFBO0FBRWpDLGlCQUFLO0FBQ0wsaUJBQUssY0FBYztBQUNuQixtQkFBTztBQUFBO0FBQUEsVUFFVCxRQUFRO0FBQ04sd0JBQVksS0FBSyxRQUFRLEtBQUs7QUFDOUIsbUJBQU87QUFBQTtBQUFBLFVBRVQsT0FBTztBQUNMLHFCQUFTLEtBQUs7QUFDZCxtQkFBTztBQUFBO0FBQUEsVUFFVCxPQUFPLE9BQU8sUUFBUTtBQUNwQixnQkFBSSxDQUFDLFNBQVMsUUFBUSxPQUFPO0FBQzNCLG1CQUFLLFFBQVEsT0FBTztBQUFBLG1CQUNmO0FBQ0wsbUJBQUssb0JBQW9CLEVBQUMsT0FBTztBQUFBO0FBQUE7QUFBQSxVQUdyQyxRQUFRLE9BQU8sUUFBUTtBQUNyQixrQkFBTSxVQUFVLEtBQUs7QUFDckIsa0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGtCQUFNLGNBQWMsUUFBUSx1QkFBdUIsS0FBSztBQUN4RCxrQkFBTSxVQUFVLEtBQUssU0FBUyxlQUFlLFFBQVEsT0FBTyxRQUFRO0FBQ3BFLGtCQUFNLFdBQVcsUUFBUSxvQkFBb0IsS0FBSyxTQUFTO0FBQzNELGtCQUFNLE9BQU8sS0FBSyxRQUFRLFdBQVc7QUFDckMsaUJBQUssUUFBUSxRQUFRO0FBQ3JCLGlCQUFLLFNBQVMsUUFBUTtBQUN0QixpQkFBSyxlQUFlLEtBQUs7QUFDekIsZ0JBQUksQ0FBQyxZQUFZLE1BQU0sVUFBVSxPQUFPO0FBQ3RDO0FBQUE7QUFFRixpQkFBSyxjQUFjLFVBQVUsRUFBQyxNQUFNO0FBQ3BDLHFCQUFTLFFBQVEsVUFBVSxDQUFDLE1BQU0sVUFBVTtBQUM1QyxnQkFBSSxLQUFLLFVBQVU7QUFDakIsa0JBQUksS0FBSyxVQUFVLE9BQU87QUFDeEIscUJBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUlYLHNCQUFzQjtBQUNwQixrQkFBTSxVQUFVLEtBQUs7QUFDckIsa0JBQU0sZ0JBQWdCLFFBQVEsVUFBVTtBQUN4QyxpQkFBSyxlQUFlLENBQUMsYUFBYSxXQUFXO0FBQzNDLDBCQUFZLEtBQUs7QUFBQTtBQUFBO0FBQUEsVUFHckIsc0JBQXNCO0FBQ3BCLGtCQUFNLFVBQVUsS0FBSztBQUNyQixrQkFBTSxZQUFZLFFBQVE7QUFDMUIsa0JBQU0sVUFBUyxLQUFLO0FBQ3BCLGtCQUFNLFVBQVUsT0FBTyxLQUFLLFNBQVEsT0FBTyxDQUFDLEtBQUssT0FBTztBQUN0RCxrQkFBSSxNQUFNO0FBQ1YscUJBQU87QUFBQSxlQUNOO0FBQ0gsZ0JBQUksUUFBUTtBQUNaLGdCQUFJLFdBQVc7QUFDYixzQkFBUSxNQUFNLE9BQ1osT0FBTyxLQUFLLFdBQVcsSUFBSSxDQUFDLE9BQU87QUFDakMsc0JBQU0sZUFBZSxVQUFVO0FBQy9CLHNCQUFNLE9BQU8sY0FBYyxJQUFJO0FBQy9CLHNCQUFNLFdBQVcsU0FBUztBQUMxQixzQkFBTSxlQUFlLFNBQVM7QUFDOUIsdUJBQU87QUFBQSxrQkFDTCxTQUFTO0FBQUEsa0JBQ1QsV0FBVyxXQUFXLGNBQWMsZUFBZSxXQUFXO0FBQUEsa0JBQzlELE9BQU8sV0FBVyxpQkFBaUIsZUFBZSxhQUFhO0FBQUE7QUFBQTtBQUFBO0FBS3ZFLGlCQUFLLE9BQU8sQ0FBQyxTQUFTO0FBQ3BCLG9CQUFNLGVBQWUsS0FBSztBQUMxQixvQkFBTSxLQUFLLGFBQWE7QUFDeEIsb0JBQU0sT0FBTyxjQUFjLElBQUk7QUFDL0Isb0JBQU0sWUFBWSxlQUFlLGFBQWEsTUFBTSxLQUFLO0FBQ3pELGtCQUFJLGFBQWEsYUFBYSxVQUFhLHFCQUFxQixhQUFhLFVBQVUsVUFBVSxxQkFBcUIsS0FBSyxZQUFZO0FBQ3JJLDZCQUFhLFdBQVcsS0FBSztBQUFBO0FBRS9CLHNCQUFRLE1BQU07QUFDZCxrQkFBSSxRQUFRO0FBQ1osa0JBQUksTUFBTSxXQUFVLFFBQU8sSUFBSSxTQUFTLFdBQVc7QUFDakQsd0JBQVEsUUFBTztBQUFBLHFCQUNWO0FBQ0wsc0JBQU0sYUFBYSxTQUFTLFNBQVM7QUFDckMsd0JBQVEsSUFBSSxXQUFXO0FBQUEsa0JBQ3JCO0FBQUEsa0JBQ0EsTUFBTTtBQUFBLGtCQUNOLEtBQUssS0FBSztBQUFBLGtCQUNWLE9BQU87QUFBQTtBQUVULHdCQUFPLE1BQU0sTUFBTTtBQUFBO0FBRXJCLG9CQUFNLEtBQUssY0FBYztBQUFBO0FBRTNCLGlCQUFLLFNBQVMsQ0FBQyxZQUFZLE9BQU87QUFDaEMsa0JBQUksQ0FBQyxZQUFZO0FBQ2YsdUJBQU8sUUFBTztBQUFBO0FBQUE7QUFHbEIsaUJBQUssU0FBUSxDQUFDLFVBQVU7QUFDdEIsc0JBQVEsVUFBVSxNQUFNLE9BQU8sTUFBTTtBQUNyQyxzQkFBUSxPQUFPLE1BQU07QUFBQTtBQUFBO0FBQUEsVUFHekIsa0JBQWtCO0FBQ2hCLGtCQUFNLFdBQVcsS0FBSztBQUN0QixrQkFBTSxVQUFVLEtBQUssS0FBSyxTQUFTO0FBQ25DLGtCQUFNLFVBQVUsU0FBUztBQUN6QixxQkFBUyxLQUFLLENBQUMsR0FBRyxNQUFNLEVBQUUsUUFBUSxFQUFFO0FBQ3BDLGdCQUFJLFVBQVUsU0FBUztBQUNyQix1QkFBUyxJQUFJLFNBQVMsSUFBSSxTQUFTLEVBQUUsR0FBRztBQUN0QyxxQkFBSyxvQkFBb0I7QUFBQTtBQUUzQix1QkFBUyxPQUFPLFNBQVMsVUFBVTtBQUFBO0FBRXJDLGlCQUFLLGtCQUFrQixTQUFTLE1BQU0sR0FBRyxLQUFLLGNBQWMsU0FBUztBQUFBO0FBQUEsVUFFdkUsOEJBQThCO0FBQzVCLGtCQUFNLEVBQUMsV0FBVyxVQUFVLE1BQU0sRUFBQyxlQUFhO0FBQ2hELGdCQUFJLFNBQVMsU0FBUyxTQUFTLFFBQVE7QUFDckMscUJBQU8sS0FBSztBQUFBO0FBRWQscUJBQVMsUUFBUSxDQUFDLE1BQU0sV0FBVTtBQUNoQyxrQkFBSSxTQUFTLE9BQU8sT0FBSyxNQUFNLEtBQUssVUFBVSxXQUFXLEdBQUc7QUFDMUQscUJBQUssb0JBQW9CO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFJL0IsMkJBQTJCO0FBQ3pCLGtCQUFNLGlCQUFpQjtBQUN2QixrQkFBTSxXQUFXLEtBQUssS0FBSztBQUMzQixnQkFBSSxHQUFHO0FBQ1AsaUJBQUs7QUFDTCxpQkFBSyxJQUFJLEdBQUcsT0FBTyxTQUFTLFFBQVEsSUFBSSxNQUFNLEtBQUs7QUFDakQsb0JBQU0sVUFBVSxTQUFTO0FBQ3pCLGtCQUFJLE9BQU8sS0FBSyxlQUFlO0FBQy9CLG9CQUFNLE9BQU8sUUFBUSxRQUFRLEtBQUssT0FBTztBQUN6QyxrQkFBSSxLQUFLLFFBQVEsS0FBSyxTQUFTLE1BQU07QUFDbkMscUJBQUssb0JBQW9CO0FBQ3pCLHVCQUFPLEtBQUssZUFBZTtBQUFBO0FBRTdCLG1CQUFLLE9BQU87QUFDWixtQkFBSyxZQUFZLFFBQVEsYUFBYSxhQUFhLE1BQU0sS0FBSztBQUM5RCxtQkFBSyxRQUFRLFFBQVEsU0FBUztBQUM5QixtQkFBSyxRQUFRO0FBQ2IsbUJBQUssUUFBUSxLQUFLLFFBQVE7QUFDMUIsbUJBQUssVUFBVSxLQUFLLGlCQUFpQjtBQUNyQyxrQkFBSSxLQUFLLFlBQVk7QUFDbkIscUJBQUssV0FBVyxZQUFZO0FBQzVCLHFCQUFLLFdBQVc7QUFBQSxxQkFDWDtBQUNMLHNCQUFNLGtCQUFrQixTQUFTLGNBQWM7QUFDL0Msc0JBQU0sRUFBQyxvQkFBb0Isb0JBQW1CLFNBQVMsU0FBUztBQUNoRSx1QkFBTyxPQUFPLGdCQUFnQixXQUFXO0FBQUEsa0JBQ3ZDLGlCQUFpQixTQUFTLFdBQVc7QUFBQSxrQkFDckMsb0JBQW9CLHNCQUFzQixTQUFTLFdBQVc7QUFBQTtBQUVoRSxxQkFBSyxhQUFhLElBQUksZ0JBQWdCLE1BQU07QUFDNUMsK0JBQWUsS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUc3QixpQkFBSztBQUNMLG1CQUFPO0FBQUE7QUFBQSxVQUVULGlCQUFpQjtBQUNmLGlCQUFLLEtBQUssS0FBSyxVQUFVLENBQUMsU0FBUyxpQkFBaUI7QUFDbEQsbUJBQUssZUFBZSxjQUFjLFdBQVc7QUFBQSxlQUM1QztBQUFBO0FBQUEsVUFFTCxRQUFRO0FBQ04saUJBQUs7QUFDTCxpQkFBSyxjQUFjO0FBQUE7QUFBQSxVQUVyQixPQUFPLE1BQU07QUFDWCxrQkFBTSxTQUFTLEtBQUs7QUFDcEIsbUJBQU87QUFDUCxrQkFBTSxVQUFVLEtBQUssV0FBVyxPQUFPLGVBQWUsT0FBTyxxQkFBcUIsS0FBSztBQUN2RixrQkFBTSxnQkFBZ0IsS0FBSyxzQkFBc0IsQ0FBQyxRQUFRO0FBQzFELGlCQUFLO0FBQ0wsaUJBQUs7QUFDTCxpQkFBSztBQUNMLGlCQUFLLFNBQVM7QUFDZCxnQkFBSSxLQUFLLGNBQWMsZ0JBQWdCLEVBQUMsTUFBTSxZQUFZLFlBQVcsT0FBTztBQUMxRTtBQUFBO0FBRUYsa0JBQU0saUJBQWlCLEtBQUs7QUFDNUIsaUJBQUssY0FBYztBQUNuQixnQkFBSSxhQUFhO0FBQ2pCLHFCQUFTLElBQUksR0FBRyxPQUFPLEtBQUssS0FBSyxTQUFTLFFBQVEsSUFBSSxNQUFNLEtBQUs7QUFDL0Qsb0JBQU0sRUFBQyxlQUFjLEtBQUssZUFBZTtBQUN6QyxvQkFBTSxTQUFRLENBQUMsaUJBQWlCLGVBQWUsUUFBUSxnQkFBZ0I7QUFDdkUseUJBQVcsc0JBQXNCO0FBQ2pDLDJCQUFhLEtBQUssSUFBSSxDQUFDLFdBQVcsa0JBQWtCO0FBQUE7QUFFdEQseUJBQWEsS0FBSyxjQUFjLFFBQVEsT0FBTyxjQUFjLGFBQWE7QUFDMUUsaUJBQUssY0FBYztBQUNuQixnQkFBSSxDQUFDLGVBQWU7QUFDbEIsbUJBQUssZ0JBQWdCLENBQUMsZUFBZTtBQUNuQywyQkFBVztBQUFBO0FBQUE7QUFHZixpQkFBSyxnQkFBZ0I7QUFDckIsaUJBQUssY0FBYyxlQUFlLEVBQUM7QUFDbkMsaUJBQUssUUFBUSxLQUFLLGNBQWMsS0FBSztBQUNyQyxrQkFBTSxFQUFDLFNBQVMsZUFBYztBQUM5QixnQkFBSSxZQUFZO0FBQ2QsbUJBQUssY0FBYyxZQUFZO0FBQUEsdUJBQ3RCLFFBQVEsUUFBUTtBQUN6QixtQkFBSyxtQkFBbUIsU0FBUyxTQUFTO0FBQUE7QUFFNUMsaUJBQUs7QUFBQTtBQUFBLFVBRVAsZ0JBQWdCO0FBQ2QsaUJBQUssS0FBSyxRQUFRLENBQUMsVUFBVTtBQUMzQixzQkFBUSxVQUFVLE1BQU07QUFBQTtBQUUxQixpQkFBSztBQUNMLGlCQUFLO0FBQUE7QUFBQSxVQUVQLHNCQUFzQjtBQUNwQixrQkFBTSxVQUFVLEtBQUs7QUFDckIsa0JBQU0saUJBQWlCLElBQUksSUFBSSxPQUFPLEtBQUssS0FBSztBQUNoRCxrQkFBTSxZQUFZLElBQUksSUFBSSxRQUFRO0FBQ2xDLGdCQUFJLENBQUMsVUFBVSxnQkFBZ0IsY0FBYyxDQUFDLENBQUMsS0FBSyx5QkFBeUIsUUFBUSxZQUFZO0FBQy9GLG1CQUFLO0FBQ0wsbUJBQUs7QUFBQTtBQUFBO0FBQUEsVUFHVCx1QkFBdUI7QUFDckIsa0JBQU0sRUFBQyxtQkFBa0I7QUFDekIsa0JBQU0sVUFBVSxLQUFLLDRCQUE0QjtBQUNqRCx1QkFBVyxFQUFDLFFBQVEsT0FBTyxXQUFVLFNBQVM7QUFDNUMsb0JBQU0sUUFBTyxXQUFXLG9CQUFvQixDQUFDLFFBQVE7QUFDckQsOEJBQWdCLGdCQUFnQixPQUFPO0FBQUE7QUFBQTtBQUFBLFVBRzNDLHlCQUF5QjtBQUN2QixrQkFBTSxlQUFlLEtBQUs7QUFDMUIsZ0JBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLFFBQVE7QUFDekM7QUFBQTtBQUVGLGlCQUFLLGVBQWU7QUFDcEIsa0JBQU0sZUFBZSxLQUFLLEtBQUssU0FBUztBQUN4QyxrQkFBTSxVQUFVLENBQUMsUUFBUSxJQUFJLElBQzNCLGFBQ0csT0FBTyxPQUFLLEVBQUUsT0FBTyxLQUNyQixJQUFJLENBQUMsR0FBRyxNQUFNLElBQUksTUFBTSxFQUFFLE9BQU8sR0FBRyxLQUFLO0FBRTlDLGtCQUFNLFlBQVksUUFBUTtBQUMxQixxQkFBUyxJQUFJLEdBQUcsSUFBSSxjQUFjLEtBQUs7QUFDckMsa0JBQUksQ0FBQyxVQUFVLFdBQVcsUUFBUSxLQUFLO0FBQ3JDO0FBQUE7QUFBQTtBQUdKLG1CQUFPLE1BQU0sS0FBSyxXQUNmLElBQUksT0FBSyxFQUFFLE1BQU0sTUFDakIsSUFBSSxPQUFNLEdBQUMsUUFBUSxFQUFFLElBQUksT0FBTyxDQUFDLEVBQUUsSUFBSSxPQUFPLENBQUMsRUFBRTtBQUFBO0FBQUEsVUFFdEQsY0FBYyxZQUFZO0FBQ3hCLGdCQUFJLEtBQUssY0FBYyxnQkFBZ0IsRUFBQyxZQUFZLFlBQVcsT0FBTztBQUNwRTtBQUFBO0FBRUYsb0JBQVEsT0FBTyxNQUFNLEtBQUssT0FBTyxLQUFLLFFBQVE7QUFDOUMsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLFNBQVMsS0FBSyxTQUFTLEtBQUssS0FBSyxVQUFVO0FBQ2pELGlCQUFLLFVBQVU7QUFDZixpQkFBSyxLQUFLLE9BQU8sQ0FBQyxRQUFRO0FBQ3hCLGtCQUFJLFVBQVUsSUFBSSxhQUFhLGFBQWE7QUFDMUM7QUFBQTtBQUVGLGtCQUFJLElBQUksV0FBVztBQUNqQixvQkFBSTtBQUFBO0FBRU4sbUJBQUssUUFBUSxLQUFLLEdBQUcsSUFBSTtBQUFBLGVBQ3hCO0FBQ0gsaUJBQUssUUFBUSxRQUFRLENBQUMsTUFBTSxXQUFVO0FBQ3BDLG1CQUFLLE9BQU87QUFBQTtBQUVkLGlCQUFLLGNBQWM7QUFBQTtBQUFBLFVBRXJCLGdCQUFnQixNQUFNO0FBQ3BCLGdCQUFJLEtBQUssY0FBYyx3QkFBd0IsRUFBQyxNQUFNLFlBQVksWUFBVyxPQUFPO0FBQ2xGO0FBQUE7QUFFRixxQkFBUyxJQUFJLEdBQUcsT0FBTyxLQUFLLEtBQUssU0FBUyxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDL0QsbUJBQUssZUFBZSxHQUFHLFdBQVc7QUFBQTtBQUVwQyxxQkFBUyxJQUFJLEdBQUcsT0FBTyxLQUFLLEtBQUssU0FBUyxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDL0QsbUJBQUssZUFBZSxHQUFHLFlBQVcsUUFBUSxLQUFLLEVBQUMsY0FBYyxPQUFNO0FBQUE7QUFFdEUsaUJBQUssY0FBYyx1QkFBdUIsRUFBQztBQUFBO0FBQUEsVUFFN0MsZUFBZSxRQUFPLE1BQU07QUFDMUIsa0JBQU0sT0FBTyxLQUFLLGVBQWU7QUFDakMsa0JBQU0sT0FBTyxFQUFDLE1BQU0sZUFBTyxNQUFNLFlBQVk7QUFDN0MsZ0JBQUksS0FBSyxjQUFjLHVCQUF1QixVQUFVLE9BQU87QUFDN0Q7QUFBQTtBQUVGLGlCQUFLLFdBQVcsUUFBUTtBQUN4QixpQkFBSyxhQUFhO0FBQ2xCLGlCQUFLLGNBQWMsc0JBQXNCO0FBQUE7QUFBQSxVQUUzQyxTQUFTO0FBQ1AsZ0JBQUksS0FBSyxjQUFjLGdCQUFnQixFQUFDLFlBQVksWUFBVyxPQUFPO0FBQ3BFO0FBQUE7QUFFRixnQkFBSSxTQUFTLElBQUksT0FBTztBQUN0QixrQkFBSSxLQUFLLFlBQVksQ0FBQyxTQUFTLFFBQVEsT0FBTztBQUM1Qyx5QkFBUyxNQUFNO0FBQUE7QUFBQSxtQkFFWjtBQUNMLG1CQUFLO0FBQ0wsbUNBQXFCLEVBQUMsT0FBTztBQUFBO0FBQUE7QUFBQSxVQUdqQyxPQUFPO0FBQ0wsZ0JBQUk7QUFDSixnQkFBSSxLQUFLLG1CQUFtQjtBQUMxQixvQkFBTSxFQUFDLE9BQU8sV0FBVSxLQUFLO0FBQzdCLG1CQUFLLFFBQVEsT0FBTztBQUNwQixtQkFBSyxvQkFBb0I7QUFBQTtBQUUzQixpQkFBSztBQUNMLGdCQUFJLEtBQUssU0FBUyxLQUFLLEtBQUssVUFBVSxHQUFHO0FBQ3ZDO0FBQUE7QUFFRixnQkFBSSxLQUFLLGNBQWMsY0FBYyxFQUFDLFlBQVksWUFBVyxPQUFPO0FBQ2xFO0FBQUE7QUFFRixrQkFBTSxTQUFTLEtBQUs7QUFDcEIsaUJBQUssSUFBSSxHQUFHLElBQUksT0FBTyxVQUFVLE9BQU8sR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQ3RELHFCQUFPLEdBQUcsS0FBSyxLQUFLO0FBQUE7QUFFdEIsaUJBQUs7QUFDTCxtQkFBTyxJQUFJLE9BQU8sUUFBUSxFQUFFLEdBQUc7QUFDN0IscUJBQU8sR0FBRyxLQUFLLEtBQUs7QUFBQTtBQUV0QixpQkFBSyxjQUFjO0FBQUE7QUFBQSxVQUVyQix1QkFBdUIsZUFBZTtBQUNwQyxrQkFBTSxXQUFXLEtBQUs7QUFDdEIsa0JBQU0sU0FBUztBQUNmLGdCQUFJLEdBQUc7QUFDUCxpQkFBSyxJQUFJLEdBQUcsT0FBTyxTQUFTLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUNqRCxvQkFBTSxPQUFPLFNBQVM7QUFDdEIsa0JBQUksQ0FBQyxpQkFBaUIsS0FBSyxTQUFTO0FBQ2xDLHVCQUFPLEtBQUs7QUFBQTtBQUFBO0FBR2hCLG1CQUFPO0FBQUE7QUFBQSxVQUVULCtCQUErQjtBQUM3QixtQkFBTyxLQUFLLHVCQUF1QjtBQUFBO0FBQUEsVUFFckMsZ0JBQWdCO0FBQ2QsZ0JBQUksS0FBSyxjQUFjLHNCQUFzQixFQUFDLFlBQVksWUFBVyxPQUFPO0FBQzFFO0FBQUE7QUFFRixrQkFBTSxXQUFXLEtBQUs7QUFDdEIscUJBQVMsSUFBSSxTQUFTLFNBQVMsR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQzdDLG1CQUFLLGFBQWEsU0FBUztBQUFBO0FBRTdCLGlCQUFLLGNBQWM7QUFBQTtBQUFBLFVBRXJCLGFBQWEsTUFBTTtBQUNqQixrQkFBTSxNQUFNLEtBQUs7QUFDakIsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLFVBQVUsQ0FBQyxLQUFLO0FBQ3RCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxPQUFPO0FBQUEsY0FDWDtBQUFBLGNBQ0EsT0FBTyxLQUFLO0FBQUEsY0FDWixZQUFZO0FBQUE7QUFFZCxnQkFBSSxLQUFLLGNBQWMscUJBQXFCLFVBQVUsT0FBTztBQUMzRDtBQUFBO0FBRUYsZ0JBQUksU0FBUztBQUNYLHVCQUFTLEtBQUs7QUFBQSxnQkFDWixNQUFNLEtBQUssU0FBUyxRQUFRLElBQUksS0FBSyxPQUFPLEtBQUs7QUFBQSxnQkFDakQsT0FBTyxLQUFLLFVBQVUsUUFBUSxLQUFLLFFBQVEsS0FBSyxRQUFRLEtBQUs7QUFBQSxnQkFDN0QsS0FBSyxLQUFLLFFBQVEsUUFBUSxJQUFJLEtBQUssTUFBTSxLQUFLO0FBQUEsZ0JBQzlDLFFBQVEsS0FBSyxXQUFXLFFBQVEsS0FBSyxTQUFTLEtBQUssU0FBUyxLQUFLO0FBQUE7QUFBQTtBQUdyRSxpQkFBSyxXQUFXO0FBQ2hCLGdCQUFJLFNBQVM7QUFDWCx5QkFBVztBQUFBO0FBRWIsaUJBQUssYUFBYTtBQUNsQixpQkFBSyxjQUFjLG9CQUFvQjtBQUFBO0FBQUEsVUFFekMsY0FBYyxPQUFPO0FBQ25CLG1CQUFPLGVBQWUsT0FBTyxLQUFLLFdBQVcsS0FBSztBQUFBO0FBQUEsVUFFcEQsMEJBQTBCLEdBQUcsTUFBTSxTQUFTLGtCQUFrQjtBQUM1RCxrQkFBTSxTQUFTLFlBQVksTUFBTTtBQUNqQyxnQkFBSSxPQUFPLFdBQVcsWUFBWTtBQUNoQyxxQkFBTyxPQUFPLE1BQU0sR0FBRyxTQUFTO0FBQUE7QUFFbEMsbUJBQU87QUFBQTtBQUFBLFVBRVQsZUFBZSxjQUFjO0FBQzNCLGtCQUFNLFVBQVUsS0FBSyxLQUFLLFNBQVM7QUFDbkMsa0JBQU0sV0FBVyxLQUFLO0FBQ3RCLGdCQUFJLE9BQU8sU0FBUyxPQUFPLE9BQUssS0FBSyxFQUFFLGFBQWEsU0FBUztBQUM3RCxnQkFBSSxDQUFDLE1BQU07QUFDVCxxQkFBTztBQUFBLGdCQUNMLE1BQU07QUFBQSxnQkFDTixNQUFNO0FBQUEsZ0JBQ04sU0FBUztBQUFBLGdCQUNULFlBQVk7QUFBQSxnQkFDWixRQUFRO0FBQUEsZ0JBQ1IsU0FBUztBQUFBLGdCQUNULFNBQVM7QUFBQSxnQkFDVCxPQUFPLFdBQVcsUUFBUSxTQUFTO0FBQUEsZ0JBQ25DLE9BQU87QUFBQSxnQkFDUCxVQUFVO0FBQUEsZ0JBQ1YsU0FBUztBQUFBLGdCQUNULFNBQVM7QUFBQTtBQUVYLHVCQUFTLEtBQUs7QUFBQTtBQUVoQixtQkFBTztBQUFBO0FBQUEsVUFFVCxhQUFhO0FBQ1gsbUJBQU8sS0FBSyxZQUFhLE1BQUssV0FBVyxjQUFjLE1BQU0sRUFBQyxPQUFPLE1BQU0sTUFBTTtBQUFBO0FBQUEsVUFFbkYseUJBQXlCO0FBQ3ZCLG1CQUFPLEtBQUssK0JBQStCO0FBQUE7QUFBQSxVQUU3QyxpQkFBaUIsY0FBYztBQUM3QixrQkFBTSxVQUFVLEtBQUssS0FBSyxTQUFTO0FBQ25DLGdCQUFJLENBQUMsU0FBUztBQUNaLHFCQUFPO0FBQUE7QUFFVCxrQkFBTSxPQUFPLEtBQUssZUFBZTtBQUNqQyxtQkFBTyxPQUFPLEtBQUssV0FBVyxZQUFZLENBQUMsS0FBSyxTQUFTLENBQUMsUUFBUTtBQUFBO0FBQUEsVUFFcEUscUJBQXFCLGNBQWMsU0FBUztBQUMxQyxrQkFBTSxPQUFPLEtBQUssZUFBZTtBQUNqQyxpQkFBSyxTQUFTLENBQUM7QUFBQTtBQUFBLFVBRWpCLHFCQUFxQixRQUFPO0FBQzFCLGlCQUFLLGVBQWUsVUFBUyxDQUFDLEtBQUssZUFBZTtBQUFBO0FBQUEsVUFFcEQsa0JBQWtCLFFBQU87QUFDdkIsbUJBQU8sQ0FBQyxLQUFLLGVBQWU7QUFBQTtBQUFBLFVBRTlCLGtCQUFrQixjQUFjLFdBQVcsU0FBUztBQUNsRCxrQkFBTSxPQUFPLFVBQVUsU0FBUztBQUNoQyxrQkFBTSxPQUFPLEtBQUssZUFBZTtBQUNqQyxrQkFBTSxRQUFRLEtBQUssV0FBVyxtQkFBbUIsUUFBVztBQUM1RCxnQkFBSSxRQUFRLFlBQVk7QUFDdEIsbUJBQUssS0FBSyxXQUFXLFNBQVMsQ0FBQztBQUMvQixtQkFBSztBQUFBLG1CQUNBO0FBQ0wsbUJBQUsscUJBQXFCLGNBQWM7QUFDeEMsb0JBQU0sT0FBTyxNQUFNLEVBQUM7QUFDcEIsbUJBQUssT0FBTyxDQUFDLFFBQVEsSUFBSSxpQkFBaUIsZUFBZSxPQUFPO0FBQUE7QUFBQTtBQUFBLFVBR3BFLEtBQUssY0FBYyxXQUFXO0FBQzVCLGlCQUFLLGtCQUFrQixjQUFjLFdBQVc7QUFBQTtBQUFBLFVBRWxELEtBQUssY0FBYyxXQUFXO0FBQzVCLGlCQUFLLGtCQUFrQixjQUFjLFdBQVc7QUFBQTtBQUFBLFVBRWxELG9CQUFvQixjQUFjO0FBQ2hDLGtCQUFNLE9BQU8sS0FBSyxVQUFVO0FBQzVCLGdCQUFJLFFBQVEsS0FBSyxZQUFZO0FBQzNCLG1CQUFLLFdBQVc7QUFBQTtBQUVsQixtQkFBTyxLQUFLLFVBQVU7QUFBQTtBQUFBLFVBRXhCLFFBQVE7QUFDTixnQkFBSSxHQUFHO0FBQ1AsaUJBQUs7QUFDTCxxQkFBUyxPQUFPO0FBQ2hCLGlCQUFLLElBQUksR0FBRyxPQUFPLEtBQUssS0FBSyxTQUFTLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUMzRCxtQkFBSyxvQkFBb0I7QUFBQTtBQUFBO0FBQUEsVUFHN0IsVUFBVTtBQUNSLGlCQUFLLGNBQWM7QUFDbkIsa0JBQU0sRUFBQyxRQUFRLFFBQU87QUFDdEIsaUJBQUs7QUFDTCxpQkFBSyxPQUFPO0FBQ1osZ0JBQUksUUFBUTtBQUNWLG1CQUFLO0FBQ0wsMEJBQVksUUFBUTtBQUNwQixtQkFBSyxTQUFTLGVBQWU7QUFDN0IsbUJBQUssU0FBUztBQUNkLG1CQUFLLE1BQU07QUFBQTtBQUViLGlCQUFLLGNBQWM7QUFDbkIsbUJBQU8sVUFBVSxLQUFLO0FBQ3RCLGlCQUFLLGNBQWM7QUFBQTtBQUFBLFVBRXJCLGlCQUFpQixNQUFNO0FBQ3JCLG1CQUFPLEtBQUssT0FBTyxVQUFVLEdBQUc7QUFBQTtBQUFBLFVBRWxDLGFBQWE7QUFDWCxpQkFBSztBQUNMLGdCQUFJLEtBQUssUUFBUSxZQUFZO0FBQzNCLG1CQUFLO0FBQUEsbUJBQ0E7QUFDTCxtQkFBSyxXQUFXO0FBQUE7QUFBQTtBQUFBLFVBR3BCLGlCQUFpQjtBQUNmLGtCQUFNLFlBQVksS0FBSztBQUN2QixrQkFBTSxXQUFXLEtBQUs7QUFDdEIsa0JBQU0sT0FBTyxDQUFDLE1BQU0sY0FBYTtBQUMvQix1QkFBUyxpQkFBaUIsTUFBTSxNQUFNO0FBQ3RDLHdCQUFVLFFBQVE7QUFBQTtBQUVwQixrQkFBTSxXQUFXLENBQUMsR0FBRyxHQUFHLE1BQU07QUFDNUIsZ0JBQUUsVUFBVTtBQUNaLGdCQUFFLFVBQVU7QUFDWixtQkFBSyxjQUFjO0FBQUE7QUFFckIsaUJBQUssS0FBSyxRQUFRLFFBQVEsQ0FBQyxTQUFTLEtBQUssTUFBTTtBQUFBO0FBQUEsVUFFakQsdUJBQXVCO0FBQ3JCLGdCQUFJLENBQUMsS0FBSyxzQkFBc0I7QUFDOUIsbUJBQUssdUJBQXVCO0FBQUE7QUFFOUIsa0JBQU0sWUFBWSxLQUFLO0FBQ3ZCLGtCQUFNLFdBQVcsS0FBSztBQUN0QixrQkFBTSxPQUFPLENBQUMsTUFBTSxjQUFhO0FBQy9CLHVCQUFTLGlCQUFpQixNQUFNLE1BQU07QUFDdEMsd0JBQVUsUUFBUTtBQUFBO0FBRXBCLGtCQUFNLFVBQVUsQ0FBQyxNQUFNLGNBQWE7QUFDbEMsa0JBQUksVUFBVSxPQUFPO0FBQ25CLHlCQUFTLG9CQUFvQixNQUFNLE1BQU07QUFDekMsdUJBQU8sVUFBVTtBQUFBO0FBQUE7QUFHckIsa0JBQU0sV0FBVyxDQUFDLE9BQU8sV0FBVztBQUNsQyxrQkFBSSxLQUFLLFFBQVE7QUFDZixxQkFBSyxPQUFPLE9BQU87QUFBQTtBQUFBO0FBR3ZCLGdCQUFJO0FBQ0osa0JBQU0sV0FBVyxNQUFNO0FBQ3JCLHNCQUFRLFVBQVU7QUFDbEIsbUJBQUssV0FBVztBQUNoQixtQkFBSztBQUNMLG1CQUFLLFVBQVU7QUFDZixtQkFBSyxVQUFVO0FBQUE7QUFFakIsdUJBQVcsTUFBTTtBQUNmLG1CQUFLLFdBQVc7QUFDaEIsc0JBQVEsVUFBVTtBQUNsQixtQkFBSztBQUNMLG1CQUFLLFFBQVEsR0FBRztBQUNoQixtQkFBSyxVQUFVO0FBQUE7QUFFakIsZ0JBQUksU0FBUyxXQUFXLEtBQUssU0FBUztBQUNwQztBQUFBLG1CQUNLO0FBQ0w7QUFBQTtBQUFBO0FBQUEsVUFHSixlQUFlO0FBQ2IsaUJBQUssS0FBSyxZQUFZLENBQUMsVUFBVSxTQUFTO0FBQ3hDLG1CQUFLLFNBQVMsb0JBQW9CLE1BQU0sTUFBTTtBQUFBO0FBRWhELGlCQUFLLGFBQWE7QUFDbEIsaUJBQUssS0FBSyxzQkFBc0IsQ0FBQyxVQUFVLFNBQVM7QUFDbEQsbUJBQUssU0FBUyxvQkFBb0IsTUFBTSxNQUFNO0FBQUE7QUFFaEQsaUJBQUssdUJBQXVCO0FBQUE7QUFBQSxVQUU5QixpQkFBaUIsT0FBTyxNQUFNLFNBQVM7QUFDckMsa0JBQU0sU0FBUyxVQUFVLFFBQVE7QUFDakMsZ0JBQUksTUFBTSxNQUFNLEdBQUc7QUFDbkIsZ0JBQUksU0FBUyxXQUFXO0FBQ3RCLHFCQUFPLEtBQUssZUFBZSxNQUFNLEdBQUc7QUFDcEMsbUJBQUssV0FBVyxNQUFNLFNBQVM7QUFBQTtBQUVqQyxpQkFBSyxJQUFJLEdBQUcsT0FBTyxNQUFNLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUM5QyxxQkFBTyxNQUFNO0FBQ2Isb0JBQU0sYUFBYSxRQUFRLEtBQUssZUFBZSxLQUFLLGNBQWM7QUFDbEUsa0JBQUksWUFBWTtBQUNkLDJCQUFXLFNBQVMsY0FBYyxLQUFLLFNBQVMsS0FBSyxjQUFjLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUk5RSxvQkFBb0I7QUFDbEIsbUJBQU8sS0FBSyxXQUFXO0FBQUE7QUFBQSxVQUV6QixrQkFBa0IsZ0JBQWdCO0FBQ2hDLGtCQUFNLGFBQWEsS0FBSyxXQUFXO0FBQ25DLGtCQUFNLFNBQVMsZUFBZSxJQUFJLENBQUMsRUFBQyxjQUFjLG9CQUFXO0FBQzNELG9CQUFNLE9BQU8sS0FBSyxlQUFlO0FBQ2pDLGtCQUFJLENBQUMsTUFBTTtBQUNULHNCQUFNLElBQUksTUFBTSwrQkFBK0I7QUFBQTtBQUVqRCxxQkFBTztBQUFBLGdCQUNMO0FBQUEsZ0JBQ0EsU0FBUyxLQUFLLEtBQUs7QUFBQSxnQkFDbkI7QUFBQTtBQUFBO0FBR0osa0JBQU0sVUFBVSxDQUFDLGVBQWUsUUFBUTtBQUN4QyxnQkFBSSxTQUFTO0FBQ1gsbUJBQUssVUFBVTtBQUNmLG1CQUFLLGFBQWE7QUFDbEIsbUJBQUssbUJBQW1CLFFBQVE7QUFBQTtBQUFBO0FBQUEsVUFHcEMsY0FBYyxNQUFNLE1BQU0sUUFBUTtBQUNoQyxtQkFBTyxLQUFLLFNBQVMsT0FBTyxNQUFNLE1BQU0sTUFBTTtBQUFBO0FBQUEsVUFFaEQsbUJBQW1CLFFBQVEsWUFBWSxRQUFRO0FBQzdDLGtCQUFNLGVBQWUsS0FBSyxRQUFRO0FBQ2xDLGtCQUFNLE9BQU8sQ0FBQyxHQUFHLE1BQU0sRUFBRSxPQUFPLE9BQUssQ0FBQyxFQUFFLEtBQUssT0FBSyxFQUFFLGlCQUFpQixFQUFFLGdCQUFnQixFQUFFLFVBQVUsRUFBRTtBQUNyRyxrQkFBTSxjQUFjLEtBQUssWUFBWTtBQUNyQyxrQkFBTSxZQUFZLFNBQVMsU0FBUyxLQUFLLFFBQVE7QUFDakQsZ0JBQUksWUFBWSxRQUFRO0FBQ3RCLG1CQUFLLGlCQUFpQixhQUFhLGFBQWEsTUFBTTtBQUFBO0FBRXhELGdCQUFJLFVBQVUsVUFBVSxhQUFhLE1BQU07QUFDekMsbUJBQUssaUJBQWlCLFdBQVcsYUFBYSxNQUFNO0FBQUE7QUFBQTtBQUFBLFVBR3hELGNBQWMsR0FBRyxRQUFRO0FBQ3ZCLGtCQUFNLE9BQU87QUFBQSxjQUNYLE9BQU87QUFBQSxjQUNQO0FBQUEsY0FDQSxZQUFZO0FBQUEsY0FDWixhQUFhLEtBQUssY0FBYztBQUFBO0FBRWxDLGtCQUFNLGNBQWMsQ0FBQyxXQUFZLFFBQU8sUUFBUSxVQUFVLEtBQUssUUFBUSxRQUFRLFNBQVMsRUFBRSxPQUFPO0FBQ2pHLGdCQUFJLEtBQUssY0FBYyxlQUFlLE1BQU0saUJBQWlCLE9BQU87QUFDbEU7QUFBQTtBQUVGLGtCQUFNLFVBQVUsS0FBSyxhQUFhLEdBQUcsUUFBUSxLQUFLO0FBQ2xELGlCQUFLLGFBQWE7QUFDbEIsaUJBQUssY0FBYyxjQUFjLE1BQU07QUFDdkMsZ0JBQUksV0FBVyxLQUFLLFNBQVM7QUFDM0IsbUJBQUs7QUFBQTtBQUVQLG1CQUFPO0FBQUE7QUFBQSxVQUVULGFBQWEsR0FBRyxRQUFRLGFBQWE7QUFDbkMsa0JBQU0sRUFBQyxTQUFTLGFBQWEsSUFBSSxZQUFXO0FBQzVDLGtCQUFNLG1CQUFtQjtBQUN6QixrQkFBTSxTQUFTLEtBQUssbUJBQW1CLEdBQUcsWUFBWSxhQUFhO0FBQ25FLGtCQUFNLFVBQVUsY0FBYztBQUM5QixrQkFBTSxZQUFZLG1CQUFtQixHQUFHLEtBQUssWUFBWSxhQUFhO0FBQ3RFLGdCQUFJLGFBQWE7QUFDZixtQkFBSyxhQUFhO0FBQ2xCLHVCQUFTLFFBQVEsU0FBUyxDQUFDLEdBQUcsUUFBUSxPQUFPO0FBQzdDLGtCQUFJLFNBQVM7QUFDWCx5QkFBUyxRQUFRLFNBQVMsQ0FBQyxHQUFHLFFBQVEsT0FBTztBQUFBO0FBQUE7QUFHakQsa0JBQU0sVUFBVSxDQUFDLGVBQWUsUUFBUTtBQUN4QyxnQkFBSSxXQUFXLFFBQVE7QUFDckIsbUJBQUssVUFBVTtBQUNmLG1CQUFLLG1CQUFtQixRQUFRLFlBQVk7QUFBQTtBQUU5QyxpQkFBSyxhQUFhO0FBQ2xCLG1CQUFPO0FBQUE7QUFBQSxVQUVULG1CQUFtQixHQUFHLFlBQVksYUFBYSxrQkFBa0I7QUFDL0QsZ0JBQUksRUFBRSxTQUFTLFlBQVk7QUFDekIscUJBQU87QUFBQTtBQUVULGdCQUFJLENBQUMsYUFBYTtBQUNoQixxQkFBTztBQUFBO0FBRVQsa0JBQU0sZUFBZSxLQUFLLFFBQVE7QUFDbEMsbUJBQU8sS0FBSywwQkFBMEIsR0FBRyxhQUFhLE1BQU0sY0FBYztBQUFBO0FBQUE7QUFHOUUsY0FBTSxvQkFBb0IsTUFBTSxLQUFLLE9BQU0sV0FBVyxDQUFDLFdBQVUsT0FBTSxTQUFTO0FBQ2hGLGNBQU0sYUFBYTtBQUNuQixlQUFPLGlCQUFpQixRQUFPO0FBQUEsVUFDN0IsVUFBVTtBQUFBLFlBQ1I7QUFBQSxZQUNBLE9BQU87QUFBQTtBQUFBLFVBRVQsV0FBVztBQUFBLFlBQ1Q7QUFBQSxZQUNBLE9BQU87QUFBQTtBQUFBLFVBRVQsV0FBVztBQUFBLFlBQ1Q7QUFBQSxZQUNBLE9BQU87QUFBQTtBQUFBLFVBRVQsVUFBVTtBQUFBLFlBQ1I7QUFBQSxZQUNBLE9BQU87QUFBQTtBQUFBLFVBRVQsU0FBUztBQUFBLFlBQ1A7QUFBQSxZQUNBLE9BQU87QUFBQTtBQUFBLFVBRVQsVUFBVTtBQUFBLFlBQ1I7QUFBQSxZQUNBLE9BQU87QUFBQTtBQUFBLFVBRVQsVUFBVTtBQUFBLFlBQ1I7QUFBQSxZQUNBLE9BQU8sSUFBSSxVQUFVO0FBQ25CLHVCQUFTLElBQUksR0FBRztBQUNoQjtBQUFBO0FBQUE7QUFBQSxVQUdKLFlBQVk7QUFBQSxZQUNWO0FBQUEsWUFDQSxPQUFPLElBQUksVUFBVTtBQUNuQix1QkFBUyxPQUFPLEdBQUc7QUFDbkI7QUFBQTtBQUFBO0FBQUE7QUFLTiw0QkFBb0I7QUFDbEIsZ0JBQU0sSUFBSSxNQUFNO0FBQUE7QUFFbEIsMEJBQWtCO0FBQUEsVUFDaEIsWUFBWSxTQUFTO0FBQ25CLGlCQUFLLFVBQVUsV0FBVztBQUFBO0FBQUEsVUFFNUIsS0FBSyxjQUFjO0FBQUE7QUFBQSxVQUNuQixVQUFVO0FBQ1IsbUJBQU87QUFBQTtBQUFBLFVBRVQsTUFBTSxPQUFPLFFBQVE7QUFDbkIsbUJBQU87QUFBQTtBQUFBLFVBRVQsT0FBTyxXQUFXLFFBQVE7QUFDeEIsbUJBQU87QUFBQTtBQUFBLFVBRVQsSUFBSSxXQUFXLFFBQVEsTUFBTTtBQUMzQixtQkFBTztBQUFBO0FBQUEsVUFFVCxLQUFLLEdBQUcsR0FBRyxNQUFNO0FBQ2YsbUJBQU87QUFBQTtBQUFBLFVBRVQsUUFBUSxXQUFXLE1BQU0sU0FBUztBQUNoQyxtQkFBTztBQUFBO0FBQUEsVUFFVCxNQUFNLFdBQVcsTUFBTTtBQUNyQixtQkFBTztBQUFBO0FBQUE7QUFHWCxvQkFBWSxXQUFXLFNBQVMsU0FBUztBQUN2QyxpQkFBTyxPQUFPLFlBQVksV0FBVztBQUFBO0FBRXZDLFlBQUksWUFBWTtBQUFBLFVBQ2QsT0FBTztBQUFBO0FBR1QsbUNBQTJCLE9BQU8sTUFBTTtBQUN0QyxjQUFJLENBQUMsTUFBTSxPQUFPLE1BQU07QUFDdEIsa0JBQU0sZUFBZSxNQUFNLHdCQUF3QjtBQUNuRCxnQkFBSSxTQUFTO0FBQ2IscUJBQVMsSUFBSSxHQUFHLE9BQU8sYUFBYSxRQUFRLElBQUksTUFBTSxLQUFLO0FBQ3pELHVCQUFTLE9BQU8sT0FBTyxhQUFhLEdBQUcsV0FBVyxtQkFBbUI7QUFBQTtBQUV2RSxrQkFBTSxPQUFPLE9BQU8sYUFBYSxPQUFPLEtBQUssQ0FBQyxHQUFHLE1BQU0sSUFBSTtBQUFBO0FBRTdELGlCQUFPLE1BQU0sT0FBTztBQUFBO0FBRXRCLHNDQUE4QixNQUFNO0FBQ2xDLGdCQUFNLFFBQVEsS0FBSztBQUNuQixnQkFBTSxTQUFTLGtCQUFrQixPQUFPLEtBQUs7QUFDN0MsY0FBSSxNQUFNLE1BQU07QUFDaEIsY0FBSSxHQUFHLE1BQU0sTUFBTTtBQUNuQixnQkFBTSxtQkFBbUIsTUFBTTtBQUM3QixnQkFBSSxTQUFTLFNBQVMsU0FBUyxRQUFRO0FBQ3JDO0FBQUE7QUFFRixnQkFBSSxRQUFRLE9BQU87QUFDakIsb0JBQU0sS0FBSyxJQUFJLEtBQUssS0FBSyxJQUFJLE9BQU8sU0FBUztBQUFBO0FBRS9DLG1CQUFPO0FBQUE7QUFFVCxlQUFLLElBQUksR0FBRyxPQUFPLE9BQU8sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQy9DLG1CQUFPLE1BQU0saUJBQWlCLE9BQU87QUFDckM7QUFBQTtBQUVGLGlCQUFPO0FBQ1AsZUFBSyxJQUFJLEdBQUcsT0FBTyxNQUFNLE1BQU0sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ3BELG1CQUFPLE1BQU0sZ0JBQWdCO0FBQzdCO0FBQUE7QUFFRixpQkFBTztBQUFBO0FBRVQsMENBQWtDLFFBQU8sT0FBTyxTQUFTLFlBQVk7QUFDbkUsZ0JBQU0sWUFBWSxRQUFRO0FBQzFCLGNBQUksTUFBTTtBQUNWLGNBQUksY0FBYyxZQUFZO0FBQzVCLG1CQUFPLE1BQU0sTUFBTSxRQUFRO0FBQzNCLG9CQUFRLFFBQVE7QUFBQSxpQkFDWDtBQUNMLG1CQUFPLFlBQVk7QUFDbkIsb0JBQVE7QUFBQTtBQUVWLGlCQUFPO0FBQUEsWUFDTCxPQUFPLE9BQU87QUFBQSxZQUNkO0FBQUEsWUFDQSxPQUFPLE1BQU0sT0FBTyxVQUFVLE9BQU87QUFBQTtBQUFBO0FBR3pDLDJDQUFtQyxRQUFPLE9BQU8sU0FBUyxZQUFZO0FBQ3BFLGdCQUFNLFNBQVMsTUFBTTtBQUNyQixnQkFBTSxPQUFPLE9BQU87QUFDcEIsY0FBSSxPQUFPLFNBQVEsSUFBSSxPQUFPLFNBQVEsS0FBSztBQUMzQyxjQUFJLE9BQU8sU0FBUSxPQUFPLFNBQVMsSUFBSSxPQUFPLFNBQVEsS0FBSztBQUMzRCxnQkFBTSxVQUFVLFFBQVE7QUFDeEIsY0FBSSxTQUFTLE1BQU07QUFDakIsbUJBQU8sT0FBUSxVQUFTLE9BQU8sTUFBTSxNQUFNLE1BQU0sUUFBUSxPQUFPO0FBQUE7QUFFbEUsY0FBSSxTQUFTLE1BQU07QUFDakIsbUJBQU8sT0FBTyxPQUFPO0FBQUE7QUFFdkIsZ0JBQU0sUUFBUSxPQUFRLFFBQU8sS0FBSyxJQUFJLE1BQU0sU0FBUyxJQUFJO0FBQ3pELGdCQUFNLE9BQU8sS0FBSyxJQUFJLE9BQU8sUUFBUSxJQUFJO0FBQ3pDLGlCQUFPO0FBQUEsWUFDTCxPQUFPLE9BQU87QUFBQSxZQUNkLE9BQU8sUUFBUTtBQUFBLFlBQ2Y7QUFBQTtBQUFBO0FBR0osK0JBQXVCLE9BQU8sTUFBTSxRQUFRLEdBQUc7QUFDN0MsZ0JBQU0sYUFBYSxPQUFPLE1BQU0sTUFBTSxJQUFJO0FBQzFDLGdCQUFNLFdBQVcsT0FBTyxNQUFNLE1BQU0sSUFBSTtBQUN4QyxnQkFBTSxNQUFNLEtBQUssSUFBSSxZQUFZO0FBQ2pDLGdCQUFNLE1BQU0sS0FBSyxJQUFJLFlBQVk7QUFDakMsY0FBSSxXQUFXO0FBQ2YsY0FBSSxTQUFTO0FBQ2IsY0FBSSxLQUFLLElBQUksT0FBTyxLQUFLLElBQUksTUFBTTtBQUNqQyx1QkFBVztBQUNYLHFCQUFTO0FBQUE7QUFFWCxlQUFLLE9BQU8sUUFBUTtBQUNwQixlQUFLLFVBQVU7QUFBQSxZQUNiO0FBQUEsWUFDQTtBQUFBLFlBQ0EsT0FBTztBQUFBLFlBQ1AsS0FBSztBQUFBLFlBQ0w7QUFBQSxZQUNBO0FBQUE7QUFBQTtBQUdKLDRCQUFvQixPQUFPLE1BQU0sUUFBUSxHQUFHO0FBQzFDLGNBQUksUUFBUSxRQUFRO0FBQ2xCLDBCQUFjLE9BQU8sTUFBTSxRQUFRO0FBQUEsaUJBQzlCO0FBQ0wsaUJBQUssT0FBTyxRQUFRLE9BQU8sTUFBTSxPQUFPO0FBQUE7QUFFMUMsaUJBQU87QUFBQTtBQUVULHVDQUErQixNQUFNLE1BQU0sT0FBTyxPQUFPO0FBQ3ZELGdCQUFNLFNBQVMsS0FBSztBQUNwQixnQkFBTSxTQUFTLEtBQUs7QUFDcEIsZ0JBQU0sU0FBUyxPQUFPO0FBQ3RCLGdCQUFNLGNBQWMsV0FBVztBQUMvQixnQkFBTSxTQUFTO0FBQ2YsY0FBSSxHQUFHLE1BQU0sTUFBTTtBQUNuQixlQUFLLElBQUksT0FBTyxPQUFPLFFBQVEsT0FBTyxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ25ELG9CQUFRLEtBQUs7QUFDYixtQkFBTztBQUNQLGlCQUFLLE9BQU8sUUFBUSxlQUFlLE9BQU8sTUFBTSxPQUFPLElBQUk7QUFDM0QsbUJBQU8sS0FBSyxXQUFXLE9BQU8sTUFBTSxRQUFRO0FBQUE7QUFFOUMsaUJBQU87QUFBQTtBQUVULDRCQUFvQixRQUFRO0FBQzFCLGlCQUFPLFVBQVUsT0FBTyxhQUFhLFVBQWEsT0FBTyxXQUFXO0FBQUE7QUFFdEUseUJBQWlCLE1BQU0sUUFBUSxZQUFZO0FBQ3pDLGNBQUksU0FBUyxHQUFHO0FBQ2QsbUJBQU8sS0FBSztBQUFBO0FBRWQsaUJBQVEsUUFBTyxpQkFBaUIsSUFBSSxNQUFPLFFBQU8sT0FBTyxhQUFhLElBQUk7QUFBQTtBQUU1RSw2QkFBcUIsWUFBWTtBQUMvQixjQUFJLFNBQVMsT0FBTyxLQUFLLEtBQUs7QUFDOUIsY0FBSSxXQUFXLFlBQVk7QUFDekIsc0JBQVUsV0FBVyxPQUFPLFdBQVc7QUFDdkMsb0JBQVE7QUFDUixrQkFBTTtBQUFBLGlCQUNEO0FBQ0wsc0JBQVUsV0FBVyxPQUFPLFdBQVc7QUFDdkMsb0JBQVE7QUFDUixrQkFBTTtBQUFBO0FBRVIsY0FBSSxTQUFTO0FBQ1gsa0JBQU07QUFDTixxQkFBUztBQUFBLGlCQUNKO0FBQ0wsa0JBQU07QUFDTixxQkFBUztBQUFBO0FBRVgsaUJBQU8sRUFBQyxPQUFPLEtBQUssU0FBUyxLQUFLO0FBQUE7QUFFcEMsa0NBQTBCLFlBQVksU0FBUyxPQUFPLFFBQU87QUFDM0QsY0FBSSxPQUFPLFFBQVE7QUFDbkIsZ0JBQU0sTUFBTTtBQUNaLGNBQUksQ0FBQyxNQUFNO0FBQ1QsdUJBQVcsZ0JBQWdCO0FBQzNCO0FBQUE7QUFFRixjQUFJLFNBQVMsTUFBTTtBQUNqQix1QkFBVyxnQkFBZ0IsRUFBQyxLQUFLLE1BQU0sT0FBTyxNQUFNLFFBQVEsTUFBTSxNQUFNO0FBQ3hFO0FBQUE7QUFFRixnQkFBTSxFQUFDLE9BQU8sS0FBSyxTQUFTLEtBQUssV0FBVSxZQUFZO0FBQ3ZELGNBQUksU0FBUyxZQUFZLE9BQU87QUFDOUIsdUJBQVcscUJBQXFCO0FBQ2hDLGdCQUFLLE9BQU0sUUFBUSxPQUFPLFFBQU87QUFDL0IscUJBQU87QUFBQSx1QkFDRyxPQUFNLFdBQVcsT0FBTyxRQUFPO0FBQ3pDLHFCQUFPO0FBQUEsbUJBQ0Y7QUFDTCxrQkFBSSxVQUFVLFFBQVEsT0FBTyxLQUFLLFlBQVk7QUFDOUMscUJBQU87QUFBQTtBQUFBO0FBR1gsY0FBSSxVQUFVLE1BQU0sT0FBTyxLQUFLLFlBQVk7QUFDNUMscUJBQVcsZ0JBQWdCO0FBQUE7QUFFN0IsMkJBQW1CLE1BQU0sR0FBRyxHQUFHLFNBQVM7QUFDdEMsY0FBSSxTQUFTO0FBQ1gsbUJBQU8sS0FBSyxNQUFNLEdBQUc7QUFDckIsbUJBQU8sU0FBUyxNQUFNLEdBQUc7QUFBQSxpQkFDcEI7QUFDTCxtQkFBTyxTQUFTLE1BQU0sR0FBRztBQUFBO0FBRTNCLGlCQUFPO0FBQUE7QUFFVCxzQkFBYyxNQUFNLElBQUksSUFBSTtBQUMxQixpQkFBTyxTQUFTLEtBQUssS0FBSyxTQUFTLEtBQUssS0FBSztBQUFBO0FBRS9DLDBCQUFrQixHQUFHLE9BQU8sS0FBSztBQUMvQixpQkFBTyxNQUFNLFVBQVUsUUFBUSxNQUFNLFFBQVEsTUFBTTtBQUFBO0FBRXJELGtDQUEwQixZQUFZLEVBQUMsaUJBQWdCLE9BQU87QUFDNUQscUJBQVcsZ0JBQWdCLGtCQUFrQixTQUN6QyxVQUFVLElBQUksT0FBTyxJQUNyQjtBQUFBO0FBRU4sb0NBQTRCLGtCQUFrQjtBQUFBLFVBQzVDLG1CQUFtQixNQUFNLE1BQU0sT0FBTyxPQUFPO0FBQzNDLG1CQUFPLHNCQUFzQixNQUFNLE1BQU0sT0FBTztBQUFBO0FBQUEsVUFFbEQsZUFBZSxNQUFNLE1BQU0sT0FBTyxPQUFPO0FBQ3ZDLG1CQUFPLHNCQUFzQixNQUFNLE1BQU0sT0FBTztBQUFBO0FBQUEsVUFFbEQsZ0JBQWdCLE1BQU0sTUFBTSxPQUFPLE9BQU87QUFDeEMsa0JBQU0sRUFBQyxRQUFRLFdBQVU7QUFDekIsa0JBQU0sRUFBQyxXQUFXLEtBQUssV0FBVyxRQUFPLEtBQUs7QUFDOUMsa0JBQU0sV0FBVyxPQUFPLFNBQVMsTUFBTSxXQUFXO0FBQ2xELGtCQUFNLFdBQVcsT0FBTyxTQUFTLE1BQU0sV0FBVztBQUNsRCxrQkFBTSxTQUFTO0FBQ2YsZ0JBQUksR0FBRyxNQUFNLE1BQU07QUFDbkIsaUJBQUssSUFBSSxPQUFPLE9BQU8sUUFBUSxPQUFPLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDbkQsb0JBQU0sS0FBSztBQUNYLHFCQUFPO0FBQ1AsbUJBQUssT0FBTyxRQUFRLE9BQU8sTUFBTSxpQkFBaUIsS0FBSyxXQUFXO0FBQ2xFLHFCQUFPLEtBQUssV0FBVyxpQkFBaUIsS0FBSyxXQUFXLE1BQU0sUUFBUTtBQUFBO0FBRXhFLG1CQUFPO0FBQUE7QUFBQSxVQUVULHNCQUFzQixRQUFPLE9BQU8sUUFBUSxPQUFPO0FBQ2pELGtCQUFNLHNCQUFzQixRQUFPLE9BQU8sUUFBUTtBQUNsRCxrQkFBTSxTQUFTLE9BQU87QUFDdEIsZ0JBQUksVUFBVSxVQUFVLEtBQUssWUFBWSxRQUFRO0FBQy9DLHFCQUFNLE1BQU0sS0FBSyxJQUFJLE9BQU0sS0FBSyxPQUFPO0FBQ3ZDLHFCQUFNLE1BQU0sS0FBSyxJQUFJLE9BQU0sS0FBSyxPQUFPO0FBQUE7QUFBQTtBQUFBLFVBRzNDLGlCQUFpQjtBQUNmLG1CQUFPO0FBQUE7QUFBQSxVQUVULGlCQUFpQixRQUFPO0FBQ3RCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxFQUFDLFFBQVEsV0FBVTtBQUN6QixrQkFBTSxTQUFTLEtBQUssVUFBVTtBQUM5QixrQkFBTSxTQUFTLE9BQU87QUFDdEIsa0JBQU0sUUFBUSxXQUFXLFVBQ3JCLE1BQU0sT0FBTyxRQUFRLE9BQU8sT0FBTyxNQUFNLE1BQ3pDLEtBQUssT0FBTyxpQkFBaUIsT0FBTyxPQUFPO0FBQy9DLG1CQUFPO0FBQUEsY0FDTCxPQUFPLEtBQUssT0FBTyxpQkFBaUIsT0FBTyxPQUFPO0FBQUEsY0FDbEQ7QUFBQTtBQUFBO0FBQUEsVUFHSixhQUFhO0FBQ1gsaUJBQUssc0JBQXNCO0FBQzNCLGtCQUFNO0FBQ04sa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGlCQUFLLFFBQVEsS0FBSyxhQUFhO0FBQUE7QUFBQSxVQUVqQyxPQUFPLE1BQU07QUFDWCxrQkFBTSxPQUFPLEtBQUs7QUFDbEIsaUJBQUssZUFBZSxLQUFLLE1BQU0sR0FBRyxLQUFLLEtBQUssUUFBUTtBQUFBO0FBQUEsVUFFdEQsZUFBZSxNQUFNLE9BQU8sT0FBTyxNQUFNO0FBQ3ZDLGtCQUFNLFNBQVEsU0FBUztBQUN2QixrQkFBTSxFQUFDLGVBQU8sYUFBYSxFQUFDLGFBQVc7QUFDdkMsa0JBQU0sT0FBTyxPQUFPO0FBQ3BCLGtCQUFNLGFBQWEsT0FBTztBQUMxQixrQkFBTSxRQUFRLEtBQUs7QUFDbkIsa0JBQU0sRUFBQyxlQUFlLG1CQUFrQixLQUFLLGtCQUFrQixPQUFPO0FBQ3RFLHFCQUFTLElBQUksT0FBTyxJQUFJLFFBQVEsT0FBTyxLQUFLO0FBQzFDLG9CQUFNLFNBQVMsS0FBSyxVQUFVO0FBQzlCLG9CQUFNLFVBQVUsVUFBUyxjQUFjLE9BQU8sT0FBTyxTQUFTLEVBQUMsTUFBTSxNQUFNLFNBQVEsS0FBSyx5QkFBeUI7QUFDakgsb0JBQU0sVUFBVSxLQUFLLHlCQUF5QixHQUFHO0FBQ2pELG9CQUFNLFFBQVMsUUFBTyxXQUFXLElBQUksT0FBTztBQUM1QyxvQkFBTSxhQUFhO0FBQUEsZ0JBQ2pCO0FBQUEsZ0JBQ0EsTUFBTSxRQUFRO0FBQUEsZ0JBQ2Qsb0JBQW9CLENBQUMsU0FBUyxXQUFXLE9BQU8sWUFBYSxZQUFVLE1BQU0sUUFBUSxXQUFVLE1BQU07QUFBQSxnQkFDckcsR0FBRyxhQUFhLFFBQVEsT0FBTyxRQUFRO0FBQUEsZ0JBQ3ZDLEdBQUcsYUFBYSxRQUFRLFNBQVMsUUFBUTtBQUFBLGdCQUN6QyxRQUFRLGFBQWEsUUFBUSxPQUFPLEtBQUssSUFBSSxRQUFRO0FBQUEsZ0JBQ3JELE9BQU8sYUFBYSxLQUFLLElBQUksUUFBUSxRQUFRLFFBQVE7QUFBQTtBQUV2RCxrQkFBSSxnQkFBZ0I7QUFDbEIsMkJBQVcsVUFBVSxpQkFBaUIsS0FBSywwQkFBMEIsR0FBRyxLQUFLLEdBQUcsU0FBUyxXQUFXO0FBQUE7QUFFdEcsb0JBQU0sVUFBVSxXQUFXLFdBQVcsS0FBSyxHQUFHO0FBQzlDLCtCQUFpQixZQUFZLFNBQVMsT0FBTztBQUM3QywrQkFBaUIsWUFBWSxTQUFTLE1BQU07QUFDNUMsbUJBQUssY0FBYyxLQUFLLElBQUksR0FBRyxZQUFZO0FBQUE7QUFBQTtBQUFBLFVBRy9DLFdBQVcsTUFBTSxXQUFXO0FBQzFCLGtCQUFNLEVBQUMsV0FBVSxLQUFLO0FBQ3RCLGtCQUFNLFdBQVcsT0FBTyx3QkFBd0IsS0FBSyxPQUNsRCxPQUFPLFVBQVEsS0FBSyxXQUFXLFFBQVE7QUFDMUMsa0JBQU0sVUFBVSxPQUFPLFFBQVE7QUFDL0Isa0JBQU0sU0FBUztBQUNmLGtCQUFNLFdBQVcsQ0FBQyxTQUFTO0FBQ3pCLG9CQUFNLFNBQVMsS0FBSyxXQUFXLFVBQVU7QUFDekMsb0JBQU0sTUFBTSxVQUFVLE9BQU8sS0FBSyxPQUFPO0FBQ3pDLGtCQUFJLGNBQWMsUUFBUSxNQUFNLE1BQU07QUFDcEMsdUJBQU87QUFBQTtBQUFBO0FBR1gsdUJBQVcsUUFBUSxVQUFVO0FBQzNCLGtCQUFJLGNBQWMsVUFBYSxTQUFTLE9BQU87QUFDN0M7QUFBQTtBQUVGLGtCQUFJLFlBQVksU0FBUyxPQUFPLFFBQVEsS0FBSyxXQUFXLE1BQ3pELFlBQVksVUFBYSxLQUFLLFVBQVUsUUFBWTtBQUNqRCx1QkFBTyxLQUFLLEtBQUs7QUFBQTtBQUVuQixrQkFBSSxLQUFLLFVBQVUsTUFBTTtBQUN2QjtBQUFBO0FBQUE7QUFHSixnQkFBSSxDQUFDLE9BQU8sUUFBUTtBQUNsQixxQkFBTyxLQUFLO0FBQUE7QUFFZCxtQkFBTztBQUFBO0FBQUEsVUFFVCxlQUFlLFFBQU87QUFDcEIsbUJBQU8sS0FBSyxXQUFXLFFBQVcsUUFBTztBQUFBO0FBQUEsVUFFM0MsZUFBZSxjQUFjLE1BQU0sV0FBVztBQUM1QyxrQkFBTSxTQUFTLEtBQUssV0FBVyxjQUFjO0FBQzdDLGtCQUFNLFNBQVMsU0FBUyxTQUNwQixPQUFPLFFBQVEsUUFDZjtBQUNKLG1CQUFRLFdBQVUsS0FDZCxPQUFPLFNBQVMsSUFDaEI7QUFBQTtBQUFBLFVBRU4sWUFBWTtBQUNWLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGtCQUFNLFNBQVM7QUFDZixnQkFBSSxHQUFHO0FBQ1AsaUJBQUssSUFBSSxHQUFHLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUNsRCxxQkFBTyxLQUFLLE9BQU8saUJBQWlCLEtBQUssVUFBVSxHQUFHLE9BQU8sT0FBTztBQUFBO0FBRXRFLGtCQUFNLGVBQWUsS0FBSztBQUMxQixrQkFBTSxNQUFNLGdCQUFnQixxQkFBcUI7QUFDakQsbUJBQU87QUFBQSxjQUNMO0FBQUEsY0FDQTtBQUFBLGNBQ0EsT0FBTyxPQUFPO0FBQUEsY0FDZCxLQUFLLE9BQU87QUFBQSxjQUNaLFlBQVksS0FBSztBQUFBLGNBQ2pCLE9BQU87QUFBQSxjQUNQLFNBQVMsS0FBSztBQUFBLGNBQ2QsT0FBTyxlQUFlLElBQUksS0FBSyxxQkFBcUIsS0FBSztBQUFBO0FBQUE7QUFBQSxVQUc3RCx5QkFBeUIsUUFBTztBQUM5QixrQkFBTSxFQUFDLGFBQWEsRUFBQyxRQUFRLFlBQVcsU0FBUyxFQUFDLE1BQU0sV0FBVyxtQkFBaUI7QUFDcEYsa0JBQU0sYUFBYSxhQUFhO0FBQ2hDLGtCQUFNLFNBQVMsS0FBSyxVQUFVO0FBQzlCLGtCQUFNLFNBQVMsT0FBTztBQUN0QixrQkFBTSxXQUFXLFdBQVc7QUFDNUIsZ0JBQUksUUFBUSxPQUFPLE9BQU87QUFDMUIsZ0JBQUksUUFBUTtBQUNaLGdCQUFJLFNBQVMsV0FBVyxLQUFLLFdBQVcsUUFBUSxRQUFRLFlBQVk7QUFDcEUsZ0JBQUksTUFBTTtBQUNWLGdCQUFJLFdBQVcsT0FBTztBQUNwQixzQkFBUSxTQUFTO0FBQ2pCLHVCQUFTO0FBQUE7QUFFWCxnQkFBSSxVQUFVO0FBQ1osc0JBQVEsT0FBTztBQUNmLHVCQUFTLE9BQU8sU0FBUyxPQUFPO0FBQ2hDLGtCQUFJLFVBQVUsS0FBSyxLQUFLLFdBQVcsS0FBSyxPQUFPLFNBQVM7QUFDdEQsd0JBQVE7QUFBQTtBQUVWLHVCQUFTO0FBQUE7QUFFWCxrQkFBTSxhQUFhLENBQUMsY0FBYyxjQUFjLENBQUMsV0FBVyxZQUFZO0FBQ3hFLGdCQUFJLE9BQU8sT0FBTyxpQkFBaUI7QUFDbkMsZ0JBQUksS0FBSyxNQUFNLGtCQUFrQixTQUFRO0FBQ3ZDLHFCQUFPLE9BQU8saUJBQWlCLFFBQVE7QUFBQSxtQkFDbEM7QUFDTCxxQkFBTztBQUFBO0FBRVQsbUJBQU8sT0FBTztBQUNkLGdCQUFJLEtBQUssSUFBSSxRQUFRLGNBQWM7QUFDakMscUJBQU8sUUFBUSxNQUFNLFFBQVEsY0FBYztBQUMzQyxrQkFBSSxVQUFVLFlBQVk7QUFDeEIsd0JBQVEsT0FBTztBQUFBO0FBRWpCLG9CQUFNLGFBQWEsT0FBTyxtQkFBbUI7QUFDN0Msb0JBQU0sV0FBVyxPQUFPLG1CQUFtQjtBQUMzQyxvQkFBTSxNQUFNLEtBQUssSUFBSSxZQUFZO0FBQ2pDLG9CQUFNLE1BQU0sS0FBSyxJQUFJLFlBQVk7QUFDakMscUJBQU8sS0FBSyxJQUFJLEtBQUssSUFBSSxNQUFNLE1BQU07QUFDckMscUJBQU8sT0FBTztBQUFBO0FBRWhCLGdCQUFJLFNBQVMsT0FBTyxpQkFBaUIsYUFBYTtBQUNoRCxvQkFBTSxXQUFXLEtBQUssUUFBUSxPQUFPLHFCQUFxQixjQUFjO0FBQ3hFLHNCQUFRO0FBQ1Isc0JBQVE7QUFBQTtBQUVWLG1CQUFPO0FBQUEsY0FDTDtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsY0FDQSxRQUFRLE9BQU8sT0FBTztBQUFBO0FBQUE7QUFBQSxVQUcxQix5QkFBeUIsUUFBTyxPQUFPO0FBQ3JDLGtCQUFNLFFBQVEsTUFBTTtBQUNwQixrQkFBTSxVQUFVLEtBQUs7QUFDckIsa0JBQU0sV0FBVyxRQUFRO0FBQ3pCLGtCQUFNLGtCQUFrQixlQUFlLFFBQVEsaUJBQWlCO0FBQ2hFLGdCQUFJLFFBQVE7QUFDWixnQkFBSSxNQUFNLFNBQVM7QUFDakIsb0JBQU0sYUFBYSxXQUFXLEtBQUssZUFBZSxVQUFTLE1BQU07QUFDakUsb0JBQU0sU0FBUSxRQUFRLGlCQUFpQixTQUNuQywwQkFBMEIsUUFBTyxPQUFPLFNBQVMsY0FDakQseUJBQXlCLFFBQU8sT0FBTyxTQUFTO0FBQ3BELG9CQUFNLGFBQWEsS0FBSyxlQUFlLEtBQUssT0FBTyxLQUFLLFlBQVksT0FBTyxXQUFXLFNBQVE7QUFDOUYsdUJBQVMsT0FBTSxRQUFTLE9BQU0sUUFBUSxhQUFlLE9BQU0sUUFBUTtBQUNuRSxxQkFBTyxLQUFLLElBQUksaUJBQWlCLE9BQU0sUUFBUSxPQUFNO0FBQUEsbUJBQ2hEO0FBQ0wsdUJBQVMsTUFBTSxpQkFBaUIsS0FBSyxVQUFVLFFBQU8sTUFBTSxPQUFPO0FBQ25FLHFCQUFPLEtBQUssSUFBSSxpQkFBaUIsTUFBTSxNQUFNLE1BQU07QUFBQTtBQUVyRCxtQkFBTztBQUFBLGNBQ0wsTUFBTSxTQUFTLE9BQU87QUFBQSxjQUN0QixNQUFNLFNBQVMsT0FBTztBQUFBLGNBQ3RCO0FBQUEsY0FDQTtBQUFBO0FBQUE7QUFBQSxVQUdKLE9BQU87QUFDTCxrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGtCQUFNLFFBQVEsS0FBSztBQUNuQixrQkFBTSxPQUFPLE1BQU07QUFDbkIsZ0JBQUksSUFBSTtBQUNSLG1CQUFPLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDcEIsa0JBQUksS0FBSyxVQUFVLEdBQUcsT0FBTyxVQUFVLE1BQU07QUFDM0Msc0JBQU0sR0FBRyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUszQixzQkFBYyxLQUFLO0FBQ25CLHNCQUFjLFdBQVc7QUFBQSxVQUN2QixvQkFBb0I7QUFBQSxVQUNwQixpQkFBaUI7QUFBQSxVQUNqQixvQkFBb0I7QUFBQSxVQUNwQixlQUFlO0FBQUEsVUFDZixTQUFTO0FBQUEsVUFDVCxZQUFZO0FBQUEsWUFDVixTQUFTO0FBQUEsY0FDUCxNQUFNO0FBQUEsY0FDTixZQUFZLENBQUMsS0FBSyxLQUFLLFFBQVEsU0FBUztBQUFBO0FBQUE7QUFBQTtBQUk5QyxzQkFBYyxZQUFZO0FBQUEsVUFDeEIsUUFBUTtBQUFBLFlBQ04sU0FBUztBQUFBLGNBQ1AsTUFBTTtBQUFBLGNBQ04sUUFBUTtBQUFBLGNBQ1IsTUFBTTtBQUFBLGdCQUNKLFFBQVE7QUFBQTtBQUFBO0FBQUEsWUFHWixTQUFTO0FBQUEsY0FDUCxNQUFNO0FBQUEsY0FDTixhQUFhO0FBQUE7QUFBQTtBQUFBO0FBS25CLHVDQUErQixrQkFBa0I7QUFBQSxVQUMvQyxhQUFhO0FBQ1gsaUJBQUssc0JBQXNCO0FBQzNCLGtCQUFNO0FBQUE7QUFBQSxVQUVSLG1CQUFtQixNQUFNLE1BQU0sT0FBTyxPQUFPO0FBQzNDLGtCQUFNLFNBQVMsTUFBTSxtQkFBbUIsTUFBTSxNQUFNLE9BQU87QUFDM0QscUJBQVMsSUFBSSxHQUFHLElBQUksT0FBTyxRQUFRLEtBQUs7QUFDdEMscUJBQU8sR0FBRyxVQUFVLEtBQUssMEJBQTBCLElBQUksT0FBTztBQUFBO0FBRWhFLG1CQUFPO0FBQUE7QUFBQSxVQUVULGVBQWUsTUFBTSxNQUFNLE9BQU8sT0FBTztBQUN2QyxrQkFBTSxTQUFTLE1BQU0sZUFBZSxNQUFNLE1BQU0sT0FBTztBQUN2RCxxQkFBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsS0FBSztBQUN0QyxvQkFBTSxPQUFPLEtBQUssUUFBUTtBQUMxQixxQkFBTyxHQUFHLFVBQVUsZUFBZSxLQUFLLElBQUksS0FBSywwQkFBMEIsSUFBSSxPQUFPO0FBQUE7QUFFeEYsbUJBQU87QUFBQTtBQUFBLFVBRVQsZ0JBQWdCLE1BQU0sTUFBTSxPQUFPLE9BQU87QUFDeEMsa0JBQU0sU0FBUyxNQUFNLGdCQUFnQixNQUFNLE1BQU0sT0FBTztBQUN4RCxxQkFBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsS0FBSztBQUN0QyxvQkFBTSxPQUFPLEtBQUssUUFBUTtBQUMxQixxQkFBTyxHQUFHLFVBQVUsZUFBZSxRQUFRLEtBQUssS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLDBCQUEwQixJQUFJLE9BQU87QUFBQTtBQUUxRyxtQkFBTztBQUFBO0FBQUEsVUFFVCxpQkFBaUI7QUFDZixrQkFBTSxPQUFPLEtBQUssWUFBWTtBQUM5QixnQkFBSSxNQUFNO0FBQ1YscUJBQVMsSUFBSSxLQUFLLFNBQVMsR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQ3pDLG9CQUFNLEtBQUssSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssMEJBQTBCLE1BQU07QUFBQTtBQUV4RSxtQkFBTyxNQUFNLEtBQUs7QUFBQTtBQUFBLFVBRXBCLGlCQUFpQixRQUFPO0FBQ3RCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxFQUFDLFFBQVEsV0FBVTtBQUN6QixrQkFBTSxTQUFTLEtBQUssVUFBVTtBQUM5QixrQkFBTSxJQUFJLE9BQU8saUJBQWlCLE9BQU87QUFDekMsa0JBQU0sSUFBSSxPQUFPLGlCQUFpQixPQUFPO0FBQ3pDLGtCQUFNLElBQUksT0FBTztBQUNqQixtQkFBTztBQUFBLGNBQ0wsT0FBTyxLQUFLO0FBQUEsY0FDWixPQUFPLE1BQU0sSUFBSSxPQUFPLElBQUssS0FBSSxPQUFPLElBQUksTUFBTTtBQUFBO0FBQUE7QUFBQSxVQUd0RCxPQUFPLE1BQU07QUFDWCxrQkFBTSxTQUFTLEtBQUssWUFBWTtBQUNoQyxpQkFBSyxlQUFlLFFBQVEsR0FBRyxPQUFPLFFBQVE7QUFBQTtBQUFBLFVBRWhELGVBQWUsUUFBUSxPQUFPLE9BQU8sTUFBTTtBQUN6QyxrQkFBTSxTQUFRLFNBQVM7QUFDdkIsa0JBQU0sRUFBQyxRQUFRLFdBQVUsS0FBSztBQUM5QixrQkFBTSxFQUFDLGVBQWUsbUJBQWtCLEtBQUssa0JBQWtCLE9BQU87QUFDdEUsa0JBQU0sUUFBUSxPQUFPO0FBQ3JCLGtCQUFNLFFBQVEsT0FBTztBQUNyQixxQkFBUyxJQUFJLE9BQU8sSUFBSSxRQUFRLE9BQU8sS0FBSztBQUMxQyxvQkFBTSxRQUFRLE9BQU87QUFDckIsb0JBQU0sU0FBUyxDQUFDLFVBQVMsS0FBSyxVQUFVO0FBQ3hDLG9CQUFNLGFBQWE7QUFDbkIsb0JBQU0sU0FBUyxXQUFXLFNBQVMsU0FBUSxPQUFPLG1CQUFtQixPQUFPLE9BQU8saUJBQWlCLE9BQU87QUFDM0csb0JBQU0sU0FBUyxXQUFXLFNBQVMsU0FBUSxPQUFPLGlCQUFpQixPQUFPLGlCQUFpQixPQUFPO0FBQ2xHLHlCQUFXLE9BQU8sTUFBTSxXQUFXLE1BQU07QUFDekMsa0JBQUksZ0JBQWdCO0FBQ2xCLDJCQUFXLFVBQVUsaUJBQWlCLEtBQUssMEJBQTBCLEdBQUcsTUFBTSxTQUFTLFdBQVc7QUFDbEcsb0JBQUksUUFBTztBQUNULDZCQUFXLFFBQVEsU0FBUztBQUFBO0FBQUE7QUFHaEMsbUJBQUssY0FBYyxPQUFPLEdBQUcsWUFBWTtBQUFBO0FBQUE7QUFBQSxVQUc3QywwQkFBMEIsUUFBTyxNQUFNO0FBQ3JDLGtCQUFNLFNBQVMsS0FBSyxVQUFVO0FBQzlCLGdCQUFJLFNBQVMsTUFBTSwwQkFBMEIsUUFBTztBQUNwRCxnQkFBSSxPQUFPLFNBQVM7QUFDbEIsdUJBQVMsT0FBTyxPQUFPLElBQUksUUFBUSxFQUFDLFNBQVM7QUFBQTtBQUUvQyxrQkFBTSxTQUFTLE9BQU87QUFDdEIsZ0JBQUksU0FBUyxVQUFVO0FBQ3JCLHFCQUFPLFNBQVM7QUFBQTtBQUVsQixtQkFBTyxVQUFVLGVBQWUsVUFBVSxPQUFPLFNBQVM7QUFDMUQsbUJBQU87QUFBQTtBQUFBO0FBR1gseUJBQWlCLEtBQUs7QUFDdEIseUJBQWlCLFdBQVc7QUFBQSxVQUMxQixvQkFBb0I7QUFBQSxVQUNwQixpQkFBaUI7QUFBQSxVQUNqQixZQUFZO0FBQUEsWUFDVixTQUFTO0FBQUEsY0FDUCxNQUFNO0FBQUEsY0FDTixZQUFZLENBQUMsS0FBSyxLQUFLLGVBQWU7QUFBQTtBQUFBO0FBQUE7QUFJNUMseUJBQWlCLFlBQVk7QUFBQSxVQUMzQixRQUFRO0FBQUEsWUFDTixHQUFHO0FBQUEsY0FDRCxNQUFNO0FBQUE7QUFBQSxZQUVSLEdBQUc7QUFBQSxjQUNELE1BQU07QUFBQTtBQUFBO0FBQUEsVUFHVixTQUFTO0FBQUEsWUFDUCxTQUFTO0FBQUEsY0FDUCxXQUFXO0FBQUEsZ0JBQ1QsUUFBUTtBQUNOLHlCQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9qQixtQ0FBMkIsVUFBVSxlQUFlLFFBQVE7QUFDMUQsY0FBSSxTQUFTO0FBQ2IsY0FBSSxTQUFTO0FBQ2IsY0FBSSxVQUFVO0FBQ2QsY0FBSSxVQUFVO0FBQ2QsY0FBSSxnQkFBZ0IsS0FBSztBQUN2QixrQkFBTSxhQUFhO0FBQ25CLGtCQUFNLFdBQVcsYUFBYTtBQUM5QixrQkFBTSxTQUFTLEtBQUssSUFBSTtBQUN4QixrQkFBTSxTQUFTLEtBQUssSUFBSTtBQUN4QixrQkFBTSxPQUFPLEtBQUssSUFBSTtBQUN0QixrQkFBTSxPQUFPLEtBQUssSUFBSTtBQUN0QixrQkFBTSxVQUFVLENBQUMsT0FBTyxHQUFHLE1BQU0sY0FBYyxPQUFPLFlBQVksVUFBVSxRQUFRLElBQUksS0FBSyxJQUFJLEdBQUcsSUFBSSxRQUFRLEdBQUcsSUFBSTtBQUN2SCxrQkFBTSxVQUFVLENBQUMsT0FBTyxHQUFHLE1BQU0sY0FBYyxPQUFPLFlBQVksVUFBVSxRQUFRLEtBQUssS0FBSyxJQUFJLEdBQUcsSUFBSSxRQUFRLEdBQUcsSUFBSTtBQUN4SCxrQkFBTSxPQUFPLFFBQVEsR0FBRyxRQUFRO0FBQ2hDLGtCQUFNLE9BQU8sUUFBUSxTQUFTLFFBQVE7QUFDdEMsa0JBQU0sT0FBTyxRQUFRLElBQUksUUFBUTtBQUNqQyxrQkFBTSxPQUFPLFFBQVEsS0FBSyxTQUFTLFFBQVE7QUFDM0MscUJBQVUsUUFBTyxRQUFRO0FBQ3pCLHFCQUFVLFFBQU8sUUFBUTtBQUN6QixzQkFBVSxDQUFFLFFBQU8sUUFBUTtBQUMzQixzQkFBVSxDQUFFLFFBQU8sUUFBUTtBQUFBO0FBRTdCLGlCQUFPLEVBQUMsUUFBUSxRQUFRLFNBQVM7QUFBQTtBQUVuQyx5Q0FBaUMsa0JBQWtCO0FBQUEsVUFDakQsWUFBWSxRQUFPLGNBQWM7QUFDL0Isa0JBQU0sUUFBTztBQUNiLGlCQUFLLHNCQUFzQjtBQUMzQixpQkFBSyxjQUFjO0FBQ25CLGlCQUFLLGNBQWM7QUFDbkIsaUJBQUssVUFBVTtBQUNmLGlCQUFLLFVBQVU7QUFBQTtBQUFBLFVBRWpCLGFBQWE7QUFBQTtBQUFBLFVBQ2IsTUFBTSxPQUFPLE9BQU87QUFDbEIsa0JBQU0sT0FBTyxLQUFLLGFBQWE7QUFDL0Isa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGdCQUFJLEtBQUssYUFBYSxPQUFPO0FBQzNCLG1CQUFLLFVBQVU7QUFBQSxtQkFDVjtBQUNMLGtCQUFJLFNBQVMsQ0FBQyxPQUFNLENBQUMsS0FBSztBQUMxQixrQkFBSSxVQUFTLEtBQUssU0FBUztBQUN6QixzQkFBTSxFQUFDLE1BQU0sWUFBVyxLQUFLO0FBQzdCLHlCQUFTLENBQUMsT0FBTSxDQUFDLGlCQUFpQixLQUFLLEtBQUk7QUFBQTtBQUU3QyxrQkFBSSxHQUFHO0FBQ1AsbUJBQUssSUFBSSxPQUFPLE9BQU8sUUFBUSxPQUFPLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDbkQscUJBQUssUUFBUSxLQUFLLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUkvQixlQUFlO0FBQ2IsbUJBQU8sVUFBVSxLQUFLLFFBQVEsV0FBVztBQUFBO0FBQUEsVUFFM0Msb0JBQW9CO0FBQ2xCLG1CQUFPLFVBQVUsS0FBSyxRQUFRO0FBQUE7QUFBQSxVQUVoQyxzQkFBc0I7QUFDcEIsZ0JBQUksTUFBTTtBQUNWLGdCQUFJLE1BQU0sQ0FBQztBQUNYLHFCQUFTLElBQUksR0FBRyxJQUFJLEtBQUssTUFBTSxLQUFLLFNBQVMsUUFBUSxFQUFFLEdBQUc7QUFDeEQsa0JBQUksS0FBSyxNQUFNLGlCQUFpQixJQUFJO0FBQ2xDLHNCQUFNLGFBQWEsS0FBSyxNQUFNLGVBQWUsR0FBRztBQUNoRCxzQkFBTSxXQUFXLFdBQVc7QUFDNUIsc0JBQU0sZ0JBQWdCLFdBQVc7QUFDakMsc0JBQU0sS0FBSyxJQUFJLEtBQUs7QUFDcEIsc0JBQU0sS0FBSyxJQUFJLEtBQUssV0FBVztBQUFBO0FBQUE7QUFHbkMsbUJBQU87QUFBQSxjQUNMLFVBQVU7QUFBQSxjQUNWLGVBQWUsTUFBTTtBQUFBO0FBQUE7QUFBQSxVQUd6QixPQUFPLE1BQU07QUFDWCxrQkFBTSxTQUFRLEtBQUs7QUFDbkIsa0JBQU0sRUFBQyxjQUFhO0FBQ3BCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sVUFBVSxLQUFLLHNCQUFzQixLQUFLLGFBQWEsUUFBUSxLQUFLLFFBQVE7QUFDbEYsa0JBQU0sVUFBVSxLQUFLLElBQUssTUFBSyxJQUFJLFVBQVUsT0FBTyxVQUFVLFVBQVUsV0FBVyxHQUFHO0FBQ3RGLGtCQUFNLFNBQVMsS0FBSyxJQUFJLGFBQWEsS0FBSyxRQUFRLFFBQVEsVUFBVTtBQUNwRSxrQkFBTSxjQUFjLEtBQUssZUFBZSxLQUFLO0FBQzdDLGtCQUFNLEVBQUMsZUFBZSxhQUFZLEtBQUs7QUFDdkMsa0JBQU0sRUFBQyxRQUFRLFFBQVEsU0FBUyxZQUFXLGtCQUFrQixVQUFVLGVBQWU7QUFDdEYsa0JBQU0sV0FBWSxXQUFVLFFBQVEsV0FBVztBQUMvQyxrQkFBTSxZQUFhLFdBQVUsU0FBUyxXQUFXO0FBQ2pELGtCQUFNLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSSxVQUFVLGFBQWEsR0FBRztBQUM5RCxrQkFBTSxjQUFjLFlBQVksS0FBSyxRQUFRLFFBQVE7QUFDckQsa0JBQU0sY0FBYyxLQUFLLElBQUksY0FBYyxRQUFRO0FBQ25ELGtCQUFNLGVBQWdCLGVBQWMsZUFBZSxLQUFLO0FBQ3hELGlCQUFLLFVBQVUsVUFBVTtBQUN6QixpQkFBSyxVQUFVLFVBQVU7QUFDekIsaUJBQUssUUFBUSxLQUFLO0FBQ2xCLGlCQUFLLGNBQWMsY0FBYyxlQUFlLEtBQUsscUJBQXFCLEtBQUs7QUFDL0UsaUJBQUssY0FBYyxLQUFLLElBQUksS0FBSyxjQUFjLGVBQWUsYUFBYTtBQUMzRSxpQkFBSyxlQUFlLE1BQU0sR0FBRyxLQUFLLFFBQVE7QUFBQTtBQUFBLFVBRTVDLGVBQWUsR0FBRyxRQUFPO0FBQ3ZCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sZ0JBQWdCLEtBQUs7QUFDM0IsZ0JBQUssVUFBUyxLQUFLLFVBQVUsaUJBQWtCLENBQUMsS0FBSyxNQUFNLGtCQUFrQixNQUFNLEtBQUssUUFBUSxPQUFPLFFBQVEsS0FBSyxLQUFLLEdBQUcsUUFBUTtBQUNsSSxxQkFBTztBQUFBO0FBRVQsbUJBQU8sS0FBSyx1QkFBdUIsS0FBSyxRQUFRLEtBQUssZ0JBQWdCO0FBQUE7QUFBQSxVQUV2RSxlQUFlLE1BQU0sT0FBTyxPQUFPLE1BQU07QUFDdkMsa0JBQU0sU0FBUSxTQUFTO0FBQ3ZCLGtCQUFNLFNBQVEsS0FBSztBQUNuQixrQkFBTSxZQUFZLE9BQU07QUFDeEIsa0JBQU0sT0FBTyxPQUFNO0FBQ25CLGtCQUFNLGdCQUFnQixLQUFLO0FBQzNCLGtCQUFNLFVBQVcsV0FBVSxPQUFPLFVBQVUsU0FBUztBQUNyRCxrQkFBTSxVQUFXLFdBQVUsTUFBTSxVQUFVLFVBQVU7QUFDckQsa0JBQU0sZUFBZSxVQUFTLGNBQWM7QUFDNUMsa0JBQU0sY0FBYyxlQUFlLElBQUksS0FBSztBQUM1QyxrQkFBTSxjQUFjLGVBQWUsSUFBSSxLQUFLO0FBQzVDLGtCQUFNLEVBQUMsZUFBZSxtQkFBa0IsS0FBSyxrQkFBa0IsT0FBTztBQUN0RSxnQkFBSSxhQUFhLEtBQUs7QUFDdEIsZ0JBQUk7QUFDSixpQkFBSyxJQUFJLEdBQUcsSUFBSSxPQUFPLEVBQUUsR0FBRztBQUMxQiw0QkFBYyxLQUFLLGVBQWUsR0FBRztBQUFBO0FBRXZDLGlCQUFLLElBQUksT0FBTyxJQUFJLFFBQVEsT0FBTyxFQUFFLEdBQUc7QUFDdEMsb0JBQU0sZ0JBQWdCLEtBQUssZUFBZSxHQUFHO0FBQzdDLG9CQUFNLE1BQU0sS0FBSztBQUNqQixvQkFBTSxhQUFhO0FBQUEsZ0JBQ2pCLEdBQUcsVUFBVSxLQUFLO0FBQUEsZ0JBQ2xCLEdBQUcsVUFBVSxLQUFLO0FBQUEsZ0JBQ2xCO0FBQUEsZ0JBQ0EsVUFBVSxhQUFhO0FBQUEsZ0JBQ3ZCO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBO0FBRUYsa0JBQUksZ0JBQWdCO0FBQ2xCLDJCQUFXLFVBQVUsaUJBQWlCLEtBQUssMEJBQTBCLEdBQUcsSUFBSSxTQUFTLFdBQVc7QUFBQTtBQUVsRyw0QkFBYztBQUNkLG1CQUFLLGNBQWMsS0FBSyxHQUFHLFlBQVk7QUFBQTtBQUFBO0FBQUEsVUFHM0MsaUJBQWlCO0FBQ2Ysa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLFdBQVcsS0FBSztBQUN0QixnQkFBSSxRQUFRO0FBQ1osZ0JBQUk7QUFDSixpQkFBSyxJQUFJLEdBQUcsSUFBSSxTQUFTLFFBQVEsS0FBSztBQUNwQyxvQkFBTSxRQUFRLEtBQUssUUFBUTtBQUMzQixrQkFBSSxVQUFVLFFBQVEsQ0FBQyxNQUFNLFVBQVUsS0FBSyxNQUFNLGtCQUFrQixNQUFNLENBQUMsU0FBUyxHQUFHLFFBQVE7QUFDN0YseUJBQVMsS0FBSyxJQUFJO0FBQUE7QUFBQTtBQUd0QixtQkFBTztBQUFBO0FBQUEsVUFFVCx1QkFBdUIsT0FBTztBQUM1QixrQkFBTSxRQUFRLEtBQUssWUFBWTtBQUMvQixnQkFBSSxRQUFRLEtBQUssQ0FBQyxNQUFNLFFBQVE7QUFDOUIscUJBQU8sTUFBTyxNQUFLLElBQUksU0FBUztBQUFBO0FBRWxDLG1CQUFPO0FBQUE7QUFBQSxVQUVULGlCQUFpQixRQUFPO0FBQ3RCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxTQUFRLEtBQUs7QUFDbkIsa0JBQU0sU0FBUyxPQUFNLEtBQUssVUFBVTtBQUNwQyxrQkFBTSxRQUFRLGFBQWEsS0FBSyxRQUFRLFNBQVEsT0FBTSxRQUFRO0FBQzlELG1CQUFPO0FBQUEsY0FDTCxPQUFPLE9BQU8sV0FBVTtBQUFBLGNBQ3hCO0FBQUE7QUFBQTtBQUFBLFVBR0osa0JBQWtCLE1BQU07QUFDdEIsZ0JBQUksTUFBTTtBQUNWLGtCQUFNLFNBQVEsS0FBSztBQUNuQixnQkFBSSxHQUFHLE1BQU0sTUFBTSxZQUFZO0FBQy9CLGdCQUFJLENBQUMsTUFBTTtBQUNULG1CQUFLLElBQUksR0FBRyxPQUFPLE9BQU0sS0FBSyxTQUFTLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUM1RCxvQkFBSSxPQUFNLGlCQUFpQixJQUFJO0FBQzdCLHlCQUFPLE9BQU0sZUFBZTtBQUM1Qix5QkFBTyxLQUFLO0FBQ1osK0JBQWEsS0FBSztBQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUlOLGdCQUFJLENBQUMsTUFBTTtBQUNULHFCQUFPO0FBQUE7QUFFVCxpQkFBSyxJQUFJLEdBQUcsT0FBTyxLQUFLLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUM3Qyx3QkFBVSxXQUFXLDBCQUEwQjtBQUMvQyxrQkFBSSxRQUFRLGdCQUFnQixTQUFTO0FBQ25DLHNCQUFNLEtBQUssSUFBSSxLQUFLLFFBQVEsZUFBZSxHQUFHLFFBQVEsb0JBQW9CO0FBQUE7QUFBQTtBQUc5RSxtQkFBTztBQUFBO0FBQUEsVUFFVCxhQUFhLE1BQU07QUFDakIsZ0JBQUksTUFBTTtBQUNWLHFCQUFTLElBQUksR0FBRyxPQUFPLEtBQUssUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ2pELG9CQUFNLFVBQVUsS0FBSywwQkFBMEI7QUFDL0Msb0JBQU0sS0FBSyxJQUFJLEtBQUssUUFBUSxVQUFVLEdBQUcsUUFBUSxlQUFlO0FBQUE7QUFFbEUsbUJBQU87QUFBQTtBQUFBLFVBRVQscUJBQXFCLGNBQWM7QUFDakMsZ0JBQUksbUJBQW1CO0FBQ3ZCLHFCQUFTLElBQUksR0FBRyxJQUFJLGNBQWMsRUFBRSxHQUFHO0FBQ3JDLGtCQUFJLEtBQUssTUFBTSxpQkFBaUIsSUFBSTtBQUNsQyxvQ0FBb0IsS0FBSyxlQUFlO0FBQUE7QUFBQTtBQUc1QyxtQkFBTztBQUFBO0FBQUEsVUFFVCxlQUFlLGNBQWM7QUFDM0IsbUJBQU8sS0FBSyxJQUFJLGVBQWUsS0FBSyxNQUFNLEtBQUssU0FBUyxjQUFjLFFBQVEsSUFBSTtBQUFBO0FBQUEsVUFFcEYsZ0NBQWdDO0FBQzlCLG1CQUFPLEtBQUsscUJBQXFCLEtBQUssTUFBTSxLQUFLLFNBQVMsV0FBVztBQUFBO0FBQUE7QUFHekUsMkJBQW1CLEtBQUs7QUFDeEIsMkJBQW1CLFdBQVc7QUFBQSxVQUM1QixvQkFBb0I7QUFBQSxVQUNwQixpQkFBaUI7QUFBQSxVQUNqQixXQUFXO0FBQUEsWUFDVCxlQUFlO0FBQUEsWUFDZixjQUFjO0FBQUE7QUFBQSxVQUVoQixZQUFZO0FBQUEsWUFDVixTQUFTO0FBQUEsY0FDUCxNQUFNO0FBQUEsY0FDTixZQUFZLENBQUMsaUJBQWlCLFlBQVksZUFBZSxlQUFlLGNBQWMsS0FBSyxLQUFLLFVBQVUsZUFBZTtBQUFBO0FBQUE7QUFBQSxVQUc3SCxRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsVUFDVixlQUFlO0FBQUEsVUFDZixRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxXQUFXO0FBQUE7QUFFYiwyQkFBbUIsY0FBYztBQUFBLFVBQy9CLGFBQWEsQ0FBQyxTQUFTLFNBQVM7QUFBQSxVQUNoQyxZQUFZLENBQUMsU0FBUyxTQUFTO0FBQUE7QUFFakMsMkJBQW1CLFlBQVk7QUFBQSxVQUM3QixhQUFhO0FBQUEsVUFDYixTQUFTO0FBQUEsWUFDUCxRQUFRO0FBQUEsY0FDTixRQUFRO0FBQUEsZ0JBQ04sZUFBZSxRQUFPO0FBQ3BCLHdCQUFNLE9BQU8sT0FBTTtBQUNuQixzQkFBSSxLQUFLLE9BQU8sVUFBVSxLQUFLLFNBQVMsUUFBUTtBQUM5QywwQkFBTSxFQUFDLFFBQVEsRUFBQyxpQkFBZSxPQUFNLE9BQU87QUFDNUMsMkJBQU8sS0FBSyxPQUFPLElBQUksQ0FBQyxPQUFPLE1BQU07QUFDbkMsNEJBQU0sT0FBTyxPQUFNLGVBQWU7QUFDbEMsNEJBQU0sUUFBUSxLQUFLLFdBQVcsU0FBUztBQUN2Qyw2QkFBTztBQUFBLHdCQUNMLE1BQU07QUFBQSx3QkFDTixXQUFXLE1BQU07QUFBQSx3QkFDakIsYUFBYSxNQUFNO0FBQUEsd0JBQ25CLFdBQVcsTUFBTTtBQUFBLHdCQUNqQjtBQUFBLHdCQUNBLFFBQVEsQ0FBQyxPQUFNLGtCQUFrQjtBQUFBLHdCQUNqQyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBSWIseUJBQU87QUFBQTtBQUFBO0FBQUEsY0FHWCxRQUFRLEdBQUcsWUFBWSxRQUFRO0FBQzdCLHVCQUFPLE1BQU0scUJBQXFCLFdBQVc7QUFDN0MsdUJBQU8sTUFBTTtBQUFBO0FBQUE7QUFBQSxZQUdqQixTQUFTO0FBQUEsY0FDUCxXQUFXO0FBQUEsZ0JBQ1QsUUFBUTtBQUNOLHlCQUFPO0FBQUE7QUFBQSxnQkFFVCxNQUFNLGFBQWE7QUFDakIsc0JBQUksWUFBWSxZQUFZO0FBQzVCLHdCQUFNLFFBQVEsT0FBTyxZQUFZO0FBQ2pDLHNCQUFJLFFBQVEsWUFBWTtBQUN0QixnQ0FBWSxVQUFVO0FBQ3RCLDhCQUFVLE1BQU07QUFBQSx5QkFDWDtBQUNMLGlDQUFhO0FBQUE7QUFFZix5QkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPakIscUNBQTZCLGtCQUFrQjtBQUFBLFVBQzdDLGFBQWE7QUFDWCxpQkFBSyxzQkFBc0I7QUFDM0IsaUJBQUsscUJBQXFCO0FBQzFCLGtCQUFNO0FBQUE7QUFBQSxVQUVSLE9BQU8sTUFBTTtBQUNYLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxFQUFDLFNBQVMsTUFBTSxNQUFNLFNBQVMsSUFBSSxhQUFZO0FBQ3JELGtCQUFNLHFCQUFxQixLQUFLLE1BQU07QUFDdEMsZ0JBQUksRUFBQyxPQUFPLFVBQVMsaUNBQWlDLE1BQU0sUUFBUTtBQUNwRSxpQkFBSyxhQUFhO0FBQ2xCLGlCQUFLLGFBQWE7QUFDbEIsZ0JBQUksb0JBQW9CLE9BQU87QUFDN0Isc0JBQVE7QUFDUixzQkFBUSxPQUFPO0FBQUE7QUFFakIsaUJBQUssU0FBUyxLQUFLO0FBQ25CLGlCQUFLLGdCQUFnQixLQUFLO0FBQzFCLGlCQUFLLGFBQWEsQ0FBQyxDQUFDLFNBQVM7QUFDN0IsaUJBQUssU0FBUztBQUNkLGtCQUFNLFVBQVUsS0FBSyw2QkFBNkI7QUFDbEQsZ0JBQUksQ0FBQyxLQUFLLFFBQVEsVUFBVTtBQUMxQixzQkFBUSxjQUFjO0FBQUE7QUFFeEIsb0JBQVEsVUFBVSxLQUFLLFFBQVE7QUFDL0IsaUJBQUssY0FBYyxNQUFNLFFBQVc7QUFBQSxjQUNsQyxVQUFVLENBQUM7QUFBQSxjQUNYO0FBQUEsZUFDQztBQUNILGlCQUFLLGVBQWUsUUFBUSxPQUFPLE9BQU87QUFBQTtBQUFBLFVBRTVDLGVBQWUsUUFBUSxPQUFPLE9BQU8sTUFBTTtBQUN6QyxrQkFBTSxTQUFRLFNBQVM7QUFDdkIsa0JBQU0sRUFBQyxRQUFRLFFBQVEsVUFBVSxhQUFZLEtBQUs7QUFDbEQsa0JBQU0sRUFBQyxlQUFlLG1CQUFrQixLQUFLLGtCQUFrQixPQUFPO0FBQ3RFLGtCQUFNLFFBQVEsT0FBTztBQUNyQixrQkFBTSxRQUFRLE9BQU87QUFDckIsa0JBQU0sRUFBQyxVQUFVLFlBQVcsS0FBSztBQUNqQyxrQkFBTSxlQUFlLFNBQVMsWUFBWSxXQUFXLE9BQU87QUFDNUQsa0JBQU0sZUFBZSxLQUFLLE1BQU0sdUJBQXVCLFVBQVMsU0FBUztBQUN6RSxnQkFBSSxhQUFhLFFBQVEsS0FBSyxLQUFLLFVBQVUsUUFBUTtBQUNyRCxxQkFBUyxJQUFJLE9BQU8sSUFBSSxRQUFRLE9BQU8sRUFBRSxHQUFHO0FBQzFDLG9CQUFNLFFBQVEsT0FBTztBQUNyQixvQkFBTSxTQUFTLEtBQUssVUFBVTtBQUM5QixvQkFBTSxhQUFhLGVBQWUsUUFBUTtBQUMxQyxvQkFBTSxXQUFXLGNBQWMsT0FBTztBQUN0QyxvQkFBTSxTQUFTLFdBQVcsU0FBUyxPQUFPLGlCQUFpQixPQUFPLFFBQVE7QUFDMUUsb0JBQU0sU0FBUyxXQUFXLFNBQVMsVUFBUyxXQUFXLE9BQU8saUJBQWlCLE9BQU8saUJBQWlCLFdBQVcsS0FBSyxXQUFXLFFBQVEsUUFBUSxZQUFZLE9BQU8sUUFBUTtBQUM3Syx5QkFBVyxPQUFPLE1BQU0sV0FBVyxNQUFNLFdBQVc7QUFDcEQseUJBQVcsT0FBTyxJQUFJLEtBQU0sS0FBSyxJQUFJLE9BQU8sU0FBUyxXQUFXLFVBQVc7QUFDM0Usa0JBQUksU0FBUztBQUNYLDJCQUFXLFNBQVM7QUFDcEIsMkJBQVcsTUFBTSxTQUFTLEtBQUs7QUFBQTtBQUVqQyxrQkFBSSxnQkFBZ0I7QUFDbEIsMkJBQVcsVUFBVSxpQkFBaUIsS0FBSywwQkFBMEIsR0FBRyxNQUFNLFNBQVMsV0FBVztBQUFBO0FBRXBHLGtCQUFJLENBQUMsY0FBYztBQUNqQixxQkFBSyxjQUFjLE9BQU8sR0FBRyxZQUFZO0FBQUE7QUFFM0MsMkJBQWE7QUFBQTtBQUFBO0FBQUEsVUFHakIsaUJBQWlCO0FBQ2Ysa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLFVBQVUsS0FBSztBQUNyQixrQkFBTSxTQUFTLFFBQVEsV0FBVyxRQUFRLFFBQVEsZUFBZTtBQUNqRSxrQkFBTSxPQUFPLEtBQUssUUFBUTtBQUMxQixnQkFBSSxDQUFDLEtBQUssUUFBUTtBQUNoQixxQkFBTztBQUFBO0FBRVQsa0JBQU0sYUFBYSxLQUFLLEdBQUcsS0FBSyxLQUFLLDBCQUEwQjtBQUMvRCxrQkFBTSxZQUFZLEtBQUssS0FBSyxTQUFTLEdBQUcsS0FBSyxLQUFLLDBCQUEwQixLQUFLLFNBQVM7QUFDMUYsbUJBQU8sS0FBSyxJQUFJLFFBQVEsWUFBWSxhQUFhO0FBQUE7QUFBQSxVQUVuRCxPQUFPO0FBQ0wsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGlCQUFLLFFBQVEsb0JBQW9CLEtBQUssTUFBTSxXQUFXLEtBQUssT0FBTztBQUNuRSxrQkFBTTtBQUFBO0FBQUE7QUFHVix1QkFBZSxLQUFLO0FBQ3BCLHVCQUFlLFdBQVc7QUFBQSxVQUN4QixvQkFBb0I7QUFBQSxVQUNwQixpQkFBaUI7QUFBQSxVQUNqQixVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUE7QUFFWix1QkFBZSxZQUFZO0FBQUEsVUFDekIsUUFBUTtBQUFBLFlBQ04sU0FBUztBQUFBLGNBQ1AsTUFBTTtBQUFBO0FBQUEsWUFFUixTQUFTO0FBQUEsY0FDUCxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBS1osMENBQWtDLGtCQUFrQjtBQUFBLFVBQ2xELFlBQVksUUFBTyxjQUFjO0FBQy9CLGtCQUFNLFFBQU87QUFDYixpQkFBSyxjQUFjO0FBQ25CLGlCQUFLLGNBQWM7QUFBQTtBQUFBLFVBRXJCLGlCQUFpQixRQUFPO0FBQ3RCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxTQUFRLEtBQUs7QUFDbkIsa0JBQU0sU0FBUyxPQUFNLEtBQUssVUFBVTtBQUNwQyxrQkFBTSxRQUFRLGFBQWEsS0FBSyxRQUFRLFFBQU8sR0FBRyxPQUFNLFFBQVE7QUFDaEUsbUJBQU87QUFBQSxjQUNMLE9BQU8sT0FBTyxXQUFVO0FBQUEsY0FDeEI7QUFBQTtBQUFBO0FBQUEsVUFHSixnQkFBZ0IsTUFBTSxNQUFNLE9BQU8sT0FBTztBQUN4QyxtQkFBTyw0QkFBNEIsS0FBSyxNQUFNLE1BQU0sTUFBTSxPQUFPO0FBQUE7QUFBQSxVQUVuRSxPQUFPLE1BQU07QUFDWCxrQkFBTSxPQUFPLEtBQUssWUFBWTtBQUM5QixpQkFBSztBQUNMLGlCQUFLLGVBQWUsTUFBTSxHQUFHLEtBQUssUUFBUTtBQUFBO0FBQUEsVUFFNUMsWUFBWTtBQUNWLGtCQUFNLE9BQU8sS0FBSztBQUNsQixrQkFBTSxTQUFRLEVBQUMsS0FBSyxPQUFPLG1CQUFtQixLQUFLLE9BQU87QUFDMUQsaUJBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxXQUFVO0FBQ3BDLG9CQUFNLFNBQVMsS0FBSyxVQUFVLFFBQU87QUFDckMsa0JBQUksQ0FBQyxNQUFNLFdBQVcsS0FBSyxNQUFNLGtCQUFrQixTQUFRO0FBQ3pELG9CQUFJLFNBQVMsT0FBTSxLQUFLO0FBQ3RCLHlCQUFNLE1BQU07QUFBQTtBQUVkLG9CQUFJLFNBQVMsT0FBTSxLQUFLO0FBQ3RCLHlCQUFNLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFJbEIsbUJBQU87QUFBQTtBQUFBLFVBRVQsZ0JBQWdCO0FBQ2Qsa0JBQU0sU0FBUSxLQUFLO0FBQ25CLGtCQUFNLFlBQVksT0FBTTtBQUN4QixrQkFBTSxPQUFPLE9BQU07QUFDbkIsa0JBQU0sVUFBVSxLQUFLLElBQUksVUFBVSxRQUFRLFVBQVUsTUFBTSxVQUFVLFNBQVMsVUFBVTtBQUN4RixrQkFBTSxjQUFjLEtBQUssSUFBSSxVQUFVLEdBQUc7QUFDMUMsa0JBQU0sY0FBYyxLQUFLLElBQUksS0FBSyxtQkFBb0IsY0FBYyxNQUFRLEtBQUssbUJBQW9CLEdBQUc7QUFDeEcsa0JBQU0sZUFBZ0IsZUFBYyxlQUFlLE9BQU07QUFDekQsaUJBQUssY0FBYyxjQUFlLGVBQWUsS0FBSztBQUN0RCxpQkFBSyxjQUFjLEtBQUssY0FBYztBQUFBO0FBQUEsVUFFeEMsZUFBZSxNQUFNLE9BQU8sT0FBTyxNQUFNO0FBQ3ZDLGtCQUFNLFNBQVEsU0FBUztBQUN2QixrQkFBTSxTQUFRLEtBQUs7QUFDbkIsa0JBQU0sT0FBTyxPQUFNO0FBQ25CLGtCQUFNLGdCQUFnQixLQUFLO0FBQzNCLGtCQUFNLFFBQVEsS0FBSyxZQUFZO0FBQy9CLGtCQUFNLFVBQVUsTUFBTTtBQUN0QixrQkFBTSxVQUFVLE1BQU07QUFDdEIsa0JBQU0sb0JBQW9CLE1BQU0sY0FBYyxLQUFLLE1BQU07QUFDekQsZ0JBQUksUUFBUTtBQUNaLGdCQUFJO0FBQ0osa0JBQU0sZUFBZSxNQUFNLEtBQUs7QUFDaEMsaUJBQUssSUFBSSxHQUFHLElBQUksT0FBTyxFQUFFLEdBQUc7QUFDMUIsdUJBQVMsS0FBSyxjQUFjLEdBQUcsTUFBTTtBQUFBO0FBRXZDLGlCQUFLLElBQUksT0FBTyxJQUFJLFFBQVEsT0FBTyxLQUFLO0FBQ3RDLG9CQUFNLE1BQU0sS0FBSztBQUNqQixrQkFBSSxhQUFhO0FBQ2pCLGtCQUFJLFdBQVcsUUFBUSxLQUFLLGNBQWMsR0FBRyxNQUFNO0FBQ25ELGtCQUFJLGNBQWMsT0FBTSxrQkFBa0IsS0FBSyxNQUFNLDhCQUE4QixLQUFLLFVBQVUsR0FBRyxLQUFLO0FBQzFHLHNCQUFRO0FBQ1Isa0JBQUksUUFBTztBQUNULG9CQUFJLGNBQWMsY0FBYztBQUM5QixnQ0FBYztBQUFBO0FBRWhCLG9CQUFJLGNBQWMsZUFBZTtBQUMvQiwrQkFBYSxXQUFXO0FBQUE7QUFBQTtBQUc1QixvQkFBTSxhQUFhO0FBQUEsZ0JBQ2pCLEdBQUc7QUFBQSxnQkFDSCxHQUFHO0FBQUEsZ0JBQ0gsYUFBYTtBQUFBLGdCQUNiO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBLGdCQUNBLFNBQVMsS0FBSywwQkFBMEIsR0FBRyxJQUFJLFNBQVMsV0FBVztBQUFBO0FBRXJFLG1CQUFLLGNBQWMsS0FBSyxHQUFHLFlBQVk7QUFBQTtBQUFBO0FBQUEsVUFHM0MsdUJBQXVCO0FBQ3JCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixnQkFBSSxRQUFRO0FBQ1osaUJBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxXQUFVO0FBQ3BDLGtCQUFJLENBQUMsTUFBTSxLQUFLLFVBQVUsUUFBTyxNQUFNLEtBQUssTUFBTSxrQkFBa0IsU0FBUTtBQUMxRTtBQUFBO0FBQUE7QUFHSixtQkFBTztBQUFBO0FBQUEsVUFFVCxjQUFjLFFBQU8sTUFBTSxjQUFjO0FBQ3ZDLG1CQUFPLEtBQUssTUFBTSxrQkFBa0IsVUFDaEMsVUFBVSxLQUFLLDBCQUEwQixRQUFPLE1BQU0sU0FBUyxnQkFDL0Q7QUFBQTtBQUFBO0FBR1IsNEJBQW9CLEtBQUs7QUFDekIsNEJBQW9CLFdBQVc7QUFBQSxVQUM3QixpQkFBaUI7QUFBQSxVQUNqQixXQUFXO0FBQUEsWUFDVCxlQUFlO0FBQUEsWUFDZixjQUFjO0FBQUE7QUFBQSxVQUVoQixZQUFZO0FBQUEsWUFDVixTQUFTO0FBQUEsY0FDUCxNQUFNO0FBQUEsY0FDTixZQUFZLENBQUMsS0FBSyxLQUFLLGNBQWMsWUFBWSxlQUFlO0FBQUE7QUFBQTtBQUFBLFVBR3BFLFdBQVc7QUFBQSxVQUNYLFlBQVk7QUFBQTtBQUVkLDRCQUFvQixZQUFZO0FBQUEsVUFDOUIsYUFBYTtBQUFBLFVBQ2IsU0FBUztBQUFBLFlBQ1AsUUFBUTtBQUFBLGNBQ04sUUFBUTtBQUFBLGdCQUNOLGVBQWUsUUFBTztBQUNwQix3QkFBTSxPQUFPLE9BQU07QUFDbkIsc0JBQUksS0FBSyxPQUFPLFVBQVUsS0FBSyxTQUFTLFFBQVE7QUFDOUMsMEJBQU0sRUFBQyxRQUFRLEVBQUMsaUJBQWUsT0FBTSxPQUFPO0FBQzVDLDJCQUFPLEtBQUssT0FBTyxJQUFJLENBQUMsT0FBTyxNQUFNO0FBQ25DLDRCQUFNLE9BQU8sT0FBTSxlQUFlO0FBQ2xDLDRCQUFNLFFBQVEsS0FBSyxXQUFXLFNBQVM7QUFDdkMsNkJBQU87QUFBQSx3QkFDTCxNQUFNO0FBQUEsd0JBQ04sV0FBVyxNQUFNO0FBQUEsd0JBQ2pCLGFBQWEsTUFBTTtBQUFBLHdCQUNuQixXQUFXLE1BQU07QUFBQSx3QkFDakI7QUFBQSx3QkFDQSxRQUFRLENBQUMsT0FBTSxrQkFBa0I7QUFBQSx3QkFDakMsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUliLHlCQUFPO0FBQUE7QUFBQTtBQUFBLGNBR1gsUUFBUSxHQUFHLFlBQVksUUFBUTtBQUM3Qix1QkFBTyxNQUFNLHFCQUFxQixXQUFXO0FBQzdDLHVCQUFPLE1BQU07QUFBQTtBQUFBO0FBQUEsWUFHakIsU0FBUztBQUFBLGNBQ1AsV0FBVztBQUFBLGdCQUNULFFBQVE7QUFDTix5QkFBTztBQUFBO0FBQUEsZ0JBRVQsTUFBTSxTQUFTO0FBQ2IseUJBQU8sUUFBUSxNQUFNLEtBQUssT0FBTyxRQUFRLGFBQWEsT0FBTyxRQUFRO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUs3RSxRQUFRO0FBQUEsWUFDTixHQUFHO0FBQUEsY0FDRCxNQUFNO0FBQUEsY0FDTixZQUFZO0FBQUEsZ0JBQ1YsU0FBUztBQUFBO0FBQUEsY0FFWCxhQUFhO0FBQUEsY0FDYixNQUFNO0FBQUEsZ0JBQ0osVUFBVTtBQUFBO0FBQUEsY0FFWixhQUFhO0FBQUEsZ0JBQ1gsU0FBUztBQUFBO0FBQUEsY0FFWCxZQUFZO0FBQUE7QUFBQTtBQUFBO0FBS2xCLG9DQUE0QixtQkFBbUI7QUFBQTtBQUUvQyxzQkFBYyxLQUFLO0FBQ25CLHNCQUFjLFdBQVc7QUFBQSxVQUN2QixRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsVUFDVixlQUFlO0FBQUEsVUFDZixRQUFRO0FBQUE7QUFHVixzQ0FBOEIsa0JBQWtCO0FBQUEsVUFDOUMsaUJBQWlCLFFBQU87QUFDdEIsa0JBQU0sU0FBUyxLQUFLLFlBQVk7QUFDaEMsa0JBQU0sU0FBUyxLQUFLLFVBQVU7QUFDOUIsbUJBQU87QUFBQSxjQUNMLE9BQU8sT0FBTyxZQUFZO0FBQUEsY0FDMUIsT0FBTyxLQUFLLE9BQU8saUJBQWlCLE9BQU8sT0FBTztBQUFBO0FBQUE7QUFBQSxVQUd0RCxnQkFBZ0IsTUFBTSxNQUFNLE9BQU8sT0FBTztBQUN4QyxtQkFBTyw0QkFBNEIsS0FBSyxNQUFNLE1BQU0sTUFBTSxPQUFPO0FBQUE7QUFBQSxVQUVuRSxPQUFPLE1BQU07QUFDWCxrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLFNBQVMsS0FBSyxRQUFRO0FBQzVCLGtCQUFNLFNBQVMsS0FBSyxPQUFPO0FBQzNCLGlCQUFLLFNBQVM7QUFDZCxnQkFBSSxTQUFTLFVBQVU7QUFDckIsb0JBQU0sVUFBVSxLQUFLLDZCQUE2QjtBQUNsRCxrQkFBSSxDQUFDLEtBQUssUUFBUSxVQUFVO0FBQzFCLHdCQUFRLGNBQWM7QUFBQTtBQUV4QixvQkFBTSxhQUFhO0FBQUEsZ0JBQ2pCLE9BQU87QUFBQSxnQkFDUCxXQUFXLE9BQU8sV0FBVyxPQUFPO0FBQUEsZ0JBQ3BDO0FBQUE7QUFFRixtQkFBSyxjQUFjLE1BQU0sUUFBVyxZQUFZO0FBQUE7QUFFbEQsaUJBQUssZUFBZSxRQUFRLEdBQUcsT0FBTyxRQUFRO0FBQUE7QUFBQSxVQUVoRCxlQUFlLFFBQVEsT0FBTyxPQUFPLE1BQU07QUFDekMsa0JBQU0sUUFBUSxLQUFLLFlBQVk7QUFDL0Isa0JBQU0sU0FBUSxTQUFTO0FBQ3ZCLHFCQUFTLElBQUksT0FBTyxJQUFJLFFBQVEsT0FBTyxLQUFLO0FBQzFDLG9CQUFNLFFBQVEsT0FBTztBQUNyQixvQkFBTSxVQUFVLEtBQUssMEJBQTBCLEdBQUcsTUFBTSxTQUFTLFdBQVc7QUFDNUUsb0JBQU0sZ0JBQWdCLE1BQU0seUJBQXlCLEdBQUcsS0FBSyxVQUFVLEdBQUc7QUFDMUUsb0JBQU0sSUFBSSxTQUFRLE1BQU0sVUFBVSxjQUFjO0FBQ2hELG9CQUFNLElBQUksU0FBUSxNQUFNLFVBQVUsY0FBYztBQUNoRCxvQkFBTSxhQUFhO0FBQUEsZ0JBQ2pCO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQSxPQUFPLGNBQWM7QUFBQSxnQkFDckIsTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUFBLGdCQUN4QjtBQUFBO0FBRUYsbUJBQUssY0FBYyxPQUFPLEdBQUcsWUFBWTtBQUFBO0FBQUE7QUFBQTtBQUkvQyx3QkFBZ0IsS0FBSztBQUNyQix3QkFBZ0IsV0FBVztBQUFBLFVBQ3pCLG9CQUFvQjtBQUFBLFVBQ3BCLGlCQUFpQjtBQUFBLFVBQ2pCLFdBQVc7QUFBQSxVQUNYLFVBQVU7QUFBQSxVQUNWLFVBQVU7QUFBQSxZQUNSLE1BQU07QUFBQSxjQUNKLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFJWix3QkFBZ0IsWUFBWTtBQUFBLFVBQzFCLGFBQWE7QUFBQSxVQUNiLFFBQVE7QUFBQSxZQUNOLEdBQUc7QUFBQSxjQUNELE1BQU07QUFBQTtBQUFBO0FBQUE7QUFLWix3Q0FBZ0Msa0JBQWtCO0FBQUEsVUFDaEQsT0FBTyxNQUFNO0FBQ1gsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLEVBQUMsTUFBTSxTQUFTLE9BQU07QUFDNUIsa0JBQU0scUJBQXFCLEtBQUssTUFBTTtBQUN0QyxnQkFBSSxFQUFDLE9BQU8sVUFBUyxpQ0FBaUMsTUFBTSxRQUFRO0FBQ3BFLGlCQUFLLGFBQWE7QUFDbEIsaUJBQUssYUFBYTtBQUNsQixnQkFBSSxvQkFBb0IsT0FBTztBQUM3QixzQkFBUTtBQUNSLHNCQUFRLE9BQU87QUFBQTtBQUVqQixnQkFBSSxLQUFLLFFBQVEsVUFBVTtBQUN6QixvQkFBTSxFQUFDLFNBQVMsTUFBTSxhQUFZO0FBQ2xDLG1CQUFLLFNBQVMsS0FBSztBQUNuQixtQkFBSyxnQkFBZ0IsS0FBSztBQUMxQixtQkFBSyxhQUFhLENBQUMsQ0FBQyxTQUFTO0FBQzdCLG1CQUFLLFNBQVM7QUFDZCxvQkFBTSxVQUFVLEtBQUssNkJBQTZCO0FBQ2xELHNCQUFRLFVBQVUsS0FBSyxRQUFRO0FBQy9CLG1CQUFLLGNBQWMsTUFBTSxRQUFXO0FBQUEsZ0JBQ2xDLFVBQVUsQ0FBQztBQUFBLGdCQUNYO0FBQUEsaUJBQ0M7QUFBQTtBQUVMLGlCQUFLLGVBQWUsUUFBUSxPQUFPLE9BQU87QUFBQTtBQUFBLFVBRTVDLGNBQWM7QUFDWixrQkFBTSxFQUFDLGFBQVksS0FBSztBQUN4QixnQkFBSSxDQUFDLEtBQUssc0JBQXNCLFVBQVU7QUFDeEMsbUJBQUsscUJBQXFCLFNBQVMsV0FBVztBQUFBO0FBRWhELGtCQUFNO0FBQUE7QUFBQSxVQUVSLGVBQWUsUUFBUSxPQUFPLE9BQU8sTUFBTTtBQUN6QyxrQkFBTSxTQUFRLFNBQVM7QUFDdkIsa0JBQU0sRUFBQyxRQUFRLFFBQVEsVUFBVSxhQUFZLEtBQUs7QUFDbEQsa0JBQU0sWUFBWSxLQUFLLDBCQUEwQixPQUFPO0FBQ3hELGtCQUFNLGdCQUFnQixLQUFLLGlCQUFpQjtBQUM1QyxrQkFBTSxpQkFBaUIsS0FBSyxlQUFlLE1BQU07QUFDakQsa0JBQU0sUUFBUSxPQUFPO0FBQ3JCLGtCQUFNLFFBQVEsT0FBTztBQUNyQixrQkFBTSxFQUFDLFVBQVUsWUFBVyxLQUFLO0FBQ2pDLGtCQUFNLGVBQWUsU0FBUyxZQUFZLFdBQVcsT0FBTztBQUM1RCxrQkFBTSxlQUFlLEtBQUssTUFBTSx1QkFBdUIsVUFBUyxTQUFTO0FBQ3pFLGdCQUFJLGFBQWEsUUFBUSxLQUFLLEtBQUssVUFBVSxRQUFRO0FBQ3JELHFCQUFTLElBQUksT0FBTyxJQUFJLFFBQVEsT0FBTyxFQUFFLEdBQUc7QUFDMUMsb0JBQU0sUUFBUSxPQUFPO0FBQ3JCLG9CQUFNLFNBQVMsS0FBSyxVQUFVO0FBQzlCLG9CQUFNLGFBQWEsZUFBZSxRQUFRO0FBQzFDLG9CQUFNLFdBQVcsY0FBYyxPQUFPO0FBQ3RDLG9CQUFNLFNBQVMsV0FBVyxTQUFTLE9BQU8saUJBQWlCLE9BQU8sUUFBUTtBQUMxRSxvQkFBTSxTQUFTLFdBQVcsU0FBUyxVQUFTLFdBQVcsT0FBTyxpQkFBaUIsT0FBTyxpQkFBaUIsV0FBVyxLQUFLLFdBQVcsUUFBUSxRQUFRLFlBQVksT0FBTyxRQUFRO0FBQzdLLHlCQUFXLE9BQU8sTUFBTSxXQUFXLE1BQU0sV0FBVztBQUNwRCx5QkFBVyxPQUFPLElBQUksS0FBTSxLQUFLLElBQUksT0FBTyxTQUFTLFdBQVcsVUFBVztBQUMzRSxrQkFBSSxTQUFTO0FBQ1gsMkJBQVcsU0FBUztBQUNwQiwyQkFBVyxNQUFNLFNBQVMsS0FBSztBQUFBO0FBRWpDLGtCQUFJLGdCQUFnQjtBQUNsQiwyQkFBVyxVQUFVLGlCQUFpQixLQUFLLDBCQUEwQixHQUFHLE1BQU0sU0FBUyxXQUFXO0FBQUE7QUFFcEcsa0JBQUksQ0FBQyxjQUFjO0FBQ2pCLHFCQUFLLGNBQWMsT0FBTyxHQUFHLFlBQVk7QUFBQTtBQUUzQywyQkFBYTtBQUFBO0FBRWYsaUJBQUssb0JBQW9CLGVBQWUsTUFBTTtBQUFBO0FBQUEsVUFFaEQsaUJBQWlCO0FBQ2Ysa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLE9BQU8sS0FBSyxRQUFRO0FBQzFCLGdCQUFJLENBQUMsS0FBSyxRQUFRLFVBQVU7QUFDMUIsa0JBQUksTUFBTTtBQUNWLHVCQUFTLElBQUksS0FBSyxTQUFTLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUN6QyxzQkFBTSxLQUFLLElBQUksS0FBSyxLQUFLLEdBQUcsS0FBSyxLQUFLLDBCQUEwQixNQUFNO0FBQUE7QUFFeEUscUJBQU8sTUFBTSxLQUFLO0FBQUE7QUFFcEIsa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGtCQUFNLFNBQVMsUUFBUSxXQUFXLFFBQVEsUUFBUSxlQUFlO0FBQ2pFLGdCQUFJLENBQUMsS0FBSyxRQUFRO0FBQ2hCLHFCQUFPO0FBQUE7QUFFVCxrQkFBTSxhQUFhLEtBQUssR0FBRyxLQUFLLEtBQUssMEJBQTBCO0FBQy9ELGtCQUFNLFlBQVksS0FBSyxLQUFLLFNBQVMsR0FBRyxLQUFLLEtBQUssMEJBQTBCLEtBQUssU0FBUztBQUMxRixtQkFBTyxLQUFLLElBQUksUUFBUSxZQUFZLGFBQWE7QUFBQTtBQUFBO0FBR3JELDBCQUFrQixLQUFLO0FBQ3ZCLDBCQUFrQixXQUFXO0FBQUEsVUFDM0Isb0JBQW9CO0FBQUEsVUFDcEIsaUJBQWlCO0FBQUEsVUFDakIsVUFBVTtBQUFBLFVBQ1YsTUFBTTtBQUFBO0FBRVIsMEJBQWtCLFlBQVk7QUFBQSxVQUM1QixhQUFhO0FBQUEsWUFDWCxNQUFNO0FBQUE7QUFBQSxVQUVSLFNBQVM7QUFBQSxZQUNQLFNBQVM7QUFBQSxjQUNQLFdBQVc7QUFBQSxnQkFDVCxRQUFRO0FBQ04seUJBQU87QUFBQTtBQUFBLGdCQUVULE1BQU0sTUFBTTtBQUNWLHlCQUFPLE1BQU0sS0FBSyxRQUFRLE9BQU8sS0FBSyxpQkFBaUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBSy9ELFFBQVE7QUFBQSxZQUNOLEdBQUc7QUFBQSxjQUNELE1BQU07QUFBQTtBQUFBLFlBRVIsR0FBRztBQUFBLGNBQ0QsTUFBTTtBQUFBO0FBQUE7QUFBQTtBQUtaLFlBQUksY0FBMkIsdUJBQU8sT0FBTztBQUFBLFVBQzdDLFdBQVc7QUFBQSxVQUNYO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBO0FBR0EseUJBQWlCLEtBQUssU0FBUyxVQUFVO0FBQ3ZDLGdCQUFNLEVBQUMsWUFBWSxhQUFhLEdBQUcsR0FBRyxhQUFhLGdCQUFlO0FBQ2xFLGNBQUksY0FBYyxjQUFjO0FBQ2hDLGNBQUk7QUFDSixjQUFJLElBQUksR0FBRyxHQUFHLGFBQWEsYUFBYSxhQUFhLFdBQVc7QUFDaEUsY0FBSSxjQUFjLGFBQWE7QUFDN0IsMEJBQWMsY0FBYztBQUM1QixnQkFBSSxJQUFJLEdBQUcsR0FBRyxhQUFhLFdBQVcsYUFBYSxhQUFhLGFBQWE7QUFBQSxpQkFDeEU7QUFDTCxnQkFBSSxJQUFJLEdBQUcsR0FBRyxhQUFhLFdBQVcsU0FBUyxhQUFhO0FBQUE7QUFFOUQsY0FBSTtBQUNKLGNBQUk7QUFBQTtBQUVOLGlDQUF5QixPQUFPO0FBQzlCLGlCQUFPLGtCQUFrQixPQUFPLENBQUMsY0FBYyxZQUFZLGNBQWM7QUFBQTtBQUUzRSxxQ0FBNkIsS0FBSyxhQUFhLGFBQWEsWUFBWTtBQUN0RSxnQkFBTSxJQUFJLGdCQUFnQixJQUFJLFFBQVE7QUFDdEMsZ0JBQU0sZ0JBQWlCLGVBQWMsZUFBZTtBQUNwRCxnQkFBTSxhQUFhLEtBQUssSUFBSSxlQUFlLGFBQWEsY0FBYztBQUN0RSxnQkFBTSxvQkFBb0IsQ0FBQyxRQUFRO0FBQ2pDLGtCQUFNLGdCQUFpQixlQUFjLEtBQUssSUFBSSxlQUFlLFFBQVEsYUFBYTtBQUNsRixtQkFBTyxZQUFZLEtBQUssR0FBRyxLQUFLLElBQUksZUFBZTtBQUFBO0FBRXJELGlCQUFPO0FBQUEsWUFDTCxZQUFZLGtCQUFrQixFQUFFO0FBQUEsWUFDaEMsVUFBVSxrQkFBa0IsRUFBRTtBQUFBLFlBQzlCLFlBQVksWUFBWSxFQUFFLFlBQVksR0FBRztBQUFBLFlBQ3pDLFVBQVUsWUFBWSxFQUFFLFVBQVUsR0FBRztBQUFBO0FBQUE7QUFHekMsNEJBQW9CLEdBQUcsT0FBTyxHQUFHLEdBQUc7QUFDbEMsaUJBQU87QUFBQSxZQUNMLEdBQUcsSUFBSSxJQUFJLEtBQUssSUFBSTtBQUFBLFlBQ3BCLEdBQUcsSUFBSSxJQUFJLEtBQUssSUFBSTtBQUFBO0FBQUE7QUFHeEIseUJBQWlCLEtBQUssU0FBUyxRQUFRLFNBQVMsS0FBSyxVQUFVO0FBQzdELGdCQUFNLEVBQUMsR0FBRyxHQUFHLFlBQVksT0FBTyxhQUFhLGFBQWEsV0FBVTtBQUNwRSxnQkFBTSxjQUFjLEtBQUssSUFBSSxRQUFRLGNBQWMsVUFBVSxTQUFTLGFBQWE7QUFDbkYsZ0JBQU0sY0FBYyxTQUFTLElBQUksU0FBUyxVQUFVLFNBQVMsY0FBYztBQUMzRSxjQUFJLGdCQUFnQjtBQUNwQixnQkFBTSxTQUFRLE1BQU07QUFDcEIsY0FBSSxTQUFTO0FBQ1gsa0JBQU0sdUJBQXVCLFNBQVMsSUFBSSxTQUFTLFVBQVU7QUFDN0Qsa0JBQU0sdUJBQXVCLGNBQWMsSUFBSSxjQUFjLFVBQVU7QUFDdkUsa0JBQU0scUJBQXNCLHdCQUF1Qix3QkFBd0I7QUFDM0Usa0JBQU0sZ0JBQWdCLHVCQUF1QixJQUFLLFNBQVEscUJBQXVCLHNCQUFxQixXQUFXO0FBQ2pILDRCQUFpQixVQUFRLGlCQUFpQjtBQUFBO0FBRTVDLGdCQUFNLE9BQU8sS0FBSyxJQUFJLE1BQU8sU0FBUSxjQUFjLFNBQVMsTUFBTTtBQUNsRSxnQkFBTSxjQUFlLFVBQVEsUUFBUTtBQUNyQyxnQkFBTSxhQUFhLFFBQVEsY0FBYztBQUN6QyxnQkFBTSxXQUFXLE1BQU0sY0FBYztBQUNyQyxnQkFBTSxFQUFDLFlBQVksVUFBVSxZQUFZLGFBQVksb0JBQW9CLFNBQVMsYUFBYSxhQUFhLFdBQVc7QUFDdkgsZ0JBQU0sMkJBQTJCLGNBQWM7QUFDL0MsZ0JBQU0seUJBQXlCLGNBQWM7QUFDN0MsZ0JBQU0sMEJBQTBCLGFBQWEsYUFBYTtBQUMxRCxnQkFBTSx3QkFBd0IsV0FBVyxXQUFXO0FBQ3BELGdCQUFNLDJCQUEyQixjQUFjO0FBQy9DLGdCQUFNLHlCQUF5QixjQUFjO0FBQzdDLGdCQUFNLDBCQUEwQixhQUFhLGFBQWE7QUFDMUQsZ0JBQU0sd0JBQXdCLFdBQVcsV0FBVztBQUNwRCxjQUFJO0FBQ0osY0FBSSxVQUFVO0FBQ1osZ0JBQUksSUFBSSxHQUFHLEdBQUcsYUFBYSx5QkFBeUI7QUFDcEQsZ0JBQUksV0FBVyxHQUFHO0FBQ2hCLG9CQUFNLFVBQVUsV0FBVyx3QkFBd0IsdUJBQXVCLEdBQUc7QUFDN0Usa0JBQUksSUFBSSxRQUFRLEdBQUcsUUFBUSxHQUFHLFVBQVUsdUJBQXVCLFdBQVc7QUFBQTtBQUU1RSxrQkFBTSxLQUFLLFdBQVcsd0JBQXdCLFVBQVUsR0FBRztBQUMzRCxnQkFBSSxPQUFPLEdBQUcsR0FBRyxHQUFHO0FBQ3BCLGdCQUFJLFdBQVcsR0FBRztBQUNoQixvQkFBTSxVQUFVLFdBQVcsd0JBQXdCLHVCQUF1QixHQUFHO0FBQzdFLGtCQUFJLElBQUksUUFBUSxHQUFHLFFBQVEsR0FBRyxVQUFVLFdBQVcsU0FBUyx3QkFBd0IsS0FBSztBQUFBO0FBRTNGLGdCQUFJLElBQUksR0FBRyxHQUFHLGFBQWEsV0FBWSxXQUFXLGFBQWMsYUFBYyxhQUFhLGFBQWM7QUFDekcsZ0JBQUksYUFBYSxHQUFHO0FBQ2xCLG9CQUFNLFVBQVUsV0FBVywwQkFBMEIseUJBQXlCLEdBQUc7QUFDakYsa0JBQUksSUFBSSxRQUFRLEdBQUcsUUFBUSxHQUFHLFlBQVksMEJBQTBCLEtBQUssSUFBSSxhQUFhO0FBQUE7QUFFNUYsa0JBQU0sS0FBSyxXQUFXLDBCQUEwQixZQUFZLEdBQUc7QUFDL0QsZ0JBQUksT0FBTyxHQUFHLEdBQUcsR0FBRztBQUNwQixnQkFBSSxhQUFhLEdBQUc7QUFDbEIsb0JBQU0sVUFBVSxXQUFXLDBCQUEwQix5QkFBeUIsR0FBRztBQUNqRixrQkFBSSxJQUFJLFFBQVEsR0FBRyxRQUFRLEdBQUcsWUFBWSxhQUFhLFNBQVM7QUFBQTtBQUFBLGlCQUU3RDtBQUNMLGdCQUFJLE9BQU8sR0FBRztBQUNkLGtCQUFNLGNBQWMsS0FBSyxJQUFJLDJCQUEyQixjQUFjO0FBQ3RFLGtCQUFNLGNBQWMsS0FBSyxJQUFJLDJCQUEyQixjQUFjO0FBQ3RFLGdCQUFJLE9BQU8sYUFBYTtBQUN4QixrQkFBTSxZQUFZLEtBQUssSUFBSSx5QkFBeUIsY0FBYztBQUNsRSxrQkFBTSxZQUFZLEtBQUssSUFBSSx5QkFBeUIsY0FBYztBQUNsRSxnQkFBSSxPQUFPLFdBQVc7QUFBQTtBQUV4QixjQUFJO0FBQUE7QUFFTix5QkFBaUIsS0FBSyxTQUFTLFFBQVEsU0FBUyxVQUFVO0FBQ3hELGdCQUFNLEVBQUMsYUFBYSxZQUFZLGtCQUFpQjtBQUNqRCxjQUFJLFdBQVcsUUFBUTtBQUN2QixjQUFJLGFBQWE7QUFDZixvQkFBUSxLQUFLLFNBQVMsUUFBUSxTQUFTLGFBQWEsS0FBSztBQUN6RCxxQkFBUyxJQUFJLEdBQUcsSUFBSSxhQUFhLEVBQUUsR0FBRztBQUNwQyxrQkFBSTtBQUFBO0FBRU4sZ0JBQUksQ0FBQyxNQUFNLGdCQUFnQjtBQUN6Qix5QkFBVyxhQUFhLGdCQUFnQjtBQUN4QyxrQkFBSSxnQkFBZ0IsUUFBUSxHQUFHO0FBQzdCLDRCQUFZO0FBQUE7QUFBQTtBQUFBO0FBSWxCLGtCQUFRLEtBQUssU0FBUyxRQUFRLFNBQVMsVUFBVTtBQUNqRCxjQUFJO0FBQ0osaUJBQU87QUFBQTtBQUVULHVDQUErQixLQUFLLFNBQVMsT0FBTztBQUNsRCxnQkFBTSxFQUFDLEdBQUcsR0FBRyxZQUFZLGFBQWEsZ0JBQWU7QUFDckQsZ0JBQU0sY0FBYyxLQUFLLElBQUksUUFBUSxjQUFjLGFBQWE7QUFDaEUsZ0JBQU0sY0FBYyxRQUFRLGNBQWM7QUFDMUMsY0FBSTtBQUNKLGNBQUksT0FBTztBQUNULG9CQUFRLEtBQUssU0FBUyxhQUFhO0FBQUE7QUFFckMsY0FBSTtBQUNKLGNBQUksSUFBSSxHQUFHLEdBQUcsYUFBYSxhQUFhLEtBQUssWUFBWTtBQUN6RCxlQUFLLElBQUksR0FBRyxJQUFJLGFBQWEsRUFBRSxHQUFHO0FBQ2hDLGdCQUFJO0FBQUE7QUFFTixjQUFJO0FBQ0osY0FBSSxJQUFJLEdBQUcsR0FBRyxhQUFhLFlBQVksYUFBYTtBQUNwRCxlQUFLLElBQUksR0FBRyxJQUFJLGFBQWEsRUFBRSxHQUFHO0FBQ2hDLGdCQUFJO0FBQUE7QUFBQTtBQUdSLDRCQUFvQixLQUFLLFNBQVMsUUFBUSxTQUFTLFVBQVUsVUFBVTtBQUNyRSxnQkFBTSxFQUFDLFlBQVc7QUFDbEIsZ0JBQU0sRUFBQyxhQUFhLG9CQUFtQjtBQUN2QyxnQkFBTSxRQUFRLFFBQVEsZ0JBQWdCO0FBQ3RDLGNBQUksQ0FBQyxhQUFhO0FBQ2hCO0FBQUE7QUFFRixjQUFJLE9BQU87QUFDVCxnQkFBSSxZQUFZLGNBQWM7QUFDOUIsZ0JBQUksV0FBVyxtQkFBbUI7QUFBQSxpQkFDN0I7QUFDTCxnQkFBSSxZQUFZO0FBQ2hCLGdCQUFJLFdBQVcsbUJBQW1CO0FBQUE7QUFFcEMsY0FBSSxRQUFRLGFBQWE7QUFDdkIsa0NBQXNCLEtBQUssU0FBUztBQUFBO0FBRXRDLGNBQUksT0FBTztBQUNULG9CQUFRLEtBQUssU0FBUztBQUFBO0FBRXhCLGtCQUFRLEtBQUssU0FBUyxRQUFRLFNBQVMsVUFBVTtBQUNqRCxjQUFJO0FBQUE7QUFFTixpQ0FBeUIsU0FBUTtBQUFBLFVBQy9CLFlBQVksS0FBSztBQUNmO0FBQ0EsaUJBQUssVUFBVTtBQUNmLGlCQUFLLGdCQUFnQjtBQUNyQixpQkFBSyxhQUFhO0FBQ2xCLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssY0FBYztBQUNuQixpQkFBSyxjQUFjO0FBQ25CLGlCQUFLLGNBQWM7QUFDbkIsaUJBQUssY0FBYztBQUNuQixnQkFBSSxLQUFLO0FBQ1AscUJBQU8sT0FBTyxNQUFNO0FBQUE7QUFBQTtBQUFBLFVBR3hCLFFBQVEsUUFBUSxRQUFRLGtCQUFrQjtBQUN4QyxrQkFBTSxRQUFRLEtBQUssU0FBUyxDQUFDLEtBQUssTUFBTTtBQUN4QyxrQkFBTSxFQUFDLE9BQU8sd0JBQVksa0JBQWtCLE9BQU8sRUFBQyxHQUFHLFFBQVEsR0FBRztBQUNsRSxrQkFBTSxFQUFDLFlBQVksVUFBVSxhQUFhLGFBQWEsa0JBQWlCLEtBQUssU0FBUztBQUFBLGNBQ3BGO0FBQUEsY0FDQTtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsY0FDQTtBQUFBLGVBQ0M7QUFDSCxrQkFBTSxVQUFVLEtBQUssUUFBUSxVQUFVO0FBQ3ZDLGtCQUFNLGlCQUFpQixlQUFlLGVBQWUsV0FBVztBQUNoRSxrQkFBTSxnQkFBZ0Isa0JBQWtCLE9BQU8sY0FBYyxPQUFPLFlBQVk7QUFDaEYsa0JBQU0sZUFBZSxXQUFXLFdBQVUsY0FBYyxTQUFTLGNBQWM7QUFDL0UsbUJBQVEsaUJBQWlCO0FBQUE7QUFBQSxVQUUzQixlQUFlLGtCQUFrQjtBQUMvQixrQkFBTSxFQUFDLEdBQUcsR0FBRyxZQUFZLFVBQVUsYUFBYSxnQkFBZSxLQUFLLFNBQVM7QUFBQSxjQUMzRTtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsY0FDQTtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsY0FDQTtBQUFBLGVBQ0M7QUFDSCxrQkFBTSxFQUFDLFFBQVEsWUFBVyxLQUFLO0FBQy9CLGtCQUFNLFlBQWEsY0FBYSxZQUFZO0FBQzVDLGtCQUFNLGFBQWMsZUFBYyxjQUFjLFVBQVUsVUFBVTtBQUNwRSxtQkFBTztBQUFBLGNBQ0wsR0FBRyxJQUFJLEtBQUssSUFBSSxhQUFhO0FBQUEsY0FDN0IsR0FBRyxJQUFJLEtBQUssSUFBSSxhQUFhO0FBQUE7QUFBQTtBQUFBLFVBR2pDLGdCQUFnQixrQkFBa0I7QUFDaEMsbUJBQU8sS0FBSyxlQUFlO0FBQUE7QUFBQSxVQUU3QixLQUFLLEtBQUs7QUFDUixrQkFBTSxFQUFDLFNBQVMsa0JBQWlCO0FBQ2pDLGtCQUFNLFNBQVUsU0FBUSxVQUFVLEtBQUs7QUFDdkMsa0JBQU0sVUFBVyxTQUFRLFdBQVcsS0FBSztBQUN6QyxrQkFBTSxXQUFXLFFBQVE7QUFDekIsaUJBQUssY0FBZSxRQUFRLGdCQUFnQixVQUFXLE9BQU87QUFDOUQsaUJBQUssY0FBYyxnQkFBZ0IsTUFBTSxLQUFLLE1BQU0sZ0JBQWdCLE9BQU87QUFDM0UsZ0JBQUksa0JBQWtCLEtBQUssS0FBSyxjQUFjLEtBQUssS0FBSyxjQUFjLEdBQUc7QUFDdkU7QUFBQTtBQUVGLGdCQUFJO0FBQ0osZ0JBQUksZUFBZTtBQUNuQixnQkFBSSxRQUFRO0FBQ1YsNkJBQWUsU0FBUztBQUN4QixvQkFBTSxZQUFhLE1BQUssYUFBYSxLQUFLLFlBQVk7QUFDdEQsa0JBQUksVUFBVSxLQUFLLElBQUksYUFBYSxjQUFjLEtBQUssSUFBSSxhQUFhO0FBQ3hFLGtCQUFJLEtBQUssaUJBQWlCLElBQUk7QUFDNUIsK0JBQWU7QUFBQTtBQUFBO0FBR25CLGdCQUFJLFlBQVksUUFBUTtBQUN4QixnQkFBSSxjQUFjLFFBQVE7QUFDMUIsa0JBQU0sV0FBVyxRQUFRLEtBQUssTUFBTSxjQUFjLFNBQVM7QUFDM0QsdUJBQVcsS0FBSyxNQUFNLGNBQWMsU0FBUyxVQUFVO0FBQ3ZELGdCQUFJO0FBQUE7QUFBQTtBQUdSLG1CQUFXLEtBQUs7QUFDaEIsbUJBQVcsV0FBVztBQUFBLFVBQ3BCLGFBQWE7QUFBQSxVQUNiLGFBQWE7QUFBQSxVQUNiLGlCQUFpQjtBQUFBLFVBQ2pCLGNBQWM7QUFBQSxVQUNkLGFBQWE7QUFBQSxVQUNiLFFBQVE7QUFBQSxVQUNSLFNBQVM7QUFBQSxVQUNULE9BQU87QUFBQSxVQUNQLFVBQVU7QUFBQTtBQUVaLG1CQUFXLGdCQUFnQjtBQUFBLFVBQ3pCLGlCQUFpQjtBQUFBO0FBR25CLDBCQUFrQixLQUFLLFNBQVMsUUFBUSxTQUFTO0FBQy9DLGNBQUksVUFBVSxlQUFlLE1BQU0sZ0JBQWdCLFFBQVE7QUFDM0QsY0FBSSxZQUFZLGVBQWUsTUFBTSxZQUFZLFFBQVE7QUFDekQsY0FBSSxpQkFBaUIsZUFBZSxNQUFNLGtCQUFrQixRQUFRO0FBQ3BFLGNBQUksV0FBVyxlQUFlLE1BQU0saUJBQWlCLFFBQVE7QUFDN0QsY0FBSSxZQUFZLGVBQWUsTUFBTSxhQUFhLFFBQVE7QUFDMUQsY0FBSSxjQUFjLGVBQWUsTUFBTSxhQUFhLFFBQVE7QUFBQTtBQUU5RCx3QkFBZ0IsS0FBSyxVQUFVLFFBQVE7QUFDckMsY0FBSSxPQUFPLE9BQU8sR0FBRyxPQUFPO0FBQUE7QUFFOUIsK0JBQXVCLFNBQVM7QUFDOUIsY0FBSSxRQUFRLFNBQVM7QUFDbkIsbUJBQU87QUFBQTtBQUVULGNBQUksUUFBUSxXQUFXLFFBQVEsMkJBQTJCLFlBQVk7QUFDcEUsbUJBQU87QUFBQTtBQUVULGlCQUFPO0FBQUE7QUFFVCwwQkFBa0IsUUFBUSxTQUFTLFNBQVMsSUFBSTtBQUM5QyxnQkFBTSxRQUFRLE9BQU87QUFDckIsZ0JBQU0sRUFBQyxPQUFPLGNBQWMsR0FBRyxLQUFLLFlBQVksUUFBUSxNQUFLO0FBQzdELGdCQUFNLEVBQUMsT0FBTyxjQUFjLEtBQUssZUFBYztBQUMvQyxnQkFBTSxRQUFRLEtBQUssSUFBSSxhQUFhO0FBQ3BDLGdCQUFNLE1BQU0sS0FBSyxJQUFJLFdBQVc7QUFDaEMsZ0JBQU0sVUFBVSxjQUFjLGdCQUFnQixZQUFZLGdCQUFnQixjQUFjLGNBQWMsWUFBWTtBQUNsSCxpQkFBTztBQUFBLFlBQ0w7QUFBQSxZQUNBO0FBQUEsWUFDQSxNQUFNLFFBQVE7QUFBQSxZQUNkLE1BQU0sTUFBTSxTQUFTLENBQUMsVUFBVSxRQUFRLE1BQU0sUUFBUSxNQUFNO0FBQUE7QUFBQTtBQUdoRSw2QkFBcUIsS0FBSyxNQUFNLFNBQVMsUUFBUTtBQUMvQyxnQkFBTSxFQUFDLFFBQVEsWUFBVztBQUMxQixnQkFBTSxFQUFDLE9BQU8sT0FBTyxNQUFNLFNBQVEsU0FBUyxRQUFRLFNBQVM7QUFDN0QsZ0JBQU0sYUFBYSxjQUFjO0FBQ2pDLGNBQUksRUFBQyxjQUFPLE1BQU0sWUFBVyxVQUFVO0FBQ3ZDLGNBQUksR0FBRyxPQUFPO0FBQ2QsZUFBSyxJQUFJLEdBQUcsS0FBSyxNQUFNLEVBQUUsR0FBRztBQUMxQixvQkFBUSxPQUFRLFNBQVMsV0FBVSxPQUFPLElBQUksTUFBTTtBQUNwRCxnQkFBSSxNQUFNLE1BQU07QUFDZDtBQUFBLHVCQUNTLE9BQU07QUFDZixrQkFBSSxPQUFPLE1BQU0sR0FBRyxNQUFNO0FBQzFCLHNCQUFPO0FBQUEsbUJBQ0Y7QUFDTCx5QkFBVyxLQUFLLE1BQU0sT0FBTyxTQUFTLFFBQVE7QUFBQTtBQUVoRCxtQkFBTztBQUFBO0FBRVQsY0FBSSxNQUFNO0FBQ1Isb0JBQVEsT0FBUSxTQUFTLFdBQVUsT0FBTyxNQUFNO0FBQ2hELHVCQUFXLEtBQUssTUFBTSxPQUFPLFNBQVMsUUFBUTtBQUFBO0FBRWhELGlCQUFPLENBQUMsQ0FBQztBQUFBO0FBRVgsaUNBQXlCLEtBQUssTUFBTSxTQUFTLFFBQVE7QUFDbkQsZ0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGdCQUFNLEVBQUMsT0FBTyxPQUFPLFNBQVEsU0FBUyxRQUFRLFNBQVM7QUFDdkQsZ0JBQU0sRUFBQyxjQUFPLE1BQU0sWUFBVyxVQUFVO0FBQ3pDLGNBQUksT0FBTztBQUNYLGNBQUksU0FBUztBQUNiLGNBQUksR0FBRyxPQUFPLE9BQU8sTUFBTSxNQUFNO0FBQ2pDLGdCQUFNLGFBQWEsQ0FBQyxXQUFXLFNBQVMsV0FBVSxPQUFPLFNBQVEsV0FBVTtBQUMzRSxnQkFBTSxRQUFRLE1BQU07QUFDbEIsZ0JBQUksU0FBUyxNQUFNO0FBQ2pCLGtCQUFJLE9BQU8sTUFBTTtBQUNqQixrQkFBSSxPQUFPLE1BQU07QUFDakIsa0JBQUksT0FBTyxNQUFNO0FBQUE7QUFBQTtBQUdyQixjQUFJLE9BQU07QUFDUixvQkFBUSxPQUFPLFdBQVc7QUFDMUIsZ0JBQUksT0FBTyxNQUFNLEdBQUcsTUFBTTtBQUFBO0FBRTVCLGVBQUssSUFBSSxHQUFHLEtBQUssTUFBTSxFQUFFLEdBQUc7QUFDMUIsb0JBQVEsT0FBTyxXQUFXO0FBQzFCLGdCQUFJLE1BQU0sTUFBTTtBQUNkO0FBQUE7QUFFRixrQkFBTSxJQUFJLE1BQU07QUFDaEIsa0JBQU0sSUFBSSxNQUFNO0FBQ2hCLGtCQUFNLFNBQVMsSUFBSTtBQUNuQixnQkFBSSxXQUFXLE9BQU87QUFDcEIsa0JBQUksSUFBSSxNQUFNO0FBQ1osdUJBQU87QUFBQSx5QkFDRSxJQUFJLE1BQU07QUFDbkIsdUJBQU87QUFBQTtBQUVULHFCQUFRLFVBQVMsT0FBTyxLQUFLLEVBQUU7QUFBQSxtQkFDMUI7QUFDTDtBQUNBLGtCQUFJLE9BQU8sR0FBRztBQUNkLHNCQUFRO0FBQ1IsdUJBQVM7QUFDVCxxQkFBTyxPQUFPO0FBQUE7QUFFaEIsb0JBQVE7QUFBQTtBQUVWO0FBQUE7QUFFRixtQ0FBMkIsTUFBTTtBQUMvQixnQkFBTSxPQUFPLEtBQUs7QUFDbEIsZ0JBQU0sYUFBYSxLQUFLLGNBQWMsS0FBSyxXQUFXO0FBQ3RELGdCQUFNLGNBQWMsQ0FBQyxLQUFLLGNBQWMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxLQUFLLFdBQVcsS0FBSywyQkFBMkIsY0FBYyxDQUFDLEtBQUssV0FBVyxDQUFDO0FBQ3hJLGlCQUFPLGNBQWMsa0JBQWtCO0FBQUE7QUFFekMseUNBQWlDLFNBQVM7QUFDeEMsY0FBSSxRQUFRLFNBQVM7QUFDbkIsbUJBQU87QUFBQTtBQUVULGNBQUksUUFBUSxXQUFXLFFBQVEsMkJBQTJCLFlBQVk7QUFDcEUsbUJBQU87QUFBQTtBQUVULGlCQUFPO0FBQUE7QUFFVCxxQ0FBNkIsS0FBSyxNQUFNLE9BQU8sT0FBTztBQUNwRCxjQUFJLE9BQU8sS0FBSztBQUNoQixjQUFJLENBQUMsTUFBTTtBQUNULG1CQUFPLEtBQUssUUFBUSxJQUFJO0FBQ3hCLGdCQUFJLEtBQUssS0FBSyxNQUFNLE9BQU8sUUFBUTtBQUNqQyxtQkFBSztBQUFBO0FBQUE7QUFHVCxtQkFBUyxLQUFLLEtBQUs7QUFDbkIsY0FBSSxPQUFPO0FBQUE7QUFFYixrQ0FBMEIsS0FBSyxNQUFNLE9BQU8sT0FBTztBQUNqRCxnQkFBTSxFQUFDLFVBQVUsWUFBVztBQUM1QixnQkFBTSxnQkFBZ0Isa0JBQWtCO0FBQ3hDLHFCQUFXLFdBQVcsVUFBVTtBQUM5QixxQkFBUyxLQUFLLFNBQVMsUUFBUTtBQUMvQixnQkFBSTtBQUNKLGdCQUFJLGNBQWMsS0FBSyxNQUFNLFNBQVMsRUFBQyxPQUFPLEtBQUssUUFBUSxRQUFRLE1BQUs7QUFDdEUsa0JBQUk7QUFBQTtBQUVOLGdCQUFJO0FBQUE7QUFBQTtBQUdSLGNBQU0sWUFBWSxPQUFPLFdBQVc7QUFDcEMsc0JBQWMsS0FBSyxNQUFNLE9BQU8sT0FBTztBQUNyQyxjQUFJLGFBQWEsQ0FBQyxLQUFLLFFBQVEsU0FBUztBQUN0QyxnQ0FBb0IsS0FBSyxNQUFNLE9BQU87QUFBQSxpQkFDakM7QUFDTCw2QkFBaUIsS0FBSyxNQUFNLE9BQU87QUFBQTtBQUFBO0FBR3ZDLGtDQUEwQixTQUFRO0FBQUEsVUFDaEMsWUFBWSxLQUFLO0FBQ2Y7QUFDQSxpQkFBSyxXQUFXO0FBQ2hCLGlCQUFLLFVBQVU7QUFDZixpQkFBSyxTQUFTO0FBQ2QsaUJBQUssUUFBUTtBQUNiLGlCQUFLLFlBQVk7QUFDakIsaUJBQUssUUFBUTtBQUNiLGlCQUFLLFVBQVU7QUFDZixpQkFBSyxZQUFZO0FBQ2pCLGlCQUFLLGFBQWE7QUFDbEIsaUJBQUssaUJBQWlCO0FBQ3RCLGlCQUFLLGdCQUFnQjtBQUNyQixnQkFBSSxLQUFLO0FBQ1AscUJBQU8sT0FBTyxNQUFNO0FBQUE7QUFBQTtBQUFBLFVBR3hCLG9CQUFvQixXQUFXLFdBQVc7QUFDeEMsa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGdCQUFLLFNBQVEsV0FBVyxRQUFRLDJCQUEyQixlQUFlLENBQUMsUUFBUSxXQUFXLENBQUMsS0FBSyxnQkFBZ0I7QUFDbEgsb0JBQU0sT0FBTyxRQUFRLFdBQVcsS0FBSyxRQUFRLEtBQUs7QUFDbEQseUNBQTJCLEtBQUssU0FBUyxTQUFTLFdBQVcsTUFBTTtBQUNuRSxtQkFBSyxpQkFBaUI7QUFBQTtBQUFBO0FBQUEsY0FHdEIsT0FBTyxRQUFRO0FBQ2pCLGlCQUFLLFVBQVU7QUFDZixtQkFBTyxLQUFLO0FBQ1osbUJBQU8sS0FBSztBQUNaLGlCQUFLLGlCQUFpQjtBQUFBO0FBQUEsY0FFcEIsU0FBUztBQUNYLG1CQUFPLEtBQUs7QUFBQTtBQUFBLGNBRVYsV0FBVztBQUNiLG1CQUFPLEtBQUssYUFBYyxNQUFLLFlBQVksaUJBQWlCLE1BQU0sS0FBSyxRQUFRO0FBQUE7QUFBQSxVQUVqRixRQUFRO0FBQ04sa0JBQU0sV0FBVyxLQUFLO0FBQ3RCLGtCQUFNLFNBQVMsS0FBSztBQUNwQixtQkFBTyxTQUFTLFVBQVUsT0FBTyxTQUFTLEdBQUc7QUFBQTtBQUFBLFVBRS9DLE9BQU87QUFDTCxrQkFBTSxXQUFXLEtBQUs7QUFDdEIsa0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGtCQUFNLFFBQVEsU0FBUztBQUN2QixtQkFBTyxTQUFTLE9BQU8sU0FBUyxRQUFRLEdBQUc7QUFBQTtBQUFBLFVBRTdDLFlBQVksT0FBTyxVQUFVO0FBQzNCLGtCQUFNLFVBQVUsS0FBSztBQUNyQixrQkFBTSxRQUFRLE1BQU07QUFDcEIsa0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGtCQUFNLFdBQVcsZUFBZSxNQUFNLEVBQUMsVUFBVSxPQUFPLE9BQU8sS0FBSztBQUNwRSxnQkFBSSxDQUFDLFNBQVMsUUFBUTtBQUNwQjtBQUFBO0FBRUYsa0JBQU0sU0FBUztBQUNmLGtCQUFNLGVBQWUsd0JBQXdCO0FBQzdDLGdCQUFJLEdBQUc7QUFDUCxpQkFBSyxJQUFJLEdBQUcsT0FBTyxTQUFTLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUNqRCxvQkFBTSxFQUFDLE9BQU8sUUFBTyxTQUFTO0FBQzlCLG9CQUFNLEtBQUssT0FBTztBQUNsQixvQkFBTSxLQUFLLE9BQU87QUFDbEIsa0JBQUksT0FBTyxJQUFJO0FBQ2IsdUJBQU8sS0FBSztBQUNaO0FBQUE7QUFFRixvQkFBTSxJQUFJLEtBQUssSUFBSyxTQUFRLEdBQUcsYUFBYyxJQUFHLFlBQVksR0FBRztBQUMvRCxvQkFBTSxlQUFlLGFBQWEsSUFBSSxJQUFJLEdBQUcsUUFBUTtBQUNyRCwyQkFBYSxZQUFZLE1BQU07QUFDL0IscUJBQU8sS0FBSztBQUFBO0FBRWQsbUJBQU8sT0FBTyxXQUFXLElBQUksT0FBTyxLQUFLO0FBQUE7QUFBQSxVQUUzQyxZQUFZLEtBQUssU0FBUyxRQUFRO0FBQ2hDLGtCQUFNLGdCQUFnQixrQkFBa0I7QUFDeEMsbUJBQU8sY0FBYyxLQUFLLE1BQU0sU0FBUztBQUFBO0FBQUEsVUFFM0MsS0FBSyxLQUFLLE9BQU8sT0FBTztBQUN0QixrQkFBTSxXQUFXLEtBQUs7QUFDdEIsa0JBQU0sZ0JBQWdCLGtCQUFrQjtBQUN4QyxnQkFBSSxPQUFPLEtBQUs7QUFDaEIsb0JBQVEsU0FBUztBQUNqQixvQkFBUSxTQUFVLEtBQUssT0FBTyxTQUFTO0FBQ3ZDLHVCQUFXLFdBQVcsVUFBVTtBQUM5QixzQkFBUSxjQUFjLEtBQUssTUFBTSxTQUFTLEVBQUMsT0FBTyxLQUFLLFFBQVEsUUFBUTtBQUFBO0FBRXpFLG1CQUFPLENBQUMsQ0FBQztBQUFBO0FBQUEsVUFFWCxLQUFLLEtBQUssV0FBVyxPQUFPLE9BQU87QUFDakMsa0JBQU0sVUFBVSxLQUFLLFdBQVc7QUFDaEMsa0JBQU0sU0FBUyxLQUFLLFVBQVU7QUFDOUIsZ0JBQUksT0FBTyxVQUFVLFFBQVEsYUFBYTtBQUN4QyxrQkFBSTtBQUNKLG1CQUFLLEtBQUssTUFBTSxPQUFPO0FBQ3ZCLGtCQUFJO0FBQUE7QUFFTixnQkFBSSxLQUFLLFVBQVU7QUFDakIsbUJBQUssaUJBQWlCO0FBQ3RCLG1CQUFLLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFJbkIsb0JBQVksS0FBSztBQUNqQixvQkFBWSxXQUFXO0FBQUEsVUFDckIsZ0JBQWdCO0FBQUEsVUFDaEIsWUFBWTtBQUFBLFVBQ1osa0JBQWtCO0FBQUEsVUFDbEIsaUJBQWlCO0FBQUEsVUFDakIsYUFBYTtBQUFBLFVBQ2IsaUJBQWlCO0FBQUEsVUFDakIsd0JBQXdCO0FBQUEsVUFDeEIsTUFBTTtBQUFBLFVBQ04sVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBO0FBRVgsb0JBQVksZ0JBQWdCO0FBQUEsVUFDMUIsaUJBQWlCO0FBQUEsVUFDakIsYUFBYTtBQUFBO0FBRWYsb0JBQVksY0FBYztBQUFBLFVBQ3hCLGFBQWE7QUFBQSxVQUNiLFlBQVksQ0FBQyxTQUFTLFNBQVMsZ0JBQWdCLFNBQVM7QUFBQTtBQUcxRCwyQkFBbUIsSUFBSSxLQUFLLE1BQU0sa0JBQWtCO0FBQ2xELGdCQUFNLFVBQVUsR0FBRztBQUNuQixnQkFBTSxHQUFFLE9BQU8sVUFBUyxHQUFHLFNBQVMsQ0FBQyxPQUFPO0FBQzVDLGlCQUFRLEtBQUssSUFBSSxNQUFNLFNBQVMsUUFBUSxTQUFTLFFBQVE7QUFBQTtBQUUzRCxtQ0FBMkIsU0FBUTtBQUFBLFVBQ2pDLFlBQVksS0FBSztBQUNmO0FBQ0EsaUJBQUssVUFBVTtBQUNmLGlCQUFLLFNBQVM7QUFDZCxpQkFBSyxPQUFPO0FBQ1osaUJBQUssT0FBTztBQUNaLGdCQUFJLEtBQUs7QUFDUCxxQkFBTyxPQUFPLE1BQU07QUFBQTtBQUFBO0FBQUEsVUFHeEIsUUFBUSxRQUFRLFFBQVEsa0JBQWtCO0FBQ3hDLGtCQUFNLFVBQVUsS0FBSztBQUNyQixrQkFBTSxFQUFDLEdBQUcsTUFBSyxLQUFLLFNBQVMsQ0FBQyxLQUFLLE1BQU07QUFDekMsbUJBQVMsS0FBSyxJQUFJLFNBQVMsR0FBRyxLQUFLLEtBQUssSUFBSSxTQUFTLEdBQUcsS0FBTSxLQUFLLElBQUksUUFBUSxZQUFZLFFBQVEsUUFBUTtBQUFBO0FBQUEsVUFFN0csU0FBUyxRQUFRLGtCQUFrQjtBQUNqQyxtQkFBTyxVQUFVLE1BQU0sUUFBUSxLQUFLO0FBQUE7QUFBQSxVQUV0QyxTQUFTLFFBQVEsa0JBQWtCO0FBQ2pDLG1CQUFPLFVBQVUsTUFBTSxRQUFRLEtBQUs7QUFBQTtBQUFBLFVBRXRDLGVBQWUsa0JBQWtCO0FBQy9CLGtCQUFNLEVBQUMsR0FBRyxNQUFLLEtBQUssU0FBUyxDQUFDLEtBQUssTUFBTTtBQUN6QyxtQkFBTyxFQUFDLEdBQUc7QUFBQTtBQUFBLFVBRWIsS0FBSyxTQUFTO0FBQ1osc0JBQVUsV0FBVyxLQUFLLFdBQVc7QUFDckMsZ0JBQUksU0FBUyxRQUFRLFVBQVU7QUFDL0IscUJBQVMsS0FBSyxJQUFJLFFBQVEsVUFBVSxRQUFRLGVBQWU7QUFDM0Qsa0JBQU0sY0FBYyxVQUFVLFFBQVEsZUFBZTtBQUNyRCxtQkFBUSxVQUFTLGVBQWU7QUFBQTtBQUFBLFVBRWxDLEtBQUssS0FBSyxNQUFNO0FBQ2Qsa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGdCQUFJLEtBQUssUUFBUSxRQUFRLFNBQVMsT0FBTyxDQUFDLGVBQWUsTUFBTSxNQUFNLEtBQUssS0FBSyxXQUFXLElBQUk7QUFDNUY7QUFBQTtBQUVGLGdCQUFJLGNBQWMsUUFBUTtBQUMxQixnQkFBSSxZQUFZLFFBQVE7QUFDeEIsZ0JBQUksWUFBWSxRQUFRO0FBQ3hCLHNCQUFVLEtBQUssU0FBUyxLQUFLLEdBQUcsS0FBSztBQUFBO0FBQUEsVUFFdkMsV0FBVztBQUNULGtCQUFNLFVBQVUsS0FBSyxXQUFXO0FBQ2hDLG1CQUFPLFFBQVEsU0FBUyxRQUFRO0FBQUE7QUFBQTtBQUdwQyxxQkFBYSxLQUFLO0FBQ2xCLHFCQUFhLFdBQVc7QUFBQSxVQUN0QixhQUFhO0FBQUEsVUFDYixXQUFXO0FBQUEsVUFDWCxrQkFBa0I7QUFBQSxVQUNsQixhQUFhO0FBQUEsVUFDYixZQUFZO0FBQUEsVUFDWixRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUE7QUFFWixxQkFBYSxnQkFBZ0I7QUFBQSxVQUMzQixpQkFBaUI7QUFBQSxVQUNqQixhQUFhO0FBQUE7QUFHZiw4QkFBc0IsS0FBSyxrQkFBa0I7QUFDM0MsZ0JBQU0sRUFBQyxHQUFHLEdBQUcsTUFBTSxPQUFPLFdBQVUsSUFBSSxTQUFTLENBQUMsS0FBSyxLQUFLLFFBQVEsU0FBUyxXQUFXO0FBQ3hGLGNBQUksTUFBTSxPQUFPLEtBQUssUUFBUTtBQUM5QixjQUFJLElBQUksWUFBWTtBQUNsQixtQkFBTyxTQUFTO0FBQ2hCLG1CQUFPLEtBQUssSUFBSSxHQUFHO0FBQ25CLG9CQUFRLEtBQUssSUFBSSxHQUFHO0FBQ3BCLGtCQUFNLElBQUk7QUFDVixxQkFBUyxJQUFJO0FBQUEsaUJBQ1I7QUFDTCxtQkFBTyxRQUFRO0FBQ2YsbUJBQU8sSUFBSTtBQUNYLG9CQUFRLElBQUk7QUFDWixrQkFBTSxLQUFLLElBQUksR0FBRztBQUNsQixxQkFBUyxLQUFLLElBQUksR0FBRztBQUFBO0FBRXZCLGlCQUFPLEVBQUMsTUFBTSxLQUFLLE9BQU87QUFBQTtBQUU1Qiw2QkFBcUIsT0FBTSxPQUFPLEtBQUssS0FBSztBQUMxQyxpQkFBTyxRQUFPLElBQUksWUFBWSxPQUFPLEtBQUs7QUFBQTtBQUU1QyxrQ0FBMEIsS0FBSyxNQUFNLE1BQU07QUFDekMsZ0JBQU0sUUFBUSxJQUFJLFFBQVE7QUFDMUIsZ0JBQU0sUUFBTyxJQUFJO0FBQ2pCLGdCQUFNLElBQUksT0FBTztBQUNqQixpQkFBTztBQUFBLFlBQ0wsR0FBRyxZQUFZLE1BQUssS0FBSyxFQUFFLEtBQUssR0FBRztBQUFBLFlBQ25DLEdBQUcsWUFBWSxNQUFLLE9BQU8sRUFBRSxPQUFPLEdBQUc7QUFBQSxZQUN2QyxHQUFHLFlBQVksTUFBSyxRQUFRLEVBQUUsUUFBUSxHQUFHO0FBQUEsWUFDekMsR0FBRyxZQUFZLE1BQUssTUFBTSxFQUFFLE1BQU0sR0FBRztBQUFBO0FBQUE7QUFHekMsbUNBQTJCLEtBQUssTUFBTSxNQUFNO0FBQzFDLGdCQUFNLEVBQUMsdUJBQXNCLElBQUksU0FBUyxDQUFDO0FBQzNDLGdCQUFNLFFBQVEsSUFBSSxRQUFRO0FBQzFCLGdCQUFNLElBQUksY0FBYztBQUN4QixnQkFBTSxPQUFPLEtBQUssSUFBSSxNQUFNO0FBQzVCLGdCQUFNLFFBQU8sSUFBSTtBQUNqQixnQkFBTSxlQUFlLHNCQUFzQixVQUFTO0FBQ3BELGlCQUFPO0FBQUEsWUFDTCxTQUFTLFlBQVksQ0FBQyxnQkFBZ0IsTUFBSyxPQUFPLE1BQUssTUFBTSxFQUFFLFNBQVMsR0FBRztBQUFBLFlBQzNFLFVBQVUsWUFBWSxDQUFDLGdCQUFnQixNQUFLLE9BQU8sTUFBSyxPQUFPLEVBQUUsVUFBVSxHQUFHO0FBQUEsWUFDOUUsWUFBWSxZQUFZLENBQUMsZ0JBQWdCLE1BQUssVUFBVSxNQUFLLE1BQU0sRUFBRSxZQUFZLEdBQUc7QUFBQSxZQUNwRixhQUFhLFlBQVksQ0FBQyxnQkFBZ0IsTUFBSyxVQUFVLE1BQUssT0FBTyxFQUFFLGFBQWEsR0FBRztBQUFBO0FBQUE7QUFHM0YsK0JBQXVCLEtBQUs7QUFDMUIsZ0JBQU0sU0FBUyxhQUFhO0FBQzVCLGdCQUFNLFFBQVEsT0FBTyxRQUFRLE9BQU87QUFDcEMsZ0JBQU0sU0FBUyxPQUFPLFNBQVMsT0FBTztBQUN0QyxnQkFBTSxTQUFTLGlCQUFpQixLQUFLLFFBQVEsR0FBRyxTQUFTO0FBQ3pELGdCQUFNLFNBQVMsa0JBQWtCLEtBQUssUUFBUSxHQUFHLFNBQVM7QUFDMUQsaUJBQU87QUFBQSxZQUNMLE9BQU87QUFBQSxjQUNMLEdBQUcsT0FBTztBQUFBLGNBQ1YsR0FBRyxPQUFPO0FBQUEsY0FDVixHQUFHO0FBQUEsY0FDSCxHQUFHO0FBQUEsY0FDSDtBQUFBO0FBQUEsWUFFRixPQUFPO0FBQUEsY0FDTCxHQUFHLE9BQU8sT0FBTyxPQUFPO0FBQUEsY0FDeEIsR0FBRyxPQUFPLE1BQU0sT0FBTztBQUFBLGNBQ3ZCLEdBQUcsUUFBUSxPQUFPLElBQUksT0FBTztBQUFBLGNBQzdCLEdBQUcsU0FBUyxPQUFPLElBQUksT0FBTztBQUFBLGNBQzlCLFFBQVE7QUFBQSxnQkFDTixTQUFTLEtBQUssSUFBSSxHQUFHLE9BQU8sVUFBVSxLQUFLLElBQUksT0FBTyxHQUFHLE9BQU87QUFBQSxnQkFDaEUsVUFBVSxLQUFLLElBQUksR0FBRyxPQUFPLFdBQVcsS0FBSyxJQUFJLE9BQU8sR0FBRyxPQUFPO0FBQUEsZ0JBQ2xFLFlBQVksS0FBSyxJQUFJLEdBQUcsT0FBTyxhQUFhLEtBQUssSUFBSSxPQUFPLEdBQUcsT0FBTztBQUFBLGdCQUN0RSxhQUFhLEtBQUssSUFBSSxHQUFHLE9BQU8sY0FBYyxLQUFLLElBQUksT0FBTyxHQUFHLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtoRix5QkFBaUIsS0FBSyxHQUFHLEdBQUcsa0JBQWtCO0FBQzVDLGdCQUFNLFFBQVEsTUFBTTtBQUNwQixnQkFBTSxRQUFRLE1BQU07QUFDcEIsZ0JBQU0sV0FBVyxTQUFTO0FBQzFCLGdCQUFNLFNBQVMsT0FBTyxDQUFDLFlBQVksYUFBYSxLQUFLO0FBQ3JELGlCQUFPLFVBQ0gsVUFBUyxXQUFXLEdBQUcsT0FBTyxNQUFNLE9BQU8sV0FDM0MsVUFBUyxXQUFXLEdBQUcsT0FBTyxLQUFLLE9BQU87QUFBQTtBQUVoRCwyQkFBbUIsUUFBUTtBQUN6QixpQkFBTyxPQUFPLFdBQVcsT0FBTyxZQUFZLE9BQU8sY0FBYyxPQUFPO0FBQUE7QUFFMUUsbUNBQTJCLEtBQUssTUFBTTtBQUNwQyxjQUFJLEtBQUssS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztBQUFBO0FBRXhDLDZCQUFxQixNQUFNLFFBQVEsVUFBVSxJQUFJO0FBQy9DLGdCQUFNLElBQUksS0FBSyxNQUFNLFFBQVEsSUFBSSxDQUFDLFNBQVM7QUFDM0MsZ0JBQU0sSUFBSSxLQUFLLE1BQU0sUUFBUSxJQUFJLENBQUMsU0FBUztBQUMzQyxnQkFBTSxJQUFLLE1BQUssSUFBSSxLQUFLLE1BQU0sUUFBUSxJQUFJLFFBQVEsSUFBSSxTQUFTLEtBQUs7QUFDckUsZ0JBQU0sSUFBSyxNQUFLLElBQUksS0FBSyxNQUFNLFFBQVEsSUFBSSxRQUFRLElBQUksU0FBUyxLQUFLO0FBQ3JFLGlCQUFPO0FBQUEsWUFDTCxHQUFHLEtBQUssSUFBSTtBQUFBLFlBQ1osR0FBRyxLQUFLLElBQUk7QUFBQSxZQUNaLEdBQUcsS0FBSyxJQUFJO0FBQUEsWUFDWixHQUFHLEtBQUssSUFBSTtBQUFBLFlBQ1osUUFBUSxLQUFLO0FBQUE7QUFBQTtBQUdqQixpQ0FBeUIsU0FBUTtBQUFBLFVBQy9CLFlBQVksS0FBSztBQUNmO0FBQ0EsaUJBQUssVUFBVTtBQUNmLGlCQUFLLGFBQWE7QUFDbEIsaUJBQUssT0FBTztBQUNaLGlCQUFLLFFBQVE7QUFDYixpQkFBSyxTQUFTO0FBQ2QsaUJBQUssZ0JBQWdCO0FBQ3JCLGdCQUFJLEtBQUs7QUFDUCxxQkFBTyxPQUFPLE1BQU07QUFBQTtBQUFBO0FBQUEsVUFHeEIsS0FBSyxLQUFLO0FBQ1Isa0JBQU0sRUFBQyxlQUFlLFNBQVMsRUFBQyxhQUFhLHNCQUFvQjtBQUNqRSxrQkFBTSxFQUFDLE9BQU8sVUFBUyxjQUFjO0FBQ3JDLGtCQUFNLGNBQWMsVUFBVSxNQUFNLFVBQVUscUJBQXFCO0FBQ25FLGdCQUFJO0FBQ0osZ0JBQUksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sTUFBTSxHQUFHO0FBQzlDLGtCQUFJO0FBQ0osMEJBQVksS0FBSyxZQUFZLE9BQU8sZUFBZTtBQUNuRCxrQkFBSTtBQUNKLDBCQUFZLEtBQUssWUFBWSxPQUFPLENBQUMsZUFBZTtBQUNwRCxrQkFBSSxZQUFZO0FBQ2hCLGtCQUFJLEtBQUs7QUFBQTtBQUVYLGdCQUFJO0FBQ0osd0JBQVksS0FBSyxZQUFZLE9BQU87QUFDcEMsZ0JBQUksWUFBWTtBQUNoQixnQkFBSTtBQUNKLGdCQUFJO0FBQUE7QUFBQSxVQUVOLFFBQVEsUUFBUSxRQUFRLGtCQUFrQjtBQUN4QyxtQkFBTyxRQUFRLE1BQU0sUUFBUSxRQUFRO0FBQUE7QUFBQSxVQUV2QyxTQUFTLFFBQVEsa0JBQWtCO0FBQ2pDLG1CQUFPLFFBQVEsTUFBTSxRQUFRLE1BQU07QUFBQTtBQUFBLFVBRXJDLFNBQVMsUUFBUSxrQkFBa0I7QUFDakMsbUJBQU8sUUFBUSxNQUFNLE1BQU0sUUFBUTtBQUFBO0FBQUEsVUFFckMsZUFBZSxrQkFBa0I7QUFDL0Isa0JBQU0sRUFBQyxHQUFHLEdBQUcsTUFBTSxlQUFjLEtBQUssU0FBUyxDQUFDLEtBQUssS0FBSyxRQUFRLGVBQWU7QUFDakYsbUJBQU87QUFBQSxjQUNMLEdBQUcsYUFBYyxLQUFJLFFBQVEsSUFBSTtBQUFBLGNBQ2pDLEdBQUcsYUFBYSxJQUFLLEtBQUksUUFBUTtBQUFBO0FBQUE7QUFBQSxVQUdyQyxTQUFTLE1BQU07QUFDYixtQkFBTyxTQUFTLE1BQU0sS0FBSyxRQUFRLElBQUksS0FBSyxTQUFTO0FBQUE7QUFBQTtBQUd6RCxtQkFBVyxLQUFLO0FBQ2hCLG1CQUFXLFdBQVc7QUFBQSxVQUNwQixlQUFlO0FBQUEsVUFDZixhQUFhO0FBQUEsVUFDYixjQUFjO0FBQUEsVUFDZCxlQUFlO0FBQUEsVUFDZixZQUFZO0FBQUE7QUFFZCxtQkFBVyxnQkFBZ0I7QUFBQSxVQUN6QixpQkFBaUI7QUFBQSxVQUNqQixhQUFhO0FBQUE7QUFHZixZQUFJLFdBQXdCLHVCQUFPLE9BQU87QUFBQSxVQUMxQyxXQUFXO0FBQUEsVUFDWDtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBO0FBR0EsZ0NBQXdCLE1BQU0sT0FBTyxPQUFPLGdCQUFnQixTQUFTO0FBQ25FLGdCQUFNLFVBQVUsUUFBUSxXQUFXO0FBQ25DLGNBQUksV0FBVyxPQUFPO0FBQ3BCLG1CQUFPLEtBQUssTUFBTSxPQUFPLFFBQVE7QUFBQTtBQUVuQyxnQkFBTSxZQUFZO0FBQ2xCLGdCQUFNLGNBQWUsU0FBUSxLQUFNLFdBQVU7QUFDN0MsY0FBSSxlQUFlO0FBQ25CLGdCQUFNLFdBQVcsUUFBUSxRQUFRO0FBQ2pDLGNBQUksSUFBSTtBQUNSLGNBQUksR0FBRyxjQUFjLFNBQVMsTUFBTTtBQUNwQyxvQkFBVSxrQkFBa0IsS0FBSztBQUNqQyxlQUFLLElBQUksR0FBRyxJQUFJLFVBQVUsR0FBRyxLQUFLO0FBQ2hDLGdCQUFJLE9BQU87QUFDWCxnQkFBSSxPQUFPO0FBQ1gsZ0JBQUk7QUFDSixrQkFBTSxnQkFBZ0IsS0FBSyxNQUFPLEtBQUksS0FBSyxlQUFlLElBQUk7QUFDOUQsa0JBQU0sY0FBYyxLQUFLLElBQUksS0FBSyxNQUFPLEtBQUksS0FBSyxlQUFlLEdBQUcsU0FBUztBQUM3RSxrQkFBTSxpQkFBaUIsY0FBYztBQUNyQyxpQkFBSyxJQUFJLGVBQWUsSUFBSSxhQUFhLEtBQUs7QUFDNUMsc0JBQVEsS0FBSyxHQUFHO0FBQ2hCLHNCQUFRLEtBQUssR0FBRztBQUFBO0FBRWxCLG9CQUFRO0FBQ1Isb0JBQVE7QUFDUixrQkFBTSxZQUFZLEtBQUssTUFBTSxJQUFJLGVBQWUsSUFBSTtBQUNwRCxrQkFBTSxVQUFVLEtBQUssSUFBSSxLQUFLLE1BQU8sS0FBSSxLQUFLLGVBQWUsR0FBRyxTQUFTO0FBQ3pFLGtCQUFNLEVBQUMsR0FBRyxTQUFTLEdBQUcsWUFBVyxLQUFLO0FBQ3RDLHNCQUFVLE9BQU87QUFDakIsaUJBQUssSUFBSSxXQUFXLElBQUksU0FBUyxLQUFLO0FBQ3BDLHFCQUFPLE1BQU0sS0FBSyxJQUNmLFdBQVUsUUFBUyxNQUFLLEdBQUcsSUFBSSxXQUMvQixXQUFVLEtBQUssR0FBRyxLQUFNLFFBQU87QUFFbEMsa0JBQUksT0FBTyxTQUFTO0FBQ2xCLDBCQUFVO0FBQ1YsK0JBQWUsS0FBSztBQUNwQix3QkFBUTtBQUFBO0FBQUE7QUFHWixzQkFBVSxrQkFBa0I7QUFDNUIsZ0JBQUk7QUFBQTtBQUVOLG9CQUFVLGtCQUFrQixLQUFLO0FBQ2pDLGlCQUFPO0FBQUE7QUFFVCxrQ0FBMEIsTUFBTSxPQUFPLE9BQU8sZ0JBQWdCO0FBQzVELGNBQUksT0FBTztBQUNYLGNBQUksU0FBUztBQUNiLGNBQUksR0FBRyxPQUFPLEdBQUcsR0FBRyxPQUFPLFVBQVUsVUFBVSxZQUFZLE1BQU07QUFDakUsZ0JBQU0sWUFBWTtBQUNsQixnQkFBTSxXQUFXLFFBQVEsUUFBUTtBQUNqQyxnQkFBTSxPQUFPLEtBQUssT0FBTztBQUN6QixnQkFBTSxPQUFPLEtBQUssVUFBVTtBQUM1QixnQkFBTSxLQUFLLE9BQU87QUFDbEIsZUFBSyxJQUFJLE9BQU8sSUFBSSxRQUFRLE9BQU8sRUFBRSxHQUFHO0FBQ3RDLG9CQUFRLEtBQUs7QUFDYixnQkFBSyxPQUFNLElBQUksUUFBUSxLQUFLO0FBQzVCLGdCQUFJLE1BQU07QUFDVixrQkFBTSxTQUFTLElBQUk7QUFDbkIsZ0JBQUksV0FBVyxPQUFPO0FBQ3BCLGtCQUFJLElBQUksTUFBTTtBQUNaLHVCQUFPO0FBQ1AsMkJBQVc7QUFBQSx5QkFDRixJQUFJLE1BQU07QUFDbkIsdUJBQU87QUFDUCwyQkFBVztBQUFBO0FBRWIscUJBQVEsVUFBUyxPQUFPLE1BQU0sS0FBSyxFQUFFO0FBQUEsbUJBQ2hDO0FBQ0wsb0JBQU0sWUFBWSxJQUFJO0FBQ3RCLGtCQUFJLENBQUMsY0FBYyxhQUFhLENBQUMsY0FBYyxXQUFXO0FBQ3hELHNCQUFNLHFCQUFxQixLQUFLLElBQUksVUFBVTtBQUM5QyxzQkFBTSxxQkFBcUIsS0FBSyxJQUFJLFVBQVU7QUFDOUMsb0JBQUksdUJBQXVCLGNBQWMsdUJBQXVCLFdBQVc7QUFDekUsNEJBQVUsS0FBSyxpQ0FDVixLQUFLLHNCQURLO0FBQUEsb0JBRWIsR0FBRztBQUFBO0FBQUE7QUFHUCxvQkFBSSx1QkFBdUIsY0FBYyx1QkFBdUIsV0FBVztBQUN6RSw0QkFBVSxLQUFLLGlDQUNWLEtBQUssc0JBREs7QUFBQSxvQkFFYixHQUFHO0FBQUE7QUFBQTtBQUFBO0FBSVQsa0JBQUksSUFBSSxLQUFLLGNBQWMsWUFBWTtBQUNyQywwQkFBVSxLQUFLLEtBQUs7QUFBQTtBQUV0Qix3QkFBVSxLQUFLO0FBQ2Ysc0JBQVE7QUFDUix1QkFBUztBQUNULHFCQUFPLE9BQU87QUFDZCx5QkFBVyxXQUFXLGFBQWE7QUFBQTtBQUFBO0FBR3ZDLGlCQUFPO0FBQUE7QUFFVCx1Q0FBK0IsU0FBUztBQUN0QyxjQUFJLFFBQVEsWUFBWTtBQUN0QixrQkFBTSxPQUFPLFFBQVE7QUFDckIsbUJBQU8sUUFBUTtBQUNmLG1CQUFPLFFBQVE7QUFDZixtQkFBTyxlQUFlLFNBQVMsUUFBUSxFQUFDLE9BQU87QUFBQTtBQUFBO0FBR25ELG9DQUE0QixRQUFPO0FBQ2pDLGlCQUFNLEtBQUssU0FBUyxRQUFRLENBQUMsWUFBWTtBQUN2QyxrQ0FBc0I7QUFBQTtBQUFBO0FBRzFCLDJEQUFtRCxNQUFNLFFBQVE7QUFDL0QsZ0JBQU0sYUFBYSxPQUFPO0FBQzFCLGNBQUksUUFBUTtBQUNaLGNBQUk7QUFDSixnQkFBTSxFQUFDLFdBQVU7QUFDakIsZ0JBQU0sRUFBQyxLQUFLLEtBQUssWUFBWSxlQUFjLE9BQU87QUFDbEQsY0FBSSxZQUFZO0FBQ2Qsb0JBQVEsWUFBWSxhQUFhLFFBQVEsT0FBTyxNQUFNLEtBQUssSUFBSSxHQUFHLGFBQWE7QUFBQTtBQUVqRixjQUFJLFlBQVk7QUFDZCxvQkFBUSxZQUFZLGFBQWEsUUFBUSxPQUFPLE1BQU0sS0FBSyxLQUFLLEdBQUcsT0FBTyxjQUFjO0FBQUEsaUJBQ25GO0FBQ0wsb0JBQVEsYUFBYTtBQUFBO0FBRXZCLGlCQUFPLEVBQUMsT0FBTztBQUFBO0FBRWpCLFlBQUksb0JBQW9CO0FBQUEsVUFDdEIsSUFBSTtBQUFBLFVBQ0osVUFBVTtBQUFBLFlBQ1IsV0FBVztBQUFBLFlBQ1gsU0FBUztBQUFBO0FBQUEsVUFFWCxzQkFBc0IsQ0FBQyxRQUFPLE1BQU0sWUFBWTtBQUM5QyxnQkFBSSxDQUFDLFFBQVEsU0FBUztBQUNwQixpQ0FBbUI7QUFDbkI7QUFBQTtBQUVGLGtCQUFNLGlCQUFpQixPQUFNO0FBQzdCLG1CQUFNLEtBQUssU0FBUyxRQUFRLENBQUMsU0FBUyxpQkFBaUI7QUFDckQsb0JBQU0sRUFBQyxPQUFPLGNBQWE7QUFDM0Isb0JBQU0sT0FBTyxPQUFNLGVBQWU7QUFDbEMsb0JBQU0sT0FBTyxTQUFTLFFBQVE7QUFDOUIsa0JBQUksUUFBUSxDQUFDLFdBQVcsT0FBTSxRQUFRLGdCQUFnQixLQUFLO0FBQ3pEO0FBQUE7QUFFRixrQkFBSSxDQUFDLEtBQUssV0FBVyxvQkFBb0I7QUFDdkM7QUFBQTtBQUVGLG9CQUFNLFFBQVEsT0FBTSxPQUFPLEtBQUs7QUFDaEMsa0JBQUksTUFBTSxTQUFTLFlBQVksTUFBTSxTQUFTLFFBQVE7QUFDcEQ7QUFBQTtBQUVGLGtCQUFJLE9BQU0sUUFBUSxTQUFTO0FBQ3pCO0FBQUE7QUFFRixrQkFBSSxFQUFDLE9BQU8sVUFBUywwQ0FBMEMsTUFBTTtBQUNyRSxvQkFBTSxZQUFZLFFBQVEsYUFBYSxJQUFJO0FBQzNDLGtCQUFJLFNBQVMsV0FBVztBQUN0QixzQ0FBc0I7QUFDdEI7QUFBQTtBQUVGLGtCQUFJLGNBQWMsUUFBUTtBQUN4Qix3QkFBUSxRQUFRO0FBQ2hCLHVCQUFPLFFBQVE7QUFDZix1QkFBTyxlQUFlLFNBQVMsUUFBUTtBQUFBLGtCQUNyQyxjQUFjO0FBQUEsa0JBQ2QsWUFBWTtBQUFBLGtCQUNaLEtBQUssV0FBVztBQUNkLDJCQUFPLEtBQUs7QUFBQTtBQUFBLGtCQUVkLEtBQUssU0FBUyxHQUFHO0FBQ2YseUJBQUssUUFBUTtBQUFBO0FBQUE7QUFBQTtBQUluQixrQkFBSTtBQUNKLHNCQUFRLFFBQVE7QUFBQSxxQkFDWDtBQUNILDhCQUFZLGVBQWUsTUFBTSxPQUFPLE9BQU8sZ0JBQWdCO0FBQy9EO0FBQUEscUJBQ0c7QUFDSCw4QkFBWSxpQkFBaUIsTUFBTSxPQUFPLE9BQU87QUFDakQ7QUFBQTtBQUVBLHdCQUFNLElBQUksTUFBTSxxQ0FBcUMsUUFBUTtBQUFBO0FBRS9ELHNCQUFRLGFBQWE7QUFBQTtBQUFBO0FBQUEsVUFHekIsUUFBUSxRQUFPO0FBQ2IsK0JBQW1CO0FBQUE7QUFBQTtBQUl2QiwyQkFBbUIsTUFBTSxRQUFRLFVBQVU7QUFDekMsZ0JBQU0sV0FBVyxLQUFLO0FBQ3RCLGdCQUFNLFNBQVMsS0FBSztBQUNwQixnQkFBTSxVQUFVLE9BQU87QUFDdkIsZ0JBQU0sUUFBUTtBQUNkLHFCQUFXLFdBQVcsVUFBVTtBQUM5QixnQkFBSSxFQUFDLE9BQU8sUUFBTztBQUNuQixrQkFBTSxnQkFBZ0IsT0FBTyxLQUFLO0FBQ2xDLGtCQUFNLFNBQVMsV0FBVyxVQUFVLE9BQU8sUUFBUSxPQUFPLE1BQU0sUUFBUTtBQUN4RSxnQkFBSSxDQUFDLE9BQU8sVUFBVTtBQUNwQixvQkFBTSxLQUFLO0FBQUEsZ0JBQ1QsUUFBUTtBQUFBLGdCQUNSLFFBQVE7QUFBQSxnQkFDUixPQUFPLE9BQU87QUFBQSxnQkFDZCxLQUFLLE9BQU87QUFBQTtBQUVkO0FBQUE7QUFFRixrQkFBTSxpQkFBaUIsZUFBZSxRQUFRO0FBQzlDLHVCQUFXLE9BQU8sZ0JBQWdCO0FBQ2hDLG9CQUFNLFlBQVksV0FBVyxVQUFVLFFBQVEsSUFBSSxRQUFRLFFBQVEsSUFBSSxNQUFNLElBQUk7QUFDakYsb0JBQU0sY0FBYyxjQUFjLFNBQVMsUUFBUTtBQUNuRCx5QkFBVyxjQUFjLGFBQWE7QUFDcEMsc0JBQU0sS0FBSztBQUFBLGtCQUNULFFBQVE7QUFBQSxrQkFDUixRQUFRO0FBQUEsa0JBQ1IsT0FBTztBQUFBLHFCQUNKLFdBQVcsU0FBUyxRQUFRLFdBQVcsU0FBUyxLQUFLO0FBQUE7QUFBQSxrQkFFeEQsS0FBSztBQUFBLHFCQUNGLFdBQVcsU0FBUyxRQUFRLFdBQVcsT0FBTyxLQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU05RCxpQkFBTztBQUFBO0FBRVQsNEJBQW9CLFVBQVUsT0FBTyxNQUFNLE1BQU07QUFDL0MsY0FBSSxNQUFNO0FBQ1I7QUFBQTtBQUVGLGNBQUksUUFBUSxNQUFNO0FBQ2xCLGNBQUksTUFBTSxLQUFLO0FBQ2YsY0FBSSxhQUFhLFNBQVM7QUFDeEIsb0JBQVEsZ0JBQWdCO0FBQ3hCLGtCQUFNLGdCQUFnQjtBQUFBO0FBRXhCLGlCQUFPLEVBQUMsVUFBVSxPQUFPO0FBQUE7QUFFM0IscUNBQTZCLFVBQVUsTUFBTTtBQUMzQyxnQkFBTSxFQUFDLElBQUksTUFBTSxJQUFJLFNBQVEsWUFBWTtBQUN6QyxnQkFBTSxhQUFhLEtBQUs7QUFDeEIsZ0JBQU0sU0FBUztBQUNmLGVBQUssU0FBUyxRQUFRLENBQUMsRUFBQyxPQUFPLFVBQVM7QUFDdEMsa0JBQU0sZ0JBQWdCLE9BQU8sS0FBSztBQUNsQyxrQkFBTSxRQUFRLFdBQVc7QUFDekIsa0JBQU0sT0FBTyxXQUFXO0FBQ3hCLGdCQUFJLE1BQU0sTUFBTTtBQUNkLHFCQUFPLEtBQUssRUFBQyxHQUFHLE1BQU0sR0FBRztBQUN6QixxQkFBTyxLQUFLLEVBQUMsR0FBRyxLQUFLLEdBQUc7QUFBQSx1QkFDZixNQUFNLE1BQU07QUFDckIscUJBQU8sS0FBSyxFQUFDLEdBQUcsR0FBRyxNQUFNO0FBQ3pCLHFCQUFPLEtBQUssRUFBQyxHQUFHLEdBQUcsS0FBSztBQUFBO0FBQUE7QUFHNUIsaUJBQU87QUFBQTtBQUVULGlDQUF5QixPQUFPLEtBQUssUUFBUTtBQUMzQyxpQkFBTSxNQUFNLE9BQU8sT0FBTztBQUN4QixrQkFBTSxRQUFRLE9BQU87QUFDckIsZ0JBQUksQ0FBQyxNQUFNLE1BQU0sTUFBTSxDQUFDLE1BQU0sTUFBTSxJQUFJO0FBQ3RDO0FBQUE7QUFBQTtBQUdKLGlCQUFPO0FBQUE7QUFFVCwwQkFBa0IsR0FBRyxHQUFHLE1BQU0sSUFBSTtBQUNoQyxjQUFJLEtBQUssR0FBRztBQUNWLG1CQUFPLEdBQUcsRUFBRSxPQUFPLEVBQUU7QUFBQTtBQUV2QixpQkFBTyxJQUFJLEVBQUUsUUFBUSxJQUFJLEVBQUUsUUFBUTtBQUFBO0FBR3JDLHFDQUE2QixVQUFVLE1BQU07QUFDM0MsY0FBSSxTQUFTO0FBQ2IsY0FBSSxRQUFRO0FBQ1osY0FBSSxRQUFRLFdBQVc7QUFDckIsb0JBQVE7QUFDUixxQkFBUztBQUFBLGlCQUNKO0FBQ0wscUJBQVMsb0JBQW9CLFVBQVU7QUFBQTtBQUV6QyxpQkFBTyxPQUFPLFNBQVMsSUFBSSxZQUFZO0FBQUEsWUFDckM7QUFBQSxZQUNBLFNBQVMsRUFBQyxTQUFTO0FBQUEsWUFDbkI7QUFBQSxZQUNBLFdBQVc7QUFBQSxlQUNSO0FBQUE7QUFFUCxrQ0FBMEIsUUFBUTtBQUNoQyxpQkFBTyxVQUFVLE9BQU8sU0FBUztBQUFBO0FBR25DLGdDQUF3QixTQUFTLFFBQU8sV0FBVztBQUNqRCxnQkFBTSxTQUFTLFFBQVE7QUFDdkIsY0FBSSxRQUFPLE9BQU87QUFDbEIsZ0JBQU0sVUFBVSxDQUFDO0FBQ2pCLGNBQUk7QUFDSixjQUFJLENBQUMsV0FBVztBQUNkLG1CQUFPO0FBQUE7QUFFVCxpQkFBTyxVQUFTLFNBQVMsUUFBUSxRQUFRLFdBQVUsSUFBSTtBQUNyRCxnQkFBSSxDQUFDLGVBQWUsUUFBTztBQUN6QixxQkFBTztBQUFBO0FBRVQscUJBQVMsUUFBUTtBQUNqQixnQkFBSSxDQUFDLFFBQVE7QUFDWCxxQkFBTztBQUFBO0FBRVQsZ0JBQUksT0FBTyxTQUFTO0FBQ2xCLHFCQUFPO0FBQUE7QUFFVCxvQkFBUSxLQUFLO0FBQ2Isb0JBQU8sT0FBTztBQUFBO0FBRWhCLGlCQUFPO0FBQUE7QUFFVCw2QkFBcUIsTUFBTSxRQUFPLE9BQU87QUFDdkMsZ0JBQU0sUUFBTyxnQkFBZ0I7QUFDN0IsY0FBSSxVQUFTLFFBQU87QUFDbEIsbUJBQU8sTUFBTSxNQUFLLFNBQVMsUUFBUTtBQUFBO0FBRXJDLGNBQUksU0FBUyxXQUFXO0FBQ3hCLGNBQUksZUFBZSxXQUFXLEtBQUssTUFBTSxZQUFZLFFBQVE7QUFDM0QsbUJBQU8sa0JBQWtCLE1BQUssSUFBSSxRQUFPLFFBQVE7QUFBQTtBQUVuRCxpQkFBTyxDQUFDLFVBQVUsU0FBUyxPQUFPLFNBQVMsU0FBUyxRQUFRLFVBQVMsS0FBSztBQUFBO0FBRTVFLG1DQUEyQixTQUFTLFFBQU8sUUFBUSxPQUFPO0FBQ3hELGNBQUksWUFBWSxPQUFPLFlBQVksS0FBSztBQUN0QyxxQkFBUyxTQUFRO0FBQUE7QUFFbkIsY0FBSSxXQUFXLFVBQVMsU0FBUyxLQUFLLFVBQVUsT0FBTztBQUNyRCxtQkFBTztBQUFBO0FBRVQsaUJBQU87QUFBQTtBQUVULGlDQUF5QixPQUFNLE9BQU87QUFDcEMsY0FBSSxRQUFRO0FBQ1osY0FBSSxVQUFTLFNBQVM7QUFDcEIsb0JBQVEsTUFBTTtBQUFBLHFCQUNMLFVBQVMsT0FBTztBQUN6QixvQkFBUSxNQUFNO0FBQUEscUJBQ0wsVUFBUyxRQUFPO0FBQ3pCLG9CQUFRLE1BQU0saUJBQWlCLE1BQUs7QUFBQSxxQkFDM0IsTUFBTSxjQUFjO0FBQzdCLG9CQUFRLE1BQU07QUFBQTtBQUVoQixpQkFBTztBQUFBO0FBRVQsaUNBQXlCLE9BQU0sT0FBTyxZQUFZO0FBQ2hELGNBQUk7QUFDSixjQUFJLFVBQVMsU0FBUztBQUNwQixvQkFBUTtBQUFBLHFCQUNDLFVBQVMsT0FBTztBQUN6QixvQkFBUSxNQUFNLFFBQVEsVUFBVSxNQUFNLE1BQU0sTUFBTTtBQUFBLHFCQUN6QyxVQUFTLFFBQU87QUFDekIsb0JBQVEsTUFBSztBQUFBLGlCQUNSO0FBQ0wsb0JBQVEsTUFBTTtBQUFBO0FBRWhCLGlCQUFPO0FBQUE7QUFFVCxpQ0FBeUIsTUFBTTtBQUM3QixnQkFBTSxVQUFVLEtBQUs7QUFDckIsZ0JBQU0sYUFBYSxRQUFRO0FBQzNCLGNBQUksUUFBTyxlQUFlLGNBQWMsV0FBVyxRQUFRO0FBQzNELGNBQUksVUFBUyxRQUFXO0FBQ3RCLG9CQUFPLENBQUMsQ0FBQyxRQUFRO0FBQUE7QUFFbkIsY0FBSSxVQUFTLFNBQVMsVUFBUyxNQUFNO0FBQ25DLG1CQUFPO0FBQUE7QUFFVCxjQUFJLFVBQVMsTUFBTTtBQUNqQixtQkFBTztBQUFBO0FBRVQsaUJBQU87QUFBQTtBQUdULGlDQUF5QixRQUFRO0FBQy9CLGdCQUFNLEVBQUMsT0FBTyxlQUFPLFNBQVE7QUFDN0IsZ0JBQU0sU0FBUztBQUNmLGdCQUFNLFdBQVcsS0FBSztBQUN0QixnQkFBTSxlQUFlLEtBQUs7QUFDMUIsZ0JBQU0sYUFBYSxjQUFjLE9BQU87QUFDeEMscUJBQVcsS0FBSyxvQkFBb0IsRUFBQyxHQUFHLE1BQU0sR0FBRyxNQUFNLFVBQVM7QUFDaEUsbUJBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxRQUFRLEtBQUs7QUFDeEMsa0JBQU0sVUFBVSxTQUFTO0FBQ3pCLHFCQUFTLElBQUksUUFBUSxPQUFPLEtBQUssUUFBUSxLQUFLLEtBQUs7QUFDakQsNkJBQWUsUUFBUSxhQUFhLElBQUk7QUFBQTtBQUFBO0FBRzVDLGlCQUFPLElBQUksWUFBWSxFQUFDLFFBQVEsU0FBUztBQUFBO0FBRTNDLCtCQUF1QixPQUFPLFFBQU87QUFDbkMsZ0JBQU0sUUFBUTtBQUNkLGdCQUFNLFFBQVEsTUFBTSx3QkFBd0I7QUFDNUMsbUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFDckMsa0JBQU0sT0FBTyxNQUFNO0FBQ25CLGdCQUFJLEtBQUssVUFBVSxRQUFPO0FBQ3hCO0FBQUE7QUFFRixnQkFBSSxDQUFDLEtBQUssUUFBUTtBQUNoQixvQkFBTSxRQUFRLEtBQUs7QUFBQTtBQUFBO0FBR3ZCLGlCQUFPO0FBQUE7QUFFVCxnQ0FBd0IsUUFBUSxhQUFhLFlBQVk7QUFDdkQsZ0JBQU0sWUFBWTtBQUNsQixtQkFBUyxJQUFJLEdBQUcsSUFBSSxXQUFXLFFBQVEsS0FBSztBQUMxQyxrQkFBTSxPQUFPLFdBQVc7QUFDeEIsa0JBQU0sRUFBQyxPQUFPLE1BQU0sVUFBUyxVQUFVLE1BQU0sYUFBYTtBQUMxRCxnQkFBSSxDQUFDLFNBQVUsU0FBUyxNQUFPO0FBQzdCO0FBQUE7QUFFRixnQkFBSSxPQUFPO0FBQ1Qsd0JBQVUsUUFBUTtBQUFBLG1CQUNiO0FBQ0wscUJBQU8sS0FBSztBQUNaLGtCQUFJLENBQUMsTUFBTTtBQUNUO0FBQUE7QUFBQTtBQUFBO0FBSU4saUJBQU8sS0FBSyxHQUFHO0FBQUE7QUFFakIsMkJBQW1CLE1BQU0sYUFBYSxVQUFVO0FBQzlDLGdCQUFNLFFBQVEsS0FBSyxZQUFZLGFBQWE7QUFDNUMsY0FBSSxDQUFDLE9BQU87QUFDVixtQkFBTztBQUFBO0FBRVQsZ0JBQU0sYUFBYSxNQUFNO0FBQ3pCLGdCQUFNLFdBQVcsS0FBSztBQUN0QixnQkFBTSxhQUFhLEtBQUs7QUFDeEIsY0FBSSxRQUFRO0FBQ1osY0FBSSxPQUFPO0FBQ1gsbUJBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxRQUFRLEtBQUs7QUFDeEMsa0JBQU0sVUFBVSxTQUFTO0FBQ3pCLGtCQUFNLGFBQWEsV0FBVyxRQUFRLE9BQU87QUFDN0Msa0JBQU0sWUFBWSxXQUFXLFFBQVEsS0FBSztBQUMxQyxnQkFBSSxXQUFXLFlBQVksWUFBWSxZQUFZO0FBQ2pELHNCQUFRLGVBQWU7QUFDdkIscUJBQU8sZUFBZTtBQUN0QjtBQUFBO0FBQUE7QUFHSixpQkFBTyxFQUFDLE9BQU8sTUFBTTtBQUFBO0FBR3ZCLHdCQUFnQjtBQUFBLFVBQ2QsWUFBWSxNQUFNO0FBQ2hCLGlCQUFLLElBQUksS0FBSztBQUNkLGlCQUFLLElBQUksS0FBSztBQUNkLGlCQUFLLFNBQVMsS0FBSztBQUFBO0FBQUEsVUFFckIsWUFBWSxLQUFLLFFBQVEsTUFBTTtBQUM3QixrQkFBTSxFQUFDLEdBQUcsR0FBRyxXQUFVO0FBQ3ZCLHFCQUFTLFVBQVUsRUFBQyxPQUFPLEdBQUcsS0FBSztBQUNuQyxnQkFBSSxJQUFJLEdBQUcsR0FBRyxRQUFRLE9BQU8sS0FBSyxPQUFPLE9BQU87QUFDaEQsbUJBQU8sQ0FBQyxLQUFLO0FBQUE7QUFBQSxVQUVmLFlBQVksT0FBTztBQUNqQixrQkFBTSxFQUFDLEdBQUcsR0FBRyxXQUFVO0FBQ3ZCLGtCQUFNLFFBQVEsTUFBTTtBQUNwQixtQkFBTztBQUFBLGNBQ0wsR0FBRyxJQUFJLEtBQUssSUFBSSxTQUFTO0FBQUEsY0FDekIsR0FBRyxJQUFJLEtBQUssSUFBSSxTQUFTO0FBQUEsY0FDekI7QUFBQTtBQUFBO0FBQUE7QUFLTiw0QkFBb0IsUUFBUTtBQUMxQixnQkFBTSxFQUFDLGVBQU8sYUFBTSxTQUFRO0FBQzVCLGNBQUksZUFBZSxRQUFPO0FBQ3hCLG1CQUFPLGVBQWUsUUFBTztBQUFBO0FBRS9CLGNBQUksVUFBUyxTQUFTO0FBQ3BCLG1CQUFPLGdCQUFnQjtBQUFBO0FBRXpCLGNBQUksVUFBUyxTQUFTO0FBQ3BCLG1CQUFPO0FBQUE7QUFFVCxnQkFBTSxXQUFXLGdCQUFnQjtBQUNqQyxjQUFJLG9CQUFvQixXQUFXO0FBQ2pDLG1CQUFPO0FBQUE7QUFFVCxpQkFBTyxvQkFBb0IsVUFBVTtBQUFBO0FBRXZDLGdDQUF3QixRQUFPLFFBQU87QUFDcEMsZ0JBQU0sT0FBTyxPQUFNLGVBQWU7QUFDbEMsZ0JBQU0sVUFBVSxRQUFRLE9BQU0saUJBQWlCO0FBQy9DLGlCQUFPLFVBQVUsS0FBSyxVQUFVO0FBQUE7QUFFbEMsaUNBQXlCLFFBQVE7QUFDL0IsZ0JBQU0sUUFBUSxPQUFPLFNBQVM7QUFDOUIsY0FBSSxNQUFNLDBCQUEwQjtBQUNsQyxtQkFBTyx3QkFBd0I7QUFBQTtBQUVqQyxpQkFBTyxzQkFBc0I7QUFBQTtBQUUvQix1Q0FBK0IsUUFBUTtBQUNyQyxnQkFBTSxFQUFDLFFBQVEsSUFBSSxnQkFBUTtBQUMzQixnQkFBTSxRQUFRLGdCQUFnQixPQUFNO0FBQ3BDLGNBQUksZUFBZSxRQUFRO0FBQ3pCLGtCQUFNLGFBQWEsTUFBTTtBQUN6QixtQkFBTztBQUFBLGNBQ0wsR0FBRyxhQUFhLFFBQVE7QUFBQSxjQUN4QixHQUFHLGFBQWEsT0FBTztBQUFBO0FBQUE7QUFHM0IsaUJBQU87QUFBQTtBQUVULHlDQUFpQyxRQUFRO0FBQ3ZDLGdCQUFNLEVBQUMsT0FBTyxnQkFBUTtBQUN0QixnQkFBTSxVQUFVLE1BQU07QUFDdEIsZ0JBQU0sU0FBUyxNQUFNLFlBQVk7QUFDakMsZ0JBQU0sUUFBUSxRQUFRLFVBQVUsTUFBTSxNQUFNLE1BQU07QUFDbEQsZ0JBQU0sUUFBUSxnQkFBZ0IsT0FBTSxPQUFPO0FBQzNDLGdCQUFNLFNBQVM7QUFDZixjQUFJLFFBQVEsS0FBSyxVQUFVO0FBQ3pCLGtCQUFNLFNBQVMsTUFBTSx5QkFBeUIsR0FBRztBQUNqRCxtQkFBTyxJQUFJLFVBQVU7QUFBQSxjQUNuQixHQUFHLE9BQU87QUFBQSxjQUNWLEdBQUcsT0FBTztBQUFBLGNBQ1YsUUFBUSxNQUFNLDhCQUE4QjtBQUFBO0FBQUE7QUFHaEQsbUJBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxFQUFFLEdBQUc7QUFDL0IsbUJBQU8sS0FBSyxNQUFNLHlCQUF5QixHQUFHO0FBQUE7QUFFaEQsaUJBQU87QUFBQTtBQUdULDJCQUFtQixLQUFLLFFBQVEsTUFBTTtBQUNwQyxnQkFBTSxTQUFTLFdBQVc7QUFDMUIsZ0JBQU0sRUFBQyxNQUFNLE9BQU8sU0FBUTtBQUM1QixnQkFBTSxXQUFXLEtBQUs7QUFDdEIsZ0JBQU0sYUFBYSxTQUFTO0FBQzVCLGdCQUFNLFNBQVEsU0FBUztBQUN2QixnQkFBTSxFQUFDLFFBQVEsUUFBTyxRQUFRLFdBQVMsY0FBYztBQUNyRCxjQUFJLFVBQVUsS0FBSyxPQUFPLFFBQVE7QUFDaEMscUJBQVMsS0FBSztBQUNkLG1CQUFPLEtBQUssRUFBQyxNQUFNLFFBQVEsT0FBTyxPQUFPLE1BQU0sT0FBTztBQUN0RCx1QkFBVztBQUFBO0FBQUE7QUFHZix3QkFBZ0IsS0FBSyxLQUFLO0FBQ3hCLGdCQUFNLEVBQUMsTUFBTSxRQUFRLE9BQU8sT0FBTyxNQUFNLFVBQVM7QUFDbEQsZ0JBQU0sV0FBVyxLQUFLLFFBQVEsVUFBVSxJQUFJO0FBQzVDLGNBQUk7QUFDSixjQUFJLGFBQWEsT0FBTyxVQUFVLE9BQU87QUFDdkMseUJBQWEsS0FBSyxRQUFRLEtBQUs7QUFDL0IsaUJBQUssS0FBSyxFQUFDLE1BQU0sUUFBUSxPQUFPLE9BQU8sT0FBTztBQUM5QyxnQkFBSTtBQUNKLGdCQUFJO0FBQ0oseUJBQWEsS0FBSyxRQUFRLEtBQUs7QUFBQTtBQUVqQyxlQUFLLEtBQUssRUFBQyxNQUFNLFFBQVEsT0FBTyxPQUFPLE9BQU87QUFDOUMsY0FBSTtBQUFBO0FBRU4sOEJBQXNCLEtBQUssUUFBUSxPQUFPO0FBQ3hDLGdCQUFNLEVBQUMsVUFBVSxXQUFVO0FBQzNCLGNBQUksUUFBUTtBQUNaLGNBQUksV0FBVztBQUNmLGNBQUk7QUFDSixxQkFBVyxXQUFXLFVBQVU7QUFDOUIsa0JBQU0sRUFBQyxPQUFPLFFBQU87QUFDckIsa0JBQU0sYUFBYSxPQUFPO0FBQzFCLGtCQUFNLFlBQVksT0FBTyxnQkFBZ0IsT0FBTyxLQUFLO0FBQ3JELGdCQUFJLE9BQU87QUFDVCxrQkFBSSxPQUFPLFdBQVcsR0FBRyxXQUFXO0FBQ3BDLHNCQUFRO0FBQUEsbUJBQ0g7QUFDTCxrQkFBSSxPQUFPLFdBQVcsR0FBRztBQUN6QixrQkFBSSxPQUFPLFdBQVcsR0FBRyxXQUFXO0FBQUE7QUFFdEMsdUJBQVcsQ0FBQyxDQUFDLE9BQU8sWUFBWSxLQUFLLFNBQVMsRUFBQyxNQUFNO0FBQ3JELGdCQUFJLFVBQVU7QUFDWixrQkFBSTtBQUFBLG1CQUNDO0FBQ0wsa0JBQUksT0FBTyxVQUFVLEdBQUc7QUFBQTtBQUFBO0FBRzVCLGNBQUksT0FBTyxPQUFPLFFBQVEsR0FBRztBQUM3QixjQUFJO0FBQ0osY0FBSTtBQUFBO0FBRU4sc0JBQWMsS0FBSyxLQUFLO0FBQ3RCLGdCQUFNLEVBQUMsTUFBTSxRQUFRLFVBQVUsZUFBTyxVQUFTO0FBQy9DLGdCQUFNLFdBQVcsVUFBVSxNQUFNLFFBQVE7QUFDekMscUJBQVcsRUFBQyxRQUFRLEtBQUssUUFBUSxLQUFLLE9BQU8sU0FBUSxVQUFVO0FBQzdELGtCQUFNLEVBQUMsT0FBTyxFQUFDLGtCQUFrQixXQUFTLE9BQU07QUFDaEQsa0JBQU0sV0FBVyxXQUFXO0FBQzVCLGdCQUFJO0FBQ0osZ0JBQUksWUFBWTtBQUNoQix1QkFBVyxLQUFLLE9BQU8sWUFBWSxXQUFXLFVBQVUsT0FBTztBQUMvRCxnQkFBSTtBQUNKLGtCQUFNLFdBQVcsQ0FBQyxDQUFDLEtBQUssWUFBWSxLQUFLO0FBQ3pDLGdCQUFJO0FBQ0osZ0JBQUksVUFBVTtBQUNaLGtCQUFJLFVBQVU7QUFDWixvQkFBSTtBQUFBLHFCQUNDO0FBQ0wsbUNBQW1CLEtBQUssUUFBUSxLQUFLO0FBQUE7QUFFdkMsb0JBQU0sYUFBYSxDQUFDLENBQUMsT0FBTyxZQUFZLEtBQUssS0FBSyxFQUFDLE1BQU0sVUFBVSxTQUFTO0FBQzVFLHFCQUFPLFlBQVk7QUFDbkIsa0JBQUksQ0FBQyxNQUFNO0FBQ1QsbUNBQW1CLEtBQUssUUFBUSxPQUFPO0FBQUE7QUFBQTtBQUczQyxnQkFBSTtBQUNKLGdCQUFJLEtBQUssT0FBTyxZQUFZO0FBQzVCLGdCQUFJO0FBQUE7QUFBQTtBQUdSLDRCQUFvQixLQUFLLE9BQU8sUUFBUTtBQUN0QyxnQkFBTSxFQUFDLEtBQUssV0FBVSxNQUFNLE1BQU07QUFDbEMsZ0JBQU0sRUFBQyxVQUFVLE9BQU8sUUFBTyxVQUFVO0FBQ3pDLGNBQUksYUFBYSxLQUFLO0FBQ3BCLGdCQUFJO0FBQ0osZ0JBQUksS0FBSyxPQUFPLEtBQUssTUFBTSxPQUFPLFNBQVM7QUFDM0MsZ0JBQUk7QUFBQTtBQUFBO0FBR1Isb0NBQTRCLEtBQUssUUFBUSxPQUFPLFVBQVU7QUFDeEQsZ0JBQU0sb0JBQW9CLE9BQU8sWUFBWSxPQUFPO0FBQ3BELGNBQUksbUJBQW1CO0FBQ3JCLGdCQUFJLE9BQU8sa0JBQWtCLEdBQUcsa0JBQWtCO0FBQUE7QUFBQTtBQUl0RCxZQUFJLFNBQVE7QUFBQSxVQUNWLElBQUk7QUFBQSxVQUNKLG9CQUFvQixRQUFPLE9BQU8sU0FBUztBQUN6QyxrQkFBTSxRQUFTLFFBQU0sS0FBSyxZQUFZLElBQUk7QUFDMUMsa0JBQU0sVUFBVTtBQUNoQixnQkFBSSxNQUFNLEdBQUcsTUFBTTtBQUNuQixpQkFBSyxJQUFJLEdBQUcsSUFBSSxPQUFPLEVBQUUsR0FBRztBQUMxQixxQkFBTyxPQUFNLGVBQWU7QUFDNUIscUJBQU8sS0FBSztBQUNaLHVCQUFTO0FBQ1Qsa0JBQUksUUFBUSxLQUFLLFdBQVcsZ0JBQWdCLGFBQWE7QUFDdkQseUJBQVM7QUFBQSxrQkFDUCxTQUFTLE9BQU0saUJBQWlCO0FBQUEsa0JBQ2hDLE9BQU87QUFBQSxrQkFDUCxNQUFNLFlBQVksTUFBTSxHQUFHO0FBQUEsa0JBQzNCO0FBQUEsa0JBQ0EsTUFBTSxLQUFLLFdBQVcsUUFBUTtBQUFBLGtCQUM5QixPQUFPLEtBQUs7QUFBQSxrQkFDWjtBQUFBO0FBQUE7QUFHSixtQkFBSyxVQUFVO0FBQ2Ysc0JBQVEsS0FBSztBQUFBO0FBRWYsaUJBQUssSUFBSSxHQUFHLElBQUksT0FBTyxFQUFFLEdBQUc7QUFDMUIsdUJBQVMsUUFBUTtBQUNqQixrQkFBSSxDQUFDLFVBQVUsT0FBTyxTQUFTLE9BQU87QUFDcEM7QUFBQTtBQUVGLHFCQUFPLE9BQU8sZUFBZSxTQUFTLEdBQUcsUUFBUTtBQUFBO0FBQUE7QUFBQSxVQUdyRCxXQUFXLFFBQU8sT0FBTyxTQUFTO0FBQ2hDLGtCQUFNLFFBQU8sUUFBUSxhQUFhO0FBQ2xDLGtCQUFNLFdBQVcsT0FBTTtBQUN2QixrQkFBTSxPQUFPLE9BQU07QUFDbkIscUJBQVMsSUFBSSxTQUFTLFNBQVMsR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQzdDLG9CQUFNLFNBQVMsU0FBUyxHQUFHO0FBQzNCLGtCQUFJLENBQUMsUUFBUTtBQUNYO0FBQUE7QUFFRixxQkFBTyxLQUFLLG9CQUFvQixNQUFNLE9BQU87QUFDN0Msa0JBQUksU0FBUSxPQUFPLE1BQU07QUFDdkIsMEJBQVUsT0FBTSxLQUFLLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUluQyxtQkFBbUIsUUFBTyxPQUFPLFNBQVM7QUFDeEMsZ0JBQUksUUFBUSxhQUFhLHNCQUFzQjtBQUM3QztBQUFBO0FBRUYsa0JBQU0sV0FBVyxPQUFNO0FBQ3ZCLHFCQUFTLElBQUksU0FBUyxTQUFTLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUM3QyxvQkFBTSxTQUFTLFNBQVMsR0FBRztBQUMzQixrQkFBSSxpQkFBaUIsU0FBUztBQUM1QiwwQkFBVSxPQUFNLEtBQUssUUFBUSxPQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFJekMsa0JBQWtCLFFBQU8sTUFBTSxTQUFTO0FBQ3RDLGtCQUFNLFNBQVMsS0FBSyxLQUFLO0FBQ3pCLGdCQUFJLENBQUMsaUJBQWlCLFdBQVcsUUFBUSxhQUFhLHFCQUFxQjtBQUN6RTtBQUFBO0FBRUYsc0JBQVUsT0FBTSxLQUFLLFFBQVEsT0FBTTtBQUFBO0FBQUEsVUFFckMsVUFBVTtBQUFBLFlBQ1IsV0FBVztBQUFBLFlBQ1gsVUFBVTtBQUFBO0FBQUE7QUFJZCxjQUFNLGFBQWEsQ0FBQyxXQUFXLGFBQWE7QUFDMUMsY0FBSSxFQUFDLFlBQVksVUFBVSxXQUFXLGFBQVk7QUFDbEQsY0FBSSxVQUFVLGVBQWU7QUFDM0Isd0JBQVksS0FBSyxJQUFJLFdBQVc7QUFDaEMsdUJBQVcsVUFBVSxtQkFBbUIsS0FBSyxJQUFJLFVBQVU7QUFBQTtBQUU3RCxpQkFBTztBQUFBLFlBQ0w7QUFBQSxZQUNBO0FBQUEsWUFDQSxZQUFZLEtBQUssSUFBSSxVQUFVO0FBQUE7QUFBQTtBQUduQyxjQUFNLGFBQWEsQ0FBQyxHQUFHLE1BQU0sTUFBTSxRQUFRLE1BQU0sUUFBUSxFQUFFLGlCQUFpQixFQUFFLGdCQUFnQixFQUFFLFVBQVUsRUFBRTtBQUM1Ryw2QkFBcUIsU0FBUTtBQUFBLFVBQzNCLFlBQVksUUFBUTtBQUNsQjtBQUNBLGlCQUFLLFNBQVM7QUFDZCxpQkFBSyxpQkFBaUI7QUFDdEIsaUJBQUssZUFBZTtBQUNwQixpQkFBSyxlQUFlO0FBQ3BCLGlCQUFLLFFBQVEsT0FBTztBQUNwQixpQkFBSyxVQUFVLE9BQU87QUFDdEIsaUJBQUssTUFBTSxPQUFPO0FBQ2xCLGlCQUFLLGNBQWM7QUFDbkIsaUJBQUssY0FBYztBQUNuQixpQkFBSyxhQUFhO0FBQ2xCLGlCQUFLLFlBQVk7QUFDakIsaUJBQUssV0FBVztBQUNoQixpQkFBSyxNQUFNO0FBQ1gsaUJBQUssU0FBUztBQUNkLGlCQUFLLE9BQU87QUFDWixpQkFBSyxRQUFRO0FBQ2IsaUJBQUssU0FBUztBQUNkLGlCQUFLLFFBQVE7QUFDYixpQkFBSyxXQUFXO0FBQ2hCLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssU0FBUztBQUNkLGlCQUFLLFdBQVc7QUFBQTtBQUFBLFVBRWxCLE9BQU8sVUFBVSxXQUFXLFNBQVM7QUFDbkMsaUJBQUssV0FBVztBQUNoQixpQkFBSyxZQUFZO0FBQ2pCLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUs7QUFDTCxpQkFBSztBQUNMLGlCQUFLO0FBQUE7QUFBQSxVQUVQLGdCQUFnQjtBQUNkLGdCQUFJLEtBQUssZ0JBQWdCO0FBQ3ZCLG1CQUFLLFFBQVEsS0FBSztBQUNsQixtQkFBSyxPQUFPLEtBQUssU0FBUztBQUMxQixtQkFBSyxRQUFRLEtBQUs7QUFBQSxtQkFDYjtBQUNMLG1CQUFLLFNBQVMsS0FBSztBQUNuQixtQkFBSyxNQUFNLEtBQUssU0FBUztBQUN6QixtQkFBSyxTQUFTLEtBQUs7QUFBQTtBQUFBO0FBQUEsVUFHdkIsY0FBYztBQUNaLGtCQUFNLFlBQVksS0FBSyxRQUFRLFVBQVU7QUFDekMsZ0JBQUksY0FBYyxTQUFTLFVBQVUsZ0JBQWdCLENBQUMsS0FBSyxRQUFRLFNBQVM7QUFDNUUsZ0JBQUksVUFBVSxRQUFRO0FBQ3BCLDRCQUFjLFlBQVksT0FBTyxDQUFDLFNBQVMsVUFBVSxPQUFPLE1BQU0sS0FBSyxNQUFNO0FBQUE7QUFFL0UsZ0JBQUksVUFBVSxNQUFNO0FBQ2xCLDRCQUFjLFlBQVksS0FBSyxDQUFDLEdBQUcsTUFBTSxVQUFVLEtBQUssR0FBRyxHQUFHLEtBQUssTUFBTTtBQUFBO0FBRTNFLGdCQUFJLEtBQUssUUFBUSxTQUFTO0FBQ3hCLDBCQUFZO0FBQUE7QUFFZCxpQkFBSyxjQUFjO0FBQUE7QUFBQSxVQUVyQixNQUFNO0FBQ0osa0JBQU0sRUFBQyxTQUFTLFFBQU87QUFDdkIsZ0JBQUksQ0FBQyxRQUFRLFNBQVM7QUFDcEIsbUJBQUssUUFBUSxLQUFLLFNBQVM7QUFDM0I7QUFBQTtBQUVGLGtCQUFNLFlBQVksUUFBUTtBQUMxQixrQkFBTSxZQUFZLE9BQU8sVUFBVTtBQUNuQyxrQkFBTSxXQUFXLFVBQVU7QUFDM0Isa0JBQU0sY0FBYyxLQUFLO0FBQ3pCLGtCQUFNLEVBQUMsVUFBVSxlQUFjLFdBQVcsV0FBVztBQUNyRCxnQkFBSSxPQUFPO0FBQ1gsZ0JBQUksT0FBTyxVQUFVO0FBQ3JCLGdCQUFJLEtBQUssZ0JBQWdCO0FBQ3ZCLHNCQUFRLEtBQUs7QUFDYix1QkFBUyxLQUFLLFNBQVMsYUFBYSxVQUFVLFVBQVUsY0FBYztBQUFBLG1CQUNqRTtBQUNMLHVCQUFTLEtBQUs7QUFDZCxzQkFBUSxLQUFLLFNBQVMsYUFBYSxVQUFVLFVBQVUsY0FBYztBQUFBO0FBRXZFLGlCQUFLLFFBQVEsS0FBSyxJQUFJLE9BQU8sUUFBUSxZQUFZLEtBQUs7QUFDdEQsaUJBQUssU0FBUyxLQUFLLElBQUksUUFBUSxRQUFRLGFBQWEsS0FBSztBQUFBO0FBQUEsVUFFM0QsU0FBUyxhQUFhLFVBQVUsVUFBVSxZQUFZO0FBQ3BELGtCQUFNLEVBQUMsS0FBSyxVQUFVLFNBQVMsRUFBQyxRQUFRLEVBQUMsZ0JBQWE7QUFDdEQsa0JBQU0sV0FBVyxLQUFLLGlCQUFpQjtBQUN2QyxrQkFBTSxhQUFhLEtBQUssYUFBYSxDQUFDO0FBQ3RDLGtCQUFNLGFBQWEsYUFBYTtBQUNoQyxnQkFBSSxjQUFjO0FBQ2xCLGdCQUFJLFlBQVk7QUFDaEIsZ0JBQUksZUFBZTtBQUNuQixnQkFBSSxNQUFNO0FBQ1YsZ0JBQUksTUFBTSxDQUFDO0FBQ1gsaUJBQUssWUFBWSxRQUFRLENBQUMsWUFBWSxNQUFNO0FBQzFDLG9CQUFNLFlBQVksV0FBWSxXQUFXLElBQUssSUFBSSxZQUFZLFdBQVcsTUFBTTtBQUMvRSxrQkFBSSxNQUFNLEtBQUssV0FBVyxXQUFXLFNBQVMsS0FBSyxZQUFZLElBQUksVUFBVSxVQUFVO0FBQ3JGLCtCQUFlO0FBQ2YsMkJBQVcsV0FBVyxTQUFVLEtBQUksSUFBSSxJQUFJLE1BQU07QUFDbEQsdUJBQU87QUFDUDtBQUFBO0FBRUYsdUJBQVMsS0FBSyxFQUFDLE1BQU0sR0FBRyxLQUFLLEtBQUssT0FBTyxXQUFXLFFBQVE7QUFDNUQseUJBQVcsV0FBVyxTQUFTLE1BQU0sWUFBWTtBQUFBO0FBRW5ELG1CQUFPO0FBQUE7QUFBQSxVQUVULFNBQVMsYUFBYSxVQUFVLFVBQVUsWUFBWTtBQUNwRCxrQkFBTSxFQUFDLEtBQUssV0FBVyxTQUFTLEVBQUMsUUFBUSxFQUFDLGdCQUFhO0FBQ3ZELGtCQUFNLFdBQVcsS0FBSyxpQkFBaUI7QUFDdkMsa0JBQU0sY0FBYyxLQUFLLGNBQWM7QUFDdkMsa0JBQU0sY0FBYyxZQUFZO0FBQ2hDLGdCQUFJLGFBQWE7QUFDakIsZ0JBQUksa0JBQWtCO0FBQ3RCLGdCQUFJLG1CQUFtQjtBQUN2QixnQkFBSSxPQUFPO0FBQ1gsZ0JBQUksTUFBTTtBQUNWLGlCQUFLLFlBQVksUUFBUSxDQUFDLFlBQVksTUFBTTtBQUMxQyxvQkFBTSxZQUFZLFdBQVksV0FBVyxJQUFLLElBQUksWUFBWSxXQUFXLE1BQU07QUFDL0Usa0JBQUksSUFBSSxLQUFLLG1CQUFtQixhQUFhLElBQUksVUFBVSxhQUFhO0FBQ3RFLDhCQUFjLGtCQUFrQjtBQUNoQyw0QkFBWSxLQUFLLEVBQUMsT0FBTyxpQkFBaUIsUUFBUTtBQUNsRCx3QkFBUSxrQkFBa0I7QUFDMUI7QUFDQSxrQ0FBa0IsbUJBQW1CO0FBQUE7QUFFdkMsdUJBQVMsS0FBSyxFQUFDLE1BQU0sS0FBSyxrQkFBa0IsS0FBSyxPQUFPLFdBQVcsUUFBUTtBQUMzRSxnQ0FBa0IsS0FBSyxJQUFJLGlCQUFpQjtBQUM1QyxrQ0FBb0IsYUFBYTtBQUFBO0FBRW5DLDBCQUFjO0FBQ2Qsd0JBQVksS0FBSyxFQUFDLE9BQU8saUJBQWlCLFFBQVE7QUFDbEQsbUJBQU87QUFBQTtBQUFBLFVBRVQsaUJBQWlCO0FBQ2YsZ0JBQUksQ0FBQyxLQUFLLFFBQVEsU0FBUztBQUN6QjtBQUFBO0FBRUYsa0JBQU0sY0FBYyxLQUFLO0FBQ3pCLGtCQUFNLEVBQUMsZ0JBQWdCLFVBQVUsU0FBUyxFQUFDLE9BQU8sUUFBUSxFQUFDLFdBQVUsVUFBUTtBQUM3RSxrQkFBTSxZQUFZLGNBQWMsS0FBSyxLQUFLLE1BQU0sS0FBSztBQUNyRCxnQkFBSSxLQUFLLGdCQUFnQjtBQUN2QixrQkFBSSxNQUFNO0FBQ1Ysa0JBQUksT0FBTyxlQUFlLE9BQU8sS0FBSyxPQUFPLFNBQVMsS0FBSyxRQUFRLEtBQUssV0FBVztBQUNuRix5QkFBVyxVQUFVLFVBQVU7QUFDN0Isb0JBQUksUUFBUSxPQUFPLEtBQUs7QUFDdEIsd0JBQU0sT0FBTztBQUNiLHlCQUFPLGVBQWUsT0FBTyxLQUFLLE9BQU8sU0FBUyxLQUFLLFFBQVEsS0FBSyxXQUFXO0FBQUE7QUFFakYsdUJBQU8sT0FBTyxLQUFLLE1BQU0sY0FBYztBQUN2Qyx1QkFBTyxPQUFPLFVBQVUsV0FBVyxVQUFVLEVBQUUsT0FBTyxPQUFPO0FBQzdELHdCQUFRLE9BQU8sUUFBUTtBQUFBO0FBQUEsbUJBRXBCO0FBQ0wsa0JBQUksTUFBTTtBQUNWLGtCQUFJLE1BQU0sZUFBZSxPQUFPLEtBQUssTUFBTSxjQUFjLFNBQVMsS0FBSyxTQUFTLEtBQUssWUFBWSxLQUFLO0FBQ3RHLHlCQUFXLFVBQVUsVUFBVTtBQUM3QixvQkFBSSxPQUFPLFFBQVEsS0FBSztBQUN0Qix3QkFBTSxPQUFPO0FBQ2Isd0JBQU0sZUFBZSxPQUFPLEtBQUssTUFBTSxjQUFjLFNBQVMsS0FBSyxTQUFTLEtBQUssWUFBWSxLQUFLO0FBQUE7QUFFcEcsdUJBQU8sTUFBTTtBQUNiLHVCQUFPLFFBQVEsS0FBSyxPQUFPO0FBQzNCLHVCQUFPLE9BQU8sVUFBVSxXQUFXLFVBQVUsRUFBRSxPQUFPLE9BQU8sT0FBTztBQUNwRSx1QkFBTyxPQUFPLFNBQVM7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUk3QixlQUFlO0FBQ2IsbUJBQU8sS0FBSyxRQUFRLGFBQWEsU0FBUyxLQUFLLFFBQVEsYUFBYTtBQUFBO0FBQUEsVUFFdEUsT0FBTztBQUNMLGdCQUFJLEtBQUssUUFBUSxTQUFTO0FBQ3hCLG9CQUFNLE1BQU0sS0FBSztBQUNqQix1QkFBUyxLQUFLO0FBQ2QsbUJBQUs7QUFDTCx5QkFBVztBQUFBO0FBQUE7QUFBQSxVQUdmLFFBQVE7QUFDTixrQkFBTSxFQUFDLFNBQVMsTUFBTSxhQUFhLFlBQVksUUFBTztBQUN0RCxrQkFBTSxFQUFDLE9BQU8sUUFBUSxjQUFhO0FBQ25DLGtCQUFNLGVBQWUsU0FBUztBQUM5QixrQkFBTSxZQUFZLGNBQWMsS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLO0FBQzFELGtCQUFNLFlBQVksT0FBTyxVQUFVO0FBQ25DLGtCQUFNLEVBQUMsT0FBTyxXQUFXLFlBQVc7QUFDcEMsa0JBQU0sV0FBVyxVQUFVO0FBQzNCLGtCQUFNLGVBQWUsV0FBVztBQUNoQyxnQkFBSTtBQUNKLGlCQUFLO0FBQ0wsZ0JBQUksWUFBWSxVQUFVLFVBQVU7QUFDcEMsZ0JBQUksZUFBZTtBQUNuQixnQkFBSSxZQUFZO0FBQ2hCLGdCQUFJLE9BQU8sVUFBVTtBQUNyQixrQkFBTSxFQUFDLFVBQVUsV0FBVyxlQUFjLFdBQVcsV0FBVztBQUNoRSxrQkFBTSxnQkFBZ0IsU0FBUyxHQUFHLEdBQUcsWUFBWTtBQUMvQyxrQkFBSSxNQUFNLGFBQWEsWUFBWSxLQUFLLE1BQU0sY0FBYyxZQUFZLEdBQUc7QUFDekU7QUFBQTtBQUVGLGtCQUFJO0FBQ0osb0JBQU0sWUFBWSxlQUFlLFdBQVcsV0FBVztBQUN2RCxrQkFBSSxZQUFZLGVBQWUsV0FBVyxXQUFXO0FBQ3JELGtCQUFJLFVBQVUsZUFBZSxXQUFXLFNBQVM7QUFDakQsa0JBQUksaUJBQWlCLGVBQWUsV0FBVyxnQkFBZ0I7QUFDL0Qsa0JBQUksV0FBVyxlQUFlLFdBQVcsVUFBVTtBQUNuRCxrQkFBSSxZQUFZO0FBQ2hCLGtCQUFJLGNBQWMsZUFBZSxXQUFXLGFBQWE7QUFDekQsa0JBQUksWUFBWSxlQUFlLFdBQVcsVUFBVTtBQUNwRCxrQkFBSSxVQUFVLGVBQWU7QUFDM0Isc0JBQU0sY0FBYztBQUFBLGtCQUNsQixRQUFRLFlBQVksS0FBSyxRQUFRO0FBQUEsa0JBQ2pDLFlBQVksV0FBVztBQUFBLGtCQUN2QixVQUFVLFdBQVc7QUFBQSxrQkFDckIsYUFBYTtBQUFBO0FBRWYsc0JBQU0sVUFBVSxVQUFVLE1BQU0sR0FBRyxXQUFXO0FBQzlDLHNCQUFNLFVBQVUsSUFBSTtBQUNwQixnQ0FBZ0IsS0FBSyxhQUFhLFNBQVMsU0FBUyxVQUFVLG1CQUFtQjtBQUFBLHFCQUM1RTtBQUNMLHNCQUFNLFVBQVUsSUFBSSxLQUFLLElBQUssWUFBVyxhQUFhLEdBQUc7QUFDekQsc0JBQU0sV0FBVyxVQUFVLFdBQVcsR0FBRztBQUN6QyxzQkFBTSxlQUFlLGNBQWMsV0FBVztBQUM5QyxvQkFBSTtBQUNKLG9CQUFJLE9BQU8sT0FBTyxjQUFjLEtBQUssT0FBSyxNQUFNLElBQUk7QUFDbEQscUNBQW1CLEtBQUs7QUFBQSxvQkFDdEIsR0FBRztBQUFBLG9CQUNILEdBQUc7QUFBQSxvQkFDSCxHQUFHO0FBQUEsb0JBQ0gsR0FBRztBQUFBLG9CQUNILFFBQVE7QUFBQTtBQUFBLHVCQUVMO0FBQ0wsc0JBQUksS0FBSyxVQUFVLFNBQVMsVUFBVTtBQUFBO0FBRXhDLG9CQUFJO0FBQ0osb0JBQUksY0FBYyxHQUFHO0FBQ25CLHNCQUFJO0FBQUE7QUFBQTtBQUdSLGtCQUFJO0FBQUE7QUFFTixrQkFBTSxXQUFXLFNBQVMsR0FBRyxHQUFHLFlBQVk7QUFDMUMseUJBQVcsS0FBSyxXQUFXLE1BQU0sR0FBRyxJQUFLLGFBQWEsR0FBSSxXQUFXO0FBQUEsZ0JBQ25FLGVBQWUsV0FBVztBQUFBLGdCQUMxQixXQUFXLFVBQVUsVUFBVSxXQUFXO0FBQUE7QUFBQTtBQUc5QyxrQkFBTSxlQUFlLEtBQUs7QUFDMUIsa0JBQU0sY0FBYyxLQUFLO0FBQ3pCLGdCQUFJLGNBQWM7QUFDaEIsdUJBQVM7QUFBQSxnQkFDUCxHQUFHLGVBQWUsT0FBTyxLQUFLLE9BQU8sU0FBUyxLQUFLLFFBQVEsV0FBVztBQUFBLGdCQUN0RSxHQUFHLEtBQUssTUFBTSxVQUFVO0FBQUEsZ0JBQ3hCLE1BQU07QUFBQTtBQUFBLG1CQUVIO0FBQ0wsdUJBQVM7QUFBQSxnQkFDUCxHQUFHLEtBQUssT0FBTztBQUFBLGdCQUNmLEdBQUcsZUFBZSxPQUFPLEtBQUssTUFBTSxjQUFjLFNBQVMsS0FBSyxTQUFTLFlBQVksR0FBRztBQUFBLGdCQUN4RixNQUFNO0FBQUE7QUFBQTtBQUdWLGtDQUFzQixLQUFLLEtBQUssS0FBSztBQUNyQyxrQkFBTSxhQUFhLGFBQWE7QUFDaEMsaUJBQUssWUFBWSxRQUFRLENBQUMsWUFBWSxNQUFNO0FBQzFDLGtCQUFJLGNBQWMsV0FBVyxhQUFhO0FBQzFDLGtCQUFJLFlBQVksV0FBVyxhQUFhO0FBQ3hDLG9CQUFNLFlBQVksSUFBSSxZQUFZLFdBQVcsTUFBTTtBQUNuRCxvQkFBTSxZQUFZLFVBQVUsVUFBVSxXQUFXLGFBQWMsWUFBVyxZQUFZLFVBQVU7QUFDaEcsb0JBQU0sUUFBUSxXQUFXLGVBQWU7QUFDeEMsa0JBQUksSUFBSSxPQUFPO0FBQ2Ysa0JBQUksSUFBSSxPQUFPO0FBQ2Ysd0JBQVUsU0FBUyxLQUFLO0FBQ3hCLGtCQUFJLGNBQWM7QUFDaEIsb0JBQUksSUFBSSxLQUFLLElBQUksUUFBUSxVQUFVLEtBQUssT0FBTztBQUM3QyxzQkFBSSxPQUFPLEtBQUs7QUFDaEIseUJBQU87QUFDUCxzQkFBSSxPQUFPLElBQUksZUFBZSxPQUFPLEtBQUssT0FBTyxTQUFTLEtBQUssUUFBUSxXQUFXLE9BQU87QUFBQTtBQUFBLHlCQUVsRixJQUFJLEtBQUssSUFBSSxhQUFhLEtBQUssUUFBUTtBQUNoRCxvQkFBSSxPQUFPLElBQUksSUFBSSxZQUFZLE9BQU8sTUFBTSxRQUFRO0FBQ3BELHVCQUFPO0FBQ1Asb0JBQUksT0FBTyxJQUFJLGVBQWUsT0FBTyxLQUFLLE1BQU0sY0FBYyxTQUFTLEtBQUssU0FBUyxZQUFZLE9BQU8sTUFBTTtBQUFBO0FBRWhILG9CQUFNLFFBQVEsVUFBVSxFQUFFO0FBQzFCLDRCQUFjLE9BQU8sR0FBRztBQUN4QixrQkFBSSxPQUFPLFdBQVcsSUFBSSxXQUFXLGNBQWMsZUFBZSxJQUFJLFFBQVEsS0FBSyxPQUFPLEtBQUs7QUFDL0YsdUJBQVMsVUFBVSxFQUFFLElBQUksR0FBRztBQUM1QixrQkFBSSxjQUFjO0FBQ2hCLHVCQUFPLEtBQUssUUFBUTtBQUFBLHFCQUNmO0FBQ0wsdUJBQU8sS0FBSztBQUFBO0FBQUE7QUFHaEIsaUNBQXFCLEtBQUssS0FBSyxLQUFLO0FBQUE7QUFBQSxVQUV0QyxZQUFZO0FBQ1Ysa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLFlBQVksS0FBSztBQUN2QixrQkFBTSxZQUFZLE9BQU8sVUFBVTtBQUNuQyxrQkFBTSxlQUFlLFVBQVUsVUFBVTtBQUN6QyxnQkFBSSxDQUFDLFVBQVUsU0FBUztBQUN0QjtBQUFBO0FBRUYsa0JBQU0sWUFBWSxjQUFjLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSztBQUMxRCxrQkFBTSxNQUFNLEtBQUs7QUFDakIsa0JBQU0sV0FBVyxVQUFVO0FBQzNCLGtCQUFNLGVBQWUsVUFBVSxPQUFPO0FBQ3RDLGtCQUFNLDZCQUE2QixhQUFhLE1BQU07QUFDdEQsZ0JBQUk7QUFDSixnQkFBSSxPQUFPLEtBQUs7QUFDaEIsZ0JBQUksV0FBVyxLQUFLO0FBQ3BCLGdCQUFJLEtBQUssZ0JBQWdCO0FBQ3ZCLHlCQUFXLEtBQUssSUFBSSxHQUFHLEtBQUs7QUFDNUIsa0JBQUksS0FBSyxNQUFNO0FBQ2YscUJBQU8sZUFBZSxLQUFLLE9BQU8sTUFBTSxLQUFLLFFBQVE7QUFBQSxtQkFDaEQ7QUFDTCxvQkFBTSxZQUFZLEtBQUssWUFBWSxPQUFPLENBQUMsS0FBSyxTQUFTLEtBQUssSUFBSSxLQUFLLEtBQUssU0FBUztBQUNyRixrQkFBSSw2QkFBNkIsZUFBZSxLQUFLLE9BQU8sS0FBSyxLQUFLLEtBQUssU0FBUyxZQUFZLEtBQUssT0FBTyxVQUFVLEtBQUs7QUFBQTtBQUU3SCxrQkFBTSxJQUFJLGVBQWUsVUFBVSxNQUFNLE9BQU87QUFDaEQsZ0JBQUksWUFBWSxVQUFVLFVBQVUsbUJBQW1CO0FBQ3ZELGdCQUFJLGVBQWU7QUFDbkIsZ0JBQUksY0FBYyxVQUFVO0FBQzVCLGdCQUFJLFlBQVksVUFBVTtBQUMxQixnQkFBSSxPQUFPLFVBQVU7QUFDckIsdUJBQVcsS0FBSyxVQUFVLE1BQU0sR0FBRyxHQUFHO0FBQUE7QUFBQSxVQUV4QyxzQkFBc0I7QUFDcEIsa0JBQU0sWUFBWSxLQUFLLFFBQVE7QUFDL0Isa0JBQU0sWUFBWSxPQUFPLFVBQVU7QUFDbkMsa0JBQU0sZUFBZSxVQUFVLFVBQVU7QUFDekMsbUJBQU8sVUFBVSxVQUFVLFVBQVUsYUFBYSxhQUFhLFNBQVM7QUFBQTtBQUFBLFVBRTFFLGlCQUFpQixHQUFHLEdBQUc7QUFDckIsZ0JBQUksR0FBRyxRQUFRO0FBQ2YsZ0JBQUksV0FBVyxHQUFHLEtBQUssTUFBTSxLQUFLLFVBQzdCLFdBQVcsR0FBRyxLQUFLLEtBQUssS0FBSyxTQUFTO0FBQ3pDLG1CQUFLLEtBQUs7QUFDVixtQkFBSyxJQUFJLEdBQUcsSUFBSSxHQUFHLFFBQVEsRUFBRSxHQUFHO0FBQzlCLHlCQUFTLEdBQUc7QUFDWixvQkFBSSxXQUFXLEdBQUcsT0FBTyxNQUFNLE9BQU8sT0FBTyxPQUFPLFVBQy9DLFdBQVcsR0FBRyxPQUFPLEtBQUssT0FBTyxNQUFNLE9BQU8sU0FBUztBQUMxRCx5QkFBTyxLQUFLLFlBQVk7QUFBQTtBQUFBO0FBQUE7QUFJOUIsbUJBQU87QUFBQTtBQUFBLFVBRVQsWUFBWSxHQUFHO0FBQ2Isa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGdCQUFJLENBQUMsV0FBVyxFQUFFLE1BQU0sT0FBTztBQUM3QjtBQUFBO0FBRUYsa0JBQU0sY0FBYyxLQUFLLGlCQUFpQixFQUFFLEdBQUcsRUFBRTtBQUNqRCxnQkFBSSxFQUFFLFNBQVMsZUFBZSxFQUFFLFNBQVMsWUFBWTtBQUNuRCxvQkFBTSxXQUFXLEtBQUs7QUFDdEIsb0JBQU0sV0FBVyxXQUFXLFVBQVU7QUFDdEMsa0JBQUksWUFBWSxDQUFDLFVBQVU7QUFDekIseUJBQVMsS0FBSyxTQUFTLENBQUMsR0FBRyxVQUFVLE9BQU87QUFBQTtBQUU5QyxtQkFBSyxlQUFlO0FBQ3BCLGtCQUFJLGVBQWUsQ0FBQyxVQUFVO0FBQzVCLHlCQUFTLEtBQUssU0FBUyxDQUFDLEdBQUcsYUFBYSxPQUFPO0FBQUE7QUFBQSx1QkFFeEMsYUFBYTtBQUN0Qix1QkFBUyxLQUFLLFNBQVMsQ0FBQyxHQUFHLGFBQWEsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUlyRCw0QkFBb0IsTUFBTSxNQUFNO0FBQzlCLGNBQUssVUFBUyxlQUFlLFNBQVMsZUFBZ0IsTUFBSyxXQUFXLEtBQUssVUFBVTtBQUNuRixtQkFBTztBQUFBO0FBRVQsY0FBSSxLQUFLLFdBQVksVUFBUyxXQUFXLFNBQVMsWUFBWTtBQUM1RCxtQkFBTztBQUFBO0FBRVQsaUJBQU87QUFBQTtBQUVULFlBQUksZ0JBQWdCO0FBQUEsVUFDbEIsSUFBSTtBQUFBLFVBQ0osVUFBVTtBQUFBLFVBQ1YsTUFBTSxRQUFPLE9BQU8sU0FBUztBQUMzQixrQkFBTSxTQUFTLE9BQU0sU0FBUyxJQUFJLE9BQU8sRUFBQyxLQUFLLE9BQU0sS0FBSyxTQUFTO0FBQ25FLG9CQUFRLFVBQVUsUUFBTyxRQUFRO0FBQ2pDLG9CQUFRLE9BQU8sUUFBTztBQUFBO0FBQUEsVUFFeEIsS0FBSyxRQUFPO0FBQ1Ysb0JBQVEsVUFBVSxRQUFPLE9BQU07QUFDL0IsbUJBQU8sT0FBTTtBQUFBO0FBQUEsVUFFZixhQUFhLFFBQU8sT0FBTyxTQUFTO0FBQ2xDLGtCQUFNLFNBQVMsT0FBTTtBQUNyQixvQkFBUSxVQUFVLFFBQU8sUUFBUTtBQUNqQyxtQkFBTyxVQUFVO0FBQUE7QUFBQSxVQUVuQixZQUFZLFFBQU87QUFDakIsa0JBQU0sU0FBUyxPQUFNO0FBQ3JCLG1CQUFPO0FBQ1AsbUJBQU87QUFBQTtBQUFBLFVBRVQsV0FBVyxRQUFPLE1BQU07QUFDdEIsZ0JBQUksQ0FBQyxLQUFLLFFBQVE7QUFDaEIscUJBQU0sT0FBTyxZQUFZLEtBQUs7QUFBQTtBQUFBO0FBQUEsVUFHbEMsVUFBVTtBQUFBLFlBQ1IsU0FBUztBQUFBLFlBQ1QsVUFBVTtBQUFBLFlBQ1YsT0FBTztBQUFBLFlBQ1AsVUFBVTtBQUFBLFlBQ1YsU0FBUztBQUFBLFlBQ1QsUUFBUTtBQUFBLFlBQ1IsUUFBUSxHQUFHLFlBQVksUUFBUTtBQUM3QixvQkFBTSxTQUFRLFdBQVc7QUFDekIsb0JBQU0sS0FBSyxPQUFPO0FBQ2xCLGtCQUFJLEdBQUcsaUJBQWlCLFNBQVE7QUFDOUIsbUJBQUcsS0FBSztBQUNSLDJCQUFXLFNBQVM7QUFBQSxxQkFDZjtBQUNMLG1CQUFHLEtBQUs7QUFDUiwyQkFBVyxTQUFTO0FBQUE7QUFBQTtBQUFBLFlBR3hCLFNBQVM7QUFBQSxZQUNULFNBQVM7QUFBQSxZQUNULFFBQVE7QUFBQSxjQUNOLE9BQU8sQ0FBQyxRQUFRLElBQUksTUFBTSxRQUFRO0FBQUEsY0FDbEMsVUFBVTtBQUFBLGNBQ1YsU0FBUztBQUFBLGNBQ1QsZUFBZSxRQUFPO0FBQ3BCLHNCQUFNLFdBQVcsT0FBTSxLQUFLO0FBQzVCLHNCQUFNLEVBQUMsUUFBUSxFQUFDLGVBQWUsWUFBWSxXQUFXLG9CQUFVLE9BQU0sT0FBTztBQUM3RSx1QkFBTyxPQUFNLHlCQUF5QixJQUFJLENBQUMsU0FBUztBQUNsRCx3QkFBTSxRQUFRLEtBQUssV0FBVyxTQUFTLGdCQUFnQixJQUFJO0FBQzNELHdCQUFNLGNBQWMsVUFBVSxNQUFNO0FBQ3BDLHlCQUFPO0FBQUEsb0JBQ0wsTUFBTSxTQUFTLEtBQUssT0FBTztBQUFBLG9CQUMzQixXQUFXLE1BQU07QUFBQSxvQkFDakIsV0FBVztBQUFBLG9CQUNYLFFBQVEsQ0FBQyxLQUFLO0FBQUEsb0JBQ2QsU0FBUyxNQUFNO0FBQUEsb0JBQ2YsVUFBVSxNQUFNO0FBQUEsb0JBQ2hCLGdCQUFnQixNQUFNO0FBQUEsb0JBQ3RCLFVBQVUsTUFBTTtBQUFBLG9CQUNoQixXQUFZLGFBQVksUUFBUSxZQUFZLFVBQVU7QUFBQSxvQkFDdEQsYUFBYSxNQUFNO0FBQUEsb0JBQ25CLFlBQVksY0FBYyxNQUFNO0FBQUEsb0JBQ2hDLFVBQVUsTUFBTTtBQUFBLG9CQUNoQixXQUFXLGFBQWEsTUFBTTtBQUFBLG9CQUM5QixjQUFjO0FBQUEsb0JBQ2QsY0FBYyxLQUFLO0FBQUE7QUFBQSxtQkFFcEI7QUFBQTtBQUFBO0FBQUEsWUFHUCxPQUFPO0FBQUEsY0FDTCxPQUFPLENBQUMsUUFBUSxJQUFJLE1BQU0sUUFBUTtBQUFBLGNBQ2xDLFNBQVM7QUFBQSxjQUNULFVBQVU7QUFBQSxjQUNWLE1BQU07QUFBQTtBQUFBO0FBQUEsVUFHVixhQUFhO0FBQUEsWUFDWCxhQUFhLENBQUMsU0FBUyxDQUFDLEtBQUssV0FBVztBQUFBLFlBQ3hDLFFBQVE7QUFBQSxjQUNOLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxrQkFBa0IsVUFBVSxRQUFRLFNBQVM7QUFBQTtBQUFBO0FBQUE7QUFLNUUsNEJBQW9CLFNBQVE7QUFBQSxVQUMxQixZQUFZLFFBQVE7QUFDbEI7QUFDQSxpQkFBSyxRQUFRLE9BQU87QUFDcEIsaUJBQUssVUFBVSxPQUFPO0FBQ3RCLGlCQUFLLE1BQU0sT0FBTztBQUNsQixpQkFBSyxXQUFXO0FBQ2hCLGlCQUFLLE1BQU07QUFDWCxpQkFBSyxTQUFTO0FBQ2QsaUJBQUssT0FBTztBQUNaLGlCQUFLLFFBQVE7QUFDYixpQkFBSyxRQUFRO0FBQ2IsaUJBQUssU0FBUztBQUNkLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssU0FBUztBQUNkLGlCQUFLLFdBQVc7QUFBQTtBQUFBLFVBRWxCLE9BQU8sVUFBVSxXQUFXO0FBQzFCLGtCQUFNLE9BQU8sS0FBSztBQUNsQixpQkFBSyxPQUFPO0FBQ1osaUJBQUssTUFBTTtBQUNYLGdCQUFJLENBQUMsS0FBSyxTQUFTO0FBQ2pCLG1CQUFLLFFBQVEsS0FBSyxTQUFTLEtBQUssUUFBUSxLQUFLLFNBQVM7QUFDdEQ7QUFBQTtBQUVGLGlCQUFLLFFBQVEsS0FBSyxRQUFRO0FBQzFCLGlCQUFLLFNBQVMsS0FBSyxTQUFTO0FBQzVCLGtCQUFNLFlBQVksUUFBUSxLQUFLLFFBQVEsS0FBSyxLQUFLLFNBQVM7QUFDMUQsaUJBQUssV0FBVyxVQUFVLEtBQUs7QUFDL0Isa0JBQU0sV0FBVyxZQUFZLE9BQU8sS0FBSyxNQUFNLGFBQWEsS0FBSyxTQUFTO0FBQzFFLGdCQUFJLEtBQUssZ0JBQWdCO0FBQ3ZCLG1CQUFLLFNBQVM7QUFBQSxtQkFDVDtBQUNMLG1CQUFLLFFBQVE7QUFBQTtBQUFBO0FBQUEsVUFHakIsZUFBZTtBQUNiLGtCQUFNLE1BQU0sS0FBSyxRQUFRO0FBQ3pCLG1CQUFPLFFBQVEsU0FBUyxRQUFRO0FBQUE7QUFBQSxVQUVsQyxVQUFVLFFBQVE7QUFDaEIsa0JBQU0sRUFBQyxLQUFLLE1BQU0sUUFBUSxPQUFPLFlBQVc7QUFDNUMsa0JBQU0sUUFBUSxRQUFRO0FBQ3RCLGdCQUFJLFdBQVc7QUFDZixnQkFBSSxVQUFVLFFBQVE7QUFDdEIsZ0JBQUksS0FBSyxnQkFBZ0I7QUFDdkIsdUJBQVMsZUFBZSxPQUFPLE1BQU07QUFDckMsdUJBQVMsTUFBTTtBQUNmLHlCQUFXLFFBQVE7QUFBQSxtQkFDZDtBQUNMLGtCQUFJLFFBQVEsYUFBYSxRQUFRO0FBQy9CLHlCQUFTLE9BQU87QUFDaEIseUJBQVMsZUFBZSxPQUFPLFFBQVE7QUFDdkMsMkJBQVcsS0FBSztBQUFBLHFCQUNYO0FBQ0wseUJBQVMsUUFBUTtBQUNqQix5QkFBUyxlQUFlLE9BQU8sS0FBSztBQUNwQywyQkFBVyxLQUFLO0FBQUE7QUFFbEIseUJBQVcsU0FBUztBQUFBO0FBRXRCLG1CQUFPLEVBQUMsUUFBUSxRQUFRLFVBQVU7QUFBQTtBQUFBLFVBRXBDLE9BQU87QUFDTCxrQkFBTSxNQUFNLEtBQUs7QUFDakIsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGdCQUFJLENBQUMsS0FBSyxTQUFTO0FBQ2pCO0FBQUE7QUFFRixrQkFBTSxXQUFXLE9BQU8sS0FBSztBQUM3QixrQkFBTSxhQUFhLFNBQVM7QUFDNUIsa0JBQU0sU0FBUyxhQUFhLElBQUksS0FBSyxTQUFTO0FBQzlDLGtCQUFNLEVBQUMsUUFBUSxRQUFRLFVBQVUsYUFBWSxLQUFLLFVBQVU7QUFDNUQsdUJBQVcsS0FBSyxLQUFLLE1BQU0sR0FBRyxHQUFHLFVBQVU7QUFBQSxjQUN6QyxPQUFPLEtBQUs7QUFBQSxjQUNaO0FBQUEsY0FDQTtBQUFBLGNBQ0EsV0FBVyxtQkFBbUIsS0FBSztBQUFBLGNBQ25DLGNBQWM7QUFBQSxjQUNkLGFBQWEsQ0FBQyxRQUFRO0FBQUE7QUFBQTtBQUFBO0FBSTVCLDZCQUFxQixRQUFPLFdBQVc7QUFDckMsZ0JBQU0sUUFBUSxJQUFJLE1BQU07QUFBQSxZQUN0QixLQUFLLE9BQU07QUFBQSxZQUNYLFNBQVM7QUFBQSxZQUNUO0FBQUE7QUFFRixrQkFBUSxVQUFVLFFBQU8sT0FBTztBQUNoQyxrQkFBUSxPQUFPLFFBQU87QUFDdEIsaUJBQU0sYUFBYTtBQUFBO0FBRXJCLFlBQUksZUFBZTtBQUFBLFVBQ2pCLElBQUk7QUFBQSxVQUNKLFVBQVU7QUFBQSxVQUNWLE1BQU0sUUFBTyxPQUFPLFNBQVM7QUFDM0Isd0JBQVksUUFBTztBQUFBO0FBQUEsVUFFckIsS0FBSyxRQUFPO0FBQ1Ysa0JBQU0sYUFBYSxPQUFNO0FBQ3pCLG9CQUFRLFVBQVUsUUFBTztBQUN6QixtQkFBTyxPQUFNO0FBQUE7QUFBQSxVQUVmLGFBQWEsUUFBTyxPQUFPLFNBQVM7QUFDbEMsa0JBQU0sUUFBUSxPQUFNO0FBQ3BCLG9CQUFRLFVBQVUsUUFBTyxPQUFPO0FBQ2hDLGtCQUFNLFVBQVU7QUFBQTtBQUFBLFVBRWxCLFVBQVU7QUFBQSxZQUNSLE9BQU87QUFBQSxZQUNQLFNBQVM7QUFBQSxZQUNULE1BQU07QUFBQSxjQUNKLFFBQVE7QUFBQTtBQUFBLFlBRVYsVUFBVTtBQUFBLFlBQ1YsU0FBUztBQUFBLFlBQ1QsVUFBVTtBQUFBLFlBQ1YsTUFBTTtBQUFBLFlBQ04sUUFBUTtBQUFBO0FBQUEsVUFFVixlQUFlO0FBQUEsWUFDYixPQUFPO0FBQUE7QUFBQSxVQUVULGFBQWE7QUFBQSxZQUNYLGFBQWE7QUFBQSxZQUNiLFlBQVk7QUFBQTtBQUFBO0FBSWhCLGNBQU0sTUFBTSxJQUFJO0FBQ2hCLFlBQUksa0JBQWtCO0FBQUEsVUFDcEIsSUFBSTtBQUFBLFVBQ0osTUFBTSxRQUFPLE9BQU8sU0FBUztBQUMzQixrQkFBTSxRQUFRLElBQUksTUFBTTtBQUFBLGNBQ3RCLEtBQUssT0FBTTtBQUFBLGNBQ1g7QUFBQSxjQUNBO0FBQUE7QUFFRixvQkFBUSxVQUFVLFFBQU8sT0FBTztBQUNoQyxvQkFBUSxPQUFPLFFBQU87QUFDdEIsZ0JBQUksSUFBSSxRQUFPO0FBQUE7QUFBQSxVQUVqQixLQUFLLFFBQU87QUFDVixvQkFBUSxVQUFVLFFBQU8sSUFBSSxJQUFJO0FBQ2pDLGdCQUFJLE9BQU87QUFBQTtBQUFBLFVBRWIsYUFBYSxRQUFPLE9BQU8sU0FBUztBQUNsQyxrQkFBTSxRQUFRLElBQUksSUFBSTtBQUN0QixvQkFBUSxVQUFVLFFBQU8sT0FBTztBQUNoQyxrQkFBTSxVQUFVO0FBQUE7QUFBQSxVQUVsQixVQUFVO0FBQUEsWUFDUixPQUFPO0FBQUEsWUFDUCxTQUFTO0FBQUEsWUFDVCxNQUFNO0FBQUEsY0FDSixRQUFRO0FBQUE7QUFBQSxZQUVWLFVBQVU7QUFBQSxZQUNWLFNBQVM7QUFBQSxZQUNULFVBQVU7QUFBQSxZQUNWLE1BQU07QUFBQSxZQUNOLFFBQVE7QUFBQTtBQUFBLFVBRVYsZUFBZTtBQUFBLFlBQ2IsT0FBTztBQUFBO0FBQUEsVUFFVCxhQUFhO0FBQUEsWUFDWCxhQUFhO0FBQUEsWUFDYixZQUFZO0FBQUE7QUFBQTtBQUloQixjQUFNLGNBQWM7QUFBQSxVQUNsQixRQUFRLE9BQU87QUFDYixnQkFBSSxDQUFDLE1BQU0sUUFBUTtBQUNqQixxQkFBTztBQUFBO0FBRVQsZ0JBQUksR0FBRztBQUNQLGdCQUFJLElBQUk7QUFDUixnQkFBSSxJQUFJO0FBQ1IsZ0JBQUksUUFBUTtBQUNaLGlCQUFLLElBQUksR0FBRyxNQUFNLE1BQU0sUUFBUSxJQUFJLEtBQUssRUFBRSxHQUFHO0FBQzVDLG9CQUFNLEtBQUssTUFBTSxHQUFHO0FBQ3BCLGtCQUFJLE1BQU0sR0FBRyxZQUFZO0FBQ3ZCLHNCQUFNLE1BQU0sR0FBRztBQUNmLHFCQUFLLElBQUk7QUFDVCxxQkFBSyxJQUFJO0FBQ1Qsa0JBQUU7QUFBQTtBQUFBO0FBR04sbUJBQU87QUFBQSxjQUNMLEdBQUcsSUFBSTtBQUFBLGNBQ1AsR0FBRyxJQUFJO0FBQUE7QUFBQTtBQUFBLFVBR1gsUUFBUSxPQUFPLGVBQWU7QUFDNUIsZ0JBQUksQ0FBQyxNQUFNLFFBQVE7QUFDakIscUJBQU87QUFBQTtBQUVULGdCQUFJLElBQUksY0FBYztBQUN0QixnQkFBSSxJQUFJLGNBQWM7QUFDdEIsZ0JBQUksY0FBYyxPQUFPO0FBQ3pCLGdCQUFJLEdBQUcsS0FBSztBQUNaLGlCQUFLLElBQUksR0FBRyxNQUFNLE1BQU0sUUFBUSxJQUFJLEtBQUssRUFBRSxHQUFHO0FBQzVDLG9CQUFNLEtBQUssTUFBTSxHQUFHO0FBQ3BCLGtCQUFJLE1BQU0sR0FBRyxZQUFZO0FBQ3ZCLHNCQUFNLFNBQVMsR0FBRztBQUNsQixzQkFBTSxJQUFJLHNCQUFzQixlQUFlO0FBQy9DLG9CQUFJLElBQUksYUFBYTtBQUNuQixnQ0FBYztBQUNkLG1DQUFpQjtBQUFBO0FBQUE7QUFBQTtBQUl2QixnQkFBSSxnQkFBZ0I7QUFDbEIsb0JBQU0sS0FBSyxlQUFlO0FBQzFCLGtCQUFJLEdBQUc7QUFDUCxrQkFBSSxHQUFHO0FBQUE7QUFFVCxtQkFBTztBQUFBLGNBQ0w7QUFBQSxjQUNBO0FBQUE7QUFBQTtBQUFBO0FBSU4sOEJBQXNCLE1BQU0sUUFBUTtBQUNsQyxjQUFJLFFBQVE7QUFDVixnQkFBSSxRQUFRLFNBQVM7QUFDbkIsb0JBQU0sVUFBVSxLQUFLLE1BQU0sTUFBTTtBQUFBLG1CQUM1QjtBQUNMLG1CQUFLLEtBQUs7QUFBQTtBQUFBO0FBR2QsaUJBQU87QUFBQTtBQUVULCtCQUF1QixLQUFLO0FBQzFCLGNBQUssUUFBTyxRQUFRLFlBQVksZUFBZSxXQUFXLElBQUksUUFBUSxRQUFRLElBQUk7QUFDaEYsbUJBQU8sSUFBSSxNQUFNO0FBQUE7QUFFbkIsaUJBQU87QUFBQTtBQUVULG1DQUEyQixRQUFPLE1BQU07QUFDdEMsZ0JBQU0sRUFBQyxTQUFTLGNBQWMsa0JBQVM7QUFDdkMsZ0JBQU0sYUFBYSxPQUFNLGVBQWUsY0FBYztBQUN0RCxnQkFBTSxFQUFDLE9BQU8sVUFBUyxXQUFXLGlCQUFpQjtBQUNuRCxpQkFBTztBQUFBLFlBQ0w7QUFBQSxZQUNBO0FBQUEsWUFDQSxRQUFRLFdBQVcsVUFBVTtBQUFBLFlBQzdCLEtBQUssT0FBTSxLQUFLLFNBQVMsY0FBYyxLQUFLO0FBQUEsWUFDNUMsZ0JBQWdCO0FBQUEsWUFDaEIsU0FBUyxXQUFXO0FBQUEsWUFDcEIsV0FBVztBQUFBLFlBQ1g7QUFBQSxZQUNBO0FBQUE7QUFBQTtBQUdKLGdDQUF3QixTQUFTLFNBQVM7QUFDeEMsZ0JBQU0sTUFBTSxRQUFRLE1BQU07QUFDMUIsZ0JBQU0sRUFBQyxNQUFNLFFBQVEsVUFBUztBQUM5QixnQkFBTSxFQUFDLFVBQVUsY0FBYTtBQUM5QixnQkFBTSxXQUFXLE9BQU8sUUFBUTtBQUNoQyxnQkFBTSxZQUFZLE9BQU8sUUFBUTtBQUNqQyxnQkFBTSxhQUFhLE9BQU8sUUFBUTtBQUNsQyxnQkFBTSxpQkFBaUIsTUFBTTtBQUM3QixnQkFBTSxrQkFBa0IsT0FBTztBQUMvQixnQkFBTSxvQkFBb0IsS0FBSztBQUMvQixnQkFBTSxVQUFVLFVBQVUsUUFBUTtBQUNsQyxjQUFJLFNBQVMsUUFBUTtBQUNyQixjQUFJLFFBQVE7QUFDWixjQUFJLHFCQUFxQixLQUFLLE9BQU8sQ0FBQyxPQUFPLGFBQWEsUUFBUSxTQUFTLE9BQU8sU0FBUyxTQUFTLE1BQU0sU0FBUyxTQUFTLE1BQU0sUUFBUTtBQUMxSSxnQ0FBc0IsUUFBUSxXQUFXLFNBQVMsUUFBUSxVQUFVO0FBQ3BFLGNBQUksZ0JBQWdCO0FBQ2xCLHNCQUFVLGlCQUFpQixVQUFVLGFBQ25DLGtCQUFpQixLQUFLLFFBQVEsZUFDL0IsUUFBUTtBQUFBO0FBRVgsY0FBSSxvQkFBb0I7QUFDdEIsa0JBQU0saUJBQWlCLFFBQVEsZ0JBQWdCLEtBQUssSUFBSSxXQUFXLFNBQVMsY0FBYyxTQUFTO0FBQ25HLHNCQUFVLG9CQUFvQixpQkFDNUIsc0JBQXFCLHFCQUFxQixTQUFTLGFBQ25ELHNCQUFxQixLQUFLLFFBQVE7QUFBQTtBQUV0QyxjQUFJLGlCQUFpQjtBQUNuQixzQkFBVSxRQUFRLGtCQUNqQixrQkFBa0IsV0FBVyxhQUM1QixtQkFBa0IsS0FBSyxRQUFRO0FBQUE7QUFFbkMsY0FBSSxlQUFlO0FBQ25CLGdCQUFNLGVBQWUsU0FBUyxNQUFNO0FBQ2xDLG9CQUFRLEtBQUssSUFBSSxPQUFPLElBQUksWUFBWSxNQUFNLFFBQVE7QUFBQTtBQUV4RCxjQUFJO0FBQ0osY0FBSSxPQUFPLFVBQVU7QUFDckIsZUFBSyxRQUFRLE9BQU87QUFDcEIsY0FBSSxPQUFPLFNBQVM7QUFDcEIsZUFBSyxRQUFRLFdBQVcsT0FBTyxRQUFRLFlBQVk7QUFDbkQseUJBQWUsUUFBUSxnQkFBaUIsV0FBVyxJQUFJLFFBQVEsYUFBYztBQUM3RSxlQUFLLE1BQU0sQ0FBQyxhQUFhO0FBQ3ZCLGlCQUFLLFNBQVMsUUFBUTtBQUN0QixpQkFBSyxTQUFTLE9BQU87QUFDckIsaUJBQUssU0FBUyxPQUFPO0FBQUE7QUFFdkIseUJBQWU7QUFDZixjQUFJLE9BQU8sV0FBVztBQUN0QixlQUFLLFFBQVEsUUFBUTtBQUNyQixjQUFJO0FBQ0osbUJBQVMsUUFBUTtBQUNqQixpQkFBTyxFQUFDLE9BQU87QUFBQTtBQUVqQixpQ0FBeUIsUUFBTyxNQUFNO0FBQ3BDLGdCQUFNLEVBQUMsR0FBRyxXQUFVO0FBQ3BCLGNBQUksSUFBSSxTQUFTLEdBQUc7QUFDbEIsbUJBQU87QUFBQSxxQkFDRSxJQUFLLE9BQU0sU0FBUyxTQUFTLEdBQUk7QUFDMUMsbUJBQU87QUFBQTtBQUVULGlCQUFPO0FBQUE7QUFFVCxxQ0FBNkIsUUFBUSxRQUFPLFNBQVMsTUFBTTtBQUN6RCxnQkFBTSxFQUFDLEdBQUcsVUFBUztBQUNuQixnQkFBTSxRQUFRLFFBQVEsWUFBWSxRQUFRO0FBQzFDLGNBQUksV0FBVyxVQUFVLElBQUksUUFBUSxRQUFRLE9BQU0sT0FBTztBQUN4RCxtQkFBTztBQUFBO0FBRVQsY0FBSSxXQUFXLFdBQVcsSUFBSSxRQUFRLFFBQVEsR0FBRztBQUMvQyxtQkFBTztBQUFBO0FBQUE7QUFHWCxpQ0FBeUIsUUFBTyxTQUFTLE1BQU0sUUFBUTtBQUNyRCxnQkFBTSxFQUFDLEdBQUcsVUFBUztBQUNuQixnQkFBTSxFQUFDLE9BQU8sWUFBWSxXQUFXLEVBQUMsTUFBTSxZQUFVO0FBQ3RELGNBQUksU0FBUztBQUNiLGNBQUksV0FBVyxVQUFVO0FBQ3ZCLHFCQUFTLEtBQU0sUUFBTyxTQUFTLElBQUksU0FBUztBQUFBLHFCQUNuQyxLQUFLLFFBQVEsR0FBRztBQUN6QixxQkFBUztBQUFBLHFCQUNBLEtBQUssYUFBYSxRQUFRLEdBQUc7QUFDdEMscUJBQVM7QUFBQTtBQUVYLGNBQUksb0JBQW9CLFFBQVEsUUFBTyxTQUFTLE9BQU87QUFDckQscUJBQVM7QUFBQTtBQUVYLGlCQUFPO0FBQUE7QUFFVCxvQ0FBNEIsUUFBTyxTQUFTLE1BQU07QUFDaEQsZ0JBQU0sU0FBUyxLQUFLLFVBQVUsUUFBUSxVQUFVLGdCQUFnQixRQUFPO0FBQ3ZFLGlCQUFPO0FBQUEsWUFDTCxRQUFRLEtBQUssVUFBVSxRQUFRLFVBQVUsZ0JBQWdCLFFBQU8sU0FBUyxNQUFNO0FBQUEsWUFDL0U7QUFBQTtBQUFBO0FBR0osd0JBQWdCLE1BQU0sUUFBUTtBQUM1QixjQUFJLEVBQUMsR0FBRyxVQUFTO0FBQ2pCLGNBQUksV0FBVyxTQUFTO0FBQ3RCLGlCQUFLO0FBQUEscUJBQ0ksV0FBVyxVQUFVO0FBQzlCLGlCQUFNLFFBQVE7QUFBQTtBQUVoQixpQkFBTztBQUFBO0FBRVQsd0JBQWdCLE1BQU0sUUFBUSxnQkFBZ0I7QUFDNUMsY0FBSSxFQUFDLEdBQUcsV0FBVTtBQUNsQixjQUFJLFdBQVcsT0FBTztBQUNwQixpQkFBSztBQUFBLHFCQUNJLFdBQVcsVUFBVTtBQUM5QixpQkFBSyxTQUFTO0FBQUEsaUJBQ1Q7QUFDTCxpQkFBTSxTQUFTO0FBQUE7QUFFakIsaUJBQU87QUFBQTtBQUVULG9DQUE0QixTQUFTLE1BQU0sV0FBVyxRQUFPO0FBQzNELGdCQUFNLEVBQUMsV0FBVyxjQUFjLGlCQUFnQjtBQUNoRCxnQkFBTSxFQUFDLFFBQVEsV0FBVTtBQUN6QixnQkFBTSxpQkFBaUIsWUFBWTtBQUNuQyxnQkFBTSxFQUFDLFNBQVMsVUFBVSxZQUFZLGdCQUFlLGNBQWM7QUFDbkUsY0FBSSxJQUFJLE9BQU8sTUFBTTtBQUNyQixnQkFBTSxJQUFJLE9BQU8sTUFBTSxRQUFRO0FBQy9CLGNBQUksV0FBVyxVQUFVO0FBQ3ZCLGdCQUFJLFdBQVcsUUFBUTtBQUNyQixtQkFBSztBQUFBLHVCQUNJLFdBQVcsU0FBUztBQUM3QixtQkFBSztBQUFBO0FBQUEscUJBRUUsV0FBVyxRQUFRO0FBQzVCLGlCQUFLLEtBQUssSUFBSSxTQUFTLGNBQWM7QUFBQSxxQkFDNUIsV0FBVyxTQUFTO0FBQzdCLGlCQUFLLEtBQUssSUFBSSxVQUFVLGVBQWU7QUFBQTtBQUV6QyxpQkFBTztBQUFBLFlBQ0wsR0FBRyxZQUFZLEdBQUcsR0FBRyxPQUFNLFFBQVEsS0FBSztBQUFBLFlBQ3hDLEdBQUcsWUFBWSxHQUFHLEdBQUcsT0FBTSxTQUFTLEtBQUs7QUFBQTtBQUFBO0FBRzdDLDZCQUFxQixTQUFTLE9BQU8sU0FBUztBQUM1QyxnQkFBTSxVQUFVLFVBQVUsUUFBUTtBQUNsQyxpQkFBTyxVQUFVLFdBQ2IsUUFBUSxJQUFJLFFBQVEsUUFBUSxJQUM1QixVQUFVLFVBQ1IsUUFBUSxJQUFJLFFBQVEsUUFBUSxRQUFRLFFBQ3BDLFFBQVEsSUFBSSxRQUFRO0FBQUE7QUFFNUIseUNBQWlDLFdBQVU7QUFDekMsaUJBQU8sYUFBYSxJQUFJLGNBQWM7QUFBQTtBQUV4QyxzQ0FBOEIsUUFBUSxTQUFTLGNBQWM7QUFDM0QsaUJBQU8sY0FBYyxRQUFRO0FBQUEsWUFDM0I7QUFBQSxZQUNBO0FBQUEsWUFDQSxNQUFNO0FBQUE7QUFBQTtBQUdWLG1DQUEyQixXQUFXLFNBQVM7QUFDN0MsZ0JBQU0sV0FBVyxXQUFXLFFBQVEsV0FBVyxRQUFRLFFBQVEsV0FBVyxRQUFRLFFBQVEsUUFBUTtBQUNsRyxpQkFBTyxXQUFXLFVBQVUsU0FBUyxZQUFZO0FBQUE7QUFFbkQsOEJBQXNCLFNBQVE7QUFBQSxVQUM1QixZQUFZLFFBQVE7QUFDbEI7QUFDQSxpQkFBSyxVQUFVO0FBQ2YsaUJBQUssVUFBVTtBQUNmLGlCQUFLLGlCQUFpQjtBQUN0QixpQkFBSyxRQUFRO0FBQ2IsaUJBQUssb0JBQW9CO0FBQ3pCLGlCQUFLLGdCQUFnQjtBQUNyQixpQkFBSyxjQUFjO0FBQ25CLGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssUUFBUSxPQUFPLFNBQVMsT0FBTztBQUNwQyxpQkFBSyxTQUFTLEtBQUs7QUFDbkIsaUJBQUssVUFBVSxPQUFPO0FBQ3RCLGlCQUFLLGFBQWE7QUFDbEIsaUJBQUssUUFBUTtBQUNiLGlCQUFLLGFBQWE7QUFDbEIsaUJBQUssT0FBTztBQUNaLGlCQUFLLFlBQVk7QUFDakIsaUJBQUssU0FBUztBQUNkLGlCQUFLLFNBQVM7QUFDZCxpQkFBSyxTQUFTO0FBQ2QsaUJBQUssSUFBSTtBQUNULGlCQUFLLElBQUk7QUFDVCxpQkFBSyxTQUFTO0FBQ2QsaUJBQUssUUFBUTtBQUNiLGlCQUFLLFNBQVM7QUFDZCxpQkFBSyxTQUFTO0FBQ2QsaUJBQUssY0FBYztBQUNuQixpQkFBSyxtQkFBbUI7QUFDeEIsaUJBQUssa0JBQWtCO0FBQUE7QUFBQSxVQUV6QixXQUFXLFNBQVM7QUFDbEIsaUJBQUssVUFBVTtBQUNmLGlCQUFLLG9CQUFvQjtBQUN6QixpQkFBSyxXQUFXO0FBQUE7QUFBQSxVQUVsQixxQkFBcUI7QUFDbkIsa0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGdCQUFJLFFBQVE7QUFDVixxQkFBTztBQUFBO0FBRVQsa0JBQU0sU0FBUSxLQUFLO0FBQ25CLGtCQUFNLFVBQVUsS0FBSyxRQUFRLFdBQVcsS0FBSztBQUM3QyxrQkFBTSxPQUFPLFFBQVEsV0FBVyxPQUFNLFFBQVEsYUFBYSxRQUFRO0FBQ25FLGtCQUFNLGFBQWEsSUFBSSxXQUFXLEtBQUssT0FBTztBQUM5QyxnQkFBSSxLQUFLLFlBQVk7QUFDbkIsbUJBQUssb0JBQW9CLE9BQU8sT0FBTztBQUFBO0FBRXpDLG1CQUFPO0FBQUE7QUFBQSxVQUVULGFBQWE7QUFDWCxtQkFBTyxLQUFLLFlBQ1osTUFBSyxXQUFXLHFCQUFxQixLQUFLLE1BQU0sY0FBYyxNQUFNLEtBQUs7QUFBQTtBQUFBLFVBRTNFLFNBQVMsU0FBUyxTQUFTO0FBQ3pCLGtCQUFNLEVBQUMsY0FBYTtBQUNwQixrQkFBTSxjQUFjLFVBQVUsWUFBWSxNQUFNLE1BQU0sQ0FBQztBQUN2RCxrQkFBTSxRQUFRLFVBQVUsTUFBTSxNQUFNLE1BQU0sQ0FBQztBQUMzQyxrQkFBTSxhQUFhLFVBQVUsV0FBVyxNQUFNLE1BQU0sQ0FBQztBQUNyRCxnQkFBSSxRQUFRO0FBQ1osb0JBQVEsYUFBYSxPQUFPLGNBQWM7QUFDMUMsb0JBQVEsYUFBYSxPQUFPLGNBQWM7QUFDMUMsb0JBQVEsYUFBYSxPQUFPLGNBQWM7QUFDMUMsbUJBQU87QUFBQTtBQUFBLFVBRVQsY0FBYyxjQUFjLFNBQVM7QUFDbkMsbUJBQU8sd0JBQXdCLFFBQVEsVUFBVSxXQUFXLE1BQU0sTUFBTSxDQUFDO0FBQUE7QUFBQSxVQUUzRSxRQUFRLGNBQWMsU0FBUztBQUM3QixrQkFBTSxFQUFDLGNBQWE7QUFDcEIsa0JBQU0sWUFBWTtBQUNsQixpQkFBSyxjQUFjLENBQUMsWUFBWTtBQUM5QixvQkFBTSxXQUFXO0FBQUEsZ0JBQ2YsUUFBUTtBQUFBLGdCQUNSLE9BQU87QUFBQSxnQkFDUCxPQUFPO0FBQUE7QUFFVCxvQkFBTSxTQUFTLGtCQUFrQixXQUFXO0FBQzVDLDJCQUFhLFNBQVMsUUFBUSxjQUFjLE9BQU8sWUFBWSxLQUFLLE1BQU07QUFDMUUsMkJBQWEsU0FBUyxPQUFPLE9BQU8sTUFBTSxLQUFLLE1BQU07QUFDckQsMkJBQWEsU0FBUyxPQUFPLGNBQWMsT0FBTyxXQUFXLEtBQUssTUFBTTtBQUN4RSx3QkFBVSxLQUFLO0FBQUE7QUFFakIsbUJBQU87QUFBQTtBQUFBLFVBRVQsYUFBYSxjQUFjLFNBQVM7QUFDbEMsbUJBQU8sd0JBQXdCLFFBQVEsVUFBVSxVQUFVLE1BQU0sTUFBTSxDQUFDO0FBQUE7QUFBQSxVQUUxRSxVQUFVLGNBQWMsU0FBUztBQUMvQixrQkFBTSxFQUFDLGNBQWE7QUFDcEIsa0JBQU0sZUFBZSxVQUFVLGFBQWEsTUFBTSxNQUFNLENBQUM7QUFDekQsa0JBQU0sU0FBUyxVQUFVLE9BQU8sTUFBTSxNQUFNLENBQUM7QUFDN0Msa0JBQU0sY0FBYyxVQUFVLFlBQVksTUFBTSxNQUFNLENBQUM7QUFDdkQsZ0JBQUksUUFBUTtBQUNaLG9CQUFRLGFBQWEsT0FBTyxjQUFjO0FBQzFDLG9CQUFRLGFBQWEsT0FBTyxjQUFjO0FBQzFDLG9CQUFRLGFBQWEsT0FBTyxjQUFjO0FBQzFDLG1CQUFPO0FBQUE7QUFBQSxVQUVULGFBQWEsU0FBUztBQUNwQixrQkFBTSxTQUFTLEtBQUs7QUFDcEIsa0JBQU0sT0FBTyxLQUFLLE1BQU07QUFDeEIsa0JBQU0sY0FBYztBQUNwQixrQkFBTSxtQkFBbUI7QUFDekIsa0JBQU0sa0JBQWtCO0FBQ3hCLGdCQUFJLGVBQWU7QUFDbkIsZ0JBQUksR0FBRztBQUNQLGlCQUFLLElBQUksR0FBRyxNQUFNLE9BQU8sUUFBUSxJQUFJLEtBQUssRUFBRSxHQUFHO0FBQzdDLDJCQUFhLEtBQUssa0JBQWtCLEtBQUssT0FBTyxPQUFPO0FBQUE7QUFFekQsZ0JBQUksUUFBUSxRQUFRO0FBQ2xCLDZCQUFlLGFBQWEsT0FBTyxDQUFDLFNBQVMsUUFBTyxVQUFVLFFBQVEsT0FBTyxTQUFTLFFBQU8sT0FBTztBQUFBO0FBRXRHLGdCQUFJLFFBQVEsVUFBVTtBQUNwQiw2QkFBZSxhQUFhLEtBQUssQ0FBQyxHQUFHLE1BQU0sUUFBUSxTQUFTLEdBQUcsR0FBRztBQUFBO0FBRXBFLGlCQUFLLGNBQWMsQ0FBQyxZQUFZO0FBQzlCLG9CQUFNLFNBQVMsa0JBQWtCLFFBQVEsV0FBVztBQUNwRCwwQkFBWSxLQUFLLE9BQU8sV0FBVyxLQUFLLE1BQU07QUFDOUMsK0JBQWlCLEtBQUssT0FBTyxnQkFBZ0IsS0FBSyxNQUFNO0FBQ3hELDhCQUFnQixLQUFLLE9BQU8sZUFBZSxLQUFLLE1BQU07QUFBQTtBQUV4RCxpQkFBSyxjQUFjO0FBQ25CLGlCQUFLLG1CQUFtQjtBQUN4QixpQkFBSyxrQkFBa0I7QUFDdkIsaUJBQUssYUFBYTtBQUNsQixtQkFBTztBQUFBO0FBQUEsVUFFVCxPQUFPLFNBQVMsUUFBUTtBQUN0QixrQkFBTSxVQUFVLEtBQUssUUFBUSxXQUFXLEtBQUs7QUFDN0Msa0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGdCQUFJO0FBQ0osZ0JBQUksZUFBZTtBQUNuQixnQkFBSSxDQUFDLE9BQU8sUUFBUTtBQUNsQixrQkFBSSxLQUFLLFlBQVksR0FBRztBQUN0Qiw2QkFBYTtBQUFBLGtCQUNYLFNBQVM7QUFBQTtBQUFBO0FBQUEsbUJBR1I7QUFDTCxvQkFBTSxXQUFXLFlBQVksUUFBUSxVQUFVLEtBQUssTUFBTSxRQUFRLEtBQUs7QUFDdkUsNkJBQWUsS0FBSyxhQUFhO0FBQ2pDLG1CQUFLLFFBQVEsS0FBSyxTQUFTLGNBQWM7QUFDekMsbUJBQUssYUFBYSxLQUFLLGNBQWMsY0FBYztBQUNuRCxtQkFBSyxPQUFPLEtBQUssUUFBUSxjQUFjO0FBQ3ZDLG1CQUFLLFlBQVksS0FBSyxhQUFhLGNBQWM7QUFDakQsbUJBQUssU0FBUyxLQUFLLFVBQVUsY0FBYztBQUMzQyxvQkFBTSxPQUFPLEtBQUssUUFBUSxlQUFlLE1BQU07QUFDL0Msb0JBQU0sa0JBQWtCLE9BQU8sT0FBTyxJQUFJLFVBQVU7QUFDcEQsb0JBQU0sWUFBWSxtQkFBbUIsS0FBSyxPQUFPLFNBQVM7QUFDMUQsb0JBQU0sa0JBQWtCLG1CQUFtQixTQUFTLGlCQUFpQixXQUFXLEtBQUs7QUFDckYsbUJBQUssU0FBUyxVQUFVO0FBQ3hCLG1CQUFLLFNBQVMsVUFBVTtBQUN4QiwyQkFBYTtBQUFBLGdCQUNYLFNBQVM7QUFBQSxnQkFDVCxHQUFHLGdCQUFnQjtBQUFBLGdCQUNuQixHQUFHLGdCQUFnQjtBQUFBLGdCQUNuQixPQUFPLEtBQUs7QUFBQSxnQkFDWixRQUFRLEtBQUs7QUFBQSxnQkFDYixRQUFRLFNBQVM7QUFBQSxnQkFDakIsUUFBUSxTQUFTO0FBQUE7QUFBQTtBQUdyQixpQkFBSyxnQkFBZ0I7QUFDckIsaUJBQUssV0FBVztBQUNoQixnQkFBSSxZQUFZO0FBQ2QsbUJBQUsscUJBQXFCLE9BQU8sTUFBTTtBQUFBO0FBRXpDLGdCQUFJLFdBQVcsUUFBUSxVQUFVO0FBQy9CLHNCQUFRLFNBQVMsS0FBSyxNQUFNLEVBQUMsT0FBTyxLQUFLLE9BQU8sU0FBUyxNQUFNO0FBQUE7QUFBQTtBQUFBLFVBR25FLFVBQVUsY0FBYyxLQUFLLE1BQU0sU0FBUztBQUMxQyxrQkFBTSxnQkFBZ0IsS0FBSyxpQkFBaUIsY0FBYyxNQUFNO0FBQ2hFLGdCQUFJLE9BQU8sY0FBYyxJQUFJLGNBQWM7QUFDM0MsZ0JBQUksT0FBTyxjQUFjLElBQUksY0FBYztBQUMzQyxnQkFBSSxPQUFPLGNBQWMsSUFBSSxjQUFjO0FBQUE7QUFBQSxVQUU3QyxpQkFBaUIsY0FBYyxNQUFNLFNBQVM7QUFDNUMsa0JBQU0sRUFBQyxRQUFRLFdBQVU7QUFDekIsa0JBQU0sRUFBQyxXQUFXLGlCQUFnQjtBQUNsQyxrQkFBTSxFQUFDLFNBQVMsVUFBVSxZQUFZLGdCQUFlLGNBQWM7QUFDbkUsa0JBQU0sRUFBQyxHQUFHLEtBQUssR0FBRyxRQUFPO0FBQ3pCLGtCQUFNLEVBQUMsT0FBTyxXQUFVO0FBQ3hCLGdCQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSTtBQUN4QixnQkFBSSxXQUFXLFVBQVU7QUFDdkIsbUJBQUssTUFBTyxTQUFTO0FBQ3JCLGtCQUFJLFdBQVcsUUFBUTtBQUNyQixxQkFBSztBQUNMLHFCQUFLLEtBQUs7QUFDVixxQkFBSyxLQUFLO0FBQ1YscUJBQUssS0FBSztBQUFBLHFCQUNMO0FBQ0wscUJBQUssTUFBTTtBQUNYLHFCQUFLLEtBQUs7QUFDVixxQkFBSyxLQUFLO0FBQ1YscUJBQUssS0FBSztBQUFBO0FBRVosbUJBQUs7QUFBQSxtQkFDQTtBQUNMLGtCQUFJLFdBQVcsUUFBUTtBQUNyQixxQkFBSyxNQUFNLEtBQUssSUFBSSxTQUFTLGNBQWU7QUFBQSx5QkFDbkMsV0FBVyxTQUFTO0FBQzdCLHFCQUFLLE1BQU0sUUFBUSxLQUFLLElBQUksVUFBVSxlQUFlO0FBQUEscUJBQ2hEO0FBQ0wscUJBQUssS0FBSztBQUFBO0FBRVosa0JBQUksV0FBVyxPQUFPO0FBQ3BCLHFCQUFLO0FBQ0wscUJBQUssS0FBSztBQUNWLHFCQUFLLEtBQUs7QUFDVixxQkFBSyxLQUFLO0FBQUEscUJBQ0w7QUFDTCxxQkFBSyxNQUFNO0FBQ1gscUJBQUssS0FBSztBQUNWLHFCQUFLLEtBQUs7QUFDVixxQkFBSyxLQUFLO0FBQUE7QUFFWixtQkFBSztBQUFBO0FBRVAsbUJBQU8sRUFBQyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFBQTtBQUFBLFVBRTlCLFVBQVUsSUFBSSxLQUFLLFNBQVM7QUFDMUIsa0JBQU0sUUFBUSxLQUFLO0FBQ25CLGtCQUFNLFNBQVMsTUFBTTtBQUNyQixnQkFBSSxXQUFXLGNBQWM7QUFDN0IsZ0JBQUksUUFBUTtBQUNWLG9CQUFNLFlBQVksY0FBYyxRQUFRLEtBQUssS0FBSyxHQUFHLEtBQUs7QUFDMUQsaUJBQUcsSUFBSSxZQUFZLE1BQU0sUUFBUSxZQUFZO0FBQzdDLGtCQUFJLFlBQVksVUFBVSxVQUFVLFFBQVE7QUFDNUMsa0JBQUksZUFBZTtBQUNuQiwwQkFBWSxPQUFPLFFBQVE7QUFDM0IsNkJBQWUsUUFBUTtBQUN2QixrQkFBSSxZQUFZLFFBQVE7QUFDeEIsa0JBQUksT0FBTyxVQUFVO0FBQ3JCLG1CQUFLLElBQUksR0FBRyxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQzNCLG9CQUFJLFNBQVMsTUFBTSxJQUFJLFVBQVUsRUFBRSxHQUFHLElBQUksR0FBRyxJQUFJLFVBQVUsYUFBYTtBQUN4RSxtQkFBRyxLQUFLLFVBQVUsYUFBYTtBQUMvQixvQkFBSSxJQUFJLE1BQU0sUUFBUTtBQUNwQixxQkFBRyxLQUFLLFFBQVEsb0JBQW9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUs1QyxjQUFjLEtBQUssSUFBSSxHQUFHLFdBQVcsU0FBUztBQUM1QyxrQkFBTSxjQUFjLEtBQUssWUFBWTtBQUNyQyxrQkFBTSxrQkFBa0IsS0FBSyxpQkFBaUI7QUFDOUMsa0JBQU0sRUFBQyxXQUFXLFVBQVUsZUFBYztBQUMxQyxrQkFBTSxXQUFXLE9BQU8sUUFBUTtBQUNoQyxrQkFBTSxTQUFTLFlBQVksTUFBTSxRQUFRO0FBQ3pDLGtCQUFNLFlBQVksVUFBVSxFQUFFO0FBQzlCLGtCQUFNLFVBQVUsWUFBWSxTQUFTLGFBQWMsVUFBUyxhQUFhLGFBQWEsSUFBSTtBQUMxRixrQkFBTSxTQUFTLEdBQUcsSUFBSTtBQUN0QixnQkFBSSxRQUFRLGVBQWU7QUFDekIsb0JBQU0sY0FBYztBQUFBLGdCQUNsQixRQUFRLEtBQUssSUFBSSxVQUFVLGFBQWE7QUFBQSxnQkFDeEMsWUFBWSxnQkFBZ0I7QUFBQSxnQkFDNUIsVUFBVSxnQkFBZ0I7QUFBQSxnQkFDMUIsYUFBYTtBQUFBO0FBRWYsb0JBQU0sVUFBVSxVQUFVLFdBQVcsV0FBVyxZQUFZLFdBQVc7QUFDdkUsb0JBQU0sVUFBVSxTQUFTLFlBQVk7QUFDckMsa0JBQUksY0FBYyxRQUFRO0FBQzFCLGtCQUFJLFlBQVksUUFBUTtBQUN4Qix3QkFBVSxLQUFLLGFBQWEsU0FBUztBQUNyQyxrQkFBSSxjQUFjLFlBQVk7QUFDOUIsa0JBQUksWUFBWSxZQUFZO0FBQzVCLHdCQUFVLEtBQUssYUFBYSxTQUFTO0FBQUEsbUJBQ2hDO0FBQ0wsa0JBQUksWUFBWSxVQUFTLFlBQVksZUFBZSxLQUFLLElBQUksR0FBRyxPQUFPLE9BQU8sWUFBWSxnQkFBaUIsWUFBWSxlQUFlO0FBQ3RJLGtCQUFJLGNBQWMsWUFBWTtBQUM5QixrQkFBSSxZQUFZLFlBQVksY0FBYztBQUMxQyxrQkFBSSxpQkFBaUIsWUFBWSxvQkFBb0I7QUFDckQsb0JBQU0sU0FBUyxVQUFVLFdBQVcsV0FBVyxXQUFXO0FBQzFELG9CQUFNLFNBQVMsVUFBVSxXQUFXLFVBQVUsTUFBTSxXQUFXLElBQUksV0FBVyxhQUFhO0FBQzNGLG9CQUFNLGVBQWUsY0FBYyxZQUFZO0FBQy9DLGtCQUFJLE9BQU8sT0FBTyxjQUFjLEtBQUssT0FBSyxNQUFNLElBQUk7QUFDbEQsb0JBQUk7QUFDSixvQkFBSSxZQUFZLFFBQVE7QUFDeEIsbUNBQW1CLEtBQUs7QUFBQSxrQkFDdEIsR0FBRztBQUFBLGtCQUNILEdBQUc7QUFBQSxrQkFDSCxHQUFHO0FBQUEsa0JBQ0gsR0FBRztBQUFBLGtCQUNILFFBQVE7QUFBQTtBQUVWLG9CQUFJO0FBQ0osb0JBQUk7QUFDSixvQkFBSSxZQUFZLFlBQVk7QUFDNUIsb0JBQUk7QUFDSixtQ0FBbUIsS0FBSztBQUFBLGtCQUN0QixHQUFHO0FBQUEsa0JBQ0gsR0FBRyxTQUFTO0FBQUEsa0JBQ1osR0FBRyxXQUFXO0FBQUEsa0JBQ2QsR0FBRyxZQUFZO0FBQUEsa0JBQ2YsUUFBUTtBQUFBO0FBRVYsb0JBQUk7QUFBQSxxQkFDQztBQUNMLG9CQUFJLFlBQVksUUFBUTtBQUN4QixvQkFBSSxTQUFTLFFBQVEsUUFBUSxVQUFVO0FBQ3ZDLG9CQUFJLFdBQVcsUUFBUSxRQUFRLFVBQVU7QUFDekMsb0JBQUksWUFBWSxZQUFZO0FBQzVCLG9CQUFJLFNBQVMsUUFBUSxTQUFTLEdBQUcsV0FBVyxHQUFHLFlBQVk7QUFBQTtBQUFBO0FBRy9ELGdCQUFJLFlBQVksS0FBSyxnQkFBZ0I7QUFBQTtBQUFBLFVBRXZDLFNBQVMsSUFBSSxLQUFLLFNBQVM7QUFDekIsa0JBQU0sRUFBQyxTQUFRO0FBQ2Ysa0JBQU0sRUFBQyxhQUFhLFdBQVcsZUFBZSxXQUFXLFVBQVUsZUFBYztBQUNqRixrQkFBTSxXQUFXLE9BQU8sUUFBUTtBQUNoQyxnQkFBSSxpQkFBaUIsU0FBUztBQUM5QixnQkFBSSxlQUFlO0FBQ25CLGtCQUFNLFlBQVksY0FBYyxRQUFRLEtBQUssS0FBSyxHQUFHLEtBQUs7QUFDMUQsa0JBQU0saUJBQWlCLFNBQVMsTUFBTTtBQUNwQyxrQkFBSSxTQUFTLE1BQU0sVUFBVSxFQUFFLEdBQUcsSUFBSSxlQUFlLEdBQUcsSUFBSSxpQkFBaUI7QUFDN0UsaUJBQUcsS0FBSyxpQkFBaUI7QUFBQTtBQUUzQixrQkFBTSwwQkFBMEIsVUFBVSxVQUFVO0FBQ3BELGdCQUFJLFVBQVUsV0FBVyxPQUFPLEdBQUcsR0FBRyxNQUFNO0FBQzVDLGdCQUFJLFlBQVk7QUFDaEIsZ0JBQUksZUFBZTtBQUNuQixnQkFBSSxPQUFPLFNBQVM7QUFDcEIsZUFBRyxJQUFJLFlBQVksTUFBTSx5QkFBeUI7QUFDbEQsZ0JBQUksWUFBWSxRQUFRO0FBQ3hCLGlCQUFLLEtBQUssWUFBWTtBQUN0QiwyQkFBZSxpQkFBaUIsNEJBQTRCLFVBQ3hELGNBQWMsV0FBWSxXQUFXLElBQUksYUFBZSxXQUFXLElBQUksYUFDdkU7QUFDSixpQkFBSyxJQUFJLEdBQUcsT0FBTyxLQUFLLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUM3Qyx5QkFBVyxLQUFLO0FBQ2hCLDBCQUFZLEtBQUssZ0JBQWdCO0FBQ2pDLGtCQUFJLFlBQVk7QUFDaEIsbUJBQUssU0FBUyxRQUFRO0FBQ3RCLHNCQUFRLFNBQVM7QUFDakIsa0JBQUksaUJBQWlCLE1BQU0sUUFBUTtBQUNqQyxxQkFBSyxjQUFjLEtBQUssSUFBSSxHQUFHLFdBQVc7QUFDMUMsaUNBQWlCLEtBQUssSUFBSSxTQUFTLFlBQVk7QUFBQTtBQUVqRCxtQkFBSyxJQUFJLEdBQUcsT0FBTyxNQUFNLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUM5QywrQkFBZSxNQUFNO0FBQ3JCLGlDQUFpQixTQUFTO0FBQUE7QUFFNUIsbUJBQUssU0FBUyxPQUFPO0FBQUE7QUFFdkIsMkJBQWU7QUFDZiw2QkFBaUIsU0FBUztBQUMxQixpQkFBSyxLQUFLLFdBQVc7QUFDckIsZUFBRyxLQUFLO0FBQUE7QUFBQSxVQUVWLFdBQVcsSUFBSSxLQUFLLFNBQVM7QUFDM0Isa0JBQU0sU0FBUyxLQUFLO0FBQ3BCLGtCQUFNLFNBQVMsT0FBTztBQUN0QixnQkFBSSxZQUFZO0FBQ2hCLGdCQUFJLFFBQVE7QUFDVixvQkFBTSxZQUFZLGNBQWMsUUFBUSxLQUFLLEtBQUssR0FBRyxLQUFLO0FBQzFELGlCQUFHLElBQUksWUFBWSxNQUFNLFFBQVEsYUFBYTtBQUM5QyxpQkFBRyxLQUFLLFFBQVE7QUFDaEIsa0JBQUksWUFBWSxVQUFVLFVBQVUsUUFBUTtBQUM1QyxrQkFBSSxlQUFlO0FBQ25CLDJCQUFhLE9BQU8sUUFBUTtBQUM1QixrQkFBSSxZQUFZLFFBQVE7QUFDeEIsa0JBQUksT0FBTyxXQUFXO0FBQ3RCLG1CQUFLLElBQUksR0FBRyxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQzNCLG9CQUFJLFNBQVMsT0FBTyxJQUFJLFVBQVUsRUFBRSxHQUFHLElBQUksR0FBRyxJQUFJLFdBQVcsYUFBYTtBQUMxRSxtQkFBRyxLQUFLLFdBQVcsYUFBYSxRQUFRO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFJOUMsZUFBZSxJQUFJLEtBQUssYUFBYSxTQUFTO0FBQzVDLGtCQUFNLEVBQUMsUUFBUSxXQUFVO0FBQ3pCLGtCQUFNLEVBQUMsR0FBRyxNQUFLO0FBQ2Ysa0JBQU0sRUFBQyxPQUFPLFdBQVU7QUFDeEIsa0JBQU0sRUFBQyxTQUFTLFVBQVUsWUFBWSxnQkFBZSxjQUFjLFFBQVE7QUFDM0UsZ0JBQUksWUFBWSxRQUFRO0FBQ3hCLGdCQUFJLGNBQWMsUUFBUTtBQUMxQixnQkFBSSxZQUFZLFFBQVE7QUFDeEIsZ0JBQUk7QUFDSixnQkFBSSxPQUFPLElBQUksU0FBUztBQUN4QixnQkFBSSxXQUFXLE9BQU87QUFDcEIsbUJBQUssVUFBVSxJQUFJLEtBQUssYUFBYTtBQUFBO0FBRXZDLGdCQUFJLE9BQU8sSUFBSSxRQUFRLFVBQVU7QUFDakMsZ0JBQUksaUJBQWlCLElBQUksT0FBTyxHQUFHLElBQUksT0FBTyxJQUFJO0FBQ2xELGdCQUFJLFdBQVcsWUFBWSxXQUFXLFNBQVM7QUFDN0MsbUJBQUssVUFBVSxJQUFJLEtBQUssYUFBYTtBQUFBO0FBRXZDLGdCQUFJLE9BQU8sSUFBSSxPQUFPLElBQUksU0FBUztBQUNuQyxnQkFBSSxpQkFBaUIsSUFBSSxPQUFPLElBQUksUUFBUSxJQUFJLFFBQVEsYUFBYSxJQUFJO0FBQ3pFLGdCQUFJLFdBQVcsVUFBVTtBQUN2QixtQkFBSyxVQUFVLElBQUksS0FBSyxhQUFhO0FBQUE7QUFFdkMsZ0JBQUksT0FBTyxJQUFJLFlBQVksSUFBSTtBQUMvQixnQkFBSSxpQkFBaUIsR0FBRyxJQUFJLFFBQVEsR0FBRyxJQUFJLFNBQVM7QUFDcEQsZ0JBQUksV0FBVyxZQUFZLFdBQVcsUUFBUTtBQUM1QyxtQkFBSyxVQUFVLElBQUksS0FBSyxhQUFhO0FBQUE7QUFFdkMsZ0JBQUksT0FBTyxHQUFHLElBQUk7QUFDbEIsZ0JBQUksaUJBQWlCLEdBQUcsR0FBRyxJQUFJLFNBQVM7QUFDeEMsZ0JBQUk7QUFDSixnQkFBSTtBQUNKLGdCQUFJLFFBQVEsY0FBYyxHQUFHO0FBQzNCLGtCQUFJO0FBQUE7QUFBQTtBQUFBLFVBR1IsdUJBQXVCLFNBQVM7QUFDOUIsa0JBQU0sU0FBUSxLQUFLO0FBQ25CLGtCQUFNLFFBQVEsS0FBSztBQUNuQixrQkFBTSxRQUFRLFNBQVMsTUFBTTtBQUM3QixrQkFBTSxRQUFRLFNBQVMsTUFBTTtBQUM3QixnQkFBSSxTQUFTLE9BQU87QUFDbEIsb0JBQU0sV0FBVyxZQUFZLFFBQVEsVUFBVSxLQUFLLE1BQU0sS0FBSyxTQUFTLEtBQUs7QUFDN0Usa0JBQUksQ0FBQyxVQUFVO0FBQ2I7QUFBQTtBQUVGLG9CQUFNLE9BQU8sS0FBSyxRQUFRLGVBQWUsTUFBTTtBQUMvQyxvQkFBTSxrQkFBa0IsT0FBTyxPQUFPLElBQUksVUFBVSxLQUFLO0FBQ3pELG9CQUFNLFlBQVksbUJBQW1CLFFBQU8sU0FBUztBQUNyRCxvQkFBTSxRQUFRLG1CQUFtQixTQUFTLGlCQUFpQixXQUFXO0FBQ3RFLGtCQUFJLE1BQU0sUUFBUSxNQUFNLEtBQUssTUFBTSxRQUFRLE1BQU0sR0FBRztBQUNsRCxxQkFBSyxTQUFTLFVBQVU7QUFDeEIscUJBQUssU0FBUyxVQUFVO0FBQ3hCLHFCQUFLLFFBQVEsS0FBSztBQUNsQixxQkFBSyxTQUFTLEtBQUs7QUFDbkIscUJBQUssU0FBUyxTQUFTO0FBQ3ZCLHFCQUFLLFNBQVMsU0FBUztBQUN2QixxQkFBSyxxQkFBcUIsT0FBTyxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFJN0MsY0FBYztBQUNaLG1CQUFPLENBQUMsQ0FBQyxLQUFLO0FBQUE7QUFBQSxVQUVoQixLQUFLLEtBQUs7QUFDUixrQkFBTSxVQUFVLEtBQUssUUFBUSxXQUFXLEtBQUs7QUFDN0MsZ0JBQUksVUFBVSxLQUFLO0FBQ25CLGdCQUFJLENBQUMsU0FBUztBQUNaO0FBQUE7QUFFRixpQkFBSyx1QkFBdUI7QUFDNUIsa0JBQU0sY0FBYztBQUFBLGNBQ2xCLE9BQU8sS0FBSztBQUFBLGNBQ1osUUFBUSxLQUFLO0FBQUE7QUFFZixrQkFBTSxLQUFLO0FBQUEsY0FDVCxHQUFHLEtBQUs7QUFBQSxjQUNSLEdBQUcsS0FBSztBQUFBO0FBRVYsc0JBQVUsS0FBSyxJQUFJLFdBQVcsT0FBTyxJQUFJO0FBQ3pDLGtCQUFNLFVBQVUsVUFBVSxRQUFRO0FBQ2xDLGtCQUFNLG9CQUFvQixLQUFLLE1BQU0sVUFBVSxLQUFLLFdBQVcsVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLFVBQVUsVUFBVSxLQUFLLE9BQU87QUFDbEksZ0JBQUksUUFBUSxXQUFXLG1CQUFtQjtBQUN4QyxrQkFBSTtBQUNKLGtCQUFJLGNBQWM7QUFDbEIsbUJBQUssZUFBZSxJQUFJLEtBQUssYUFBYTtBQUMxQyxvQ0FBc0IsS0FBSyxRQUFRO0FBQ25DLGlCQUFHLEtBQUssUUFBUTtBQUNoQixtQkFBSyxVQUFVLElBQUksS0FBSztBQUN4QixtQkFBSyxTQUFTLElBQUksS0FBSztBQUN2QixtQkFBSyxXQUFXLElBQUksS0FBSztBQUN6QixtQ0FBcUIsS0FBSyxRQUFRO0FBQ2xDLGtCQUFJO0FBQUE7QUFBQTtBQUFBLFVBR1Isb0JBQW9CO0FBQ2xCLG1CQUFPLEtBQUssV0FBVztBQUFBO0FBQUEsVUFFekIsa0JBQWtCLGdCQUFnQixlQUFlO0FBQy9DLGtCQUFNLGFBQWEsS0FBSztBQUN4QixrQkFBTSxTQUFTLGVBQWUsSUFBSSxDQUFDLEVBQUMsY0FBYyxvQkFBVztBQUMzRCxvQkFBTSxPQUFPLEtBQUssTUFBTSxlQUFlO0FBQ3ZDLGtCQUFJLENBQUMsTUFBTTtBQUNULHNCQUFNLElBQUksTUFBTSxvQ0FBb0M7QUFBQTtBQUV0RCxxQkFBTztBQUFBLGdCQUNMO0FBQUEsZ0JBQ0EsU0FBUyxLQUFLLEtBQUs7QUFBQSxnQkFDbkI7QUFBQTtBQUFBO0FBR0osa0JBQU0sVUFBVSxDQUFDLGVBQWUsWUFBWTtBQUM1QyxrQkFBTSxrQkFBa0IsS0FBSyxpQkFBaUIsUUFBUTtBQUN0RCxnQkFBSSxXQUFXLGlCQUFpQjtBQUM5QixtQkFBSyxVQUFVO0FBQ2YsbUJBQUssaUJBQWlCO0FBQ3RCLG1CQUFLLHNCQUFzQjtBQUMzQixtQkFBSyxPQUFPO0FBQUE7QUFBQTtBQUFBLFVBR2hCLFlBQVksR0FBRyxRQUFRLGNBQWMsTUFBTTtBQUN6QyxnQkFBSSxVQUFVLEtBQUsscUJBQXFCO0FBQ3RDLHFCQUFPO0FBQUE7QUFFVCxpQkFBSyxzQkFBc0I7QUFDM0Isa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGtCQUFNLGFBQWEsS0FBSyxXQUFXO0FBQ25DLGtCQUFNLFNBQVMsS0FBSyxtQkFBbUIsR0FBRyxZQUFZLFFBQVE7QUFDOUQsa0JBQU0sa0JBQWtCLEtBQUssaUJBQWlCLFFBQVE7QUFDdEQsa0JBQU0sVUFBVSxVQUFVLENBQUMsZUFBZSxRQUFRLGVBQWU7QUFDakUsZ0JBQUksU0FBUztBQUNYLG1CQUFLLFVBQVU7QUFDZixrQkFBSSxRQUFRLFdBQVcsUUFBUSxVQUFVO0FBQ3ZDLHFCQUFLLGlCQUFpQjtBQUFBLGtCQUNwQixHQUFHLEVBQUU7QUFBQSxrQkFDTCxHQUFHLEVBQUU7QUFBQTtBQUVQLHFCQUFLLE9BQU8sTUFBTTtBQUFBO0FBQUE7QUFHdEIsbUJBQU87QUFBQTtBQUFBLFVBRVQsbUJBQW1CLEdBQUcsWUFBWSxRQUFRLGFBQWE7QUFDckQsa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGdCQUFJLEVBQUUsU0FBUyxZQUFZO0FBQ3pCLHFCQUFPO0FBQUE7QUFFVCxnQkFBSSxDQUFDLGFBQWE7QUFDaEIscUJBQU87QUFBQTtBQUVULGtCQUFNLFNBQVMsS0FBSyxNQUFNLDBCQUEwQixHQUFHLFFBQVEsTUFBTSxTQUFTO0FBQzlFLGdCQUFJLFFBQVEsU0FBUztBQUNuQixxQkFBTztBQUFBO0FBRVQsbUJBQU87QUFBQTtBQUFBLFVBRVQsaUJBQWlCLFFBQVEsR0FBRztBQUMxQixrQkFBTSxFQUFDLFFBQVEsUUFBUSxZQUFXO0FBQ2xDLGtCQUFNLFdBQVcsWUFBWSxRQUFRLFVBQVUsS0FBSyxNQUFNLFFBQVE7QUFDbEUsbUJBQU8sYUFBYSxTQUFVLFlBQVcsU0FBUyxLQUFLLFdBQVcsU0FBUztBQUFBO0FBQUE7QUFHL0UsZ0JBQVEsY0FBYztBQUN0QixZQUFJLGlCQUFpQjtBQUFBLFVBQ25CLElBQUk7QUFBQSxVQUNKLFVBQVU7QUFBQSxVQUNWO0FBQUEsVUFDQSxVQUFVLFFBQU8sT0FBTyxTQUFTO0FBQy9CLGdCQUFJLFNBQVM7QUFDWCxxQkFBTSxVQUFVLElBQUksUUFBUSxFQUFDLGVBQU87QUFBQTtBQUFBO0FBQUEsVUFHeEMsYUFBYSxRQUFPLE9BQU8sU0FBUztBQUNsQyxnQkFBSSxPQUFNLFNBQVM7QUFDakIscUJBQU0sUUFBUSxXQUFXO0FBQUE7QUFBQTtBQUFBLFVBRzdCLE1BQU0sUUFBTyxPQUFPLFNBQVM7QUFDM0IsZ0JBQUksT0FBTSxTQUFTO0FBQ2pCLHFCQUFNLFFBQVEsV0FBVztBQUFBO0FBQUE7QUFBQSxVQUc3QixVQUFVLFFBQU87QUFDZixrQkFBTSxVQUFVLE9BQU07QUFDdEIsZ0JBQUksV0FBVyxRQUFRLGVBQWU7QUFDcEMsb0JBQU0sT0FBTztBQUFBLGdCQUNYO0FBQUE7QUFFRixrQkFBSSxPQUFNLGNBQWMscUJBQXFCLFVBQVUsT0FBTztBQUM1RDtBQUFBO0FBRUYsc0JBQVEsS0FBSyxPQUFNO0FBQ25CLHFCQUFNLGNBQWMsb0JBQW9CO0FBQUE7QUFBQTtBQUFBLFVBRzVDLFdBQVcsUUFBTyxNQUFNO0FBQ3RCLGdCQUFJLE9BQU0sU0FBUztBQUNqQixvQkFBTSxtQkFBbUIsS0FBSztBQUM5QixrQkFBSSxPQUFNLFFBQVEsWUFBWSxLQUFLLE9BQU8sa0JBQWtCLEtBQUssY0FBYztBQUM3RSxxQkFBSyxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFJckIsVUFBVTtBQUFBLFlBQ1IsU0FBUztBQUFBLFlBQ1QsVUFBVTtBQUFBLFlBQ1YsVUFBVTtBQUFBLFlBQ1YsaUJBQWlCO0FBQUEsWUFDakIsWUFBWTtBQUFBLFlBQ1osV0FBVztBQUFBLGNBQ1QsUUFBUTtBQUFBO0FBQUEsWUFFVixjQUFjO0FBQUEsWUFDZCxtQkFBbUI7QUFBQSxZQUNuQixZQUFZO0FBQUEsWUFDWixXQUFXO0FBQUEsWUFDWCxhQUFhO0FBQUEsWUFDYixVQUFVO0FBQUEsWUFFVixXQUFXO0FBQUEsWUFDWCxhQUFhO0FBQUEsWUFDYixlQUFlO0FBQUEsWUFDZixpQkFBaUI7QUFBQSxZQUNqQixZQUFZO0FBQUEsY0FDVixRQUFRO0FBQUE7QUFBQSxZQUVWLGFBQWE7QUFBQSxZQUNiLFNBQVM7QUFBQSxZQUNULGNBQWM7QUFBQSxZQUNkLFdBQVc7QUFBQSxZQUNYLGNBQWM7QUFBQSxZQUNkLFdBQVcsQ0FBQyxLQUFLLFNBQVMsS0FBSyxTQUFTO0FBQUEsWUFDeEMsVUFBVSxDQUFDLEtBQUssU0FBUyxLQUFLLFNBQVM7QUFBQSxZQUN2QyxvQkFBb0I7QUFBQSxZQUNwQixlQUFlO0FBQUEsWUFDZixZQUFZO0FBQUEsWUFDWixhQUFhO0FBQUEsWUFDYixhQUFhO0FBQUEsWUFDYixXQUFXO0FBQUEsY0FDVCxVQUFVO0FBQUEsY0FDVixRQUFRO0FBQUE7QUFBQSxZQUVWLFlBQVk7QUFBQSxjQUNWLFNBQVM7QUFBQSxnQkFDUCxNQUFNO0FBQUEsZ0JBQ04sWUFBWSxDQUFDLEtBQUssS0FBSyxTQUFTLFVBQVUsVUFBVTtBQUFBO0FBQUEsY0FFdEQsU0FBUztBQUFBLGdCQUNQLFFBQVE7QUFBQSxnQkFDUixVQUFVO0FBQUE7QUFBQTtBQUFBLFlBR2QsV0FBVztBQUFBLGNBQ1QsYUFBYTtBQUFBLGNBQ2IsTUFBTSxjQUFjO0FBQ2xCLG9CQUFJLGFBQWEsU0FBUyxHQUFHO0FBQzNCLHdCQUFNLE9BQU8sYUFBYTtBQUMxQix3QkFBTSxTQUFTLEtBQUssTUFBTSxLQUFLO0FBQy9CLHdCQUFNLGFBQWEsU0FBUyxPQUFPLFNBQVM7QUFDNUMsc0JBQUksUUFBUSxLQUFLLFdBQVcsS0FBSyxRQUFRLFNBQVMsV0FBVztBQUMzRCwyQkFBTyxLQUFLLFFBQVEsU0FBUztBQUFBLDZCQUNwQixLQUFLLE9BQU87QUFDckIsMkJBQU8sS0FBSztBQUFBLDZCQUNILGFBQWEsS0FBSyxLQUFLLFlBQVksWUFBWTtBQUN4RCwyQkFBTyxPQUFPLEtBQUs7QUFBQTtBQUFBO0FBR3ZCLHVCQUFPO0FBQUE7QUFBQSxjQUVULFlBQVk7QUFBQSxjQUNaLFlBQVk7QUFBQSxjQUNaLGFBQWE7QUFBQSxjQUNiLE1BQU0sYUFBYTtBQUNqQixvQkFBSSxRQUFRLEtBQUssV0FBVyxLQUFLLFFBQVEsU0FBUyxXQUFXO0FBQzNELHlCQUFPLFlBQVksUUFBUSxPQUFPLFlBQVksa0JBQWtCLFlBQVk7QUFBQTtBQUU5RSxvQkFBSSxRQUFRLFlBQVksUUFBUSxTQUFTO0FBQ3pDLG9CQUFJLE9BQU87QUFDVCwyQkFBUztBQUFBO0FBRVgsc0JBQU0sUUFBUSxZQUFZO0FBQzFCLG9CQUFJLENBQUMsY0FBYyxRQUFRO0FBQ3pCLDJCQUFTO0FBQUE7QUFFWCx1QkFBTztBQUFBO0FBQUEsY0FFVCxXQUFXLGFBQWE7QUFDdEIsc0JBQU0sT0FBTyxZQUFZLE1BQU0sZUFBZSxZQUFZO0FBQzFELHNCQUFNLFVBQVUsS0FBSyxXQUFXLFNBQVMsWUFBWTtBQUNyRCx1QkFBTztBQUFBLGtCQUNMLGFBQWEsUUFBUTtBQUFBLGtCQUNyQixpQkFBaUIsUUFBUTtBQUFBLGtCQUN6QixhQUFhLFFBQVE7QUFBQSxrQkFDckIsWUFBWSxRQUFRO0FBQUEsa0JBQ3BCLGtCQUFrQixRQUFRO0FBQUEsa0JBQzFCLGNBQWM7QUFBQTtBQUFBO0FBQUEsY0FHbEIsaUJBQWlCO0FBQ2YsdUJBQU8sS0FBSyxRQUFRO0FBQUE7QUFBQSxjQUV0QixnQkFBZ0IsYUFBYTtBQUMzQixzQkFBTSxPQUFPLFlBQVksTUFBTSxlQUFlLFlBQVk7QUFDMUQsc0JBQU0sVUFBVSxLQUFLLFdBQVcsU0FBUyxZQUFZO0FBQ3JELHVCQUFPO0FBQUEsa0JBQ0wsWUFBWSxRQUFRO0FBQUEsa0JBQ3BCLFVBQVUsUUFBUTtBQUFBO0FBQUE7QUFBQSxjQUd0QixZQUFZO0FBQUEsY0FDWixXQUFXO0FBQUEsY0FDWCxjQUFjO0FBQUEsY0FDZCxRQUFRO0FBQUEsY0FDUixhQUFhO0FBQUE7QUFBQTtBQUFBLFVBR2pCLGVBQWU7QUFBQSxZQUNiLFVBQVU7QUFBQSxZQUNWLFlBQVk7QUFBQSxZQUNaLFdBQVc7QUFBQTtBQUFBLFVBRWIsYUFBYTtBQUFBLFlBQ1gsYUFBYSxDQUFDLFNBQVMsU0FBUyxZQUFZLFNBQVMsY0FBYyxTQUFTO0FBQUEsWUFDNUUsWUFBWTtBQUFBLFlBQ1osV0FBVztBQUFBLGNBQ1QsYUFBYTtBQUFBLGNBQ2IsWUFBWTtBQUFBO0FBQUEsWUFFZCxXQUFXO0FBQUEsY0FDVCxXQUFXO0FBQUE7QUFBQSxZQUViLFlBQVk7QUFBQSxjQUNWLFdBQVc7QUFBQTtBQUFBO0FBQUEsVUFHZix3QkFBd0IsQ0FBQztBQUFBO0FBRzNCLFlBQUksVUFBdUIsdUJBQU8sT0FBTztBQUFBLFVBQ3pDLFdBQVc7QUFBQSxVQUNYLFlBQVk7QUFBQSxVQUNaLFFBQVE7QUFBQSxVQUNSLFFBQVE7QUFBQSxVQUNSLFVBQVU7QUFBQSxVQUNWLE9BQU87QUFBQSxVQUNQLFNBQVM7QUFBQTtBQUdULGNBQU0sY0FBYyxDQUFDLFFBQVEsS0FBSyxRQUFPLGdCQUFnQjtBQUN2RCxjQUFJLE9BQU8sUUFBUSxVQUFVO0FBQzNCLHFCQUFRLE9BQU8sS0FBSyxPQUFPO0FBQzNCLHdCQUFZLFFBQVEsRUFBQyxlQUFPLE9BQU87QUFBQSxxQkFDMUIsTUFBTSxNQUFNO0FBQ3JCLHFCQUFRO0FBQUE7QUFFVixpQkFBTztBQUFBO0FBRVQsZ0NBQXdCLFFBQVEsS0FBSyxRQUFPLGFBQWE7QUFDdkQsZ0JBQU0sUUFBUSxPQUFPLFFBQVE7QUFDN0IsY0FBSSxVQUFVLElBQUk7QUFDaEIsbUJBQU8sWUFBWSxRQUFRLEtBQUssUUFBTztBQUFBO0FBRXpDLGdCQUFNLE9BQU8sT0FBTyxZQUFZO0FBQ2hDLGlCQUFPLFVBQVUsT0FBTyxTQUFRO0FBQUE7QUFFbEMsY0FBTSxhQUFhLENBQUMsUUFBTyxRQUFRLFdBQVUsT0FBTyxPQUFPLFlBQVksS0FBSyxNQUFNLFNBQVEsR0FBRztBQUM3RixvQ0FBNEIsTUFBTTtBQUFBLFVBQ2hDLFlBQVksS0FBSztBQUNmLGtCQUFNO0FBQ04saUJBQUssY0FBYztBQUNuQixpQkFBSyxjQUFjO0FBQ25CLGlCQUFLLGVBQWU7QUFBQTtBQUFBLFVBRXRCLEtBQUssY0FBYztBQUNqQixrQkFBTSxRQUFRLEtBQUs7QUFDbkIsZ0JBQUksTUFBTSxRQUFRO0FBQ2hCLG9CQUFNLFNBQVMsS0FBSztBQUNwQix5QkFBVyxFQUFDLGVBQU8sV0FBVSxPQUFPO0FBQ2xDLG9CQUFJLE9BQU8sWUFBVyxPQUFPO0FBQzNCLHlCQUFPLE9BQU8sUUFBTztBQUFBO0FBQUE7QUFHekIsbUJBQUssZUFBZTtBQUFBO0FBRXRCLGtCQUFNLEtBQUs7QUFBQTtBQUFBLFVBRWIsTUFBTSxLQUFLLFFBQU87QUFDaEIsZ0JBQUksY0FBYyxNQUFNO0FBQ3RCLHFCQUFPO0FBQUE7QUFFVCxrQkFBTSxTQUFTLEtBQUs7QUFDcEIscUJBQVEsU0FBUyxXQUFVLE9BQU8sWUFBVyxNQUFNLFNBQy9DLGVBQWUsUUFBUSxLQUFLLGVBQWUsUUFBTyxNQUFNLEtBQUs7QUFDakUsbUJBQU8sV0FBVyxRQUFPLE9BQU8sU0FBUztBQUFBO0FBQUEsVUFFM0Msc0JBQXNCO0FBQ3BCLGtCQUFNLEVBQUMsWUFBWSxlQUFjLEtBQUs7QUFDdEMsZ0JBQUksRUFBQyxLQUFLLFFBQU8sS0FBSyxVQUFVO0FBQ2hDLGdCQUFJLEtBQUssUUFBUSxXQUFXLFNBQVM7QUFDbkMsa0JBQUksQ0FBQyxZQUFZO0FBQ2Ysc0JBQU07QUFBQTtBQUVSLGtCQUFJLENBQUMsWUFBWTtBQUNmLHNCQUFNLEtBQUssWUFBWSxTQUFTO0FBQUE7QUFBQTtBQUdwQyxpQkFBSyxNQUFNO0FBQ1gsaUJBQUssTUFBTTtBQUFBO0FBQUEsVUFFYixhQUFhO0FBQ1gsa0JBQU0sTUFBTSxLQUFLO0FBQ2pCLGtCQUFNLE1BQU0sS0FBSztBQUNqQixrQkFBTSxTQUFTLEtBQUssUUFBUTtBQUM1QixrQkFBTSxRQUFRO0FBQ2QsZ0JBQUksU0FBUyxLQUFLO0FBQ2xCLHFCQUFVLFFBQVEsS0FBSyxRQUFRLE9BQU8sU0FBUyxJQUFLLFNBQVMsT0FBTyxNQUFNLEtBQUssTUFBTTtBQUNyRixpQkFBSyxjQUFjLEtBQUssSUFBSSxPQUFPLFNBQVUsVUFBUyxJQUFJLElBQUk7QUFDOUQsaUJBQUssY0FBYyxLQUFLLE1BQU8sVUFBUyxNQUFNO0FBQzlDLHFCQUFTLFFBQVEsS0FBSyxTQUFTLEtBQUssU0FBUztBQUMzQyxvQkFBTSxLQUFLLEVBQUM7QUFBQTtBQUVkLG1CQUFPO0FBQUE7QUFBQSxVQUVULGlCQUFpQixPQUFPO0FBQ3RCLGtCQUFNLFNBQVMsS0FBSztBQUNwQixnQkFBSSxTQUFTLEtBQUssUUFBUSxPQUFPLFFBQVE7QUFDdkMscUJBQU8sT0FBTztBQUFBO0FBRWhCLG1CQUFPO0FBQUE7QUFBQSxVQUVULFlBQVk7QUFDVixrQkFBTTtBQUNOLGdCQUFJLENBQUMsS0FBSyxnQkFBZ0I7QUFDeEIsbUJBQUssaUJBQWlCLENBQUMsS0FBSztBQUFBO0FBQUE7QUFBQSxVQUdoQyxpQkFBaUIsT0FBTztBQUN0QixnQkFBSSxPQUFPLFVBQVUsVUFBVTtBQUM3QixzQkFBUSxLQUFLLE1BQU07QUFBQTtBQUVyQixtQkFBTyxVQUFVLE9BQU8sTUFBTSxLQUFLLG1CQUFvQixTQUFRLEtBQUssZUFBZSxLQUFLO0FBQUE7QUFBQSxVQUUxRixnQkFBZ0IsUUFBTztBQUNyQixrQkFBTSxRQUFRLEtBQUs7QUFDbkIsZ0JBQUksU0FBUSxLQUFLLFNBQVEsTUFBTSxTQUFTLEdBQUc7QUFDekMscUJBQU87QUFBQTtBQUVULG1CQUFPLEtBQUssaUJBQWlCLE1BQU0sUUFBTztBQUFBO0FBQUEsVUFFNUMsaUJBQWlCLE9BQU87QUFDdEIsbUJBQU8sS0FBSyxNQUFNLEtBQUssY0FBYyxLQUFLLG1CQUFtQixTQUFTLEtBQUs7QUFBQTtBQUFBLFVBRTdFLGVBQWU7QUFDYixtQkFBTyxLQUFLO0FBQUE7QUFBQTtBQUdoQixzQkFBYyxLQUFLO0FBQ25CLHNCQUFjLFdBQVc7QUFBQSxVQUN2QixPQUFPO0FBQUEsWUFDTCxVQUFVLGNBQWMsVUFBVTtBQUFBO0FBQUE7QUFJdEMsaUNBQXlCLG1CQUFtQixXQUFXO0FBQ3JELGdCQUFNLFFBQVE7QUFDZCxnQkFBTSxjQUFjO0FBQ3BCLGdCQUFNLEVBQUMsUUFBUSxNQUFNLEtBQUssS0FBSyxXQUFXLE9BQU8sVUFBVSxXQUFXLGtCQUFpQjtBQUN2RixnQkFBTSxPQUFPLFFBQVE7QUFDckIsZ0JBQU0sWUFBWSxXQUFXO0FBQzdCLGdCQUFNLEVBQUMsS0FBSyxNQUFNLEtBQUssU0FBUTtBQUMvQixnQkFBTSxhQUFhLENBQUMsY0FBYztBQUNsQyxnQkFBTSxhQUFhLENBQUMsY0FBYztBQUNsQyxnQkFBTSxlQUFlLENBQUMsY0FBYztBQUNwQyxnQkFBTSxhQUFjLFFBQU8sUUFBUyxhQUFZO0FBQ2hELGNBQUksVUFBVSxRQUFTLFFBQU8sUUFBUSxZQUFZLFFBQVE7QUFDMUQsY0FBSSxRQUFRLFNBQVMsU0FBUztBQUM5QixjQUFJLFVBQVUsZUFBZSxDQUFDLGNBQWMsQ0FBQyxZQUFZO0FBQ3ZELG1CQUFPLENBQUMsRUFBQyxPQUFPLFFBQU8sRUFBQyxPQUFPO0FBQUE7QUFFakMsc0JBQVksS0FBSyxLQUFLLE9BQU8sV0FBVyxLQUFLLE1BQU0sT0FBTztBQUMxRCxjQUFJLFlBQVksV0FBVztBQUN6QixzQkFBVSxRQUFRLFlBQVksVUFBVSxZQUFZLFFBQVE7QUFBQTtBQUU5RCxjQUFJLENBQUMsY0FBYyxZQUFZO0FBQzdCLHFCQUFTLEtBQUssSUFBSSxJQUFJO0FBQ3RCLHNCQUFVLEtBQUssS0FBSyxVQUFVLFVBQVU7QUFBQTtBQUUxQyxjQUFJLFdBQVcsU0FBUztBQUN0QixzQkFBVSxLQUFLLE1BQU0sT0FBTyxXQUFXO0FBQ3ZDLHNCQUFVLEtBQUssS0FBSyxPQUFPLFdBQVc7QUFBQSxpQkFDakM7QUFDTCxzQkFBVTtBQUNWLHNCQUFVO0FBQUE7QUFFWixjQUFJLGNBQWMsY0FBYyxRQUFRLFlBQWEsT0FBTSxPQUFPLE1BQU0sVUFBVSxNQUFPO0FBQ3ZGLHdCQUFZLEtBQUssTUFBTSxLQUFLLElBQUssT0FBTSxPQUFPLFNBQVM7QUFDdkQsc0JBQVcsT0FBTSxPQUFPO0FBQ3hCLHNCQUFVO0FBQ1Ysc0JBQVU7QUFBQSxxQkFDRCxjQUFjO0FBQ3ZCLHNCQUFVLGFBQWEsTUFBTTtBQUM3QixzQkFBVSxhQUFhLE1BQU07QUFDN0Isd0JBQVksUUFBUTtBQUNwQixzQkFBVyxXQUFVLFdBQVc7QUFBQSxpQkFDM0I7QUFDTCx3QkFBYSxXQUFVLFdBQVc7QUFDbEMsZ0JBQUksYUFBYSxXQUFXLEtBQUssTUFBTSxZQUFZLFVBQVUsTUFBTztBQUNsRSwwQkFBWSxLQUFLLE1BQU07QUFBQSxtQkFDbEI7QUFDTCwwQkFBWSxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBRzFCLGdCQUFNLGdCQUFnQixLQUFLLElBQ3pCLGVBQWUsVUFDZixlQUFlO0FBRWpCLG1CQUFTLEtBQUssSUFBSSxJQUFJLGNBQWMsYUFBYSxnQkFBZ0I7QUFDakUsb0JBQVUsS0FBSyxNQUFNLFVBQVUsVUFBVTtBQUN6QyxvQkFBVSxLQUFLLE1BQU0sVUFBVSxVQUFVO0FBQ3pDLGNBQUksSUFBSTtBQUNSLGNBQUksWUFBWTtBQUNkLGdCQUFJLGlCQUFpQixZQUFZLEtBQUs7QUFDcEMsb0JBQU0sS0FBSyxFQUFDLE9BQU87QUFDbkIsa0JBQUksVUFBVSxLQUFLO0FBQ2pCO0FBQUE7QUFFRixrQkFBSSxhQUFhLEtBQUssTUFBTyxXQUFVLElBQUksV0FBVyxVQUFVLFFBQVEsS0FBSyxrQkFBa0IsS0FBSyxZQUFZLHFCQUFxQjtBQUNuSTtBQUFBO0FBQUEsdUJBRU8sVUFBVSxLQUFLO0FBQ3hCO0FBQUE7QUFBQTtBQUdKLGlCQUFPLElBQUksV0FBVyxFQUFFLEdBQUc7QUFDekIsa0JBQU0sS0FBSyxFQUFDLE9BQU8sS0FBSyxNQUFPLFdBQVUsSUFBSSxXQUFXLFVBQVU7QUFBQTtBQUVwRSxjQUFJLGNBQWMsaUJBQWlCLFlBQVksS0FBSztBQUNsRCxnQkFBSSxNQUFNLFVBQVUsYUFBYSxNQUFNLE1BQU0sU0FBUyxHQUFHLE9BQU8sS0FBSyxrQkFBa0IsS0FBSyxZQUFZLHFCQUFxQjtBQUMzSCxvQkFBTSxNQUFNLFNBQVMsR0FBRyxRQUFRO0FBQUEsbUJBQzNCO0FBQ0wsb0JBQU0sS0FBSyxFQUFDLE9BQU87QUFBQTtBQUFBLHFCQUVaLENBQUMsY0FBYyxZQUFZLEtBQUs7QUFDekMsa0JBQU0sS0FBSyxFQUFDLE9BQU87QUFBQTtBQUVyQixpQkFBTztBQUFBO0FBRVQsbUNBQTJCLE9BQU8sWUFBWSxFQUFDLFlBQVksZUFBYztBQUN2RSxnQkFBTSxNQUFNLFVBQVU7QUFDdEIsZ0JBQU0sUUFBUyxjQUFhLEtBQUssSUFBSSxPQUFPLEtBQUssSUFBSSxTQUFTO0FBQzlELGdCQUFNLFNBQVMsT0FBTyxhQUFjLE1BQUssT0FBTztBQUNoRCxpQkFBTyxLQUFLLElBQUksYUFBYSxPQUFPO0FBQUE7QUFFdEMsc0NBQThCLE1BQU07QUFBQSxVQUNsQyxZQUFZLEtBQUs7QUFDZixrQkFBTTtBQUNOLGlCQUFLLFFBQVE7QUFDYixpQkFBSyxNQUFNO0FBQ1gsaUJBQUssY0FBYztBQUNuQixpQkFBSyxZQUFZO0FBQ2pCLGlCQUFLLGNBQWM7QUFBQTtBQUFBLFVBRXJCLE1BQU0sS0FBSyxRQUFPO0FBQ2hCLGdCQUFJLGNBQWMsTUFBTTtBQUN0QixxQkFBTztBQUFBO0FBRVQsZ0JBQUssUUFBTyxRQUFRLFlBQVksZUFBZSxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU07QUFDekUscUJBQU87QUFBQTtBQUVULG1CQUFPLENBQUM7QUFBQTtBQUFBLFVBRVYseUJBQXlCO0FBQ3ZCLGtCQUFNLEVBQUMsZ0JBQWUsS0FBSztBQUMzQixrQkFBTSxFQUFDLFlBQVksZUFBYyxLQUFLO0FBQ3RDLGdCQUFJLEVBQUMsS0FBSyxRQUFPO0FBQ2pCLGtCQUFNLFNBQVMsT0FBTSxNQUFNLGFBQWEsTUFBTTtBQUM5QyxrQkFBTSxTQUFTLE9BQU0sTUFBTSxhQUFhLE1BQU07QUFDOUMsZ0JBQUksYUFBYTtBQUNmLG9CQUFNLFVBQVUsS0FBSztBQUNyQixvQkFBTSxVQUFVLEtBQUs7QUFDckIsa0JBQUksVUFBVSxLQUFLLFVBQVUsR0FBRztBQUM5Qix1QkFBTztBQUFBLHlCQUNFLFVBQVUsS0FBSyxVQUFVLEdBQUc7QUFDckMsdUJBQU87QUFBQTtBQUFBO0FBR1gsZ0JBQUksUUFBUSxLQUFLO0FBQ2Ysa0JBQUksU0FBUztBQUNiLGtCQUFJLE9BQU8sT0FBTyxvQkFBb0IsT0FBTyxPQUFPLGtCQUFrQjtBQUNwRSx5QkFBUyxLQUFLLElBQUksTUFBTTtBQUFBO0FBRTFCLHFCQUFPLE1BQU07QUFDYixrQkFBSSxDQUFDLGFBQWE7QUFDaEIsdUJBQU8sTUFBTTtBQUFBO0FBQUE7QUFHakIsaUJBQUssTUFBTTtBQUNYLGlCQUFLLE1BQU07QUFBQTtBQUFBLFVBRWIsZUFBZTtBQUNiLGtCQUFNLFdBQVcsS0FBSyxRQUFRO0FBQzlCLGdCQUFJLEVBQUMsZUFBZSxhQUFZO0FBQ2hDLGdCQUFJO0FBQ0osZ0JBQUksVUFBVTtBQUNaLHlCQUFXLEtBQUssS0FBSyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sS0FBSyxNQUFNLFlBQVk7QUFDOUUsa0JBQUksV0FBVyxLQUFNO0FBQ25CLHdCQUFRLEtBQUssVUFBVSxLQUFLLHNCQUFzQiwwQ0FBMEM7QUFDNUYsMkJBQVc7QUFBQTtBQUFBLG1CQUVSO0FBQ0wseUJBQVcsS0FBSztBQUNoQiw4QkFBZ0IsaUJBQWlCO0FBQUE7QUFFbkMsZ0JBQUksZUFBZTtBQUNqQix5QkFBVyxLQUFLLElBQUksZUFBZTtBQUFBO0FBRXJDLG1CQUFPO0FBQUE7QUFBQSxVQUVULG1CQUFtQjtBQUNqQixtQkFBTyxPQUFPO0FBQUE7QUFBQSxVQUVoQixhQUFhO0FBQ1gsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLFdBQVcsS0FBSztBQUN0QixnQkFBSSxXQUFXLEtBQUs7QUFDcEIsdUJBQVcsS0FBSyxJQUFJLEdBQUc7QUFDdkIsa0JBQU0sMEJBQTBCO0FBQUEsY0FDOUI7QUFBQSxjQUNBLFFBQVEsS0FBSztBQUFBLGNBQ2IsS0FBSyxLQUFLO0FBQUEsY0FDVixLQUFLLEtBQUs7QUFBQSxjQUNWLFdBQVcsU0FBUztBQUFBLGNBQ3BCLE1BQU0sU0FBUztBQUFBLGNBQ2YsT0FBTyxTQUFTO0FBQUEsY0FDaEIsV0FBVyxLQUFLO0FBQUEsY0FDaEIsWUFBWSxLQUFLO0FBQUEsY0FDakIsYUFBYSxTQUFTLGVBQWU7QUFBQSxjQUNyQyxlQUFlLFNBQVMsa0JBQWtCO0FBQUE7QUFFNUMsa0JBQU0sWUFBWSxLQUFLLFVBQVU7QUFDakMsa0JBQU0sUUFBUSxnQkFBZ0IseUJBQXlCO0FBQ3ZELGdCQUFJLEtBQUssV0FBVyxTQUFTO0FBQzNCLGlDQUFtQixPQUFPLE1BQU07QUFBQTtBQUVsQyxnQkFBSSxLQUFLLFNBQVM7QUFDaEIsb0JBQU07QUFDTixtQkFBSyxRQUFRLEtBQUs7QUFDbEIsbUJBQUssTUFBTSxLQUFLO0FBQUEsbUJBQ1g7QUFDTCxtQkFBSyxRQUFRLEtBQUs7QUFDbEIsbUJBQUssTUFBTSxLQUFLO0FBQUE7QUFFbEIsbUJBQU87QUFBQTtBQUFBLFVBRVQsWUFBWTtBQUNWLGtCQUFNLFFBQVEsS0FBSztBQUNuQixnQkFBSSxRQUFRLEtBQUs7QUFDakIsZ0JBQUksTUFBTSxLQUFLO0FBQ2Ysa0JBQU07QUFDTixnQkFBSSxLQUFLLFFBQVEsVUFBVSxNQUFNLFFBQVE7QUFDdkMsb0JBQU0sU0FBVSxPQUFNLFNBQVMsS0FBSyxJQUFJLE1BQU0sU0FBUyxHQUFHLEtBQUs7QUFDL0QsdUJBQVM7QUFDVCxxQkFBTztBQUFBO0FBRVQsaUJBQUssY0FBYztBQUNuQixpQkFBSyxZQUFZO0FBQ2pCLGlCQUFLLGNBQWMsTUFBTTtBQUFBO0FBQUEsVUFFM0IsaUJBQWlCLE9BQU87QUFDdEIsbUJBQU8sYUFBYSxPQUFPLEtBQUssTUFBTSxRQUFRLFFBQVEsS0FBSyxRQUFRLE1BQU07QUFBQTtBQUFBO0FBSTdFLGtDQUEwQixnQkFBZ0I7QUFBQSxVQUN4QyxzQkFBc0I7QUFDcEIsa0JBQU0sRUFBQyxLQUFLLFFBQU8sS0FBSyxVQUFVO0FBQ2xDLGlCQUFLLE1BQU0sZUFBZSxPQUFPLE1BQU07QUFDdkMsaUJBQUssTUFBTSxlQUFlLE9BQU8sTUFBTTtBQUN2QyxpQkFBSztBQUFBO0FBQUEsVUFFUCxtQkFBbUI7QUFDakIsa0JBQU0sYUFBYSxLQUFLO0FBQ3hCLGtCQUFNLFNBQVMsYUFBYSxLQUFLLFFBQVEsS0FBSztBQUM5QyxrQkFBTSxjQUFjLFVBQVUsS0FBSyxRQUFRLE1BQU07QUFDakQsa0JBQU0sUUFBUyxjQUFhLEtBQUssSUFBSSxlQUFlLEtBQUssSUFBSSxpQkFBaUI7QUFDOUUsa0JBQU0sV0FBVyxLQUFLLHdCQUF3QjtBQUM5QyxtQkFBTyxLQUFLLEtBQUssU0FBUyxLQUFLLElBQUksSUFBSSxTQUFTLGFBQWE7QUFBQTtBQUFBLFVBRS9ELGlCQUFpQixPQUFPO0FBQ3RCLG1CQUFPLFVBQVUsT0FBTyxNQUFNLEtBQUssbUJBQW9CLFNBQVEsS0FBSyxlQUFlLEtBQUs7QUFBQTtBQUFBLFVBRTFGLGlCQUFpQixPQUFPO0FBQ3RCLG1CQUFPLEtBQUssY0FBYyxLQUFLLG1CQUFtQixTQUFTLEtBQUs7QUFBQTtBQUFBO0FBR3BFLG9CQUFZLEtBQUs7QUFDakIsb0JBQVksV0FBVztBQUFBLFVBQ3JCLE9BQU87QUFBQSxZQUNMLFVBQVUsTUFBTSxXQUFXO0FBQUE7QUFBQTtBQUkvQix5QkFBaUIsU0FBUztBQUN4QixnQkFBTSxTQUFTLFVBQVcsS0FBSyxJQUFJLElBQUksS0FBSyxNQUFNLE1BQU07QUFDeEQsaUJBQU8sV0FBVztBQUFBO0FBRXBCLCtCQUF1QixtQkFBbUIsV0FBVztBQUNuRCxnQkFBTSxTQUFTLEtBQUssTUFBTSxNQUFNLFVBQVU7QUFDMUMsZ0JBQU0saUJBQWlCLEtBQUssS0FBSyxVQUFVLE1BQU0sS0FBSyxJQUFJLElBQUk7QUFDOUQsZ0JBQU0sUUFBUTtBQUNkLGNBQUksVUFBVSxnQkFBZ0Isa0JBQWtCLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxNQUFNLE1BQU0sVUFBVTtBQUM3RixjQUFJLE1BQU0sS0FBSyxNQUFNLE1BQU07QUFDM0IsY0FBSSxjQUFjLEtBQUssTUFBTSxVQUFVLEtBQUssSUFBSSxJQUFJO0FBQ3BELGNBQUksWUFBWSxNQUFNLElBQUksS0FBSyxJQUFJLElBQUksS0FBSyxJQUFJLFFBQVE7QUFDeEQsYUFBRztBQUNELGtCQUFNLEtBQUssRUFBQyxPQUFPLFNBQVMsT0FBTyxRQUFRO0FBQzNDLGNBQUU7QUFDRixnQkFBSSxnQkFBZ0IsSUFBSTtBQUN0Qiw0QkFBYztBQUNkLGdCQUFFO0FBQ0YsMEJBQVksT0FBTyxJQUFJLElBQUk7QUFBQTtBQUU3QixzQkFBVSxLQUFLLE1BQU0sY0FBYyxLQUFLLElBQUksSUFBSSxPQUFPLGFBQWE7QUFBQSxtQkFDN0QsTUFBTSxVQUFXLFFBQVEsVUFBVSxjQUFjO0FBQzFELGdCQUFNLFdBQVcsZ0JBQWdCLGtCQUFrQixLQUFLO0FBQ3hELGdCQUFNLEtBQUssRUFBQyxPQUFPLFVBQVUsT0FBTyxRQUFRO0FBQzVDLGlCQUFPO0FBQUE7QUFFVCx1Q0FBK0IsTUFBTTtBQUFBLFVBQ25DLFlBQVksS0FBSztBQUNmLGtCQUFNO0FBQ04saUJBQUssUUFBUTtBQUNiLGlCQUFLLE1BQU07QUFDWCxpQkFBSyxjQUFjO0FBQ25CLGlCQUFLLGNBQWM7QUFBQTtBQUFBLFVBRXJCLE1BQU0sS0FBSyxRQUFPO0FBQ2hCLGtCQUFNLFFBQVEsZ0JBQWdCLFVBQVUsTUFBTSxNQUFNLE1BQU0sQ0FBQyxLQUFLO0FBQ2hFLGdCQUFJLFVBQVUsR0FBRztBQUNmLG1CQUFLLFFBQVE7QUFDYixxQkFBTztBQUFBO0FBRVQsbUJBQU8sZUFBZSxVQUFVLFFBQVEsSUFBSSxRQUFRO0FBQUE7QUFBQSxVQUV0RCxzQkFBc0I7QUFDcEIsa0JBQU0sRUFBQyxLQUFLLFFBQU8sS0FBSyxVQUFVO0FBQ2xDLGlCQUFLLE1BQU0sZUFBZSxPQUFPLEtBQUssSUFBSSxHQUFHLE9BQU87QUFDcEQsaUJBQUssTUFBTSxlQUFlLE9BQU8sS0FBSyxJQUFJLEdBQUcsT0FBTztBQUNwRCxnQkFBSSxLQUFLLFFBQVEsYUFBYTtBQUM1QixtQkFBSyxRQUFRO0FBQUE7QUFFZixpQkFBSztBQUFBO0FBQUEsVUFFUCx5QkFBeUI7QUFDdkIsa0JBQU0sRUFBQyxZQUFZLGVBQWMsS0FBSztBQUN0QyxnQkFBSSxNQUFNLEtBQUs7QUFDZixnQkFBSSxNQUFNLEtBQUs7QUFDZixrQkFBTSxTQUFTLE9BQU0sTUFBTSxhQUFhLE1BQU07QUFDOUMsa0JBQU0sU0FBUyxPQUFNLE1BQU0sYUFBYSxNQUFNO0FBQzlDLGtCQUFNLE1BQU0sQ0FBQyxHQUFHLE1BQU0sS0FBSyxJQUFJLElBQUksS0FBSyxNQUFNLE1BQU0sTUFBTTtBQUMxRCxnQkFBSSxRQUFRLEtBQUs7QUFDZixrQkFBSSxPQUFPLEdBQUc7QUFDWix1QkFBTztBQUNQLHVCQUFPO0FBQUEscUJBQ0Y7QUFDTCx1QkFBTyxJQUFJLEtBQUs7QUFDaEIsdUJBQU8sSUFBSSxLQUFLO0FBQUE7QUFBQTtBQUdwQixnQkFBSSxPQUFPLEdBQUc7QUFDWixxQkFBTyxJQUFJLEtBQUs7QUFBQTtBQUVsQixnQkFBSSxPQUFPLEdBQUc7QUFDWixxQkFBTyxJQUFJLEtBQUs7QUFBQTtBQUVsQixnQkFBSSxLQUFLLFNBQVMsS0FBSyxRQUFRLEtBQUssaUJBQWlCLFFBQVEsSUFBSSxLQUFLLEtBQUssSUFBSTtBQUM3RSxxQkFBTyxJQUFJLEtBQUs7QUFBQTtBQUVsQixpQkFBSyxNQUFNO0FBQ1gsaUJBQUssTUFBTTtBQUFBO0FBQUEsVUFFYixhQUFhO0FBQ1gsa0JBQU0sT0FBTyxLQUFLO0FBQ2xCLGtCQUFNLG9CQUFvQjtBQUFBLGNBQ3hCLEtBQUssS0FBSztBQUFBLGNBQ1YsS0FBSyxLQUFLO0FBQUE7QUFFWixrQkFBTSxRQUFRLGNBQWMsbUJBQW1CO0FBQy9DLGdCQUFJLEtBQUssV0FBVyxTQUFTO0FBQzNCLGlDQUFtQixPQUFPLE1BQU07QUFBQTtBQUVsQyxnQkFBSSxLQUFLLFNBQVM7QUFDaEIsb0JBQU07QUFDTixtQkFBSyxRQUFRLEtBQUs7QUFDbEIsbUJBQUssTUFBTSxLQUFLO0FBQUEsbUJBQ1g7QUFDTCxtQkFBSyxRQUFRLEtBQUs7QUFDbEIsbUJBQUssTUFBTSxLQUFLO0FBQUE7QUFFbEIsbUJBQU87QUFBQTtBQUFBLFVBRVQsaUJBQWlCLE9BQU87QUFDdEIsbUJBQU8sVUFBVSxTQUNiLE1BQ0EsYUFBYSxPQUFPLEtBQUssTUFBTSxRQUFRLFFBQVEsS0FBSyxRQUFRLE1BQU07QUFBQTtBQUFBLFVBRXhFLFlBQVk7QUFDVixrQkFBTSxRQUFRLEtBQUs7QUFDbkIsa0JBQU07QUFDTixpQkFBSyxjQUFjLE1BQU07QUFDekIsaUJBQUssY0FBYyxNQUFNLEtBQUssT0FBTyxNQUFNO0FBQUE7QUFBQSxVQUU3QyxpQkFBaUIsT0FBTztBQUN0QixnQkFBSSxVQUFVLFVBQWEsVUFBVSxHQUFHO0FBQ3RDLHNCQUFRLEtBQUs7QUFBQTtBQUVmLGdCQUFJLFVBQVUsUUFBUSxNQUFNLFFBQVE7QUFDbEMscUJBQU87QUFBQTtBQUVULG1CQUFPLEtBQUssbUJBQW1CLFVBQVUsS0FBSyxNQUMxQyxJQUNDLE9BQU0sU0FBUyxLQUFLLGVBQWUsS0FBSztBQUFBO0FBQUEsVUFFL0MsaUJBQWlCLE9BQU87QUFDdEIsa0JBQU0sVUFBVSxLQUFLLG1CQUFtQjtBQUN4QyxtQkFBTyxLQUFLLElBQUksSUFBSSxLQUFLLGNBQWMsVUFBVSxLQUFLO0FBQUE7QUFBQTtBQUcxRCx5QkFBaUIsS0FBSztBQUN0Qix5QkFBaUIsV0FBVztBQUFBLFVBQzFCLE9BQU87QUFBQSxZQUNMLFVBQVUsTUFBTSxXQUFXO0FBQUEsWUFDM0IsT0FBTztBQUFBLGNBQ0wsU0FBUztBQUFBO0FBQUE7QUFBQTtBQUtmLHVDQUErQixNQUFNO0FBQ25DLGdCQUFNLFdBQVcsS0FBSztBQUN0QixjQUFJLFNBQVMsV0FBVyxLQUFLLFNBQVM7QUFDcEMsa0JBQU0sVUFBVSxVQUFVLFNBQVM7QUFDbkMsbUJBQU8sZUFBZSxTQUFTLFFBQVEsU0FBUyxLQUFLLE1BQU0sU0FBUyxLQUFLLFFBQVEsUUFBUTtBQUFBO0FBRTNGLGlCQUFPO0FBQUE7QUFFVCxrQ0FBMEIsS0FBSyxNQUFNLE9BQU87QUFDMUMsa0JBQVEsUUFBUSxTQUFTLFFBQVEsQ0FBQztBQUNsQyxpQkFBTztBQUFBLFlBQ0wsR0FBRyxhQUFhLEtBQUssS0FBSyxRQUFRO0FBQUEsWUFDbEMsR0FBRyxNQUFNLFNBQVMsS0FBSztBQUFBO0FBQUE7QUFHM0IsaUNBQXlCLE9BQU8sS0FBSyxNQUFNLEtBQUssS0FBSztBQUNuRCxjQUFJLFVBQVUsT0FBTyxVQUFVLEtBQUs7QUFDbEMsbUJBQU87QUFBQSxjQUNMLE9BQU8sTUFBTyxPQUFPO0FBQUEsY0FDckIsS0FBSyxNQUFPLE9BQU87QUFBQTtBQUFBLHFCQUVaLFFBQVEsT0FBTyxRQUFRLEtBQUs7QUFDckMsbUJBQU87QUFBQSxjQUNMLE9BQU8sTUFBTTtBQUFBLGNBQ2IsS0FBSztBQUFBO0FBQUE7QUFHVCxpQkFBTztBQUFBLFlBQ0wsT0FBTztBQUFBLFlBQ1AsS0FBSyxNQUFNO0FBQUE7QUFBQTtBQUdmLG9DQUE0QixPQUFPO0FBQ2pDLGdCQUFNLE9BQU87QUFBQSxZQUNYLEdBQUcsTUFBTSxPQUFPLE1BQU0sU0FBUztBQUFBLFlBQy9CLEdBQUcsTUFBTSxRQUFRLE1BQU0sU0FBUztBQUFBLFlBQ2hDLEdBQUcsTUFBTSxNQUFNLE1BQU0sU0FBUztBQUFBLFlBQzlCLEdBQUcsTUFBTSxTQUFTLE1BQU0sU0FBUztBQUFBO0FBRW5DLGdCQUFNLFNBQVMsT0FBTyxPQUFPLElBQUk7QUFDakMsZ0JBQU0sYUFBYTtBQUNuQixnQkFBTSxVQUFVO0FBQ2hCLGdCQUFNLGFBQWEsTUFBTSxhQUFhO0FBQ3RDLGdCQUFNLGlCQUFpQixNQUFNLFFBQVE7QUFDckMsZ0JBQU0sa0JBQWtCLGVBQWUsb0JBQW9CLEtBQUssYUFBYTtBQUM3RSxtQkFBUyxJQUFJLEdBQUcsSUFBSSxZQUFZLEtBQUs7QUFDbkMsa0JBQU0sT0FBTyxlQUFlLFdBQVcsTUFBTSxxQkFBcUI7QUFDbEUsb0JBQVEsS0FBSyxLQUFLO0FBQ2xCLGtCQUFNLGdCQUFnQixNQUFNLGlCQUFpQixHQUFHLE1BQU0sY0FBYyxRQUFRLElBQUk7QUFDaEYsa0JBQU0sU0FBUyxPQUFPLEtBQUs7QUFDM0Isa0JBQU0sV0FBVyxpQkFBaUIsTUFBTSxLQUFLLFFBQVEsTUFBTSxhQUFhO0FBQ3hFLHVCQUFXLEtBQUs7QUFDaEIsa0JBQU0sZUFBZSxnQkFBZ0IsTUFBTSxjQUFjLEtBQUs7QUFDOUQsa0JBQU0sUUFBUSxLQUFLLE1BQU0sVUFBVTtBQUNuQyxrQkFBTSxVQUFVLGdCQUFnQixPQUFPLGNBQWMsR0FBRyxTQUFTLEdBQUcsR0FBRztBQUN2RSxrQkFBTSxVQUFVLGdCQUFnQixPQUFPLGNBQWMsR0FBRyxTQUFTLEdBQUcsSUFBSTtBQUN4RSx5QkFBYSxRQUFRLE1BQU0sY0FBYyxTQUFTO0FBQUE7QUFFcEQsZ0JBQU0sZUFDSixLQUFLLElBQUksT0FBTyxHQUNoQixPQUFPLElBQUksS0FBSyxHQUNoQixLQUFLLElBQUksT0FBTyxHQUNoQixPQUFPLElBQUksS0FBSztBQUVsQixnQkFBTSxtQkFBbUIscUJBQXFCLE9BQU8sWUFBWTtBQUFBO0FBRW5FLDhCQUFzQixRQUFRLE1BQU0sT0FBTyxTQUFTLFNBQVM7QUFDM0QsZ0JBQU0sTUFBTSxLQUFLLElBQUksS0FBSyxJQUFJO0FBQzlCLGdCQUFNLE1BQU0sS0FBSyxJQUFJLEtBQUssSUFBSTtBQUM5QixjQUFJLElBQUk7QUFDUixjQUFJLElBQUk7QUFDUixjQUFJLFFBQVEsUUFBUSxLQUFLLEdBQUc7QUFDMUIsZ0JBQUssTUFBSyxJQUFJLFFBQVEsU0FBUztBQUMvQixtQkFBTyxJQUFJLEtBQUssSUFBSSxPQUFPLEdBQUcsS0FBSyxJQUFJO0FBQUEscUJBQzlCLFFBQVEsTUFBTSxLQUFLLEdBQUc7QUFDL0IsZ0JBQUssU0FBUSxNQUFNLEtBQUssS0FBSztBQUM3QixtQkFBTyxJQUFJLEtBQUssSUFBSSxPQUFPLEdBQUcsS0FBSyxJQUFJO0FBQUE7QUFFekMsY0FBSSxRQUFRLFFBQVEsS0FBSyxHQUFHO0FBQzFCLGdCQUFLLE1BQUssSUFBSSxRQUFRLFNBQVM7QUFDL0IsbUJBQU8sSUFBSSxLQUFLLElBQUksT0FBTyxHQUFHLEtBQUssSUFBSTtBQUFBLHFCQUM5QixRQUFRLE1BQU0sS0FBSyxHQUFHO0FBQy9CLGdCQUFLLFNBQVEsTUFBTSxLQUFLLEtBQUs7QUFDN0IsbUJBQU8sSUFBSSxLQUFLLElBQUksT0FBTyxHQUFHLEtBQUssSUFBSTtBQUFBO0FBQUE7QUFHM0Msc0NBQThCLE9BQU8sWUFBWSxTQUFTO0FBQ3hELGdCQUFNLFFBQVE7QUFDZCxnQkFBTSxhQUFhLE1BQU0sYUFBYTtBQUN0QyxnQkFBTSxPQUFPLE1BQU07QUFDbkIsZ0JBQU0sUUFBUSxzQkFBc0IsUUFBUTtBQUM1QyxnQkFBTSxnQkFBZ0IsTUFBTTtBQUM1QixnQkFBTSxrQkFBa0IsS0FBSyxZQUFZLG9CQUFvQixLQUFLLGFBQWE7QUFDL0UsbUJBQVMsSUFBSSxHQUFHLElBQUksWUFBWSxLQUFLO0FBQ25DLGtCQUFNLHFCQUFxQixNQUFNLGlCQUFpQixHQUFHLGdCQUFnQixRQUFRLFFBQVEsSUFBSTtBQUN6RixrQkFBTSxRQUFRLEtBQUssTUFBTSxVQUFVLGdCQUFnQixtQkFBbUIsUUFBUTtBQUM5RSxrQkFBTSxPQUFPLFdBQVc7QUFDeEIsa0JBQU0sSUFBSSxVQUFVLG1CQUFtQixHQUFHLEtBQUssR0FBRztBQUNsRCxrQkFBTSxZQUFZLHFCQUFxQjtBQUN2QyxrQkFBTSxPQUFPLGlCQUFpQixtQkFBbUIsR0FBRyxLQUFLLEdBQUc7QUFDNUQsa0JBQU0sS0FBSztBQUFBLGNBQ1QsR0FBRyxtQkFBbUI7QUFBQSxjQUN0QjtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsY0FDQSxLQUFLO0FBQUEsY0FDTCxPQUFPLE9BQU8sS0FBSztBQUFBLGNBQ25CLFFBQVEsSUFBSSxLQUFLO0FBQUE7QUFBQTtBQUdyQixpQkFBTztBQUFBO0FBRVQsc0NBQThCLE9BQU87QUFDbkMsY0FBSSxVQUFVLEtBQUssVUFBVSxLQUFLO0FBQ2hDLG1CQUFPO0FBQUEscUJBQ0UsUUFBUSxLQUFLO0FBQ3RCLG1CQUFPO0FBQUE7QUFFVCxpQkFBTztBQUFBO0FBRVQsa0NBQTBCLEdBQUcsR0FBRyxPQUFPO0FBQ3JDLGNBQUksVUFBVSxTQUFTO0FBQ3JCLGlCQUFLO0FBQUEscUJBQ0ksVUFBVSxVQUFVO0FBQzdCLGlCQUFNLElBQUk7QUFBQTtBQUVaLGlCQUFPO0FBQUE7QUFFVCwyQkFBbUIsR0FBRyxHQUFHLE9BQU87QUFDOUIsY0FBSSxVQUFVLE1BQU0sVUFBVSxLQUFLO0FBQ2pDLGlCQUFNLElBQUk7QUFBQSxxQkFDRCxRQUFRLE9BQU8sUUFBUSxJQUFJO0FBQ3BDLGlCQUFLO0FBQUE7QUFFUCxpQkFBTztBQUFBO0FBRVQsaUNBQXlCLE9BQU8sWUFBWTtBQUMxQyxnQkFBTSxFQUFDLEtBQUssU0FBUyxFQUFDLGtCQUFnQjtBQUN0QyxtQkFBUyxJQUFJLGFBQWEsR0FBRyxLQUFLLEdBQUcsS0FBSztBQUN4QyxrQkFBTSxjQUFjLFlBQVksV0FBVyxNQUFNLHFCQUFxQjtBQUN0RSxrQkFBTSxTQUFTLE9BQU8sWUFBWTtBQUNsQyxrQkFBTSxFQUFDLEdBQUcsR0FBRyxXQUFXLE1BQU0sS0FBSyxPQUFPLFdBQVUsTUFBTSxpQkFBaUI7QUFDM0Usa0JBQU0sRUFBQyxrQkFBaUI7QUFDeEIsZ0JBQUksQ0FBQyxjQUFjLGdCQUFnQjtBQUNqQyxvQkFBTSxlQUFlLGNBQWMsWUFBWTtBQUMvQyxvQkFBTSxVQUFVLFVBQVUsWUFBWTtBQUN0QyxrQkFBSSxZQUFZO0FBQ2hCLG9CQUFNLGVBQWUsT0FBTyxRQUFRO0FBQ3BDLG9CQUFNLGNBQWMsTUFBTSxRQUFRO0FBQ2xDLG9CQUFNLGdCQUFnQixRQUFRLE9BQU8sUUFBUTtBQUM3QyxvQkFBTSxpQkFBaUIsU0FBUyxNQUFNLFFBQVE7QUFDOUMsa0JBQUksT0FBTyxPQUFPLGNBQWMsS0FBSyxPQUFLLE1BQU0sSUFBSTtBQUNsRCxvQkFBSTtBQUNKLG1DQUFtQixLQUFLO0FBQUEsa0JBQ3RCLEdBQUc7QUFBQSxrQkFDSCxHQUFHO0FBQUEsa0JBQ0gsR0FBRztBQUFBLGtCQUNILEdBQUc7QUFBQSxrQkFDSCxRQUFRO0FBQUE7QUFFVixvQkFBSTtBQUFBLHFCQUNDO0FBQ0wsb0JBQUksU0FBUyxjQUFjLGFBQWEsZUFBZTtBQUFBO0FBQUE7QUFHM0QsdUJBQ0UsS0FDQSxNQUFNLGFBQWEsSUFDbkIsR0FDQSxJQUFLLE9BQU8sYUFBYSxHQUN6QixRQUNBO0FBQUEsY0FDRSxPQUFPLFlBQVk7QUFBQSxjQUNuQjtBQUFBLGNBQ0EsY0FBYztBQUFBO0FBQUE7QUFBQTtBQUt0QixnQ0FBd0IsT0FBTyxRQUFRLFVBQVUsWUFBWTtBQUMzRCxnQkFBTSxFQUFDLFFBQU87QUFDZCxjQUFJLFVBQVU7QUFDWixnQkFBSSxJQUFJLE1BQU0sU0FBUyxNQUFNLFNBQVMsUUFBUSxHQUFHO0FBQUEsaUJBQzVDO0FBQ0wsZ0JBQUksZ0JBQWdCLE1BQU0saUJBQWlCLEdBQUc7QUFDOUMsZ0JBQUksT0FBTyxjQUFjLEdBQUcsY0FBYztBQUMxQyxxQkFBUyxJQUFJLEdBQUcsSUFBSSxZQUFZLEtBQUs7QUFDbkMsOEJBQWdCLE1BQU0saUJBQWlCLEdBQUc7QUFDMUMsa0JBQUksT0FBTyxjQUFjLEdBQUcsY0FBYztBQUFBO0FBQUE7QUFBQTtBQUloRCxnQ0FBd0IsT0FBTyxjQUFjLFFBQVEsWUFBWTtBQUMvRCxnQkFBTSxNQUFNLE1BQU07QUFDbEIsZ0JBQU0sV0FBVyxhQUFhO0FBQzlCLGdCQUFNLEVBQUMsZUFBTyxjQUFhO0FBQzNCLGNBQUssQ0FBQyxZQUFZLENBQUMsY0FBZSxDQUFDLFVBQVMsQ0FBQyxhQUFhLFNBQVMsR0FBRztBQUNwRTtBQUFBO0FBRUYsY0FBSTtBQUNKLGNBQUksY0FBYztBQUNsQixjQUFJLFlBQVk7QUFDaEIsY0FBSSxZQUFZLGFBQWE7QUFDN0IsY0FBSSxpQkFBaUIsYUFBYTtBQUNsQyxjQUFJO0FBQ0oseUJBQWUsT0FBTyxRQUFRLFVBQVU7QUFDeEMsY0FBSTtBQUNKLGNBQUk7QUFDSixjQUFJO0FBQUE7QUFFTix5Q0FBaUMsUUFBUSxRQUFPLE9BQU87QUFDckQsaUJBQU8sY0FBYyxRQUFRO0FBQUEsWUFDM0I7QUFBQSxZQUNBO0FBQUEsWUFDQSxNQUFNO0FBQUE7QUFBQTtBQUdWLHdDQUFnQyxnQkFBZ0I7QUFBQSxVQUM5QyxZQUFZLEtBQUs7QUFDZixrQkFBTTtBQUNOLGlCQUFLLFVBQVU7QUFDZixpQkFBSyxVQUFVO0FBQ2YsaUJBQUssY0FBYztBQUNuQixpQkFBSyxlQUFlO0FBQ3BCLGlCQUFLLG1CQUFtQjtBQUFBO0FBQUEsVUFFMUIsZ0JBQWdCO0FBQ2Qsa0JBQU0sVUFBVSxLQUFLLFdBQVcsVUFBVSxzQkFBc0IsS0FBSyxXQUFXO0FBQ2hGLGtCQUFNLElBQUksS0FBSyxRQUFRLEtBQUssV0FBVyxRQUFRO0FBQy9DLGtCQUFNLElBQUksS0FBSyxTQUFTLEtBQUssWUFBWSxRQUFRO0FBQ2pELGlCQUFLLFVBQVUsS0FBSyxNQUFNLEtBQUssT0FBTyxJQUFJLElBQUksUUFBUTtBQUN0RCxpQkFBSyxVQUFVLEtBQUssTUFBTSxLQUFLLE1BQU0sSUFBSSxJQUFJLFFBQVE7QUFDckQsaUJBQUssY0FBYyxLQUFLLE1BQU0sS0FBSyxJQUFJLEdBQUcsS0FBSztBQUFBO0FBQUEsVUFFakQsc0JBQXNCO0FBQ3BCLGtCQUFNLEVBQUMsS0FBSyxRQUFPLEtBQUssVUFBVTtBQUNsQyxpQkFBSyxNQUFNLGVBQWUsUUFBUSxDQUFDLE1BQU0sT0FBTyxNQUFNO0FBQ3RELGlCQUFLLE1BQU0sZUFBZSxRQUFRLENBQUMsTUFBTSxPQUFPLE1BQU07QUFDdEQsaUJBQUs7QUFBQTtBQUFBLFVBRVAsbUJBQW1CO0FBQ2pCLG1CQUFPLEtBQUssS0FBSyxLQUFLLGNBQWMsc0JBQXNCLEtBQUs7QUFBQTtBQUFBLFVBRWpFLG1CQUFtQixPQUFPO0FBQ3hCLDRCQUFnQixVQUFVLG1CQUFtQixLQUFLLE1BQU07QUFDeEQsaUJBQUssZUFBZSxLQUFLLFlBQ3RCLElBQUksQ0FBQyxPQUFPLFdBQVU7QUFDckIsb0JBQU0sUUFBUSxTQUFTLEtBQUssUUFBUSxZQUFZLFVBQVUsQ0FBQyxPQUFPLFNBQVE7QUFDMUUscUJBQU8sU0FBUyxVQUFVLElBQUksUUFBUTtBQUFBLGVBRXZDLE9BQU8sQ0FBQyxHQUFHLE1BQU0sS0FBSyxNQUFNLGtCQUFrQjtBQUFBO0FBQUEsVUFFbkQsTUFBTTtBQUNKLGtCQUFNLE9BQU8sS0FBSztBQUNsQixnQkFBSSxLQUFLLFdBQVcsS0FBSyxZQUFZLFNBQVM7QUFDNUMsaUNBQW1CO0FBQUEsbUJBQ2Q7QUFDTCxtQkFBSyxlQUFlLEdBQUcsR0FBRyxHQUFHO0FBQUE7QUFBQTtBQUFBLFVBR2pDLGVBQWUsY0FBYyxlQUFlLGFBQWEsZ0JBQWdCO0FBQ3ZFLGlCQUFLLFdBQVcsS0FBSyxNQUFPLGdCQUFlLGlCQUFpQjtBQUM1RCxpQkFBSyxXQUFXLEtBQUssTUFBTyxlQUFjLGtCQUFrQjtBQUM1RCxpQkFBSyxlQUFlLEtBQUssSUFBSSxLQUFLLGNBQWMsR0FBRyxLQUFLLElBQUksY0FBYyxlQUFlLGFBQWE7QUFBQTtBQUFBLFVBRXhHLGNBQWMsUUFBTztBQUNuQixrQkFBTSxrQkFBa0IsTUFBTyxNQUFLLGFBQWEsVUFBVTtBQUMzRCxrQkFBTSxhQUFhLEtBQUssUUFBUSxjQUFjO0FBQzlDLG1CQUFPLGdCQUFnQixTQUFRLGtCQUFrQixVQUFVO0FBQUE7QUFBQSxVQUU3RCw4QkFBOEIsT0FBTztBQUNuQyxnQkFBSSxjQUFjLFFBQVE7QUFDeEIscUJBQU87QUFBQTtBQUVULGtCQUFNLGdCQUFnQixLQUFLLGNBQWUsTUFBSyxNQUFNLEtBQUs7QUFDMUQsZ0JBQUksS0FBSyxRQUFRLFNBQVM7QUFDeEIscUJBQVEsTUFBSyxNQUFNLFNBQVM7QUFBQTtBQUU5QixtQkFBUSxTQUFRLEtBQUssT0FBTztBQUFBO0FBQUEsVUFFOUIsOEJBQThCLFdBQVU7QUFDdEMsZ0JBQUksY0FBYyxZQUFXO0FBQzNCLHFCQUFPO0FBQUE7QUFFVCxrQkFBTSxpQkFBaUIsWUFBWSxNQUFLLGNBQWUsTUFBSyxNQUFNLEtBQUs7QUFDdkUsbUJBQU8sS0FBSyxRQUFRLFVBQVUsS0FBSyxNQUFNLGlCQUFpQixLQUFLLE1BQU07QUFBQTtBQUFBLFVBRXZFLHFCQUFxQixRQUFPO0FBQzFCLGtCQUFNLGNBQWMsS0FBSyxnQkFBZ0I7QUFDekMsZ0JBQUksVUFBUyxLQUFLLFNBQVEsWUFBWSxRQUFRO0FBQzVDLG9CQUFNLGFBQWEsWUFBWTtBQUMvQixxQkFBTyx3QkFBd0IsS0FBSyxjQUFjLFFBQU87QUFBQTtBQUFBO0FBQUEsVUFHN0QsaUJBQWlCLFFBQU8sb0JBQW9CLGtCQUFrQixHQUFHO0FBQy9ELGtCQUFNLFFBQVEsS0FBSyxjQUFjLFVBQVMsVUFBVTtBQUNwRCxtQkFBTztBQUFBLGNBQ0wsR0FBRyxLQUFLLElBQUksU0FBUyxxQkFBcUIsS0FBSztBQUFBLGNBQy9DLEdBQUcsS0FBSyxJQUFJLFNBQVMscUJBQXFCLEtBQUs7QUFBQSxjQUMvQztBQUFBO0FBQUE7QUFBQSxVQUdKLHlCQUF5QixRQUFPLE9BQU87QUFDckMsbUJBQU8sS0FBSyxpQkFBaUIsUUFBTyxLQUFLLDhCQUE4QjtBQUFBO0FBQUEsVUFFekUsZ0JBQWdCLFFBQU87QUFDckIsbUJBQU8sS0FBSyx5QkFBeUIsVUFBUyxHQUFHLEtBQUs7QUFBQTtBQUFBLFVBRXhELHNCQUFzQixRQUFPO0FBQzNCLGtCQUFNLEVBQUMsTUFBTSxLQUFLLE9BQU8sV0FBVSxLQUFLLGlCQUFpQjtBQUN6RCxtQkFBTztBQUFBLGNBQ0w7QUFBQSxjQUNBO0FBQUEsY0FDQTtBQUFBLGNBQ0E7QUFBQTtBQUFBO0FBQUEsVUFHSixpQkFBaUI7QUFDZixrQkFBTSxFQUFDLGlCQUFpQixNQUFNLEVBQUMsZUFBYSxLQUFLO0FBQ2pELGdCQUFJLGlCQUFpQjtBQUNuQixvQkFBTSxNQUFNLEtBQUs7QUFDakIsa0JBQUk7QUFDSixrQkFBSTtBQUNKLDZCQUFlLE1BQU0sS0FBSyw4QkFBOEIsS0FBSyxZQUFZLFVBQVUsS0FBSyxhQUFhO0FBQ3JHLGtCQUFJO0FBQ0osa0JBQUksWUFBWTtBQUNoQixrQkFBSTtBQUNKLGtCQUFJO0FBQUE7QUFBQTtBQUFBLFVBR1IsV0FBVztBQUNULGtCQUFNLE1BQU0sS0FBSztBQUNqQixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sRUFBQyxZQUFZLFNBQVE7QUFDM0Isa0JBQU0sYUFBYSxLQUFLLGFBQWE7QUFDckMsZ0JBQUksR0FBRyxRQUFRO0FBQ2YsZ0JBQUksS0FBSyxZQUFZLFNBQVM7QUFDNUIsOEJBQWdCLE1BQU07QUFBQTtBQUV4QixnQkFBSSxLQUFLLFNBQVM7QUFDaEIsbUJBQUssTUFBTSxRQUFRLENBQUMsTUFBTSxXQUFVO0FBQ2xDLG9CQUFJLFdBQVUsR0FBRztBQUNmLDJCQUFTLEtBQUssOEJBQThCLEtBQUs7QUFDakQsd0JBQU0sY0FBYyxLQUFLLFdBQVcsS0FBSyxXQUFXLFNBQVE7QUFDNUQsaUNBQWUsTUFBTSxhQUFhLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFJaEQsZ0JBQUksV0FBVyxTQUFTO0FBQ3RCLGtCQUFJO0FBQ0osbUJBQUssSUFBSSxhQUFhLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDcEMsc0JBQU0sY0FBYyxXQUFXLFdBQVcsS0FBSyxxQkFBcUI7QUFDcEUsc0JBQU0sRUFBQyxlQUFPLGNBQWE7QUFDM0Isb0JBQUksQ0FBQyxhQUFhLENBQUMsUUFBTztBQUN4QjtBQUFBO0FBRUYsb0JBQUksWUFBWTtBQUNoQixvQkFBSSxjQUFjO0FBQ2xCLG9CQUFJLFlBQVksWUFBWTtBQUM1QixvQkFBSSxpQkFBaUIsWUFBWTtBQUNqQyx5QkFBUyxLQUFLLDhCQUE4QixLQUFLLE1BQU0sVUFBVSxLQUFLLE1BQU0sS0FBSztBQUNqRiwyQkFBVyxLQUFLLGlCQUFpQixHQUFHO0FBQ3BDLG9CQUFJO0FBQ0osb0JBQUksT0FBTyxLQUFLLFNBQVMsS0FBSztBQUM5QixvQkFBSSxPQUFPLFNBQVMsR0FBRyxTQUFTO0FBQ2hDLG9CQUFJO0FBQUE7QUFFTixrQkFBSTtBQUFBO0FBQUE7QUFBQSxVQUdSLGFBQWE7QUFBQTtBQUFBLFVBQ2IsYUFBYTtBQUNYLGtCQUFNLE1BQU0sS0FBSztBQUNqQixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sV0FBVyxLQUFLO0FBQ3RCLGdCQUFJLENBQUMsU0FBUyxTQUFTO0FBQ3JCO0FBQUE7QUFFRixrQkFBTSxhQUFhLEtBQUssY0FBYztBQUN0QyxnQkFBSSxRQUFRO0FBQ1osZ0JBQUk7QUFDSixnQkFBSSxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQ2pDLGdCQUFJLE9BQU87QUFDWCxnQkFBSSxZQUFZO0FBQ2hCLGdCQUFJLGVBQWU7QUFDbkIsaUJBQUssTUFBTSxRQUFRLENBQUMsTUFBTSxXQUFVO0FBQ2xDLGtCQUFJLFdBQVUsS0FBSyxDQUFDLEtBQUssU0FBUztBQUNoQztBQUFBO0FBRUYsb0JBQU0sY0FBYyxTQUFTLFdBQVcsS0FBSyxXQUFXO0FBQ3hELG9CQUFNLFdBQVcsT0FBTyxZQUFZO0FBQ3BDLHVCQUFTLEtBQUssOEJBQThCLEtBQUssTUFBTSxRQUFPO0FBQzlELGtCQUFJLFlBQVksbUJBQW1CO0FBQ2pDLG9CQUFJLE9BQU8sU0FBUztBQUNwQix3QkFBUSxJQUFJLFlBQVksS0FBSyxPQUFPO0FBQ3BDLG9CQUFJLFlBQVksWUFBWTtBQUM1QixzQkFBTSxVQUFVLFVBQVUsWUFBWTtBQUN0QyxvQkFBSSxTQUNGLENBQUMsUUFBUSxJQUFJLFFBQVEsTUFDckIsQ0FBQyxTQUFTLFNBQVMsT0FBTyxJQUFJLFFBQVEsS0FDdEMsUUFBUSxRQUFRLE9BQ2hCLFNBQVMsT0FBTyxRQUFRO0FBQUE7QUFHNUIseUJBQVcsS0FBSyxLQUFLLE9BQU8sR0FBRyxDQUFDLFFBQVEsVUFBVTtBQUFBLGdCQUNoRCxPQUFPLFlBQVk7QUFBQTtBQUFBO0FBR3ZCLGdCQUFJO0FBQUE7QUFBQSxVQUVOLFlBQVk7QUFBQTtBQUFBO0FBRWQsMEJBQWtCLEtBQUs7QUFDdkIsMEJBQWtCLFdBQVc7QUFBQSxVQUMzQixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxVQUFVO0FBQUEsVUFDVixZQUFZO0FBQUEsWUFDVixTQUFTO0FBQUEsWUFDVCxXQUFXO0FBQUEsWUFDWCxZQUFZO0FBQUEsWUFDWixrQkFBa0I7QUFBQTtBQUFBLFVBRXBCLE1BQU07QUFBQSxZQUNKLFVBQVU7QUFBQTtBQUFBLFVBRVosWUFBWTtBQUFBLFVBQ1osT0FBTztBQUFBLFlBQ0wsbUJBQW1CO0FBQUEsWUFDbkIsVUFBVSxNQUFNLFdBQVc7QUFBQTtBQUFBLFVBRTdCLGFBQWE7QUFBQSxZQUNYLGVBQWU7QUFBQSxZQUNmLGlCQUFpQjtBQUFBLFlBQ2pCLFNBQVM7QUFBQSxZQUNULE1BQU07QUFBQSxjQUNKLE1BQU07QUFBQTtBQUFBLFlBRVIsU0FBUyxPQUFPO0FBQ2QscUJBQU87QUFBQTtBQUFBLFlBRVQsU0FBUztBQUFBLFlBQ1QsbUJBQW1CO0FBQUE7QUFBQTtBQUd2QiwwQkFBa0IsZ0JBQWdCO0FBQUEsVUFDaEMsb0JBQW9CO0FBQUEsVUFDcEIscUJBQXFCO0FBQUEsVUFDckIsZUFBZTtBQUFBO0FBRWpCLDBCQUFrQixjQUFjO0FBQUEsVUFDOUIsWUFBWTtBQUFBLFlBQ1YsV0FBVztBQUFBO0FBQUE7QUFJZixjQUFNLFlBQVk7QUFBQSxVQUNoQixhQUFhLEVBQUMsUUFBUSxNQUFNLE1BQU0sR0FBRyxPQUFPO0FBQUEsVUFDNUMsUUFBUSxFQUFDLFFBQVEsTUFBTSxNQUFNLEtBQU0sT0FBTztBQUFBLFVBQzFDLFFBQVEsRUFBQyxRQUFRLE1BQU0sTUFBTSxLQUFPLE9BQU87QUFBQSxVQUMzQyxNQUFNLEVBQUMsUUFBUSxNQUFNLE1BQU0sTUFBUyxPQUFPO0FBQUEsVUFDM0MsS0FBSyxFQUFDLFFBQVEsTUFBTSxNQUFNLE9BQVUsT0FBTztBQUFBLFVBQzNDLE1BQU0sRUFBQyxRQUFRLE9BQU8sTUFBTSxRQUFXLE9BQU87QUFBQSxVQUM5QyxPQUFPLEVBQUMsUUFBUSxNQUFNLE1BQU0sUUFBUyxPQUFPO0FBQUEsVUFDNUMsU0FBUyxFQUFDLFFBQVEsT0FBTyxNQUFNLFFBQVMsT0FBTztBQUFBLFVBQy9DLE1BQU0sRUFBQyxRQUFRLE1BQU0sTUFBTTtBQUFBO0FBRTdCLGNBQU0sUUFBUyxPQUFPLEtBQUs7QUFDM0Isd0JBQWdCLEdBQUcsR0FBRztBQUNwQixpQkFBTyxJQUFJO0FBQUE7QUFFYix1QkFBZSxPQUFPLE9BQU87QUFDM0IsY0FBSSxjQUFjLFFBQVE7QUFDeEIsbUJBQU87QUFBQTtBQUVULGdCQUFNLFVBQVUsTUFBTTtBQUN0QixnQkFBTSxFQUFDLFFBQVEsZUFBTyxlQUFjLE1BQU07QUFDMUMsY0FBSSxRQUFRO0FBQ1osY0FBSSxPQUFPLFdBQVcsWUFBWTtBQUNoQyxvQkFBUSxPQUFPO0FBQUE7QUFFakIsY0FBSSxDQUFDLGVBQWUsUUFBUTtBQUMxQixvQkFBUSxPQUFPLFdBQVcsV0FDdEIsUUFBUSxNQUFNLE9BQU8sVUFDckIsUUFBUSxNQUFNO0FBQUE7QUFFcEIsY0FBSSxVQUFVLE1BQU07QUFDbEIsbUJBQU87QUFBQTtBQUVULGNBQUksUUFBTztBQUNULG9CQUFRLFdBQVUsVUFBVyxVQUFTLGVBQWUsZUFBZSxRQUNoRSxRQUFRLFFBQVEsT0FBTyxXQUFXLGNBQ2xDLFFBQVEsUUFBUSxPQUFPO0FBQUE7QUFFN0IsaUJBQU8sQ0FBQztBQUFBO0FBRVYsMkNBQW1DLFNBQVMsS0FBSyxLQUFLLFVBQVU7QUFDOUQsZ0JBQU0sT0FBTyxNQUFNO0FBQ25CLG1CQUFTLElBQUksTUFBTSxRQUFRLFVBQVUsSUFBSSxPQUFPLEdBQUcsRUFBRSxHQUFHO0FBQ3RELGtCQUFNLFdBQVcsVUFBVSxNQUFNO0FBQ2pDLGtCQUFNLFNBQVMsU0FBUyxRQUFRLFNBQVMsUUFBUSxPQUFPO0FBQ3hELGdCQUFJLFNBQVMsVUFBVSxLQUFLLEtBQU0sT0FBTSxPQUFRLFVBQVMsU0FBUyxVQUFVLFVBQVU7QUFDcEYscUJBQU8sTUFBTTtBQUFBO0FBQUE7QUFHakIsaUJBQU8sTUFBTSxPQUFPO0FBQUE7QUFFdEIsNENBQW9DLE9BQU8sVUFBVSxTQUFTLEtBQUssS0FBSztBQUN0RSxtQkFBUyxJQUFJLE1BQU0sU0FBUyxHQUFHLEtBQUssTUFBTSxRQUFRLFVBQVUsS0FBSztBQUMvRCxrQkFBTSxPQUFPLE1BQU07QUFDbkIsZ0JBQUksVUFBVSxNQUFNLFVBQVUsTUFBTSxTQUFTLEtBQUssS0FBSyxLQUFLLFNBQVMsV0FBVyxHQUFHO0FBQ2pGLHFCQUFPO0FBQUE7QUFBQTtBQUdYLGlCQUFPLE1BQU0sVUFBVSxNQUFNLFFBQVEsV0FBVztBQUFBO0FBRWxELG9DQUE0QixNQUFNO0FBQ2hDLG1CQUFTLElBQUksTUFBTSxRQUFRLFFBQVEsR0FBRyxPQUFPLE1BQU0sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ3hFLGdCQUFJLFVBQVUsTUFBTSxJQUFJLFFBQVE7QUFDOUIscUJBQU8sTUFBTTtBQUFBO0FBQUE7QUFBQTtBQUluQix5QkFBaUIsT0FBTyxNQUFNLFlBQVk7QUFDeEMsY0FBSSxDQUFDLFlBQVk7QUFDZixrQkFBTSxRQUFRO0FBQUEscUJBQ0wsV0FBVyxRQUFRO0FBQzVCLGtCQUFNLEVBQUMsSUFBSSxPQUFNLFFBQVEsWUFBWTtBQUNyQyxrQkFBTSxZQUFZLFdBQVcsT0FBTyxPQUFPLFdBQVcsTUFBTSxXQUFXO0FBQ3ZFLGtCQUFNLGFBQWE7QUFBQTtBQUFBO0FBR3ZCLCtCQUF1QixPQUFPLE9BQU8sTUFBSyxXQUFXO0FBQ25ELGdCQUFNLFVBQVUsTUFBTTtBQUN0QixnQkFBTSxRQUFRLENBQUMsUUFBUSxRQUFRLE1BQU0sR0FBRyxPQUFPO0FBQy9DLGdCQUFNLE9BQU8sTUFBTSxNQUFNLFNBQVMsR0FBRztBQUNyQyxjQUFJLE9BQU87QUFDWCxlQUFLLFFBQVEsT0FBTyxTQUFTLE1BQU0sUUFBUSxDQUFDLFFBQVEsSUFBSSxPQUFPLEdBQUcsWUFBWTtBQUM1RSxxQkFBUSxLQUFJO0FBQ1osZ0JBQUksVUFBUyxHQUFHO0FBQ2Qsb0JBQU0sUUFBTyxRQUFRO0FBQUE7QUFBQTtBQUd6QixpQkFBTztBQUFBO0FBRVQscUNBQTZCLE9BQU8sUUFBUSxXQUFXO0FBQ3JELGdCQUFNLFFBQVE7QUFDZCxnQkFBTSxPQUFNO0FBQ1osZ0JBQU0sT0FBTyxPQUFPO0FBQ3BCLGNBQUksR0FBRztBQUNQLGVBQUssSUFBSSxHQUFHLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDekIsb0JBQVEsT0FBTztBQUNmLGlCQUFJLFNBQVM7QUFDYixrQkFBTSxLQUFLO0FBQUEsY0FDVDtBQUFBLGNBQ0EsT0FBTztBQUFBO0FBQUE7QUFHWCxpQkFBUSxTQUFTLEtBQUssQ0FBQyxZQUFhLFFBQVEsY0FBYyxPQUFPLE9BQU8sTUFBSztBQUFBO0FBRS9FLGdDQUF3QixNQUFNO0FBQUEsVUFDNUIsWUFBWSxPQUFPO0FBQ2pCLGtCQUFNO0FBQ04saUJBQUssU0FBUztBQUFBLGNBQ1osTUFBTTtBQUFBLGNBQ04sUUFBUTtBQUFBLGNBQ1IsS0FBSztBQUFBO0FBRVAsaUJBQUssUUFBUTtBQUNiLGlCQUFLLGFBQWE7QUFDbEIsaUJBQUssV0FBVztBQUNoQixpQkFBSyxjQUFjO0FBQ25CLGlCQUFLLGFBQWE7QUFBQTtBQUFBLFVBRXBCLEtBQUssV0FBVyxNQUFNO0FBQ3BCLGtCQUFNLE9BQU8sVUFBVSxRQUFTLFdBQVUsT0FBTztBQUNqRCxrQkFBTSxVQUFVLEtBQUssV0FBVyxJQUFJLFVBQVUsTUFBTSxVQUFVLFNBQVM7QUFDdkUsb0JBQVEsS0FBSztBQUNiLG9CQUFRLEtBQUssZ0JBQWdCLFFBQVE7QUFDckMsaUJBQUssYUFBYTtBQUFBLGNBQ2hCLFFBQVEsS0FBSztBQUFBLGNBQ2IsT0FBTyxLQUFLO0FBQUEsY0FDWixZQUFZLEtBQUs7QUFBQTtBQUVuQixrQkFBTSxLQUFLO0FBQ1gsaUJBQUssY0FBYyxLQUFLO0FBQUE7QUFBQSxVQUUxQixNQUFNLEtBQUssUUFBTztBQUNoQixnQkFBSSxRQUFRLFFBQVc7QUFDckIscUJBQU87QUFBQTtBQUVULG1CQUFPLE1BQU0sTUFBTTtBQUFBO0FBQUEsVUFFckIsZUFBZTtBQUNiLGtCQUFNO0FBQ04saUJBQUssU0FBUztBQUFBLGNBQ1osTUFBTTtBQUFBLGNBQ04sUUFBUTtBQUFBLGNBQ1IsS0FBSztBQUFBO0FBQUE7QUFBQSxVQUdULHNCQUFzQjtBQUNwQixrQkFBTSxVQUFVLEtBQUs7QUFDckIsa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGtCQUFNLE9BQU8sUUFBUSxLQUFLLFFBQVE7QUFDbEMsZ0JBQUksRUFBQyxLQUFLLEtBQUssWUFBWSxlQUFjLEtBQUs7QUFDOUMsa0NBQXNCLFFBQVE7QUFDNUIsa0JBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxPQUFPLE1BQU07QUFDckMsc0JBQU0sS0FBSyxJQUFJLEtBQUssT0FBTztBQUFBO0FBRTdCLGtCQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sT0FBTyxNQUFNO0FBQ3JDLHNCQUFNLEtBQUssSUFBSSxLQUFLLE9BQU87QUFBQTtBQUFBO0FBRy9CLGdCQUFJLENBQUMsY0FBYyxDQUFDLFlBQVk7QUFDOUIsMkJBQWEsS0FBSztBQUNsQixrQkFBSSxRQUFRLFdBQVcsV0FBVyxRQUFRLE1BQU0sV0FBVyxVQUFVO0FBQ25FLDZCQUFhLEtBQUssVUFBVTtBQUFBO0FBQUE7QUFHaEMsa0JBQU0sZUFBZSxRQUFRLENBQUMsTUFBTSxPQUFPLE1BQU0sQ0FBQyxRQUFRLFFBQVEsS0FBSyxPQUFPO0FBQzlFLGtCQUFNLGVBQWUsUUFBUSxDQUFDLE1BQU0sT0FBTyxNQUFNLENBQUMsUUFBUSxNQUFNLEtBQUssT0FBTyxRQUFRO0FBQ3BGLGlCQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUssTUFBTTtBQUMvQixpQkFBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEdBQUc7QUFBQTtBQUFBLFVBRS9CLGtCQUFrQjtBQUNoQixrQkFBTSxNQUFNLEtBQUs7QUFDakIsZ0JBQUksTUFBTSxPQUFPO0FBQ2pCLGdCQUFJLE1BQU0sT0FBTztBQUNqQixnQkFBSSxJQUFJLFFBQVE7QUFDZCxvQkFBTSxJQUFJO0FBQ1Ysb0JBQU0sSUFBSSxJQUFJLFNBQVM7QUFBQTtBQUV6QixtQkFBTyxFQUFDLEtBQUs7QUFBQTtBQUFBLFVBRWYsYUFBYTtBQUNYLGtCQUFNLFVBQVUsS0FBSztBQUNyQixrQkFBTSxXQUFXLFFBQVE7QUFDekIsa0JBQU0sV0FBVyxRQUFRO0FBQ3pCLGtCQUFNLGFBQWEsU0FBUyxXQUFXLFdBQVcsS0FBSyx1QkFBdUIsS0FBSztBQUNuRixnQkFBSSxRQUFRLFdBQVcsV0FBVyxXQUFXLFFBQVE7QUFDbkQsbUJBQUssTUFBTSxLQUFLLFlBQVksV0FBVztBQUN2QyxtQkFBSyxNQUFNLEtBQUssWUFBWSxXQUFXLFdBQVcsU0FBUztBQUFBO0FBRTdELGtCQUFNLE1BQU0sS0FBSztBQUNqQixrQkFBTSxNQUFNLEtBQUs7QUFDakIsa0JBQU0sUUFBUSxlQUFlLFlBQVksS0FBSztBQUM5QyxpQkFBSyxRQUFRLFNBQVMsUUFBUyxVQUFTLFdBQ3BDLDBCQUEwQixTQUFTLFNBQVMsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLGtCQUFrQixRQUN2RiwyQkFBMkIsTUFBTSxNQUFNLFFBQVEsU0FBUyxTQUFTLEtBQUssS0FBSyxLQUFLO0FBQ3BGLGlCQUFLLGFBQWEsQ0FBQyxTQUFTLE1BQU0sV0FBVyxLQUFLLFVBQVUsU0FBUyxTQUNqRSxtQkFBbUIsS0FBSztBQUM1QixpQkFBSyxZQUFZO0FBQ2pCLGdCQUFJLFFBQVEsU0FBUztBQUNuQixvQkFBTTtBQUFBO0FBRVIsbUJBQU8sb0JBQW9CLE1BQU0sT0FBTyxLQUFLO0FBQUE7QUFBQSxVQUUvQyxnQkFBZ0I7QUFDZCxnQkFBSSxLQUFLLFFBQVEscUJBQXFCO0FBQ3BDLG1CQUFLLFlBQVksS0FBSyxNQUFNLElBQUksVUFBUSxDQUFDLEtBQUs7QUFBQTtBQUFBO0FBQUEsVUFHbEQsWUFBWSxZQUFZO0FBQ3RCLGdCQUFJLFFBQVE7QUFDWixnQkFBSSxNQUFNO0FBQ1YsZ0JBQUksT0FBTztBQUNYLGdCQUFJLEtBQUssUUFBUSxVQUFVLFdBQVcsUUFBUTtBQUM1QyxzQkFBUSxLQUFLLG1CQUFtQixXQUFXO0FBQzNDLGtCQUFJLFdBQVcsV0FBVyxHQUFHO0FBQzNCLHdCQUFRLElBQUk7QUFBQSxxQkFDUDtBQUNMLHdCQUFTLE1BQUssbUJBQW1CLFdBQVcsTUFBTSxTQUFTO0FBQUE7QUFFN0QscUJBQU8sS0FBSyxtQkFBbUIsV0FBVyxXQUFXLFNBQVM7QUFDOUQsa0JBQUksV0FBVyxXQUFXLEdBQUc7QUFDM0Isc0JBQU07QUFBQSxxQkFDRDtBQUNMLHNCQUFPLFFBQU8sS0FBSyxtQkFBbUIsV0FBVyxXQUFXLFNBQVMsT0FBTztBQUFBO0FBQUE7QUFHaEYsa0JBQU0sUUFBUSxXQUFXLFNBQVMsSUFBSSxNQUFNO0FBQzVDLG9CQUFRLFlBQVksT0FBTyxHQUFHO0FBQzlCLGtCQUFNLFlBQVksS0FBSyxHQUFHO0FBQzFCLGlCQUFLLFdBQVcsRUFBQyxPQUFPLEtBQUssUUFBUSxJQUFLLFNBQVEsSUFBSTtBQUFBO0FBQUEsVUFFeEQsWUFBWTtBQUNWLGtCQUFNLFVBQVUsS0FBSztBQUNyQixrQkFBTSxNQUFNLEtBQUs7QUFDakIsa0JBQU0sTUFBTSxLQUFLO0FBQ2pCLGtCQUFNLFVBQVUsS0FBSztBQUNyQixrQkFBTSxXQUFXLFFBQVE7QUFDekIsa0JBQU0sUUFBUSxTQUFTLFFBQVEsMEJBQTBCLFNBQVMsU0FBUyxLQUFLLEtBQUssS0FBSyxrQkFBa0I7QUFDNUcsa0JBQU0sV0FBVyxlQUFlLFNBQVMsVUFBVTtBQUNuRCxrQkFBTSxVQUFVLFVBQVUsU0FBUyxTQUFTLGFBQWE7QUFDekQsa0JBQU0sYUFBYSxTQUFTLFlBQVksWUFBWTtBQUNwRCxrQkFBTSxRQUFRO0FBQ2QsZ0JBQUksUUFBUTtBQUNaLGdCQUFJLE1BQU07QUFDVixnQkFBSSxZQUFZO0FBQ2Qsc0JBQVEsQ0FBQyxRQUFRLFFBQVEsT0FBTyxXQUFXO0FBQUE7QUFFN0Msb0JBQVEsQ0FBQyxRQUFRLFFBQVEsT0FBTyxhQUFhLFFBQVE7QUFDckQsZ0JBQUksUUFBUSxLQUFLLEtBQUssS0FBSyxTQUFTLE1BQVMsVUFBVTtBQUNyRCxvQkFBTSxJQUFJLE1BQU0sTUFBTSxVQUFVLE1BQU0seUNBQXlDLFdBQVcsTUFBTTtBQUFBO0FBRWxHLGtCQUFNLGFBQWEsUUFBUSxNQUFNLFdBQVcsVUFBVSxLQUFLO0FBQzNELGlCQUFLLE9BQU8sT0FBTyxRQUFRLEdBQUcsT0FBTyxLQUFLLE9BQU8sQ0FBQyxRQUFRLElBQUksTUFBTSxVQUFVLFFBQVEsU0FBUztBQUM3RixzQkFBUSxPQUFPLE1BQU07QUFBQTtBQUV2QixnQkFBSSxTQUFTLE9BQU8sUUFBUSxXQUFXLFdBQVcsVUFBVSxHQUFHO0FBQzdELHNCQUFRLE9BQU8sTUFBTTtBQUFBO0FBRXZCLG1CQUFPLE9BQU8sS0FBSyxPQUFPLEtBQUssQ0FBQyxHQUFHLE1BQU0sSUFBSSxHQUFHLElBQUksT0FBSyxDQUFDO0FBQUE7QUFBQSxVQUU1RCxpQkFBaUIsT0FBTztBQUN0QixrQkFBTSxVQUFVLEtBQUs7QUFDckIsa0JBQU0sV0FBVyxLQUFLLFFBQVE7QUFDOUIsZ0JBQUksU0FBUyxlQUFlO0FBQzFCLHFCQUFPLFFBQVEsT0FBTyxPQUFPLFNBQVM7QUFBQTtBQUV4QyxtQkFBTyxRQUFRLE9BQU8sT0FBTyxTQUFTLGVBQWU7QUFBQTtBQUFBLFVBRXZELG9CQUFvQixNQUFNLFFBQU8sT0FBTyxRQUFRO0FBQzlDLGtCQUFNLFVBQVUsS0FBSztBQUNyQixrQkFBTSxVQUFVLFFBQVEsS0FBSztBQUM3QixrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sWUFBWSxLQUFLO0FBQ3ZCLGtCQUFNLGNBQWMsUUFBUSxRQUFRO0FBQ3BDLGtCQUFNLGNBQWMsYUFBYSxRQUFRO0FBQ3pDLGtCQUFNLE9BQU8sTUFBTTtBQUNuQixrQkFBTSxRQUFRLGFBQWEsZUFBZSxRQUFRLEtBQUs7QUFDdkQsa0JBQU0sUUFBUSxLQUFLLFNBQVMsT0FBTyxNQUFNLFVBQVcsU0FBUSxjQUFjO0FBQzFFLGtCQUFNLFlBQVksUUFBUSxNQUFNO0FBQ2hDLG1CQUFPLFlBQVksU0FBUyxXQUFXLENBQUMsT0FBTyxRQUFPLFFBQVEsUUFBUTtBQUFBO0FBQUEsVUFFeEUsbUJBQW1CLE9BQU87QUFDeEIsZ0JBQUksR0FBRyxNQUFNO0FBQ2IsaUJBQUssSUFBSSxHQUFHLE9BQU8sTUFBTSxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDOUMscUJBQU8sTUFBTTtBQUNiLG1CQUFLLFFBQVEsS0FBSyxvQkFBb0IsS0FBSyxPQUFPLEdBQUc7QUFBQTtBQUFBO0FBQUEsVUFHekQsbUJBQW1CLE9BQU87QUFDeEIsbUJBQU8sVUFBVSxPQUFPLE1BQU8sU0FBUSxLQUFLLE9BQVEsTUFBSyxNQUFNLEtBQUs7QUFBQTtBQUFBLFVBRXRFLGlCQUFpQixPQUFPO0FBQ3RCLGtCQUFNLFVBQVUsS0FBSztBQUNyQixrQkFBTSxNQUFNLEtBQUssbUJBQW1CO0FBQ3BDLG1CQUFPLEtBQUssbUJBQW9CLFNBQVEsUUFBUSxPQUFPLFFBQVE7QUFBQTtBQUFBLFVBRWpFLGlCQUFpQixPQUFPO0FBQ3RCLGtCQUFNLFVBQVUsS0FBSztBQUNyQixrQkFBTSxNQUFNLEtBQUssbUJBQW1CLFNBQVMsUUFBUSxTQUFTLFFBQVE7QUFDdEUsbUJBQU8sS0FBSyxNQUFNLE1BQU8sTUFBSyxNQUFNLEtBQUs7QUFBQTtBQUFBLFVBRTNDLGNBQWMsT0FBTztBQUNuQixrQkFBTSxZQUFZLEtBQUssUUFBUTtBQUMvQixrQkFBTSxpQkFBaUIsS0FBSyxJQUFJLFlBQVksT0FBTztBQUNuRCxrQkFBTSxRQUFRLFVBQVUsS0FBSyxpQkFBaUIsVUFBVSxjQUFjLFVBQVU7QUFDaEYsa0JBQU0sY0FBYyxLQUFLLElBQUk7QUFDN0Isa0JBQU0sY0FBYyxLQUFLLElBQUk7QUFDN0Isa0JBQU0sZUFBZSxLQUFLLHdCQUF3QixHQUFHO0FBQ3JELG1CQUFPO0FBQUEsY0FDTCxHQUFJLGlCQUFpQixjQUFnQixlQUFlO0FBQUEsY0FDcEQsR0FBSSxpQkFBaUIsY0FBZ0IsZUFBZTtBQUFBO0FBQUE7QUFBQSxVQUd4RCxrQkFBa0IsYUFBYTtBQUM3QixrQkFBTSxXQUFXLEtBQUssUUFBUTtBQUM5QixrQkFBTSxpQkFBaUIsU0FBUztBQUNoQyxrQkFBTSxTQUFTLGVBQWUsU0FBUyxTQUFTLGVBQWU7QUFDL0Qsa0JBQU0sZUFBZSxLQUFLLG9CQUFvQixhQUFhLEdBQUcsb0JBQW9CLE1BQU0sQ0FBQyxjQUFjLEtBQUssYUFBYTtBQUN6SCxrQkFBTSxPQUFPLEtBQUssY0FBYztBQUNoQyxrQkFBTSxXQUFXLEtBQUssTUFBTSxLQUFLLGlCQUFpQixLQUFLLFFBQVEsS0FBSyxJQUFJLEtBQUssU0FBUyxLQUFLLEtBQUs7QUFDaEcsbUJBQU8sV0FBVyxJQUFJLFdBQVc7QUFBQTtBQUFBLFVBRW5DLG9CQUFvQjtBQUNsQixnQkFBSSxhQUFhLEtBQUssT0FBTyxRQUFRO0FBQ3JDLGdCQUFJLEdBQUc7QUFDUCxnQkFBSSxXQUFXLFFBQVE7QUFDckIscUJBQU87QUFBQTtBQUVULGtCQUFNLFFBQVEsS0FBSztBQUNuQixnQkFBSSxLQUFLLGVBQWUsTUFBTSxRQUFRO0FBQ3BDLHFCQUFRLEtBQUssT0FBTyxPQUFPLE1BQU0sR0FBRyxXQUFXLG1CQUFtQjtBQUFBO0FBRXBFLGlCQUFLLElBQUksR0FBRyxPQUFPLE1BQU0sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQzlDLDJCQUFhLFdBQVcsT0FBTyxNQUFNLEdBQUcsV0FBVyxtQkFBbUI7QUFBQTtBQUV4RSxtQkFBUSxLQUFLLE9BQU8sT0FBTyxLQUFLLFVBQVU7QUFBQTtBQUFBLFVBRTVDLHFCQUFxQjtBQUNuQixrQkFBTSxhQUFhLEtBQUssT0FBTyxVQUFVO0FBQ3pDLGdCQUFJLEdBQUc7QUFDUCxnQkFBSSxXQUFXLFFBQVE7QUFDckIscUJBQU87QUFBQTtBQUVULGtCQUFNLFNBQVMsS0FBSztBQUNwQixpQkFBSyxJQUFJLEdBQUcsT0FBTyxPQUFPLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUMvQyx5QkFBVyxLQUFLLE1BQU0sTUFBTSxPQUFPO0FBQUE7QUFFckMsbUJBQVEsS0FBSyxPQUFPLFNBQVMsS0FBSyxjQUFjLGFBQWEsS0FBSyxVQUFVO0FBQUE7QUFBQSxVQUU5RSxVQUFVLFFBQVE7QUFDaEIsbUJBQU8sYUFBYSxPQUFPLEtBQUs7QUFBQTtBQUFBO0FBR3BDLGtCQUFVLEtBQUs7QUFDZixrQkFBVSxXQUFXO0FBQUEsVUFDbkIsUUFBUTtBQUFBLFVBQ1IsVUFBVTtBQUFBLFVBQ1YsTUFBTTtBQUFBLFlBQ0osUUFBUTtBQUFBLFlBQ1IsTUFBTTtBQUFBLFlBQ04sT0FBTztBQUFBLFlBQ1AsWUFBWTtBQUFBLFlBQ1osU0FBUztBQUFBLFlBQ1QsZ0JBQWdCO0FBQUE7QUFBQSxVQUVsQixPQUFPO0FBQUEsWUFDTCxRQUFRO0FBQUEsWUFDUixPQUFPO0FBQUEsY0FDTCxTQUFTO0FBQUE7QUFBQTtBQUFBO0FBS2YsNkJBQXFCLE9BQU8sS0FBSyxTQUFTO0FBQ3hDLGNBQUksS0FBSztBQUNULGNBQUksS0FBSyxNQUFNLFNBQVM7QUFDeEIsY0FBSSxZQUFZLFlBQVksWUFBWTtBQUN4QyxjQUFJLFNBQVM7QUFDWCxnQkFBSSxPQUFPLE1BQU0sSUFBSSxPQUFPLE9BQU8sTUFBTSxJQUFJLEtBQUs7QUFDaEQsY0FBQyxHQUFDLElBQUksT0FBTSxhQUFhLE9BQU8sT0FBTztBQUFBO0FBRXpDLFlBQUMsR0FBQyxLQUFLLFlBQVksTUFBTSxlQUFjLE1BQU07QUFDN0MsWUFBQyxHQUFDLEtBQUssWUFBWSxNQUFNLGVBQWMsTUFBTTtBQUFBLGlCQUN4QztBQUNMLGdCQUFJLE9BQU8sTUFBTSxJQUFJLFFBQVEsT0FBTyxNQUFNLElBQUksTUFBTTtBQUNsRCxjQUFDLEdBQUMsSUFBSSxPQUFNLGFBQWEsT0FBTyxRQUFRO0FBQUE7QUFFMUMsWUFBQyxHQUFDLE1BQU0sWUFBWSxLQUFLLGVBQWMsTUFBTTtBQUM3QyxZQUFDLEdBQUMsTUFBTSxZQUFZLEtBQUssZUFBYyxNQUFNO0FBQUE7QUFFL0MsZ0JBQU0sT0FBTyxhQUFhO0FBQzFCLGlCQUFPLE9BQU8sYUFBYyxjQUFhLGNBQWUsT0FBTSxjQUFjLE9BQU87QUFBQTtBQUVyRixzQ0FBOEIsVUFBVTtBQUFBLFVBQ3RDLFlBQVksT0FBTztBQUNqQixrQkFBTTtBQUNOLGlCQUFLLFNBQVM7QUFDZCxpQkFBSyxVQUFVO0FBQ2YsaUJBQUssY0FBYztBQUFBO0FBQUEsVUFFckIsY0FBYztBQUNaLGtCQUFNLGFBQWEsS0FBSztBQUN4QixrQkFBTSxRQUFRLEtBQUssU0FBUyxLQUFLLGlCQUFpQjtBQUNsRCxpQkFBSyxVQUFVLFlBQVksT0FBTyxLQUFLO0FBQ3ZDLGlCQUFLLGNBQWMsWUFBWSxPQUFPLEtBQUssT0FBTyxLQUFLO0FBQ3ZELGtCQUFNLFlBQVk7QUFBQTtBQUFBLFVBRXBCLGlCQUFpQixZQUFZO0FBQzNCLGtCQUFNLEVBQUMsS0FBSyxRQUFPO0FBQ25CLGtCQUFNLFFBQVE7QUFDZCxrQkFBTSxRQUFRO0FBQ2QsZ0JBQUksR0FBRyxNQUFNLE1BQU0sTUFBTTtBQUN6QixpQkFBSyxJQUFJLEdBQUcsT0FBTyxXQUFXLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUNuRCxxQkFBTyxXQUFXO0FBQ2xCLGtCQUFJLFFBQVEsT0FBTyxRQUFRLEtBQUs7QUFDOUIsc0JBQU0sS0FBSztBQUFBO0FBQUE7QUFHZixnQkFBSSxNQUFNLFNBQVMsR0FBRztBQUNwQixxQkFBTztBQUFBLGdCQUNMLEVBQUMsTUFBTSxLQUFLLEtBQUs7QUFBQSxnQkFDakIsRUFBQyxNQUFNLEtBQUssS0FBSztBQUFBO0FBQUE7QUFHckIsaUJBQUssSUFBSSxHQUFHLE9BQU8sTUFBTSxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDOUMscUJBQU8sTUFBTSxJQUFJO0FBQ2pCLHFCQUFPLE1BQU0sSUFBSTtBQUNqQixxQkFBTyxNQUFNO0FBQ2Isa0JBQUksS0FBSyxNQUFPLFFBQU8sUUFBUSxPQUFPLE1BQU07QUFDMUMsc0JBQU0sS0FBSyxFQUFDLE1BQU0sTUFBTSxLQUFLLElBQUssUUFBTztBQUFBO0FBQUE7QUFHN0MsbUJBQU87QUFBQTtBQUFBLFVBRVQseUJBQXlCO0FBQ3ZCLGdCQUFJLGFBQWEsS0FBSyxPQUFPLE9BQU87QUFDcEMsZ0JBQUksV0FBVyxRQUFRO0FBQ3JCLHFCQUFPO0FBQUE7QUFFVCxrQkFBTSxPQUFPLEtBQUs7QUFDbEIsa0JBQU0sUUFBUSxLQUFLO0FBQ25CLGdCQUFJLEtBQUssVUFBVSxNQUFNLFFBQVE7QUFDL0IsMkJBQWEsS0FBSyxVQUFVLEtBQUssT0FBTztBQUFBLG1CQUNuQztBQUNMLDJCQUFhLEtBQUssU0FBUyxPQUFPO0FBQUE7QUFFcEMseUJBQWEsS0FBSyxPQUFPLE1BQU07QUFDL0IsbUJBQU87QUFBQTtBQUFBLFVBRVQsbUJBQW1CLE9BQU87QUFDeEIsbUJBQVEsYUFBWSxLQUFLLFFBQVEsU0FBUyxLQUFLLFdBQVcsS0FBSztBQUFBO0FBQUEsVUFFakUsaUJBQWlCLE9BQU87QUFDdEIsa0JBQU0sVUFBVSxLQUFLO0FBQ3JCLGtCQUFNLFVBQVUsS0FBSyxtQkFBbUIsU0FBUyxRQUFRLFNBQVMsUUFBUTtBQUMxRSxtQkFBTyxZQUFZLEtBQUssUUFBUSxVQUFVLEtBQUssY0FBYyxLQUFLLFNBQVM7QUFBQTtBQUFBO0FBRy9FLHdCQUFnQixLQUFLO0FBQ3JCLHdCQUFnQixXQUFXLFVBQVU7QUFFckMsWUFBSSxTQUFzQix1QkFBTyxPQUFPO0FBQUEsVUFDeEMsV0FBVztBQUFBLFVBQ1g7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBO0FBR0EsZUFBTSxTQUFTLGFBQWEsUUFBUSxVQUFVO0FBQzlDLGVBQU0sVUFBVSxtQkFBSTtBQUNwQixlQUFNLFlBQVk7QUFDbEIsZUFBTSxZQUFZO0FBQ2xCLGVBQU0sYUFBYTtBQUNuQixlQUFNLFdBQVc7QUFDakIsZUFBTSxjQUFjLFNBQVMsWUFBWTtBQUN6QyxlQUFNLG9CQUFvQjtBQUMxQixlQUFNLFVBQVU7QUFDaEIsZUFBTSxXQUFXO0FBQ2pCLGVBQU0sY0FBYztBQUNwQixlQUFNLFVBQVU7QUFDaEIsZUFBTSxZQUFZO0FBQ2xCLGVBQU0sUUFBUTtBQUNkLGVBQU0sUUFBUTtBQUNkLGVBQU8sT0FBTyxRQUFPLGFBQWEsUUFBUSxVQUFVLFNBQVM7QUFDN0QsZUFBTSxRQUFRO0FBQ2QsWUFBSSxPQUFPLFdBQVcsYUFBYTtBQUNqQyxpQkFBTyxRQUFRO0FBQUE7QUFHakIsZUFBTztBQUFBO0FBQUE7QUFBQTs7O0FDbHRhUDtBQUFBO0FBQUEsYUFBTyxVQUFVLGdCQUFjO0FBQUE7QUFBQTs7O0FDQS9CO0FBQUE7QUFNQSxNQUFDLFVBQVUsU0FBUSxTQUFTO0FBQzVCLGVBQU8sWUFBWSxZQUFZLE9BQU8sV0FBVyxjQUFjLE9BQU8sVUFBVSxRQUFRLG1CQUE2QixtQkFDckgsT0FBTyxXQUFXLGNBQWMsT0FBTyxNQUFNLE9BQU8sQ0FBQyxvQkFBb0IsYUFBYSxXQUNyRixXQUFTLE9BQU8sZUFBZSxjQUFjLGFBQWEsV0FBVSxNQUFNLFFBQU8sa0JBQWtCLFFBQVEsUUFBTyxNQUFNLFNBQVMsUUFBTztBQUFBLFNBQ3RJLFNBQU8sU0FBVSxTQUFTLFVBQVU7QUFBRTtBQUV6QyxZQUFJLG1CQUFvQixXQUFXO0FBQ2pDLGNBQUksT0FBTyxXQUFXLGFBQWE7QUFDakMsZ0JBQUksT0FBTyxrQkFBa0I7QUFDM0IscUJBQU8sT0FBTztBQUFBO0FBTWhCLGdCQUFJLFNBQVMsT0FBTztBQUNwQixnQkFBSSxRQUFRO0FBQ1YscUJBQVEsUUFBTyxjQUFjLEtBQU0sUUFBTyxlQUFlO0FBQUE7QUFBQTtBQUk3RCxpQkFBTztBQUFBO0FBR1QsWUFBSSxRQUFRO0FBQUEsVUFFVixhQUFhLFNBQVMsUUFBUTtBQUM1QixnQkFBSSxRQUFRO0FBQ1osZ0JBQUk7QUFFSixxQkFBUyxHQUFHLE9BQU87QUFDbkIsbUJBQU8sT0FBTyxRQUFRO0FBQ3BCLHNCQUFRLE9BQU87QUFDZixrQkFBSSxPQUFPLFVBQVUsVUFBVTtBQUM3QixzQkFBTSxRQUFRLE1BQU0sT0FBTyxNQUFNLE1BQU07QUFBQSx5QkFDOUIsTUFBTSxRQUFRLFFBQVE7QUFDL0IsdUJBQU8sS0FBSyxNQUFNLFFBQVE7QUFBQSx5QkFDakIsQ0FBQyxRQUFRLGNBQWMsU0FBUztBQUN6QyxzQkFBTSxRQUFRLEtBQUs7QUFBQTtBQUFBO0FBSXZCLG1CQUFPO0FBQUE7QUFBQSxVQUtULFVBQVUsU0FBUyxLQUFLLE9BQU8sTUFBTTtBQUNuQyxnQkFBSSxRQUFRLEdBQUcsT0FBTztBQUN0QixnQkFBSSxPQUFPLE1BQU07QUFDakIsZ0JBQUksT0FBTyxJQUFJO0FBQ2YsZ0JBQUksUUFBUTtBQUNaLGdCQUFJO0FBRUosZ0JBQUksT0FBTyxLQUFLO0FBRWhCLGlCQUFLLElBQUksR0FBRyxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ3pCLHNCQUFRLEtBQUssSUFBSSxJQUFJLFlBQVksTUFBTSxJQUFJLE9BQU87QUFBQTtBQUdwRCxnQkFBSSxPQUFPO0FBRVgsbUJBQU87QUFBQSxjQUNMLFFBQVEsT0FBTyxLQUFLO0FBQUEsY0FDcEI7QUFBQTtBQUFBO0FBQUEsVUFTSixPQUFPLFNBQVMsS0FBSyxPQUFPLEtBQUs7QUFDL0IsbUJBQU8sS0FBSyxJQUFJLEtBQUssS0FBSyxJQUFJLE9BQU87QUFBQTtBQUFBLFVBUXZDLFdBQVcsU0FBUyxJQUFJLElBQUk7QUFDMUIsZ0JBQUksT0FBTyxHQUFHO0FBQ2QsZ0JBQUksVUFBVTtBQUNkLGdCQUFJLEdBQUcsR0FBRyxNQUFNO0FBRWhCLGlCQUFLLElBQUksR0FBRyxPQUFPLEdBQUcsUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQzNDLGtCQUFJLEdBQUc7QUFDUCxrQkFBSSxLQUFLLFFBQVE7QUFFakIsa0JBQUksTUFBTSxJQUFJO0FBQ1osd0JBQVEsS0FBSyxDQUFDLEdBQUc7QUFBQSxxQkFDWjtBQUNMLHFCQUFLLE9BQU8sR0FBRztBQUFBO0FBQUE7QUFJbkIsaUJBQUssSUFBSSxHQUFHLE9BQU8sS0FBSyxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDN0Msc0JBQVEsS0FBSyxDQUFDLEtBQUssSUFBSTtBQUFBO0FBR3pCLG1CQUFPO0FBQUE7QUFBQSxVQU1ULFdBQVcsU0FBUyxHQUFHO0FBQ3JCLG1CQUFPLEtBQUssTUFBTSxJQUFJLG9CQUFvQjtBQUFBO0FBQUE7QUFJOUMsd0JBQWdCLE9BQU8sUUFBUTtBQUM3QixjQUFJLEtBQUssT0FBTztBQUNoQixjQUFJLEtBQUssT0FBTztBQUVoQixjQUFJLE9BQU8sTUFBTTtBQUNmLG1CQUFPLEVBQUMsR0FBRyxHQUFHLEdBQUc7QUFBQTtBQUVuQixjQUFJLE9BQU8sTUFBTTtBQUNmLG1CQUFPLEVBQUMsR0FBRyxHQUFHLEdBQUc7QUFBQTtBQUduQixjQUFJLEtBQUssTUFBTSxJQUFJO0FBQ25CLGNBQUksS0FBSyxNQUFNLElBQUk7QUFDbkIsY0FBSSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSztBQUVsQyxpQkFBTztBQUFBLFlBQ0wsR0FBRyxLQUFLLEtBQUssS0FBSztBQUFBLFlBQ2xCLEdBQUcsS0FBSyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBSXRCLHlCQUFpQixHQUFHLEdBQUcsSUFBSSxJQUFJLE9BQU87QUFDcEMsa0JBQVE7QUFBQSxpQkFDSDtBQUNILG1CQUFLLEtBQUs7QUFDVjtBQUFBLGlCQUNHO0FBQ0gsbUJBQUs7QUFDTCxtQkFBSztBQUNMO0FBQUEsaUJBQ0c7QUFDSCxtQkFBSztBQUNMLG1CQUFLO0FBQ0w7QUFBQSxpQkFDRztBQUNILG1CQUFLO0FBQ0wsbUJBQUs7QUFDTDtBQUFBLGlCQUNHO0FBQ0gsbUJBQUs7QUFDTCxtQkFBSztBQUNMO0FBQUEsaUJBQ0c7QUFDSCxtQkFBSyxDQUFDO0FBQ04sbUJBQUssQ0FBQztBQUNOO0FBQUEsaUJBQ0c7QUFFSDtBQUFBO0FBR0EsdUJBQVUsS0FBSyxLQUFLO0FBQ3BCLG1CQUFLLEtBQUssSUFBSTtBQUNkLG1CQUFLLEtBQUssSUFBSTtBQUNkO0FBQUE7QUFHRixpQkFBTztBQUFBLFlBQ0w7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQTtBQUFBO0FBT0osWUFBSSxXQUFXO0FBQ2YsWUFBSSxTQUFTO0FBQ2IsWUFBSSxVQUFVO0FBQ2QsWUFBSSxXQUFXO0FBQ2YsWUFBSSxRQUFRO0FBRVosd0JBQWdCLEdBQUcsR0FBRyxNQUFNO0FBQzFCLGNBQUksTUFBTTtBQUVWLGNBQUksSUFBSSxLQUFLLE1BQU07QUFDakIsbUJBQU87QUFBQSxxQkFDRSxJQUFJLEtBQUssT0FBTztBQUN6QixtQkFBTztBQUFBO0FBRVQsY0FBSSxJQUFJLEtBQUssS0FBSztBQUNoQixtQkFBTztBQUFBLHFCQUNFLElBQUksS0FBSyxRQUFRO0FBQzFCLG1CQUFPO0FBQUE7QUFHVCxpQkFBTztBQUFBO0FBR1QseUJBQWlCLFNBQVMsTUFBTTtBQUM5QixjQUFJLEtBQUssUUFBUTtBQUNqQixjQUFJLEtBQUssUUFBUTtBQUNqQixjQUFJLEtBQUssUUFBUTtBQUNqQixjQUFJLEtBQUssUUFBUTtBQUNqQixjQUFJLEtBQUssT0FBTyxJQUFJLElBQUk7QUFDeEIsY0FBSSxLQUFLLE9BQU8sSUFBSSxJQUFJO0FBQ3hCLGNBQUksR0FBRyxHQUFHO0FBR1YsaUJBQU8sTUFBTTtBQUNYLGdCQUFJLENBQUUsTUFBSyxPQUFRLEtBQUssSUFBSztBQUUzQjtBQUFBO0FBSUYsZ0JBQUksTUFBTTtBQUVWLGdCQUFJLElBQUksT0FBTztBQUNiLGtCQUFJLEtBQU0sTUFBSyxNQUFPLE1BQUssTUFBTSxNQUFPLE1BQUs7QUFDN0Msa0JBQUksS0FBSztBQUFBLHVCQUNBLElBQUksVUFBVTtBQUN2QixrQkFBSSxLQUFNLE1BQUssTUFBTyxNQUFLLFNBQVMsTUFBTyxNQUFLO0FBQ2hELGtCQUFJLEtBQUs7QUFBQSx1QkFDQSxJQUFJLFNBQVM7QUFDdEIsa0JBQUksS0FBTSxNQUFLLE1BQU8sTUFBSyxRQUFRLE1BQU8sTUFBSztBQUMvQyxrQkFBSSxLQUFLO0FBQUEsdUJBQ0EsSUFBSSxRQUFRO0FBQ3JCLGtCQUFJLEtBQU0sTUFBSyxNQUFPLE1BQUssT0FBTyxNQUFPLE1BQUs7QUFDOUMsa0JBQUksS0FBSztBQUFBO0FBR1gsZ0JBQUksTUFBTSxJQUFJO0FBQ1osbUJBQUs7QUFDTCxtQkFBSztBQUNMLG1CQUFLLE9BQU8sSUFBSSxJQUFJO0FBQUEsbUJBQ2Y7QUFDTCxtQkFBSztBQUNMLG1CQUFLO0FBQ0wsbUJBQUssT0FBTyxJQUFJLElBQUk7QUFBQTtBQUFBO0FBSXhCLGlCQUFPO0FBQUEsWUFDTDtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBO0FBQUE7QUFJSiwyQkFBbUIsUUFBTyxRQUFRO0FBQ2hDLGNBQUksU0FBUyxPQUFPO0FBQ3BCLGNBQUksVUFBVTtBQUNkLGNBQUksR0FBRztBQUVQLGNBQUksT0FBTyxPQUFPO0FBQ2hCLHNCQUFVLFFBQVEsU0FBUyxPQUFPO0FBQUE7QUFHcEMsY0FBSSxXQUFXLFNBQVM7QUFDdEIsZ0JBQUksUUFBUTtBQUNaLGdCQUFJLFFBQVE7QUFBQSxxQkFDSCxXQUFXLE9BQU87QUFDM0IsZ0JBQUksUUFBUTtBQUNaLGdCQUFJLFFBQVE7QUFBQSxpQkFDUDtBQUNMLGdCQUFLLFNBQVEsS0FBSyxRQUFRLE1BQU07QUFDaEMsZ0JBQUssU0FBUSxLQUFLLFFBQVEsTUFBTTtBQUFBO0FBR2xDLGlCQUFPLFFBQVEsR0FBRyxHQUFHLE9BQU0sSUFBSSxPQUFNLElBQUksT0FBTztBQUFBO0FBR2xELFlBQUksY0FBYztBQUFBLFVBQ2hCLEtBQUssU0FBUyxJQUFJLFFBQVE7QUFDeEIsZ0JBQUksUUFBUyxJQUFHLGFBQWEsR0FBRyxZQUFZO0FBQzVDLGdCQUFJLEtBQUssS0FBSyxJQUFJO0FBQ2xCLGdCQUFJLEtBQUssS0FBSyxJQUFJO0FBQ2xCLGdCQUFJLEtBQUssR0FBRztBQUNaLGdCQUFJLEtBQUssR0FBRztBQUVaLG1CQUFPLFVBQVU7QUFBQSxjQUNmLElBQUksR0FBRyxJQUFJLEtBQUs7QUFBQSxjQUNoQixJQUFJLEdBQUcsSUFBSSxLQUFLO0FBQUEsY0FDaEIsSUFBSSxHQUFHLElBQUksS0FBSztBQUFBLGNBQ2hCLElBQUksR0FBRyxJQUFJLEtBQUs7QUFBQSxjQUNoQjtBQUFBLGNBQ0E7QUFBQSxlQUNDO0FBQUE7QUFBQSxVQUdMLE9BQU8sU0FBUyxJQUFJLFFBQVE7QUFDMUIsZ0JBQUksSUFBSSxPQUFPLElBQUksT0FBTztBQUMxQixnQkFBSSxLQUFLLEVBQUUsSUFBSSxHQUFHLFFBQVE7QUFDMUIsZ0JBQUksS0FBSyxFQUFFLElBQUksR0FBRyxRQUFRO0FBRTFCLG1CQUFPLFVBQVU7QUFBQSxjQUNmLElBQUksR0FBRyxJQUFJO0FBQUEsY0FDWCxJQUFJLEdBQUcsSUFBSTtBQUFBLGNBQ1gsSUFBSSxHQUFHLElBQUk7QUFBQSxjQUNYLElBQUksR0FBRyxJQUFJO0FBQUEsY0FDWCxJQUFJLEVBQUU7QUFBQSxjQUNOLElBQUksRUFBRTtBQUFBLGVBQ0w7QUFBQTtBQUFBLFVBR0wsS0FBSyxTQUFTLElBQUksUUFBUTtBQUN4QixnQkFBSSxJQUFJLE9BQU8sSUFBSSxPQUFPO0FBQzFCLGdCQUFJLElBQUksR0FBRztBQUNYLGdCQUFJLElBQUksR0FBRztBQUNYLGdCQUFJLEtBQUs7QUFDVCxnQkFBSSxLQUFLO0FBRVQsZ0JBQUksR0FBRyxZQUFZO0FBQ2pCLGtCQUFJLEtBQUssSUFBSSxHQUFHLEdBQUcsR0FBRztBQUN0QixtQkFBSyxLQUFLLElBQUksR0FBRyxPQUFPLEdBQUc7QUFBQSxtQkFDdEI7QUFDTCxrQkFBSSxLQUFLLElBQUksR0FBRyxHQUFHLEdBQUc7QUFDdEIsbUJBQUssS0FBSyxJQUFJLEdBQUcsT0FBTyxHQUFHO0FBQUE7QUFHN0IsbUJBQU8sVUFBVTtBQUFBLGNBQ2YsSUFBSTtBQUFBLGNBQ0osSUFBSSxJQUFJO0FBQUEsY0FDUixJQUFJLElBQUk7QUFBQSxjQUNSLElBQUk7QUFBQSxjQUNKLElBQUksRUFBRTtBQUFBLGNBQ04sSUFBSSxFQUFFO0FBQUEsZUFDTDtBQUFBO0FBQUEsVUFHTCxVQUFVLFNBQVMsSUFBSSxRQUFRO0FBQzdCLGdCQUFJLElBQUksT0FBTyxJQUFJLE9BQU87QUFFMUIsbUJBQU8sVUFBVTtBQUFBLGNBQ2YsSUFBSSxHQUFHO0FBQUEsY0FDUCxJQUFJLEdBQUc7QUFBQSxjQUNQLElBQUksR0FBRyxJQUFLLElBQUcsU0FBUztBQUFBLGNBQ3hCLElBQUksR0FBRyxJQUFLLElBQUcsVUFBVTtBQUFBLGNBQ3pCLElBQUksRUFBRTtBQUFBLGNBQ04sSUFBSSxFQUFFO0FBQUEsZUFDTDtBQUFBO0FBQUE7QUFJUCxZQUFJLFlBQVksTUFBTTtBQUV0QiwrQkFBdUIsT0FBTztBQUM1QixjQUFJLGNBQWMsTUFBTSxlQUFlO0FBQ3ZDLGNBQUksVUFBVSxNQUFNO0FBQ3BCLGNBQUksS0FBSyxNQUFNLEtBQUs7QUFDcEIsY0FBSSxLQUFLLE1BQU0sS0FBSztBQUNwQixjQUFJLEtBQUssQ0FBQyxLQUFLO0FBQ2YsY0FBSSxLQUFLLENBQUMsS0FBSztBQUVmLGlCQUFPO0FBQUEsWUFDTCxPQUFPO0FBQUEsY0FDTCxHQUFHLEtBQUssUUFBUSxPQUFPO0FBQUEsY0FDdkIsR0FBRyxLQUFLLFFBQVEsTUFBTTtBQUFBLGNBQ3RCLEdBQUcsS0FBSyxRQUFRLFFBQVEsY0FBYztBQUFBLGNBQ3RDLEdBQUcsS0FBSyxRQUFRLFNBQVMsY0FBYztBQUFBO0FBQUEsWUFFekMsTUFBTTtBQUFBLGNBQ0osR0FBRztBQUFBLGNBQ0gsR0FBRztBQUFBLGNBQ0gsR0FBRztBQUFBLGNBQ0gsR0FBRztBQUFBO0FBQUE7QUFBQTtBQUtULGdDQUF3QixJQUFJLFNBQVM7QUFDbkMsY0FBSSxRQUFRLFFBQVEsTUFBTSxlQUFlLFFBQVEsY0FBYztBQUUvRCxjQUFJLENBQUMsT0FBTztBQUNWLG1CQUFPO0FBQUE7QUFHVCxjQUFJLE1BQU0sWUFBWSxVQUFhLE1BQU0sWUFBWSxRQUFXO0FBQzlELG1CQUFPLEVBQUMsR0FBRyxNQUFNLFNBQVMsR0FBRyxNQUFNO0FBQUE7QUFHckMsY0FBSSxRQUFRLE1BQU07QUFDbEIsaUJBQU8sR0FBRyxhQUNSLEVBQUMsR0FBRyxPQUFPLEdBQUcsU0FDZCxFQUFDLEdBQUcsTUFBTSxHQUFHO0FBQUE7QUFHakIsK0JBQXVCLElBQUk7QUFDekIsY0FBSSxjQUFjLFNBQVMsWUFBWTtBQUNyQyxtQkFBTyxZQUFZO0FBQUE7QUFFckIsY0FBSSxjQUFjLFNBQVMsY0FBYztBQUN2QyxtQkFBTyxZQUFZO0FBQUE7QUFFckIsY0FBSSxjQUFjLFNBQVMsWUFBWTtBQUNyQyxtQkFBTyxZQUFZO0FBQUE7QUFFckIsaUJBQU8sWUFBWTtBQUFBO0FBR3JCLGlDQUF5QixLQUFLLEdBQUcsR0FBRyxHQUFHLEdBQUcsUUFBUTtBQUNoRCxjQUFJLFVBQVUsS0FBSyxLQUFLO0FBRXhCLGNBQUksUUFBUTtBQUNWLGdCQUFJLElBQUksS0FBSyxJQUFJLFFBQVEsSUFBSSxHQUFHLElBQUk7QUFDcEMsZ0JBQUksT0FBTyxJQUFJO0FBQ2YsZ0JBQUksTUFBTSxJQUFJO0FBQ2QsZ0JBQUksUUFBUSxJQUFJLElBQUk7QUFDcEIsZ0JBQUksU0FBUyxJQUFJLElBQUk7QUFFckIsZ0JBQUksT0FBTyxHQUFHO0FBQ2QsZ0JBQUksT0FBTyxTQUFTLE1BQU0sUUFBUTtBQUNoQyxrQkFBSSxJQUFJLE1BQU0sS0FBSyxHQUFHLENBQUMsS0FBSyxJQUFJLENBQUM7QUFDakMsa0JBQUksSUFBSSxPQUFPLEtBQUssR0FBRyxDQUFDLFNBQVM7QUFDakMsa0JBQUksSUFBSSxPQUFPLFFBQVEsR0FBRyxHQUFHO0FBQzdCLGtCQUFJLElBQUksTUFBTSxRQUFRLEdBQUcsU0FBUyxLQUFLO0FBQUEsdUJBQzlCLE9BQU8sT0FBTztBQUN2QixrQkFBSSxPQUFPLE1BQU07QUFDakIsa0JBQUksSUFBSSxPQUFPLEtBQUssR0FBRyxDQUFDLFNBQVM7QUFDakMsa0JBQUksSUFBSSxNQUFNLEtBQUssR0FBRyxTQUFTLEtBQUssS0FBSztBQUFBLHVCQUNoQyxNQUFNLFFBQVE7QUFDdkIsa0JBQUksSUFBSSxNQUFNLEtBQUssR0FBRyxDQUFDLEtBQUssSUFBSTtBQUNoQyxrQkFBSSxJQUFJLE1BQU0sUUFBUSxHQUFHLEdBQUcsS0FBSztBQUFBLG1CQUM1QjtBQUNMLGtCQUFJLElBQUksTUFBTSxLQUFLLEdBQUcsQ0FBQyxLQUFLLElBQUksS0FBSztBQUFBO0FBRXZDLGdCQUFJO0FBQ0osZ0JBQUksT0FBTyxHQUFHO0FBQUEsaUJBQ1Q7QUFDTCxnQkFBSSxLQUFLLEdBQUcsR0FBRyxHQUFHO0FBQUE7QUFBQTtBQUl0QiwyQkFBbUIsS0FBSyxNQUFNLE9BQU87QUFDbkMsY0FBSSxVQUFVLE1BQU07QUFDcEIsY0FBSSxjQUFjLE1BQU07QUFDeEIsY0FBSSxjQUFjLE1BQU07QUFFeEIsY0FBSSxDQUFDLFdBQVksRUFBQyxlQUFlLENBQUMsY0FBYztBQUM5QztBQUFBO0FBR0YsY0FBSTtBQUVKLDBCQUNFLEtBQ0EsVUFBVSxLQUFLLEtBQUssY0FBYyxHQUNsQyxVQUFVLEtBQUssS0FBSyxjQUFjLEdBQ2xDLFVBQVUsS0FBSyxLQUFLLGFBQ3BCLFVBQVUsS0FBSyxLQUFLLGFBQ3BCLE1BQU07QUFFUixjQUFJO0FBRUosY0FBSSxTQUFTO0FBQ1gsZ0JBQUksWUFBWTtBQUNoQixnQkFBSTtBQUFBO0FBR04sY0FBSSxlQUFlLGFBQWE7QUFDOUIsZ0JBQUksY0FBYztBQUNsQixnQkFBSSxZQUFZO0FBQ2hCLGdCQUFJLFdBQVc7QUFDZixnQkFBSTtBQUFBO0FBQUE7QUFJUiw4QkFBc0IsTUFBTSxPQUFPLE1BQU07QUFDdkMsY0FBSSxJQUFJLEtBQUs7QUFDYixjQUFJLElBQUksS0FBSztBQUNiLGNBQUksSUFBSSxLQUFLO0FBQ2IsY0FBSSxJQUFJLEtBQUssSUFBSSxJQUFJO0FBRXJCLGNBQUksVUFBVSxVQUFVO0FBQ3RCLGlCQUFLLElBQUk7QUFBQSxxQkFDQSxVQUFVLFNBQVMsVUFBVSxTQUFTO0FBQy9DLGlCQUFLO0FBQUE7QUFHUCxpQkFBTztBQUFBLFlBQ0w7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQTtBQUFBO0FBSUosOEJBQXNCLEtBQUssTUFBTSxLQUFLO0FBQ3BDLGNBQUksU0FBUyxJQUFJO0FBQ2pCLGNBQUksVUFBVSxJQUFJO0FBQ2xCLGNBQUksSUFBSSxVQUFVLElBQUk7QUFDdEIsY0FBSSxJQUFJLFVBQVUsSUFBSTtBQUN0QixjQUFJLElBQUksVUFBVSxJQUFJO0FBRXRCLGNBQUksU0FBUztBQUNYLGdCQUFJLFdBQVcsTUFBTSxHQUFHLEdBQUc7QUFBQTtBQUc3QixjQUFJLElBQUksUUFBUTtBQUNkLGdCQUFJLFVBQVUsU0FBUztBQUdyQixrQkFBSSxhQUFhO0FBQUE7QUFHbkIsZ0JBQUksU0FBUyxNQUFNLEdBQUcsR0FBRztBQUV6QixnQkFBSSxVQUFVLFNBQVM7QUFDckIsa0JBQUksYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUt2QiwwQkFBa0IsS0FBSyxPQUFPLE1BQU0sT0FBTztBQUN6QyxjQUFJLFFBQVEsTUFBTTtBQUNsQixjQUFJLFFBQVEsTUFBTTtBQUNsQixjQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQ2YsY0FBSSxPQUFPLE1BQU07QUFDakIsY0FBSSxPQUFPLE1BQU07QUFDakIsY0FBSSxjQUFjLE1BQU07QUFDeEIsY0FBSSxjQUFjLE1BQU07QUFDeEIsY0FBSSxVQUFVLGVBQWU7QUFDN0IsY0FBSTtBQUVKLGNBQUksQ0FBQyxRQUFTLENBQUMsVUFBVSxDQUFDLFNBQVU7QUFDbEM7QUFBQTtBQUlGLGlCQUFPLGFBQWEsTUFBTSxPQUFPO0FBRWpDLGNBQUksT0FBTyxLQUFLO0FBQ2hCLGNBQUksWUFBWTtBQUNoQixjQUFJLGVBQWU7QUFDbkIsY0FBSSxhQUFhLE1BQU07QUFDdkIsY0FBSSxjQUFjLE1BQU07QUFFeEIsY0FBSSxRQUFRO0FBQ1YsZ0JBQUksWUFBWTtBQUFBO0FBRWxCLGNBQUksU0FBUztBQUNYLGdCQUFJLFdBQVc7QUFDZixnQkFBSSxZQUFZO0FBQ2hCLGdCQUFJLGNBQWM7QUFBQTtBQUdwQixlQUFLLElBQUksR0FBRyxPQUFPLE1BQU0sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQzlDLHlCQUFhLEtBQUssTUFBTSxJQUFJO0FBQUEsY0FDMUI7QUFBQSxjQUNBO0FBQUEsY0FDQSxHQUFHLEtBQUs7QUFBQSxjQUNSLEdBQUcsS0FBSztBQUFBLGNBQ1IsR0FBRyxLQUFLLElBQUksS0FBSyxJQUFJO0FBQUE7QUFBQTtBQUFBO0FBSzNCLFlBQUksUUFBUSxTQUFTLFFBQVEsS0FBSyxJQUFJLFFBQU87QUFDM0MsY0FBSSxLQUFLO0FBRVQsYUFBRyxVQUFVO0FBQ2IsYUFBRyxTQUFTO0FBQ1osYUFBRyxTQUFTO0FBQ1osYUFBRyxTQUFTO0FBQ1osYUFBRyxPQUFPO0FBQ1YsYUFBRyxNQUFNO0FBQUE7QUFHWCxnQkFBUSxNQUFNLE1BQU0sV0FBVztBQUFBLFVBSTdCLFdBQVcsU0FBUyxTQUFTLE9BQU8sUUFBUSxTQUFTO0FBQ25ELGdCQUFJLEtBQUs7QUFDVCxnQkFBSSxTQUFRLEdBQUc7QUFDZixnQkFBSSxPQUFPLFFBQVEsT0FBTyxRQUFRLFFBQVEsQ0FBQyxPQUFPLE1BQU0sS0FBSyxTQUFTO0FBQ3RFLGdCQUFJLFFBQVEsUUFBUSxRQUFRLENBQUMsT0FBTyxPQUFPLFNBQVMsU0FBUyxRQUFRLFNBQVM7QUFFOUUsbUJBQU87QUFBQSxjQUNMLE9BQU8sUUFBUSxRQUFRLENBQUMsT0FBTyxPQUFPLFdBQVcsU0FBUztBQUFBLGNBQzFELFFBQVEsUUFBUSxRQUFRLENBQUMsT0FBTyxRQUFRLFdBQVcsU0FBUztBQUFBLGNBQzVELE1BQU0sUUFBUSxNQUFNO0FBQUEsY0FDcEIsaUJBQWlCLFFBQVEsUUFBUSxDQUFDLE9BQU8saUJBQWlCLE9BQU8sU0FBUztBQUFBLGNBQzFFLGFBQWEsUUFBUSxRQUFRLENBQUMsT0FBTyxhQUFhLE9BQU8sU0FBUztBQUFBLGNBQ2xFLGNBQWMsUUFBUSxRQUFRLENBQUMsT0FBTyxjQUFjLElBQUksU0FBUztBQUFBLGNBQ2pFLGFBQWEsUUFBUSxRQUFRLENBQUMsT0FBTyxhQUFhLElBQUksU0FBUztBQUFBLGNBQy9ELE9BQU8sUUFBUSxRQUFRLENBQUMsT0FBTyxPQUFPLFFBQVEsU0FBUztBQUFBLGNBQ3ZELE1BQU0sUUFBUSxRQUFRLENBQUMsT0FBTyxNQUFNLFFBQVEsU0FBUztBQUFBLGNBQ3JEO0FBQUEsY0FDQTtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsY0FDQSxRQUFRLFFBQVEsUUFBUSxDQUFDLE9BQU8sUUFBUSxJQUFJLFNBQVM7QUFBQSxjQUNyRCxTQUFTLFFBQVEsUUFBUSxDQUFDLE9BQU8sU0FBUyxJQUFJLFNBQVM7QUFBQSxjQUN2RCxRQUFRLGVBQWUsR0FBRyxLQUFLO0FBQUEsY0FDL0IsU0FBUyxRQUFRLFVBQVUsUUFBUSxRQUFRLENBQUMsT0FBTyxTQUFTLElBQUksU0FBUztBQUFBLGNBQ3pFLFlBQVksY0FBYyxHQUFHO0FBQUEsY0FDN0IsVUFBVSxRQUFRLFFBQVEsQ0FBQyxPQUFPLFVBQVUsSUFBSSxTQUFTLFVBQVUsTUFBSyxLQUFLO0FBQUEsY0FDN0UsTUFBTSxNQUFNLFNBQVMsR0FBRyxNQUFNLE9BQU87QUFBQSxjQUNyQyxXQUFXLFFBQVEsUUFBUSxDQUFDLE9BQU8sV0FBVyxVQUFVLFNBQVM7QUFBQSxjQUNqRSxnQkFBZ0IsUUFBUSxRQUFRLENBQUMsT0FBTyxnQkFBZ0IsSUFBSSxTQUFTO0FBQUEsY0FDckUsaUJBQWlCLFFBQVEsUUFBUSxDQUFDLE9BQU8saUJBQWlCLFFBQVEsU0FBUztBQUFBLGNBQzNFLGlCQUFpQixRQUFRLFFBQVEsQ0FBQyxPQUFPLGlCQUFpQixRQUFRLFNBQVM7QUFBQSxjQUMzRSxpQkFBaUIsUUFBUSxRQUFRLENBQUMsT0FBTyxpQkFBaUIsSUFBSSxTQUFTO0FBQUE7QUFBQTtBQUFBLFVBSTNFLFFBQVEsU0FBUyxTQUFTO0FBQ3hCLGdCQUFJLEtBQUs7QUFDVCxnQkFBSSxRQUFRO0FBQ1osZ0JBQUksUUFBUTtBQUNaLGdCQUFJLFNBQVEsR0FBRztBQUNmLGdCQUFJLFNBQVMsR0FBRztBQUNoQixnQkFBSSxPQUFPLE9BQU87QUFJbEIsZ0JBQUksVUFBVSxRQUFRLFFBQVEsQ0FBQyxPQUFPLFNBQVMsT0FBTyxTQUFTO0FBRS9ELGdCQUFJLFNBQVM7QUFDWCxzQkFBUSxRQUFRLFFBQVEsS0FBSztBQUM3QixzQkFBUSxRQUFRLGVBQWUsUUFBUSxTQUFTLE9BQU8sV0FBVyxDQUFDLE9BQU8sV0FBVztBQUNyRixzQkFBUSxRQUFRLGNBQWMsU0FBUyxLQUFLLE1BQU0sWUFBWTtBQUU5RCxrQkFBSSxNQUFNLFFBQVE7QUFDaEIsd0JBQVEsR0FBRyxVQUFVLFNBQVMsT0FBTyxRQUFRO0FBQzdDLHdCQUFRLGNBQWM7QUFBQTtBQUFBO0FBSTFCLGVBQUcsU0FBUztBQUNaLGVBQUcsU0FBUztBQUFBO0FBQUEsVUFHZCxVQUFVLFdBQVc7QUFDbkIsbUJBQU8sS0FBSyxTQUFTLEtBQUssT0FBTyxRQUFRO0FBQUE7QUFBQSxVQUczQyxVQUFVLFdBQVc7QUFDbkIsbUJBQU8sS0FBSyxTQUFTLEtBQUssT0FBTyxXQUFXO0FBQUE7QUFBQSxVQUc5QyxTQUFTLFdBQVc7QUFDbEIsbUJBQU8sS0FBSyxVQUFVLEtBQUssT0FBTztBQUFBO0FBQUEsVUFHcEMsT0FBTyxXQUFXO0FBQ2hCLG1CQUFPLEtBQUs7QUFBQTtBQUFBLFVBR2QsTUFBTSxTQUFTLFFBQU8sUUFBUTtBQUM1QixnQkFBSSxLQUFLO0FBQ1QsZ0JBQUksTUFBTSxPQUFNO0FBQ2hCLGdCQUFJLFFBQVEsR0FBRztBQUNmLGdCQUFJLFFBQVEsR0FBRztBQUNmLGdCQUFJO0FBRUosZ0JBQUksQ0FBQyxLQUFLLFdBQVc7QUFDbkI7QUFBQTtBQUdGLGdCQUFJO0FBRUosZ0JBQUksTUFBTSxNQUFNO0FBQ2QscUJBQU8sTUFBTTtBQUNiLGtCQUFJO0FBQ0osa0JBQUksS0FDRixLQUFLLE1BQ0wsS0FBSyxLQUNMLEtBQUssUUFBUSxLQUFLLE1BQ2xCLEtBQUssU0FBUyxLQUFLO0FBQ3JCLGtCQUFJO0FBQUE7QUFHTixnQkFBSSxjQUFjLE1BQU0sTUFBTSxHQUFHLE1BQU0sU0FBUztBQUNoRCxnQkFBSSxVQUFVLFVBQVUsT0FBTyxJQUFJLFVBQVUsT0FBTztBQUNwRCxnQkFBSSxPQUFPLE1BQU07QUFFakIsc0JBQVUsS0FBSyxNQUFNLE9BQU87QUFDNUIscUJBQVMsS0FBSyxNQUFNLE9BQU8sTUFBTSxNQUFNO0FBRXZDLGdCQUFJO0FBQUE7QUFBQTtBQUlSLFlBQUksY0FBYyxPQUFPLG9CQUFvQjtBQUM3QyxZQUFJLGNBQWMsT0FBTyxvQkFBb0I7QUFFN0MseUJBQWlCLE9BQU8sUUFBUSxPQUFPO0FBQ3JDLGNBQUksTUFBTSxLQUFLLElBQUk7QUFDbkIsY0FBSSxNQUFNLEtBQUssSUFBSTtBQUNuQixjQUFJLEtBQUssT0FBTztBQUNoQixjQUFJLEtBQUssT0FBTztBQUVoQixpQkFBTztBQUFBLFlBQ0wsR0FBRyxLQUFLLE1BQU8sT0FBTSxJQUFJLE1BQU0sTUFBTyxPQUFNLElBQUk7QUFBQSxZQUNoRCxHQUFHLEtBQUssTUFBTyxPQUFNLElBQUksTUFBTSxNQUFPLE9BQU0sSUFBSTtBQUFBO0FBQUE7QUFJcEQsMkJBQW1CLFFBQVEsTUFBTTtBQUMvQixjQUFJLE1BQU07QUFDVixjQUFJLE1BQU07QUFDVixjQUFJLFNBQVMsS0FBSztBQUNsQixjQUFJLEdBQUcsSUFBSSxJQUFJLElBQUk7QUFFbkIsZUFBSyxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsRUFBRSxHQUFHO0FBQ2xDLGlCQUFLLE9BQU87QUFDWixpQkFBSyxHQUFHLElBQUksT0FBTztBQUNuQixpQkFBSyxHQUFHLElBQUksT0FBTztBQUNuQixpQkFBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUs7QUFDOUIsa0JBQU0sS0FBSyxJQUFJLEtBQUs7QUFDcEIsa0JBQU0sS0FBSyxJQUFJLEtBQUs7QUFBQTtBQUd0QixpQkFBTztBQUFBLFlBQ0w7QUFBQSxZQUNBO0FBQUE7QUFBQTtBQUlKLHdCQUFnQixJQUFJLElBQUk7QUFDdEIsY0FBSSxLQUFLLEdBQUcsSUFBSSxHQUFHO0FBQ25CLGNBQUksS0FBSyxHQUFHLElBQUksR0FBRztBQUNuQixjQUFJLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLO0FBRWxDLGlCQUFPO0FBQUEsWUFDTCxJQUFLLElBQUcsSUFBSSxHQUFHLEtBQUs7QUFBQSxZQUNwQixJQUFLLElBQUcsSUFBSSxHQUFHLEtBQUs7QUFBQSxZQUNwQixRQUFRO0FBQUEsWUFDUjtBQUFBO0FBQUE7QUFJSixZQUFJLFNBQVMsV0FBVztBQUN0QixlQUFLLFlBQVk7QUFDakIsZUFBSyxRQUFRO0FBQUEsWUFDWCxHQUFHO0FBQUEsWUFDSCxHQUFHO0FBQUEsWUFDSCxHQUFHO0FBQUEsWUFDSCxHQUFHO0FBQUE7QUFBQTtBQUlQLGdCQUFRLE1BQU0sT0FBTyxXQUFXO0FBQUEsVUFDOUIsUUFBUSxXQUFXO0FBQ2pCLGdCQUFJLElBQUksS0FBSztBQUNiLG1CQUFPO0FBQUEsY0FDTCxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUk7QUFBQSxjQUNmLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSTtBQUFBO0FBQUE7QUFBQSxVQUluQixRQUFRLFNBQVMsUUFBUSxNQUFNLFVBQVU7QUFDdkMsaUJBQUssWUFBWTtBQUNqQixpQkFBSyxRQUFRO0FBQUEsY0FDWCxHQUFHLEtBQUssSUFBSSxPQUFPO0FBQUEsY0FDbkIsR0FBRyxLQUFLLElBQUksT0FBTztBQUFBLGNBQ25CLEdBQUcsS0FBSztBQUFBLGNBQ1IsR0FBRyxLQUFLO0FBQUE7QUFBQTtBQUFBLFVBSVosVUFBVSxTQUFTLE9BQU87QUFDeEIsZ0JBQUksS0FBSztBQUNULGdCQUFJLFNBQVM7QUFDYixnQkFBSSxPQUFPLEdBQUc7QUFFZCxvQkFBUSxRQUFRLE9BQU8sR0FBRyxVQUFVLENBQUMsR0FBRztBQUV4QyxtQkFBTyxDQUFFLE9BQU0sSUFBSSxLQUFLLElBQUksVUFDdkIsTUFBTSxJQUFJLEtBQUssSUFBSSxVQUNuQixNQUFNLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSSxTQUFTLEtBQ3JDLE1BQU0sSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLFNBQVM7QUFBQTtBQUFBLFVBSzVDLFlBQVksU0FBUyxPQUFPO0FBQzFCLGdCQUFJLEtBQUssS0FBSztBQUNkLGdCQUFJLEtBQUssTUFBTTtBQUNmLGdCQUFJLE9BQU87QUFBQSxjQUNULE9BQU8sR0FBRyxJQUFJLEdBQUc7QUFBQSxjQUNqQixPQUFPLEdBQUcsSUFBSSxHQUFHO0FBQUE7QUFFbkIsZ0JBQUksR0FBRyxLQUFLO0FBRVosZ0JBQUksS0FBSyxjQUFjLE1BQU0sV0FBVztBQUd0QyxtQkFBSyxLQUNILE9BQU8sR0FBRyxJQUFJLEdBQUcsS0FDakIsT0FBTyxHQUFHLElBQUksR0FBRztBQUFBO0FBSXJCLGlCQUFLLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxFQUFFLEdBQUc7QUFDaEMsb0JBQU0sVUFBVSxJQUFJLEtBQUs7QUFDekIsb0JBQU0sVUFBVSxJQUFJLEtBQUs7QUFFekIsa0JBQUksSUFBSSxNQUFNLElBQUksT0FBTyxJQUFJLE1BQU0sSUFBSSxLQUFLO0FBQzFDLHVCQUFPO0FBQUE7QUFBQTtBQUlYLG1CQUFPO0FBQUE7QUFBQSxVQU1ULFNBQVMsV0FBVztBQUNsQixnQkFBSSxLQUFLO0FBQ1QsZ0JBQUksT0FBTyxHQUFHO0FBQ2QsZ0JBQUksUUFBUSxHQUFHO0FBQ2YsZ0JBQUksU0FBUyxHQUFHO0FBRWhCLG1CQUFPO0FBQUEsY0FDTCxRQUFRLEVBQUMsR0FBRyxLQUFLLEdBQUcsR0FBRyxLQUFLLEtBQUksUUFBUTtBQUFBLGNBQ3hDLFFBQVEsRUFBQyxHQUFHLEtBQUssSUFBSSxLQUFLLEdBQUcsR0FBRyxLQUFLLEtBQUksUUFBUTtBQUFBLGNBQ2pELFFBQVEsRUFBQyxHQUFHLEtBQUssSUFBSSxLQUFLLEdBQUcsR0FBRyxLQUFLLElBQUksS0FBSyxLQUFJLFFBQVE7QUFBQSxjQUMxRCxRQUFRLEVBQUMsR0FBRyxLQUFLLEdBQUcsR0FBRyxLQUFLLElBQUksS0FBSyxLQUFJLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFLdkQsNkJBQXFCLElBQUksT0FBTyxVQUFVO0FBQ3hDLGNBQUksUUFBUSxNQUFNLFdBQVcsSUFBSTtBQUNqQyxjQUFJLEtBQUssTUFBTTtBQUNmLGNBQUksS0FBSyxNQUFNO0FBRWYsY0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJO0FBRWQsbUJBQU8sRUFBQyxHQUFHLE1BQU0sR0FBRyxHQUFHLE1BQU07QUFBQTtBQUcvQixjQUFJLElBQUksU0FBUztBQUNqQixjQUFJLElBQUksU0FBUztBQUdqQixjQUFJLFdBQVcsTUFBTTtBQUNyQixjQUFJLEtBQUssS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksYUFBYSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSTtBQUMxRSxjQUFJLEtBQUssS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksYUFBYSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSTtBQUsxRSxjQUFJLEtBQUssSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLEtBQUssS0FBSyxJQUFJO0FBQzdDLGdCQUFNLEtBQUs7QUFDWCxnQkFBTSxLQUFLO0FBR1gsZ0JBQU0sTUFBTSxTQUFTO0FBQ3JCLGdCQUFNLE1BQU0sU0FBUztBQUVyQixpQkFBTztBQUFBLFlBQ0wsR0FBRyxNQUFNLElBQUk7QUFBQSxZQUNiLEdBQUcsTUFBTSxJQUFJO0FBQUE7QUFBQTtBQUlqQix5QkFBaUIsUUFBUSxVQUFVO0FBQ2pDLGNBQUksR0FBRyxHQUFHLElBQUk7QUFNZCxlQUFLLElBQUksT0FBTyxTQUFTLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUN2QyxpQkFBSyxPQUFPLEdBQUc7QUFFZixpQkFBSyxJQUFJLElBQUksR0FBRyxLQUFLLEtBQUssR0FBRyxVQUFVLEVBQUUsR0FBRztBQUMxQyxtQkFBSyxPQUFPLEdBQUc7QUFFZixrQkFBSSxHQUFHLFlBQVksR0FBRyxLQUFLLFdBQVcsR0FBRyxPQUFPO0FBQzlDLHlCQUFTLElBQUk7QUFBQTtBQUFBO0FBQUE7QUFLbkIsaUJBQU87QUFBQTtBQUdULHlCQUFpQixRQUFRO0FBQ3ZCLGNBQUksR0FBRyxNQUFNLE9BQU8sT0FBTyxVQUFVLFFBQVE7QUFHN0MsZUFBSyxJQUFJLEdBQUcsT0FBTyxPQUFPLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUMvQyxvQkFBUSxPQUFPO0FBQ2Ysb0JBQVEsTUFBTTtBQUVkLGdCQUFJLE1BQU0sVUFBVTtBQU1sQixzQkFBUSxJQUFJLE1BQU0sTUFBTSxLQUFLLEVBQUMsS0FBSyxDQUFDLElBQUksTUFBTSxHQUFHLFNBQVMsQ0FBQyxJQUFJLE1BQU07QUFFckUseUJBQVcsTUFBTTtBQUNqQix1QkFBUyxZQUFZLE9BQU8sTUFBTSxTQUFTO0FBQzNDLG9CQUFNLEtBQUssT0FBTyxRQUFRLFVBQVUsTUFBTTtBQUFBO0FBQUE7QUFLOUMsaUJBQU8sUUFBUSxRQUFRLFNBQVMsSUFBSSxJQUFJO0FBQ3RDLGdCQUFJLEtBQUssR0FBRztBQUNaLGdCQUFJLEtBQUssR0FBRztBQUVaLGdCQUFLLE1BQU0sTUFBTyxJQUFJO0FBQ3BCLGlCQUFHLFdBQVc7QUFBQSx1QkFDTCxJQUFJO0FBQ2IsaUJBQUcsV0FBVztBQUFBO0FBQUE7QUFBQTtBQUtwQixZQUFJLFNBQVM7QUFBQSxVQUNYLFNBQVMsU0FBUyxVQUFVO0FBQzFCLGdCQUFJLFNBQVM7QUFDYixnQkFBSSxHQUFHLEdBQUcsTUFBTSxNQUFNO0FBRXRCLGlCQUFLLElBQUksR0FBRyxPQUFPLFNBQVMsUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ2pELG1CQUFLLElBQUksR0FBRyxPQUFPLFNBQVMsR0FBRyxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDcEQsd0JBQVEsU0FBUyxHQUFHO0FBQ3BCLHVCQUFPLEtBQUs7QUFDWixzQkFBTSxVQUFVO0FBQUEsa0JBQ2QsTUFBTSxJQUFJO0FBQUEsa0JBQ1YsVUFBVTtBQUFBLGtCQUNWLFVBQVU7QUFBQSxrQkFDVixNQUFNO0FBQUEsa0JBQ04sTUFBTSxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBUWxCLG1CQUFPLEtBQUssU0FBUyxHQUFHLEdBQUc7QUFDekIsa0JBQUksS0FBSyxFQUFFO0FBQ1gsa0JBQUksS0FBSyxFQUFFO0FBRVgscUJBQU8sR0FBRyxTQUFTLEdBQUcsT0FDbEIsR0FBRyxPQUFPLEdBQUcsT0FDYixHQUFHLE9BQU8sR0FBRztBQUFBO0FBR25CLGlCQUFLLE9BQU87QUFFWixtQkFBTztBQUFBO0FBQUEsVUFHVCxRQUFRLFNBQVMsUUFBUTtBQUN2QixnQkFBSSxRQUFRO0FBQ1osZ0JBQUksR0FBRyxNQUFNLE9BQU8sT0FBTztBQUUzQixpQkFBSyxJQUFJLEdBQUcsT0FBTyxPQUFPLFFBQVEsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUMvQyxzQkFBUSxPQUFPO0FBQ2Ysc0JBQVEsTUFBTTtBQUNkLHNCQUFRLE1BQU07QUFDZCxvQkFBTSxXQUFXLFNBQVMsTUFBTSxZQUFZO0FBQzVDLG9CQUFNLFdBQVcsTUFBTTtBQUN2Qix1QkFBUyxNQUFNO0FBQUE7QUFHakIsZ0JBQUksT0FBTztBQUNULHNCQUFRO0FBQUE7QUFBQTtBQUFBLFVBSVosUUFBUSxTQUFTLFFBQVEsT0FBTztBQUM5QixnQkFBSSxHQUFHO0FBS1AsaUJBQUssSUFBSSxPQUFPLFNBQVMsR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLHNCQUFRLE9BQU8sR0FBRztBQUVsQixrQkFBSSxTQUFTLE1BQU0sWUFBWSxNQUFNLEtBQUssU0FBUyxRQUFRO0FBQ3pELHVCQUFPLE9BQU87QUFBQTtBQUFBO0FBSWxCLG1CQUFPO0FBQUE7QUFBQSxVQUdULE1BQU0sU0FBUyxRQUFPLFFBQVE7QUFDNUIsZ0JBQUksR0FBRyxNQUFNLE9BQU8sT0FBTyxVQUFVO0FBRXJDLGlCQUFLLElBQUksR0FBRyxPQUFPLE9BQU8sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQy9DLHNCQUFRLE9BQU87QUFDZixzQkFBUSxNQUFNO0FBRWQsa0JBQUksTUFBTSxVQUFVO0FBQ2xCLDJCQUFXLE1BQU07QUFDakIseUJBQVMsWUFBWSxNQUFNLEtBQUssTUFBTSxTQUFTO0FBQy9DLHNCQUFNLEtBQUssT0FBTyxRQUFRLFVBQVUsTUFBTTtBQUMxQyxzQkFBTSxLQUFLLFFBQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU0xQixZQUFJLFlBQVksU0FBUyxPQUFPO0FBQzlCLGNBQUksUUFBUSxjQUFjLFFBQVE7QUFDaEMsbUJBQU87QUFBQTtBQUdULGNBQUksUUFBUTtBQUNaLGNBQUksTUFBTSxNQUFNO0FBQ2hCLGNBQUksUUFBUSxTQUFTLFFBQVE7QUFDM0IsZ0JBQUksQ0FBQyxRQUFRLGNBQWMsTUFBTSxRQUFRO0FBQ3ZDLHNCQUFRLE1BQU07QUFBQSx1QkFDTCxDQUFDLFFBQVEsY0FBYyxNQUFNLElBQUk7QUFDMUMsc0JBQVEsTUFBTTtBQUFBLG1CQUNUO0FBQ0wsc0JBQVE7QUFDUixxQkFBTyxPQUFPLEtBQUs7QUFDbkIsbUJBQUssSUFBSSxHQUFHLE9BQU8sS0FBSyxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDN0MseUJBQVUsT0FBTSxJQUFJLE9BQU8sTUFBTSxLQUFLLEtBQUssT0FBTyxNQUFNLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFLbkUsaUJBQU8sS0FBSztBQUFBO0FBUWQsWUFBSSxXQUFXO0FBQUEsVUFDYixPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixpQkFBaUI7QUFBQSxVQUNqQixhQUFhO0FBQUEsVUFDYixjQUFjO0FBQUEsVUFDZCxhQUFhO0FBQUEsVUFDYixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsWUFDSixRQUFRO0FBQUEsWUFDUixZQUFZO0FBQUEsWUFDWixNQUFNO0FBQUEsWUFDTixPQUFPO0FBQUEsWUFDUCxRQUFRO0FBQUE7QUFBQSxVQUVWO0FBQUEsVUFDQSxRQUFRO0FBQUEsVUFDUixXQUFXO0FBQUEsVUFDWCxRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsWUFDUCxLQUFLO0FBQUEsWUFDTCxPQUFPO0FBQUEsWUFDUCxRQUFRO0FBQUEsWUFDUixNQUFNO0FBQUE7QUFBQSxVQUVSLFVBQVU7QUFBQSxVQUNWLFdBQVc7QUFBQSxVQUNYLGlCQUFpQjtBQUFBLFVBQ2pCLGlCQUFpQjtBQUFBLFVBQ2pCLGdCQUFnQjtBQUFBLFVBQ2hCLGlCQUFpQjtBQUFBO0FBT25CLFlBQUksY0FBYztBQUNsQixZQUFJLGNBQWM7QUFFbEIsMkJBQW1CLFNBQVMsU0FBUztBQUNuQyxjQUFJLFdBQVcsUUFBUTtBQUN2QixjQUFJLFlBQVk7QUFDaEIsY0FBSSxVQUFVO0FBQ2QsY0FBSSxRQUFRO0FBRVosY0FBSSxhQUFhLE9BQU87QUFDdEIsbUJBQU87QUFBQTtBQUVULGNBQUksYUFBYSxNQUFNO0FBQ3JCLHVCQUFXO0FBQUE7QUFHYixvQkFBVSxRQUFRLE1BQU0sSUFBSSxDQUFDLFNBQVM7QUFDdEMsbUJBQVMsUUFBUSxVQUFVO0FBQzNCLGlCQUFPLE9BQU8sS0FBSztBQUNuQixpQkFBTyxRQUFRO0FBRWYsY0FBSSxLQUFLLFFBQVE7QUFDZixpQkFBSyxRQUFRLFNBQVMsS0FBSztBQUN6QixrQkFBSSxPQUFPLE1BQU07QUFDZix3QkFBUSxLQUFLLFFBQVEsTUFBTSxJQUFJO0FBQUEsa0JBQzdCO0FBQUEsa0JBQ0EsT0FBTztBQUFBLGtCQUNQLEVBQUMsTUFBTTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUlSO0FBRUwsb0JBQVEsS0FBSztBQUFBO0FBSWYsc0JBQVksUUFBUSxPQUFPLFNBQVMsUUFBUSxRQUFRO0FBQ2xELG9CQUFRLEtBQUssT0FBTyxhQUFhLElBQUksU0FBUyxJQUFJLE9BQU87QUFDdkQscUJBQU8sU0FBUyxPQUFPLFVBQVU7QUFDakMscUJBQU8sT0FBTyxPQUFPLFFBQVEsZUFBZTtBQUFBO0FBRzlDLG1CQUFPLE9BQU87QUFDZCxtQkFBTztBQUFBLGFBQ047QUFFSCxpQkFBTztBQUFBLFlBQ0wsUUFBUTtBQUFBLFlBQ1I7QUFBQTtBQUFBO0FBSUosK0JBQXVCLFFBQU8sV0FBVyxPQUFPLE9BQU87QUFDckQsY0FBSSxDQUFDLFdBQVc7QUFDZDtBQUFBO0FBR0YsY0FBSSxVQUFVLE1BQU07QUFDcEIsY0FBSSxTQUFTLE1BQU07QUFDbkIsY0FBSTtBQUVKLGNBQUksQ0FBQyxVQUFVLE9BQU8sT0FBTztBQUMzQjtBQUFBO0FBR0YscUJBQVcsVUFBVSxPQUFPLE1BQU0sT0FBTztBQUN6QyxjQUFJLENBQUMsVUFBVTtBQUNiO0FBQUE7QUFHRixjQUFJLFFBQVEsU0FBUyxVQUFVLENBQUMsU0FBUyxZQUFZLE1BQU07QUFLekQsbUJBQU0sYUFBYSxTQUFTO0FBQzVCLGtCQUFNLE9BQU87QUFBQTtBQUFBO0FBSWpCLG9DQUE0QixRQUFPLFdBQVcsVUFBVSxPQUFPLE9BQU87QUFDcEUsY0FBSSxPQUFPO0FBRVgsY0FBSSxDQUFDLFlBQVksQ0FBQyxPQUFPO0FBQ3ZCO0FBQUE7QUFHRixjQUFJLENBQUMsVUFBVTtBQUNiLG9CQUFRO0FBQUEscUJBQ0MsQ0FBQyxPQUFPO0FBQ2pCLG9CQUFRO0FBQUEscUJBQ0MsYUFBYSxPQUFPO0FBQzdCLG9CQUFRLFFBQVE7QUFBQTtBQUdsQixjQUFJLE9BQU87QUFDVCwwQkFBYyxRQUFPLFVBQVUsT0FBTyxVQUFVO0FBQUE7QUFFbEQsY0FBSSxPQUFPO0FBQ1QsMEJBQWMsUUFBTyxVQUFVLE9BQU8sT0FBTztBQUFBO0FBQUE7QUFJakQsa0NBQTBCLFFBQU8sT0FBTztBQUN0QyxjQUFJLFVBQVUsT0FBTTtBQUNwQixjQUFJLFlBQVksUUFBUTtBQUN4QixjQUFJLFVBQVU7QUFFZCxjQUFJLENBQUMsVUFBVSxTQUFTLENBQUMsVUFBVSxPQUFPO0FBQ3hDO0FBQUE7QUFHRixjQUFJLE1BQU0sU0FBUyxhQUFhO0FBQzlCLG9CQUFRLE9BQU8sT0FBTyxRQUFRLFNBQVM7QUFBQSxxQkFDOUIsTUFBTSxTQUFTLFlBQVk7QUFDcEM7QUFBQTtBQUdGLHFCQUFXLFFBQVE7QUFDbkIsa0JBQVEsV0FBVztBQUNuQiw2QkFBbUIsUUFBTyxXQUFXLFVBQVUsT0FBTztBQUFBO0FBR3hELG1DQUEyQixRQUFPLE9BQU87QUFDdkMsY0FBSSxVQUFVLE9BQU07QUFDcEIsY0FBSSxXQUFXLFFBQVEsV0FBVztBQUNsQyxjQUFJLFFBQVEsWUFBWSxPQUFPLE9BQU8sUUFBUSxTQUFTO0FBQ3ZELGNBQUksT0FBTztBQUNULDBCQUFjLFFBQU8sVUFBVSxPQUFPO0FBQUE7QUFBQTtBQUkxQyxZQUFJLFNBQVM7QUFBQSxVQUNYLElBQUk7QUFBQSxVQUVKO0FBQUEsVUFFQSxZQUFZLFNBQVMsUUFBTztBQUMxQixtQkFBTSxlQUFlO0FBQUEsY0FDbkIsVUFBVTtBQUFBO0FBQUE7QUFBQSxVQUlkLGNBQWMsU0FBUyxRQUFPO0FBQzVCLGdCQUFJLFVBQVUsT0FBTTtBQUNwQixvQkFBUSxZQUFZO0FBQ3BCLG9CQUFRLGFBQWE7QUFDckIsb0JBQVEsWUFBWTtBQUNwQixvQkFBUSxVQUFVO0FBQUE7QUFBQSxVQUdwQixvQkFBb0IsU0FBUyxRQUFPLE1BQU0sU0FBUztBQUNqRCxnQkFBSSxlQUFlLEtBQUs7QUFDeEIsZ0JBQUksVUFBVSxPQUFNO0FBQ3BCLGdCQUFJLFNBQVMsUUFBUSxVQUFVLGdCQUFnQjtBQUMvQyxnQkFBSSxVQUFVLE9BQU0saUJBQWlCO0FBQ3JDLGdCQUFJLFVBQVUsT0FBTSxLQUFLLFNBQVM7QUFDbEMsZ0JBQUksU0FBUyxVQUFVLFNBQVM7QUFDaEMsZ0JBQUksV0FBVyxLQUFLLEtBQUssUUFBUTtBQUNqQyxnQkFBSSxNQUFNLE9BQU07QUFDaEIsZ0JBQUksR0FBRyxHQUFHLE1BQU0sTUFBTSxLQUFLLEtBQUssSUFBSTtBQUVwQyxnQkFBSTtBQUVKLGlCQUFLLElBQUksR0FBRyxPQUFPLFNBQVMsUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ2pELG1CQUFLLFNBQVM7QUFDZCxpQkFBRyxlQUFlO0FBRWxCLGtCQUFJLFdBQVcsTUFBTSxPQUFNLGtCQUFrQixNQUFNLENBQUMsR0FBRyxNQUFNO0FBQzNELHFCQUFLLElBQUksR0FBRyxPQUFPLE9BQU8sT0FBTyxRQUFRLElBQUksTUFBTSxFQUFFLEdBQUc7QUFDdEQsd0JBQU0sT0FBTyxPQUFPO0FBQ3BCLHdCQUFNLElBQUk7QUFFViwwQkFBUSxJQUFJLE1BQU0sS0FBSyxLQUFLLElBQUk7QUFDaEMsd0JBQU0sVUFBVTtBQUFBLG9CQUNkLE1BQU07QUFBQSxvQkFDTixNQUFNLE9BQU87QUFBQTtBQUVmLHdCQUFNLFdBQVc7QUFBQSxvQkFDZixRQUFRO0FBQUEsb0JBQ1IsT0FBTztBQUFBLG9CQUNQLFdBQVc7QUFBQSxvQkFDWDtBQUFBLG9CQUNBO0FBQUE7QUFHRix3QkFBTSxPQUFPLE1BQU07QUFDbkIscUJBQUcsYUFBYSxLQUFLO0FBQ3JCLHlCQUFPLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFLbEIsZ0JBQUk7QUFJSixvQkFBUSxNQUFNLFFBQVEsWUFBWSxPQUFPLFdBQVc7QUFBQSxjQUNsRCxRQUFRLFNBQVMsT0FBTyxRQUFRLFFBQVE7QUFDdEMsdUJBQU8sU0FBUyxPQUFPLFVBQVU7QUFDakMsdUJBQU8sT0FBTyxLQUFLLFNBQVMsT0FBTztBQUNuQyx3QkFBUSxZQUFZO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFLMUIsYUFBYSxTQUFTLFFBQU87QUFDM0IsbUJBQU0sYUFBYSxVQUFVLE9BQU8sUUFBUSxPQUFNLGFBQWE7QUFBQTtBQUFBLFVBTWpFLG1CQUFtQixTQUFTLFFBQU87QUFDakMsbUJBQU8sS0FBSyxRQUFPLE9BQU0sYUFBYTtBQUFBO0FBQUEsVUFHeEMsYUFBYSxTQUFTLFFBQU8sTUFBTTtBQUlqQyxnQkFBSSxPQUFNLGFBQWEsV0FBVztBQUNoQyxrQkFBSSxRQUFRLEtBQUs7QUFDakIsc0JBQVEsTUFBTTtBQUFBLHFCQUNUO0FBQUEscUJBQ0E7QUFDSCxtQ0FBaUIsUUFBTztBQUN4QjtBQUFBLHFCQUNHO0FBQ0gsb0NBQWtCLFFBQU87QUFDekI7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUtOLFlBQVksU0FBUyxRQUFPO0FBQzFCLGdCQUFJLFVBQVUsT0FBTTtBQUNwQixnQkFBSSxXQUFXLFFBQVE7QUFDdkIsZ0JBQUksVUFBVSxRQUFRLFdBQVcsT0FBTTtBQUN2QyxnQkFBSSxVQUFVLE1BQU0sVUFBVSxVQUFVO0FBQ3hDLGdCQUFJLEdBQUcsTUFBTSxHQUFHLE1BQU0sUUFBUSxPQUFPO0FBRXJDLGlCQUFLLElBQUksR0FBRyxPQUFPLFFBQVEsUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ2hELHVCQUFTLFFBQVE7QUFDakIsa0JBQUksT0FBTyxJQUFJO0FBQ2IseUJBQVMsT0FBTyxHQUFHLFFBQVEsZ0JBQWdCO0FBQzNDLHFCQUFLLElBQUksR0FBRyxPQUFPLE9BQU8sUUFBUSxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQy9DLDBCQUFRLE9BQU87QUFDZix3QkFBTSxTQUFTLFNBQVUsT0FBTyxPQUFPO0FBQ3ZDLHdCQUFNLE9BQU8sTUFBTTtBQUFBO0FBQUE7QUFBQTtBQUt6QixnQkFBSSxRQUFRLFVBQVUsUUFBUSxRQUFRO0FBQ3BDLHFCQUFPLE9BQU8sUUFBUTtBQUN0QixxQkFBTTtBQUFBO0FBR1IsbUJBQU8sUUFBUTtBQUFBO0FBQUE7QUFJbkIsZUFBTztBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuMENQLDJCQUFPOzs7QUNPUCwwQkFBc0I7QUFNdEIsbUJBQWlCLE1BQU07QUFDbkIsVUFBTSxNQUFNLEtBQUssUUFBUTtBQUN6QixVQUFNLFNBQVMsSUFBSSxpQkFBaUI7QUFDcEMsVUFBTSxVQUFVO0FBQ2hCLFdBQU8sUUFBUSxXQUFTO0FBQ3BCLGNBQVEsTUFBTSxRQUFRLE1BQU07QUFBQTtBQUdoQyxZQUFRLElBQUksZ0NBQTBCO0FBR3RDLFVBQU0sYUFBWSxTQUFTLGNBQWMsMkJBQTJCLGFBQWE7QUFHakYsVUFBTSxnQkFBZ0I7QUFBQSxNQUNsQixRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsUUFDTCxnQkFBZ0I7QUFBQSxRQUNoQixnQkFBZ0I7QUFBQTtBQUFBLE1BRXBCLE1BQU0sS0FBSyxVQUFVO0FBQUEsT0FFcEIsS0FBSyxjQUFZO0FBQ2QsY0FBUSxJQUFJLGdCQUFnQjtBQUM1QixVQUFJLENBQUMsU0FBUyxJQUFJO0FBQ2QsY0FBTSxJQUFJLE1BQU07QUFBQTtBQUVwQixhQUFPLFNBQVM7QUFBQSxPQUVuQixLQUFLLFVBQVE7QUFFVixjQUFRLElBQUksY0FBVyxLQUFLO0FBQzVCLGFBQU8sU0FBUztBQUFBLE9BRW5CLE1BQU0sV0FBUztBQUNaLGNBQVEsTUFBTSxZQUFZO0FBQzFCLFlBQU07QUFBQTtBQUFBO0FBSWxCLHFCQUFtQixNQUFNO0FBQ3JCLFNBQUssUUFBUSxNQUFNO0FBQUE7QUFJdkIsMEJBQXdCLFlBQVk7QUFFaEMsVUFBTSxlQUFlLFdBQVc7QUFDaEMsV0FBTyxDQUFDLE1BQU0saUJBQWlCLGdCQUFnQixLQUFLLGdCQUFnQjtBQUFBO0FBSXhFLHdCQUFzQixZQUFZO0FBRTlCLFdBQU8sV0FBVyxXQUFXLE1BQU0sV0FBVyxVQUFVO0FBQUE7QUFHNUQsNEJBQTBCLE9BQU87QUFFN0IsV0FBTyxNQUFNLFdBQVc7QUFBQTtBQUc1Qix1QkFBcUIsY0FBYztBQUUvQixXQUFPLGlCQUFpQjtBQUFBO0FBUTVCLDhCQUE0QixPQUFPO0FBSS9CLFFBQUksS0FBSyxNQUFNLFNBQVMsUUFBUSxLQUFLLE1BQU0sU0FBUyxNQUFNO0FBQ3RELFlBQU0saUJBQWlCLGFBQWEsUUFBUSxTQUFTO0FBQ3JELFdBQUssUUFBUTtBQUFBO0FBSWpCLFFBQUksQ0FBQyxlQUFlLEtBQUssUUFBUTtBQUM3QixXQUFLLE1BQU0sY0FBYztBQUFBLFdBQ3RCO0FBRUgsWUFBTSxnQkFBaUIsTUFBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLElBQUk7QUFDdkQsY0FBUSxJQUFJO0FBQ1osVUFBSSxnQkFBZ0IsR0FBRztBQUNuQixpQkFBUyxXQUFXLEtBQUssT0FBTyxRQUFRO0FBQ3hDLGFBQUssUUFBUTtBQUFBO0FBRWpCLFdBQUssTUFBTSxjQUFjO0FBQUE7QUFBQTtBQU1qQyw0QkFBMEIsT0FBTztBQUM3QixRQUFJLENBQUMsYUFBYSxLQUFLLFFBQVE7QUFDM0IsV0FBSyxNQUFNLGNBQWM7QUFBQSxXQUN0QjtBQUNILFdBQUssTUFBTSxjQUFjO0FBQUE7QUFBQTtBQU9qQyxxQ0FBbUMsT0FBUSxrQkFBaUI7QUFDeEQsVUFBTSxpQkFBaUIsU0FBUyxjQUFjO0FBQzlDLFVBQU0sbUJBQW1CLGVBQWUsY0FBYztBQUN0RCxVQUFNLG9CQUFvQixNQUFNLE9BQU87QUFFdkMsUUFBSSxDQUFDLGlCQUFpQixvQkFBb0I7QUFDdEMsY0FBUSxJQUFJO0FBQ1osdUJBQWlCLE1BQU0sY0FBYztBQUFBLFdBQ2xDO0FBQ0gsY0FBUSxJQUFJO0FBQ1osdUJBQWlCLE1BQU0sY0FBYztBQUFBO0FBSXpDLHNCQUFrQixtQkFBbUI7QUFBQTtBQVN6QyxrQ0FBZ0MsT0FBTztBQUNuQyxVQUFNLGNBQWMsU0FBUyxjQUFjO0FBQzNDLFVBQU0sbUJBQW1CLFlBQVksY0FBYztBQUNuRCxVQUFNLGVBQWUsTUFBTSxPQUFPO0FBRWxDLFFBQUksQ0FBQyxZQUFZLGVBQWU7QUFDNUIsY0FBUSxJQUFJO0FBQ1osdUJBQWlCLE1BQU0sY0FBYztBQUFBLFdBQ2xDO0FBQ0gsY0FBUSxJQUFJO0FBQ1osdUJBQWlCLE1BQU0sY0FBYztBQUFBO0FBQUE7QUFZN0MsaUNBQStCLFdBQVc7QUFFdEMsVUFBTSxjQUFjLFVBQVUsY0FBYztBQUM1QyxVQUFNLG9CQUFvQixZQUFZLGNBQWM7QUFDcEQsc0JBQWtCLE1BQU0sY0FBYztBQUV0QyxVQUFNLGlCQUFpQixVQUFVLGNBQWM7QUFDL0MsVUFBTSxtQkFBbUIsZUFBZSxjQUFjO0FBQ3RELHFCQUFpQixNQUFNLGNBQWM7QUFFckMsVUFBTSxhQUFhLFVBQVUsY0FBYztBQUUzQyxlQUFXLE1BQU0sY0FBYztBQUFBO0FBSW5DLDBCQUF3QixXQUFXO0FBQy9CLFVBQU0sYUFBYSxVQUFVLGNBQWM7QUFDM0MsVUFBTSxhQUFhLFVBQVUsY0FBYztBQUMzQyxVQUFNLGdCQUFnQixVQUFVLGNBQWM7QUFDOUMsVUFBTSxlQUFlLFVBQVUsY0FBYztBQUc3QyxVQUFNLHFCQUFxQixhQUFhLFdBQVc7QUFHbkQsVUFBTSxvQkFBb0IsWUFBWSxXQUFXO0FBR2pELFVBQU0seUJBQXlCLGlCQUFpQixjQUFjO0FBRzlELFVBQU0sdUJBQXVCLGVBQWUsYUFBYTtBQUd6RCxXQUFPLHNCQUFzQixxQkFBcUIsMEJBQTBCO0FBQUE7QUFHekUsNEJBQTBCLFdBQVc7QUFDeEMsVUFBTSxnQkFBZ0IsVUFBVSxjQUFjO0FBQzlDLFFBQUksaUJBQWlCO0FBQ2pCLGFBQU87QUFBQTtBQUVQLGFBQU87QUFBQTtBQVFSLGtCQUFnQixXQUFXLFlBQVcsUUFBUSxNQUFNLFVBQVUsVUFBVTtBQUUzRSxVQUFNLFNBQVM7QUFBQTtBQUFBLHlEQUVzQztBQUFBLHFFQUNZO0FBQUEscUVBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFJL0MsU0FBUyxJQUFJLGFBQVcsa0JBQWtCLFFBQVEsT0FBTyxRQUFRLGtCQUFrQixLQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBb0IxRyxjQUFVLG1CQUFtQixhQUFhO0FBSzFDLFVBQU0sbUJBQW1CLFVBQVUsY0FBYztBQUVqRCxRQUFJLFdBQVUsa0JBQWtCO0FBQUEsTUFFNUIsWUFBWTtBQUFBLE1BQ1osV0FBVztBQUFBLFFBQ1AsT0FBTztBQUFBLFFBQ1AsV0FBVztBQUFBO0FBQUE7QUFLbkIsVUFBTSxnQkFBZ0IsVUFBVSxjQUFjO0FBQzlDLGtCQUFjLGlCQUFpQixVQUFVO0FBRXpDLHNCQUFrQixJQUFJLFdBQVUsZUFBZTtBQUFBLE1BRTNDLFlBQVk7QUFBQSxNQUNaLFdBQVc7QUFBQSxRQUNQLE9BQU87QUFBQSxRQUNQLFdBQVc7QUFBQTtBQUFBO0FBTW5CLDBCQUFzQjtBQUd0QixVQUFNLGdCQUFnQixTQUFTLGNBQWM7QUFFN0Msa0JBQWMsaUJBQWlCLFVBQVUsU0FBVSxPQUFPO0FBRXRELGdDQUEwQixPQUFPO0FBQUE7QUFLckMsVUFBTSxlQUFlLFVBQVUsY0FBYztBQUM3QyxpQkFBYSxpQkFBaUIsU0FBUztBQUd2QyxVQUFNLGFBQWEsVUFBVSxjQUFjO0FBRTNDLGVBQVcsaUJBQWlCLFNBQVM7QUFHckMsVUFBTSxjQUFjLFVBQVUsY0FBYztBQUM1QyxnQkFBWSxpQkFBaUIsU0FBUyxXQUFZO0FBRTlDLFlBQU0sVUFBVSxlQUFlO0FBRy9CLFVBQUksU0FBUztBQUNULGdCQUFRO0FBQUEsYUFDTDtBQUVILGdCQUFRLElBQUk7QUFBQTtBQUFBO0FBS3BCLFVBQU0sZ0JBQWdCLFVBQVUsY0FBYztBQUM5QyxZQUFRLElBQUk7QUFDWixrQkFBYyxpQkFBaUIsU0FBUyxXQUFZO0FBQ2hELGdCQUFVO0FBQ1Y7QUFBQTtBQUFBO0FBY1IsNkJBQTJCLG1CQUFtQixlQUFlO0FBS3pELFVBQU0sVUFBVSxxQkFDWCxLQUFLLGNBQVk7QUFDZCxjQUFRLElBQUk7QUFDWixVQUFJLENBQUMsU0FBUyxJQUFJO0FBQ2QsY0FBTSxJQUFJLE1BQU07QUFBQTtBQUVwQixhQUFPLFNBQVM7QUFBQSxPQUVuQixLQUFLLFVBQVE7QUFFVixjQUFRLElBQUk7QUFDWixZQUFNLFFBQVEsS0FBSztBQUNuQixvQkFBYztBQUNkLG9CQUFjO0FBQ2QsWUFBTSxRQUFRLFVBQVE7QUFDbEIsc0JBQWMsVUFBVSxFQUFFLE9BQU8sS0FBSyxJQUFJLE1BQU0sS0FBSztBQUFBO0FBR3pELFlBQU0sZ0JBQWdCLEtBQUs7QUFHM0IsWUFBTSxrQkFBa0IsU0FBUyxjQUFjO0FBQy9DLHNCQUFnQixRQUFRLGNBQWM7QUFBQSxPQUV6QyxNQUFNLFdBQVM7QUFDWixZQUFNLGtCQUFrQixTQUFTLGNBQWM7QUFDL0Msc0JBQWdCLFFBQVE7QUFDeEIsb0JBQWM7QUFDZCxvQkFBYztBQUNkLGNBQVEsSUFBSTtBQUNaLGNBQVEsTUFBTSxZQUFZO0FBQUE7QUFBQTtBQU10Qyw2QkFBMkI7QUFDdkIsUUFBSSxhQUFhLFNBQVMsZUFBZTtBQUN6QyxRQUFJLGFBQWEsU0FBUyxjQUFjO0FBQ3hDLGVBQVcsVUFBVSxPQUFPO0FBQzVCLGVBQVcsTUFBTSxTQUFTO0FBQUE7OztBRHhYOUIsMkJBQXNCOzs7QUVSdEI7QUFFQSxFQUFDLFlBQVc7QUFDVixRQUFJLGdCQUFnQjtBQUVwQixnQ0FBNEI7QUFDMUIsVUFBSSxPQUFPLE9BQU8sZ0JBQWdCO0FBQVksZUFBTyxPQUFPO0FBRTVELDRCQUFxQixPQUFPLFFBQVE7QUFDbEMsaUJBQVMsVUFBVSxFQUFDLFNBQVMsT0FBTyxZQUFZLE9BQU8sUUFBUTtBQUMvRCxZQUFJLE1BQU0sU0FBUyxZQUFZO0FBQy9CLFlBQUksZ0JBQWdCLE9BQU8sT0FBTyxTQUFTLE9BQU8sWUFBWSxPQUFPO0FBQ3JFLGVBQU87QUFBQTtBQUVULG1CQUFZLFlBQVksT0FBTyxNQUFNO0FBQ3JDLGFBQU87QUFBQTtBQUdULDhCQUEwQixNQUFNLE9BQU87QUFDckMsVUFBSSxRQUFRLFNBQVMsY0FBYztBQUNuQyxZQUFNLE9BQU87QUFDYixZQUFNLE9BQU87QUFDYixZQUFNLFFBQVE7QUFDZCxhQUFPO0FBQUE7QUFHVCx5QkFBcUIsU0FBUyxtQkFBbUI7QUFDL0MsVUFBSSxLQUFLLFFBQVEsYUFBYSxZQUMxQixTQUFTLGlCQUFpQixXQUFXLFFBQVEsYUFBYSxpQkFDMUQsT0FBTyxpQkFBaUIsZUFBZSxRQUFRLGFBQWEsZUFDNUQsT0FBTyxTQUFTLGNBQWMsU0FDOUIsU0FBUyxTQUFTLGNBQWMsVUFDaEMsU0FBUyxRQUFRLGFBQWE7QUFFbEMsV0FBSyxTQUFVLFFBQVEsYUFBYSxtQkFBbUIsUUFBUyxRQUFRO0FBQ3hFLFdBQUssU0FBUztBQUNkLFdBQUssTUFBTSxVQUFVO0FBRXJCLFVBQUk7QUFBUSxhQUFLLFNBQVM7QUFBQSxlQUNqQjtBQUFtQixhQUFLLFNBQVM7QUFFMUMsV0FBSyxZQUFZO0FBQ2pCLFdBQUssWUFBWTtBQUNqQixlQUFTLEtBQUssWUFBWTtBQUkxQixhQUFPLE9BQU87QUFDZCxXQUFLLFlBQVk7QUFDakIsYUFBTztBQUFBO0FBR1QsV0FBTyxpQkFBaUIsU0FBUyxTQUFTLEdBQUc7QUFDM0MsVUFBSSxVQUFVLEVBQUU7QUFDaEIsVUFBSSxFQUFFO0FBQWtCO0FBRXhCLGFBQU8sV0FBVyxRQUFRLGNBQWM7QUFDdEMsWUFBSSxtQkFBbUIsSUFBSSxjQUFjLHNCQUFzQjtBQUFBLFVBQzdELFdBQVc7QUFBQSxVQUFNLGNBQWM7QUFBQTtBQUdqQyxZQUFJLENBQUMsUUFBUSxjQUFjLG1CQUFtQjtBQUM1QyxZQUFFO0FBQ0YsWUFBRTtBQUNGLGlCQUFPO0FBQUE7QUFHVCxZQUFJLFFBQVEsYUFBYSxnQkFBZ0I7QUFDdkMsc0JBQVksU0FBUyxFQUFFLFdBQVcsRUFBRTtBQUNwQyxZQUFFO0FBQ0YsaUJBQU87QUFBQSxlQUNGO0FBQ0wsb0JBQVUsUUFBUTtBQUFBO0FBQUE7QUFBQSxPQUdyQjtBQUVILFdBQU8saUJBQWlCLHNCQUFzQixTQUFVLEdBQUc7QUFDekQsVUFBSSxVQUFVLEVBQUUsT0FBTyxhQUFhO0FBQ3BDLFVBQUcsV0FBVyxDQUFDLE9BQU8sUUFBUSxVQUFVO0FBQ3RDLFVBQUU7QUFBQTtBQUFBLE9BRUg7QUFBQTs7O0FDakZFLE1BQUksVUFBVSxDQUFDLFVBQVU7QUFDOUIsUUFBRyxPQUFPLFVBQVUsWUFBVztBQUM3QixhQUFPO1dBQ0Y7QUFDTCxVQUFJLFlBQVUsV0FBVztBQUFFLGVBQU87O0FBQ2xDLGFBQU87OztBQ05KLE1BQU0sYUFBYSxPQUFPLFNBQVMsY0FBYyxPQUFPO0FBQ3hELE1BQU0sWUFBWSxPQUFPLFdBQVcsY0FBYyxTQUFTO0FBQzNELE1BQU0sU0FBUyxjQUFjLGFBQWE7QUFDMUMsTUFBTSxjQUFjO0FBQ3BCLE1BQU0sZ0JBQWdCLEVBQUMsWUFBWSxHQUFHLE1BQU0sR0FBRyxTQUFTLEdBQUcsUUFBUTtBQUNuRSxNQUFNLGtCQUFrQjtBQUN4QixNQUFNLGtCQUFrQjtBQUN4QixNQUFNLGlCQUFpQjtJQUM1QixRQUFRO0lBQ1IsU0FBUztJQUNULFFBQVE7SUFDUixTQUFTO0lBQ1QsU0FBUzs7QUFFSixNQUFNLGlCQUFpQjtJQUM1QixPQUFPO0lBQ1AsT0FBTztJQUNQLE1BQU07SUFDTixPQUFPO0lBQ1AsT0FBTzs7QUFHRixNQUFNLGFBQWE7SUFDeEIsVUFBVTtJQUNWLFdBQVc7O0FBRU4sTUFBTSxhQUFhO0lBQ3hCLFVBQVU7O0FDcEJaLE1BQXFCLE9BQXJCLE1BQTBCO0lBQ3hCLFlBQVksU0FBUyxPQUFPLFNBQVMsU0FBUTtBQUMzQyxXQUFLLFVBQVU7QUFDZixXQUFLLFFBQVE7QUFDYixXQUFLLFVBQVUsV0FBVyxXQUFXO0FBQUUsZUFBTzs7QUFDOUMsV0FBSyxlQUFlO0FBQ3BCLFdBQUssVUFBVTtBQUNmLFdBQUssZUFBZTtBQUNwQixXQUFLLFdBQVc7QUFDaEIsV0FBSyxPQUFPOztJQU9kLE9BQU8sU0FBUTtBQUNiLFdBQUssVUFBVTtBQUNmLFdBQUs7QUFDTCxXQUFLOztJQU1QLE9BQU07QUFDSixVQUFHLEtBQUssWUFBWSxZQUFXO0FBQUU7O0FBQ2pDLFdBQUs7QUFDTCxXQUFLLE9BQU87QUFDWixXQUFLLFFBQVEsT0FBTyxLQUFLO1FBQ3ZCLE9BQU8sS0FBSyxRQUFRO1FBQ3BCLE9BQU8sS0FBSztRQUNaLFNBQVMsS0FBSztRQUNkLEtBQUssS0FBSztRQUNWLFVBQVUsS0FBSyxRQUFROzs7SUFTM0IsUUFBUSxRQUFRLFVBQVM7QUFDdkIsVUFBRyxLQUFLLFlBQVksU0FBUTtBQUMxQixpQkFBUyxLQUFLLGFBQWE7O0FBRzdCLFdBQUssU0FBUyxLQUFLLEVBQUMsUUFBUTtBQUM1QixhQUFPOztJQU1ULFFBQU87QUFDTCxXQUFLO0FBQ0wsV0FBSyxNQUFNO0FBQ1gsV0FBSyxXQUFXO0FBQ2hCLFdBQUssZUFBZTtBQUNwQixXQUFLLE9BQU87O0lBTWQsYUFBYSxFQUFDLFFBQVEsVUFBVSxRQUFNO0FBQ3BDLFdBQUssU0FBUyxPQUFPLENBQUEsTUFBSyxFQUFFLFdBQVcsUUFDcEMsUUFBUSxDQUFBLE1BQUssRUFBRSxTQUFTOztJQU03QixpQkFBZ0I7QUFDZCxVQUFHLENBQUMsS0FBSyxVQUFTO0FBQUU7O0FBQ3BCLFdBQUssUUFBUSxJQUFJLEtBQUs7O0lBTXhCLGdCQUFlO0FBQ2IsbUJBQWEsS0FBSztBQUNsQixXQUFLLGVBQWU7O0lBTXRCLGVBQWM7QUFDWixVQUFHLEtBQUssY0FBYTtBQUFFLGFBQUs7O0FBQzVCLFdBQUssTUFBTSxLQUFLLFFBQVEsT0FBTztBQUMvQixXQUFLLFdBQVcsS0FBSyxRQUFRLGVBQWUsS0FBSztBQUVqRCxXQUFLLFFBQVEsR0FBRyxLQUFLLFVBQVUsQ0FBQSxZQUFXO0FBQ3hDLGFBQUs7QUFDTCxhQUFLO0FBQ0wsYUFBSyxlQUFlO0FBQ3BCLGFBQUssYUFBYTs7QUFHcEIsV0FBSyxlQUFlLFdBQVcsTUFBTTtBQUNuQyxhQUFLLFFBQVEsV0FBVztTQUN2QixLQUFLOztJQU1WLFlBQVksUUFBTztBQUNqQixhQUFPLEtBQUssZ0JBQWdCLEtBQUssYUFBYSxXQUFXOztJQU0zRCxRQUFRLFFBQVEsVUFBUztBQUN2QixXQUFLLFFBQVEsUUFBUSxLQUFLLFVBQVUsRUFBQyxRQUFROzs7QUM1R2pELE1BQXFCLFFBQXJCLE1BQTJCO0lBQ3pCLFlBQVksVUFBVSxXQUFVO0FBQzlCLFdBQUssV0FBVztBQUNoQixXQUFLLFlBQVk7QUFDakIsV0FBSyxRQUFRO0FBQ2IsV0FBSyxRQUFROztJQUdmLFFBQU87QUFDTCxXQUFLLFFBQVE7QUFDYixtQkFBYSxLQUFLOztJQU1wQixrQkFBaUI7QUFDZixtQkFBYSxLQUFLO0FBRWxCLFdBQUssUUFBUSxXQUFXLE1BQU07QUFDNUIsYUFBSyxRQUFRLEtBQUssUUFBUTtBQUMxQixhQUFLO1NBQ0osS0FBSyxVQUFVLEtBQUssUUFBUTs7O0FDeEJuQyxNQUFxQixVQUFyQixNQUE2QjtJQUMzQixZQUFZLE9BQU8sUUFBUSxRQUFPO0FBQ2hDLFdBQUssUUFBUSxlQUFlO0FBQzVCLFdBQUssUUFBUTtBQUNiLFdBQUssU0FBUyxRQUFRLFVBQVU7QUFDaEMsV0FBSyxTQUFTO0FBQ2QsV0FBSyxXQUFXO0FBQ2hCLFdBQUssYUFBYTtBQUNsQixXQUFLLFVBQVUsS0FBSyxPQUFPO0FBQzNCLFdBQUssYUFBYTtBQUNsQixXQUFLLFdBQVcsSUFBSSxLQUFLLE1BQU0sZUFBZSxNQUFNLEtBQUssUUFBUSxLQUFLO0FBQ3RFLFdBQUssYUFBYTtBQUNsQixXQUFLLGtCQUFrQjtBQUV2QixXQUFLLGNBQWMsSUFBSSxNQUFNLE1BQU07QUFDakMsWUFBRyxLQUFLLE9BQU8sZUFBYztBQUFFLGVBQUs7O1NBQ25DLEtBQUssT0FBTztBQUNmLFdBQUssZ0JBQWdCLEtBQUssS0FBSyxPQUFPLFFBQVEsTUFBTSxLQUFLLFlBQVk7QUFDckUsV0FBSyxnQkFBZ0IsS0FBSyxLQUFLLE9BQU8sT0FBTyxNQUFNO0FBQ2pELGFBQUssWUFBWTtBQUNqQixZQUFHLEtBQUssYUFBWTtBQUFFLGVBQUs7OztBQUc3QixXQUFLLFNBQVMsUUFBUSxNQUFNLE1BQU07QUFDaEMsYUFBSyxRQUFRLGVBQWU7QUFDNUIsYUFBSyxZQUFZO0FBQ2pCLGFBQUssV0FBVyxRQUFRLENBQUEsY0FBYSxVQUFVO0FBQy9DLGFBQUssYUFBYTs7QUFFcEIsV0FBSyxTQUFTLFFBQVEsU0FBUyxNQUFNO0FBQ25DLGFBQUssUUFBUSxlQUFlO0FBQzVCLFlBQUcsS0FBSyxPQUFPLGVBQWM7QUFBRSxlQUFLLFlBQVk7OztBQUVsRCxXQUFLLFFBQVEsTUFBTTtBQUNqQixhQUFLLFlBQVk7QUFDakIsWUFBRyxLQUFLLE9BQU87QUFBYSxlQUFLLE9BQU8sSUFBSSxXQUFXLFNBQVMsS0FBSyxTQUFTLEtBQUs7QUFDbkYsYUFBSyxRQUFRLGVBQWU7QUFDNUIsYUFBSyxPQUFPLE9BQU87O0FBRXJCLFdBQUssUUFBUSxDQUFBLFdBQVU7QUFDckIsWUFBRyxLQUFLLE9BQU87QUFBYSxlQUFLLE9BQU8sSUFBSSxXQUFXLFNBQVMsS0FBSyxTQUFTO0FBQzlFLFlBQUcsS0FBSyxhQUFZO0FBQUUsZUFBSyxTQUFTOztBQUNwQyxhQUFLLFFBQVEsZUFBZTtBQUM1QixZQUFHLEtBQUssT0FBTyxlQUFjO0FBQUUsZUFBSyxZQUFZOzs7QUFFbEQsV0FBSyxTQUFTLFFBQVEsV0FBVyxNQUFNO0FBQ3JDLFlBQUcsS0FBSyxPQUFPO0FBQWEsZUFBSyxPQUFPLElBQUksV0FBVyxXQUFXLEtBQUssVUFBVSxLQUFLLGNBQWMsS0FBSyxTQUFTO0FBQ2xILFlBQUksWUFBWSxJQUFJLEtBQUssTUFBTSxlQUFlLE9BQU8sUUFBUSxLQUFLLEtBQUs7QUFDdkUsa0JBQVU7QUFDVixhQUFLLFFBQVEsZUFBZTtBQUM1QixhQUFLLFNBQVM7QUFDZCxZQUFHLEtBQUssT0FBTyxlQUFjO0FBQUUsZUFBSyxZQUFZOzs7QUFFbEQsV0FBSyxHQUFHLGVBQWUsT0FBTyxDQUFDLFNBQVMsUUFBUTtBQUM5QyxhQUFLLFFBQVEsS0FBSyxlQUFlLE1BQU07OztJQVMzQyxLQUFLLFVBQVUsS0FBSyxTQUFRO0FBQzFCLFVBQUcsS0FBSyxZQUFXO0FBQ2pCLGNBQU0sSUFBSSxNQUFNO2FBQ1g7QUFDTCxhQUFLLFVBQVU7QUFDZixhQUFLLGFBQWE7QUFDbEIsYUFBSztBQUNMLGVBQU8sS0FBSzs7O0lBUWhCLFFBQVEsVUFBUztBQUNmLFdBQUssR0FBRyxlQUFlLE9BQU87O0lBT2hDLFFBQVEsVUFBUztBQUNmLGFBQU8sS0FBSyxHQUFHLGVBQWUsT0FBTyxDQUFBLFdBQVUsU0FBUzs7SUFvQjFELEdBQUcsT0FBTyxVQUFTO0FBQ2pCLFVBQUksTUFBTSxLQUFLO0FBQ2YsV0FBSyxTQUFTLEtBQUssRUFBQyxPQUFPLEtBQUs7QUFDaEMsYUFBTzs7SUFxQlQsSUFBSSxPQUFPLEtBQUk7QUFDYixXQUFLLFdBQVcsS0FBSyxTQUFTLE9BQU8sQ0FBQyxTQUFTO0FBQzdDLGVBQU8sQ0FBRSxNQUFLLFVBQVUsU0FBVSxRQUFPLFFBQVEsZUFBZSxRQUFRLEtBQUs7OztJQU9qRixVQUFTO0FBQUUsYUFBTyxLQUFLLE9BQU8saUJBQWlCLEtBQUs7O0lBa0JwRCxLQUFLLE9BQU8sU0FBUyxVQUFVLEtBQUssU0FBUTtBQUMxQyxnQkFBVSxXQUFXO0FBQ3JCLFVBQUcsQ0FBQyxLQUFLLFlBQVc7QUFDbEIsY0FBTSxJQUFJLE1BQU0sa0JBQWtCLGNBQWMsS0FBSzs7QUFFdkQsVUFBSSxZQUFZLElBQUksS0FBSyxNQUFNLE9BQU8sV0FBVztBQUFFLGVBQU87U0FBVztBQUNyRSxVQUFHLEtBQUssV0FBVTtBQUNoQixrQkFBVTthQUNMO0FBQ0wsa0JBQVU7QUFDVixhQUFLLFdBQVcsS0FBSzs7QUFHdkIsYUFBTzs7SUFtQlQsTUFBTSxVQUFVLEtBQUssU0FBUTtBQUMzQixXQUFLLFlBQVk7QUFDakIsV0FBSyxTQUFTO0FBRWQsV0FBSyxRQUFRLGVBQWU7QUFDNUIsVUFBSSxVQUFVLE1BQU07QUFDbEIsWUFBRyxLQUFLLE9BQU87QUFBYSxlQUFLLE9BQU8sSUFBSSxXQUFXLFNBQVMsS0FBSztBQUNyRSxhQUFLLFFBQVEsZUFBZSxPQUFPOztBQUVyQyxVQUFJLFlBQVksSUFBSSxLQUFLLE1BQU0sZUFBZSxPQUFPLFFBQVEsS0FBSztBQUNsRSxnQkFBVSxRQUFRLE1BQU0sTUFBTSxXQUMzQixRQUFRLFdBQVcsTUFBTTtBQUM1QixnQkFBVTtBQUNWLFVBQUcsQ0FBQyxLQUFLLFdBQVU7QUFBRSxrQkFBVSxRQUFRLE1BQU07O0FBRTdDLGFBQU87O0lBZVQsVUFBVSxRQUFRLFNBQVMsTUFBSztBQUFFLGFBQU87O0lBS3pDLFNBQVMsT0FBTyxPQUFPLFNBQVMsU0FBUTtBQUN0QyxVQUFHLEtBQUssVUFBVSxPQUFNO0FBQUUsZUFBTzs7QUFFakMsVUFBRyxXQUFXLFlBQVksS0FBSyxXQUFVO0FBQ3ZDLFlBQUcsS0FBSyxPQUFPO0FBQWEsZUFBSyxPQUFPLElBQUksV0FBVyw2QkFBNkIsRUFBQyxPQUFPLE9BQU8sU0FBUztBQUM1RyxlQUFPO2FBQ0Y7QUFDTCxlQUFPOzs7SUFPWCxVQUFTO0FBQUUsYUFBTyxLQUFLLFNBQVM7O0lBS2hDLE9BQU8sVUFBVSxLQUFLLFNBQVE7QUFDNUIsVUFBRyxLQUFLLGFBQVk7QUFBRTs7QUFDdEIsV0FBSyxPQUFPLGVBQWUsS0FBSztBQUNoQyxXQUFLLFFBQVEsZUFBZTtBQUM1QixXQUFLLFNBQVMsT0FBTzs7SUFNdkIsUUFBUSxPQUFPLFNBQVMsS0FBSyxTQUFRO0FBQ25DLFVBQUksaUJBQWlCLEtBQUssVUFBVSxPQUFPLFNBQVMsS0FBSztBQUN6RCxVQUFHLFdBQVcsQ0FBQyxnQkFBZTtBQUFFLGNBQU0sSUFBSSxNQUFNOztBQUVoRCxVQUFJLGdCQUFnQixLQUFLLFNBQVMsT0FBTyxDQUFBLFNBQVEsS0FBSyxVQUFVO0FBRWhFLGVBQVEsSUFBSSxHQUFHLElBQUksY0FBYyxRQUFRLEtBQUk7QUFDM0MsWUFBSSxPQUFPLGNBQWM7QUFDekIsYUFBSyxTQUFTLGdCQUFnQixLQUFLLFdBQVcsS0FBSzs7O0lBT3ZELGVBQWUsS0FBSTtBQUFFLGFBQU8sY0FBYzs7SUFLMUMsV0FBVTtBQUFFLGFBQU8sS0FBSyxVQUFVLGVBQWU7O0lBS2pELFlBQVc7QUFBRSxhQUFPLEtBQUssVUFBVSxlQUFlOztJQUtsRCxXQUFVO0FBQUUsYUFBTyxLQUFLLFVBQVUsZUFBZTs7SUFLakQsWUFBVztBQUFFLGFBQU8sS0FBSyxVQUFVLGVBQWU7O0lBS2xELFlBQVc7QUFBRSxhQUFPLEtBQUssVUFBVSxlQUFlOzs7QUNoVHBELE1BQXFCLE9BQXJCLE1BQTBCO1dBRWpCLFFBQVEsUUFBUSxVQUFVLFFBQVEsTUFBTSxTQUFTLFdBQVcsVUFBUztBQUMxRSxVQUFHLE9BQU8sZ0JBQWU7QUFDdkIsWUFBSSxNQUFNLElBQUksT0FBTztBQUNyQixlQUFPLEtBQUssZUFBZSxLQUFLLFFBQVEsVUFBVSxNQUFNLFNBQVMsV0FBVzthQUN2RTtBQUNMLFlBQUksTUFBTSxJQUFJLE9BQU87QUFDckIsZUFBTyxLQUFLLFdBQVcsS0FBSyxRQUFRLFVBQVUsUUFBUSxNQUFNLFNBQVMsV0FBVzs7O1dBSTdFLGVBQWUsS0FBSyxRQUFRLFVBQVUsTUFBTSxTQUFTLFdBQVcsVUFBUztBQUM5RSxVQUFJLFVBQVU7QUFDZCxVQUFJLEtBQUssUUFBUTtBQUNqQixVQUFJLFNBQVMsTUFBTTtBQUNqQixZQUFJLFdBQVcsS0FBSyxVQUFVLElBQUk7QUFDbEMsb0JBQVksU0FBUzs7QUFFdkIsVUFBRyxXQUFVO0FBQUUsWUFBSSxZQUFZOztBQUcvQixVQUFJLGFBQWEsTUFBTTs7QUFFdkIsVUFBSSxLQUFLO0FBQ1QsYUFBTzs7V0FHRixXQUFXLEtBQUssUUFBUSxVQUFVLFFBQVEsTUFBTSxTQUFTLFdBQVcsVUFBUztBQUNsRixVQUFJLEtBQUssUUFBUSxVQUFVO0FBQzNCLFVBQUksVUFBVTtBQUNkLFVBQUksaUJBQWlCLGdCQUFnQjtBQUNyQyxVQUFJLFVBQVUsTUFBTSxZQUFZLFNBQVM7QUFDekMsVUFBSSxxQkFBcUIsTUFBTTtBQUM3QixZQUFHLElBQUksZUFBZSxXQUFXLFlBQVksVUFBUztBQUNwRCxjQUFJLFdBQVcsS0FBSyxVQUFVLElBQUk7QUFDbEMsbUJBQVM7OztBQUdiLFVBQUcsV0FBVTtBQUFFLFlBQUksWUFBWTs7QUFFL0IsVUFBSSxLQUFLO0FBQ1QsYUFBTzs7V0FHRixVQUFVLE1BQUs7QUFDcEIsVUFBRyxDQUFDLFFBQVEsU0FBUyxJQUFHO0FBQUUsZUFBTzs7QUFFakMsVUFBSTtBQUNGLGVBQU8sS0FBSyxNQUFNO2VBQ1gsR0FBVDtBQUNFLG1CQUFXLFFBQVEsSUFBSSxpQ0FBaUM7QUFDeEQsZUFBTzs7O1dBSUosVUFBVSxLQUFLLFdBQVU7QUFDOUIsVUFBSSxXQUFXO0FBQ2YsZUFBUSxPQUFPLEtBQUk7QUFDakIsWUFBRyxDQUFDLE9BQU8sVUFBVSxlQUFlLEtBQUssS0FBSyxNQUFLO0FBQUU7O0FBQ3JELFlBQUksV0FBVyxZQUFZLEdBQUcsYUFBYSxTQUFTO0FBQ3BELFlBQUksV0FBVyxJQUFJO0FBQ25CLFlBQUcsT0FBTyxhQUFhLFVBQVM7QUFDOUIsbUJBQVMsS0FBSyxLQUFLLFVBQVUsVUFBVTtlQUNsQztBQUNMLG1CQUFTLEtBQUssbUJBQW1CLFlBQVksTUFBTSxtQkFBbUI7OztBQUcxRSxhQUFPLFNBQVMsS0FBSzs7V0FHaEIsYUFBYSxLQUFLLFFBQU87QUFDOUIsVUFBRyxPQUFPLEtBQUssUUFBUSxXQUFXLEdBQUU7QUFBRSxlQUFPOztBQUU3QyxVQUFJLFNBQVMsSUFBSSxNQUFNLFFBQVEsTUFBTTtBQUNyQyxhQUFPLEdBQUcsTUFBTSxTQUFTLEtBQUssVUFBVTs7O0FDekU1QyxNQUFxQixXQUFyQixNQUE4QjtJQUU1QixZQUFZLFVBQVM7QUFDbkIsV0FBSyxXQUFXO0FBQ2hCLFdBQUssUUFBUTtBQUNiLFdBQUssZ0JBQWdCO0FBQ3JCLFdBQUssT0FBTyxvQkFBSTtBQUNoQixXQUFLLFNBQVMsV0FBVzs7QUFDekIsV0FBSyxVQUFVLFdBQVc7O0FBQzFCLFdBQUssWUFBWSxXQUFXOztBQUM1QixXQUFLLFVBQVUsV0FBVzs7QUFDMUIsV0FBSyxlQUFlLEtBQUssa0JBQWtCO0FBQzNDLFdBQUssYUFBYSxjQUFjO0FBQ2hDLFdBQUs7O0lBR1Asa0JBQWtCLFVBQVM7QUFDekIsYUFBUSxTQUNMLFFBQVEsU0FBUyxXQUNqQixRQUFRLFVBQVUsWUFDbEIsUUFBUSxJQUFJLE9BQU8sVUFBVyxXQUFXLFlBQVksUUFBUSxXQUFXOztJQUc3RSxjQUFhO0FBQ1gsYUFBTyxLQUFLLGFBQWEsS0FBSyxjQUFjLEVBQUMsT0FBTyxLQUFLOztJQUczRCxjQUFjLE1BQU0sUUFBUSxVQUFTO0FBQ25DLFdBQUssTUFBTSxNQUFNLFFBQVE7QUFDekIsV0FBSyxhQUFhLGNBQWM7O0lBR2xDLFlBQVc7QUFDVCxXQUFLLFFBQVE7QUFDYixXQUFLLGNBQWMsTUFBTSxXQUFXOztJQUd0QyxXQUFVO0FBQUUsYUFBTyxLQUFLLGVBQWUsY0FBYyxRQUFRLEtBQUssZUFBZSxjQUFjOztJQUUvRixPQUFNO0FBQ0osV0FBSyxLQUFLLE9BQU8sTUFBTSxNQUFNLEtBQUssYUFBYSxDQUFBLFNBQVE7QUFDckQsWUFBRyxNQUFLO0FBQ04sY0FBSSxFQUFDLFFBQVEsT0FBTyxhQUFZO0FBQ2hDLGVBQUssUUFBUTtlQUNSO0FBQ0wsbUJBQVM7O0FBR1gsZ0JBQU87ZUFDQTtBQUNILHFCQUFTLFFBQVEsQ0FBQSxRQUFPO0FBbUJ0Qix5QkFBVyxNQUFNLEtBQUssVUFBVSxFQUFDLE1BQU0sUUFBTzs7QUFFaEQsaUJBQUs7QUFDTDtlQUNHO0FBQ0gsaUJBQUs7QUFDTDtlQUNHO0FBQ0gsaUJBQUssYUFBYSxjQUFjO0FBQ2hDLGlCQUFLLE9BQU87QUFDWixpQkFBSztBQUNMO2VBQ0c7QUFDSCxpQkFBSyxRQUFRO0FBQ2IsaUJBQUssTUFBTSxNQUFNLGFBQWE7QUFDOUI7ZUFDRztlQUNBO0FBQ0gsaUJBQUssUUFBUTtBQUNiLGlCQUFLLGNBQWMsTUFBTSx5QkFBeUI7QUFDbEQ7O0FBQ08sa0JBQU0sSUFBSSxNQUFNLHlCQUF5Qjs7OztJQUt4RCxLQUFLLE1BQUs7QUFDUixXQUFLLEtBQUssUUFBUSxNQUFNLE1BQU0sS0FBSyxRQUFRLFlBQVksQ0FBQSxTQUFRO0FBQzdELFlBQUcsQ0FBQyxRQUFRLEtBQUssV0FBVyxLQUFJO0FBQzlCLGVBQUssUUFBUSxRQUFRLEtBQUs7QUFDMUIsZUFBSyxjQUFjLE1BQU0seUJBQXlCOzs7O0lBS3hELE1BQU0sTUFBTSxRQUFRLFVBQVM7QUFDM0IsZUFBUSxPQUFPLEtBQUssTUFBSztBQUFFLFlBQUk7O0FBQy9CLFdBQUssYUFBYSxjQUFjO0FBQ2hDLFVBQUksT0FBTyxPQUFPLE9BQU8sRUFBQyxNQUFNLEtBQU0sUUFBUSxRQUFXLFVBQVUsUUFBTyxFQUFDLE1BQU0sUUFBUTtBQUN6RixVQUFHLE9BQU8sZUFBZ0IsYUFBWTtBQUNwQyxhQUFLLFFBQVEsSUFBSSxXQUFXLFNBQVM7YUFDaEM7QUFDTCxhQUFLLFFBQVE7OztJQUlqQixLQUFLLFFBQVEsTUFBTSxpQkFBaUIsVUFBUztBQUMzQyxVQUFJO0FBQ0osVUFBSSxZQUFZLE1BQU07QUFDcEIsYUFBSyxLQUFLLE9BQU87QUFDakI7O0FBRUYsWUFBTSxLQUFLLFFBQVEsUUFBUSxLQUFLLGVBQWUsb0JBQW9CLE1BQU0sS0FBSyxTQUFTLFdBQVcsQ0FBQSxTQUFRO0FBQ3hHLGFBQUssS0FBSyxPQUFPO0FBQ2pCLFlBQUcsS0FBSyxZQUFXO0FBQUUsbUJBQVM7OztBQUVoQyxXQUFLLEtBQUssSUFBSTs7O0FFL0hsQixNQUFPLHFCQUFRO0lBQ2IsZUFBZTtJQUNmLGFBQWE7SUFDYixPQUFPLEVBQUMsTUFBTSxHQUFHLE9BQU8sR0FBRyxXQUFXO0lBRXRDLE9BQU8sS0FBSyxVQUFTO0FBQ25CLFVBQUcsSUFBSSxRQUFRLGdCQUFnQixhQUFZO0FBQ3pDLGVBQU8sU0FBUyxLQUFLLGFBQWE7YUFDN0I7QUFDTCxZQUFJLFVBQVUsQ0FBQyxJQUFJLFVBQVUsSUFBSSxLQUFLLElBQUksT0FBTyxJQUFJLE9BQU8sSUFBSTtBQUNoRSxlQUFPLFNBQVMsS0FBSyxVQUFVOzs7SUFJbkMsT0FBTyxZQUFZLFVBQVM7QUFDMUIsVUFBRyxXQUFXLGdCQUFnQixhQUFZO0FBQ3hDLGVBQU8sU0FBUyxLQUFLLGFBQWE7YUFDN0I7QUFDTCxZQUFJLENBQUMsVUFBVSxLQUFLLE9BQU8sT0FBTyxXQUFXLEtBQUssTUFBTTtBQUN4RCxlQUFPLFNBQVMsRUFBQyxVQUFVLEtBQUssT0FBTyxPQUFPOzs7SUFNbEQsYUFBYSxTQUFRO0FBQ25CLFVBQUksRUFBQyxVQUFVLEtBQUssT0FBTyxPQUFPLFlBQVc7QUFDN0MsVUFBSSxhQUFhLEtBQUssY0FBYyxTQUFTLFNBQVMsSUFBSSxTQUFTLE1BQU0sU0FBUyxNQUFNO0FBQ3hGLFVBQUksU0FBUyxJQUFJLFlBQVksS0FBSyxnQkFBZ0I7QUFDbEQsVUFBSSxPQUFPLElBQUksU0FBUztBQUN4QixVQUFJLFNBQVM7QUFFYixXQUFLLFNBQVMsVUFBVSxLQUFLLE1BQU07QUFDbkMsV0FBSyxTQUFTLFVBQVUsU0FBUztBQUNqQyxXQUFLLFNBQVMsVUFBVSxJQUFJO0FBQzVCLFdBQUssU0FBUyxVQUFVLE1BQU07QUFDOUIsV0FBSyxTQUFTLFVBQVUsTUFBTTtBQUM5QixZQUFNLEtBQUssVUFBVSxDQUFBLFNBQVEsS0FBSyxTQUFTLFVBQVUsS0FBSyxXQUFXO0FBQ3JFLFlBQU0sS0FBSyxLQUFLLENBQUEsU0FBUSxLQUFLLFNBQVMsVUFBVSxLQUFLLFdBQVc7QUFDaEUsWUFBTSxLQUFLLE9BQU8sQ0FBQSxTQUFRLEtBQUssU0FBUyxVQUFVLEtBQUssV0FBVztBQUNsRSxZQUFNLEtBQUssT0FBTyxDQUFBLFNBQVEsS0FBSyxTQUFTLFVBQVUsS0FBSyxXQUFXO0FBRWxFLFVBQUksV0FBVyxJQUFJLFdBQVcsT0FBTyxhQUFhLFFBQVE7QUFDMUQsZUFBUyxJQUFJLElBQUksV0FBVyxTQUFTO0FBQ3JDLGVBQVMsSUFBSSxJQUFJLFdBQVcsVUFBVSxPQUFPO0FBRTdDLGFBQU8sU0FBUzs7SUFHbEIsYUFBYSxRQUFPO0FBQ2xCLFVBQUksT0FBTyxJQUFJLFNBQVM7QUFDeEIsVUFBSSxPQUFPLEtBQUssU0FBUztBQUN6QixVQUFJLFVBQVUsSUFBSTtBQUNsQixjQUFPO2FBQ0EsS0FBSyxNQUFNO0FBQU0saUJBQU8sS0FBSyxXQUFXLFFBQVEsTUFBTTthQUN0RCxLQUFLLE1BQU07QUFBTyxpQkFBTyxLQUFLLFlBQVksUUFBUSxNQUFNO2FBQ3hELEtBQUssTUFBTTtBQUFXLGlCQUFPLEtBQUssZ0JBQWdCLFFBQVEsTUFBTTs7O0lBSXpFLFdBQVcsUUFBUSxNQUFNLFNBQVE7QUFDL0IsVUFBSSxjQUFjLEtBQUssU0FBUztBQUNoQyxVQUFJLFlBQVksS0FBSyxTQUFTO0FBQzlCLFVBQUksWUFBWSxLQUFLLFNBQVM7QUFDOUIsVUFBSSxTQUFTLEtBQUssZ0JBQWdCLEtBQUssY0FBYztBQUNyRCxVQUFJLFVBQVUsUUFBUSxPQUFPLE9BQU8sTUFBTSxRQUFRLFNBQVM7QUFDM0QsZUFBUyxTQUFTO0FBQ2xCLFVBQUksUUFBUSxRQUFRLE9BQU8sT0FBTyxNQUFNLFFBQVEsU0FBUztBQUN6RCxlQUFTLFNBQVM7QUFDbEIsVUFBSSxRQUFRLFFBQVEsT0FBTyxPQUFPLE1BQU0sUUFBUSxTQUFTO0FBQ3pELGVBQVMsU0FBUztBQUNsQixVQUFJLE9BQU8sT0FBTyxNQUFNLFFBQVEsT0FBTztBQUN2QyxhQUFPLEVBQUMsVUFBVSxTQUFTLEtBQUssTUFBTSxPQUFjLE9BQWMsU0FBUzs7SUFHN0UsWUFBWSxRQUFRLE1BQU0sU0FBUTtBQUNoQyxVQUFJLGNBQWMsS0FBSyxTQUFTO0FBQ2hDLFVBQUksVUFBVSxLQUFLLFNBQVM7QUFDNUIsVUFBSSxZQUFZLEtBQUssU0FBUztBQUM5QixVQUFJLFlBQVksS0FBSyxTQUFTO0FBQzlCLFVBQUksU0FBUyxLQUFLLGdCQUFnQixLQUFLO0FBQ3ZDLFVBQUksVUFBVSxRQUFRLE9BQU8sT0FBTyxNQUFNLFFBQVEsU0FBUztBQUMzRCxlQUFTLFNBQVM7QUFDbEIsVUFBSSxNQUFNLFFBQVEsT0FBTyxPQUFPLE1BQU0sUUFBUSxTQUFTO0FBQ3ZELGVBQVMsU0FBUztBQUNsQixVQUFJLFFBQVEsUUFBUSxPQUFPLE9BQU8sTUFBTSxRQUFRLFNBQVM7QUFDekQsZUFBUyxTQUFTO0FBQ2xCLFVBQUksUUFBUSxRQUFRLE9BQU8sT0FBTyxNQUFNLFFBQVEsU0FBUztBQUN6RCxlQUFTLFNBQVM7QUFDbEIsVUFBSSxPQUFPLE9BQU8sTUFBTSxRQUFRLE9BQU87QUFDdkMsVUFBSSxVQUFVLEVBQUMsUUFBUSxPQUFPLFVBQVU7QUFDeEMsYUFBTyxFQUFDLFVBQVUsU0FBUyxLQUFVLE9BQWMsT0FBTyxlQUFlLE9BQU87O0lBR2xGLGdCQUFnQixRQUFRLE1BQU0sU0FBUTtBQUNwQyxVQUFJLFlBQVksS0FBSyxTQUFTO0FBQzlCLFVBQUksWUFBWSxLQUFLLFNBQVM7QUFDOUIsVUFBSSxTQUFTLEtBQUssZ0JBQWdCO0FBQ2xDLFVBQUksUUFBUSxRQUFRLE9BQU8sT0FBTyxNQUFNLFFBQVEsU0FBUztBQUN6RCxlQUFTLFNBQVM7QUFDbEIsVUFBSSxRQUFRLFFBQVEsT0FBTyxPQUFPLE1BQU0sUUFBUSxTQUFTO0FBQ3pELGVBQVMsU0FBUztBQUNsQixVQUFJLE9BQU8sT0FBTyxNQUFNLFFBQVEsT0FBTztBQUV2QyxhQUFPLEVBQUMsVUFBVSxNQUFNLEtBQUssTUFBTSxPQUFjLE9BQWMsU0FBUzs7O0FDcEI1RSxNQUFxQixTQUFyQixNQUE0QjtJQUMxQixZQUFZLFVBQVUsT0FBTyxJQUFHO0FBQzlCLFdBQUssdUJBQXVCLEVBQUMsTUFBTSxJQUFJLE9BQU8sSUFBSSxPQUFPLElBQUksU0FBUztBQUN0RSxXQUFLLFdBQVc7QUFDaEIsV0FBSyxhQUFhO0FBQ2xCLFdBQUssTUFBTTtBQUNYLFdBQUssVUFBVSxLQUFLLFdBQVc7QUFDL0IsV0FBSyxZQUFZLEtBQUssYUFBYSxPQUFPLGFBQWE7QUFDdkQsV0FBSyx5QkFBeUI7QUFDOUIsV0FBSyxpQkFBaUIsbUJBQVcsT0FBTyxLQUFLO0FBQzdDLFdBQUssaUJBQWlCLG1CQUFXLE9BQU8sS0FBSztBQUM3QyxXQUFLLGdCQUFnQjtBQUNyQixXQUFLLGFBQWEsS0FBSyxjQUFjO0FBQ3JDLFdBQUssZUFBZTtBQUNwQixVQUFHLEtBQUssY0FBYyxVQUFTO0FBQzdCLGFBQUssU0FBUyxLQUFLLFVBQVUsS0FBSztBQUNsQyxhQUFLLFNBQVMsS0FBSyxVQUFVLEtBQUs7YUFDN0I7QUFDTCxhQUFLLFNBQVMsS0FBSztBQUNuQixhQUFLLFNBQVMsS0FBSzs7QUFFckIsVUFBSSwrQkFBK0I7QUFDbkMsVUFBRyxhQUFhLFVBQVUsa0JBQWlCO0FBQ3pDLGtCQUFVLGlCQUFpQixZQUFZLENBQUEsT0FBTTtBQUMzQyxjQUFHLEtBQUssTUFBSztBQUNYLGlCQUFLO0FBQ0wsMkNBQStCLEtBQUs7OztBQUd4QyxrQkFBVSxpQkFBaUIsWUFBWSxDQUFBLE9BQU07QUFDM0MsY0FBRyxpQ0FBaUMsS0FBSyxjQUFhO0FBQ3BELDJDQUErQjtBQUMvQixpQkFBSzs7OztBQUlYLFdBQUssc0JBQXNCLEtBQUssdUJBQXVCO0FBQ3ZELFdBQUssZ0JBQWdCLENBQUMsVUFBVTtBQUM5QixZQUFHLEtBQUssZUFBYztBQUNwQixpQkFBTyxLQUFLLGNBQWM7ZUFDckI7QUFDTCxpQkFBTyxDQUFDLEtBQU0sS0FBTSxLQUFNLFFBQVEsTUFBTTs7O0FBRzVDLFdBQUssbUJBQW1CLENBQUMsVUFBVTtBQUNqQyxZQUFHLEtBQUssa0JBQWlCO0FBQ3ZCLGlCQUFPLEtBQUssaUJBQWlCO2VBQ3hCO0FBQ0wsaUJBQU8sQ0FBQyxJQUFJLElBQUksS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQU0sS0FBTSxRQUFRLE1BQU07OztBQUd2RSxXQUFLLFNBQVMsS0FBSyxVQUFVO0FBQzdCLFdBQUssb0JBQW9CLEtBQUsscUJBQXFCO0FBQ25ELFdBQUssU0FBUyxRQUFRLEtBQUssVUFBVTtBQUNyQyxXQUFLLFdBQVcsR0FBRyxZQUFZLFdBQVc7QUFDMUMsV0FBSyxNQUFNLEtBQUssT0FBTztBQUN2QixXQUFLLHdCQUF3QjtBQUM3QixXQUFLLGlCQUFpQjtBQUN0QixXQUFLLHNCQUFzQjtBQUMzQixXQUFLLGlCQUFpQixJQUFJLE1BQU0sTUFBTTtBQUNwQyxhQUFLLFNBQVMsTUFBTSxLQUFLO1NBQ3hCLEtBQUs7O0lBTVYsdUJBQXNCO0FBQUUsYUFBTzs7SUFRL0IsaUJBQWlCLGNBQWE7QUFDNUIsV0FBSztBQUNMLFdBQUssZ0JBQWdCO0FBQ3JCLFdBQUssZUFBZTtBQUNwQixXQUFLLGFBQWE7QUFDbEIsVUFBRyxLQUFLLE1BQUs7QUFDWCxhQUFLLEtBQUs7QUFDVixhQUFLLE9BQU87O0FBRWQsV0FBSyxZQUFZOztJQVFuQixXQUFVO0FBQUUsYUFBTyxTQUFTLFNBQVMsTUFBTSxZQUFZLFFBQVE7O0lBTy9ELGNBQWE7QUFDWCxVQUFJLE1BQU0sS0FBSyxhQUNiLEtBQUssYUFBYSxLQUFLLFVBQVUsS0FBSyxXQUFXLEVBQUMsS0FBSyxLQUFLO0FBQzlELFVBQUcsSUFBSSxPQUFPLE9BQU8sS0FBSTtBQUFFLGVBQU87O0FBQ2xDLFVBQUcsSUFBSSxPQUFPLE9BQU8sS0FBSTtBQUFFLGVBQU8sR0FBRyxLQUFLLGNBQWM7O0FBRXhELGFBQU8sR0FBRyxLQUFLLGdCQUFnQixTQUFTLE9BQU87O0lBWWpELFdBQVcsVUFBVSxNQUFNLFFBQU87QUFDaEMsV0FBSztBQUNMLFdBQUssZ0JBQWdCO0FBQ3JCLFdBQUssZUFBZTtBQUNwQixXQUFLLFNBQVMsVUFBVSxNQUFNOztJQVVoQyxRQUFRLFFBQU87QUFDYixVQUFHLFFBQU87QUFDUixtQkFBVyxRQUFRLElBQUk7QUFDdkIsYUFBSyxTQUFTLFFBQVE7O0FBRXhCLFVBQUcsS0FBSyxNQUFLO0FBQUU7O0FBRWYsV0FBSztBQUNMLFdBQUssZ0JBQWdCO0FBQ3JCLFdBQUssT0FBTyxJQUFJLEtBQUssVUFBVSxLQUFLO0FBQ3BDLFdBQUssS0FBSyxhQUFhLEtBQUs7QUFDNUIsV0FBSyxLQUFLLFVBQVUsS0FBSztBQUN6QixXQUFLLEtBQUssU0FBUyxNQUFNLEtBQUs7QUFDOUIsV0FBSyxLQUFLLFVBQVUsQ0FBQSxVQUFTLEtBQUssWUFBWTtBQUM5QyxXQUFLLEtBQUssWUFBWSxDQUFBLFVBQVMsS0FBSyxjQUFjO0FBQ2xELFdBQUssS0FBSyxVQUFVLENBQUEsVUFBUyxLQUFLLFlBQVk7O0lBU2hELElBQUksTUFBTSxLQUFLLE1BQUs7QUFBRSxXQUFLLE9BQU8sTUFBTSxLQUFLOztJQUs3QyxZQUFXO0FBQUUsYUFBTyxLQUFLLFdBQVc7O0lBU3BDLE9BQU8sVUFBUztBQUNkLFVBQUksTUFBTSxLQUFLO0FBQ2YsV0FBSyxxQkFBcUIsS0FBSyxLQUFLLENBQUMsS0FBSztBQUMxQyxhQUFPOztJQU9ULFFBQVEsVUFBUztBQUNmLFVBQUksTUFBTSxLQUFLO0FBQ2YsV0FBSyxxQkFBcUIsTUFBTSxLQUFLLENBQUMsS0FBSztBQUMzQyxhQUFPOztJQVVULFFBQVEsVUFBUztBQUNmLFVBQUksTUFBTSxLQUFLO0FBQ2YsV0FBSyxxQkFBcUIsTUFBTSxLQUFLLENBQUMsS0FBSztBQUMzQyxhQUFPOztJQU9ULFVBQVUsVUFBUztBQUNqQixVQUFJLE1BQU0sS0FBSztBQUNmLFdBQUsscUJBQXFCLFFBQVEsS0FBSyxDQUFDLEtBQUs7QUFDN0MsYUFBTzs7SUFTVCxLQUFLLFVBQVM7QUFDWixVQUFHLENBQUMsS0FBSyxlQUFjO0FBQUUsZUFBTzs7QUFDaEMsVUFBSSxNQUFNLEtBQUs7QUFDZixVQUFJLFlBQVksS0FBSztBQUNyQixXQUFLLEtBQUssRUFBQyxPQUFPLFdBQVcsT0FBTyxhQUFhLFNBQVMsSUFBSTtBQUM5RCxVQUFJLFdBQVcsS0FBSyxVQUFVLENBQUEsUUFBTztBQUNuQyxZQUFHLElBQUksUUFBUSxLQUFJO0FBQ2pCLGVBQUssSUFBSSxDQUFDO0FBQ1YsbUJBQVMsS0FBSyxRQUFROzs7QUFHMUIsYUFBTzs7SUFPVCxrQkFBaUI7QUFDZixtQkFBYSxLQUFLO0FBQ2xCLG1CQUFhLEtBQUs7O0lBR3BCLGFBQVk7QUFDVixVQUFHLEtBQUs7QUFBYSxhQUFLLElBQUksYUFBYSxnQkFBZ0IsS0FBSztBQUNoRSxXQUFLLGdCQUFnQjtBQUNyQixXQUFLO0FBQ0wsV0FBSztBQUNMLFdBQUssZUFBZTtBQUNwQixXQUFLO0FBQ0wsV0FBSyxxQkFBcUIsS0FBSyxRQUFRLENBQUMsQ0FBQyxFQUFFLGNBQWM7O0lBTzNELG1CQUFrQjtBQUNoQixVQUFHLEtBQUsscUJBQW9CO0FBQzFCLGFBQUssc0JBQXNCO0FBQzNCLFlBQUcsS0FBSyxhQUFZO0FBQUUsZUFBSyxJQUFJLGFBQWE7O0FBQzVDLGFBQUs7QUFDTCxhQUFLLGdCQUFnQjtBQUNyQixhQUFLLFNBQVMsTUFBTSxLQUFLLGVBQWUsbUJBQW1CLGlCQUFpQjs7O0lBSWhGLGlCQUFnQjtBQUNkLFVBQUcsS0FBSyxRQUFRLEtBQUssS0FBSyxlQUFjO0FBQUU7O0FBQzFDLFdBQUssc0JBQXNCO0FBQzNCLFdBQUs7QUFDTCxXQUFLLGlCQUFpQixXQUFXLE1BQU0sS0FBSyxpQkFBaUIsS0FBSzs7SUFHcEUsU0FBUyxVQUFVLE1BQU0sUUFBTztBQUM5QixVQUFHLENBQUMsS0FBSyxNQUFLO0FBQ1osZUFBTyxZQUFZOztBQUdyQixXQUFLLGtCQUFrQixNQUFNO0FBQzNCLFlBQUcsS0FBSyxNQUFLO0FBQ1gsY0FBRyxNQUFLO0FBQUUsaUJBQUssS0FBSyxNQUFNLE1BQU0sVUFBVTtpQkFBVztBQUFFLGlCQUFLLEtBQUs7OztBQUduRSxhQUFLLG9CQUFvQixNQUFNO0FBQzdCLGNBQUcsS0FBSyxNQUFLO0FBQ1gsaUJBQUssS0FBSyxTQUFTLFdBQVc7O0FBQzlCLGlCQUFLLEtBQUssVUFBVSxXQUFXOztBQUMvQixpQkFBSyxLQUFLLFlBQVksV0FBVzs7QUFDakMsaUJBQUssS0FBSyxVQUFVLFdBQVc7O0FBQy9CLGlCQUFLLE9BQU87O0FBR2Qsc0JBQVk7Ozs7SUFLbEIsa0JBQWtCLFVBQVUsUUFBUSxHQUFFO0FBQ3BDLFVBQUcsVUFBVSxLQUFLLENBQUMsS0FBSyxRQUFRLENBQUMsS0FBSyxLQUFLLGdCQUFlO0FBQ3hEO0FBQ0E7O0FBR0YsaUJBQVcsTUFBTTtBQUNmLGFBQUssa0JBQWtCLFVBQVUsUUFBUTtTQUN4QyxNQUFNOztJQUdYLG9CQUFvQixVQUFVLFFBQVEsR0FBRTtBQUN0QyxVQUFHLFVBQVUsS0FBSyxDQUFDLEtBQUssUUFBUSxLQUFLLEtBQUssZUFBZSxjQUFjLFFBQU87QUFDNUU7QUFDQTs7QUFHRixpQkFBVyxNQUFNO0FBQ2YsYUFBSyxvQkFBb0IsVUFBVSxRQUFRO1NBQzFDLE1BQU07O0lBR1gsWUFBWSxPQUFNO0FBQ2hCLFVBQUksWUFBWSxTQUFTLE1BQU07QUFDL0IsVUFBRyxLQUFLO0FBQWEsYUFBSyxJQUFJLGFBQWEsU0FBUztBQUNwRCxXQUFLO0FBQ0wsV0FBSztBQUNMLFVBQUcsQ0FBQyxLQUFLLGlCQUFpQixjQUFjLEtBQUs7QUFDM0MsYUFBSyxlQUFlOztBQUV0QixXQUFLLHFCQUFxQixNQUFNLFFBQVEsQ0FBQyxDQUFDLEVBQUUsY0FBYyxTQUFTOztJQU1yRSxZQUFZLE9BQU07QUFDaEIsVUFBRyxLQUFLO0FBQWEsYUFBSyxJQUFJLGFBQWE7QUFDM0MsVUFBSSxrQkFBa0IsS0FBSztBQUMzQixVQUFJLG9CQUFvQixLQUFLO0FBQzdCLFdBQUsscUJBQXFCLE1BQU0sUUFBUSxDQUFDLENBQUMsRUFBRSxjQUFjO0FBQ3hELGlCQUFTLE9BQU8saUJBQWlCOztBQUVuQyxVQUFHLG9CQUFvQixLQUFLLGFBQWEsb0JBQW9CLEdBQUU7QUFDN0QsYUFBSzs7O0lBT1QsbUJBQWtCO0FBQ2hCLFdBQUssU0FBUyxRQUFRLENBQUEsWUFBVztBQUMvQixZQUFHLENBQUUsU0FBUSxlQUFlLFFBQVEsZUFBZSxRQUFRLGFBQVk7QUFDckUsa0JBQVEsUUFBUSxlQUFlOzs7O0lBUXJDLGtCQUFpQjtBQUNmLGNBQU8sS0FBSyxRQUFRLEtBQUssS0FBSzthQUN2QixjQUFjO0FBQVksaUJBQU87YUFDakMsY0FBYztBQUFNLGlCQUFPO2FBQzNCLGNBQWM7QUFBUyxpQkFBTzs7QUFDMUIsaUJBQU87OztJQU9wQixjQUFhO0FBQUUsYUFBTyxLQUFLLHNCQUFzQjs7SUFPakQsT0FBTyxTQUFRO0FBQ2IsV0FBSyxJQUFJLFFBQVE7QUFDakIsV0FBSyxXQUFXLEtBQUssU0FBUyxPQUFPLENBQUEsTUFBSyxFQUFFLGNBQWMsUUFBUTs7SUFTcEUsSUFBSSxNQUFLO0FBQ1AsZUFBUSxPQUFPLEtBQUssc0JBQXFCO0FBQ3ZDLGFBQUsscUJBQXFCLE9BQU8sS0FBSyxxQkFBcUIsS0FBSyxPQUFPLENBQUMsQ0FBQyxTQUFTO0FBQ2hGLGlCQUFPLEtBQUssUUFBUSxTQUFTOzs7O0lBWW5DLFFBQVEsT0FBTyxhQUFhLElBQUc7QUFDN0IsVUFBSSxPQUFPLElBQUksUUFBUSxPQUFPLFlBQVk7QUFDMUMsV0FBSyxTQUFTLEtBQUs7QUFDbkIsYUFBTzs7SUFNVCxLQUFLLE1BQUs7QUFDUixVQUFHLEtBQUssYUFBWTtBQUNsQixZQUFJLEVBQUMsT0FBTyxPQUFPLFNBQVMsS0FBSyxhQUFZO0FBQzdDLGFBQUssSUFBSSxRQUFRLEdBQUcsU0FBUyxVQUFVLGFBQWEsUUFBUTs7QUFHOUQsVUFBRyxLQUFLLGVBQWM7QUFDcEIsYUFBSyxPQUFPLE1BQU0sQ0FBQSxXQUFVLEtBQUssS0FBSyxLQUFLO2FBQ3RDO0FBQ0wsYUFBSyxXQUFXLEtBQUssTUFBTSxLQUFLLE9BQU8sTUFBTSxDQUFBLFdBQVUsS0FBSyxLQUFLLEtBQUs7OztJQVExRSxVQUFTO0FBQ1AsVUFBSSxTQUFTLEtBQUssTUFBTTtBQUN4QixVQUFHLFdBQVcsS0FBSyxLQUFJO0FBQUUsYUFBSyxNQUFNO2FBQVM7QUFBRSxhQUFLLE1BQU07O0FBRTFELGFBQU8sS0FBSyxJQUFJOztJQUdsQixnQkFBZTtBQUNiLFVBQUcsS0FBSyx1QkFBdUIsQ0FBQyxLQUFLLGVBQWM7QUFBRTs7QUFDckQsV0FBSyxzQkFBc0IsS0FBSztBQUNoQyxXQUFLLEtBQUssRUFBQyxPQUFPLFdBQVcsT0FBTyxhQUFhLFNBQVMsSUFBSSxLQUFLLEtBQUs7QUFDeEUsV0FBSyx3QkFBd0IsV0FBVyxNQUFNLEtBQUssb0JBQW9CLEtBQUs7O0lBRzlFLGtCQUFpQjtBQUNmLFVBQUcsS0FBSyxpQkFBaUIsS0FBSyxXQUFXLFNBQVMsR0FBRTtBQUNsRCxhQUFLLFdBQVcsUUFBUSxDQUFBLGFBQVk7QUFDcEMsYUFBSyxhQUFhOzs7SUFJdEIsY0FBYyxZQUFXO0FBQ3ZCLFdBQUssT0FBTyxXQUFXLE1BQU0sQ0FBQSxRQUFPO0FBQ2xDLFlBQUksRUFBQyxPQUFPLE9BQU8sU0FBUyxLQUFLLGFBQVk7QUFDN0MsWUFBRyxPQUFPLFFBQVEsS0FBSyxxQkFBb0I7QUFDekMsZUFBSztBQUNMLGVBQUssc0JBQXNCO0FBQzNCLGVBQUssaUJBQWlCLFdBQVcsTUFBTSxLQUFLLGlCQUFpQixLQUFLOztBQUdwRSxZQUFHLEtBQUs7QUFBYSxlQUFLLElBQUksV0FBVyxHQUFHLFFBQVEsVUFBVSxNQUFNLFNBQVMsU0FBUyxPQUFPLE1BQU0sTUFBTSxPQUFPLE1BQU07QUFFdEgsaUJBQVEsSUFBSSxHQUFHLElBQUksS0FBSyxTQUFTLFFBQVEsS0FBSTtBQUMzQyxnQkFBTSxVQUFVLEtBQUssU0FBUztBQUM5QixjQUFHLENBQUMsUUFBUSxTQUFTLE9BQU8sT0FBTyxTQUFTLFdBQVU7QUFBRTs7QUFDeEQsa0JBQVEsUUFBUSxPQUFPLFNBQVMsS0FBSzs7QUFHdkMsaUJBQVEsSUFBSSxHQUFHLElBQUksS0FBSyxxQkFBcUIsUUFBUSxRQUFRLEtBQUk7QUFDL0QsY0FBSSxDQUFDLEVBQUUsWUFBWSxLQUFLLHFCQUFxQixRQUFRO0FBQ3JELG1CQUFTOzs7O0lBS2YsZUFBZSxPQUFNO0FBQ25CLFVBQUksYUFBYSxLQUFLLFNBQVMsS0FBSyxDQUFBLE1BQUssRUFBRSxVQUFVLFNBQVUsR0FBRSxjQUFjLEVBQUU7QUFDakYsVUFBRyxZQUFXO0FBQ1osWUFBRyxLQUFLO0FBQWEsZUFBSyxJQUFJLGFBQWEsNEJBQTRCO0FBQ3ZFLG1CQUFXOzs7Ozs7QUNsakJWLE1BQU0sc0JBQXNCO0FBQzVCLE1BQU0sY0FBYztBQUNwQixNQUFNLG9CQUFvQjtBQUMxQixNQUFNLG9CQUFvQjtBQUMxQixNQUFNLGtCQUFrQjtBQUN4QixNQUFNLG9CQUFvQjtJQUMvQjtJQUFxQjtJQUFzQjtJQUMzQztJQUF1QjtJQUFxQjtJQUFvQjs7QUFFM0QsTUFBTSxnQkFBZ0I7QUFDdEIsTUFBTSxnQkFBZ0I7QUFDdEIsTUFBTSxtQkFBbUI7QUFDekIsTUFBTSxpQkFBaUI7QUFDdkIsTUFBTSxVQUFVO0FBQ2hCLE1BQU0sY0FBYztBQUNwQixNQUFNLG9CQUFvQjtBQUMxQixNQUFNLGlCQUFpQjtBQUN2QixNQUFNLHVCQUF1QjtBQUM3QixNQUFNLGdCQUFnQjtBQUN0QixNQUFNLGtCQUFrQjtBQUN4QixNQUFNLHdCQUF3QjtBQUM5QixNQUFNLHdCQUF3QjtBQUM5QixNQUFNLFdBQVc7QUFDakIsTUFBTSxZQUFZO0FBQ2xCLE1BQU0sbUJBQW1CO0FBQ3pCLE1BQU0sc0JBQXNCO0FBQzVCLE1BQU0seUJBQXlCO0FBQy9CLE1BQU0sd0JBQXdCO0FBQzlCLE1BQU0sa0JBQWtCO0FBQ3hCLE1BQU0sZ0JBQWdCO0FBQ3RCLE1BQU0sV0FBVztBQUNqQixNQUFNLGNBQWM7QUFDcEIsTUFBTSxxQkFBcUI7QUFDM0IsTUFBTSxtQkFBbUI7QUFDekIsTUFBTSxrQkFBa0I7QUFDeEIsTUFBTSxtQkFBbUIsQ0FBQyxRQUFRLFlBQVksVUFBVSxTQUFTLFlBQVksVUFBVSxPQUFPLE9BQU8sUUFBUSxRQUFRLGtCQUFrQixTQUFTO0FBQ2hKLE1BQU0sbUJBQW1CLENBQUMsWUFBWTtBQUN0QyxNQUFNLG9CQUFvQjtBQUMxQixNQUFNLGNBQWM7QUFDcEIsTUFBTSxvQkFBb0IsSUFBSTtBQUM5QixNQUFNLGFBQWE7QUFDbkIsTUFBTSxhQUFhO0FBQ25CLE1BQU0sZUFBZTtBQUNyQixNQUFNLGVBQWU7QUFDckIsTUFBTSxtQkFBbUI7QUFDekIsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSxXQUFXO0FBQ2pCLE1BQU0sZUFBZTtBQUNyQixNQUFNLGVBQWU7QUFDckIsTUFBTSxhQUFhO0FBQ25CLE1BQU0sVUFBVTtBQUNoQixNQUFNLGNBQWM7QUFDcEIsTUFBTSxtQkFBbUI7QUFDekIsTUFBTSxlQUFlO0FBQ3JCLE1BQU0saUJBQWlCO0FBQ3ZCLE1BQU0scUJBQXFCO0FBQzNCLE1BQU0sZUFBZTtBQUNyQixNQUFNLGlCQUFpQjtBQUN2QixNQUFNLCtCQUErQjtBQUNyQyxNQUFNLGlCQUFpQjtBQUN2QixNQUFNLGVBQWU7QUFHckIsTUFBTSxtQkFBbUI7QUFDekIsTUFBTSxZQUFZO0FBQ2xCLE1BQU0sb0JBQW9CO0FBQzFCLE1BQU0sV0FBVztJQUN0QixVQUFVO0lBQ1YsVUFBVTs7QUFJTCxNQUFNLFdBQVc7QUFDakIsTUFBTSxTQUFTO0FBQ2YsTUFBTSxhQUFhO0FBQ25CLE1BQU0sU0FBUztBQUNmLE1BQU0sUUFBUTtBQUNkLE1BQU0sUUFBUTtBQUNkLE1BQU0sWUFBWTtBQzNFekIsTUFBQSxnQkFBQSxNQUFtQztJQUNqQyxZQUFZLE9BQU8sV0FBVyxhQUFXO0FBQ3ZDLFdBQUssYUFBYTtBQUNsQixXQUFLLFFBQVE7QUFDYixXQUFLLFNBQVM7QUFDZCxXQUFLLFlBQVk7QUFDakIsV0FBSyxhQUFhO0FBQ2xCLFdBQUssZ0JBQWdCLFlBQVcsUUFBUSxPQUFPLE1BQU0sT0FBTyxFQUFDLE9BQU8sTUFBTTs7SUFHNUUsTUFBTSxRQUFPO0FBQ1gsbUJBQWEsS0FBSztBQUNsQixXQUFLLGNBQWM7QUFDbkIsV0FBSyxNQUFNLE1BQU07O0lBR25CLFNBQVE7QUFDTixXQUFLLGNBQWMsUUFBUSxDQUFBLFdBQVUsS0FBSyxNQUFNO0FBQ2hELFdBQUssY0FBYyxPQUNoQixRQUFRLE1BQU0sQ0FBQSxVQUFTLEtBQUssaUJBQzVCLFFBQVEsU0FBUyxDQUFBLFdBQVUsS0FBSyxNQUFNOztJQUczQyxTQUFRO0FBQUUsYUFBTyxLQUFLLFVBQVUsS0FBSyxNQUFNLEtBQUs7O0lBRWhELGdCQUFlO0FBQ2IsVUFBSSxTQUFTLElBQUksT0FBTztBQUN4QixVQUFJLE9BQU8sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLFFBQVEsS0FBSyxZQUFZLEtBQUs7QUFDcEUsYUFBTyxTQUFTLENBQUMsTUFBTTtBQUNyQixZQUFHLEVBQUUsT0FBTyxVQUFVLE1BQUs7QUFDekIsZUFBSyxVQUFVLEVBQUUsT0FBTyxPQUFPO0FBQy9CLGVBQUssVUFBVSxFQUFFLE9BQU87ZUFDbkI7QUFDTCxpQkFBTyxTQUFTLGlCQUFpQixFQUFFLE9BQU87OztBQUc5QyxhQUFPLGtCQUFrQjs7SUFHM0IsVUFBVSxPQUFNO0FBQ2QsVUFBRyxDQUFDLEtBQUssY0FBYyxZQUFXO0FBQUU7O0FBQ3BDLFdBQUssY0FBYyxLQUFLLFNBQVMsT0FDOUIsUUFBUSxNQUFNLE1BQU07QUFDbkIsYUFBSyxNQUFNLFNBQVUsS0FBSyxTQUFTLEtBQUssTUFBTSxLQUFLLE9BQVE7QUFDM0QsWUFBRyxDQUFDLEtBQUssVUFBUztBQUNoQixlQUFLLGFBQWEsV0FBVyxNQUFNLEtBQUssaUJBQWlCLEtBQUssV0FBVyxtQkFBbUI7Ozs7O0FDM0MvRixNQUFJLFdBQVcsQ0FBQyxLQUFLLFFBQVEsUUFBUSxTQUFTLFFBQVEsTUFBTSxLQUFLO0FBRWpFLE1BQUksUUFBUSxDQUFDLFFBQVE7QUFDMUIsUUFBSSxPQUFPLE9BQU87QUFDbEIsV0FBTyxTQUFTLFlBQWEsU0FBUyxZQUFZLGlCQUFpQixLQUFLOztBQUduRSxnQ0FBNkI7QUFDbEMsUUFBSSxNQUFNLG9CQUFJO0FBQ2QsUUFBSSxRQUFRLFNBQVMsaUJBQWlCO0FBQ3RDLGFBQVEsSUFBSSxHQUFHLE1BQU0sTUFBTSxRQUFRLElBQUksS0FBSyxLQUFJO0FBQzlDLFVBQUcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFJO0FBQ3RCLGdCQUFRLE1BQU0sMEJBQTBCLE1BQU0sR0FBRzthQUM1QztBQUNMLFlBQUksSUFBSSxNQUFNLEdBQUc7Ozs7QUFLaEIsTUFBSSxRQUFRLENBQUMsTUFBTSxNQUFNLEtBQUssUUFBUTtBQUMzQyxRQUFHLEtBQUssV0FBVyxrQkFBaUI7QUFDbEMsY0FBUSxJQUFJLEdBQUcsS0FBSyxNQUFNLFNBQVMsVUFBVTs7O0FBSzFDLE1BQUksV0FBVSxDQUFDLFFBQVEsT0FBTyxRQUFRLGFBQWEsTUFBTSxXQUFXO0FBQUUsV0FBTzs7QUFFN0UsTUFBSSxRQUFRLENBQUMsUUFBUTtBQUFFLFdBQU8sS0FBSyxNQUFNLEtBQUssVUFBVTs7QUFFeEQsTUFBSSxvQkFBb0IsQ0FBQyxJQUFJLFNBQVMsYUFBYTtBQUN4RCxPQUFHO0FBQ0QsVUFBRyxHQUFHLFFBQVEsSUFBSSxhQUFZO0FBQUUsZUFBTzs7QUFDdkMsV0FBSyxHQUFHLGlCQUFpQixHQUFHO2FBQ3RCLE9BQU8sUUFBUSxHQUFHLGFBQWEsS0FBSyxDQUFHLGFBQVksU0FBUyxXQUFXLE9BQVEsR0FBRyxRQUFRO0FBQ2xHLFdBQU87O0FBR0YsTUFBSSxXQUFXLENBQUMsUUFBUTtBQUM3QixXQUFPLFFBQVEsUUFBUSxPQUFPLFFBQVEsWUFBWSxDQUFFLGdCQUFlOztBQUc5RCxNQUFJLGFBQWEsQ0FBQyxNQUFNLFNBQVMsS0FBSyxVQUFVLFVBQVUsS0FBSyxVQUFVO0FBRXpFLE1BQUksVUFBVSxDQUFDLFFBQVE7QUFDNUIsYUFBUSxLQUFLLEtBQUk7QUFBRSxhQUFPOztBQUMxQixXQUFPOztBQUdGLE1BQUksUUFBUSxDQUFDLElBQUksYUFBYSxNQUFNLFNBQVM7QUFFN0MsTUFBSSxrQkFBa0IsU0FBVSxTQUFTLFNBQVMsTUFBTSxhQUFXO0FBQ3hFLFlBQVEsUUFBUSxDQUFBLFVBQVM7QUFDdkIsVUFBSSxnQkFBZ0IsSUFBSSxjQUFjLE9BQU8sS0FBSyxPQUFPLFlBQVk7QUFDckUsb0JBQWM7OztBQzVEbEIsTUFBSSxVQUFVO0lBQ1osZUFBYztBQUFFLGFBQVEsT0FBUSxRQUFRLGNBQWU7O0lBRXZELFVBQVUsY0FBYyxXQUFXLFFBQU87QUFDeEMsYUFBTyxhQUFhLFdBQVcsS0FBSyxTQUFTLFdBQVc7O0lBRzFELFlBQVksY0FBYyxXQUFXLFFBQVEsU0FBUyxNQUFLO0FBQ3pELFVBQUksVUFBVSxLQUFLLFNBQVMsY0FBYyxXQUFXO0FBQ3JELFVBQUksTUFBTSxLQUFLLFNBQVMsV0FBVztBQUNuQyxVQUFJLFNBQVMsWUFBWSxPQUFPLFVBQVUsS0FBSztBQUMvQyxtQkFBYSxRQUFRLEtBQUssS0FBSyxVQUFVO0FBQ3pDLGFBQU87O0lBR1QsU0FBUyxjQUFjLFdBQVcsUUFBTztBQUN2QyxhQUFPLEtBQUssTUFBTSxhQUFhLFFBQVEsS0FBSyxTQUFTLFdBQVc7O0lBR2xFLG1CQUFtQixVQUFTO0FBQzFCLFVBQUcsQ0FBQyxLQUFLLGdCQUFlO0FBQUU7O0FBQzFCLGNBQVEsYUFBYSxTQUFTLFFBQVEsU0FBUyxLQUFLLElBQUksT0FBTyxTQUFTOztJQUcxRSxVQUFVLE1BQU0sTUFBTSxJQUFHO0FBQ3ZCLFVBQUcsS0FBSyxnQkFBZTtBQUNyQixZQUFHLE9BQU8sT0FBTyxTQUFTLE1BQUs7QUFDN0IsY0FBRyxLQUFLLFFBQVEsY0FBYyxLQUFLLFFBQU87QUFFeEMsZ0JBQUksZUFBZSxRQUFRLFNBQVM7QUFDcEMseUJBQWEsU0FBUyxLQUFLO0FBQzNCLG9CQUFRLGFBQWEsY0FBYyxJQUFJLE9BQU8sU0FBUzs7QUFHekQsaUJBQU8sS0FBSztBQUNaLGtCQUFRLE9BQU8sU0FBUyxNQUFNLElBQUksTUFBTTtBQUN4QyxjQUFJLFNBQVMsS0FBSyxnQkFBZ0IsT0FBTyxTQUFTO0FBRWxELGNBQUcsUUFBTztBQUNSLG1CQUFPO3FCQUNDLEtBQUssU0FBUyxZQUFXO0FBQ2pDLG1CQUFPLE9BQU8sR0FBRzs7O2FBR2hCO0FBQ0wsYUFBSyxTQUFTOzs7SUFJbEIsVUFBVSxNQUFNLE9BQU07QUFDcEIsZUFBUyxTQUFTLEdBQUcsUUFBUTs7SUFHL0IsVUFBVSxNQUFLO0FBQ2IsYUFBTyxTQUFTLE9BQU8sUUFBUSxJQUFJLE9BQU8saUJBQWtCLDhCQUFpQzs7SUFHL0YsU0FBUyxPQUFPLE9BQU07QUFDcEIsVUFBRyxPQUFNO0FBQUUsZ0JBQVEsVUFBVSxxQkFBcUIsUUFBUTs7QUFDMUQsYUFBTyxXQUFXOztJQUdwQixTQUFTLFdBQVcsUUFBTztBQUFFLGFBQU8sR0FBRyxhQUFhOztJQUVwRCxnQkFBZ0IsV0FBVTtBQUN4QixVQUFJLE9BQU8sVUFBVSxXQUFXLFVBQVU7QUFDMUMsVUFBRyxTQUFTLElBQUc7QUFBRTs7QUFDakIsYUFBTyxTQUFTLGVBQWUsU0FBUyxTQUFTLGNBQWMsV0FBVzs7O0FBSTlFLE1BQU8sa0JBQVE7QUMzQ2YsTUFBSSxNQUFNO0lBQ1IsS0FBSyxJQUFHO0FBQUUsYUFBTyxTQUFTLGVBQWUsT0FBTyxTQUFTLG1CQUFtQjs7SUFFNUUsWUFBWSxJQUFJLFdBQVU7QUFDeEIsU0FBRyxVQUFVLE9BQU87QUFDcEIsVUFBRyxHQUFHLFVBQVUsV0FBVyxHQUFFO0FBQUUsV0FBRyxnQkFBZ0I7OztJQUdwRCxJQUFJLE1BQU0sT0FBTyxVQUFTO0FBQ3hCLFVBQUcsQ0FBQyxNQUFLO0FBQUUsZUFBTzs7QUFDbEIsVUFBSSxRQUFRLE1BQU0sS0FBSyxLQUFLLGlCQUFpQjtBQUM3QyxhQUFPLFdBQVcsTUFBTSxRQUFRLFlBQVk7O0lBRzlDLGdCQUFnQixNQUFLO0FBQ25CLFVBQUksV0FBVyxTQUFTLGNBQWM7QUFDdEMsZUFBUyxZQUFZO0FBQ3JCLGFBQU8sU0FBUyxRQUFROztJQUcxQixjQUFjLElBQUc7QUFBRSxhQUFPLEdBQUcsU0FBUyxVQUFVLEdBQUcsYUFBYSxvQkFBb0I7O0lBRXBGLGlCQUFpQixNQUFLO0FBQUUsYUFBTyxLQUFLLElBQUksTUFBTSxzQkFBc0I7O0lBRXBFLHNCQUFzQixNQUFNLEtBQUk7QUFDOUIsYUFBTyxLQUFLLHlCQUF5QixLQUFLLElBQUksTUFBTSxJQUFJLGtCQUFrQixVQUFVOztJQUd0RixlQUFlLE1BQUs7QUFDbEIsYUFBTyxLQUFLLE1BQU0sSUFBSSxRQUFRLE1BQU0sZUFBZSxPQUFPOztJQUc1RCxzQkFBc0IsSUFBRztBQUN2QixVQUFHLEtBQUssV0FBVyxLQUFJO0FBQUUsV0FBRyxhQUFhLGFBQWE7O0FBQ3RELFdBQUssV0FBVyxJQUFJLGFBQWE7O0lBR25DLDBCQUEwQixNQUFNLFVBQVM7QUFDdkMsVUFBSSxXQUFXLFNBQVMsY0FBYztBQUN0QyxlQUFTLFlBQVk7QUFDckIsYUFBTyxLQUFLLGdCQUFnQixTQUFTLFNBQVM7O0lBR2hELFVBQVUsSUFBSSxXQUFVO0FBQ3RCLGFBQVEsSUFBRyxhQUFhLGNBQWMsR0FBRyxhQUFhLHdCQUF3Qjs7SUFHaEYsWUFBWSxJQUFJLFdBQVcsYUFBWTtBQUNyQyxhQUFPLEdBQUcsZ0JBQWdCLFlBQVksUUFBUSxHQUFHLGFBQWEsZUFBZTs7SUFHL0UsY0FBYyxJQUFHO0FBQUUsYUFBTyxLQUFLLElBQUksSUFBSSxJQUFJOztJQUUzQyxnQkFBZ0IsSUFBSSxVQUFTO0FBQzNCLGFBQU8sS0FBSyxJQUFJLElBQUksR0FBRyxxQkFBcUIsa0JBQWtCOztJQUdoRSxlQUFlLE1BQU0sTUFBSztBQUN4QixVQUFJLFVBQVUsSUFBSSxJQUFJO0FBQ3RCLGFBQU8sS0FBSyxPQUFPLENBQUMsS0FBSyxRQUFRO0FBQy9CLFlBQUksV0FBVyxJQUFJLGtCQUFrQixVQUFVO0FBRS9DLGFBQUsseUJBQXlCLEtBQUssSUFBSSxNQUFNLFdBQVcsTUFDckQsSUFBSSxDQUFBLE9BQU0sU0FBUyxHQUFHLGFBQWEsaUJBQ25DLFFBQVEsQ0FBQSxhQUFZLElBQUksT0FBTztBQUVsQyxlQUFPO1NBQ047O0lBR0wseUJBQXlCLE9BQU8sUUFBTztBQUNyQyxVQUFHLE9BQU8sY0FBYyxvQkFBbUI7QUFDekMsZUFBTyxNQUFNLE9BQU8sQ0FBQSxPQUFNLEtBQUssbUJBQW1CLElBQUk7YUFDakQ7QUFDTCxlQUFPOzs7SUFJWCxtQkFBbUIsTUFBTSxRQUFPO0FBQzlCLGFBQU0sT0FBTyxLQUFLLFlBQVc7QUFDM0IsWUFBRyxLQUFLLFdBQVcsU0FBUTtBQUFFLGlCQUFPOztBQUNwQyxZQUFHLEtBQUssYUFBYSxpQkFBaUIsTUFBSztBQUFFLGlCQUFPOzs7O0lBSXhELFFBQVEsSUFBSSxLQUFJO0FBQUUsYUFBTyxHQUFHLGdCQUFnQixHQUFHLGFBQWE7O0lBRTVELGNBQWMsSUFBSSxLQUFJO0FBQUUsU0FBRyxnQkFBZ0IsT0FBUSxHQUFHLGFBQWE7O0lBRW5FLFdBQVcsSUFBSSxLQUFLLE9BQU07QUFDeEIsVUFBRyxDQUFDLEdBQUcsY0FBYTtBQUFFLFdBQUcsZUFBZTs7QUFDeEMsU0FBRyxhQUFhLE9BQU87O0lBR3pCLGNBQWMsSUFBSSxLQUFLLFlBQVksWUFBVztBQUM1QyxVQUFJLFdBQVcsS0FBSyxRQUFRLElBQUk7QUFDaEMsVUFBRyxhQUFhLFFBQVU7QUFDeEIsYUFBSyxXQUFXLElBQUksS0FBSyxXQUFXO2FBQy9CO0FBQ0wsYUFBSyxXQUFXLElBQUksS0FBSyxXQUFXOzs7SUFJeEMsYUFBYSxRQUFRLFFBQU87QUFDMUIsVUFBRyxPQUFPLGNBQWE7QUFDckIsZUFBTyxlQUFlLE9BQU87OztJQUlqQyxTQUFTLEtBQUk7QUFDWCxVQUFJLFVBQVUsU0FBUyxjQUFjO0FBQ3JDLFVBQUksRUFBQyxRQUFRLFdBQVUsUUFBUTtBQUMvQixlQUFTLFFBQVEsR0FBRyxVQUFVLEtBQUssTUFBTSxVQUFVOztJQUdyRCxTQUFTLElBQUksT0FBTyxhQUFhLGlCQUFpQixhQUFhLGlCQUFpQixhQUFhLFVBQVM7QUFDcEcsVUFBSSxXQUFXLEdBQUcsYUFBYTtBQUMvQixVQUFJLFdBQVcsR0FBRyxhQUFhO0FBQy9CLFVBQUcsYUFBYSxJQUFHO0FBQUUsbUJBQVc7O0FBQ2hDLFVBQUcsYUFBYSxJQUFHO0FBQUUsbUJBQVc7O0FBQ2hDLFVBQUksUUFBUSxZQUFZO0FBQ3hCLGNBQU87YUFDQTtBQUFNLGlCQUFPO2FBRWI7QUFDSCxjQUFHLEtBQUssS0FBSyxJQUFJLGtCQUFpQjtBQUNoQyxlQUFHLGlCQUFpQixRQUFRLE1BQU07O0FBRXBDOztBQUdBLGNBQUksVUFBVSxTQUFTO0FBQ3ZCLGNBQUksVUFBVSxNQUFNLFdBQVcsS0FBSyxjQUFjLElBQUksYUFBYTtBQUNuRSxjQUFJLGVBQWUsS0FBSyxTQUFTLElBQUksa0JBQWtCO0FBQ3ZELGNBQUcsTUFBTSxVQUFTO0FBQUUsbUJBQU8sU0FBUyxvQ0FBb0M7O0FBQ3hFLGNBQUcsVUFBUztBQUNWLGdCQUFJLGFBQWE7QUFDakIsZ0JBQUcsTUFBTSxTQUFTLFdBQVU7QUFDMUIsa0JBQUksVUFBVSxLQUFLLFFBQVEsSUFBSTtBQUMvQixtQkFBSyxXQUFXLElBQUksbUJBQW1CLE1BQU07QUFDN0MsMkJBQWEsWUFBWSxNQUFNOztBQUdqQyxnQkFBRyxDQUFDLGNBQWMsS0FBSyxRQUFRLElBQUksWUFBVztBQUM1QyxxQkFBTzttQkFDRjtBQUNMO0FBQ0EsbUJBQUssV0FBVyxJQUFJLFdBQVc7QUFDL0IseUJBQVcsTUFBTTtBQUNmLG9CQUFHLGVBQWM7QUFBRSx1QkFBSyxhQUFhLElBQUk7O2lCQUN4Qzs7aUJBRUE7QUFDTCx1QkFBVyxNQUFNO0FBQ2Ysa0JBQUcsZUFBYztBQUFFLHFCQUFLLGFBQWEsSUFBSSxrQkFBa0I7O2VBQzFEOztBQUdMLGNBQUksT0FBTyxHQUFHO0FBQ2QsY0FBRyxRQUFRLEtBQUssS0FBSyxNQUFNLGtCQUFpQjtBQUMxQyxpQkFBSyxpQkFBaUIsVUFBVSxNQUFNO0FBQ3BDLG9CQUFNLEtBQU0sSUFBSSxTQUFTLE1BQU8sV0FBVyxDQUFDLENBQUMsVUFBVTtBQUNyRCxvQkFBSSxRQUFRLEtBQUssY0FBYyxVQUFVO0FBQ3pDLHFCQUFLLFNBQVMsT0FBTztBQUNyQixxQkFBSyxjQUFjLE9BQU87Ozs7QUFJaEMsY0FBRyxLQUFLLEtBQUssSUFBSSxrQkFBaUI7QUFDaEMsZUFBRyxpQkFBaUIsUUFBUSxNQUFNLEtBQUssYUFBYSxJQUFJOzs7O0lBS2hFLGFBQWEsSUFBSSxLQUFLLGNBQWE7QUFDakMsVUFBSSxDQUFDLE9BQU8sV0FBVyxLQUFLLFFBQVEsSUFBSTtBQUN4QyxVQUFHLENBQUMsY0FBYTtBQUFFLHVCQUFlOztBQUNsQyxVQUFHLGlCQUFpQixPQUFNO0FBQ3hCLGFBQUssU0FBUyxJQUFJO0FBQ2xCOzs7SUFJSixLQUFLLElBQUksS0FBSTtBQUNYLFVBQUcsS0FBSyxRQUFRLElBQUksU0FBUyxNQUFLO0FBQUUsZUFBTzs7QUFDM0MsV0FBSyxXQUFXLElBQUksS0FBSztBQUN6QixhQUFPOztJQUdULFNBQVMsSUFBSSxLQUFLLFVBQVUsV0FBVztPQUFJO0FBQ3pDLFVBQUksQ0FBQyxnQkFBZ0IsS0FBSyxRQUFRLElBQUksUUFBUSxDQUFDLEdBQUc7QUFDbEQ7QUFDQSxXQUFLLFdBQVcsSUFBSSxLQUFLLENBQUMsY0FBYztBQUN4QyxhQUFPOztJQUdULGFBQWEsV0FBVyxJQUFJLGdCQUFlO0FBQ3pDLFVBQUksUUFBUSxHQUFHLGdCQUFnQixHQUFHLGFBQWE7QUFFL0MsVUFBSSxRQUFRLFNBQVMsVUFBVSxjQUFjLFFBQVEsbUJBQW1CO0FBQ3hFLFVBQUcsQ0FBQyxPQUFNO0FBQUU7O0FBRVosVUFBRyxDQUFFLE1BQUssUUFBUSxPQUFPLG9CQUFvQixLQUFLLFFBQVEsTUFBTSxNQUFNLHFCQUFvQjtBQUN4RixXQUFHLFVBQVUsSUFBSTs7O0lBSXJCLFVBQVUsU0FBUyxnQkFBZTtBQUNoQyxVQUFHLFFBQVEsTUFBTSxRQUFRLE1BQUs7QUFDNUIsYUFBSyxJQUFJLFFBQVEsTUFBTSxJQUFJLG1CQUFtQixRQUFRLFVBQVUsbUJBQW1CLFFBQVEsVUFBVSxDQUFDLE9BQU87QUFDM0csZUFBSyxZQUFZLElBQUk7Ozs7SUFLM0IsV0FBVyxNQUFLO0FBQ2QsYUFBTyxLQUFLLGdCQUFnQixLQUFLLGFBQWE7O0lBR2hELFlBQVksTUFBSztBQUNmLGFBQU8sS0FBSyxnQkFBZ0IsS0FBSyxhQUFhLGdCQUFnQjs7SUFHaEUsY0FBYyxJQUFHO0FBQ2YsYUFBTyxLQUFLLFdBQVcsTUFBTSxLQUFLLEtBQUssSUFBSSxJQUFJLElBQUksa0JBQWtCOztJQUd2RSxjQUFjLFFBQVEsTUFBTSxPQUFPLElBQUc7QUFDcEMsVUFBSSxVQUFVLEtBQUssWUFBWSxTQUFZLE9BQU8sQ0FBQyxDQUFDLEtBQUs7QUFDekQsVUFBSSxZQUFZLEVBQUMsU0FBa0IsWUFBWSxNQUFNLFFBQVEsS0FBSyxVQUFVO0FBQzVFLFVBQUksUUFBUSxTQUFTLFVBQVUsSUFBSSxXQUFXLFNBQVMsYUFBYSxJQUFJLFlBQVksTUFBTTtBQUMxRixhQUFPLGNBQWM7O0lBR3ZCLFVBQVUsTUFBTSxNQUFLO0FBQ25CLFVBQUcsT0FBUSxTQUFVLGFBQVk7QUFDL0IsZUFBTyxLQUFLLFVBQVU7YUFDakI7QUFDTCxZQUFJLFNBQVMsS0FBSyxVQUFVO0FBQzVCLGVBQU8sWUFBWTtBQUNuQixlQUFPOzs7SUFJWCxXQUFXLFFBQVEsUUFBUSxPQUFPLElBQUc7QUFDbkMsVUFBSSxVQUFVLEtBQUssV0FBVztBQUM5QixVQUFJLFlBQVksS0FBSztBQUNyQixVQUFJLGNBQWMsT0FBTztBQUN6QixlQUFRLElBQUksWUFBWSxTQUFTLEdBQUcsS0FBSyxHQUFHLEtBQUk7QUFDOUMsWUFBSSxPQUFPLFlBQVksR0FBRztBQUMxQixZQUFHLFFBQVEsUUFBUSxRQUFRLEdBQUU7QUFBRSxpQkFBTyxhQUFhLE1BQU0sT0FBTyxhQUFhOzs7QUFHL0UsVUFBSSxjQUFjLE9BQU87QUFDekIsZUFBUSxJQUFJLFlBQVksU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFJO0FBQzlDLFlBQUksT0FBTyxZQUFZLEdBQUc7QUFDMUIsWUFBRyxXQUFVO0FBQ1gsY0FBRyxLQUFLLFdBQVcsWUFBWSxDQUFDLE9BQU8sYUFBYSxPQUFNO0FBQUUsbUJBQU8sZ0JBQWdCOztlQUM5RTtBQUNMLGNBQUcsQ0FBQyxPQUFPLGFBQWEsT0FBTTtBQUFFLG1CQUFPLGdCQUFnQjs7Ozs7SUFLN0Qsa0JBQWtCLFFBQVEsUUFBTztBQUUvQixVQUFHLENBQUUsbUJBQWtCLG9CQUFtQjtBQUFFLFlBQUksV0FBVyxRQUFRLFFBQVEsRUFBQyxTQUFTLENBQUM7O0FBQ3RGLFVBQUcsT0FBTyxVQUFTO0FBQ2pCLGVBQU8sYUFBYSxZQUFZO2FBQzNCO0FBQ0wsZUFBTyxnQkFBZ0I7OztJQUkzQixrQkFBa0IsSUFBRztBQUNuQixhQUFPLEdBQUcscUJBQXNCLElBQUcsU0FBUyxVQUFVLEdBQUcsU0FBUzs7SUFHcEUsYUFBYSxTQUFTLGdCQUFnQixjQUFhO0FBQ2pELFVBQUcsQ0FBQyxJQUFJLGVBQWUsVUFBUztBQUFFOztBQUNsQyxVQUFJLGFBQWEsUUFBUSxRQUFRO0FBQ2pDLFVBQUcsUUFBUSxVQUFTO0FBQUUsZ0JBQVE7O0FBQzlCLFVBQUcsQ0FBQyxZQUFXO0FBQUUsZ0JBQVE7O0FBQ3pCLFVBQUcsS0FBSyxrQkFBa0IsVUFBUztBQUNqQyxnQkFBUSxrQkFBa0IsZ0JBQWdCOzs7SUFJOUMsWUFBWSxJQUFHO0FBQUUsYUFBTywrQkFBK0IsS0FBSyxHQUFHLFlBQVksR0FBRyxTQUFTOztJQUV2RixpQkFBaUIsSUFBRztBQUNsQixVQUFHLGNBQWMsb0JBQW9CLGlCQUFpQixRQUFRLEdBQUcsS0FBSyx3QkFBd0IsR0FBRTtBQUM5RixXQUFHLFVBQVUsR0FBRyxhQUFhLGVBQWU7OztJQUloRCxlQUFlLElBQUc7QUFBRSxhQUFPLGlCQUFpQixRQUFRLEdBQUcsU0FBUzs7SUFFaEUseUJBQXlCLElBQUksb0JBQW1CO0FBQzlDLGFBQU8sR0FBRyxnQkFBZ0IsR0FBRyxhQUFhLHdCQUF3Qjs7SUFHcEUsZUFBZSxRQUFRLE1BQU0sYUFBWTtBQUN2QyxVQUFJLE1BQU0sT0FBTyxhQUFhO0FBQzlCLFVBQUcsUUFBUSxNQUFLO0FBQUUsZUFBTzs7QUFDekIsVUFBSSxTQUFTLE9BQU8sYUFBYTtBQUVqQyxVQUFHLElBQUksWUFBWSxXQUFXLE9BQU8sYUFBYSxpQkFBaUIsTUFBSztBQUN0RSxZQUFHLElBQUksY0FBYyxTQUFRO0FBQUUsY0FBSSxXQUFXLFFBQVEsTUFBTSxFQUFDLFdBQVc7O0FBQ3hFLFlBQUksV0FBVyxRQUFRLFNBQVM7QUFDaEMsZUFBTzthQUNGO0FBQ0wsMEJBQWtCLFFBQVEsQ0FBQSxjQUFhO0FBQ3JDLGlCQUFPLFVBQVUsU0FBUyxjQUFjLEtBQUssVUFBVSxJQUFJOztBQUU3RCxhQUFLLGFBQWEsU0FBUztBQUMzQixhQUFLLGFBQWEsYUFBYTtBQUMvQixlQUFPOzs7SUFJWCxnQkFBZ0IsV0FBVyxXQUFVO0FBQ25DLFVBQUcsSUFBSSxZQUFZLFdBQVcsV0FBVyxDQUFDLFVBQVUsYUFBWTtBQUM5RCxZQUFJLFdBQVc7QUFDZixrQkFBVSxXQUFXLFFBQVEsQ0FBQSxjQUFhO0FBQ3hDLGNBQUcsQ0FBQyxVQUFVLElBQUc7QUFFZixnQkFBSSxrQkFBa0IsVUFBVSxhQUFhLEtBQUssYUFBYSxVQUFVLFVBQVUsV0FBVztBQUM5RixnQkFBRyxDQUFDLGlCQUFnQjtBQUNsQix1QkFBUzs7MEJBQ3FCLFdBQVUsYUFBYSxVQUFVLFdBQVc7Ozs7QUFFNUUscUJBQVMsS0FBSzs7O0FBR2xCLGlCQUFTLFFBQVEsQ0FBQSxjQUFhLFVBQVU7OztJQUk1QyxxQkFBcUIsV0FBVyxTQUFTLE9BQU07QUFDN0MsVUFBSSxnQkFBZ0Isb0JBQUksSUFBSSxDQUFDLE1BQU0sYUFBYSxZQUFZLFVBQVU7QUFDdEUsVUFBRyxVQUFVLFFBQVEsa0JBQWtCLFFBQVEsZUFBYztBQUMzRCxjQUFNLEtBQUssVUFBVSxZQUNsQixPQUFPLENBQUEsU0FBUSxDQUFDLGNBQWMsSUFBSSxLQUFLLEtBQUssZ0JBQzVDLFFBQVEsQ0FBQSxTQUFRLFVBQVUsZ0JBQWdCLEtBQUs7QUFFbEQsZUFBTyxLQUFLLE9BQ1QsT0FBTyxDQUFBLFNBQVEsQ0FBQyxjQUFjLElBQUksS0FBSyxnQkFDdkMsUUFBUSxDQUFBLFNBQVEsVUFBVSxhQUFhLE1BQU0sTUFBTTtBQUV0RCxlQUFPO2FBRUY7QUFDTCxZQUFJLGVBQWUsU0FBUyxjQUFjO0FBQzFDLGVBQU8sS0FBSyxPQUFPLFFBQVEsQ0FBQSxTQUFRLGFBQWEsYUFBYSxNQUFNLE1BQU07QUFDekUsc0JBQWMsUUFBUSxDQUFBLFNBQVEsYUFBYSxhQUFhLE1BQU0sVUFBVSxhQUFhO0FBQ3JGLHFCQUFhLFlBQVksVUFBVTtBQUNuQyxrQkFBVSxZQUFZO0FBQ3RCLGVBQU87OztJQUlYLFVBQVUsSUFBSSxNQUFNLFlBQVc7QUFDN0IsVUFBSSxLQUFNLEtBQUksUUFBUSxJQUFJLGFBQWEsSUFBSSxLQUFLLENBQUMsQ0FBQyxrQkFBb0IsU0FBUztBQUMvRSxVQUFHLElBQUc7QUFDSixZQUFJLENBQUMsT0FBTyxLQUFLLGlCQUFpQjtBQUNsQyxlQUFPO2FBQ0Y7QUFDTCxlQUFPLE9BQU8sZUFBZ0IsYUFBYSxlQUFlOzs7SUFJOUQsYUFBYSxJQUFJLE1BQUs7QUFDcEIsV0FBSyxjQUFjLElBQUksVUFBVSxJQUFJLENBQUEsUUFBTztBQUMxQyxlQUFPLElBQUksT0FBTyxDQUFDLENBQUMsY0FBYyxPQUFPLGlCQUFpQjs7O0lBSTlELFVBQVUsSUFBSSxNQUFNLElBQUc7QUFDckIsVUFBSSxnQkFBZ0IsR0FBRztBQUN2QixXQUFLLGNBQWMsSUFBSSxVQUFVLElBQUksQ0FBQSxRQUFPO0FBQzFDLFlBQUksZ0JBQWdCLElBQUksVUFBVSxDQUFDLENBQUMsa0JBQW9CLFNBQVM7QUFDakUsWUFBRyxpQkFBaUIsR0FBRTtBQUNwQixjQUFJLGlCQUFpQixDQUFDLE1BQU0sSUFBSTtlQUMzQjtBQUNMLGNBQUksS0FBSyxDQUFDLE1BQU0sSUFBSTs7QUFFdEIsZUFBTzs7O0lBSVgsc0JBQXNCLElBQUc7QUFDdkIsVUFBSSxNQUFNLElBQUksUUFBUSxJQUFJO0FBQzFCLFVBQUcsQ0FBQyxLQUFJO0FBQUU7O0FBRVYsVUFBSSxRQUFRLENBQUMsQ0FBQyxNQUFNLElBQUksY0FBYyxLQUFLLFVBQVUsSUFBSSxNQUFNOzs7QUFJbkUsTUFBTyxjQUFRO0FDOVpmLE1BQUEsY0FBQSxNQUFpQztXQUN4QixTQUFTLFFBQVEsTUFBSztBQUMzQixVQUFJLFFBQVEsS0FBSyxZQUFZO0FBQzdCLFVBQUksYUFBYSxPQUFPLGFBQWEsdUJBQXVCLE1BQU07QUFDbEUsVUFBSSxXQUFXLFdBQVcsUUFBUSxhQUFhLFdBQVcsVUFBVTtBQUNwRSxhQUFPLEtBQUssT0FBTyxLQUFNLFVBQVM7O1dBRzdCLGNBQWMsUUFBUSxNQUFLO0FBQ2hDLFVBQUksa0JBQWtCLE9BQU8sYUFBYSxzQkFBc0IsTUFBTTtBQUN0RSxVQUFJLGdCQUFnQixnQkFBZ0IsUUFBUSxhQUFhLFdBQVcsVUFBVTtBQUM5RSxhQUFPLGlCQUFpQixLQUFLLFNBQVMsUUFBUTs7SUFHaEQsWUFBWSxRQUFRLE1BQU0sTUFBSztBQUM3QixXQUFLLE1BQU0sYUFBYSxXQUFXO0FBQ25DLFdBQUssU0FBUztBQUNkLFdBQUssT0FBTztBQUNaLFdBQUssT0FBTztBQUNaLFdBQUssT0FBTztBQUNaLFdBQUssZUFBZTtBQUNwQixXQUFLLFVBQVU7QUFDZixXQUFLLFlBQVk7QUFDakIsV0FBSyxvQkFBb0I7QUFDekIsV0FBSyxVQUFVLFdBQVc7O0FBQzFCLFdBQUssZUFBZSxLQUFLLFlBQVksS0FBSztBQUMxQyxXQUFLLE9BQU8saUJBQWlCLHVCQUF1QixLQUFLOztJQUczRCxXQUFVO0FBQUUsYUFBTyxLQUFLOztJQUV4QixTQUFTLFVBQVM7QUFDaEIsV0FBSyxZQUFZLEtBQUssTUFBTTtBQUM1QixVQUFHLEtBQUssWUFBWSxLQUFLLG1CQUFrQjtBQUN6QyxZQUFHLEtBQUssYUFBYSxLQUFJO0FBQ3ZCLGVBQUssWUFBWTtBQUNqQixlQUFLLG9CQUFvQjtBQUN6QixlQUFLLFVBQVU7QUFDZixlQUFLLEtBQUssaUJBQWlCLEtBQUssUUFBUSxLQUFLLEtBQUssS0FBSyxNQUFNO0FBQzNELHlCQUFhLFlBQVksS0FBSyxRQUFRLEtBQUs7QUFDM0MsaUJBQUs7O2VBRUY7QUFDTCxlQUFLLG9CQUFvQixLQUFLO0FBQzlCLGVBQUssS0FBSyxpQkFBaUIsS0FBSyxRQUFRLEtBQUssS0FBSyxLQUFLOzs7O0lBSzdELFNBQVE7QUFDTixXQUFLLGVBQWU7QUFDcEIsV0FBSyxVQUFVO0FBQ2YsV0FBSzs7SUFHUCxTQUFRO0FBQUUsYUFBTyxLQUFLOztJQUV0QixNQUFNLFNBQVMsVUFBUztBQUN0QixXQUFLLEtBQUssaUJBQWlCLEtBQUssUUFBUSxLQUFLLEtBQUssRUFBQyxPQUFPO0FBQzFELG1CQUFhLFdBQVcsS0FBSzs7SUFLL0IsT0FBTyxVQUFTO0FBQ2QsV0FBSyxVQUFVLE1BQU07QUFDbkIsYUFBSyxPQUFPLG9CQUFvQix1QkFBdUIsS0FBSztBQUM1RDs7O0lBSUosY0FBYTtBQUNYLFVBQUksYUFBYSxLQUFLLE9BQU8sYUFBYSx1QkFBdUIsTUFBTTtBQUN2RSxVQUFHLFdBQVcsUUFBUSxLQUFLLFNBQVMsSUFBRztBQUFFLGFBQUs7OztJQUdoRCxxQkFBb0I7QUFDbEIsYUFBTztRQUNMLGVBQWUsS0FBSyxLQUFLO1FBQ3pCLE1BQU0sS0FBSyxLQUFLO1FBQ2hCLE1BQU0sS0FBSyxLQUFLO1FBQ2hCLE1BQU0sS0FBSyxLQUFLO1FBQ2hCLEtBQUssS0FBSzs7O0lBSWQsU0FBUyxXQUFVO0FBQ2pCLFVBQUcsS0FBSyxLQUFLLFVBQVM7QUFDcEIsWUFBSSxXQUFXLFVBQVUsS0FBSyxLQUFLLGFBQWEsU0FBUyw4QkFBOEIsS0FBSyxLQUFLO0FBQ2pHLGVBQU8sRUFBQyxNQUFNLEtBQUssS0FBSyxVQUFVO2FBQzdCO0FBQ0wsZUFBTyxFQUFDLE1BQU0sV0FBVyxVQUFVOzs7SUFJdkMsY0FBYyxNQUFLO0FBQ2pCLFdBQUssT0FBTyxLQUFLLFFBQVEsS0FBSztBQUM5QixVQUFHLENBQUMsS0FBSyxNQUFLO0FBQUUsaUJBQVMsa0RBQWtELEtBQUssT0FBTyxFQUFDLE9BQU8sS0FBSyxRQUFRLFVBQVU7Ozs7QUNsRzFILE1BQUksc0JBQXNCO0FBRTFCLE1BQUEsZUFBQSxNQUFrQztXQUN6QixXQUFXLE1BQUs7QUFDckIsVUFBSSxNQUFNLEtBQUs7QUFDZixVQUFHLFFBQVEsUUFBVTtBQUNuQixlQUFPO2FBQ0Y7QUFDTCxhQUFLLFVBQVcsd0JBQXVCO0FBQ3ZDLGVBQU8sS0FBSzs7O1dBSVQsZ0JBQWdCLFNBQVMsS0FBSyxVQUFTO0FBQzVDLFVBQUksT0FBTyxLQUFLLFlBQVksU0FBUyxLQUFLLENBQUEsVUFBUSxLQUFLLFdBQVcsV0FBVTtBQUM1RSxlQUFTLElBQUksZ0JBQWdCOztXQUd4QixxQkFBcUIsUUFBTztBQUNqQyxVQUFJLFNBQVM7QUFDYixrQkFBSSxpQkFBaUIsUUFBUSxRQUFRLENBQUEsVUFBUztBQUM1QyxZQUFHLE1BQU0sYUFBYSwwQkFBMEIsTUFBTSxhQUFhLGdCQUFlO0FBQ2hGOzs7QUFHSixhQUFPLFNBQVM7O1dBR1gsaUJBQWlCLFNBQVE7QUFDOUIsVUFBSSxRQUFRLEtBQUssWUFBWTtBQUM3QixVQUFJLFdBQVc7QUFDZixZQUFNLFFBQVEsQ0FBQSxTQUFRO0FBQ3BCLFlBQUksUUFBUSxFQUFDLE1BQU0sUUFBUTtBQUMzQixZQUFJLFlBQVksUUFBUSxhQUFhO0FBQ3JDLGlCQUFTLGFBQWEsU0FBUyxjQUFjO0FBQzdDLGNBQU0sTUFBTSxLQUFLLFdBQVc7QUFDNUIsY0FBTSxPQUFPLEtBQUssUUFBUSxNQUFNO0FBQ2hDLGNBQU0sT0FBTyxLQUFLO0FBQ2xCLGNBQU0sT0FBTyxLQUFLO0FBQ2xCLGlCQUFTLFdBQVcsS0FBSzs7QUFFM0IsYUFBTzs7V0FHRixXQUFXLFNBQVE7QUFDeEIsY0FBUSxRQUFRO0FBQ2hCLGNBQVEsZ0JBQWdCO0FBQ3hCLGtCQUFJLFdBQVcsU0FBUyxTQUFTOztXQUc1QixZQUFZLFNBQVMsTUFBSztBQUMvQixrQkFBSSxXQUFXLFNBQVMsU0FBUyxZQUFJLFFBQVEsU0FBUyxTQUFTLE9BQU8sQ0FBQSxNQUFLLENBQUMsT0FBTyxHQUFHLEdBQUc7O1dBR3BGLFdBQVcsU0FBUyxPQUFNO0FBQy9CLFVBQUcsUUFBUSxhQUFhLGdCQUFnQixNQUFLO0FBQzNDLFlBQUksV0FBVyxNQUFNLE9BQU8sQ0FBQSxTQUFRLENBQUMsS0FBSyxZQUFZLFNBQVMsS0FBSyxDQUFBLE1BQUssT0FBTyxHQUFHLEdBQUc7QUFDdEYsb0JBQUksV0FBVyxTQUFTLFNBQVMsS0FBSyxZQUFZLFNBQVMsT0FBTztBQUNsRSxnQkFBUSxRQUFRO2FBQ1g7QUFDTCxvQkFBSSxXQUFXLFNBQVMsU0FBUzs7O1dBSTlCLGlCQUFpQixRQUFPO0FBQzdCLFVBQUksYUFBYSxZQUFJLGlCQUFpQjtBQUN0QyxhQUFPLE1BQU0sS0FBSyxZQUFZLE9BQU8sQ0FBQSxPQUFNLEdBQUcsU0FBUyxLQUFLLFlBQVksSUFBSSxTQUFTOztXQUdoRixZQUFZLE9BQU07QUFDdkIsYUFBUSxhQUFJLFFBQVEsT0FBTyxZQUFZLElBQUksT0FBTyxDQUFBLE1BQUssWUFBWSxTQUFTLE9BQU87O1dBRzlFLHdCQUF3QixRQUFPO0FBQ3BDLFVBQUksYUFBYSxZQUFJLGlCQUFpQjtBQUN0QyxhQUFPLE1BQU0sS0FBSyxZQUFZLE9BQU8sQ0FBQSxVQUFTLEtBQUssdUJBQXVCLE9BQU8sU0FBUzs7V0FHckYsdUJBQXVCLE9BQU07QUFDbEMsYUFBTyxLQUFLLFlBQVksT0FBTyxPQUFPLENBQUEsTUFBSyxDQUFDLFlBQVksY0FBYyxPQUFPOztJQUcvRSxZQUFZLFNBQVMsTUFBTSxZQUFXO0FBQ3BDLFdBQUssT0FBTztBQUNaLFdBQUssYUFBYTtBQUNsQixXQUFLLFdBQ0gsTUFBTSxLQUFLLGFBQWEsdUJBQXVCLFlBQVksSUFDeEQsSUFBSSxDQUFBLFNBQVEsSUFBSSxZQUFZLFNBQVMsTUFBTTtBQUVoRCxXQUFLLHVCQUF1QixLQUFLLFNBQVM7O0lBRzVDLFVBQVM7QUFBRSxhQUFPLEtBQUs7O0lBRXZCLGtCQUFrQixNQUFNLFNBQVMsYUFBVztBQUMxQyxXQUFLLFdBQ0gsS0FBSyxTQUFTLElBQUksQ0FBQSxVQUFTO0FBQ3pCLGNBQU0sY0FBYztBQUNwQixjQUFNLE9BQU8sTUFBTTtBQUNqQixlQUFLO0FBQ0wsY0FBRyxLQUFLLHlCQUF5QixHQUFFO0FBQUUsaUJBQUs7OztBQUU1QyxlQUFPOztBQUdYLFVBQUksaUJBQWlCLEtBQUssU0FBUyxPQUFPLENBQUMsS0FBSyxVQUFVO0FBQ3hELFlBQUksRUFBQyxNQUFNLGFBQVksTUFBTSxTQUFTLFlBQVc7QUFDakQsWUFBSSxRQUFRLElBQUksU0FBUyxFQUFDLFVBQW9CLFNBQVM7QUFDdkQsWUFBSSxNQUFNLFFBQVEsS0FBSztBQUN2QixlQUFPO1NBQ047QUFFSCxlQUFRLFFBQVEsZ0JBQWU7QUFDN0IsWUFBSSxFQUFDLFVBQVUsWUFBVyxlQUFlO0FBQ3pDLGlCQUFTLFNBQVMsU0FBUyxNQUFNOzs7O0FDckh2QyxNQUFJLFFBQVE7SUFDVixnQkFBZ0I7TUFDZCxhQUFZO0FBQUUsZUFBTyxLQUFLLEdBQUcsYUFBYTs7TUFFMUMsa0JBQWlCO0FBQUUsZUFBTyxLQUFLLEdBQUcsYUFBYTs7TUFFL0MsVUFBUztBQUFFLGFBQUssaUJBQWlCLEtBQUs7O01BRXRDLFVBQVM7QUFDUCxZQUFJLGdCQUFnQixLQUFLO0FBQ3pCLFlBQUcsS0FBSyxtQkFBbUIsZUFBYztBQUN2QyxlQUFLLGlCQUFpQjtBQUN0QixjQUFHLGtCQUFrQixJQUFHO0FBQ3RCLGlCQUFLLE9BQU8sYUFBYSxLQUFLLEdBQUc7OztBQUlyQyxZQUFHLEtBQUssaUJBQWlCLElBQUc7QUFBRSxlQUFLLEdBQUcsUUFBUTs7QUFDOUMsYUFBSyxHQUFHLGNBQWMsSUFBSSxZQUFZOzs7SUFJMUMsZ0JBQWdCO01BQ2QsVUFBUztBQUNQLGFBQUssTUFBTSxLQUFLLEdBQUcsYUFBYTtBQUNoQyxhQUFLLFVBQVUsU0FBUyxlQUFlLEtBQUssR0FBRyxhQUFhO0FBQzVELHFCQUFhLGdCQUFnQixLQUFLLFNBQVMsS0FBSyxLQUFLLENBQUEsUUFBTztBQUMxRCxlQUFLLE1BQU07QUFDWCxlQUFLLEdBQUcsTUFBTTs7O01BR2xCLFlBQVc7QUFDVCxZQUFJLGdCQUFnQixLQUFLOzs7O0FBSy9CLE1BQU8sZ0JBQVE7QUN4Q2YsTUFBQSx1QkFBQSxNQUEwQztJQUN4QyxZQUFZLGlCQUFpQixnQkFBZ0IsWUFBVztBQUN0RCxVQUFJLFlBQVksb0JBQUk7QUFDcEIsVUFBSSxXQUFXLElBQUksSUFBSSxDQUFDLEdBQUcsZUFBZSxVQUFVLElBQUksQ0FBQSxVQUFTLE1BQU07QUFFdkUsVUFBSSxtQkFBbUI7QUFFdkIsWUFBTSxLQUFLLGdCQUFnQixVQUFVLFFBQVEsQ0FBQSxVQUFTO0FBQ3BELFlBQUcsTUFBTSxJQUFHO0FBQ1Ysb0JBQVUsSUFBSSxNQUFNO0FBQ3BCLGNBQUcsU0FBUyxJQUFJLE1BQU0sS0FBSTtBQUN4QixnQkFBSSxvQkFBb0IsTUFBTSwwQkFBMEIsTUFBTSx1QkFBdUI7QUFDckYsNkJBQWlCLEtBQUssRUFBQyxXQUFXLE1BQU0sSUFBSTs7OztBQUtsRCxXQUFLLGNBQWMsZUFBZTtBQUNsQyxXQUFLLGFBQWE7QUFDbEIsV0FBSyxtQkFBbUI7QUFDeEIsV0FBSyxrQkFBa0IsQ0FBQyxHQUFHLFVBQVUsT0FBTyxDQUFBLE9BQU0sQ0FBQyxVQUFVLElBQUk7O0lBU25FLFVBQVM7QUFDUCxVQUFJLFlBQVksWUFBSSxLQUFLLEtBQUs7QUFDOUIsV0FBSyxpQkFBaUIsUUFBUSxDQUFBLG9CQUFtQjtBQUMvQyxZQUFHLGdCQUFnQixtQkFBa0I7QUFDbkMsZ0JBQU0sU0FBUyxlQUFlLGdCQUFnQixvQkFBb0IsQ0FBQSxpQkFBZ0I7QUFDaEYsa0JBQU0sU0FBUyxlQUFlLGdCQUFnQixZQUFZLENBQUEsU0FBUTtBQUNoRSxrQkFBSSxpQkFBaUIsS0FBSywwQkFBMEIsS0FBSyx1QkFBdUIsTUFBTSxhQUFhO0FBQ25HLGtCQUFHLENBQUMsZ0JBQWU7QUFDakIsNkJBQWEsc0JBQXNCLFlBQVk7Ozs7ZUFJaEQ7QUFFTCxnQkFBTSxTQUFTLGVBQWUsZ0JBQWdCLFlBQVksQ0FBQSxTQUFRO0FBQ2hFLGdCQUFJLGlCQUFpQixLQUFLLDBCQUEwQjtBQUNwRCxnQkFBRyxDQUFDLGdCQUFlO0FBQ2pCLHdCQUFVLHNCQUFzQixjQUFjOzs7OztBQU10RCxVQUFHLEtBQUssY0FBYyxXQUFVO0FBQzlCLGFBQUssZ0JBQWdCLFVBQVUsUUFBUSxDQUFBLFdBQVU7QUFDL0MsZ0JBQU0sU0FBUyxlQUFlLFNBQVMsQ0FBQSxTQUFRLFVBQVUsc0JBQXNCLGNBQWM7Ozs7O0FDNURyRyxNQUFJLHlCQUF5QjtBQUU3QixzQkFBb0IsVUFBVSxRQUFRO0FBQ2xDLFFBQUksY0FBYyxPQUFPO0FBQ3pCLFFBQUk7QUFDSixRQUFJO0FBQ0osUUFBSTtBQUNKLFFBQUk7QUFDSixRQUFJO0FBR0osUUFBSSxPQUFPLGFBQWEsMEJBQTBCLFNBQVMsYUFBYSx3QkFBd0I7QUFDOUY7O0FBSUYsYUFBUyxJQUFJLFlBQVksU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQzlDLGFBQU8sWUFBWTtBQUNuQixpQkFBVyxLQUFLO0FBQ2hCLHlCQUFtQixLQUFLO0FBQ3hCLGtCQUFZLEtBQUs7QUFFakIsVUFBSSxrQkFBa0I7QUFDbEIsbUJBQVcsS0FBSyxhQUFhO0FBQzdCLG9CQUFZLFNBQVMsZUFBZSxrQkFBa0I7QUFFdEQsWUFBSSxjQUFjLFdBQVc7QUFDekIsY0FBSSxLQUFLLFdBQVcsU0FBUTtBQUN4Qix1QkFBVyxLQUFLOztBQUVwQixtQkFBUyxlQUFlLGtCQUFrQixVQUFVOzthQUVyRDtBQUNILG9CQUFZLFNBQVMsYUFBYTtBQUVsQyxZQUFJLGNBQWMsV0FBVztBQUN6QixtQkFBUyxhQUFhLFVBQVU7Ozs7QUFPNUMsUUFBSSxnQkFBZ0IsU0FBUztBQUU3QixhQUFTLElBQUksY0FBYyxTQUFTLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDaEQsYUFBTyxjQUFjO0FBQ3JCLGlCQUFXLEtBQUs7QUFDaEIseUJBQW1CLEtBQUs7QUFFeEIsVUFBSSxrQkFBa0I7QUFDbEIsbUJBQVcsS0FBSyxhQUFhO0FBRTdCLFlBQUksQ0FBQyxPQUFPLGVBQWUsa0JBQWtCLFdBQVc7QUFDcEQsbUJBQVMsa0JBQWtCLGtCQUFrQjs7YUFFOUM7QUFDSCxZQUFJLENBQUMsT0FBTyxhQUFhLFdBQVc7QUFDaEMsbUJBQVMsZ0JBQWdCOzs7OztBQU16QyxNQUFJO0FBQ0osTUFBSSxXQUFXO0FBRWYsTUFBSSxNQUFNLE9BQU8sYUFBYSxjQUFjLFNBQVk7QUFDeEQsTUFBSSx1QkFBdUIsQ0FBQyxDQUFDLE9BQU8sYUFBYSxJQUFJLGNBQWM7QUFDbkUsTUFBSSxvQkFBb0IsQ0FBQyxDQUFDLE9BQU8sSUFBSSxlQUFlLDhCQUE4QixJQUFJO0FBRXRGLHNDQUFvQyxLQUFLO0FBQ3JDLFFBQUksV0FBVyxJQUFJLGNBQWM7QUFDakMsYUFBUyxZQUFZO0FBQ3JCLFdBQU8sU0FBUyxRQUFRLFdBQVc7O0FBR3ZDLG1DQUFpQyxLQUFLO0FBQ2xDLFFBQUksQ0FBQyxPQUFPO0FBQ1IsY0FBUSxJQUFJO0FBQ1osWUFBTSxXQUFXLElBQUk7O0FBR3pCLFFBQUksV0FBVyxNQUFNLHlCQUF5QjtBQUM5QyxXQUFPLFNBQVMsV0FBVzs7QUFHL0Isa0NBQWdDLEtBQUs7QUFDakMsUUFBSSxXQUFXLElBQUksY0FBYztBQUNqQyxhQUFTLFlBQVk7QUFDckIsV0FBTyxTQUFTLFdBQVc7O0FBVy9CLHFCQUFtQixLQUFLO0FBQ3BCLFVBQU0sSUFBSTtBQUNWLFFBQUksc0JBQXNCO0FBSXhCLGFBQU8sMkJBQTJCO2VBQ3pCLG1CQUFtQjtBQUM1QixhQUFPLHdCQUF3Qjs7QUFHakMsV0FBTyx1QkFBdUI7O0FBYWxDLDRCQUEwQixRQUFRLE1BQU07QUFDcEMsUUFBSSxlQUFlLE9BQU87QUFDMUIsUUFBSSxhQUFhLEtBQUs7QUFDdEIsUUFBSSxlQUFlO0FBRW5CLFFBQUksaUJBQWlCLFlBQVk7QUFDN0IsYUFBTzs7QUFHWCxvQkFBZ0IsYUFBYSxXQUFXO0FBQ3hDLGtCQUFjLFdBQVcsV0FBVztBQU1wQyxRQUFJLGlCQUFpQixNQUFNLGVBQWUsSUFBSTtBQUMxQyxhQUFPLGlCQUFpQixXQUFXO2VBQzVCLGVBQWUsTUFBTSxpQkFBaUIsSUFBSTtBQUNqRCxhQUFPLGVBQWUsYUFBYTtXQUNoQztBQUNILGFBQU87OztBQWFmLDJCQUF5QixNQUFNLGNBQWM7QUFDekMsV0FBTyxDQUFDLGdCQUFnQixpQkFBaUIsV0FDckMsSUFBSSxjQUFjLFFBQ2xCLElBQUksZ0JBQWdCLGNBQWM7O0FBTTFDLHdCQUFzQixRQUFRLE1BQU07QUFDaEMsUUFBSSxXQUFXLE9BQU87QUFDdEIsV0FBTyxVQUFVO0FBQ2IsVUFBSSxZQUFZLFNBQVM7QUFDekIsV0FBSyxZQUFZO0FBQ2pCLGlCQUFXOztBQUVmLFdBQU87O0FBR1gsK0JBQTZCLFFBQVEsTUFBTSxNQUFNO0FBQzdDLFFBQUksT0FBTyxVQUFVLEtBQUssT0FBTztBQUM3QixhQUFPLFFBQVEsS0FBSztBQUNwQixVQUFJLE9BQU8sT0FBTztBQUNkLGVBQU8sYUFBYSxNQUFNO2FBQ3ZCO0FBQ0gsZUFBTyxnQkFBZ0I7Ozs7QUFLbkMsTUFBSSxvQkFBb0I7SUFDcEIsUUFBUSxTQUFTLFFBQVEsTUFBTTtBQUMzQixVQUFJLGFBQWEsT0FBTztBQUN4QixVQUFJLFlBQVk7QUFDWixZQUFJLGFBQWEsV0FBVyxTQUFTO0FBQ3JDLFlBQUksZUFBZSxZQUFZO0FBQzNCLHVCQUFhLFdBQVc7QUFDeEIsdUJBQWEsY0FBYyxXQUFXLFNBQVM7O0FBRW5ELFlBQUksZUFBZSxZQUFZLENBQUMsV0FBVyxhQUFhLGFBQWE7QUFDakUsY0FBSSxPQUFPLGFBQWEsZUFBZSxDQUFDLEtBQUssVUFBVTtBQUluRCxtQkFBTyxhQUFhLFlBQVk7QUFDaEMsbUJBQU8sZ0JBQWdCOztBQUszQixxQkFBVyxnQkFBZ0I7OztBQUduQywwQkFBb0IsUUFBUSxNQUFNOztJQVF0QyxPQUFPLFNBQVMsUUFBUSxNQUFNO0FBQzFCLDBCQUFvQixRQUFRLE1BQU07QUFDbEMsMEJBQW9CLFFBQVEsTUFBTTtBQUVsQyxVQUFJLE9BQU8sVUFBVSxLQUFLLE9BQU87QUFDN0IsZUFBTyxRQUFRLEtBQUs7O0FBR3hCLFVBQUksQ0FBQyxLQUFLLGFBQWEsVUFBVTtBQUM3QixlQUFPLGdCQUFnQjs7O0lBSS9CLFVBQVUsU0FBUyxRQUFRLE1BQU07QUFDN0IsVUFBSSxXQUFXLEtBQUs7QUFDcEIsVUFBSSxPQUFPLFVBQVUsVUFBVTtBQUMzQixlQUFPLFFBQVE7O0FBR25CLFVBQUksYUFBYSxPQUFPO0FBQ3hCLFVBQUksWUFBWTtBQUdaLFlBQUksV0FBVyxXQUFXO0FBRTFCLFlBQUksWUFBWSxZQUFhLENBQUMsWUFBWSxZQUFZLE9BQU8sYUFBYztBQUN2RTs7QUFHSixtQkFBVyxZQUFZOzs7SUFHL0IsUUFBUSxTQUFTLFFBQVEsTUFBTTtBQUMzQixVQUFJLENBQUMsS0FBSyxhQUFhLGFBQWE7QUFDaEMsWUFBSSxnQkFBZ0I7QUFDcEIsWUFBSSxJQUFJO0FBS1IsWUFBSSxXQUFXLE9BQU87QUFDdEIsWUFBSTtBQUNKLFlBQUk7QUFDSixlQUFNLFVBQVU7QUFDWixxQkFBVyxTQUFTLFlBQVksU0FBUyxTQUFTO0FBQ2xELGNBQUksYUFBYSxZQUFZO0FBQ3pCLHVCQUFXO0FBQ1gsdUJBQVcsU0FBUztpQkFDakI7QUFDSCxnQkFBSSxhQUFhLFVBQVU7QUFDdkIsa0JBQUksU0FBUyxhQUFhLGFBQWE7QUFDbkMsZ0NBQWdCO0FBQ2hCOztBQUVKOztBQUVKLHVCQUFXLFNBQVM7QUFDcEIsZ0JBQUksQ0FBQyxZQUFZLFVBQVU7QUFDdkIseUJBQVcsU0FBUztBQUNwQix5QkFBVzs7OztBQUt2QixlQUFPLGdCQUFnQjs7OztBQUtuQyxNQUFJLGVBQWU7QUFDbkIsTUFBSSwyQkFBMkI7QUFDL0IsTUFBSSxZQUFZO0FBQ2hCLE1BQUksZUFBZTtBQUVuQixrQkFBZ0I7O0FBRWhCLDZCQUEyQixNQUFNO0FBQy9CLFFBQUksTUFBTTtBQUNOLGFBQVEsS0FBSyxnQkFBZ0IsS0FBSyxhQUFhLFNBQVUsS0FBSzs7O0FBSXBFLDJCQUF5QixhQUFZO0FBRWpDLFdBQU8sbUJBQWtCLFVBQVUsUUFBUSxTQUFTO0FBQ2hELFVBQUksQ0FBQyxTQUFTO0FBQ1Ysa0JBQVU7O0FBR2QsVUFBSSxPQUFPLFdBQVcsVUFBVTtBQUM1QixZQUFJLFNBQVMsYUFBYSxlQUFlLFNBQVMsYUFBYSxVQUFVLFNBQVMsYUFBYSxRQUFRO0FBQ25HLGNBQUksYUFBYTtBQUNqQixtQkFBUyxJQUFJLGNBQWM7QUFDM0IsaUJBQU8sWUFBWTtlQUNoQjtBQUNILG1CQUFTLFVBQVU7OztBQUkzQixVQUFJLGFBQWEsUUFBUSxjQUFjO0FBQ3ZDLFVBQUksb0JBQW9CLFFBQVEscUJBQXFCO0FBQ3JELFVBQUksY0FBYyxRQUFRLGVBQWU7QUFDekMsVUFBSSxvQkFBb0IsUUFBUSxxQkFBcUI7QUFDckQsVUFBSSxjQUFjLFFBQVEsZUFBZTtBQUN6QyxVQUFJLHdCQUF3QixRQUFRLHlCQUF5QjtBQUM3RCxVQUFJLGtCQUFrQixRQUFRLG1CQUFtQjtBQUNqRCxVQUFJLDRCQUE0QixRQUFRLDZCQUE2QjtBQUNyRSxVQUFJLGVBQWUsUUFBUSxpQkFBaUI7QUFHNUMsVUFBSSxrQkFBa0IsT0FBTyxPQUFPO0FBQ3BDLFVBQUksbUJBQW1CO0FBRXZCLCtCQUF5QixLQUFLO0FBQzFCLHlCQUFpQixLQUFLOztBQUcxQix1Q0FBaUMsTUFBTSxnQkFBZ0I7QUFDbkQsWUFBSSxLQUFLLGFBQWEsY0FBYztBQUNoQyxjQUFJLFdBQVcsS0FBSztBQUNwQixpQkFBTyxVQUFVO0FBRWIsZ0JBQUksTUFBTTtBQUVWLGdCQUFJLGtCQUFtQixPQUFNLFdBQVcsWUFBWTtBQUdoRCw4QkFBZ0I7bUJBQ2I7QUFJSCw4QkFBZ0I7QUFDaEIsa0JBQUksU0FBUyxZQUFZO0FBQ3JCLHdDQUF3QixVQUFVOzs7QUFJMUMsdUJBQVcsU0FBUzs7OztBQWFoQywwQkFBb0IsTUFBTSxZQUFZLGdCQUFnQjtBQUNsRCxZQUFJLHNCQUFzQixVQUFVLE9BQU87QUFDdkM7O0FBR0osWUFBSSxZQUFZO0FBQ1oscUJBQVcsWUFBWTs7QUFHM0Isd0JBQWdCO0FBQ2hCLGdDQUF3QixNQUFNOztBQStCbEMseUJBQW1CLE1BQU07QUFDckIsWUFBSSxLQUFLLGFBQWEsZ0JBQWdCLEtBQUssYUFBYSwwQkFBMEI7QUFDOUUsY0FBSSxXQUFXLEtBQUs7QUFDcEIsaUJBQU8sVUFBVTtBQUNiLGdCQUFJLE1BQU0sV0FBVztBQUNyQixnQkFBSSxLQUFLO0FBQ0wsOEJBQWdCLE9BQU87O0FBSTNCLHNCQUFVO0FBRVYsdUJBQVcsU0FBUzs7OztBQUtoQyxnQkFBVTtBQUVWLCtCQUF5QixJQUFJO0FBQ3pCLG9CQUFZO0FBRVosWUFBSSxXQUFXLEdBQUc7QUFDbEIsZUFBTyxVQUFVO0FBQ2IsY0FBSSxjQUFjLFNBQVM7QUFFM0IsY0FBSSxNQUFNLFdBQVc7QUFDckIsY0FBSSxLQUFLO0FBQ0wsZ0JBQUksa0JBQWtCLGdCQUFnQjtBQUd0QyxnQkFBSSxtQkFBbUIsaUJBQWlCLFVBQVUsa0JBQWtCO0FBQ2hFLHVCQUFTLFdBQVcsYUFBYSxpQkFBaUI7QUFDbEQsc0JBQVEsaUJBQWlCO21CQUN0QjtBQUNMLDhCQUFnQjs7aUJBRWY7QUFHTCw0QkFBZ0I7O0FBR2xCLHFCQUFXOzs7QUFJbkIsNkJBQXVCLFFBQVEsa0JBQWtCLGdCQUFnQjtBQUk3RCxlQUFPLGtCQUFrQjtBQUNyQixjQUFJLGtCQUFrQixpQkFBaUI7QUFDdkMsY0FBSyxpQkFBaUIsV0FBVyxtQkFBb0I7QUFHakQsNEJBQWdCO2lCQUNiO0FBR0gsdUJBQVcsa0JBQWtCLFFBQVE7O0FBRXpDLDZCQUFtQjs7O0FBSTNCLHVCQUFpQixRQUFRLE1BQU0sZUFBYztBQUN6QyxZQUFJLFVBQVUsV0FBVztBQUV6QixZQUFJLFNBQVM7QUFHVCxpQkFBTyxnQkFBZ0I7O0FBRzNCLFlBQUksQ0FBQyxlQUFjO0FBRWYsY0FBSSxrQkFBa0IsUUFBUSxVQUFVLE9BQU87QUFDM0M7O0FBSUosc0JBQVcsUUFBUTtBQUVuQixzQkFBWTtBQUVaLGNBQUksMEJBQTBCLFFBQVEsVUFBVSxPQUFPO0FBQ25EOzs7QUFJUixZQUFJLE9BQU8sYUFBYSxZQUFZO0FBQ2xDLHdCQUFjLFFBQVE7ZUFDakI7QUFDTCw0QkFBa0IsU0FBUyxRQUFROzs7QUFJekMsNkJBQXVCLFFBQVEsTUFBTTtBQUNqQyxZQUFJLGlCQUFpQixLQUFLO0FBQzFCLFlBQUksbUJBQW1CLE9BQU87QUFDOUIsWUFBSTtBQUNKLFlBQUk7QUFFSixZQUFJO0FBQ0osWUFBSTtBQUNKLFlBQUk7QUFHSjtBQUFPLGlCQUFPLGdCQUFnQjtBQUMxQiw0QkFBZ0IsZUFBZTtBQUMvQiwyQkFBZSxXQUFXO0FBRzFCLG1CQUFPLGtCQUFrQjtBQUNyQixnQ0FBa0IsaUJBQWlCO0FBRW5DLGtCQUFJLGVBQWUsY0FBYyxlQUFlLFdBQVcsbUJBQW1CO0FBQzFFLGlDQUFpQjtBQUNqQixtQ0FBbUI7QUFDbkI7O0FBR0osK0JBQWlCLFdBQVc7QUFFNUIsa0JBQUksa0JBQWtCLGlCQUFpQjtBQUd2QyxrQkFBSSxlQUFlO0FBRW5CLGtCQUFJLG9CQUFvQixlQUFlLFVBQVU7QUFDN0Msb0JBQUksb0JBQW9CLGNBQWM7QUFHbEMsc0JBQUksY0FBYztBQUdkLHdCQUFJLGlCQUFpQixnQkFBZ0I7QUFJakMsMEJBQUssaUJBQWlCLGdCQUFnQixlQUFnQjtBQUNsRCw0QkFBSSxvQkFBb0IsZ0JBQWdCO0FBTXBDLHlDQUFlOytCQUNaO0FBUUgsaUNBQU8sYUFBYSxnQkFBZ0I7QUFJcEMsOEJBQUksZ0JBQWdCO0FBR2hCLDRDQUFnQjtpQ0FDYjtBQUdILHVDQUFXLGtCQUFrQixRQUFROztBQUd6Qyw2Q0FBbUI7OzZCQUVwQjtBQUdILHVDQUFlOzs7NkJBR2hCLGdCQUFnQjtBQUV2QixtQ0FBZTs7QUFHbkIsaUNBQWUsaUJBQWlCLFNBQVMsaUJBQWlCLGtCQUFrQjtBQUM1RSxzQkFBSSxjQUFjO0FBS2QsNEJBQVEsa0JBQWtCOzsyQkFHdkIsb0JBQW9CLGFBQWEsbUJBQW1CLGNBQWM7QUFFekUsaUNBQWU7QUFHZixzQkFBSSxpQkFBaUIsY0FBYyxlQUFlLFdBQVc7QUFDekQscUNBQWlCLFlBQVksZUFBZTs7OztBQU14RCxrQkFBSSxjQUFjO0FBR2QsaUNBQWlCO0FBQ2pCLG1DQUFtQjtBQUNuQjs7QUFTSixrQkFBSSxnQkFBZ0I7QUFHaEIsZ0NBQWdCO3FCQUNiO0FBR0gsMkJBQVcsa0JBQWtCLFFBQVE7O0FBR3pDLGlDQUFtQjs7QUFPdkIsZ0JBQUksZ0JBQWlCLGtCQUFpQixnQkFBZ0Isa0JBQWtCLGlCQUFpQixnQkFBZ0IsaUJBQWlCO0FBQ3RILHFCQUFPLFlBQVk7QUFFbkIsc0JBQVEsZ0JBQWdCO21CQUNyQjtBQUNILGtCQUFJLDBCQUEwQixrQkFBa0I7QUFDaEQsa0JBQUksNEJBQTRCLE9BQU87QUFDbkMsb0JBQUkseUJBQXlCO0FBQ3pCLG1DQUFpQjs7QUFHckIsb0JBQUksZUFBZSxXQUFXO0FBQzFCLG1DQUFpQixlQUFlLFVBQVUsT0FBTyxpQkFBaUI7O0FBRXRFLHVCQUFPLFlBQVk7QUFDbkIsZ0NBQWdCOzs7QUFJeEIsNkJBQWlCO0FBQ2pCLCtCQUFtQjs7QUFHdkIsc0JBQWMsUUFBUSxrQkFBa0I7QUFFeEMsWUFBSSxtQkFBbUIsa0JBQWtCLE9BQU87QUFDaEQsWUFBSSxrQkFBa0I7QUFDbEIsMkJBQWlCLFFBQVE7OztBQUlqQyxVQUFJLGNBQWM7QUFDbEIsVUFBSSxrQkFBa0IsWUFBWTtBQUNsQyxVQUFJLGFBQWEsT0FBTztBQUV4QixVQUFJLENBQUMsY0FBYztBQUdmLFlBQUksb0JBQW9CLGNBQWM7QUFDbEMsY0FBSSxlQUFlLGNBQWM7QUFDN0IsZ0JBQUksQ0FBQyxpQkFBaUIsVUFBVSxTQUFTO0FBQ3JDLDhCQUFnQjtBQUNoQiw0QkFBYyxhQUFhLFVBQVUsZ0JBQWdCLE9BQU8sVUFBVSxPQUFPOztpQkFFOUU7QUFFSCwwQkFBYzs7bUJBRVgsb0JBQW9CLGFBQWEsb0JBQW9CLGNBQWM7QUFDMUUsY0FBSSxlQUFlLGlCQUFpQjtBQUNoQyxnQkFBSSxZQUFZLGNBQWMsT0FBTyxXQUFXO0FBQzVDLDBCQUFZLFlBQVksT0FBTzs7QUFHbkMsbUJBQU87aUJBQ0o7QUFFSCwwQkFBYzs7OztBQUsxQixVQUFJLGdCQUFnQixRQUFRO0FBR3hCLHdCQUFnQjthQUNiO0FBQ0gsWUFBSSxPQUFPLGNBQWMsT0FBTyxXQUFXLGNBQWM7QUFDckQ7O0FBR0osZ0JBQVEsYUFBYSxRQUFRO0FBTzdCLFlBQUksa0JBQWtCO0FBQ2xCLG1CQUFTLElBQUUsR0FBRyxNQUFJLGlCQUFpQixRQUFRLElBQUUsS0FBSyxLQUFLO0FBQ25ELGdCQUFJLGFBQWEsZ0JBQWdCLGlCQUFpQjtBQUNsRCxnQkFBSSxZQUFZO0FBQ1oseUJBQVcsWUFBWSxXQUFXLFlBQVk7Ozs7O0FBTTlELFVBQUksQ0FBQyxnQkFBZ0IsZ0JBQWdCLFlBQVksU0FBUyxZQUFZO0FBQ2xFLFlBQUksWUFBWSxXQUFXO0FBQ3ZCLHdCQUFjLFlBQVksVUFBVSxTQUFTLGlCQUFpQjs7QUFPbEUsaUJBQVMsV0FBVyxhQUFhLGFBQWE7O0FBR2xELGFBQU87OztBQUlmLE1BQUksV0FBVyxnQkFBZ0I7QUFFL0IsTUFBTyx1QkFBUTtBQzV0QmYsTUFBQSxXQUFBLE1BQThCO1dBQ3JCLFFBQVEsUUFBUSxNQUFNLGVBQWM7QUFDekMsMkJBQVMsUUFBUSxNQUFNO1FBQ3JCLGNBQWM7UUFDZCxtQkFBbUIsQ0FBQyxTQUFRLFVBQVM7QUFDbkMsY0FBRyxpQkFBaUIsY0FBYyxXQUFXLFlBQVcsWUFBSSxZQUFZLFVBQVE7QUFDOUUsd0JBQUksa0JBQWtCLFNBQVE7QUFDOUIsbUJBQU87Ozs7O0lBTWYsWUFBWSxNQUFNLFdBQVcsSUFBSSxNQUFNLFdBQVU7QUFDL0MsV0FBSyxPQUFPO0FBQ1osV0FBSyxhQUFhLEtBQUs7QUFDdkIsV0FBSyxZQUFZO0FBQ2pCLFdBQUssS0FBSztBQUNWLFdBQUssU0FBUyxLQUFLLEtBQUs7QUFDeEIsV0FBSyxPQUFPO0FBQ1osV0FBSyxZQUFZO0FBQ2pCLFdBQUssV0FBVyxNQUFNLEtBQUs7QUFDM0IsV0FBSyxZQUFZO1FBQ2YsYUFBYTtRQUFJLGVBQWU7UUFBSSxxQkFBcUI7UUFDekQsWUFBWTtRQUFJLGNBQWM7UUFBSSxnQkFBZ0I7UUFBSSxvQkFBb0I7UUFDMUUsMkJBQTJCOzs7SUFJL0IsT0FBTyxNQUFNLFVBQVM7QUFBRSxXQUFLLFVBQVUsU0FBUyxRQUFRLEtBQUs7O0lBQzdELE1BQU0sTUFBTSxVQUFTO0FBQUUsV0FBSyxVQUFVLFFBQVEsUUFBUSxLQUFLOztJQUUzRCxZQUFZLFNBQVMsTUFBSztBQUN4QixXQUFLLFVBQVUsU0FBUyxRQUFRLFFBQVEsQ0FBQSxhQUFZLFNBQVMsR0FBRzs7SUFHbEUsV0FBVyxTQUFTLE1BQUs7QUFDdkIsV0FBSyxVQUFVLFFBQVEsUUFBUSxRQUFRLENBQUEsYUFBWSxTQUFTLEdBQUc7O0lBR2pFLGdDQUErQjtBQUM3QixrQkFBSSxJQUFJLEtBQUssV0FBVyxxREFBcUQsQ0FBQSxPQUFNO0FBQ2pGLFdBQUcsYUFBYSxXQUFXOzs7SUFJL0IsVUFBUztBQUNQLFVBQUksRUFBQyxNQUFNLHlCQUFZLFdBQVcsU0FBUTtBQUMxQyxVQUFJLGtCQUFrQixLQUFLLGVBQWUsS0FBSyxtQkFBbUIsUUFBUTtBQUMxRSxVQUFHLEtBQUssZ0JBQWdCLENBQUMsaUJBQWdCO0FBQUU7O0FBRTNDLFVBQUksVUFBVSxZQUFXO0FBQ3pCLFVBQUksRUFBQyxnQkFBZ0IsaUJBQWdCLFdBQVcsWUFBSSxrQkFBa0IsV0FBVyxVQUFVO0FBQzNGLFVBQUksWUFBWSxZQUFXLFFBQVE7QUFDbkMsVUFBSSxpQkFBaUIsWUFBVyxRQUFRO0FBQ3hDLFVBQUksY0FBYyxZQUFXLFFBQVE7QUFDckMsVUFBSSxxQkFBcUIsWUFBVyxRQUFRO0FBQzVDLFVBQUksWUFBWSxZQUFXLFFBQVE7QUFDbkMsVUFBSSxRQUFRO0FBQ1osVUFBSSxVQUFVO0FBQ2QsVUFBSSx1QkFBdUI7QUFDM0IsVUFBSSxpQkFBaUI7QUFDckIsVUFBSSx3QkFBd0I7QUFFNUIsVUFBSSxXQUFXLFlBQVcsS0FBSywyQkFBMkIsTUFBTTtBQUM5RCxlQUFPLEtBQUssY0FBYyxXQUFXLE1BQU0sV0FBVzs7QUFHeEQsV0FBSyxZQUFZLFNBQVM7QUFDMUIsV0FBSyxZQUFZLFdBQVcsV0FBVztBQUV2QyxrQkFBVyxLQUFLLFlBQVksTUFBTTtBQUNoQyw2QkFBUyxpQkFBaUIsVUFBVTtVQUNsQyxjQUFjLGdCQUFnQixhQUFhLG1CQUFtQjtVQUM5RCxZQUFZLENBQUMsU0FBUztBQUNwQixtQkFBTyxZQUFJLGVBQWUsUUFBUSxPQUFPLEtBQUs7O1VBRWhELG1CQUFtQixDQUFDLE9BQU87QUFDekIsaUJBQUssWUFBWSxTQUFTO0FBQzFCLG1CQUFPOztVQUVULGFBQWEsQ0FBQyxPQUFPO0FBRW5CLGdCQUFHLGNBQWMsb0JBQW9CLEdBQUcsUUFBTztBQUM3QyxpQkFBRyxTQUFTLEdBQUc7dUJBQ1AsY0FBYyxvQkFBb0IsR0FBRyxVQUFTO0FBQ3RELGlCQUFHOztBQUVMLGdCQUFHLFlBQUkseUJBQXlCLElBQUkscUJBQW9CO0FBQ3RELHNDQUF3Qjs7QUFHMUIsd0JBQUksYUFBYSxpQkFBaUIsSUFBSTtBQUV0QyxnQkFBSSxZQUFJLFdBQVcsT0FBTyxLQUFLLFlBQVksT0FBUSxZQUFJLFlBQVksT0FBTyxLQUFLLFlBQVksR0FBRyxhQUFZO0FBQ3hHLG1CQUFLLFdBQVcsaUJBQWlCOztBQUVuQyxrQkFBTSxLQUFLOztVQUViLGlCQUFpQixDQUFDLE9BQU87QUFFdkIsZ0JBQUcsWUFBSSxXQUFXLE9BQU8sWUFBSSxZQUFZLEtBQUk7QUFBRSwwQkFBVyxnQkFBZ0I7O0FBQzFFLGlCQUFLLFdBQVcsYUFBYTs7VUFFL0IsdUJBQXVCLENBQUMsT0FBTztBQUM3QixnQkFBRyxHQUFHLGdCQUFnQixHQUFHLGFBQWEsZUFBZSxNQUFLO0FBQUUscUJBQU87O0FBQ25FLGdCQUFHLEdBQUcsZUFBZSxRQUFRLFlBQUksWUFBWSxHQUFHLFlBQVksV0FBVyxDQUFDLFVBQVUsZUFBZSxHQUFHLElBQUc7QUFBRSxxQkFBTzs7QUFDaEgsZ0JBQUcsR0FBRyxnQkFBZ0IsR0FBRyxhQUFhLFlBQVc7QUFDL0MsNkJBQWUsS0FBSztBQUNwQixxQkFBTzs7QUFFVCxnQkFBRyxLQUFLLGVBQWUsS0FBSTtBQUFFLHFCQUFPOztBQUNwQyxtQkFBTzs7VUFFVCxhQUFhLENBQUMsT0FBTztBQUNuQixnQkFBRyxZQUFJLHlCQUF5QixJQUFJLHFCQUFvQjtBQUN0RCxzQ0FBd0I7O0FBRTFCLG9CQUFRLEtBQUs7O1VBRWYsbUJBQW1CLENBQUMsUUFBUSxTQUFTO0FBQ25DLHdCQUFJLGdCQUFnQixNQUFNO0FBQzFCLGdCQUFHLEtBQUssZUFBZSxPQUFNO0FBQUUscUJBQU87O0FBQ3RDLGdCQUFHLFlBQUksWUFBWSxTQUFRO0FBQUUscUJBQU87O0FBQ3BDLGdCQUFHLFlBQUksVUFBVSxRQUFRLFlBQVc7QUFDbEMsbUJBQUssWUFBWSxXQUFXLFFBQVE7QUFDcEMsMEJBQUksV0FBVyxRQUFRLE1BQU0sRUFBQyxXQUFXO0FBQ3pDLHNCQUFRLEtBQUs7QUFDYiwwQkFBSSxzQkFBc0I7QUFDMUIscUJBQU87O0FBRVQsZ0JBQUcsT0FBTyxTQUFTLFlBQWEsUUFBTyxZQUFZLE9BQU8sU0FBUyxXQUFVO0FBQUUscUJBQU87O0FBQ3RGLGdCQUFHLENBQUMsWUFBSSxlQUFlLFFBQVEsTUFBTSxjQUFhO0FBQ2hELGtCQUFHLFlBQUksY0FBYyxTQUFRO0FBQzNCLHFCQUFLLFlBQVksV0FBVyxRQUFRO0FBQ3BDLHdCQUFRLEtBQUs7O0FBRWYsMEJBQUksc0JBQXNCO0FBQzFCLHFCQUFPOztBQUlULGdCQUFHLFlBQUksV0FBVyxPQUFNO0FBQ3RCLGtCQUFJLGNBQWMsT0FBTyxhQUFhO0FBQ3RDLDBCQUFJLFdBQVcsUUFBUSxNQUFNLEVBQUMsU0FBUyxDQUFDO0FBQ3hDLGtCQUFHLGdCQUFnQixJQUFHO0FBQUUsdUJBQU8sYUFBYSxhQUFhOztBQUN6RCxxQkFBTyxhQUFhLGFBQWEsS0FBSztBQUN0QywwQkFBSSxzQkFBc0I7QUFDMUIscUJBQU87O0FBSVQsd0JBQUksYUFBYSxNQUFNO0FBQ3ZCLHdCQUFJLGFBQWEsaUJBQWlCLE1BQU07QUFFeEMsZ0JBQUksa0JBQWtCLFdBQVcsT0FBTyxXQUFXLFlBQVksWUFBSSxZQUFZO0FBQy9FLGdCQUFHLGlCQUFnQjtBQUNqQixtQkFBSyxZQUFZLFdBQVcsUUFBUTtBQUNwQywwQkFBSSxrQkFBa0IsUUFBUTtBQUM5QiwwQkFBSSxpQkFBaUI7QUFDckIsc0JBQVEsS0FBSztBQUNiLDBCQUFJLHNCQUFzQjtBQUMxQixxQkFBTzttQkFDRjtBQUNMLGtCQUFHLFlBQUksWUFBWSxNQUFNLFdBQVcsQ0FBQyxVQUFVLGFBQVk7QUFDekQscUNBQXFCLEtBQUssSUFBSSxxQkFBcUIsUUFBUSxNQUFNLEtBQUssYUFBYTs7QUFFckYsMEJBQUksaUJBQWlCO0FBQ3JCLDBCQUFJLHNCQUFzQjtBQUMxQixtQkFBSyxZQUFZLFdBQVcsUUFBUTtBQUNwQyxxQkFBTzs7Ozs7QUFNZixVQUFHLFlBQVcsa0JBQWlCO0FBQUU7O0FBRWpDLFVBQUcscUJBQXFCLFNBQVMsR0FBRTtBQUNqQyxvQkFBVyxLQUFLLHlDQUF5QyxNQUFNO0FBQzdELCtCQUFxQixRQUFRLENBQUEsV0FBVSxPQUFPOzs7QUFJbEQsa0JBQVcsY0FBYyxNQUFNLFlBQUksYUFBYSxTQUFTLGdCQUFnQjtBQUN6RSxrQkFBSSxjQUFjLFVBQVU7QUFDNUIsWUFBTSxRQUFRLENBQUEsT0FBTSxLQUFLLFdBQVcsU0FBUztBQUM3QyxjQUFRLFFBQVEsQ0FBQSxPQUFNLEtBQUssV0FBVyxXQUFXO0FBRWpELFVBQUcsZUFBZSxTQUFTLEdBQUU7QUFDM0Isb0JBQVcsa0JBQWtCO0FBQzdCLG9CQUFXLGlCQUFpQixNQUFNO0FBQ2hDLHlCQUFlLFFBQVEsQ0FBQSxPQUFNO0FBQzNCLGdCQUFJLFFBQVEsWUFBSSxjQUFjO0FBQzlCLGdCQUFHLE9BQU07QUFBRSwwQkFBVyxnQkFBZ0I7O0FBQ3RDLGVBQUc7O0FBRUwsZUFBSyxXQUFXLHdCQUF3Qjs7O0FBSTVDLFVBQUcsdUJBQXNCO0FBQ3ZCLG9CQUFXO0FBQ1gsOEJBQXNCOztBQUV4QixhQUFPOztJQUdULGFBQVk7QUFBRSxhQUFPLEtBQUs7O0lBRTFCLGVBQWUsSUFBRztBQUNoQixhQUFPLEdBQUcsYUFBYSxLQUFLLGdCQUFnQixHQUFHLGFBQWEsY0FBYzs7SUFHNUUsbUJBQW1CLE1BQUs7QUFDdEIsVUFBRyxDQUFDLEtBQUssY0FBYTtBQUFFOztBQUN4QixVQUFJLENBQUMsVUFBVSxRQUFRLFlBQUksc0JBQXNCLEtBQUssV0FBVyxLQUFLO0FBQ3RFLFVBQUcsS0FBSyxXQUFXLEtBQUssWUFBSSxnQkFBZ0IsVUFBVSxHQUFFO0FBQ3RELGVBQU87YUFDRjtBQUNMLGVBQU8sU0FBUyxNQUFNOzs7SUFVMUIsY0FBYyxXQUFXLE1BQU0sV0FBVyxpQkFBZ0I7QUFDeEQsVUFBSSxhQUFhLEtBQUs7QUFDdEIsVUFBSSxzQkFBc0IsY0FBYyxnQkFBZ0IsYUFBYSxtQkFBbUIsS0FBSyxVQUFVO0FBQ3ZHLFVBQUcsQ0FBQyxjQUFjLHFCQUFvQjtBQUNwQyxlQUFPO2FBQ0Y7QUFFTCxZQUFJLGdCQUFnQjtBQUNwQixZQUFJLFdBQVcsU0FBUyxjQUFjO0FBQ3RDLHdCQUFnQixZQUFJLFVBQVU7QUFDOUIsWUFBSSxDQUFDLG1CQUFtQixRQUFRLFlBQUksc0JBQXNCLGVBQWUsS0FBSztBQUM5RSxpQkFBUyxZQUFZO0FBQ3JCLGFBQUssUUFBUSxDQUFBLE9BQU0sR0FBRztBQUN0QixjQUFNLEtBQUssY0FBYyxZQUFZLFFBQVEsQ0FBQSxVQUFTO0FBRXBELGNBQUcsTUFBTSxNQUFNLE1BQU0sYUFBYSxLQUFLLGdCQUFnQixNQUFNLGFBQWEsbUJBQW1CLEtBQUssVUFBVSxZQUFXO0FBQ3JILGtCQUFNLGFBQWEsVUFBVTtBQUM3QixrQkFBTSxZQUFZOzs7QUFHdEIsY0FBTSxLQUFLLFNBQVMsUUFBUSxZQUFZLFFBQVEsQ0FBQSxPQUFNLGNBQWMsYUFBYSxJQUFJO0FBQ3JGLHVCQUFlO0FBQ2YsZUFBTyxjQUFjOzs7O0FDaFEzQixNQUFBLFdBQUEsTUFBOEI7V0FDckIsUUFBUSxNQUFLO0FBQ2xCLFVBQUksR0FBRSxRQUFRLFFBQVEsU0FBUyxTQUFTLFFBQVEsVUFBUztBQUN6RCxhQUFPLEtBQUs7QUFDWixhQUFPLEtBQUs7QUFDWixhQUFPLEtBQUs7QUFDWixhQUFPLEVBQUMsTUFBTSxPQUFPLE9BQU8sU0FBUyxNQUFNLFFBQVEsVUFBVTs7SUFHL0QsWUFBWSxRQUFRLFVBQVM7QUFDM0IsV0FBSyxTQUFTO0FBQ2QsV0FBSyxXQUFXO0FBQ2hCLFdBQUssVUFBVTs7SUFHakIsZUFBYztBQUFFLGFBQU8sS0FBSzs7SUFFNUIsU0FBUyxVQUFTO0FBQ2hCLGFBQU8sS0FBSyxrQkFBa0IsS0FBSyxVQUFVLEtBQUssU0FBUyxhQUFhOztJQUcxRSxrQkFBa0IsVUFBVSxhQUFhLFNBQVMsYUFBYSxVQUFTO0FBQ3RFLGlCQUFXLFdBQVcsSUFBSSxJQUFJLFlBQVk7QUFDMUMsVUFBSSxTQUFTLEVBQUMsUUFBUSxJQUFJLFlBQXdCO0FBQ2xELFdBQUssZUFBZSxVQUFVLE1BQU07QUFDcEMsYUFBTyxPQUFPOztJQUdoQixjQUFjLE1BQUs7QUFBRSxhQUFPLE9BQU8sS0FBSyxLQUFLLGVBQWUsSUFBSSxJQUFJLENBQUEsTUFBSyxTQUFTOztJQUVsRixvQkFBb0IsTUFBSztBQUN2QixVQUFHLENBQUMsS0FBSyxhQUFZO0FBQUUsZUFBTzs7QUFDOUIsYUFBTyxPQUFPLEtBQUssTUFBTSxXQUFXOztJQUd0QyxhQUFhLE1BQU0sS0FBSTtBQUFFLGFBQU8sS0FBSyxZQUFZOztJQUVqRCxVQUFVLE1BQUs7QUFDYixVQUFJLE9BQU8sS0FBSztBQUNoQixVQUFJLFFBQVE7QUFDWixhQUFPLEtBQUs7QUFDWixXQUFLLFdBQVcsS0FBSyxhQUFhLEtBQUssVUFBVTtBQUNqRCxXQUFLLFNBQVMsY0FBYyxLQUFLLFNBQVMsZUFBZTtBQUV6RCxVQUFHLE1BQUs7QUFDTixZQUFJLE9BQU8sS0FBSyxTQUFTO0FBRXpCLGlCQUFRLE9BQU8sTUFBSztBQUNsQixlQUFLLE9BQU8sS0FBSyxvQkFBb0IsS0FBSyxLQUFLLE1BQU0sTUFBTSxNQUFNOztBQUduRSxpQkFBUSxPQUFPLE1BQUs7QUFBRSxlQUFLLE9BQU8sS0FBSzs7QUFDdkMsYUFBSyxjQUFjOzs7SUFJdkIsb0JBQW9CLEtBQUssT0FBTyxNQUFNLE1BQU0sT0FBTTtBQUNoRCxVQUFHLE1BQU0sTUFBSztBQUNaLGVBQU8sTUFBTTthQUNSO0FBQ0wsWUFBSSxPQUFPLE1BQU0sT0FBTyxNQUFNO0FBRTlCLFlBQUcsTUFBTSxPQUFNO0FBQ2IsY0FBSTtBQUVKLGNBQUcsT0FBTyxHQUFFO0FBQ1Ysb0JBQVEsS0FBSyxvQkFBb0IsTUFBTSxLQUFLLE9BQU8sTUFBTSxNQUFNO2lCQUMxRDtBQUNMLG9CQUFRLEtBQUssQ0FBQzs7QUFHaEIsaUJBQU8sTUFBTTtBQUNiLGtCQUFRLEtBQUssV0FBVyxPQUFPO0FBQy9CLGdCQUFNLFVBQVU7ZUFDWDtBQUNMLGtCQUFRLE1BQU0sWUFBWSxTQUFZLFFBQVEsS0FBSyxXQUFXLEtBQUssUUFBUSxJQUFJOztBQUdqRixjQUFNLE9BQU87QUFDYixlQUFPOzs7SUFJWCxhQUFhLFFBQVEsUUFBTztBQUMxQixVQUFHLE9BQU8sWUFBWSxRQUFVO0FBQzlCLGVBQU87YUFDRjtBQUNMLGFBQUssZUFBZSxRQUFRO0FBQzVCLGVBQU87OztJQUlYLGVBQWUsUUFBUSxRQUFPO0FBQzVCLGVBQVEsT0FBTyxRQUFPO0FBQ3BCLFlBQUksTUFBTSxPQUFPO0FBQ2pCLFlBQUksWUFBWSxPQUFPO0FBQ3ZCLFlBQUcsU0FBUyxRQUFRLElBQUksWUFBWSxVQUFhLFNBQVMsWUFBVztBQUNuRSxlQUFLLGVBQWUsV0FBVztlQUMxQjtBQUNMLGlCQUFPLE9BQU87Ozs7SUFLcEIsV0FBVyxRQUFRLFFBQU87QUFDeEIsVUFBSSxTQUFTLGtDQUFJLFNBQVc7QUFDNUIsZUFBUSxPQUFPLFFBQU87QUFDcEIsWUFBSSxNQUFNLE9BQU87QUFDakIsWUFBSSxZQUFZLE9BQU87QUFDdkIsWUFBRyxTQUFTLFFBQVEsSUFBSSxZQUFZLFVBQWEsU0FBUyxZQUFXO0FBQ25FLGlCQUFPLE9BQU8sS0FBSyxXQUFXLFdBQVc7OztBQUc3QyxhQUFPOztJQUdULGtCQUFrQixLQUFJO0FBQUUsYUFBTyxLQUFLLHFCQUFxQixLQUFLLFNBQVMsYUFBYTs7SUFFcEYsVUFBVSxNQUFLO0FBQ2IsV0FBSyxRQUFRLENBQUEsUUFBTyxPQUFPLEtBQUssU0FBUyxZQUFZOztJQUt2RCxNQUFLO0FBQUUsYUFBTyxLQUFLOztJQUVuQixpQkFBaUIsT0FBTyxJQUFHO0FBQUUsYUFBTyxDQUFDLENBQUMsS0FBSzs7SUFFM0MsZUFBZSxNQUFNLFdBQVU7QUFDN0IsVUFBRyxPQUFRLFNBQVUsVUFBVTtBQUM3QixlQUFPLFVBQVU7YUFDWjtBQUNMLGVBQU87OztJQUlYLGVBQWUsVUFBVSxXQUFXLFFBQU87QUFDekMsVUFBRyxTQUFTLFdBQVU7QUFBRSxlQUFPLEtBQUssc0JBQXNCLFVBQVUsV0FBVzs7QUFDL0UsVUFBSSxHQUFFLFNBQVMsWUFBVztBQUMxQixnQkFBVSxLQUFLLGVBQWUsU0FBUztBQUV2QyxhQUFPLFVBQVUsUUFBUTtBQUN6QixlQUFRLElBQUksR0FBRyxJQUFJLFFBQVEsUUFBUSxLQUFJO0FBQ3JDLGFBQUssZ0JBQWdCLFNBQVMsSUFBSSxJQUFJLFdBQVc7QUFDakQsZUFBTyxVQUFVLFFBQVE7OztJQUk3QixzQkFBc0IsVUFBVSxXQUFXLFFBQU87QUFDaEQsVUFBSSxHQUFFLFdBQVcsV0FBVyxTQUFTLFlBQVc7QUFDaEQsZ0JBQVUsS0FBSyxlQUFlLFNBQVM7QUFDdkMsVUFBSSxnQkFBZ0IsYUFBYSxTQUFTO0FBRTFDLGVBQVEsSUFBSSxHQUFHLElBQUksU0FBUyxRQUFRLEtBQUk7QUFDdEMsWUFBSSxVQUFVLFNBQVM7QUFDdkIsZUFBTyxVQUFVLFFBQVE7QUFDekIsaUJBQVEsSUFBSSxHQUFHLElBQUksUUFBUSxRQUFRLEtBQUk7QUFDckMsZUFBSyxnQkFBZ0IsUUFBUSxJQUFJLElBQUksZUFBZTtBQUNwRCxpQkFBTyxVQUFVLFFBQVE7Ozs7SUFLL0IsZ0JBQWdCLFVBQVUsV0FBVyxRQUFPO0FBQzFDLFVBQUcsT0FBUSxhQUFjLFVBQVM7QUFDaEMsZUFBTyxVQUFVLEtBQUsscUJBQXFCLE9BQU8sWUFBWSxVQUFVLE9BQU87aUJBQ3ZFLFNBQVMsV0FBVTtBQUMzQixhQUFLLGVBQWUsVUFBVSxXQUFXO2FBQ3BDO0FBQ0wsZUFBTyxVQUFVOzs7SUFJckIscUJBQXFCLFlBQVksS0FBSyxVQUFTO0FBQzdDLFVBQUksWUFBWSxXQUFXLFFBQVEsU0FBUyx3QkFBd0IsT0FBTztBQUMzRSxVQUFJLFdBQVcsU0FBUyxjQUFjO0FBQ3RDLGVBQVMsWUFBWSxLQUFLLGtCQUFrQixXQUFXLFlBQVk7QUFDbkUsVUFBSSxZQUFZLFNBQVM7QUFDekIsVUFBSSxPQUFPLFlBQVksQ0FBQyxTQUFTLElBQUk7QUFFckMsVUFBSSxDQUFDLGVBQWUsc0JBQ2xCLE1BQU0sS0FBSyxVQUFVLFlBQVksT0FBTyxDQUFDLENBQUMsVUFBVSxnQkFBZ0IsT0FBTyxNQUFNO0FBQy9FLFlBQUcsTUFBTSxhQUFhLEtBQUssY0FBYTtBQUN0QyxjQUFHLE1BQU0sYUFBYSxnQkFBZTtBQUNuQyxtQkFBTyxDQUFDLFVBQVU7O0FBRXBCLGdCQUFNLGFBQWEsZUFBZTtBQUNsQyxjQUFHLENBQUMsTUFBTSxJQUFHO0FBQUUsa0JBQU0sS0FBSyxHQUFHLEtBQUssa0JBQWtCLE9BQU87O0FBQzNELGNBQUcsTUFBSztBQUNOLGtCQUFNLGFBQWEsVUFBVTtBQUM3QixrQkFBTSxZQUFZOztBQUVwQixpQkFBTyxDQUFDLE1BQU07ZUFDVDtBQUNMLGNBQUcsTUFBTSxVQUFVLFdBQVcsSUFBRztBQUMvQixxQkFBUzs7UUFDRSxNQUFNLFVBQVU7OztHQUNaLFNBQVMsVUFBVTtBQUNsQyxrQkFBTSxZQUFZLEtBQUssV0FBVyxNQUFNLFdBQVc7QUFDbkQsbUJBQU8sQ0FBQyxNQUFNO2lCQUNUO0FBQ0wsa0JBQU07QUFDTixtQkFBTyxDQUFDLFVBQVU7OztTQUdyQixDQUFDLE9BQU87QUFFYixVQUFHLENBQUMsaUJBQWlCLENBQUMsb0JBQW1CO0FBQ3ZDLGlCQUFTLDRGQUNQLFNBQVMsVUFBVTtBQUNyQixlQUFPLEtBQUssV0FBVyxJQUFJLEtBQUs7aUJBQ3hCLENBQUMsaUJBQWlCLG9CQUFtQjtBQUM3QyxpQkFBUyxnTEFDUCxTQUFTLFVBQVU7QUFDckIsZUFBTyxTQUFTO2FBQ1g7QUFDTCxlQUFPLFNBQVM7OztJQUlwQixXQUFXLE1BQU0sS0FBSTtBQUNuQixVQUFJLE9BQU8sU0FBUyxjQUFjO0FBQ2xDLFdBQUssWUFBWTtBQUNqQixXQUFLLGFBQWEsZUFBZTtBQUNqQyxhQUFPOzs7QUNsUFgsTUFBSSxhQUFhO0FBQ2pCLE1BQUEsV0FBQSxNQUE4QjtXQUNyQixTQUFRO0FBQUUsYUFBTzs7V0FDakIsVUFBVSxJQUFHO0FBQUUsYUFBTyxHQUFHOztJQUVoQyxZQUFZLE1BQU0sSUFBSSxXQUFVO0FBQzlCLFdBQUssU0FBUztBQUNkLFdBQUssYUFBYSxLQUFLO0FBQ3ZCLFdBQUssY0FBYztBQUNuQixXQUFLLGNBQWMsb0JBQUk7QUFDdkIsV0FBSyxtQkFBbUI7QUFDeEIsV0FBSyxLQUFLO0FBQ1YsV0FBSyxHQUFHLFlBQVksS0FBSyxZQUFZO0FBQ3JDLGVBQVEsT0FBTyxLQUFLLGFBQVk7QUFBRSxhQUFLLE9BQU8sS0FBSyxZQUFZOzs7SUFHakUsWUFBVztBQUFFLFdBQUssV0FBVyxLQUFLOztJQUNsQyxZQUFXO0FBQUUsV0FBSyxXQUFXLEtBQUs7O0lBQ2xDLGlCQUFnQjtBQUFFLFdBQUssZ0JBQWdCLEtBQUs7O0lBQzVDLGNBQWE7QUFBRSxXQUFLLGFBQWEsS0FBSzs7SUFDdEMsZ0JBQWU7QUFDYixVQUFHLEtBQUssa0JBQWlCO0FBQ3ZCLGFBQUssbUJBQW1CO0FBQ3hCLGFBQUssZUFBZSxLQUFLOzs7SUFHN0IsaUJBQWdCO0FBQ2QsV0FBSyxtQkFBbUI7QUFDeEIsV0FBSyxnQkFBZ0IsS0FBSzs7SUFHNUIsVUFBVSxPQUFPLFVBQVUsSUFBSSxVQUFVLFdBQVc7T0FBSTtBQUN0RCxhQUFPLEtBQUssT0FBTyxjQUFjLE1BQU0sT0FBTyxTQUFTOztJQUd6RCxZQUFZLFdBQVcsT0FBTyxVQUFVLElBQUksVUFBVSxXQUFXO09BQUk7QUFDbkUsYUFBTyxLQUFLLE9BQU8sY0FBYyxXQUFXLENBQUMsTUFBTSxjQUFjO0FBQy9ELGVBQU8sS0FBSyxjQUFjLFdBQVcsT0FBTyxTQUFTOzs7SUFJekQsWUFBWSxPQUFPLFVBQVM7QUFDMUIsVUFBSSxjQUFjLENBQUMsYUFBYSxXQUFXLFNBQVMsUUFBUSxTQUFTLFlBQVk7QUFDakYsYUFBTyxpQkFBaUIsT0FBTyxTQUFTO0FBQ3hDLFdBQUssWUFBWSxJQUFJO0FBQ3JCLGFBQU87O0lBR1Qsa0JBQWtCLGFBQVk7QUFDNUIsVUFBSSxRQUFRLFlBQVksTUFBTTtBQUM5QixhQUFPLG9CQUFvQixPQUFPLFNBQVM7QUFDM0MsV0FBSyxZQUFZLE9BQU87O0lBRzFCLE9BQU8sTUFBTSxPQUFNO0FBQ2pCLGFBQU8sS0FBSyxPQUFPLGdCQUFnQixNQUFNOztJQUczQyxTQUFTLFdBQVcsTUFBTSxPQUFNO0FBQzlCLGFBQU8sS0FBSyxPQUFPLGNBQWMsV0FBVyxDQUFBLFNBQVEsS0FBSyxnQkFBZ0IsTUFBTTs7SUFHakYsY0FBYTtBQUNYLFdBQUssWUFBWSxRQUFRLENBQUEsZ0JBQWUsS0FBSyxrQkFBa0I7OztBQzdEbkUsTUFBSSxLQUFLO0lBQ1AsS0FBSyxXQUFXLFVBQVUsTUFBTSxVQUFVLFVBQVM7QUFDakQsVUFBSSxDQUFDLGFBQWEsZUFBZSxZQUFZLENBQUMsTUFBTTtBQUNwRCxVQUFJLFdBQVcsU0FBUyxPQUFPLE9BQU8sTUFDcEMsS0FBSyxNQUFNLFlBQVksQ0FBQyxDQUFDLGFBQWE7QUFFeEMsZUFBUyxRQUFRLENBQUMsQ0FBQyxNQUFNLFVBQVU7QUFDakMsWUFBRyxTQUFTLGVBQWUsWUFBWSxNQUFLO0FBQzFDLGVBQUssT0FBTyxPQUFPLE9BQU8sS0FBSyxRQUFRLElBQUksWUFBWTs7QUFFekQsYUFBSyxZQUFZLFVBQVUsTUFBTSxRQUFRLENBQUEsT0FBTTtBQUM3QyxlQUFLLFFBQVEsUUFBUSxXQUFXLFVBQVUsTUFBTSxVQUFVLElBQUk7Ozs7SUFLcEUsVUFBVSxJQUFHO0FBQ1gsYUFBTyxDQUFDLENBQUUsSUFBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCLFNBQVM7O0lBTzlFLGNBQWMsV0FBVyxVQUFVLE1BQU0sVUFBVSxJQUFJLEVBQUMsSUFBSSxPQUFPLFFBQVEsV0FBUztBQUNsRixlQUFTLFVBQVU7QUFDbkIsYUFBTyxhQUFhO0FBQ3BCLGtCQUFJLGNBQWMsSUFBSSxPQUFPLEVBQUMsUUFBUTs7SUFHeEMsVUFBVSxXQUFXLFVBQVUsTUFBTSxVQUFVLElBQUksTUFBSztBQUN0RCxVQUFHLENBQUMsS0FBSyxlQUFjO0FBQUU7O0FBRXpCLFVBQUksRUFBQyxPQUFPLE1BQU0sUUFBUSxjQUFjLFNBQVMsT0FBTyxlQUFjO0FBQ3RFLFVBQUksV0FBVyxFQUFDLFNBQVMsT0FBTyxRQUFRLGNBQWMsQ0FBQyxDQUFDO0FBQ3hELFVBQUksWUFBWSxjQUFjLFlBQVksYUFBYSxhQUFhO0FBQ3BFLFVBQUksWUFBWSxVQUFVLFVBQVUsYUFBYSxLQUFLLFFBQVEsY0FBYztBQUM1RSxXQUFLLGNBQWMsV0FBVyxDQUFDLFlBQVksY0FBYztBQUN2RCxZQUFHLGNBQWMsVUFBUztBQUN4QixjQUFJLEVBQUMsUUFBUSxTQUFTLGFBQVk7QUFDbEMsb0JBQVUsV0FBWSxxQkFBb0IsbUJBQW1CLFNBQVMsT0FBTztBQUM3RSxjQUFHLFNBQVE7QUFBRSxxQkFBUyxVQUFVOztBQUNoQyxxQkFBVyxVQUFVLFVBQVUsV0FBVyxRQUFRLFNBQVMsVUFBVSxVQUFVO21CQUN2RSxjQUFjLFVBQVM7QUFDL0IscUJBQVcsV0FBVyxVQUFVLFdBQVcsU0FBUyxVQUFVO2VBQ3pEO0FBQ0wscUJBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxTQUFTLFVBQVUsTUFBTTs7OztJQUtwRixlQUFlLFdBQVcsVUFBVSxNQUFNLFVBQVUsSUFBSSxFQUFDLE9BQU8sWUFBWSxRQUFNO0FBQ2hGLFdBQUssbUJBQW1CLElBQUksT0FBTyxJQUFJLFlBQVksTUFBTTs7SUFHM0Qsa0JBQWtCLFdBQVcsVUFBVSxNQUFNLFVBQVUsSUFBSSxFQUFDLE9BQU8sWUFBWSxRQUFNO0FBQ25GLFdBQUssbUJBQW1CLElBQUksSUFBSSxPQUFPLFlBQVksTUFBTTs7SUFHM0QsZ0JBQWdCLFdBQVcsVUFBVSxNQUFNLFVBQVUsSUFBSSxFQUFDLE1BQU0sY0FBWTtBQUMxRSxVQUFJLENBQUMsa0JBQWtCLFNBQVMsa0JBQWtCO0FBQ2xELFVBQUksVUFBVSxNQUFNLEtBQUssbUJBQW1CLElBQUksaUJBQWlCLE9BQU8sVUFBVTtBQUNsRixVQUFJLFNBQVMsTUFBTSxLQUFLLG1CQUFtQixJQUFJLGdCQUFnQixpQkFBaUIsT0FBTztBQUN2RixXQUFLLFdBQVcsTUFBTSxTQUFTOztJQUdqQyxZQUFZLFdBQVcsVUFBVSxNQUFNLFVBQVUsSUFBSSxFQUFDLFNBQVMsS0FBSyxNQUFNLFFBQU07QUFDOUUsV0FBSyxPQUFPLFdBQVcsTUFBTSxJQUFJLFNBQVMsS0FBSyxNQUFNOztJQUd2RCxVQUFVLFdBQVcsVUFBVSxNQUFNLFVBQVUsSUFBSSxFQUFDLFNBQVMsWUFBWSxRQUFNO0FBQzdFLFdBQUssS0FBSyxXQUFXLE1BQU0sSUFBSSxTQUFTLFlBQVk7O0lBR3RELFVBQVUsV0FBVyxVQUFVLE1BQU0sVUFBVSxJQUFJLEVBQUMsU0FBUyxZQUFZLFFBQU07QUFDN0UsV0FBSyxLQUFLLFdBQVcsTUFBTSxJQUFJLFNBQVMsWUFBWTs7SUFHdEQsY0FBYyxXQUFXLFVBQVUsTUFBTSxVQUFVLElBQUksRUFBQyxNQUFNLENBQUMsTUFBTSxRQUFNO0FBQ3pFLFdBQUssaUJBQWlCLElBQUksQ0FBQyxDQUFDLE1BQU0sT0FBTzs7SUFHM0MsaUJBQWlCLFdBQVcsVUFBVSxNQUFNLFVBQVUsSUFBSSxFQUFDLFFBQU07QUFDL0QsV0FBSyxpQkFBaUIsSUFBSSxJQUFJLENBQUM7O0lBS2pDLEtBQUssV0FBVyxNQUFNLElBQUksU0FBUyxZQUFZLE1BQUs7QUFDbEQsVUFBRyxDQUFDLEtBQUssVUFBVSxLQUFJO0FBQ3JCLGFBQUssT0FBTyxXQUFXLE1BQU0sSUFBSSxTQUFTLFlBQVksTUFBTTs7O0lBSWhFLEtBQUssV0FBVyxNQUFNLElBQUksU0FBUyxZQUFZLE1BQUs7QUFDbEQsVUFBRyxLQUFLLFVBQVUsS0FBSTtBQUNwQixhQUFLLE9BQU8sV0FBVyxNQUFNLElBQUksU0FBUyxNQUFNLFlBQVk7OztJQUloRSxPQUFPLFdBQVcsTUFBTSxJQUFJLFNBQVMsS0FBSyxNQUFNLE1BQUs7QUFDbkQsVUFBSSxDQUFDLFdBQVcsZ0JBQWdCLGdCQUFnQixPQUFPLENBQUMsSUFBSSxJQUFJO0FBQ2hFLFVBQUksQ0FBQyxZQUFZLGlCQUFpQixpQkFBaUIsUUFBUSxDQUFDLElBQUksSUFBSTtBQUNwRSxVQUFHLFVBQVUsU0FBUyxLQUFLLFdBQVcsU0FBUyxHQUFFO0FBQy9DLFlBQUcsS0FBSyxVQUFVLEtBQUk7QUFDcEIsY0FBSSxVQUFVLE1BQU07QUFDbEIsaUJBQUssbUJBQW1CLElBQUksaUJBQWlCLFVBQVUsT0FBTyxnQkFBZ0IsT0FBTztBQUNyRixtQkFBTyxzQkFBc0IsTUFBTTtBQUNqQyxtQkFBSyxtQkFBbUIsSUFBSSxZQUFZO0FBQ3hDLHFCQUFPLHNCQUFzQixNQUFNLEtBQUssbUJBQW1CLElBQUksZUFBZTs7O0FBR2xGLGFBQUcsY0FBYyxJQUFJLE1BQU07QUFDM0IsZUFBSyxXQUFXLE1BQU0sU0FBUyxNQUFNO0FBQ25DLGlCQUFLLG1CQUFtQixJQUFJLElBQUksV0FBVyxPQUFPO0FBQ2xELHdCQUFJLFVBQVUsSUFBSSxVQUFVLENBQUEsY0FBYSxVQUFVLE1BQU0sVUFBVTtBQUNuRSxlQUFHLGNBQWMsSUFBSSxNQUFNOztlQUV4QjtBQUNMLGNBQUcsY0FBYyxVQUFTO0FBQUU7O0FBQzVCLGNBQUksVUFBVSxNQUFNO0FBQ2xCLGlCQUFLLG1CQUFtQixJQUFJLGdCQUFnQixXQUFXLE9BQU8saUJBQWlCLE9BQU87QUFDdEYsd0JBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQSxjQUFhLFVBQVUsTUFBTSxVQUFXLFdBQVc7QUFDL0UsbUJBQU8sc0JBQXNCLE1BQU07QUFDakMsbUJBQUssbUJBQW1CLElBQUksV0FBVztBQUN2QyxxQkFBTyxzQkFBc0IsTUFBTSxLQUFLLG1CQUFtQixJQUFJLGNBQWM7OztBQUdqRixhQUFHLGNBQWMsSUFBSSxNQUFNO0FBQzNCLGVBQUssV0FBVyxNQUFNLFNBQVMsTUFBTTtBQUNuQyxpQkFBSyxtQkFBbUIsSUFBSSxJQUFJLFVBQVUsT0FBTztBQUNqRCxlQUFHLGNBQWMsSUFBSSxNQUFNOzs7YUFHMUI7QUFDTCxZQUFHLEtBQUssVUFBVSxLQUFJO0FBQ3BCLGlCQUFPLHNCQUFzQixNQUFNO0FBQ2pDLGVBQUcsY0FBYyxJQUFJLE1BQU07QUFDM0Isd0JBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQSxjQUFhLFVBQVUsTUFBTSxVQUFVO0FBQ25FLGVBQUcsY0FBYyxJQUFJLE1BQU07O2VBRXhCO0FBQ0wsaUJBQU8sc0JBQXNCLE1BQU07QUFDakMsZUFBRyxjQUFjLElBQUksTUFBTTtBQUMzQix3QkFBSSxVQUFVLElBQUksVUFBVSxDQUFBLGNBQWEsVUFBVSxNQUFNLFVBQVUsV0FBVztBQUM5RSxlQUFHLGNBQWMsSUFBSSxNQUFNOzs7OztJQU1uQyxtQkFBbUIsSUFBSSxNQUFNLFNBQVMsWUFBWSxNQUFNLE1BQUs7QUFDM0QsVUFBSSxDQUFDLGdCQUFnQixrQkFBa0Isa0JBQWtCLGNBQWMsQ0FBQyxJQUFJLElBQUk7QUFDaEYsVUFBRyxlQUFlLFNBQVMsR0FBRTtBQUMzQixZQUFJLFVBQVUsTUFBTSxLQUFLLG1CQUFtQixJQUFJLGlCQUFpQixPQUFPLGlCQUFpQjtBQUN6RixZQUFJLFNBQVMsTUFBTSxLQUFLLG1CQUFtQixJQUFJLEtBQUssT0FBTyxpQkFBaUIsUUFBUSxPQUFPLGdCQUFnQixPQUFPO0FBQ2xILGVBQU8sS0FBSyxXQUFXLE1BQU0sU0FBUzs7QUFFeEMsYUFBTyxzQkFBc0IsTUFBTTtBQUNqQyxZQUFJLENBQUMsVUFBVSxlQUFlLFlBQUksVUFBVSxJQUFJLFdBQVcsQ0FBQyxJQUFJO0FBQ2hFLFlBQUksV0FBVyxLQUFLLE9BQU8sQ0FBQSxTQUFRLFNBQVMsUUFBUSxRQUFRLEtBQUssQ0FBQyxHQUFHLFVBQVUsU0FBUztBQUN4RixZQUFJLGNBQWMsUUFBUSxPQUFPLENBQUEsU0FBUSxZQUFZLFFBQVEsUUFBUSxLQUFLLEdBQUcsVUFBVSxTQUFTO0FBQ2hHLFlBQUksVUFBVSxTQUFTLE9BQU8sQ0FBQSxTQUFRLFFBQVEsUUFBUSxRQUFRLEdBQUcsT0FBTztBQUN4RSxZQUFJLGFBQWEsWUFBWSxPQUFPLENBQUEsU0FBUSxLQUFLLFFBQVEsUUFBUSxHQUFHLE9BQU87QUFFM0Usb0JBQUksVUFBVSxJQUFJLFdBQVcsQ0FBQSxjQUFhO0FBQ3hDLG9CQUFVLFVBQVUsT0FBTyxHQUFHO0FBQzlCLG9CQUFVLFVBQVUsSUFBSSxHQUFHO0FBQzNCLGlCQUFPLENBQUMsU0FBUzs7OztJQUt2QixpQkFBaUIsSUFBSSxNQUFNLFNBQVE7QUFDakMsVUFBSSxDQUFDLFVBQVUsZUFBZSxZQUFJLFVBQVUsSUFBSSxTQUFTLENBQUMsSUFBSTtBQUU5RCxVQUFJLGVBQWUsS0FBSyxJQUFJLENBQUMsQ0FBQyxNQUFNLFVBQVUsTUFBTSxPQUFPO0FBQzNELFVBQUksVUFBVSxTQUFTLE9BQU8sQ0FBQyxDQUFDLE1BQU0sVUFBVSxDQUFDLGFBQWEsU0FBUyxPQUFPLE9BQU87QUFDckYsVUFBSSxhQUFhLFlBQVksT0FBTyxDQUFDLFNBQVMsQ0FBQyxhQUFhLFNBQVMsT0FBTyxPQUFPO0FBRW5GLGtCQUFJLFVBQVUsSUFBSSxTQUFTLENBQUEsY0FBYTtBQUN0QyxtQkFBVyxRQUFRLENBQUEsU0FBUSxVQUFVLGdCQUFnQjtBQUNyRCxnQkFBUSxRQUFRLENBQUMsQ0FBQyxNQUFNLFNBQVMsVUFBVSxhQUFhLE1BQU07QUFDOUQsZUFBTyxDQUFDLFNBQVM7OztJQUlyQixjQUFjLElBQUksU0FBUTtBQUFFLGFBQU8sUUFBUSxNQUFNLENBQUEsU0FBUSxHQUFHLFVBQVUsU0FBUzs7SUFFL0UsYUFBYSxJQUFJLFlBQVc7QUFDMUIsYUFBTyxDQUFDLEtBQUssVUFBVSxPQUFPLEtBQUssY0FBYyxJQUFJOztJQUd2RCxZQUFZLFVBQVUsRUFBQyxNQUFJO0FBQ3pCLGFBQU8sS0FBSyxZQUFJLElBQUksVUFBVSxNQUFNLENBQUM7OztBQUl6QyxNQUFPLGFBQVE7QUNwSmYsTUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLE1BQU0sWUFBWSxPQUFPO0FBQ2xELFFBQUksV0FBVyxJQUFJLFNBQVM7QUFDNUIsUUFBSSxXQUFXO0FBRWYsYUFBUyxRQUFRLENBQUMsS0FBSyxLQUFLLFdBQVc7QUFDckMsVUFBRyxlQUFlLE1BQUs7QUFBRSxpQkFBUyxLQUFLOzs7QUFJekMsYUFBUyxRQUFRLENBQUEsUUFBTyxTQUFTLE9BQU87QUFFeEMsUUFBSSxTQUFTLElBQUk7QUFDakIsYUFBUSxDQUFDLEtBQUssUUFBUSxTQUFTLFdBQVU7QUFDdkMsVUFBRyxVQUFVLFdBQVcsS0FBSyxVQUFVLFFBQVEsUUFBUSxHQUFFO0FBQ3ZELGVBQU8sT0FBTyxLQUFLOzs7QUFHdkIsYUFBUSxXQUFXLE1BQUs7QUFBRSxhQUFPLE9BQU8sU0FBUyxLQUFLOztBQUV0RCxXQUFPLE9BQU87O0FBR2hCLE1BQUEsT0FBQSxNQUEwQjtJQUN4QixZQUFZLElBQUksYUFBWSxZQUFZLE9BQU07QUFDNUMsV0FBSyxhQUFhO0FBQ2xCLFdBQUssUUFBUTtBQUNiLFdBQUssU0FBUztBQUNkLFdBQUssT0FBTyxhQUFhLFdBQVcsT0FBTztBQUMzQyxXQUFLLEtBQUs7QUFDVixXQUFLLEtBQUssS0FBSyxHQUFHO0FBQ2xCLFdBQUssTUFBTTtBQUNYLFdBQUssYUFBYTtBQUNsQixXQUFLLGNBQWM7QUFDbkIsV0FBSyxlQUFlO0FBQ3BCLFdBQUssY0FBYztBQUNuQixXQUFLLFdBQVc7QUFDaEIsV0FBSyxPQUFPO0FBQ1osV0FBSyxZQUFZLEtBQUssU0FBUyxLQUFLLE9BQU8sWUFBWSxJQUFJO0FBQzNELFdBQUssY0FBYztBQUNuQixXQUFLLFlBQVk7QUFDakIsV0FBSyxlQUFlLFNBQVMsUUFBTztBQUFFLGtCQUFVOztBQUNoRCxXQUFLLGVBQWUsV0FBVTs7QUFDOUIsV0FBSyxpQkFBaUIsS0FBSyxTQUFTLE9BQU87QUFDM0MsV0FBSyxZQUFZO0FBQ2pCLFdBQUssWUFBWTtBQUNqQixXQUFLLGNBQWM7QUFDbkIsV0FBSyxXQUFXLEtBQUssU0FBUyxPQUFPO0FBQ3JDLFdBQUssS0FBSyxTQUFTLEtBQUssTUFBTTtBQUM5QixXQUFLLFVBQVUsS0FBSyxXQUFXLFFBQVEsTUFBTSxLQUFLLE1BQU0sTUFBTTtBQUM1RCxlQUFPO1VBQ0wsVUFBVSxLQUFLLFdBQVcsS0FBSyxPQUFPO1VBQ3RDLEtBQUssS0FBSyxXQUFXLFNBQVksS0FBSyxRQUFRO1VBQzlDLFFBQVEsS0FBSztVQUNiLFNBQVMsS0FBSztVQUNkLFFBQVEsS0FBSztVQUNiLE9BQU8sS0FBSzs7O0FBR2hCLFdBQUssV0FBVyxLQUFLLFdBQVc7QUFDaEMsV0FBSzs7SUFHUCxRQUFRLE1BQUs7QUFBRSxXQUFLLE9BQU87O0lBRTNCLFlBQVksTUFBSztBQUNmLFdBQUssV0FBVztBQUNoQixXQUFLLE9BQU87O0lBR2QsU0FBUTtBQUFFLGFBQU8sS0FBSyxHQUFHLGFBQWE7O0lBRXRDLGdCQUFlO0FBQ2IsVUFBSSxTQUFTLEtBQUssV0FBVyxPQUFPLEtBQUs7QUFDekMsVUFBSSxXQUNGLFlBQUksSUFBSSxVQUFVLElBQUksS0FBSyxRQUFRLHNCQUNoQyxJQUFJLENBQUEsU0FBUSxLQUFLLE9BQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQSxRQUFPLE9BQVEsUUFBUztBQUV2RSxVQUFHLFNBQVMsU0FBUyxHQUFFO0FBQUUsZUFBTyxtQkFBbUI7O0FBQ25ELGFBQU8sYUFBYSxLQUFLO0FBRXpCLGFBQU87O0lBR1QsY0FBYTtBQUFFLGFBQU8sS0FBSyxRQUFROztJQUVuQyxhQUFZO0FBQUUsYUFBTyxLQUFLLEdBQUcsYUFBYTs7SUFFMUMsWUFBVztBQUNULFVBQUksTUFBTSxLQUFLLEdBQUcsYUFBYTtBQUMvQixhQUFPLFFBQVEsS0FBSyxPQUFPOztJQUc3QixRQUFRLFdBQVcsV0FBVztPQUFJO0FBQ2hDLFdBQUs7QUFDTCxXQUFLLFlBQVk7QUFDakIsYUFBTyxLQUFLLEtBQUssU0FBUyxLQUFLO0FBQy9CLFVBQUcsS0FBSyxRQUFPO0FBQUUsZUFBTyxLQUFLLEtBQUssU0FBUyxLQUFLLE9BQU8sSUFBSSxLQUFLOztBQUNoRSxtQkFBYSxLQUFLO0FBQ2xCLFVBQUksYUFBYSxNQUFNO0FBQ3JCO0FBQ0EsaUJBQVEsTUFBTSxLQUFLLFdBQVU7QUFDM0IsZUFBSyxZQUFZLEtBQUssVUFBVTs7O0FBSXBDLGtCQUFJLHNCQUFzQixLQUFLO0FBRS9CLFdBQUssSUFBSSxhQUFhLE1BQU0sQ0FBQztBQUM3QixXQUFLLFFBQVEsUUFDVixRQUFRLE1BQU0sWUFDZCxRQUFRLFNBQVMsWUFDakIsUUFBUSxXQUFXOztJQUd4Qix1QkFBdUIsU0FBUTtBQUM3QixXQUFLLEdBQUcsVUFBVSxPQUNoQixxQkFDQSx3QkFDQTtBQUVGLFdBQUssR0FBRyxVQUFVLElBQUksR0FBRzs7SUFHM0IsV0FBVyxTQUFRO0FBQ2pCLG1CQUFhLEtBQUs7QUFDbEIsVUFBRyxTQUFRO0FBQ1QsYUFBSyxjQUFjLFdBQVcsTUFBTSxLQUFLLGNBQWM7YUFDbEQ7QUFDTCxpQkFBUSxNQUFNLEtBQUssV0FBVTtBQUFFLGVBQUssVUFBVSxJQUFJOztBQUNsRCxhQUFLLG9CQUFvQjs7O0lBSTdCLGFBQVk7QUFDVixtQkFBYSxLQUFLO0FBQ2xCLFdBQUssb0JBQW9COztJQUczQixxQkFBb0I7QUFDbEIsZUFBUSxNQUFNLEtBQUssV0FBVTtBQUFFLGFBQUssVUFBVSxJQUFJOzs7SUFHcEQsSUFBSSxNQUFNLGFBQVk7QUFDcEIsV0FBSyxXQUFXLElBQUksTUFBTSxNQUFNOztJQUdsQyxXQUFXLE1BQU0sU0FBUyxTQUFTLFdBQVU7T0FBRztBQUM5QyxXQUFLLFdBQVcsV0FBVyxNQUFNLFNBQVM7O0lBRzVDLGNBQWMsV0FBVyxVQUFTO0FBQ2hDLFVBQUcscUJBQXFCLGVBQWUscUJBQXFCLFlBQVc7QUFDckUsZUFBTyxLQUFLLFdBQVcsTUFBTSxXQUFXLENBQUEsU0FBUSxTQUFTLE1BQU07O0FBR2pFLFVBQUcsTUFBTSxZQUFXO0FBQ2xCLFlBQUksVUFBVSxZQUFJLHNCQUFzQixLQUFLLElBQUk7QUFDakQsWUFBRyxRQUFRLFdBQVcsR0FBRTtBQUN0QixtQkFBUyw2Q0FBNkM7ZUFDakQ7QUFDTCxtQkFBUyxNQUFNLFNBQVM7O2FBRXJCO0FBQ0wsWUFBSSxVQUFVLE1BQU0sS0FBSyxTQUFTLGlCQUFpQjtBQUNuRCxZQUFHLFFBQVEsV0FBVyxHQUFFO0FBQUUsbUJBQVMsbURBQW1EOztBQUN0RixnQkFBUSxRQUFRLENBQUEsV0FBVSxLQUFLLFdBQVcsTUFBTSxRQUFRLENBQUEsU0FBUSxTQUFTLE1BQU07OztJQUluRixVQUFVLE1BQU0sU0FBUyxVQUFTO0FBQ2hDLFdBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQyxJQUFJLE1BQU07QUFDaEMsVUFBSSxFQUFDLE1BQU0sT0FBTyxRQUFRLFVBQVMsU0FBUyxRQUFRO0FBQ3BELFVBQUcsT0FBTTtBQUFFLG9CQUFJLFNBQVM7O0FBRXhCLGVBQVMsRUFBQyxNQUFNLE9BQU87QUFDdkIsYUFBTzs7SUFHVCxPQUFPLE1BQUs7QUFDVixVQUFJLEVBQUMsVUFBVSxjQUFhO0FBQzVCLFVBQUcsV0FBVTtBQUNYLFlBQUksQ0FBQyxLQUFLLFNBQVM7QUFDbkIsYUFBSyxLQUFLLFlBQUkscUJBQXFCLEtBQUssSUFBSSxLQUFLOztBQUVuRCxXQUFLLGFBQWE7QUFDbEIsV0FBSyxjQUFjO0FBQ25CLFdBQUssUUFBUTtBQUViLHNCQUFRLFVBQVUsS0FBSyxXQUFXLGNBQWMsT0FBTyxTQUFTLFVBQVU7QUFDMUUsV0FBSyxVQUFVLFNBQVMsVUFBVSxDQUFDLEVBQUMsTUFBTSxhQUFZO0FBQ3BELGFBQUssV0FBVyxJQUFJLFNBQVMsS0FBSyxJQUFJO0FBQ3RDLFlBQUksT0FBTyxLQUFLLGdCQUFnQixNQUFNO0FBQ3RDLGFBQUs7QUFDTCxZQUFJLFFBQVEsS0FBSyxpQkFBaUI7QUFDbEMsYUFBSztBQUVMLFlBQUcsTUFBTSxTQUFTLEdBQUU7QUFDbEIsZ0JBQU0sUUFBUSxDQUFDLENBQUMsTUFBTSxTQUFTLFNBQVMsTUFBTTtBQUM1QyxpQkFBSyxpQkFBaUIsTUFBTSxRQUFRLENBQUEsVUFBUTtBQUMxQyxrQkFBRyxNQUFNLE1BQU0sU0FBUyxHQUFFO0FBQ3hCLHFCQUFLLGVBQWUsT0FBTSxNQUFNOzs7O2VBSWpDO0FBQ0wsZUFBSyxlQUFlLE1BQU0sTUFBTTs7OztJQUt0QyxrQkFBaUI7QUFDZixrQkFBSSxJQUFJLFVBQVUsSUFBSSxnQkFBZ0IsS0FBSyxRQUFRLFlBQVksQ0FBQSxPQUFNO0FBQ25FLFdBQUcsZ0JBQWdCO0FBQ25CLFdBQUcsZ0JBQWdCOzs7SUFJdkIsZUFBZSxFQUFDLGNBQWEsTUFBTSxRQUFPO0FBR3hDLFVBQUcsS0FBSyxZQUFZLEtBQU0sS0FBSyxVQUFVLENBQUMsS0FBSyxPQUFPLGlCQUFpQjtBQUNyRSxlQUFPLEtBQUssZUFBZSxZQUFZLE1BQU07O0FBTy9DLFVBQUksY0FBYyxZQUFJLDBCQUEwQixNQUFNLEtBQUssSUFBSSxPQUFPLENBQUEsU0FBUTtBQUM1RSxZQUFJLFNBQVMsS0FBSyxNQUFNLEtBQUssR0FBRyxjQUFjLFFBQVEsS0FBSztBQUMzRCxZQUFJLFlBQVksVUFBVSxPQUFPLGFBQWE7QUFDOUMsWUFBRyxXQUFVO0FBQUUsZUFBSyxhQUFhLFlBQVk7O0FBQzdDLGVBQU8sS0FBSyxVQUFVOztBQUd4QixVQUFHLFlBQVksV0FBVyxHQUFFO0FBQzFCLFlBQUcsS0FBSyxRQUFPO0FBQ2IsZUFBSyxLQUFLLGVBQWUsS0FBSyxDQUFDLE1BQU0sTUFBTSxLQUFLLGVBQWUsWUFBWSxNQUFNO0FBQ2pGLGVBQUssT0FBTyxRQUFRO2VBQ2Y7QUFDTCxlQUFLO0FBQ0wsZUFBSyxlQUFlLFlBQVksTUFBTTs7YUFFbkM7QUFDTCxhQUFLLEtBQUssZUFBZSxLQUFLLENBQUMsTUFBTSxNQUFNLEtBQUssZUFBZSxZQUFZLE1BQU07OztJQUlyRixrQkFBaUI7QUFDZixXQUFLLEtBQUssWUFBSSxLQUFLLEtBQUs7QUFDeEIsV0FBSyxHQUFHLGFBQWEsYUFBYSxLQUFLLEtBQUs7O0lBRzlDLGVBQWUsWUFBWSxNQUFNLFFBQU87QUFDdEMsV0FBSztBQUNMLFVBQUksUUFBUSxJQUFJLFNBQVMsTUFBTSxLQUFLLElBQUksS0FBSyxJQUFJLE1BQU07QUFDdkQsWUFBTTtBQUNOLFdBQUssYUFBYSxPQUFPO0FBQ3pCLFdBQUs7QUFDTCxrQkFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLEtBQUssUUFBUSx5QkFBeUIsYUFBYSxDQUFBLFdBQVU7QUFDaEYsWUFBSSxPQUFPLEtBQUssUUFBUTtBQUN4QixZQUFHLE1BQUs7QUFBRSxlQUFLOzs7QUFHakIsV0FBSyxjQUFjO0FBQ25CLFdBQUssV0FBVyxlQUFlO0FBQy9CLFdBQUs7QUFFTCxVQUFHLFlBQVc7QUFDWixZQUFJLEVBQUMsTUFBTSxPQUFNO0FBQ2pCLGFBQUssV0FBVyxhQUFhLElBQUk7O0FBRW5DLFdBQUs7QUFDTCxVQUFHLEtBQUssWUFBWSxHQUFFO0FBQUUsYUFBSzs7QUFDN0IsV0FBSzs7SUFHUCx3QkFBd0IsUUFBUSxNQUFLO0FBQ25DLFdBQUssV0FBVyxXQUFXLHFCQUFxQixDQUFDLFFBQVE7QUFDekQsVUFBSSxPQUFPLEtBQUssUUFBUTtBQUN4QixVQUFJLFlBQVksUUFBUSxZQUFJLFVBQVUsUUFBUSxLQUFLLFFBQVE7QUFDM0QsVUFBRyxRQUFRLENBQUMsT0FBTyxZQUFZLFNBQVMsQ0FBRSxjQUFhLFdBQVcsT0FBTyxTQUFTLEtBQUssV0FBVTtBQUMvRixhQUFLO0FBQ0wsZUFBTzs7O0lBSVgsYUFBYSxPQUFPLFdBQVU7QUFDNUIsVUFBSSxhQUFhO0FBQ2pCLFVBQUksbUJBQW1CO0FBQ3ZCLFVBQUksaUJBQWlCLG9CQUFJO0FBRXpCLFlBQU0sTUFBTSxTQUFTLENBQUEsT0FBTTtBQUN6QixhQUFLLFdBQVcsV0FBVyxlQUFlLENBQUM7QUFFM0MsWUFBSSxVQUFVLEtBQUssUUFBUTtBQUMzQixZQUFHLFNBQVE7QUFBRSxrQkFBUTs7O0FBR3ZCLFlBQU0sTUFBTSxpQkFBaUIsQ0FBQSxPQUFNO0FBQ2pDLFlBQUcsWUFBSSxZQUFZLEtBQUk7QUFDckIsZUFBSyxXQUFXO2VBQ1g7QUFDTCw2QkFBbUI7OztBQUl2QixZQUFNLE9BQU8sV0FBVyxDQUFDLFFBQVEsU0FBUztBQUN4QyxZQUFJLE9BQU8sS0FBSyx3QkFBd0IsUUFBUTtBQUNoRCxZQUFHLE1BQUs7QUFBRSx5QkFBZSxJQUFJLE9BQU87OztBQUd0QyxZQUFNLE1BQU0sV0FBVyxDQUFBLE9BQU07QUFDM0IsWUFBRyxlQUFlLElBQUksR0FBRyxLQUFJO0FBQUUsZUFBSyxRQUFRLElBQUk7OztBQUdsRCxZQUFNLE1BQU0sYUFBYSxDQUFDLE9BQU87QUFDL0IsWUFBRyxHQUFHLGFBQWEsS0FBSyxjQUFhO0FBQUUscUJBQVcsS0FBSzs7O0FBR3pELFlBQU0sTUFBTSx3QkFBd0IsQ0FBQSxRQUFPLEtBQUsscUJBQXFCLEtBQUs7QUFDMUUsWUFBTTtBQUNOLFdBQUsscUJBQXFCLFlBQVk7QUFFdEMsYUFBTzs7SUFHVCxxQkFBcUIsVUFBVSxXQUFVO0FBQ3ZDLFVBQUksZ0JBQWdCO0FBQ3BCLGVBQVMsUUFBUSxDQUFBLFdBQVU7QUFDekIsWUFBSSxhQUFhLFlBQUksSUFBSSxRQUFRLElBQUk7QUFDckMsWUFBSSxRQUFRLFlBQUksSUFBSSxRQUFRLElBQUksS0FBSyxRQUFRO0FBQzdDLG1CQUFXLE9BQU8sUUFBUSxRQUFRLENBQUEsT0FBTTtBQUN0QyxjQUFJLE1BQU0sS0FBSyxZQUFZO0FBQzNCLGNBQUcsTUFBTSxRQUFRLGNBQWMsUUFBUSxTQUFTLElBQUc7QUFBRSwwQkFBYyxLQUFLOzs7QUFFMUUsY0FBTSxPQUFPLFFBQVEsUUFBUSxDQUFBLFdBQVU7QUFDckMsY0FBSSxPQUFPLEtBQUssUUFBUTtBQUN4QixrQkFBUSxLQUFLLFlBQVk7OztBQU03QixVQUFHLFdBQVU7QUFDWCxhQUFLLDZCQUE2Qjs7O0lBSXRDLGtCQUFpQjtBQUNmLGtCQUFJLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJLFFBQVEsQ0FBQSxPQUFNLEtBQUssVUFBVTs7SUFHckUsYUFBYSxJQUFHO0FBQUUsYUFBTyxLQUFLLEtBQUssU0FBUyxLQUFLLElBQUk7O0lBRXJELGtCQUFrQixJQUFHO0FBQ25CLFVBQUcsR0FBRyxPQUFPLEtBQUssSUFBRztBQUNuQixlQUFPO2FBQ0Y7QUFDTCxlQUFPLEtBQUssU0FBUyxHQUFHLGFBQWEsZ0JBQWdCLEdBQUc7OztJQUk1RCxrQkFBa0IsSUFBRztBQUNuQixlQUFRLFlBQVksS0FBSyxLQUFLLFVBQVM7QUFDckMsaUJBQVEsV0FBVyxLQUFLLEtBQUssU0FBUyxXQUFVO0FBQzlDLGNBQUcsWUFBWSxJQUFHO0FBQUUsbUJBQU8sS0FBSyxLQUFLLFNBQVMsVUFBVSxTQUFTOzs7OztJQUt2RSxVQUFVLElBQUc7QUFDWCxVQUFJLFFBQVEsS0FBSyxhQUFhLEdBQUc7QUFDakMsVUFBRyxDQUFDLE9BQU07QUFDUixZQUFJLE9BQU8sSUFBSSxLQUFLLElBQUksS0FBSyxZQUFZO0FBQ3pDLGFBQUssS0FBSyxTQUFTLEtBQUssSUFBSSxLQUFLLE1BQU07QUFDdkMsYUFBSztBQUNMLGFBQUs7QUFDTCxlQUFPOzs7SUFJWCxnQkFBZTtBQUFFLGFBQU8sS0FBSzs7SUFFN0IsUUFBUSxRQUFPO0FBQ2IsV0FBSztBQUVMLFVBQUcsS0FBSyxlQUFlLEdBQUU7QUFDdkIsWUFBRyxLQUFLLFFBQU87QUFDYixlQUFLLE9BQU8sUUFBUTtlQUNmO0FBQ0wsZUFBSzs7OztJQUtYLDBCQUF5QjtBQUN2QixXQUFLLGFBQWEsTUFBTTtBQUN0QixhQUFLLGVBQWUsUUFBUSxDQUFDLENBQUMsTUFBTSxRQUFRO0FBQzFDLGNBQUcsQ0FBQyxLQUFLLGVBQWM7QUFBRTs7O0FBRTNCLGFBQUssaUJBQWlCOzs7SUFJMUIsT0FBTyxNQUFNLFFBQU87QUFDbEIsVUFBRyxLQUFLLG1CQUFvQixLQUFLLFdBQVcsb0JBQW9CLENBQUMsWUFBSSxZQUFZLEtBQUssS0FBSztBQUN6RixlQUFPLEtBQUssYUFBYSxLQUFLLEVBQUMsTUFBTTs7QUFHdkMsV0FBSyxTQUFTLFVBQVU7QUFDeEIsVUFBSSxtQkFBbUI7QUFLdkIsVUFBRyxLQUFLLFNBQVMsb0JBQW9CLE9BQU07QUFDekMsYUFBSyxXQUFXLEtBQUssNEJBQTRCLE1BQU07QUFDckQsY0FBSSxhQUFhLFlBQUksZUFBZSxLQUFLLElBQUksS0FBSyxTQUFTLGNBQWM7QUFDekUscUJBQVcsUUFBUSxDQUFBLGNBQWE7QUFDOUIsZ0JBQUcsS0FBSyxlQUFlLEtBQUssU0FBUyxhQUFhLE1BQU0sWUFBWSxZQUFXO0FBQUUsaUNBQW1COzs7O2lCQUdoRyxDQUFDLFFBQVEsT0FBTTtBQUN2QixhQUFLLFdBQVcsS0FBSyx1QkFBdUIsTUFBTTtBQUNoRCxjQUFJLE9BQU8sS0FBSyxnQkFBZ0IsTUFBTTtBQUN0QyxjQUFJLFFBQVEsSUFBSSxTQUFTLE1BQU0sS0FBSyxJQUFJLEtBQUssSUFBSSxNQUFNO0FBQ3ZELDZCQUFtQixLQUFLLGFBQWEsT0FBTzs7O0FBSWhELFdBQUssV0FBVyxlQUFlO0FBQy9CLFVBQUcsa0JBQWlCO0FBQUUsYUFBSzs7O0lBRzdCLGdCQUFnQixNQUFNLE1BQUs7QUFDekIsYUFBTyxLQUFLLFdBQVcsS0FBSyxrQkFBa0IsU0FBUyxNQUFNO0FBQzNELFlBQUksTUFBTSxLQUFLLEdBQUc7QUFHbEIsWUFBSSxPQUFPLE9BQU8sS0FBSyxTQUFTLGNBQWMsTUFBTSxPQUFPLEtBQUssZUFBZTtBQUMvRSxZQUFJLE9BQU8sS0FBSyxTQUFTLFNBQVM7QUFDbEMsZUFBTyxJQUFJLE9BQU8sU0FBUzs7O0lBSS9CLGVBQWUsTUFBTSxLQUFJO0FBQ3ZCLFVBQUcsUUFBUTtBQUFPLGVBQU87QUFDekIsVUFBSSxPQUFPLEtBQUssU0FBUyxrQkFBa0I7QUFDM0MsVUFBSSxRQUFRLElBQUksU0FBUyxNQUFNLEtBQUssSUFBSSxLQUFLLElBQUksTUFBTTtBQUN2RCxVQUFJLGdCQUFnQixLQUFLLGFBQWEsT0FBTztBQUM3QyxhQUFPOztJQUdULFFBQVEsSUFBRztBQUFFLGFBQU8sS0FBSyxVQUFVLFNBQVMsVUFBVTs7SUFFdEQsUUFBUSxJQUFHO0FBQ1QsVUFBRyxTQUFTLFVBQVUsT0FBTyxDQUFDLEdBQUcsY0FBYTtBQUFFOztBQUNoRCxVQUFJLFdBQVcsR0FBRyxhQUFhLFlBQVksZUFBZSxHQUFHLGFBQWEsS0FBSyxRQUFRO0FBQ3ZGLFVBQUcsWUFBWSxDQUFDLEtBQUssWUFBWSxLQUFJO0FBQUU7O0FBQ3ZDLFVBQUksWUFBWSxLQUFLLFdBQVcsaUJBQWlCO0FBRWpELFVBQUcsV0FBVTtBQUNYLFlBQUcsQ0FBQyxHQUFHLElBQUc7QUFBRSxtQkFBUyx1QkFBdUIseURBQXlEOztBQUNyRyxZQUFJLE9BQU8sSUFBSSxTQUFTLE1BQU0sSUFBSTtBQUNsQyxhQUFLLFVBQVUsU0FBUyxVQUFVLEtBQUssT0FBTztBQUM5QyxlQUFPO2lCQUNDLGFBQWEsTUFBSztBQUMxQixpQkFBUywyQkFBMkIsYUFBYTs7O0lBSXJELFlBQVksTUFBSztBQUNmLFdBQUs7QUFDTCxXQUFLO0FBQ0wsYUFBTyxLQUFLLFVBQVUsU0FBUyxVQUFVLEtBQUs7O0lBR2hELHNCQUFxQjtBQUNuQixXQUFLLGFBQWEsUUFBUSxDQUFDLEVBQUMsTUFBTSxhQUFZLEtBQUssT0FBTyxNQUFNO0FBQ2hFLFdBQUssZUFBZTs7SUFHdEIsVUFBVSxPQUFPLElBQUc7QUFDbEIsV0FBSyxXQUFXLFVBQVUsS0FBSyxTQUFTLE9BQU8sQ0FBQSxTQUFRO0FBQ3JELFlBQUcsS0FBSyxpQkFBZ0I7QUFDdEIsZUFBSyxLQUFLLGVBQWUsS0FBSyxDQUFDLE1BQU0sTUFBTSxHQUFHO2VBQ3pDO0FBQ0wsZUFBSyxXQUFXLGlCQUFpQixNQUFNLEdBQUc7Ozs7SUFLaEQsY0FBYTtBQUdYLFdBQUssV0FBVyxVQUFVLEtBQUssU0FBUyxRQUFRLENBQUMsWUFBWTtBQUMzRCxhQUFLLFdBQVcsaUJBQWlCLE1BQU07QUFDckMsZUFBSyxVQUFVLFVBQVUsU0FBUyxDQUFDLEVBQUMsTUFBTSxhQUFZLEtBQUssT0FBTyxNQUFNOzs7QUFHNUUsV0FBSyxVQUFVLFlBQVksQ0FBQyxFQUFDLElBQUksWUFBVyxLQUFLLFdBQVcsRUFBQyxJQUFJO0FBQ2pFLFdBQUssVUFBVSxjQUFjLENBQUMsVUFBVSxLQUFLLFlBQVk7QUFDekQsV0FBSyxVQUFVLGlCQUFpQixDQUFDLFVBQVUsS0FBSyxlQUFlO0FBQy9ELFdBQUssUUFBUSxRQUFRLENBQUEsV0FBVSxLQUFLLFFBQVE7QUFDNUMsV0FBSyxRQUFRLFFBQVEsQ0FBQSxXQUFVLEtBQUssUUFBUTs7SUFHOUMscUJBQW9CO0FBQ2xCLGVBQVEsTUFBTSxLQUFLLEtBQUssU0FBUyxLQUFLLEtBQUk7QUFDeEMsYUFBSyxhQUFhLElBQUk7OztJQUkxQixlQUFlLE9BQU07QUFDbkIsVUFBSSxFQUFDLElBQUksTUFBTSxVQUFTO0FBQ3hCLFVBQUksTUFBTSxLQUFLLFVBQVU7QUFDekIsV0FBSyxXQUFXLGdCQUFnQixLQUFLLE1BQU07O0lBRzdDLFlBQVksT0FBTTtBQUNoQixVQUFJLEVBQUMsSUFBSSxTQUFRO0FBQ2pCLFdBQUssT0FBTyxLQUFLLFVBQVU7QUFDM0IsV0FBSyxXQUFXLGFBQWEsSUFBSTs7SUFHbkMsVUFBVSxJQUFHO0FBQ1gsYUFBTyxHQUFHLFdBQVcsT0FBTyxHQUFHLE9BQU8sU0FBUyxhQUFhLE9BQU8sU0FBUyxPQUFPLE9BQU87O0lBRzVGLFdBQVcsRUFBQyxJQUFJLFNBQU87QUFBRSxXQUFLLFdBQVcsU0FBUyxJQUFJOztJQUV0RCxjQUFhO0FBQUUsYUFBTyxLQUFLOztJQUUzQixLQUFLLFVBQVM7QUFDWixVQUFHLEtBQUssVUFBUztBQUNmLGFBQUssZUFBZSxLQUFLLFdBQVcsZ0JBQWdCLEVBQUMsSUFBSSxLQUFLLE1BQU0sTUFBTTs7QUFFNUUsV0FBSyxlQUFlLENBQUMsV0FBVztBQUM5QixpQkFBUyxVQUFVLFdBQVU7O0FBQzdCLG1CQUFXLFNBQVMsS0FBSyxXQUFXLFVBQVU7O0FBRWhELFdBQUssV0FBVyxTQUFTLE1BQU0sRUFBQyxTQUFTLFNBQVEsTUFBTTtBQUNyRCxlQUFPLEtBQUssUUFBUSxPQUNqQixRQUFRLE1BQU0sQ0FBQSxTQUFRO0FBQ3JCLGNBQUcsQ0FBQyxLQUFLLGVBQWM7QUFDckIsaUJBQUssV0FBVyxpQkFBaUIsTUFBTSxLQUFLLE9BQU87O1dBR3RELFFBQVEsU0FBUyxDQUFBLFNBQVEsQ0FBQyxLQUFLLGlCQUFpQixLQUFLLFlBQVksT0FDakUsUUFBUSxXQUFXLE1BQU0sQ0FBQyxLQUFLLGlCQUFpQixLQUFLLFlBQVksRUFBQyxRQUFROzs7SUFJakYsWUFBWSxNQUFLO0FBQ2YsVUFBRyxLQUFLLFdBQVcsa0JBQWtCLEtBQUssV0FBVyxTQUFRO0FBQzNELGFBQUssSUFBSSxTQUFTLE1BQU0sQ0FBQyw0REFBNEQ7QUFDckYsZUFBTyxLQUFLLFdBQVcsRUFBQyxJQUFJLEtBQUs7O0FBRW5DLFVBQUcsS0FBSyxZQUFZLEtBQUssZUFBYztBQUNyQyxhQUFLLGNBQWM7QUFDbkIsYUFBSyxRQUFROztBQUVmLFVBQUcsS0FBSyxVQUFTO0FBQUUsZUFBTyxLQUFLLFdBQVcsS0FBSzs7QUFDL0MsVUFBRyxLQUFLLGVBQWM7QUFBRSxlQUFPLEtBQUssZUFBZSxLQUFLOztBQUN4RCxXQUFLLElBQUksU0FBUyxNQUFNLENBQUMsa0JBQWtCO0FBQzNDLFVBQUcsS0FBSyxXQUFXLGVBQWM7QUFBRSxhQUFLLFdBQVcsaUJBQWlCOzs7SUFHdEUsUUFBUSxRQUFPO0FBQ2IsVUFBRyxLQUFLLGVBQWM7QUFBRTs7QUFDeEIsVUFBRyxLQUFLLFdBQVcsb0JBQW9CLFdBQVcsU0FBUTtBQUN4RCxlQUFPLEtBQUssV0FBVyxpQkFBaUI7O0FBRTFDLFdBQUs7QUFDTCxXQUFLLFdBQVcsa0JBQWtCO0FBRWxDLFVBQUcsU0FBUyxlQUFjO0FBQUUsaUJBQVMsY0FBYzs7QUFDbkQsVUFBRyxLQUFLLFdBQVcsY0FBYTtBQUM5QixhQUFLLFdBQVc7OztJQUlwQixRQUFRLFFBQU87QUFDYixXQUFLLFFBQVE7QUFDYixVQUFHLEtBQUssV0FBVyxlQUFjO0FBQUUsYUFBSyxJQUFJLFNBQVMsTUFBTSxDQUFDLGdCQUFnQjs7QUFDNUUsVUFBRyxDQUFDLEtBQUssV0FBVyxjQUFhO0FBQUUsYUFBSzs7O0lBRzFDLGVBQWM7QUFDWixVQUFHLEtBQUssVUFBUztBQUFFLG9CQUFJLGNBQWMsUUFBUSwwQkFBMEIsRUFBQyxRQUFRLEVBQUMsSUFBSSxLQUFLLE1BQU0sTUFBTTs7QUFDdEcsV0FBSztBQUNMLFdBQUssb0JBQW9CLHdCQUF3Qjs7SUFHbkQsY0FBYyxjQUFjLE9BQU8sU0FBUyxVQUFVLFdBQVc7T0FBSTtBQUNuRSxVQUFHLENBQUMsS0FBSyxlQUFjO0FBQUU7O0FBRXpCLFVBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxRQUFRLGVBQWUsaUJBQWlCLENBQUMsTUFBTSxJQUFJO0FBQ25FLFVBQUksZ0JBQWdCLFdBQVU7O0FBQzlCLFVBQUcsS0FBSyxnQkFBaUIsTUFBTyxHQUFHLGFBQWEsS0FBSyxRQUFRLHVCQUF1QixNQUFPO0FBQ3pGLHdCQUFnQixLQUFLLFdBQVcsZ0JBQWdCLEVBQUMsTUFBTSxXQUFXLFFBQVE7O0FBRzVFLFVBQUcsT0FBUSxRQUFRLFFBQVMsVUFBUztBQUFFLGVBQU8sUUFBUTs7QUFDdEQsYUFDRSxLQUFLLFdBQVcsU0FBUyxNQUFNLEVBQUMsU0FBUyxRQUFPLE1BQU07QUFDcEQsZUFBTyxLQUFLLFFBQVEsS0FBSyxPQUFPLFNBQVMsY0FBYyxRQUFRLE1BQU0sQ0FBQSxTQUFRO0FBQzNFLGNBQUcsUUFBUSxNQUFLO0FBQUUsaUJBQUssU0FBUzs7QUFDaEMsY0FBSSxTQUFTLENBQUMsY0FBYztBQUMxQixnQkFBRyxLQUFLLFVBQVM7QUFBRSxtQkFBSyxXQUFXLEtBQUs7O0FBQ3hDLGdCQUFHLEtBQUssWUFBVztBQUFFLG1CQUFLLFlBQVksS0FBSzs7QUFDM0MsZ0JBQUcsS0FBSyxlQUFjO0FBQUUsbUJBQUssZUFBZSxLQUFLOztBQUNqRDtBQUNBLG9CQUFRLE1BQU07O0FBRWhCLGNBQUcsS0FBSyxNQUFLO0FBQ1gsaUJBQUssV0FBVyxpQkFBaUIsTUFBTTtBQUNyQyxrQkFBSSxZQUFZLEtBQUssVUFBVSxVQUFVLEtBQUssTUFBTSxDQUFDLEVBQUMsTUFBTSxhQUFZO0FBQ3RFLHFCQUFLLE9BQU8sTUFBTTs7QUFFcEIscUJBQU87O2lCQUVKO0FBQ0wsbUJBQU87Ozs7O0lBT2pCLFNBQVMsS0FBSTtBQUNYLGtCQUFJLElBQUksVUFBVSxJQUFJLGdCQUFnQixLQUFLLFFBQVEsWUFBWSxTQUFTLENBQUEsT0FBTTtBQUM1RSxZQUFJLGNBQWMsR0FBRyxhQUFhO0FBRWxDLFdBQUcsZ0JBQWdCO0FBQ25CLFdBQUcsZ0JBQWdCO0FBRW5CLFlBQUcsR0FBRyxhQUFhLGtCQUFrQixNQUFLO0FBQ3hDLGFBQUcsV0FBVztBQUNkLGFBQUcsZ0JBQWdCOztBQUVyQixZQUFHLGdCQUFnQixNQUFLO0FBQ3RCLGFBQUcsV0FBVyxnQkFBZ0IsU0FBUyxPQUFPO0FBQzlDLGFBQUcsZ0JBQWdCOztBQUdyQiwwQkFBa0IsUUFBUSxDQUFBLGNBQWEsWUFBSSxZQUFZLElBQUk7QUFFM0QsWUFBSSxpQkFBaUIsR0FBRyxhQUFhO0FBQ3JDLFlBQUcsbUJBQW1CLE1BQUs7QUFDekIsYUFBRyxZQUFZO0FBQ2YsYUFBRyxnQkFBZ0I7O0FBRXJCLFlBQUksT0FBTyxZQUFJLFFBQVEsSUFBSTtBQUMzQixZQUFHLE1BQUs7QUFDTixjQUFJLE9BQU8sS0FBSyx3QkFBd0IsSUFBSTtBQUM1QyxtQkFBUyxRQUFRLElBQUksTUFBTSxLQUFLLFdBQVc7QUFDM0MsY0FBRyxNQUFLO0FBQUUsaUJBQUs7O0FBQ2Ysc0JBQUksY0FBYyxJQUFJOzs7O0lBSzVCLE9BQU8sVUFBVSxPQUFPLE9BQU8sSUFBRztBQUNoQyxVQUFJLFNBQVMsS0FBSztBQUNsQixVQUFJLGNBQWMsS0FBSyxRQUFRO0FBQy9CLFVBQUcsS0FBSyxTQUFRO0FBQUUsbUJBQVcsU0FBUyxPQUFPLFlBQUksSUFBSSxVQUFVLEtBQUs7O0FBRXBFLGVBQVMsUUFBUSxDQUFBLE9BQU07QUFDckIsV0FBRyxVQUFVLElBQUksT0FBTztBQUN4QixXQUFHLGFBQWEsU0FBUztBQUN6QixXQUFHLGFBQWEsYUFBYSxLQUFLLEdBQUc7QUFDckMsWUFBSSxjQUFjLEdBQUcsYUFBYTtBQUNsQyxZQUFHLGdCQUFnQixNQUFLO0FBQ3RCLGNBQUcsQ0FBQyxHQUFHLGFBQWEsMkJBQTBCO0FBQzVDLGVBQUcsYUFBYSwwQkFBMEIsR0FBRzs7QUFFL0MsY0FBRyxnQkFBZ0IsSUFBRztBQUFFLGVBQUcsWUFBWTs7QUFDdkMsYUFBRyxhQUFhLFlBQVk7OztBQUdoQyxhQUFPLENBQUMsUUFBUSxVQUFVOztJQUc1QixZQUFZLElBQUc7QUFDYixVQUFJLE1BQU0sR0FBRyxnQkFBZ0IsR0FBRyxhQUFhO0FBQzdDLGFBQU8sTUFBTSxTQUFTLE9BQU87O0lBRy9CLGtCQUFrQixRQUFRLFdBQVcsT0FBTyxJQUFHO0FBQzdDLFVBQUcsTUFBTSxZQUFXO0FBQUUsZUFBTzs7QUFFN0IsVUFBSSxnQkFBZ0IsT0FBTyxhQUFhLEtBQUssUUFBUTtBQUNyRCxVQUFHLE1BQU0sZ0JBQWU7QUFDdEIsZUFBTyxTQUFTO2lCQUNSLGFBQWMsbUJBQWtCLFFBQVEsS0FBSyxTQUFRO0FBQzdELGVBQU8sS0FBSyxtQkFBbUI7YUFDMUI7QUFDTCxlQUFPOzs7SUFJWCxtQkFBbUIsV0FBVTtBQUMzQixVQUFHLE1BQU0sWUFBVztBQUNsQixlQUFPO2lCQUNDLFdBQVU7QUFDbEIsZUFBTyxNQUFNLFVBQVUsUUFBUSxJQUFJLG1CQUFtQixDQUFBLE9BQU0sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZO2FBQ2hHO0FBQ0wsZUFBTzs7O0lBSVgsY0FBYyxXQUFXLE9BQU8sU0FBUyxTQUFRO0FBQy9DLFVBQUcsQ0FBQyxLQUFLLGVBQWM7QUFDckIsYUFBSyxJQUFJLFFBQVEsTUFBTSxDQUFDLHFEQUFxRCxPQUFPO0FBQ3BGLGVBQU87O0FBRVQsVUFBSSxDQUFDLEtBQUssS0FBSyxRQUFRLEtBQUssT0FBTyxJQUFJO0FBQ3ZDLFdBQUssY0FBYyxNQUFNLENBQUMsS0FBSyxLQUFLLE9BQU8sU0FBUztRQUNsRCxNQUFNO1FBQ047UUFDQSxPQUFPO1FBQ1AsS0FBSyxLQUFLLG1CQUFtQjtTQUM1QixDQUFDLE1BQU0sVUFBVSxRQUFRLE9BQU87QUFFbkMsYUFBTzs7SUFHVCxZQUFZLElBQUksTUFBTSxPQUFNO0FBQzFCLFVBQUksU0FBUyxLQUFLLFFBQVE7QUFDMUIsZUFBUSxJQUFJLEdBQUcsSUFBSSxHQUFHLFdBQVcsUUFBUSxLQUFJO0FBQzNDLFlBQUcsQ0FBQyxNQUFLO0FBQUUsaUJBQU87O0FBQ2xCLFlBQUksT0FBTyxHQUFHLFdBQVcsR0FBRztBQUM1QixZQUFHLEtBQUssV0FBVyxTQUFRO0FBQUUsZUFBSyxLQUFLLFFBQVEsUUFBUSxPQUFPLEdBQUcsYUFBYTs7O0FBRWhGLFVBQUcsR0FBRyxVQUFVLFFBQVU7QUFDeEIsWUFBRyxDQUFDLE1BQUs7QUFBRSxpQkFBTzs7QUFDbEIsYUFBSyxRQUFRLEdBQUc7QUFFaEIsWUFBRyxHQUFHLFlBQVksV0FBVyxpQkFBaUIsUUFBUSxHQUFHLFNBQVMsS0FBSyxDQUFDLEdBQUcsU0FBUTtBQUNqRixpQkFBTyxLQUFLOzs7QUFHaEIsVUFBRyxPQUFNO0FBQ1AsWUFBRyxDQUFDLE1BQUs7QUFBRSxpQkFBTzs7QUFDbEIsaUJBQVEsT0FBTyxPQUFNO0FBQUUsZUFBSyxPQUFPLE1BQU07OztBQUUzQyxhQUFPOztJQUdULFVBQVUsTUFBTSxJQUFJLFdBQVcsVUFBVSxNQUFNLE9BQU8sSUFBRztBQUN2RCxXQUFLLGNBQWMsTUFBTSxLQUFLLE9BQU8sQ0FBQyxLQUFLLE1BQU0sT0FBTyxTQUFTO1FBQy9EO1FBQ0EsT0FBTztRQUNQLE9BQU8sS0FBSyxZQUFZLElBQUksTUFBTSxLQUFLO1FBQ3ZDLEtBQUssS0FBSyxrQkFBa0IsSUFBSSxXQUFXOzs7SUFJL0MsaUJBQWlCLFFBQVEsVUFBVSxVQUFVLFVBQVUsV0FBVztPQUFJO0FBQ3BFLFdBQUssV0FBVyxhQUFhLE9BQU8sTUFBTSxDQUFDLE1BQU0sY0FBYztBQUM3RCxhQUFLLGNBQWMsTUFBTSxZQUFZO1VBQ25DLE9BQU8sT0FBTyxhQUFhLEtBQUssUUFBUTtVQUN4QyxLQUFLLE9BQU8sYUFBYTtVQUN6QixXQUFXO1VBQ1g7VUFDQSxLQUFLLEtBQUssa0JBQWtCLE9BQU8sTUFBTTtXQUN4Qzs7O0lBSVAsVUFBVSxTQUFTLFdBQVcsVUFBVSxVQUFVLE1BQU0sVUFBUztBQUMvRCxVQUFJO0FBQ0osVUFBSSxNQUFNLE1BQU0sWUFBWSxXQUFXLEtBQUssa0JBQWtCLFFBQVEsTUFBTTtBQUM1RSxVQUFJLGVBQWUsTUFBTSxLQUFLLE9BQU8sQ0FBQyxTQUFTLFFBQVEsT0FBTyxVQUFVO0FBQ3hFLFVBQUk7QUFDSixVQUFHLFFBQVEsYUFBYSxLQUFLLFFBQVEsWUFBVztBQUM5QyxtQkFBVyxjQUFjLFFBQVEsTUFBTSxFQUFDLFNBQVMsS0FBSyxXQUFVLENBQUMsUUFBUTthQUNwRTtBQUNMLG1CQUFXLGNBQWMsUUFBUSxNQUFNLEVBQUMsU0FBUyxLQUFLOztBQUV4RCxVQUFHLFlBQUksY0FBYyxZQUFZLFFBQVEsU0FBUyxRQUFRLE1BQU0sU0FBUyxHQUFFO0FBQ3pFLHFCQUFhLFdBQVcsU0FBUyxNQUFNLEtBQUssUUFBUTs7QUFFdEQsZ0JBQVUsYUFBYSxpQkFBaUI7QUFDeEMsVUFBSSxRQUFRO1FBQ1YsTUFBTTtRQUNOLE9BQU87UUFDUCxPQUFPO1FBQ1A7UUFDQTs7QUFFRixXQUFLLGNBQWMsY0FBYyxTQUFTLE9BQU8sQ0FBQSxTQUFRO0FBQ3ZELG9CQUFJLFVBQVUsU0FBUyxLQUFLLFdBQVcsUUFBUTtBQUMvQyxZQUFHLFlBQUksY0FBYyxZQUFZLFFBQVEsYUFBYSw0QkFBNEIsTUFBSztBQUNyRixjQUFHLGFBQWEsdUJBQXVCLFNBQVMsU0FBUyxHQUFFO0FBQ3pELGdCQUFJLENBQUMsS0FBSyxRQUFRO0FBQ2xCLGlCQUFLLFlBQVksUUFBUSxNQUFNLFdBQVcsS0FBSyxLQUFLLENBQUMsYUFBYTtBQUNoRSwwQkFBWSxTQUFTO0FBQ3JCLG1CQUFLLHNCQUFzQixRQUFROzs7ZUFHbEM7QUFDTCxzQkFBWSxTQUFTOzs7O0lBSzNCLHNCQUFzQixRQUFPO0FBQzNCLFVBQUksaUJBQWlCLEtBQUssbUJBQW1CO0FBQzdDLFVBQUcsZ0JBQWU7QUFDaEIsWUFBSSxDQUFDLEtBQUssTUFBTSxPQUFPLFlBQVk7QUFDbkMsYUFBSyxhQUFhO0FBQ2xCOzs7SUFJSixtQkFBbUIsUUFBTztBQUN4QixhQUFPLEtBQUssWUFBWSxLQUFLLENBQUMsQ0FBQyxJQUFJLE1BQU0sT0FBTyxlQUFlLEdBQUcsV0FBVzs7SUFHL0UsZUFBZSxRQUFRLEtBQUssTUFBTSxVQUFTO0FBQ3pDLFVBQUcsS0FBSyxtQkFBbUIsU0FBUTtBQUFFLGVBQU87O0FBQzVDLFdBQUssWUFBWSxLQUFLLENBQUMsUUFBUSxLQUFLLE1BQU07O0lBRzVDLGFBQWEsUUFBTztBQUNsQixXQUFLLGNBQWMsS0FBSyxZQUFZLE9BQU8sQ0FBQyxDQUFDLElBQUksS0FBSyxlQUFlO0FBQ25FLFlBQUcsR0FBRyxXQUFXLFNBQVE7QUFDdkIsZUFBSyxTQUFTO0FBQ2QsaUJBQU87ZUFDRjtBQUNMLGlCQUFPOzs7O0lBS2IsZUFBZSxRQUFRLFdBQVcsVUFBVSxNQUFNLFNBQVE7QUFDeEQsVUFBSSxnQkFBZ0IsQ0FBQSxPQUFNO0FBQ3hCLFlBQUksY0FBYyxrQkFBa0IsSUFBSSxHQUFHLEtBQUssUUFBUSxzQkFBc0IsR0FBRztBQUNqRixlQUFPLENBQUUsZ0JBQWUsa0JBQWtCLElBQUksMEJBQTBCLEdBQUc7O0FBRTdFLFVBQUksaUJBQWlCLENBQUEsT0FBTTtBQUN6QixlQUFPLEdBQUcsYUFBYSxLQUFLLFFBQVE7O0FBRXRDLFVBQUksZUFBZSxDQUFBLE9BQU0sR0FBRyxXQUFXO0FBRXZDLFVBQUksY0FBYyxDQUFBLE9BQU0sQ0FBQyxTQUFTLFlBQVksVUFBVSxTQUFTLEdBQUc7QUFFcEUsVUFBSSxlQUFlLE1BQU07QUFDdkIsWUFBSSxlQUFlLE1BQU0sS0FBSyxPQUFPO0FBQ3JDLFlBQUksV0FBVyxhQUFhLE9BQU87QUFDbkMsWUFBSSxVQUFVLGFBQWEsT0FBTyxjQUFjLE9BQU87QUFDdkQsWUFBSSxTQUFTLGFBQWEsT0FBTyxhQUFhLE9BQU87QUFFckQsZ0JBQVEsUUFBUSxDQUFBLFdBQVU7QUFDeEIsaUJBQU8sYUFBYSxjQUFjLE9BQU87QUFDekMsaUJBQU8sV0FBVzs7QUFFcEIsZUFBTyxRQUFRLENBQUEsVUFBUztBQUN0QixnQkFBTSxhQUFhLGNBQWMsTUFBTTtBQUN2QyxnQkFBTSxXQUFXO0FBQ2pCLGNBQUcsTUFBTSxPQUFNO0FBQ2Isa0JBQU0sYUFBYSxjQUFjLE1BQU07QUFDdkMsa0JBQU0sV0FBVzs7O0FBR3JCLGVBQU8sYUFBYSxLQUFLLFFBQVEsbUJBQW1CO0FBQ3BELGVBQU8sS0FBSyxPQUFPLENBQUMsUUFBUSxPQUFPLFVBQVUsT0FBTyxTQUFTLE9BQU8sU0FBUyxVQUFVOztBQUd6RixVQUFJLE1BQU0sS0FBSyxrQkFBa0IsUUFBUTtBQUN6QyxVQUFHLGFBQWEscUJBQXFCLFNBQVE7QUFDM0MsWUFBSSxDQUFDLEtBQUssUUFBUTtBQUNsQixZQUFJLE9BQU8sTUFBTSxLQUFLLGVBQWUsUUFBUSxXQUFXLFVBQVUsTUFBTTtBQUN4RSxlQUFPLEtBQUssZUFBZSxRQUFRLEtBQUssTUFBTTtpQkFDdEMsYUFBYSx3QkFBd0IsUUFBUSxTQUFTLEdBQUU7QUFDaEUsWUFBSSxDQUFDLEtBQUssT0FBTztBQUNqQixZQUFJLGNBQWMsTUFBTSxDQUFDLEtBQUssS0FBSztBQUNuQyxhQUFLLFlBQVksUUFBUSxXQUFXLEtBQUssS0FBSyxDQUFDLGFBQWE7QUFDMUQsY0FBSSxXQUFXLGNBQWMsUUFBUTtBQUNyQyxlQUFLLGNBQWMsYUFBYSxTQUFTO1lBQ3ZDLE1BQU07WUFDTixPQUFPO1lBQ1AsT0FBTztZQUNQO2FBQ0M7O2FBRUE7QUFDTCxZQUFJLFdBQVcsY0FBYyxRQUFRO0FBQ3JDLGFBQUssY0FBYyxjQUFjLFNBQVM7VUFDeEMsTUFBTTtVQUNOLE9BQU87VUFDUCxPQUFPO1VBQ1A7V0FDQzs7O0lBSVAsWUFBWSxRQUFRLFdBQVcsS0FBSyxLQUFLLFlBQVc7QUFDbEQsVUFBSSxvQkFBb0IsS0FBSztBQUM3QixVQUFJLFdBQVcsYUFBYSxpQkFBaUI7QUFDN0MsVUFBSSwwQkFBMEIsU0FBUztBQUd2QyxlQUFTLFFBQVEsQ0FBQSxZQUFXO0FBQzFCLFlBQUksV0FBVyxJQUFJLGFBQWEsU0FBUyxNQUFNLE1BQU07QUFDbkQ7QUFDQSxjQUFHLDRCQUE0QixHQUFFO0FBQUU7OztBQUdyQyxhQUFLLFVBQVUsV0FBVztBQUMxQixZQUFJLFVBQVUsU0FBUyxVQUFVLElBQUksQ0FBQSxVQUFTLE1BQU07QUFFcEQsWUFBSSxVQUFVO1VBQ1osS0FBSyxRQUFRLGFBQWE7VUFDMUI7VUFDQSxLQUFLLEtBQUssa0JBQWtCLFFBQVEsTUFBTTs7QUFHNUMsYUFBSyxJQUFJLFVBQVUsTUFBTSxDQUFDLDZCQUE2QjtBQUV2RCxhQUFLLGNBQWMsTUFBTSxnQkFBZ0IsU0FBUyxDQUFBLFNBQVE7QUFDeEQsZUFBSyxJQUFJLFVBQVUsTUFBTSxDQUFDLDBCQUEwQjtBQUNwRCxjQUFHLEtBQUssT0FBTTtBQUNaLGlCQUFLLFNBQVM7QUFDZCxnQkFBSSxDQUFDLFdBQVcsVUFBVSxLQUFLO0FBQy9CLGlCQUFLLElBQUksVUFBVSxNQUFNLENBQUMsbUJBQW1CLGFBQWE7aUJBQ3JEO0FBQ0wsZ0JBQUksVUFBVSxDQUFDLGFBQWE7QUFDMUIsbUJBQUssUUFBUSxRQUFRLE1BQU07QUFDekIsb0JBQUcsS0FBSyxjQUFjLG1CQUFrQjtBQUFFOzs7O0FBRzlDLHFCQUFTLGtCQUFrQixNQUFNLFNBQVMsS0FBSzs7Ozs7SUFNdkQsZ0JBQWdCLE1BQU0sY0FBYTtBQUNqQyxVQUFJLFNBQVMsWUFBSSxpQkFBaUIsS0FBSyxJQUFJLE9BQU8sQ0FBQSxPQUFNLEdBQUcsU0FBUztBQUNwRSxVQUFHLE9BQU8sV0FBVyxHQUFFO0FBQUUsaUJBQVMsZ0RBQWdEO2lCQUMxRSxPQUFPLFNBQVMsR0FBRTtBQUFFLGlCQUFTLHVEQUF1RDthQUN2RjtBQUFFLG9CQUFJLGNBQWMsT0FBTyxJQUFJLG1CQUFtQixFQUFDLFFBQVEsRUFBQyxPQUFPOzs7SUFHMUUsaUJBQWlCLE1BQU0sUUFBUSxVQUFTO0FBQ3RDLFdBQUssV0FBVyxhQUFhLE1BQU0sQ0FBQyxNQUFNLGNBQWM7QUFDdEQsWUFBSSxRQUFRLEtBQUssU0FBUztBQUMxQixZQUFJLFdBQVcsS0FBSyxhQUFhLEtBQUssUUFBUSxzQkFBc0IsS0FBSyxhQUFhLEtBQUssUUFBUTtBQUVuRyxtQkFBRyxLQUFLLFVBQVUsVUFBVSxNQUFNLE9BQU8sQ0FBQyxRQUFRLEVBQUMsU0FBUyxNQUFNLE1BQU0sUUFBZ0I7OztJQUk1RixjQUFjLE1BQU0sVUFBVSxVQUFTO0FBQ3JDLFVBQUksVUFBVSxLQUFLLFdBQVcsZUFBZTtBQUM3QyxVQUFJLFNBQVMsV0FBVyxNQUFNLEtBQUssT0FBTyxDQUFDLFdBQVcsV0FBVztBQUNqRSxVQUFJLFdBQVcsTUFBTSxLQUFLLFdBQVcsU0FBUyxPQUFPLFNBQVM7QUFFOUQsVUFBSSxPQUFPLEtBQUssY0FBYyxRQUFRLGNBQWMsRUFBQyxLQUFLLFFBQU8sQ0FBQSxTQUFRO0FBQ3ZFLGFBQUssV0FBVyxpQkFBaUIsTUFBTTtBQUNyQyxjQUFHLEtBQUssZUFBYztBQUNwQixpQkFBSyxXQUFXLFlBQVksTUFBTSxNQUFNLFVBQVU7aUJBQzdDO0FBQ0wsZ0JBQUcsS0FBSyxXQUFXLGtCQUFrQixVQUFTO0FBQzVDLG1CQUFLLE9BQU87O0FBRWQsaUJBQUs7QUFDTCx3QkFBWSxTQUFTOzs7O0FBSzNCLFVBQUcsTUFBSztBQUNOLGFBQUssUUFBUSxXQUFXO2FBQ25CO0FBQ0w7OztJQUlKLGlCQUFpQixNQUFLO0FBQ3BCLFVBQUcsS0FBSyxjQUFjLEdBQUU7QUFBRSxlQUFPOztBQUVqQyxVQUFJLFlBQVksS0FBSyxRQUFRO0FBQzdCLFVBQUksV0FBVyxTQUFTLGNBQWM7QUFDdEMsZUFBUyxZQUFZO0FBRXJCLGFBQ0UsWUFBSSxJQUFJLEtBQUssSUFBSSxRQUFRLGNBQ3RCLE9BQU8sQ0FBQSxTQUFRLEtBQUssTUFBTSxLQUFLLFlBQVksT0FDM0MsT0FBTyxDQUFBLFNBQVEsS0FBSyxTQUFTLFNBQVMsR0FDdEMsT0FBTyxDQUFBLFNBQVEsS0FBSyxhQUFhLEtBQUssUUFBUSx1QkFBdUIsVUFDckUsSUFBSSxDQUFBLFNBQVE7QUFDWCxZQUFJLFVBQVUsU0FBUyxRQUFRLGNBQWMsWUFBWSxLQUFLLFFBQVEsY0FBYyxLQUFLLGFBQWE7QUFDdEcsWUFBRyxTQUFRO0FBQ1QsaUJBQU8sQ0FBQyxNQUFNLFNBQVMsS0FBSyxrQkFBa0I7ZUFDekM7QUFDTCxpQkFBTyxDQUFDLE1BQU0sTUFBTTs7U0FHdkIsT0FBTyxDQUFDLENBQUMsTUFBTSxTQUFTLFlBQVk7O0lBSTNDLDZCQUE2QixlQUFjO0FBQ3pDLFVBQUksa0JBQWtCLGNBQWMsT0FBTyxDQUFBLFFBQU87QUFDaEQsZUFBTyxZQUFJLHNCQUFzQixLQUFLLElBQUksS0FBSyxXQUFXOztBQUU1RCxVQUFHLGdCQUFnQixTQUFTLEdBQUU7QUFDNUIsYUFBSyxZQUFZLEtBQUssR0FBRztBQUV6QixhQUFLLGNBQWMsTUFBTSxxQkFBcUIsRUFBQyxNQUFNLG1CQUFrQixNQUFNO0FBRzNFLGVBQUssY0FBYyxLQUFLLFlBQVksT0FBTyxDQUFBLFFBQU8sZ0JBQWdCLFFBQVEsU0FBUztBQUluRixjQUFJLHdCQUF3QixnQkFBZ0IsT0FBTyxDQUFBLFFBQU87QUFDeEQsbUJBQU8sWUFBSSxzQkFBc0IsS0FBSyxJQUFJLEtBQUssV0FBVzs7QUFHNUQsY0FBRyxzQkFBc0IsU0FBUyxHQUFFO0FBQ2xDLGlCQUFLLGNBQWMsTUFBTSxrQkFBa0IsRUFBQyxNQUFNLHlCQUF3QixDQUFDLFNBQVM7QUFDbEYsbUJBQUssU0FBUyxVQUFVLEtBQUs7Ozs7OztJQU92QyxZQUFZLElBQUc7QUFDYixhQUFPLEdBQUcsYUFBYSxtQkFBbUIsS0FBSyxNQUM3QyxNQUFNLEdBQUcsUUFBUSxvQkFBb0IsQ0FBQSxTQUFRLEtBQUssUUFBUSxLQUFLOztJQUduRSxXQUFXLE1BQU0sV0FBVyxVQUFVLE9BQU8sSUFBRztBQUM5QyxrQkFBSSxXQUFXLE1BQU0sbUJBQW1CO0FBQ3hDLFVBQUksY0FBYyxLQUFLLFdBQVcsUUFBUTtBQUMxQyxVQUFJLFNBQVMsTUFBTSxLQUFLLEtBQUs7QUFDN0IsV0FBSyxXQUFXLGtCQUFrQjtBQUNsQyxXQUFLLGVBQWUsTUFBTSxXQUFXLFVBQVUsTUFBTSxNQUFNO0FBQ3pELGVBQU8sUUFBUSxDQUFBLFVBQVMsWUFBSSxVQUFVLE9BQU87QUFDN0MsYUFBSyxXQUFXOzs7SUFJcEIsUUFBUSxNQUFLO0FBQUUsYUFBTyxLQUFLLFdBQVcsUUFBUTs7O0FDejlCaEQsTUFBQSxhQUFBLE1BQWdDO0lBQzlCLFlBQVksS0FBSyxXQUFXLE9BQU8sSUFBRztBQUNwQyxXQUFLLFdBQVc7QUFDaEIsVUFBRyxDQUFDLGFBQWEsVUFBVSxZQUFZLFNBQVMsVUFBUztBQUN2RCxjQUFNLElBQUksTUFBTTs7Ozs7Ozs7QUFRbEIsV0FBSyxTQUFTLElBQUksVUFBVSxLQUFLO0FBQ2pDLFdBQUssZ0JBQWdCLEtBQUssaUJBQWlCO0FBQzNDLFdBQUssT0FBTztBQUNaLFdBQUssU0FBUyxTQUFRLEtBQUssVUFBVTtBQUNyQyxXQUFLLGFBQWEsS0FBSztBQUN2QixXQUFLLG9CQUFvQixLQUFLLFlBQVk7QUFDMUMsV0FBSyxXQUFXLE9BQU8sT0FBTyxNQUFNLFdBQVcsS0FBSyxZQUFZO0FBQ2hFLFdBQUssZ0JBQWdCO0FBQ3JCLFdBQUssYUFBYTtBQUNsQixXQUFLLFdBQVc7QUFDaEIsV0FBSyxPQUFPO0FBQ1osV0FBSyxpQkFBaUI7QUFDdEIsV0FBSyx1QkFBdUI7QUFDNUIsV0FBSyxVQUFVO0FBQ2YsV0FBSyxRQUFRO0FBQ2IsV0FBSyxPQUFPLE9BQU8sU0FBUztBQUM1QixXQUFLLGNBQWM7QUFDbkIsV0FBSyxrQkFBa0IsTUFBTSxPQUFPO0FBQ3BDLFdBQUssUUFBUSxLQUFLLFNBQVM7QUFDM0IsV0FBSyxZQUFZLEtBQUssYUFBYTtBQUNuQyxXQUFLLGdCQUFnQixLQUFLLGlCQUFpQjtBQUMzQyxXQUFLLHdCQUF3QjtBQUM3QixXQUFLLGFBQWEsS0FBSyxjQUFjO0FBQ3JDLFdBQUssa0JBQWtCLEtBQUssbUJBQW1CO0FBQy9DLFdBQUssa0JBQWtCLEtBQUssbUJBQW1CO0FBQy9DLFdBQUssaUJBQWlCLEtBQUssa0JBQWtCO0FBQzdDLFdBQUssZUFBZSxLQUFLLGdCQUFnQixPQUFPO0FBQ2hELFdBQUssaUJBQWlCLEtBQUssa0JBQWtCLE9BQU87QUFDcEQsV0FBSyxzQkFBc0I7QUFDM0IsV0FBSyxlQUFlLE9BQU8sT0FBTyxFQUFDLGFBQWEsWUFBVyxtQkFBbUIsY0FBWSxLQUFLLE9BQU87QUFDdEcsV0FBSyxjQUFjLElBQUk7QUFDdkIsYUFBTyxpQkFBaUIsWUFBWSxDQUFBLE9BQU07QUFDeEMsYUFBSyxXQUFXOztBQUVsQixXQUFLLE9BQU8sT0FBTyxNQUFNO0FBQ3ZCLFlBQUcsS0FBSyxjQUFhO0FBRW5CLGlCQUFPLFNBQVM7Ozs7SUFPdEIsbUJBQWtCO0FBQUUsYUFBTyxLQUFLLGVBQWUsUUFBUSxvQkFBb0I7O0lBRTNFLGlCQUFnQjtBQUFFLGFBQU8sS0FBSyxlQUFlLFFBQVEsa0JBQWtCOztJQUV2RSxrQkFBaUI7QUFBRSxhQUFPLEtBQUssZUFBZSxRQUFRLGtCQUFrQjs7SUFFeEUsY0FBYTtBQUFFLFdBQUssZUFBZSxRQUFRLGNBQWM7O0lBRXpELGtCQUFpQjtBQUFFLFdBQUssZUFBZSxRQUFRLGdCQUFnQjs7SUFFL0QsZUFBYztBQUFFLFdBQUssZUFBZSxRQUFRLGNBQWM7O0lBRTFELG1CQUFrQjtBQUFFLFdBQUssZUFBZSxXQUFXOztJQUVuRCxpQkFBaUIsY0FBYTtBQUM1QixXQUFLO0FBQ0wsY0FBUSxJQUFJO0FBQ1osV0FBSyxlQUFlLFFBQVEsb0JBQW9COztJQUdsRCxvQkFBbUI7QUFBRSxXQUFLLGVBQWUsV0FBVzs7SUFFcEQsZ0JBQWU7QUFDYixVQUFJLE1BQU0sS0FBSyxlQUFlLFFBQVE7QUFDdEMsYUFBTyxNQUFNLFNBQVMsT0FBTzs7SUFHL0IsWUFBVztBQUFFLGFBQU8sS0FBSzs7SUFFekIsVUFBUztBQUVQLFVBQUcsT0FBTyxTQUFTLGFBQWEsZUFBZSxDQUFDLEtBQUssbUJBQWtCO0FBQUUsYUFBSzs7QUFDOUUsVUFBSSxZQUFZLE1BQU07QUFDcEIsWUFBRyxLQUFLLGlCQUFnQjtBQUN0QixlQUFLO0FBQ0wsZUFBSyxPQUFPO21CQUNKLEtBQUssTUFBSztBQUNsQixlQUFLLE9BQU87OztBQUdoQixVQUFHLENBQUMsWUFBWSxVQUFVLGVBQWUsUUFBUSxTQUFTLGVBQWUsR0FBRTtBQUN6RTthQUNLO0FBQ0wsaUJBQVMsaUJBQWlCLG9CQUFvQixNQUFNOzs7SUFJeEQsV0FBVyxVQUFTO0FBQ2xCLG1CQUFhLEtBQUs7QUFDbEIsV0FBSyxPQUFPLFdBQVc7O0lBR3pCLGlCQUFpQixXQUFVO0FBQ3pCLG1CQUFhLEtBQUs7QUFDbEIsV0FBSyxPQUFPLGlCQUFpQjtBQUM3QixXQUFLOztJQUdQLE9BQU8sSUFBSSxXQUFXLFlBQVksTUFBSztBQUNyQyxXQUFLLE1BQU0sSUFBSSxDQUFBLFNBQVEsV0FBRyxLQUFLLFdBQVcsV0FBVyxNQUFNOztJQUs3RCxXQUFXLE1BQU0sTUFBSztBQUFFLFdBQUssYUFBYSxNQUFNLEdBQUc7O0lBRW5ELEtBQUssTUFBTSxNQUFLO0FBQ2QsVUFBRyxDQUFDLEtBQUssc0JBQXNCLENBQUMsUUFBUSxNQUFLO0FBQUUsZUFBTzs7QUFDdEQsY0FBUSxLQUFLO0FBQ2IsVUFBSSxTQUFTO0FBQ2IsY0FBUSxRQUFRO0FBQ2hCLGFBQU87O0lBR1QsSUFBSSxNQUFNLE1BQU0sYUFBWTtBQUMxQixVQUFHLEtBQUssWUFBVztBQUNqQixZQUFJLENBQUMsS0FBSyxPQUFPO0FBQ2pCLGFBQUssV0FBVyxNQUFNLE1BQU0sS0FBSztpQkFDekIsS0FBSyxrQkFBaUI7QUFDOUIsWUFBSSxDQUFDLEtBQUssT0FBTztBQUNqQixjQUFNLE1BQU0sTUFBTSxLQUFLOzs7SUFJM0IsaUJBQWlCLFVBQVM7QUFDeEIsV0FBSyxZQUFZLE1BQU07O0lBR3pCLFdBQVcsTUFBTSxTQUFTLFNBQVMsV0FBVTtPQUFHO0FBQzlDLFdBQUssWUFBWSxjQUFjLE1BQU0sU0FBUzs7SUFHaEQsVUFBVSxTQUFTLE9BQU8sSUFBRztBQUMzQixjQUFRLEdBQUcsT0FBTyxDQUFBLFNBQVE7QUFDeEIsWUFBSSxVQUFVLEtBQUs7QUFDbkIsWUFBRyxDQUFDLFNBQVE7QUFDVixhQUFHO2VBQ0U7QUFDTCxrQkFBUSxJQUFJLGNBQWM7QUFDMUIscUJBQVcsTUFBTSxHQUFHLE9BQU87Ozs7SUFLakMsU0FBUyxNQUFNLE1BQU0sTUFBSztBQUN4QixVQUFJLFVBQVUsS0FBSztBQUNuQixVQUFJLGVBQWUsS0FBSztBQUN4QixVQUFHLENBQUMsU0FBUTtBQUNWLFlBQUcsS0FBSyxpQkFBaUIsS0FBSyxTQUFRO0FBQ3BDLGlCQUFPLE9BQU8sUUFBUSxXQUFXLE1BQU07QUFDckMsZ0JBQUcsS0FBSyxjQUFjLGdCQUFnQixDQUFDLEtBQUssZUFBYztBQUN4RCxtQkFBSyxpQkFBaUIsTUFBTSxNQUFNO0FBQ2hDLHFCQUFLLElBQUksTUFBTSxXQUFXLE1BQU0sQ0FBQzs7OztlQUlsQztBQUNMLGlCQUFPOzs7QUFJWCxjQUFRLElBQUksY0FBYztBQUMxQixVQUFJLFdBQVc7UUFDYixVQUFVO1FBQ1YsUUFBUSxNQUFNLElBQUc7QUFBRSxlQUFLLFNBQVMsS0FBSyxDQUFDLE1BQU07OztBQUUvQyxpQkFBVyxNQUFNO0FBQ2YsWUFBRyxLQUFLLGVBQWM7QUFBRTs7QUFDeEIsaUJBQVMsU0FBUyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sUUFBUSxJQUFJLFFBQVEsTUFBTSxLQUFLO1NBQ3BFO0FBQ0gsYUFBTzs7SUFHVCxpQkFBaUIsTUFBTSxLQUFJO0FBQ3pCLG1CQUFhLEtBQUs7QUFDbEIsV0FBSztBQUNMLFVBQUksUUFBUSxLQUFLO0FBQ2pCLFVBQUksUUFBUSxLQUFLO0FBQ2pCLFVBQUksVUFBVSxLQUFLLE1BQU0sS0FBSyxXQUFZLFNBQVEsUUFBUSxNQUFNO0FBQ2hFLFVBQUksUUFBUSxnQkFBUSxZQUFZLEtBQUssY0FBYyxPQUFPLFNBQVMsVUFBVSxxQkFBcUIsR0FBRyxDQUFBLFVBQVMsUUFBUTtBQUN0SCxVQUFHLFFBQVEsS0FBSyxZQUFXO0FBQ3pCLGtCQUFVLEtBQUs7O0FBRWpCLFdBQUssd0JBQXdCLFdBQVcsTUFBTTtBQUU1QyxZQUFHLEtBQUssaUJBQWlCLEtBQUssZUFBYztBQUFFOztBQUM5QyxhQUFLO0FBQ0wsY0FBTSxRQUFRLEtBQUssSUFBSSxNQUFNLFFBQVEsTUFBTSxDQUFDLGVBQWU7QUFDM0QsWUFBRyxRQUFRLEtBQUssWUFBVztBQUN6QixlQUFLLElBQUksTUFBTSxRQUFRLE1BQU0sQ0FBQyxZQUFZLEtBQUs7O0FBRWpELFlBQUcsS0FBSyxrQkFBaUI7QUFDdkIsaUJBQU8sV0FBVyxLQUFLO2VBQ2xCO0FBQ0wsaUJBQU8sU0FBUzs7U0FFakI7O0lBR0wsaUJBQWlCLE1BQUs7QUFDcEIsYUFBTyxRQUFRLEtBQUssV0FBVyxjQUFjLGNBQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU07O0lBR3RGLGFBQVk7QUFBRSxhQUFPLEtBQUs7O0lBRTFCLGNBQWE7QUFBRSxhQUFPLEtBQUssT0FBTzs7SUFFbEMsbUJBQWtCO0FBQUUsYUFBTyxLQUFLOztJQUVoQyxRQUFRLE1BQUs7QUFBRSxhQUFPLEdBQUcsS0FBSyxxQkFBcUI7O0lBRW5ELFFBQVEsT0FBTyxRQUFPO0FBQUUsYUFBTyxLQUFLLE9BQU8sUUFBUSxPQUFPOztJQUUxRCxnQkFBZTtBQUNiLFVBQUksYUFBYTtBQUNqQixrQkFBSSxJQUFJLFVBQVUsR0FBRywwQkFBMEIsbUJBQW1CLENBQUEsV0FBVTtBQUMxRSxZQUFHLENBQUMsS0FBSyxZQUFZLE9BQU8sS0FBSTtBQUM5QixjQUFJLE9BQU8sS0FBSyxZQUFZO0FBQzVCLGVBQUssUUFBUSxLQUFLO0FBQ2xCLGVBQUs7QUFDTCxjQUFHLE9BQU8sYUFBYSxXQUFVO0FBQUUsaUJBQUssT0FBTzs7O0FBRWpELHFCQUFhOztBQUVmLGFBQU87O0lBR1QsU0FBUyxJQUFJLE9BQU07QUFDakIsV0FBSztBQUNMLHNCQUFRLFNBQVMsSUFBSTs7SUFHdkIsWUFBWSxNQUFNLE9BQU8sV0FBVyxNQUFNLFVBQVUsS0FBSyxlQUFlLE9BQU07QUFDNUUsV0FBSyxpQkFBaUIsS0FBSyxrQkFBa0IsS0FBSyxLQUFLO0FBQ3ZELFVBQUksWUFBWSxZQUFJLFVBQVUsS0FBSyxnQkFBZ0I7QUFDbkQsV0FBSyxLQUFLLFdBQVcsS0FBSztBQUMxQixXQUFLLEtBQUs7QUFFVixXQUFLLE9BQU8sS0FBSyxZQUFZLFdBQVc7QUFDeEMsV0FBSyxLQUFLLFlBQVk7QUFDdEIsV0FBSztBQUNMLFdBQUssS0FBSyxLQUFLLENBQUMsV0FBVyxXQUFXO0FBQ3BDLFlBQUcsY0FBYyxLQUFLLEtBQUssa0JBQWtCLFVBQVM7QUFDcEQsZUFBSyxpQkFBaUIsTUFBTTtBQUMxQix3QkFBSSxjQUFjLFVBQVUsUUFBUSxDQUFBLE9BQU0sVUFBVSxZQUFZO0FBQ2hFLGlCQUFLLGVBQWUsWUFBWTtBQUNoQyxpQkFBSyxpQkFBaUI7QUFDdEIsd0JBQVksc0JBQXNCO0FBQ2xDOzs7OztJQU1SLGtCQUFrQixVQUFTO0FBQ3pCLFVBQUksYUFBYSxLQUFLLFFBQVE7QUFDOUIsaUJBQVcsWUFBWSxZQUFJLElBQUksVUFBVSxJQUFJO0FBQzdDLGVBQVMsUUFBUSxDQUFBLE9BQU07QUFDckIsWUFBRyxTQUFTLEtBQUssU0FBUyxLQUFJO0FBQzVCLGVBQUssT0FBTyxJQUFJLEdBQUcsYUFBYSxhQUFhOzs7O0lBS25ELFVBQVUsSUFBRztBQUFFLGFBQU8sR0FBRyxnQkFBZ0IsR0FBRyxhQUFhLGlCQUFpQjs7SUFFMUUsWUFBWSxJQUFJLE9BQU07QUFDcEIsVUFBSSxPQUFPLElBQUksS0FBSyxJQUFJLE1BQU0sTUFBTTtBQUNwQyxXQUFLLE1BQU0sS0FBSyxNQUFNO0FBQ3RCLGFBQU87O0lBR1QsTUFBTSxTQUFTLFVBQVM7QUFDdEIsVUFBSSxPQUFPLE1BQU0sUUFBUSxRQUFRLG9CQUFvQixDQUFBLE9BQU0sS0FBSyxZQUFZLFFBQVEsS0FBSztBQUN6RixVQUFHLE1BQUs7QUFBRSxpQkFBUzs7O0lBR3JCLGFBQWEsU0FBUyxVQUFTO0FBQzdCLFdBQUssTUFBTSxTQUFTLENBQUEsU0FBUSxTQUFTLE1BQU07O0lBRzdDLFlBQVksSUFBRztBQUNiLFVBQUksU0FBUyxHQUFHLGFBQWE7QUFDN0IsYUFBTyxNQUFNLEtBQUssWUFBWSxTQUFTLENBQUEsU0FBUSxLQUFLLGtCQUFrQjs7SUFHeEUsWUFBWSxJQUFHO0FBQUUsYUFBTyxLQUFLLE1BQU07O0lBRW5DLGtCQUFpQjtBQUNmLGVBQVEsTUFBTSxLQUFLLE9BQU07QUFDdkIsYUFBSyxNQUFNLElBQUk7QUFDZixlQUFPLEtBQUssTUFBTTs7QUFFcEIsV0FBSyxPQUFPOztJQUdkLGdCQUFnQixJQUFHO0FBQ2pCLFVBQUksT0FBTyxLQUFLLFlBQVksR0FBRyxhQUFhO0FBQzVDLFVBQUcsUUFBUSxLQUFLLE9BQU8sR0FBRyxJQUFHO0FBQzNCLGFBQUs7QUFDTCxlQUFPLEtBQUssTUFBTSxLQUFLO2lCQUNmLE1BQUs7QUFDYixhQUFLLGtCQUFrQixHQUFHOzs7SUFJOUIsaUJBQWlCLFFBQU87QUFDdEIsVUFBRyxLQUFLLGtCQUFrQixRQUFPO0FBQUU7O0FBQ25DLFdBQUssZ0JBQWdCO0FBQ3JCLFVBQUksU0FBUyxNQUFNO0FBQ2pCLFlBQUcsV0FBVyxLQUFLLGVBQWM7QUFBRSxlQUFLLGdCQUFnQjs7QUFDeEQsZUFBTyxvQkFBb0IsV0FBVztBQUN0QyxlQUFPLG9CQUFvQixZQUFZOztBQUV6QyxhQUFPLGlCQUFpQixXQUFXO0FBQ25DLGFBQU8saUJBQWlCLFlBQVk7O0lBR3RDLG1CQUFrQjtBQUNoQixVQUFHLFNBQVMsa0JBQWtCLFNBQVMsTUFBSztBQUMxQyxlQUFPLEtBQUssaUJBQWlCLFNBQVM7YUFDakM7QUFFTCxlQUFPLFNBQVMsaUJBQWlCLFNBQVM7OztJQUk5QyxrQkFBa0IsTUFBSztBQUNyQixVQUFHLEtBQUssY0FBYyxLQUFLLFlBQVksS0FBSyxhQUFZO0FBQ3RELGFBQUssYUFBYTs7O0lBSXRCLCtCQUE4QjtBQUM1QixVQUFHLEtBQUssY0FBYyxLQUFLLGVBQWUsU0FBUyxNQUFLO0FBQ3RELGFBQUssV0FBVzs7O0lBSXBCLG9CQUFtQjtBQUNqQixXQUFLLGFBQWEsS0FBSztBQUN2QixVQUFHLEtBQUssZUFBZSxTQUFTLE1BQUs7QUFBRSxhQUFLLFdBQVc7OztJQUd6RCxxQkFBb0I7QUFDbEIsVUFBRyxLQUFLLHFCQUFvQjtBQUFFOztBQUU5QixXQUFLLHNCQUFzQjtBQUUzQixXQUFLLE9BQU8sUUFBUSxDQUFBLFVBQVM7QUFDM0IsWUFBRyxTQUFTLE1BQU0sU0FBUyxPQUFRLEtBQUssTUFBSztBQUMzQyxlQUFLLGlCQUFpQixLQUFLOzs7QUFHL0IsZUFBUyxLQUFLLGlCQUFpQixTQUFTLFdBQVc7O0FBQ25ELGFBQU8saUJBQWlCLFlBQVksQ0FBQSxNQUFLO0FBQ3ZDLFlBQUcsRUFBRSxXQUFVO0FBQ2IsZUFBSyxZQUFZO0FBQ2pCLGVBQUssZ0JBQWdCLEVBQUMsSUFBSSxPQUFPLFNBQVMsTUFBTSxNQUFNO0FBQ3RELGlCQUFPLFNBQVM7O1NBRWpCO0FBQ0gsV0FBSztBQUNMLFdBQUs7QUFDTCxXQUFLO0FBQ0wsV0FBSyxLQUFLLEVBQUMsT0FBTyxTQUFTLFNBQVMsYUFBWSxDQUFDLEdBQUcsTUFBTSxNQUFNLFVBQVUsVUFBVSxnQkFBZ0I7QUFDbEcsWUFBSSxXQUFXLFNBQVMsYUFBYSxLQUFLLFFBQVE7QUFDbEQsWUFBSSxhQUFhLEVBQUUsT0FBTyxFQUFFLElBQUk7QUFDaEMsWUFBRyxZQUFZLFNBQVMsa0JBQWtCLFlBQVc7QUFBRTs7QUFFdkQsWUFBSSxPQUFPLGlCQUFDLEtBQUssRUFBRSxPQUFRLEtBQUssVUFBVSxNQUFNLEdBQUc7QUFDbkQsbUJBQUcsS0FBSyxNQUFNLFVBQVUsTUFBTSxVQUFVLENBQUMsUUFBUSxFQUFDOztBQUVwRCxXQUFLLEtBQUssRUFBQyxNQUFNLFlBQVksT0FBTyxhQUFZLENBQUMsR0FBRyxNQUFNLE1BQU0sVUFBVSxVQUFVLGdCQUFnQjtBQUNsRyxZQUFHLENBQUMsYUFBWTtBQUNkLGNBQUksT0FBTyxpQkFBQyxLQUFLLEVBQUUsT0FBUSxLQUFLLFVBQVUsTUFBTSxHQUFHO0FBQ25ELHFCQUFHLEtBQUssTUFBTSxVQUFVLE1BQU0sVUFBVSxDQUFDLFFBQVEsRUFBQzs7O0FBR3RELFdBQUssS0FBSyxFQUFDLE1BQU0sUUFBUSxPQUFPLFdBQVUsQ0FBQyxHQUFHLE1BQU0sTUFBTSxVQUFVLFdBQVcsVUFBVSxjQUFjO0FBRXJHLFlBQUcsY0FBYyxVQUFTO0FBQ3hCLGNBQUksT0FBTyxLQUFLLFVBQVUsTUFBTSxHQUFHO0FBQ25DLHFCQUFHLEtBQUssTUFBTSxVQUFVLE1BQU0sVUFBVSxDQUFDLFFBQVEsRUFBQzs7O0FBR3RELGFBQU8saUJBQWlCLFlBQVksQ0FBQSxNQUFLLEVBQUU7QUFDM0MsYUFBTyxpQkFBaUIsUUFBUSxDQUFBLE1BQUs7QUFDbkMsVUFBRTtBQUNGLFlBQUksZUFBZSxNQUFNLGtCQUFrQixFQUFFLFFBQVEsS0FBSyxRQUFRLG1CQUFtQixDQUFBLGVBQWM7QUFDakcsaUJBQU8sV0FBVyxhQUFhLEtBQUssUUFBUTs7QUFFOUMsWUFBSSxhQUFhLGdCQUFnQixTQUFTLGVBQWU7QUFDekQsWUFBSSxRQUFRLE1BQU0sS0FBSyxFQUFFLGFBQWEsU0FBUztBQUMvQyxZQUFHLENBQUMsY0FBYyxXQUFXLFlBQVksTUFBTSxXQUFXLEtBQUssQ0FBRSxZQUFXLGlCQUFpQixXQUFVO0FBQUU7O0FBRXpHLHFCQUFhLFdBQVcsWUFBWTtBQUNwQyxtQkFBVyxjQUFjLElBQUksTUFBTSxTQUFTLEVBQUMsU0FBUzs7QUFFeEQsV0FBSyxHQUFHLG1CQUFtQixDQUFBLE1BQUs7QUFDOUIsWUFBSSxlQUFlLEVBQUU7QUFDckIsWUFBRyxDQUFDLFlBQUksY0FBYyxlQUFjO0FBQUU7O0FBQ3RDLFlBQUksUUFBUSxNQUFNLEtBQUssRUFBRSxPQUFPLFNBQVMsSUFBSSxPQUFPLENBQUEsTUFBSyxhQUFhLFFBQVEsYUFBYTtBQUMzRixxQkFBYSxXQUFXLGNBQWM7QUFDdEMscUJBQWEsY0FBYyxJQUFJLE1BQU0sU0FBUyxFQUFDLFNBQVM7OztJQUk1RCxVQUFVLFdBQVcsR0FBRyxVQUFTO0FBQy9CLFVBQUksV0FBVyxLQUFLLGtCQUFrQjtBQUN0QyxhQUFPLFdBQVcsU0FBUyxHQUFHLFlBQVk7O0lBRzVDLGVBQWUsTUFBSztBQUNsQixXQUFLO0FBQ0wsV0FBSyxjQUFjO0FBQ25CLGFBQU8sS0FBSzs7SUFHZCxrQkFBa0IsU0FBUTtBQUN4QixVQUFHLEtBQUssWUFBWSxTQUFRO0FBQzFCLGVBQU87YUFDRjtBQUNMLGFBQUssT0FBTyxLQUFLO0FBQ2pCLGFBQUssY0FBYztBQUNuQixlQUFPOzs7SUFJWCxVQUFTO0FBQUUsYUFBTyxLQUFLOztJQUV2QixpQkFBZ0I7QUFBRSxhQUFPLENBQUMsQ0FBQyxLQUFLOztJQUVoQyxLQUFLLFFBQVEsVUFBUztBQUNwQixlQUFRLFNBQVMsUUFBTztBQUN0QixZQUFJLG1CQUFtQixPQUFPO0FBRTlCLGFBQUssR0FBRyxrQkFBa0IsQ0FBQSxNQUFLO0FBQzdCLGNBQUksVUFBVSxLQUFLLFFBQVE7QUFDM0IsY0FBSSxnQkFBZ0IsS0FBSyxRQUFRLFVBQVU7QUFDM0MsY0FBSSxpQkFBaUIsRUFBRSxPQUFPLGdCQUFnQixFQUFFLE9BQU8sYUFBYTtBQUNwRSxjQUFHLGdCQUFlO0FBQ2hCLGlCQUFLLFNBQVMsRUFBRSxRQUFRLEdBQUcsa0JBQWtCLE1BQU07QUFDakQsbUJBQUssYUFBYSxFQUFFLFFBQVEsQ0FBQSxTQUFRO0FBQ2xDLHlCQUFTLEdBQUcsT0FBTyxNQUFNLEVBQUUsUUFBUSxnQkFBZ0I7OztpQkFHbEQ7QUFDTCx3QkFBSSxJQUFJLFVBQVUsSUFBSSxrQkFBa0IsQ0FBQSxPQUFNO0FBQzVDLGtCQUFJLFdBQVcsR0FBRyxhQUFhO0FBQy9CLG1CQUFLLFNBQVMsSUFBSSxHQUFHLGtCQUFrQixNQUFNO0FBQzNDLHFCQUFLLGFBQWEsSUFBSSxDQUFBLFNBQVE7QUFDNUIsMkJBQVMsR0FBRyxPQUFPLE1BQU0sSUFBSSxVQUFVOzs7Ozs7OztJQVNyRCxhQUFZO0FBQ1YsYUFBTyxpQkFBaUIsYUFBYSxDQUFBLE1BQUssS0FBSyx1QkFBdUIsRUFBRTtBQUN4RSxXQUFLLFVBQVUsU0FBUyxTQUFTO0FBQ2pDLFdBQUssVUFBVSxhQUFhLGlCQUFpQjs7SUFHL0MsVUFBVSxXQUFXLGFBQWEsU0FBUTtBQUN4QyxVQUFJLFFBQVEsS0FBSyxRQUFRO0FBQ3pCLGFBQU8saUJBQWlCLFdBQVcsQ0FBQSxNQUFLO0FBQ3RDLFlBQUksU0FBUztBQUNiLFlBQUcsU0FBUTtBQUNULG1CQUFTLEVBQUUsT0FBTyxRQUFRLElBQUksWUFBWSxFQUFFLFNBQVMsRUFBRSxPQUFPLGNBQWMsSUFBSTtlQUMzRTtBQUNMLGNBQUksdUJBQXVCLEtBQUssd0JBQXdCLEVBQUU7QUFDMUQsbUJBQVMsa0JBQWtCLHNCQUFzQjtBQUNqRCxlQUFLLGtCQUFrQixHQUFHO0FBQzFCLGVBQUssdUJBQXVCOztBQUU5QixZQUFJLFdBQVcsVUFBVSxPQUFPLGFBQWE7QUFDN0MsWUFBRyxDQUFDLFVBQVM7QUFBRTs7QUFDZixZQUFHLE9BQU8sYUFBYSxZQUFZLEtBQUk7QUFBRSxZQUFFOztBQUUzQyxhQUFLLFNBQVMsUUFBUSxHQUFHLFNBQVMsTUFBTTtBQUN0QyxlQUFLLGFBQWEsUUFBUSxDQUFBLFNBQVE7QUFDaEMsdUJBQUcsS0FBSyxTQUFTLFVBQVUsTUFBTSxRQUFRLENBQUMsUUFBUSxFQUFDLE1BQU0sS0FBSyxVQUFVLFNBQVMsR0FBRzs7O1NBR3ZGOztJQUdMLGtCQUFrQixHQUFHLGdCQUFlO0FBQ2xDLFVBQUksZUFBZSxLQUFLLFFBQVE7QUFDaEMsa0JBQUksSUFBSSxVQUFVLElBQUksaUJBQWlCLENBQUEsT0FBTTtBQUMzQyxZQUFHLENBQUUsSUFBRyxXQUFXLG1CQUFtQixHQUFHLFNBQVMsa0JBQWlCO0FBQ2pFLGVBQUssYUFBYSxFQUFFLFFBQVEsQ0FBQSxTQUFRO0FBQ2xDLGdCQUFJLFdBQVcsR0FBRyxhQUFhO0FBQy9CLGdCQUFHLFdBQUcsVUFBVSxLQUFJO0FBQ2xCLHlCQUFHLEtBQUssU0FBUyxVQUFVLE1BQU0sSUFBSSxDQUFDLFFBQVEsRUFBQyxNQUFNLEtBQUssVUFBVSxTQUFTLEdBQUcsRUFBRTs7Ozs7O0lBTzVGLFVBQVM7QUFDUCxVQUFHLENBQUMsZ0JBQVEsZ0JBQWU7QUFBRTs7QUFDN0IsVUFBRyxRQUFRLG1CQUFrQjtBQUFFLGdCQUFRLG9CQUFvQjs7QUFDM0QsVUFBSSxjQUFjO0FBQ2xCLGFBQU8saUJBQWlCLFVBQVUsQ0FBQSxPQUFNO0FBQ3RDLHFCQUFhO0FBQ2Isc0JBQWMsV0FBVyxNQUFNO0FBQzdCLDBCQUFRLG1CQUFtQixDQUFBLFVBQVMsT0FBTyxPQUFPLE9BQU8sRUFBQyxRQUFRLE9BQU87V0FDeEU7O0FBRUwsYUFBTyxpQkFBaUIsWUFBWSxDQUFBLFVBQVM7QUFDM0MsWUFBRyxDQUFDLEtBQUssb0JBQW9CLE9BQU8sV0FBVTtBQUFFOztBQUNoRCxZQUFJLEVBQUMsTUFBTSxJQUFJLE1BQU0sb0JBQVUsTUFBTSxTQUFTO0FBQzlDLFlBQUksT0FBTyxPQUFPLFNBQVM7QUFFM0IsYUFBSyxpQkFBaUIsTUFBTTtBQUMxQixjQUFHLEtBQUssS0FBSyxpQkFBa0IsVUFBUyxXQUFXLE9BQU8sS0FBSyxLQUFLLEtBQUk7QUFDdEUsaUJBQUssS0FBSyxjQUFjLE1BQU07aUJBQ3pCO0FBQ0wsaUJBQUssWUFBWSxNQUFNLE1BQU0sTUFBTTtBQUNqQyxrQkFBRyxNQUFLO0FBQUUscUJBQUs7O0FBQ2Ysa0JBQUcsT0FBTyxZQUFZLFVBQVM7QUFDN0IsMkJBQVcsTUFBTTtBQUNmLHlCQUFPLFNBQVMsR0FBRzttQkFDbEI7Ozs7O1NBS1Y7QUFDSCxhQUFPLGlCQUFpQixTQUFTLENBQUEsTUFBSztBQUNwQyxZQUFJLFNBQVMsa0JBQWtCLEVBQUUsUUFBUTtBQUN6QyxZQUFJLE9BQU8sVUFBVSxPQUFPLGFBQWE7QUFDekMsWUFBSSxjQUFjLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxXQUFXO0FBQ3pELFlBQUcsQ0FBQyxRQUFRLENBQUMsS0FBSyxpQkFBaUIsQ0FBQyxLQUFLLFFBQVEsYUFBWTtBQUFFOztBQUUvRCxZQUFJLE9BQU8sT0FBTztBQUNsQixZQUFJLFlBQVksT0FBTyxhQUFhO0FBQ3BDLFVBQUU7QUFDRixVQUFFO0FBQ0YsWUFBRyxLQUFLLGdCQUFnQixNQUFLO0FBQUU7O0FBRS9CLGFBQUssaUJBQWlCLE1BQU07QUFDMUIsY0FBRyxTQUFTLFNBQVE7QUFDbEIsaUJBQUssaUJBQWlCLE1BQU0sV0FBVztxQkFDL0IsU0FBUyxZQUFXO0FBQzVCLGlCQUFLLGdCQUFnQixNQUFNO2lCQUN0QjtBQUNMLGtCQUFNLElBQUksTUFBTSxZQUFZLG1EQUFtRDs7O1NBR2xGOztJQUdMLGNBQWMsT0FBTyxVQUFVLElBQUc7QUFDaEMsa0JBQUksY0FBYyxRQUFRLE9BQU8sU0FBUyxFQUFDLFFBQVE7O0lBR3JELGVBQWUsUUFBTztBQUNwQixhQUFPLFFBQVEsQ0FBQyxDQUFDLE9BQU8sYUFBYSxLQUFLLGNBQWMsT0FBTzs7SUFHakUsZ0JBQWdCLE1BQU0sVUFBUztBQUM3QixrQkFBSSxjQUFjLFFBQVEsMEJBQTBCLEVBQUMsUUFBUTtBQUM3RCxVQUFJLE9BQU8sTUFBTSxZQUFJLGNBQWMsUUFBUSx5QkFBeUIsRUFBQyxRQUFRO0FBQzdFLGFBQU8sV0FBVyxTQUFTLFFBQVE7O0lBR3JDLGlCQUFpQixNQUFNLFdBQVcsVUFBUztBQUN6QyxXQUFLLGdCQUFnQixFQUFDLElBQUksTUFBTSxNQUFNLFdBQVUsQ0FBQSxTQUFRO0FBQ3RELGFBQUssS0FBSyxjQUFjLE1BQU0sVUFBVSxDQUFBLFlBQVc7QUFDakQsZUFBSyxhQUFhLE1BQU0sV0FBVztBQUNuQzs7OztJQUtOLGFBQWEsTUFBTSxXQUFXLFVBQVUsS0FBSyxlQUFlLE9BQU07QUFDaEUsVUFBRyxDQUFDLEtBQUssa0JBQWtCLFVBQVM7QUFBRTs7QUFFdEMsc0JBQVEsVUFBVSxXQUFXLEVBQUMsTUFBTSxTQUFTLElBQUksS0FBSyxLQUFLLE1BQUs7QUFDaEUsV0FBSyxvQkFBb0IsT0FBTzs7SUFHbEMsZ0JBQWdCLE1BQU0sV0FBVyxPQUFNO0FBQ3JDLFVBQUksVUFBUyxPQUFPO0FBQ3BCLFdBQUssZ0JBQWdCLEVBQUMsSUFBSSxNQUFNLE1BQU0sY0FBYSxDQUFBLFNBQVE7QUFDekQsYUFBSyxZQUFZLE1BQU0sT0FBTyxNQUFNO0FBQ2xDLDBCQUFRLFVBQVUsV0FBVyxFQUFDLE1BQU0sWUFBWSxJQUFJLEtBQUssS0FBSyxJQUFJLG1CQUFpQjtBQUNuRixlQUFLLG9CQUFvQixPQUFPO0FBQ2hDOzs7O0lBS04scUJBQW9CO0FBQ2xCLHNCQUFRLFVBQVUsV0FBVyxFQUFDLE1BQU0sTUFBTSxNQUFNLFNBQVMsSUFBSSxLQUFLLEtBQUs7O0lBR3pFLG9CQUFvQixhQUFZO0FBQzlCLFVBQUksRUFBQyxVQUFVLFdBQVUsS0FBSztBQUM5QixVQUFHLFdBQVcsV0FBVyxZQUFZLFdBQVcsWUFBWSxRQUFPO0FBQ2pFLGVBQU87YUFDRjtBQUNMLGFBQUssa0JBQWtCLE1BQU07QUFDN0IsZUFBTzs7O0lBSVgsWUFBVztBQUNULFVBQUksYUFBYTtBQUNqQixXQUFLLEdBQUcsVUFBVSxDQUFBLE1BQUs7QUFDckIsWUFBSSxXQUFXLEVBQUUsT0FBTyxhQUFhLEtBQUssUUFBUTtBQUNsRCxZQUFHLENBQUMsVUFBUztBQUFFOztBQUNmLFVBQUU7QUFDRixVQUFFLE9BQU8sV0FBVztBQUNwQixhQUFLLGFBQWEsRUFBRSxRQUFRLENBQUEsU0FBUTtBQUNsQyxxQkFBRyxLQUFLLFVBQVUsVUFBVSxNQUFNLEVBQUUsUUFBUSxDQUFDLFFBQVE7O1NBRXREO0FBRUgsZUFBUSxRQUFRLENBQUMsVUFBVSxVQUFTO0FBQ2xDLGFBQUssR0FBRyxNQUFNLENBQUEsTUFBSztBQUNqQixjQUFJLFlBQVksS0FBSyxRQUFRO0FBQzdCLGNBQUksUUFBUSxFQUFFO0FBQ2QsY0FBSSxhQUFhLE1BQU0sYUFBYTtBQUNwQyxjQUFJLFlBQVksTUFBTSxRQUFRLE1BQU0sS0FBSyxhQUFhO0FBQ3RELGNBQUksV0FBVyxjQUFjO0FBQzdCLGNBQUcsQ0FBQyxVQUFTO0FBQUU7O0FBQ2YsY0FBRyxNQUFNLFNBQVMsWUFBWSxNQUFNLFlBQVksTUFBTSxTQUFTLFVBQVM7QUFBRTs7QUFFMUUsY0FBSSxhQUFhLGFBQWEsUUFBUSxNQUFNO0FBQzVDLGNBQUksb0JBQW9CO0FBQ3hCO0FBQ0EsY0FBSSxFQUFDLElBQVEsTUFBTSxhQUFZLFlBQUksUUFBUSxPQUFPLHFCQUFxQjtBQUV2RSxjQUFHLE9BQU8sb0JBQW9CLEtBQUssU0FBUyxVQUFTO0FBQUU7O0FBRXZELHNCQUFJLFdBQVcsT0FBTyxrQkFBa0IsRUFBQyxJQUFJLG1CQUFtQjtBQUVoRSxlQUFLLFNBQVMsT0FBTyxHQUFHLE1BQU0sTUFBTTtBQUNsQyxpQkFBSyxhQUFhLFlBQVksQ0FBQSxTQUFRO0FBQ3BDLDBCQUFJLFdBQVcsT0FBTyxpQkFBaUI7QUFDdkMsa0JBQUcsQ0FBQyxZQUFJLGVBQWUsUUFBTztBQUM1QixxQkFBSyxpQkFBaUI7O0FBRXhCLHlCQUFHLEtBQUssVUFBVSxVQUFVLE1BQU0sT0FBTyxDQUFDLFFBQVEsRUFBQyxTQUFTLEVBQUUsT0FBTyxNQUFNOzs7V0FHOUU7OztJQUlQLFNBQVMsSUFBSSxPQUFPLFdBQVcsVUFBUztBQUN0QyxVQUFHLGNBQWMsVUFBVSxjQUFjLFlBQVc7QUFBRSxlQUFPOztBQUU3RCxVQUFJLGNBQWMsS0FBSyxRQUFRO0FBQy9CLFVBQUksY0FBYyxLQUFLLFFBQVE7QUFDL0IsVUFBSSxrQkFBa0IsS0FBSyxTQUFTLFNBQVM7QUFDN0MsVUFBSSxrQkFBa0IsS0FBSyxTQUFTLFNBQVM7QUFFN0MsV0FBSyxhQUFhLElBQUksQ0FBQSxTQUFRO0FBQzVCLFlBQUksY0FBYyxNQUFNLENBQUMsS0FBSyxpQkFBaUIsU0FBUyxLQUFLLFNBQVM7QUFDdEUsb0JBQUksU0FBUyxJQUFJLE9BQU8sYUFBYSxpQkFBaUIsYUFBYSxpQkFBaUIsYUFBYSxNQUFNO0FBQ3JHOzs7O0lBS04sY0FBYyxVQUFTO0FBQ3JCLFdBQUssV0FBVztBQUNoQjtBQUNBLFdBQUssV0FBVzs7SUFHbEIsR0FBRyxPQUFPLFVBQVM7QUFDakIsYUFBTyxpQkFBaUIsT0FBTyxDQUFBLE1BQUs7QUFDbEMsWUFBRyxDQUFDLEtBQUssVUFBUztBQUFFLG1CQUFTOzs7OztBQUtuQyxNQUFBLGdCQUFBLE1BQW9CO0lBQ2xCLGNBQWE7QUFDWCxXQUFLLGNBQWMsb0JBQUk7QUFDdkIsV0FBSyxhQUFhO0FBQ2xCLFdBQUs7O0lBR1AsUUFBTztBQUNMLFdBQUssWUFBWSxRQUFRLENBQUEsVUFBUztBQUNoQyxzQkFBYztBQUNkLGFBQUssWUFBWSxPQUFPOztBQUUxQixXQUFLOztJQUdQLE1BQU0sVUFBUztBQUNiLFVBQUcsS0FBSyxXQUFXLEdBQUU7QUFDbkI7YUFDSztBQUNMLGFBQUssY0FBYzs7O0lBSXZCLGNBQWMsTUFBTSxTQUFTLFFBQU87QUFDbEM7QUFDQSxVQUFJLFFBQVEsV0FBVyxNQUFNO0FBQzNCLGFBQUssWUFBWSxPQUFPO0FBQ3hCO0FBQ0EsWUFBRyxLQUFLLFdBQVcsR0FBRTtBQUFFLGVBQUs7O1NBQzNCO0FBQ0gsV0FBSyxZQUFZLElBQUk7O0lBR3ZCLGNBQWMsSUFBRztBQUFFLFdBQUssV0FBVyxLQUFLOztJQUV4QyxPQUFNO0FBQUUsYUFBTyxLQUFLLFlBQVk7O0lBRWhDLGtCQUFpQjtBQUNmLFdBQUssV0FBVyxRQUFRLENBQUEsT0FBTTtBQUM5QixXQUFLLGFBQWE7Ozs7O0FDMzFCdEIsNEJBQW9CO0FBQUEsSUFFbEIsWUFBWSxNQUFNO0FBRWhCLFdBQUssWUFBWTtBQUNqQixXQUFLLE9BQU87QUFBQTtBQUFBLFFBR1YsT0FBTztBQUNULGFBQU8sS0FBSyxZQUFZO0FBQUE7QUFBQSxRQUd0QixhQUFhO0FBQ2YsYUFBTyxLQUFLLFlBQVk7QUFBQTtBQUFBLElBRzFCLFNBQVM7QUFDUCxXQUFLLFlBQVk7QUFBQTtBQUFBLElBR25CLFdBQVc7QUFDVCxhQUFPLEtBQUs7QUFBQTtBQUFBLElBR2QsTUFBTSxNQUFNO0FBQ1YsYUFBTyxJQUFJLEtBQUssWUFBWSxrQ0FDdkIsS0FBSyxPQUNMO0FBQUE7QUFBQTtBQUtULGdCQUFjLE9BQU87QUFFckIsZ0JBQWMsYUFBYTs7O0FDbEMzQiw2QkFBcUI7QUFBQSxJQUVuQixZQUFZLFdBQVc7QUFDckIsV0FBSyxZQUFZO0FBQUE7QUFBQSxJQUduQixTQUFTO0FBQ1AsWUFBTSxJQUFJLE1BQU07QUFBQTtBQUFBLElBR2xCLFNBQVM7QUFDUCxZQUFNLElBQUksTUFBTTtBQUFBO0FBQUE7OztBQ1hwQixNQUFNLGVBQWU7QUFBQSxJQUNuQixPQUFPO0FBQUEsSUFDUCxNQUFNO0FBQUEsSUFDTixPQUFPO0FBQUE7QUFHVCxxQkFBYTtBQUFBLElBRVgsWUFBWSxhQUFhLElBQUksVUFBVSxJQUFJO0FBRXpDLFdBQUssYUFBYSxDQUFDLEdBQUc7QUFFdEIsV0FBSyxVQUFVLG1CQUNWO0FBR0wsV0FBSyxXQUFXO0FBRWhCLFdBQUssbUJBQW1CO0FBRXhCLFdBQUssaUJBQWlCO0FBRXRCLFdBQUssYUFBYTtBQUVsQixXQUFLLFFBQVEsVUFBVSxRQUFRO0FBQUE7QUFBQSxJQUdqQyxTQUFTO0FBQ1AsYUFBTztBQUFBO0FBQUEsSUFHVCxTQUFTO0FBQ1AsYUFBTztBQUFBO0FBQUEsSUFHVCxnQkFBZ0IsWUFBWTtBQUMxQixXQUFLLGFBQWEsQ0FBQyxHQUFHLEtBQUssWUFBWSxHQUFHO0FBQUE7QUFBQSxJQUc1QyxtQkFBbUIsWUFBWTtBQUM3QixXQUFLLGFBQWEsS0FBSyxXQUFXLE9BQU8sZUFBYSxDQUFDLFdBQVcsU0FBUztBQUFBO0FBQUEsSUFHN0UsUUFBUSxTQUFTLGFBQWE7QUFDNUIsWUFBTSxRQUFRLFNBQVMsWUFBWTtBQUNuQyxZQUFNLFNBQVM7QUFDZixZQUFNLFVBQVUsWUFBWSxNQUFNLE1BQU07QUFDeEMsY0FBUSxjQUFjO0FBQ3RCLFdBQUssWUFBWTtBQUNqQixhQUFPO0FBQUE7QUFBQTtBQUlYLHFCQUFtQixjQUFjO0FBQy9CLFVBQU0sUUFBUTtBQUNkLFFBQUksaUJBQWlCLFFBQVc7QUFDOUIsYUFBTyxtQkFDRjtBQUFBO0FBR1AsUUFBSSxPQUFPLGlCQUFpQixVQUFVO0FBQ3BDLGlCQUFXLE9BQU8sY0FBYztBQUM5QixZQUFJLE9BQU8sVUFBVSxlQUFlLEtBQUssY0FBYyxNQUFNO0FBQzNELGdCQUFNLE9BQU87QUFBQTtBQUFBO0FBR2pCLGFBQU87QUFBQTtBQUVULGVBQVcsT0FBTyxjQUFjO0FBQzlCLFVBQUksT0FBTyxVQUFVLGVBQWUsS0FBSyxjQUFjLE1BQU07QUFDM0QsWUFBSSxhQUFhLFNBQVMsUUFBVztBQUNuQyxnQkFBTSxPQUFPLGFBQWE7QUFBQSxlQUNyQjtBQUNMLGdCQUFNLE9BQU8sYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUloQyxXQUFPO0FBQUE7OztBQzdFVCxtQkFBaUIsTUFBTSxPQUFPO0FBQzVCLFFBQUksUUFBUSxNQUFNO0FBQ2hCLGFBQU87QUFBQTtBQUVULHlCQUFxQixhQUFhO0FBQ2hDLFVBQUksZUFBZSxRQUFRLFNBQVMsTUFBTTtBQUN4QyxlQUFPO0FBQUEsaUJBQ0UsV0FBVyxRQUFRO0FBQzVCLGVBQU8sUUFBUSxVQUFVLFFBQVEsS0FBSyxhQUFhO0FBQUEsaUJBQzFDLFdBQVcsUUFBUTtBQUM1QixlQUFPLENBQUMsR0FBRyxPQUFPLFNBQVM7QUFBQSxpQkFDbEIsVUFBVSxRQUFRO0FBQzNCLGVBQU8sVUFBVTtBQUFBLGlCQUNSLFdBQVcsUUFBUTtBQUM1QixlQUFPLE1BQU07QUFBQSxhQUNSO0FBQ0wsZUFBTztBQUFBO0FBQUE7QUFHWCxRQUFJLFVBQVU7QUFDZCxPQUFHO0FBQ0QsZ0JBQVUsUUFBUSwyQkFBMkIsUUFBUSx3QkFBd0I7QUFDN0UsVUFBSSxZQUFZLFVBQVU7QUFDeEIsZUFBTztBQUFBO0FBRVQsZ0JBQVUsb0NBQVMsZUFBYztBQUFBLGFBQzFCLFdBQVcsUUFBUSxZQUFZLFNBQVMsUUFBUSxZQUFZO0FBQ3JFLFdBQU87QUFBQTtBQUVULHNCQUFvQixPQUFPO0FBQ3pCLFdBQU8sUUFBUSxPQUFPLFVBQVU7QUFBQTtBQUVsQyxzQkFBb0IsT0FBTztBQUN6QixXQUFPLFFBQVEsaUJBQWlCLFlBQVksaUJBQWlCO0FBQUE7QUFFL0QscUJBQW1CLE9BQU87QUFDeEIsV0FBTyxRQUFRLGlCQUFpQjtBQUFBO0FBRWxDLHNCQUFvQixPQUFPO0FBQ3pCLFdBQU8sUUFBUSxPQUFPLFVBQVU7QUFBQTs7O0FDdkNsQyxvQkFBa0IsSUFBSSxJQUFJLElBQUksSUFBSTtBQUNoQyxXQUFPLEtBQUssS0FBTSxNQUFLLE9BQU8sSUFBSyxNQUFLLE9BQU87QUFBQTs7O0FDQ2pELGtDQUEwQixjQUFjO0FBQUEsUUFFbEMsZ0JBQWdCO0FBQ2xCLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQSxRQUdmLFVBQVU7QUFDWixhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixVQUFVO0FBQ1osYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBLFFBR2YsU0FBUztBQUNYLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQSxRQUdmLFlBQVk7QUFDZCxhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixpQkFBaUI7QUFDbkIsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBLFFBR2YsV0FBVztBQUNiLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUlyQiwyQ0FBbUMsWUFBWTtBQUFBO0FBRS9DLHVCQUFxQixPQUFPO0FBQzVCLDBDQUFrQyxZQUFZO0FBQUE7QUFFOUMsc0JBQW9CLE9BQU87QUFDM0IsMENBQWtDLFlBQVk7QUFBQTtBQUU5QyxzQkFBb0IsT0FBTztBQUMzQiw4Q0FBc0MsWUFBWTtBQUFBO0FBQ2xELDBCQUF3QixPQUFPOzs7QUN0Qy9CLE1BQU0sNkJBQTZCLE9BQU87QUFDMUMsTUFBTSxjQUFjLE9BQU87QUFDM0IsTUFBTSxjQUFjLE9BQU87QUFDM0IsTUFBTSxZQUFZLE9BQU87QUFDekIsTUFBTSxZQUFZLE9BQU87QUFDekIsTUFBTSxtQkFBbUIsT0FBTztBQUVoQyxrQ0FBMEIsT0FBTztBQUFBLElBRS9CLFlBQVksYUFBYSxJQUFJLFVBQVUsSUFBSTtBQUN6QyxZQUFNLFlBQVk7QUFFbEIsV0FBSyxtQkFBbUI7QUFFeEIsV0FBSyxRQUFRO0FBRWIsV0FBSyxRQUFRO0FBQ2IsV0FBSyw4QkFBOEIsS0FBSyw0QkFBNEIsS0FBSztBQUN6RSxXQUFLLGVBQWUsS0FBSyxhQUFhLEtBQUs7QUFDM0MsV0FBSyxlQUFlLEtBQUssYUFBYSxLQUFLO0FBQzNDLFdBQUssYUFBYSxLQUFLLFdBQVcsS0FBSztBQUN2QyxXQUFLLGFBQWEsS0FBSyxXQUFXLEtBQUs7QUFDdkMsV0FBSyxvQkFBb0IsS0FBSyxrQkFBa0IsS0FBSztBQUFBO0FBQUEsSUFHdkQsU0FBUztBQUNQLGVBQVMsaUJBQWlCLGFBQWEsS0FBSyxjQUFjO0FBQUE7QUFBQSxJQUc1RCxTQUFTO0FBQ1AsZUFBUyxvQkFBb0IsYUFBYSxLQUFLLGNBQWM7QUFBQTtBQUFBLEtBRzlELGFBQWEsT0FBTztBQUNuQixVQUFJLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxNQUFNLFNBQVM7QUFDeEQ7QUFBQTtBQUVGLFlBQU0sWUFBWSxRQUFRLE1BQU0sUUFBUSxLQUFLO0FBQzdDLFVBQUksQ0FBQyxXQUFXO0FBQ2Q7QUFBQTtBQUVGLFVBQUksS0FBSyxRQUFRLFVBQVUsTUFBTSxVQUFVLENBQUMsUUFBUSxNQUFNLFFBQVEsS0FBSyxRQUFRLFNBQVM7QUFDdEY7QUFBQTtBQUVGLFlBQU0saUJBQWlCLFFBQVEsTUFBTSxRQUFRLEtBQUssUUFBUTtBQUMxRCxVQUFJLENBQUMsZ0JBQWdCO0FBQ25CO0FBQUE7QUFFRixZQUFNO0FBQUEsUUFDSjtBQUFBLFVBQ0U7QUFDSixZQUFNO0FBQUEsUUFDSjtBQUFBLFFBQ0E7QUFBQSxVQUNFO0FBQ0osYUFBTyxPQUFPLE1BQU07QUFBQSxRQUNsQjtBQUFBLFFBQ0E7QUFBQTtBQUVGLFdBQUssZ0JBQWdCLEtBQUs7QUFDMUIsV0FBSyxhQUFhO0FBQ2xCLFdBQUssbUJBQW1CO0FBQ3hCLFdBQUssaUJBQWlCO0FBQ3RCLGVBQVMsaUJBQWlCLFdBQVcsS0FBSztBQUMxQyxlQUFTLGlCQUFpQixhQUFhO0FBQ3ZDLGVBQVMsaUJBQWlCLGFBQWEsS0FBSztBQUM1QyxXQUFLLG1CQUFtQixPQUFPLFdBQVcsTUFBTTtBQUM5QyxhQUFLLGtCQUFrQjtBQUFBLFVBQ3JCLE9BQU8sS0FBSztBQUFBLFVBQ1osT0FBTyxLQUFLO0FBQUE7QUFBQSxTQUViLE1BQU07QUFBQTtBQUFBLEtBR1YsYUFBYTtBQUNaLFlBQU0sYUFBYSxLQUFLO0FBQ3hCLFlBQU0sWUFBWSxLQUFLO0FBQ3ZCLFlBQU0saUJBQWlCLEtBQUs7QUFDNUIsWUFBTSxpQkFBaUIsSUFBSSxxQkFBcUI7QUFBQSxRQUM5QyxTQUFTLFdBQVc7QUFBQSxRQUNwQixTQUFTLFdBQVc7QUFBQSxRQUNwQixRQUFRLFdBQVc7QUFBQSxRQUNuQjtBQUFBLFFBQ0E7QUFBQSxRQUNBLGVBQWU7QUFBQTtBQUVqQixXQUFLLFFBQVEsS0FBSyxrQkFBa0I7QUFDcEMsV0FBSyxXQUFXLENBQUMsZUFBZTtBQUNoQyxVQUFJLEtBQUssVUFBVTtBQUNqQixpQkFBUyxpQkFBaUIsZUFBZSxLQUFLLDZCQUE2QjtBQUMzRSxpQkFBUyxpQkFBaUIsYUFBYSxLQUFLO0FBQUE7QUFBQTtBQUFBLEtBSS9DLGtCQUFrQixPQUFPO0FBQ3hCLFlBQU07QUFBQSxRQUNKO0FBQUEsUUFDQTtBQUFBLFVBQ0U7QUFDSixZQUFNO0FBQUEsUUFDSixVQUFVO0FBQUEsVUFDUixLQUFLO0FBQ1QsWUFBTTtBQUFBLFFBQ0o7QUFBQSxRQUNBO0FBQUEsVUFDRTtBQUNKLGFBQU8sT0FBTyxNQUFNO0FBQUEsUUFDbEI7QUFBQSxRQUNBO0FBQUE7QUFFRixVQUFJLENBQUMsS0FBSyxrQkFBa0I7QUFDMUI7QUFBQTtBQUVGLFlBQU0sY0FBYyxLQUFLLFFBQVEsS0FBSztBQUN0QyxZQUFNLG9CQUFvQixTQUFTLFdBQVcsT0FBTyxXQUFXLE9BQU8sT0FBTyxVQUFVO0FBQ3hGLG1CQUFhLEtBQUs7QUFDbEIsVUFBSSxjQUFjLE1BQU0sT0FBTztBQUU3QixpQkFBUyxvQkFBb0IsYUFBYSxLQUFLO0FBQUEsaUJBQ3RDLHFCQUFxQixZQUFZO0FBQzFDLGlCQUFTLG9CQUFvQixhQUFhLEtBQUs7QUFDL0MsYUFBSztBQUFBO0FBQUE7QUFBQSxLQUlSLGFBQWEsT0FBTztBQUNuQixVQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2xCO0FBQUE7QUFFRixZQUFNLFNBQVMsU0FBUyxpQkFBaUIsTUFBTSxTQUFTLE1BQU07QUFDOUQsWUFBTSxnQkFBZ0IsSUFBSSxvQkFBb0I7QUFBQSxRQUM1QyxTQUFTLE1BQU07QUFBQSxRQUNmLFNBQVMsTUFBTTtBQUFBLFFBQ2Y7QUFBQSxRQUNBLFdBQVcsS0FBSztBQUFBLFFBQ2hCLGVBQWU7QUFBQTtBQUVqQixXQUFLLFFBQVEsS0FBSyxrQkFBa0I7QUFBQTtBQUFBLEtBR3JDLFdBQVcsT0FBTztBQUNqQixtQkFBYSxLQUFLO0FBQ2xCLFVBQUksTUFBTSxXQUFXLEdBQUc7QUFDdEI7QUFBQTtBQUVGLGVBQVMsb0JBQW9CLFdBQVcsS0FBSztBQUM3QyxlQUFTLG9CQUFvQixhQUFhO0FBQzFDLGVBQVMsb0JBQW9CLGFBQWEsS0FBSztBQUMvQyxVQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2xCO0FBQUE7QUFFRixZQUFNLFNBQVMsU0FBUyxpQkFBaUIsTUFBTSxTQUFTLE1BQU07QUFDOUQsWUFBTSxnQkFBZ0IsSUFBSSxvQkFBb0I7QUFBQSxRQUM1QyxTQUFTLE1BQU07QUFBQSxRQUNmLFNBQVMsTUFBTTtBQUFBLFFBQ2Y7QUFBQSxRQUNBLFdBQVcsS0FBSztBQUFBLFFBQ2hCLGVBQWU7QUFBQTtBQUVqQixXQUFLLFFBQVEsS0FBSyxrQkFBa0I7QUFDcEMsZUFBUyxvQkFBb0IsZUFBZSxLQUFLLDZCQUE2QjtBQUM5RSxlQUFTLG9CQUFvQixhQUFhLEtBQUs7QUFDL0MsV0FBSyxtQkFBbUI7QUFDeEIsV0FBSyxXQUFXO0FBQ2hCLFdBQUssYUFBYTtBQUFBO0FBQUEsS0FHbkIsNEJBQTRCLE9BQU87QUFDbEMsWUFBTTtBQUFBO0FBQUE7QUFHVixrQ0FBZ0MsT0FBTztBQUNyQyxVQUFNO0FBQUE7OztBQ2pMUix1QkFBcUIsT0FBTztBQUMxQixVQUFNO0FBQUEsTUFDSjtBQUFBLE1BQ0E7QUFBQSxRQUNFO0FBQ0osV0FBTyxXQUFXLFFBQVEsTUFBTSxrQkFBa0IsZUFBZTtBQUFBOzs7QUNDbkUsTUFBTSxlQUFlLE9BQU87QUFDNUIsTUFBTSxhQUFhLE9BQU87QUFDMUIsTUFBTSxjQUFjLE9BQU87QUFDM0IsTUFBTSxhQUFZLE9BQU87QUFDekIsTUFBTSxvQkFBbUIsT0FBTztBQUVoQyxNQUFJLG1CQUFtQjtBQUV2QixTQUFPLGlCQUFpQixhQUFhLFdBQVM7QUFDNUMsUUFBSSxDQUFDLGtCQUFrQjtBQUNyQjtBQUFBO0FBR0YsVUFBTTtBQUFBLEtBQ0w7QUFBQSxJQUNELFNBQVM7QUFBQTtBQUdYLGtDQUEwQixPQUFPO0FBQUEsSUFFL0IsWUFBWSxhQUFhLElBQUksVUFBVSxJQUFJO0FBQ3pDLFlBQU0sWUFBWTtBQUVsQixXQUFLLDBCQUEwQjtBQUUvQixXQUFLLGFBQWE7QUFFbEIsV0FBSyxhQUFhO0FBRWxCLFdBQUssUUFBUTtBQUViLFdBQUssUUFBUTtBQUNiLFdBQUssZ0JBQWdCLEtBQUssY0FBYyxLQUFLO0FBQzdDLFdBQUssY0FBYyxLQUFLLFlBQVksS0FBSztBQUN6QyxXQUFLLGVBQWUsS0FBSyxhQUFhLEtBQUs7QUFDM0MsV0FBSyxjQUFhLEtBQUssWUFBVyxLQUFLO0FBQ3ZDLFdBQUsscUJBQW9CLEtBQUssbUJBQWtCLEtBQUs7QUFBQTtBQUFBLElBR3ZELFNBQVM7QUFDUCxlQUFTLGlCQUFpQixjQUFjLEtBQUs7QUFBQTtBQUFBLElBRy9DLFNBQVM7QUFDUCxlQUFTLG9CQUFvQixjQUFjLEtBQUs7QUFBQTtBQUFBLEtBR2pELGNBQWMsT0FBTztBQUNwQixZQUFNLFlBQVksUUFBUSxNQUFNLFFBQVEsS0FBSztBQUM3QyxVQUFJLENBQUMsV0FBVztBQUNkO0FBQUE7QUFFRixVQUFJLEtBQUssUUFBUSxVQUFVLE1BQU0sVUFBVSxDQUFDLFFBQVEsTUFBTSxRQUFRLEtBQUssUUFBUSxTQUFTO0FBQ3RGO0FBQUE7QUFFRixZQUFNLGlCQUFpQixRQUFRLE1BQU0sUUFBUSxLQUFLLFFBQVE7QUFDMUQsVUFBSSxDQUFDLGdCQUFnQjtBQUNuQjtBQUFBO0FBRUYsWUFBTTtBQUFBLFFBQ0osc0JBQVc7QUFBQSxVQUNULEtBQUs7QUFDVCxZQUFNO0FBQUEsUUFDSjtBQUFBLFVBQ0U7QUFDSixZQUFNO0FBQUEsUUFDSjtBQUFBLFFBQ0E7QUFBQSxVQUNFLFlBQVk7QUFDaEIsYUFBTyxPQUFPLE1BQU07QUFBQSxRQUNsQjtBQUFBLFFBQ0E7QUFBQTtBQUVGLFdBQUssaUJBQWlCLEtBQUs7QUFDM0IsV0FBSyxhQUFhO0FBQ2xCLFdBQUssbUJBQW1CO0FBQ3hCLFdBQUssaUJBQWlCO0FBQ3RCLGVBQVMsaUJBQWlCLFlBQVksS0FBSztBQUMzQyxlQUFTLGlCQUFpQixlQUFlLEtBQUs7QUFDOUMsZUFBUyxpQkFBaUIsYUFBYSxLQUFLO0FBQzVDLGdCQUFVLGlCQUFpQixlQUFlO0FBQzFDLFVBQUksV0FBVTtBQUNaLDJCQUFtQjtBQUFBO0FBRXJCLFdBQUssYUFBYSxPQUFPLFdBQVcsTUFBTTtBQUN4QyxhQUFLLG1CQUFrQjtBQUFBLFVBQ3JCLFNBQVMsQ0FBQztBQUFBLFlBQ1IsT0FBTyxLQUFLO0FBQUEsWUFDWixPQUFPLEtBQUs7QUFBQTtBQUFBO0FBQUEsU0FHZixNQUFNO0FBQUE7QUFBQSxLQUdWLGNBQWE7QUFDWixZQUFNLGFBQWEsS0FBSztBQUN4QixZQUFNLFlBQVksS0FBSztBQUN2QixZQUFNLFFBQVEsWUFBWTtBQUMxQixZQUFNLGlCQUFpQixLQUFLO0FBQzVCLFlBQU0saUJBQWlCLElBQUkscUJBQXFCO0FBQUEsUUFDOUMsU0FBUyxNQUFNO0FBQUEsUUFDZixTQUFTLE1BQU07QUFBQSxRQUNmLFFBQVEsV0FBVztBQUFBLFFBQ25CO0FBQUEsUUFDQTtBQUFBLFFBQ0EsZUFBZTtBQUFBO0FBRWpCLFdBQUssUUFBUSxLQUFLLGtCQUFrQjtBQUNwQyxXQUFLLFdBQVcsQ0FBQyxlQUFlO0FBQ2hDLFVBQUksS0FBSyxVQUFVO0FBQ2pCLGlCQUFTLGlCQUFpQixhQUFhLEtBQUs7QUFBQTtBQUU5Qyx5QkFBbUIsS0FBSztBQUFBO0FBQUEsS0FHekIsbUJBQWtCLE9BQU87QUFDeEIsWUFBTTtBQUFBLFFBQ0osVUFBVTtBQUFBLFVBQ1IsS0FBSztBQUNULFlBQU07QUFBQSxRQUNKO0FBQUEsUUFDQTtBQUFBLFVBQ0U7QUFDSixZQUFNLFFBQVEsWUFBWTtBQUMxQixZQUFNLFVBQVUsWUFBWTtBQUM1QixZQUFNLGNBQWMsS0FBSyxRQUFRLEtBQUs7QUFDdEMsWUFBTSxvQkFBb0IsU0FBUyxNQUFNLE9BQU8sTUFBTSxPQUFPLFFBQVEsT0FBTyxRQUFRO0FBQ3BGLGFBQU8sT0FBTyxNQUFNO0FBQ3BCLG1CQUFhLEtBQUs7QUFDbEIsVUFBSSxjQUFjLE1BQU0sT0FBTztBQUU3QixpQkFBUyxvQkFBb0IsYUFBYSxLQUFLO0FBQUEsaUJBQ3RDLHFCQUFxQixZQUFZO0FBQzFDLGlCQUFTLG9CQUFvQixhQUFhLEtBQUs7QUFDL0MsYUFBSztBQUFBO0FBQUE7QUFBQSxLQUlSLGFBQWEsT0FBTztBQUNuQixVQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2xCO0FBQUE7QUFFRixZQUFNO0FBQUEsUUFDSjtBQUFBLFFBQ0E7QUFBQSxVQUNFLFlBQVk7QUFDaEIsWUFBTSxTQUFTLFNBQVMsaUJBQWlCLFFBQVEsT0FBTyxTQUFTLFFBQVEsT0FBTztBQUNoRixZQUFNLGdCQUFnQixJQUFJLG9CQUFvQjtBQUFBLFFBQzVDLFNBQVM7QUFBQSxRQUNULFNBQVM7QUFBQSxRQUNUO0FBQUEsUUFDQSxXQUFXLEtBQUs7QUFBQSxRQUNoQixlQUFlO0FBQUE7QUFFakIsV0FBSyxRQUFRLEtBQUssa0JBQWtCO0FBQUE7QUFBQSxLQUdyQyxZQUFZLE9BQU87QUFDbEIsbUJBQWEsS0FBSztBQUNsQix5QkFBbUI7QUFDbkIsZUFBUyxvQkFBb0IsWUFBWSxLQUFLO0FBQzlDLGVBQVMsb0JBQW9CLGVBQWUsS0FBSztBQUNqRCxlQUFTLG9CQUFvQixhQUFhLEtBQUs7QUFDL0MsVUFBSSxLQUFLLGtCQUFrQjtBQUN6QixhQUFLLGlCQUFpQixvQkFBb0IsZUFBZTtBQUFBO0FBRTNELFVBQUksQ0FBQyxLQUFLLFVBQVU7QUFDbEI7QUFBQTtBQUVGLGVBQVMsb0JBQW9CLGFBQWEsS0FBSztBQUMvQyxZQUFNO0FBQUEsUUFDSjtBQUFBLFFBQ0E7QUFBQSxVQUNFLFlBQVk7QUFDaEIsWUFBTSxTQUFTLFNBQVMsaUJBQWlCLFFBQVEsT0FBTyxTQUFTLFFBQVEsT0FBTztBQUNoRixZQUFNO0FBQ04sWUFBTSxnQkFBZ0IsSUFBSSxvQkFBb0I7QUFBQSxRQUM1QyxTQUFTO0FBQUEsUUFDVCxTQUFTO0FBQUEsUUFDVDtBQUFBLFFBQ0EsV0FBVyxLQUFLO0FBQUEsUUFDaEIsZUFBZTtBQUFBO0FBRWpCLFdBQUssUUFBUSxLQUFLLGtCQUFrQjtBQUNwQyxXQUFLLG1CQUFtQjtBQUN4QixXQUFLLFdBQVc7QUFDaEIsV0FBSyxhQUFhO0FBQUE7QUFBQTtBQUd0Qix5QkFBdUIsT0FBTztBQUM1QixVQUFNO0FBQ04sVUFBTTtBQUFBOzs7QUNqTVIsTUFBTSxlQUFjLE9BQU87QUFDM0IsTUFBTSxhQUFZLE9BQU87QUFDekIsTUFBTSxjQUFjLE9BQU87QUFDM0IsTUFBTSxhQUFhLE9BQU87QUFDMUIsTUFBTSxZQUFZLE9BQU87QUFDekIsTUFBTSxTQUFTLE9BQU87QUFDdEIsTUFBTSxRQUFRLE9BQU87OztBQ05yQixNQUFNLHdCQUF3QixPQUFPO0FBQ3JDLE1BQU0sbUJBQW1CLE9BQU87QUFDaEMsTUFBTSxlQUFjLE9BQU87QUFDM0IsTUFBTSxxQkFBcUIsT0FBTztBQUNsQyxNQUFNLGVBQWMsT0FBTztBQUMzQixNQUFNLGFBQVksT0FBTztBQUN6QixNQUFNLDJCQUEyQixPQUFPOzs7QUNWeEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FDRUEsc0NBQThCLGNBQWM7QUFBQSxJQUUxQyxZQUFZLE1BQU07QUFDaEIsWUFBTTtBQUNOLFdBQUssT0FBTztBQUFBO0FBQUEsUUFHVixZQUFZO0FBQ2QsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3JCLGtCQUFnQixPQUFPO0FBRXZCLHdDQUFnQyxnQkFBZ0I7QUFBQSxRQUUxQyxtQkFBbUI7QUFDckIsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3JCLG9CQUFrQixPQUFPO0FBRXpCLHlDQUFpQyxnQkFBZ0I7QUFBQSxRQUUzQyxtQkFBbUI7QUFDckIsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3JCLHFCQUFtQixPQUFPOzs7QUN6QjFCLE1BQU0sYUFBYSxPQUFPO0FBQzFCLE1BQU0sYUFBYSxPQUFPO0FBQzFCLE1BQU0sMEJBQTBCLE9BQU87QUFFdkMsaUNBQXlCLGVBQWU7QUFBQSxJQUV0QyxZQUFZLFdBQVc7QUFDckIsWUFBTTtBQUVOLFdBQUssNEJBQTRCO0FBRWpDLFdBQUssdUJBQXVCO0FBRTVCLFdBQUssd0JBQXdCO0FBQzdCLFdBQUssY0FBYyxLQUFLLFlBQVksS0FBSztBQUN6QyxXQUFLLGNBQWMsS0FBSyxZQUFZLEtBQUs7QUFDekMsV0FBSywyQkFBMkIsS0FBSyx5QkFBeUIsS0FBSztBQUFBO0FBQUEsSUFHckUsU0FBUztBQUNQLFdBQUssVUFBVSxHQUFHLGFBQWEsS0FBSyxhQUFhLEdBQUcsYUFBYSxLQUFLO0FBQUE7QUFBQSxJQUd4RSxTQUFTO0FBQ1AsV0FBSyxVQUFVLElBQUksYUFBYSxLQUFLLGFBQWEsSUFBSSxhQUFhLEtBQUs7QUFBQTtBQUFBLElBRzFFLGlCQUFpQjtBQUNmLFlBQU0sY0FBYyxLQUFLLFVBQVUsUUFBUTtBQUMzQyxVQUFJLE9BQU8sZ0JBQWdCLFVBQVU7QUFDbkMsZUFBTyxNQUFNLFVBQVUsTUFBTSxLQUFLLFNBQVMsaUJBQWlCO0FBQUEsaUJBQ25ELHVCQUF1QixZQUFZLHVCQUF1QixPQUFPO0FBQzFFLGVBQU8sTUFBTSxVQUFVLE1BQU0sS0FBSztBQUFBLGlCQUN6Qix1QkFBdUIsYUFBYTtBQUM3QyxlQUFPLENBQUM7QUFBQSxpQkFDQyxPQUFPLGdCQUFnQixZQUFZO0FBQzVDLGVBQU87QUFBQSxhQUNGO0FBQ0wsZUFBTztBQUFBO0FBQUE7QUFBQSxLQUlWLFlBQVksT0FBTztBQUNsQixZQUFNLFNBQVMsTUFBTSxZQUFZO0FBQ2pDLFdBQUssd0JBQXdCLHNCQUFzQixLQUFLLHlCQUF5QjtBQUNqRixVQUFJLEtBQUssMkJBQTJCO0FBQ2xDLGNBQU07QUFBQTtBQUVSLFlBQU0sb0JBQW9CLElBQUksa0JBQWtCO0FBQUEsUUFDOUMsV0FBVztBQUFBLFFBQ1gsa0JBQWtCLEtBQUs7QUFBQTtBQUV6QixZQUFNLHFCQUFxQixJQUFJLG1CQUFtQjtBQUFBLFFBQ2hELFdBQVc7QUFBQSxRQUNYLGtCQUFrQixLQUFLO0FBQUE7QUFFekIsWUFBTSxxQkFBcUIsUUFBUSxLQUFLLDZCQUE2QixLQUFLLHlCQUF5QixLQUFLO0FBQ3hHLFlBQU0sb0JBQW9CLFFBQVEsQ0FBQyxLQUFLLDZCQUE2QixLQUFLO0FBQzFFLFVBQUksb0JBQW9CO0FBQ3RCLFlBQUksS0FBSyxzQkFBc0I7QUFDN0IsZUFBSyxVQUFVLFFBQVE7QUFBQTtBQUV6QixhQUFLLFVBQVUsUUFBUTtBQUFBLGlCQUNkLG1CQUFtQjtBQUM1QixhQUFLLFVBQVUsUUFBUTtBQUFBO0FBRXpCLFdBQUssdUJBQXVCLEtBQUs7QUFBQTtBQUFBLEtBR2xDLFlBQVksT0FBTztBQUNsQixZQUFNLHVCQUF1QixLQUFLLDZCQUE2QixLQUFLO0FBQ3BFLFlBQU0scUJBQXFCLElBQUksbUJBQW1CO0FBQUEsUUFDaEQsV0FBVztBQUFBLFFBQ1gsa0JBQWtCO0FBQUE7QUFFcEIsVUFBSSxzQkFBc0I7QUFDeEIsYUFBSyxVQUFVLFFBQVE7QUFBQTtBQUV6QixXQUFLLHVCQUF1QjtBQUM1QixXQUFLLDRCQUE0QjtBQUFBO0FBQUEsS0FHbEMseUJBQXlCLFFBQVE7QUFDaEMsYUFBTyxNQUFNO0FBQ1gsY0FBTSxjQUFjLEtBQUs7QUFDekIsYUFBSyw0QkFBNEIsUUFBUSxRQUFRLGFBQVcsWUFBWSxTQUFTO0FBQUE7QUFBQTtBQUFBOzs7QUN6RnZGLHNDQUFvQyxHQUFHLEdBQUc7QUFDeEMsV0FBTyxTQUFVLEdBQUc7QUFDbEIsd0JBQWtCLEdBQUcsbUJBQW1CLGVBQWUsR0FBRyxtQkFBbUIsRUFBRSxLQUFLO0FBQUE7QUFBQTtBQUd4RixtQ0FBaUMsR0FBRyxHQUFHO0FBQ3JDLFFBQUksQ0FBQyxFQUFFO0FBQUksWUFBTSxJQUFJLFVBQVU7QUFBQTtBQUVqQyxxQkFBbUIsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ2xELFFBQUk7QUFDSixZQUFRO0FBQUEsV0FDRDtBQUNILFlBQUk7QUFDSjtBQUFBLFdBQ0c7QUFDSCxZQUFJO0FBQ0o7QUFBQSxXQUNHO0FBQ0gsWUFBSTtBQUNKO0FBQUEsV0FDRztBQUNILFlBQUk7QUFDSjtBQUFBO0FBRUEsWUFBSTtBQUFBO0FBRVIsUUFBSSxHQUNGLEdBQ0EsSUFBSTtBQUFBLE1BQ0YsTUFBTTtBQUFBLE1BQ04sTUFBTSxJQUFJLE1BQU0sSUFBSTtBQUFBLE1BQ3BCLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxPQUVaLElBQUk7QUFBQSxNQUNGLEdBQUc7QUFBQTtBQUVQLFFBQUksQUFBTSxNQUFOLEtBQVksR0FBRSxpQkFBaUIsMkJBQTJCLEdBQUcsS0FBSyxLQUFLLEFBQU0sTUFBTixLQUFXLEFBQU0sTUFBTixHQUFTO0FBQzdGLFVBQUksQUFBTSxNQUFOO0FBQVMsWUFBSSxTQUFVLElBQUc7QUFDNUIsaUJBQU8sd0JBQXdCLEdBQUcsS0FBSSxFQUFFO0FBQUE7QUFBQSxXQUNuQztBQUNMLFlBQUksSUFBSSxBQUFNLE1BQU4sS0FBVyxBQUFNLE1BQU47QUFDbkIsUUFBQyxNQUFLLEFBQU0sTUFBTixNQUFhLEtBQUksSUFBSSxTQUFVLElBQUc7QUFDdEMsaUJBQU8sd0JBQXdCLEdBQUcsS0FBSSxFQUFFLElBQUksS0FBSztBQUFBLFlBQy9DLFNBQVUsSUFBRztBQUNmLGlCQUFPLEVBQUUsSUFBSSxLQUFLO0FBQUEsWUFDZixNQUFLLEFBQU0sTUFBTixNQUFhLEtBQUksSUFBSSxTQUFVLElBQUcsSUFBRztBQUM3QyxrQ0FBd0IsR0FBRyxLQUFJLEVBQUUsSUFBSSxLQUFLLElBQUc7QUFBQSxZQUMzQyxTQUFVLElBQUcsSUFBRztBQUNsQixZQUFFLElBQUksS0FBSyxJQUFHO0FBQUE7QUFBQTtBQUFBO0FBR2IsVUFBSSxTQUFVLElBQUc7QUFDdEIsZUFBTyxHQUFFO0FBQUEsU0FDUixBQUFNLE1BQU4sS0FBWSxLQUFJLFNBQVUsSUFBRyxJQUFHO0FBQ2pDLFdBQUUsS0FBSztBQUFBO0FBRVQsUUFBSSxJQUFJLElBQUksRUFBRSxTQUFTLFNBQVUsSUFBRztBQUNsQyxhQUFPLEtBQUs7QUFBQTtBQUVkLE1BQUUsU0FBUyxLQUFLLElBQUk7QUFBQSxNQUNsQixLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsUUFDSCxJQUFJO0FBQUEsTUFDTixLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsUUFDSDtBQUFBLE1BQ0YsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBO0FBRVAsUUFBSTtBQUNGLGFBQU8sRUFBRSxLQUFLLEdBQUcsR0FBRztBQUFBLGNBQ3BCO0FBQ0EsUUFBRSxJQUFJO0FBQUE7QUFBQTtBQUdWLDZCQUEyQixHQUFHLEdBQUc7QUFDL0IsUUFBSSxFQUFFO0FBQUcsWUFBTSxJQUFJLE1BQU0sdUJBQXVCLElBQUk7QUFBQTtBQUV0RCwwQkFBd0IsR0FBRyxHQUFHO0FBQzVCLFFBQUksQUFBYyxPQUFPLEtBQXJCO0FBQXdCLFlBQU0sSUFBSSxVQUFVLElBQUk7QUFBQTtBQUV0RCxrQ0FBZ0MsR0FBRyxHQUFHO0FBQ3BDLFFBQUksSUFBSSxPQUFPO0FBQ2YsUUFBSSxBQUFNLE1BQU4sR0FBUztBQUNYLFVBQUksQUFBYSxNQUFiLFlBQWtCLEFBQVMsTUFBVDtBQUFZLGNBQU0sSUFBSSxVQUFVO0FBQ3RELE1BQVcsRUFBRSxRQUFiLFVBQW9CLGVBQWUsRUFBRSxLQUFLLGlCQUFpQixBQUFXLEVBQUUsUUFBYixVQUFvQixlQUFlLEVBQUUsS0FBSyxpQkFBaUIsQUFBVyxFQUFFLFNBQWIsVUFBcUIsZUFBZSxFQUFFLE1BQU07QUFBQSxlQUN6SixBQUFlLE1BQWYsWUFBa0I7QUFDM0IsVUFBSTtBQUNKLFlBQU0sSUFBSSxBQUFNLE1BQU4sSUFBVSxVQUFVLEFBQU0sTUFBTixJQUFVLFVBQVUsVUFBVSxJQUFJLFVBQVUsSUFBSTtBQUFBO0FBQUE7QUFHbEYsc0JBQW9CLEdBQUc7QUFDckIsV0FBTyxXQUFZO0FBQ2pCLGFBQU8sRUFBRTtBQUFBO0FBQUE7QUFHYixzQkFBb0IsR0FBRztBQUNyQixXQUFPLFNBQVUsR0FBRztBQUNsQixRQUFFLE1BQU07QUFBQTtBQUFBO0FBR1osMEJBQXdCLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUN2RCxRQUFJLEdBQ0YsR0FDQSxHQUNBLEdBQ0EsR0FDQSxHQUNBLElBQUksRUFBRTtBQUNSLFNBQUssTUFBTSxRQUFRLE1BQU8sS0FBSSxDQUFDLEtBQUssSUFBSSxJQUFJLEFBQU0sTUFBTixLQUFXLEFBQU0sTUFBTixJQUFVO0FBQUEsTUFDL0QsS0FBSyxXQUFXLEVBQUU7QUFBQSxNQUNsQixLQUFLLFdBQVcsRUFBRTtBQUFBLFFBQ2hCLEFBQU0sTUFBTixJQUFVO0FBQUEsTUFDWixLQUFLLEVBQUU7QUFBQSxRQUNMLEFBQU0sTUFBTixJQUFVO0FBQUEsTUFDWixLQUFLLEVBQUU7QUFBQSxRQUNMO0FBQUEsTUFDRixPQUFPLEVBQUU7QUFBQSxRQUNQLEFBQU0sTUFBTixLQUFZLEtBQUksT0FBTyx5QkFBeUIsR0FBRyxLQUFLLEFBQU0sTUFBTixJQUFVLElBQUk7QUFBQSxNQUN4RSxLQUFLLEVBQUU7QUFBQSxNQUNQLEtBQUssRUFBRTtBQUFBLFFBQ0wsQUFBTSxNQUFOLElBQVUsSUFBSSxFQUFFLFFBQVEsQUFBTSxNQUFOLElBQVUsSUFBSSxFQUFFLE1BQU0sQUFBTSxNQUFOLEtBQVksS0FBSSxFQUFFO0FBQ3BFLGFBQVMsSUFBSSxJQUFJLElBQUksR0FBRyxJQUFJLEVBQUUsU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUc7QUFDeEQsVUFBSTtBQUNKLFVBQUksQUFBWSxLQUFJLFVBQVUsRUFBRSxJQUFJLElBQUksRUFBRSxJQUFJLEtBQUssUUFBUSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsUUFBL0U7QUFBb0YsK0JBQXVCLEdBQUcsSUFBSSxBQUFNLE1BQU4sSUFBVSxJQUFJLElBQUksQUFBTSxNQUFOLElBQVcsS0FBSSxFQUFFLE1BQU0sSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxJQUFJO0FBQUEsVUFDek0sS0FBSztBQUFBLFVBQ0wsS0FBSztBQUFBLGFBQ0YsSUFBSSxHQUFHLEFBQVcsTUFBWCxVQUFpQixDQUFXLE1BQVgsU0FBZSxJQUFJLElBQUksQUFBYyxPQUFPLEtBQXJCLGFBQXlCLElBQUksQ0FBQyxHQUFHLEtBQUssRUFBRSxLQUFLO0FBQUE7QUFFbkcsUUFBSSxBQUFNLE1BQU4sS0FBVyxBQUFNLE1BQU4sR0FBUztBQUN0QixVQUFJLEFBQVcsTUFBWDtBQUFjLFlBQUksU0FBVSxJQUFHLElBQUc7QUFDcEMsaUJBQU87QUFBQTtBQUFBLGVBQ0UsQUFBYyxPQUFPLEtBQXJCLFlBQXdCO0FBQ2pDLFlBQUksSUFBSTtBQUNSLFlBQUksU0FBVSxJQUFHLElBQUc7QUFDbEIsbUJBQVMsS0FBSSxJQUFHLEtBQUksRUFBRSxTQUFTLEdBQUcsTUFBSyxHQUFHO0FBQUssaUJBQUksRUFBRSxJQUFHLEtBQUssSUFBRztBQUNoRSxpQkFBTztBQUFBO0FBQUEsYUFFSjtBQUNMLFlBQUksSUFBSTtBQUNSLFlBQUksU0FBVSxJQUFHLElBQUc7QUFDbEIsaUJBQU8sRUFBRSxLQUFLLElBQUc7QUFBQTtBQUFBO0FBR3JCLFFBQUUsS0FBSztBQUFBO0FBRVQsSUFBTSxNQUFOLEtBQVksQ0FBTSxNQUFOLElBQVcsR0FBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxPQUFPLEFBQU0sTUFBTixJQUFVLEVBQUUsUUFBUSxJQUFJLEFBQU0sTUFBTixJQUFVLEVBQUUsTUFBTSxJQUFJLEFBQU0sTUFBTixLQUFZLEdBQUUsTUFBTSxJQUFJLElBQUksQUFBTSxNQUFOLElBQVcsR0FBRSxLQUFLLFNBQVUsSUFBRyxJQUFHO0FBQ2pLLGFBQU8sRUFBRSxJQUFJLEtBQUssSUFBRztBQUFBLFFBQ25CLEVBQUUsS0FBSyxTQUFVLElBQUcsSUFBRztBQUN6QixhQUFPLEVBQUUsSUFBSSxLQUFLLElBQUc7QUFBQSxVQUNqQixBQUFNLE1BQU4sSUFBVSxFQUFFLEtBQUssS0FBSyxFQUFFLEtBQUssU0FBVSxJQUFHLElBQUc7QUFDakQsYUFBTyxFQUFFLEtBQUssSUFBRztBQUFBLFNBQ2QsT0FBTyxlQUFlLEdBQUcsR0FBRztBQUFBO0FBRW5DLDJCQUF5QixHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ25DLGFBQVMsR0FBRyxHQUFHLEdBQUcsSUFBSSxJQUFJLElBQUksb0JBQUksT0FBTyxJQUFJLG9CQUFJLE9BQU8sSUFBSSxHQUFHLElBQUksRUFBRSxRQUFRLEtBQUs7QUFDaEYsVUFBSSxJQUFJLEVBQUU7QUFDVixVQUFJLE1BQU0sUUFBUSxJQUFJO0FBQ3BCLFlBQUksR0FDRixHQUNBLElBQUksRUFBRSxJQUNOLElBQUksRUFBRSxJQUNOLElBQUksRUFBRSxTQUFTLEdBQ2YsSUFBSSxLQUFLLEdBQ1QsSUFBSSxDQUFDLENBQUUsS0FBSSxJQUNYLElBQUk7QUFDTixZQUFJLEtBQUssR0FBRyxJQUFLLEtBQUksR0FBRyxBQUFNLE1BQU4sS0FBWSxLQUFJLElBQUksS0FBSyxLQUFLLEtBQUssQ0FBQyxLQUFNLEtBQUksU0FBVSxJQUFHO0FBQ2pGLGlCQUFPLFlBQVksUUFBTztBQUFBLFlBQ3hCLElBQUksS0FBTSxLQUFJLEVBQUUsV0FBVyxBQUFNLE1BQU4sS0FBWSxLQUFJLElBQUksS0FBSyxNQUFNLEFBQU0sTUFBTixLQUFXLENBQUMsR0FBRztBQUMzRSxjQUFJLElBQUksSUFBSSxJQUFJLEdBQ2QsSUFBSSxFQUFFLElBQUksTUFBTTtBQUNsQixjQUFJLEFBQU8sTUFBUCxRQUFZLEFBQU0sTUFBTixLQUFXLEFBQU0sTUFBTixLQUFXLEFBQU0sTUFBTixLQUFXLEFBQU0sTUFBTjtBQUFTLGtCQUFNLElBQUksTUFBTSwwTUFBME07QUFDcFIsWUFBRSxJQUFJLEdBQUcsQ0FBRSxFQUFDLEtBQUssSUFBSSxNQUFNO0FBQUE7QUFFN0IsdUJBQWUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUFBO0FBQUE7QUFHakQsV0FBTyxpQkFBaUIsR0FBRyxJQUFJLGlCQUFpQixHQUFHLElBQUk7QUFBQTtBQUV6RCw0QkFBMEIsR0FBRyxHQUFHO0FBQzlCLFNBQUssRUFBRSxLQUFLLFNBQVUsSUFBRztBQUN2QixlQUFTLElBQUksR0FBRyxJQUFJLEVBQUUsUUFBUTtBQUFLLFVBQUUsR0FBRyxLQUFLO0FBQzdDLGFBQU87QUFBQTtBQUFBO0FBR1gsMEJBQXdCLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDbEMsUUFBSSxFQUFFLFFBQVE7QUFDWixlQUFTLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxFQUFFLE1BQU0sSUFBSSxJQUFJLElBQUksR0FBRyxJQUFJLEVBQUUsU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUc7QUFDbkYsWUFBSSxJQUFJO0FBQUEsVUFDTixHQUFHO0FBQUE7QUFFTCxZQUFJO0FBQ0YsY0FBSSxJQUFJLEVBQUUsR0FBRyxLQUFLLElBQUksRUFBRSxJQUFJLEtBQUssUUFBUSxHQUFHO0FBQUEsWUFDMUMsTUFBTTtBQUFBLFlBQ04sTUFBTTtBQUFBLFlBQ04sZ0JBQWdCLDJCQUEyQixHQUFHO0FBQUEsWUFDOUMsVUFBVTtBQUFBO0FBQUEsa0JBRVo7QUFDQSxZQUFFLElBQUk7QUFBQTtBQUVSLFFBQVcsTUFBWCxVQUFpQix3QkFBdUIsR0FBRyxJQUFJLElBQUk7QUFBQTtBQUVyRCxhQUFPLENBQUMsZUFBZSxHQUFHLElBQUksV0FBWTtBQUN4QyxpQkFBUyxLQUFJLEdBQUcsS0FBSSxFQUFFLFFBQVE7QUFBSyxZQUFFLElBQUcsS0FBSztBQUFBO0FBQUE7QUFBQTtBQUluRCwwQkFBd0IsR0FBRyxHQUFHO0FBQzVCLFdBQU8sT0FBTyxlQUFlLEdBQUcsT0FBTyxZQUFZLE9BQU8sSUFBSSxvQkFBb0I7QUFBQSxNQUNoRixjQUFjO0FBQUEsTUFDZCxZQUFZO0FBQUEsTUFDWixPQUFPO0FBQUE7QUFBQTtBQUdYLDBCQUF3QixHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUN4QyxRQUFJLFVBQVUsVUFBVTtBQUFHLFVBQUksSUFBSSxFQUFFLE9BQU8sWUFBWSxPQUFPLElBQUk7QUFDbkUsUUFBSSxJQUFJLE9BQU8sT0FBTyxBQUFXLE1BQVgsU0FBZSxPQUFPLElBQzFDLElBQUksZ0JBQWdCLEdBQUcsR0FBRyxHQUFHO0FBQy9CLFdBQU8sRUFBRSxVQUFVLGVBQWUsR0FBRyxJQUFJO0FBQUEsTUFDdkMsR0FBRztBQUFBLFVBQ0MsSUFBSTtBQUNOLGVBQU8sZUFBZSxHQUFHLEdBQUcsR0FBRztBQUFBO0FBQUE7QUFBQTtBQUlyQyx1QkFBcUIsR0FBRztBQUN0QixRQUFJLE9BQU8sT0FBTztBQUFHLFlBQU0sVUFBVSxzREFBdUQsQ0FBUyxNQUFULE9BQWEsT0FBTyxJQUFJO0FBQ3BILFdBQU87QUFBQTs7O0FDdk9ULG9CQUFrQixnQkFBZ0I7QUFBQSxJQUNoQztBQUFBLElBQ0E7QUFBQSxLQUNDO0FBQ0QsbUJBQWUsV0FBWTtBQUV6QixXQUFLLFFBQVEsZUFBZSxLQUFLO0FBQUE7QUFBQTs7O0FDTnJDLHFDQUFtQyxVQUFVO0FBQzNDLFdBQU8sc0JBQXNCLE1BQU07QUFDakMsNEJBQXNCO0FBQUE7QUFBQTs7O0FDQTFCLGdDQUF3QixjQUFjO0FBQUEsSUFFcEMsWUFBWSxNQUFNO0FBQ2hCLFlBQU07QUFDTixXQUFLLE9BQU87QUFBQTtBQUFBLFFBR1YsU0FBUztBQUNYLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQSxRQUdmLGlCQUFpQjtBQUNuQixhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixTQUFTO0FBQ1gsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBLFFBR2Ysa0JBQWtCO0FBQ3BCLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQSxRQUdmLGNBQWM7QUFDaEIsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBLFFBR2YsZ0JBQWdCO0FBQ2xCLFVBQUksS0FBSyxhQUFhO0FBQ3BCLGVBQU8sS0FBSyxZQUFZO0FBQUE7QUFFMUIsYUFBTztBQUFBO0FBQUE7QUFJWCxZQUFVLE9BQU87QUFDakIscUNBQTZCLFVBQVU7QUFBQTtBQUV2QyxpQkFBZSxPQUFPO0FBQ3RCLGlCQUFlLGFBQWE7QUFDNUIsb0NBQTRCLFVBQVU7QUFBQTtBQUV0QyxnQkFBYyxPQUFPO0FBRXJCLG9DQUE0QixVQUFVO0FBQUEsUUFFaEMsZ0JBQWdCO0FBQ2xCLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQSxRQUdmLE9BQU87QUFDVCxhQUFPLEtBQUssS0FBSztBQUFBO0FBQUE7QUFHckIsZ0JBQWMsT0FBTztBQUNyQixnQkFBYyxhQUFhO0FBQzNCLDJCQUF5QixPQUFPO0FBQzlCLFdBQU8sTUFBTSxTQUFTLGNBQWM7QUFBQTtBQUd0QyxtQ0FBMkIsVUFBVTtBQUFBLFFBRS9CLGdCQUFnQjtBQUNsQixhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixPQUFPO0FBQ1QsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBSXJCLGVBQWEsT0FBTztBQUVwQiw2Q0FBcUMsVUFBVTtBQUFBLFFBRXpDLGdCQUFnQjtBQUNsQixhQUFPLEtBQUssS0FBSztBQUFBO0FBQUE7QUFJckIseUJBQXVCLE9BQU87QUFFOUIsNENBQW9DLFVBQVU7QUFBQSxRQUV4QyxnQkFBZ0I7QUFDbEIsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBSXJCLHdCQUFzQixPQUFPO0FBRTdCLHdDQUFnQyxVQUFVO0FBQUEsUUFFcEMsV0FBVztBQUNiLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUlyQixvQkFBa0IsT0FBTztBQUN6QixvQ0FBNEIsVUFBVTtBQUFBO0FBRXRDLGdCQUFjLE9BQU87QUFDckIsZ0JBQWMsYUFBYTtBQUMzQix1Q0FBK0IsVUFBVTtBQUFBO0FBQ3pDLG1CQUFpQixPQUFPOzs7QUNwR3hCLE1BQUk7QUFBSixNQUFnQjtBQUVoQixNQUFNLGlCQUFpQjtBQUV2QixtQ0FBMkIsZUFBZTtBQUFBLElBRXhDLFlBQVksV0FBVztBQUNyQixpQkFBVyxNQUFNO0FBRWpCLFdBQUssWUFBWTtBQUVqQixXQUFLLGFBQWE7QUFFbEIsV0FBSyxTQUFTO0FBQUE7QUFBQSxJQUdoQixTQUFTO0FBQ1AsV0FBSyxVQUFVLEdBQUcsa0JBQWtCLEtBQUssaUJBQWlCLEdBQUcsYUFBYSxLQUFLLFlBQVksR0FBRyx1QkFBdUIsS0FBSztBQUFBO0FBQUEsSUFHNUgsU0FBUztBQUNQLFdBQUssVUFBVSxJQUFJLGtCQUFrQixLQUFLLGlCQUFpQixJQUFJLGtCQUFrQixLQUFLLGlCQUFpQixJQUFJLGFBQWEsS0FBSyxZQUFZLElBQUksdUJBQXVCLEtBQUs7QUFBQTtBQUFBLElBRzNLLGFBQWE7QUFDWCxhQUFPLEtBQUssVUFBVSxRQUFRLGdCQUFnQjtBQUFBO0FBQUEsSUFHaEQsZ0JBQWdCO0FBQUEsTUFDZDtBQUFBLE9BQ0M7QUFDRCxXQUFLLFNBQVM7QUFBQTtBQUFBLElBR2hCLGtCQUFrQjtBQUNoQixXQUFLLFNBQVM7QUFBQTtBQUFBLElBR2hCLFdBQVcsV0FBVztBQUNwQixXQUFLLE9BQU87QUFBQTtBQUFBLElBR2QsT0FBTyxXQUFXO0FBQ2hCLDRCQUFzQixNQUFNO0FBQzFCLFlBQUksT0FBTztBQUNYLGNBQU07QUFBQSxVQUNKO0FBQUEsWUFDRTtBQUNKLFlBQUksS0FBSyxVQUFVLFFBQVEsS0FBSyxPQUFPLGNBQWMsTUFBTTtBQUN6RDtBQUFBO0FBRUYsWUFBSSxLQUFLLE9BQU8sZUFBZSxlQUFlO0FBQzVDLHdCQUFjLFlBQVksS0FBSztBQUFBO0FBRWpDLFlBQUksZ0JBQWdCLFlBQVk7QUFDOUIsaUJBQU8sVUFBVTtBQUFBO0FBRW5CLGNBQU0sY0FBYyxRQUFRLEtBQUssVUFBVSxpQ0FBaUMsZUFBZTtBQUMzRixZQUFJLENBQUMsYUFBYTtBQUNoQjtBQUFBO0FBRUYsa0NBQTBCLE1BQU07QUFDOUIsZ0JBQU0sV0FBVyxZQUFZO0FBQzdCLGNBQUksS0FBSyxVQUFVLFFBQVEsS0FBSyxlQUFlLFNBQVMsVUFBVSxLQUFLLGNBQWMsU0FBUyxPQUFPO0FBQ25HO0FBQUE7QUFFRixlQUFLLE9BQU8sTUFBTSxRQUFRLEdBQUcsU0FBUztBQUN0QyxlQUFLLE9BQU8sTUFBTSxTQUFTLEdBQUcsU0FBUztBQUN2QyxlQUFLLFlBQVksU0FBUztBQUMxQixlQUFLLGFBQWEsU0FBUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS25DLFdBQVM7QUFDVCxHQUFDLGNBQWMsZUFBZSxRQUFRLENBQUMsQ0FBQyxVQUFVLEdBQUcsb0JBQW9CLENBQUMsVUFBVSxHQUFHLG9CQUFvQixDQUFDLFVBQVUsR0FBRyxnQkFBZ0IsSUFBSSxHQUFHLFFBQVEsZ0JBQWdCOzs7QUMvRXhLLGdDQUF3QixjQUFjO0FBQUEsUUFFaEMsWUFBWTtBQUNkLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQSxRQUdmLFlBQVk7QUFDZCxhQUFPLEtBQUssS0FBSztBQUFBO0FBQUE7QUFJckIsWUFBVSxPQUFPO0FBQ2pCLGtDQUEwQixVQUFVO0FBQUE7QUFFcEMsY0FBWSxPQUFPO0FBQ25CLGNBQVksYUFBYTtBQUN6QixtQ0FBMkIsVUFBVTtBQUFBO0FBQ3JDLGVBQWEsT0FBTztBQUNwQixlQUFhLGFBQWE7OztBQ2pCMUIsTUFBTSxlQUFjLE9BQU87QUFDM0IsTUFBTSxjQUFhLE9BQU87QUFDMUIsTUFBTSxjQUFhLE9BQU87QUFDMUIsTUFBTSxZQUFZLE9BQU87QUFDekIsTUFBTSxrQkFBa0IsT0FBTztBQUMvQixNQUFNLGtCQUFrQixPQUFPO0FBRS9CLGdDQUF3QixlQUFlO0FBQUEsSUFFckMsWUFBWSxXQUFXO0FBQ3JCLFlBQU07QUFFTixXQUFLLGNBQWM7QUFFbkIsV0FBSyxTQUFTO0FBQ2QsV0FBSyxnQkFBZSxLQUFLLGNBQWEsS0FBSztBQUMzQyxXQUFLLGVBQWMsS0FBSyxhQUFZLEtBQUs7QUFDekMsV0FBSyxlQUFjLEtBQUssYUFBWSxLQUFLO0FBQ3pDLFdBQUssYUFBYSxLQUFLLFdBQVcsS0FBSztBQUN2QyxXQUFLLG1CQUFtQixLQUFLLGlCQUFpQixLQUFLO0FBQ25ELFdBQUssbUJBQW1CLEtBQUssaUJBQWlCLEtBQUs7QUFBQTtBQUFBLElBR3JELFNBQVM7QUFDUCxXQUFLLFVBQVUsR0FBRyxjQUFjLEtBQUssZUFBYyxHQUFHLGFBQWEsS0FBSyxjQUFhLEdBQUcsYUFBYSxLQUFLLGNBQWEsR0FBRyxZQUFZLEtBQUssWUFBWSxHQUFHLGtCQUFrQixLQUFLLGNBQWEsR0FBRyxpQkFBaUIsS0FBSyxZQUFZLEdBQUcsa0JBQWtCLEtBQUssa0JBQWtCLEdBQUcsa0JBQWtCLEtBQUs7QUFBQTtBQUFBLElBRzNTLFNBQVM7QUFDUCxXQUFLLFVBQVUsSUFBSSxjQUFjLEtBQUssZUFBYyxJQUFJLGFBQWEsS0FBSyxjQUFhLElBQUksYUFBYSxLQUFLLGNBQWEsSUFBSSxZQUFZLEtBQUssWUFBWSxJQUFJLGtCQUFrQixLQUFLLGNBQWEsSUFBSSxpQkFBaUIsS0FBSyxZQUFZLElBQUksa0JBQWtCLEtBQUssa0JBQWtCLElBQUksa0JBQWtCLEtBQUs7QUFBQTtBQUFBLEtBR2xULGNBQWEsT0FBTztBQUNuQixVQUFJLE1BQU0sWUFBWTtBQUNwQjtBQUFBO0FBRUYsV0FBSyxjQUFjLE1BQU07QUFBQTtBQUFBLEtBRzFCLGVBQWM7QUFDYixXQUFLLGNBQWM7QUFBQTtBQUFBLEtBR3BCLGFBQVksT0FBTztBQUNsQixVQUFJLE1BQU0sWUFBWTtBQUNwQjtBQUFBO0FBRUYsWUFBTSxTQUFTLE1BQU0sVUFBVSxNQUFNLFVBQVU7QUFDL0MsVUFBSSxXQUFXLEtBQUssYUFBYTtBQUMvQixhQUFLLGNBQWM7QUFDbkI7QUFBQTtBQUVGLFlBQU0sY0FBYyxJQUFJLFlBQVk7QUFBQSxRQUNsQyxXQUFXO0FBQUEsUUFDWCxXQUFXLE1BQU0sUUFBUSxNQUFNO0FBQUE7QUFFakMsV0FBSyxVQUFVLFFBQVE7QUFDdkIsVUFBSSxZQUFZLFlBQVk7QUFDMUI7QUFBQTtBQUVGLFVBQUksS0FBSyxRQUFRO0FBQ2YsYUFBSyxPQUFPLE1BQU0sVUFBVTtBQUFBO0FBRTlCLGFBQU8sVUFBVSxPQUFPLEdBQUcsS0FBSyxVQUFVLGlCQUFpQjtBQUMzRCxhQUFPLFVBQVUsSUFBSSxHQUFHLEtBQUssVUFBVSxpQkFBaUI7QUFFeEQsaUJBQVcsTUFBTTtBQUNmLGVBQU8sVUFBVSxPQUFPLEdBQUcsS0FBSyxVQUFVLGlCQUFpQjtBQUFBLFNBQzFELEtBQUssVUFBVSxRQUFRO0FBQUE7QUFBQSxLQUczQixXQUFXLE9BQU87QUFDakIsVUFBSSxNQUFNLFlBQVk7QUFDcEI7QUFBQTtBQUVGLFlBQU0sU0FBUyxNQUFNLFVBQVUsTUFBTSxVQUFVO0FBQy9DLFlBQU0sZUFBZSxJQUFJLGFBQWE7QUFBQSxRQUNwQyxXQUFXO0FBQUEsUUFDWCxXQUFXLE1BQU0sUUFBUSxNQUFNO0FBQUE7QUFFakMsV0FBSyxVQUFVLFFBQVE7QUFDdkIsVUFBSSxhQUFhLFlBQVk7QUFDM0I7QUFBQTtBQUVGLFVBQUksS0FBSyxRQUFRO0FBQ2YsYUFBSyxPQUFPLE1BQU0sVUFBVTtBQUFBO0FBRTlCLGFBQU8sVUFBVSxJQUFJLEdBQUcsS0FBSyxVQUFVLGlCQUFpQjtBQUFBO0FBQUEsS0FHekQsaUJBQWlCO0FBQUEsTUFDaEI7QUFBQSxPQUNDO0FBQ0QsV0FBSyxTQUFTO0FBQUE7QUFBQSxLQUdmLG1CQUFtQjtBQUNsQixXQUFLLFNBQVM7QUFBQTtBQUFBOzs7QUMvRmxCLE1BQUk7QUFBSixNQUFnQjtBQUVoQixNQUFNLGtCQUFpQjtBQUFBLElBQ3JCLFVBQVU7QUFBQSxJQUNWLGdCQUFnQjtBQUFBLElBQ2hCLFlBQVk7QUFBQTtBQUdkLG9DQUE0QixlQUFlO0FBQUEsSUFFekMsWUFBWSxXQUFXO0FBQ3JCLGtCQUFXLE1BQU07QUFFakIsV0FBSyxVQUFVLGtDQUNWLGtCQUNBLEtBQUs7QUFHVixXQUFLLHFCQUFxQjtBQUFBO0FBQUEsSUFHNUIsU0FBUztBQUNQLFdBQUssVUFBVSxHQUFHLG1CQUFtQixLQUFLO0FBQUE7QUFBQSxJQUc1QyxTQUFTO0FBQ1AsV0FBSyxVQUFVLElBQUksbUJBQW1CLEtBQUs7QUFBQTtBQUFBLElBRzdDLGFBQWE7QUFDWCxhQUFPLEtBQUssVUFBVSxRQUFRLGlCQUFpQjtBQUFBO0FBQUEsSUFHakQsaUJBQWlCO0FBQUEsTUFDZjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsT0FDQztBQUNELFlBQU07QUFBQSxRQUNKO0FBQUEsUUFDQTtBQUFBLFVBQ0U7QUFDSixVQUFJLEtBQUssb0JBQW9CO0FBQzNCLDZCQUFxQixLQUFLO0FBQUE7QUFHNUIsV0FBSyxxQkFBcUIsc0JBQXNCLE1BQU07QUFDcEQsWUFBSSxZQUFZLFVBQVU7QUFDeEIsa0JBQVEsUUFBUSxNQUFNLEtBQUs7QUFBQSxlQUN0QjtBQUNMLGtCQUFRLE1BQU0sUUFBUSxLQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNbkMsWUFBUztBQUNULEdBQUMsZUFBYyxlQUFlLFNBQVEsQ0FBQyxDQUFDLFVBQVUsR0FBRyxzQkFBc0IsSUFBSSxHQUFHLFFBQVEsZ0JBQWdCO0FBQzFHLG1CQUFpQixNQUFNLElBQUk7QUFBQSxJQUN6QjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsS0FDQztBQUNELGVBQVcsV0FBVyxDQUFDLE1BQU0sS0FBSztBQUNoQyxjQUFRLE1BQU0sZ0JBQWdCO0FBQUE7QUFFaEMsUUFBSSxZQUFZO0FBQ2QsWUFBTSxRQUFRLEtBQUs7QUFDbkIsV0FBSyxNQUFNLFlBQVksZUFBZTtBQUN0QyxTQUFHLE1BQU0sWUFBWSxnQkFBZ0I7QUFBQSxXQUNoQztBQUNMLFlBQU0sU0FBUyxLQUFLO0FBQ3BCLFdBQUssTUFBTSxZQUFZLGtCQUFrQjtBQUN6QyxTQUFHLE1BQU0sWUFBWSxtQkFBbUI7QUFBQTtBQUUxQywwQkFBc0IsTUFBTTtBQUMxQixpQkFBVyxXQUFXLENBQUMsTUFBTSxLQUFLO0FBQ2hDLGdCQUFRLGlCQUFpQixpQkFBaUI7QUFDMUMsZ0JBQVEsTUFBTSxhQUFhLGFBQWEsY0FBYztBQUN0RCxnQkFBUSxNQUFNLFlBQVk7QUFBQTtBQUFBO0FBQUE7QUFLaEMsdUNBQXFDLE9BQU87QUFDMUMsUUFBSSxNQUFNLFVBQVUsUUFBUSxDQUFDLGNBQWMsTUFBTSxTQUFTO0FBQ3hEO0FBQUE7QUFFRixVQUFNLE9BQU8sTUFBTSxhQUFhO0FBQ2hDLFVBQU0sT0FBTyxNQUFNLGdCQUFnQjtBQUNuQyxVQUFNLE9BQU8sb0JBQW9CLGlCQUFpQjtBQUFBO0FBRXBELHlCQUF1QixhQUFhO0FBQ2xDLFdBQU8sUUFBUSxXQUFXO0FBQUE7OztBQy9GNUIsTUFBTSxtQkFBbUIsT0FBTztBQUNoQyxNQUFNLGlCQUFpQixPQUFPO0FBRTlCLE1BQU0sa0JBQWlCO0FBQUEsSUFDckIsVUFBVTtBQUFBLElBQ1YsZ0JBQWdCO0FBQUE7QUFHbEIsb0NBQTRCLGVBQWU7QUFBQSxJQUV6QyxZQUFZLFdBQVc7QUFDckIsWUFBTTtBQUVOLFdBQUssVUFBVSxrQ0FDVixrQkFDQSxLQUFLO0FBR1YsV0FBSyxxQkFBcUI7QUFDMUIsV0FBSyxlQUFlO0FBQ3BCLFdBQUssb0JBQW9CLEtBQUssa0JBQWtCLEtBQUs7QUFDckQsV0FBSyxrQkFBa0IsS0FBSyxnQkFBZ0IsS0FBSztBQUFBO0FBQUEsSUFHbkQsU0FBUztBQUNQLFdBQUssVUFBVSxHQUFHLGlCQUFpQixLQUFLO0FBQ3hDLFdBQUssVUFBVSxHQUFHLG1CQUFtQixLQUFLO0FBQUE7QUFBQSxJQUc1QyxTQUFTO0FBQ1AsV0FBSyxVQUFVLElBQUksaUJBQWlCLEtBQUs7QUFDekMsV0FBSyxVQUFVLElBQUksbUJBQW1CLEtBQUs7QUFBQTtBQUFBLElBRzdDLGFBQWE7QUFDWCxhQUFPLEtBQUssVUFBVSxRQUFRLGlCQUFpQjtBQUFBO0FBQUEsS0FHaEQsZ0JBQWdCO0FBQUEsTUFDZjtBQUFBLE9BQ0M7QUFDRCxZQUFNO0FBQUEsUUFDSjtBQUFBLFVBQ0U7QUFDSixZQUFNLFdBQVcsS0FBSyxVQUFVLGlDQUFpQztBQUNqRSxXQUFLLGVBQWUsTUFBTSxLQUFLLFVBQVUsSUFBSSxRQUFNO0FBQ2pELGVBQU87QUFBQSxVQUNMLE9BQU87QUFBQSxVQUNQLFdBQVcsR0FBRztBQUFBLFVBQ2QsWUFBWSxHQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FLcEIsa0JBQWtCO0FBQUEsTUFDakI7QUFBQSxNQUNBO0FBQUEsT0FDQztBQUNELFVBQUksYUFBYSxVQUFVO0FBQ3pCO0FBQUE7QUFFRixZQUFNLG1CQUFtQjtBQUN6QixVQUFJO0FBQ0osVUFBSTtBQUNKLFVBQUk7QUFDSixVQUFJLFdBQVcsVUFBVTtBQUN2QixnQkFBUTtBQUNSLGNBQU0sV0FBVztBQUNqQixjQUFNO0FBQUEsYUFDRDtBQUNMLGdCQUFRLFdBQVc7QUFDbkIsY0FBTTtBQUNOLGNBQU07QUFBQTtBQUVSLGVBQVMsSUFBSSxPQUFPLEtBQUssS0FBSyxLQUFLO0FBQ2pDLGNBQU0sT0FBTyxLQUFLLGFBQWE7QUFDL0IsY0FBTSxLQUFLLEtBQUssYUFBYSxJQUFJO0FBQ2pDLHlCQUFpQixLQUFLO0FBQUEsVUFDcEI7QUFBQSxVQUNBO0FBQUE7QUFBQTtBQUdKLDJCQUFxQixLQUFLO0FBRTFCLFdBQUsscUJBQXFCLHNCQUFzQixNQUFNO0FBQ3BELHlCQUFpQixRQUFRLGFBQVcsU0FBUSxTQUFTLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFLaEUsb0JBQWlCO0FBQUEsSUFDZjtBQUFBLElBQ0E7QUFBQSxLQUNDO0FBQUEsSUFDRDtBQUFBLElBQ0E7QUFBQSxLQUNDO0FBQ0QsVUFBTSxRQUFRLEtBQUs7QUFDbkIsVUFBTSxJQUFJLEtBQUssYUFBYSxHQUFHO0FBQy9CLFVBQU0sSUFBSSxLQUFLLFlBQVksR0FBRztBQUM5QixVQUFNLE1BQU0sZ0JBQWdCO0FBQzVCLFVBQU0sTUFBTSxZQUFZLGVBQWUsUUFBUTtBQUMvQywwQkFBc0IsTUFBTTtBQUMxQixZQUFNLGlCQUFpQixpQkFBaUI7QUFDeEMsWUFBTSxNQUFNLGFBQWEsYUFBYSxjQUFjO0FBQ3BELFlBQU0sTUFBTSxZQUFZO0FBQUE7QUFBQTtBQUk1Qix3Q0FBcUMsT0FBTztBQUMxQyxVQUFNLE9BQU8sTUFBTSxhQUFhO0FBQ2hDLFVBQU0sT0FBTyxNQUFNLGdCQUFnQjtBQUNuQyxVQUFNLE9BQU8sb0JBQW9CLGlCQUFpQjtBQUFBOzs7QUNoSHBELE1BQU0sZUFBZSxPQUFPO0FBQzVCLE1BQU0sWUFBWSxPQUFPO0FBQ3pCLE1BQU0sZ0JBQWdCLE9BQU87QUFDN0IsTUFBTSxrQkFBa0IsT0FBTztBQUMvQixNQUFNLGdCQUFnQjtBQUN0QixNQUFNLGNBQWM7QUFDcEIsTUFBTSxZQUFZO0FBQ2xCLE1BQU0sT0FBTztBQUViLE1BQU0sa0JBQWlCO0FBQUEsSUFDckIsUUFBUTtBQUFBO0FBR1YsbUNBQTJCLGVBQWU7QUFBQSxJQUV4QyxZQUFZLFdBQVc7QUFDckIsWUFBTTtBQUVOLFdBQUssVUFBVSxrQ0FDVixrQkFDQSxLQUFLO0FBR1YsV0FBSyx3QkFBd0IsS0FBSyxVQUFVO0FBQzVDLFdBQUssZ0JBQWdCLEtBQUssY0FBYyxLQUFLO0FBQzdDLFdBQUssYUFBYSxLQUFLLFdBQVcsS0FBSztBQUFBO0FBQUEsSUFHekMsU0FBUztBQUNQLFdBQUssVUFBVSxHQUFHLHdCQUF3QixLQUFLO0FBQUE7QUFBQSxJQUdqRCxTQUFTO0FBQ1AsV0FBSyxVQUFVLElBQUkscUJBQXFCLEtBQUs7QUFBQTtBQUFBLElBRy9DLGFBQWE7QUFDWCxhQUFPLEtBQUssVUFBVSxRQUFRLGlCQUFpQjtBQUFBO0FBQUEsS0FHaEQsZUFBZSxPQUFPO0FBQ3JCLFlBQU0sVUFBVSxLQUFLLFFBQVEsTUFBTTtBQUNuQyxVQUFJLFdBQVcsT0FBTyxZQUFZLFVBQVU7QUFDMUMsYUFBSyxpQkFBaUI7QUFBQTtBQUV4QixVQUFJLFdBQVcsT0FBTyxZQUFZLFlBQVk7QUFDNUMsYUFBSyxpQkFBaUIsUUFBUTtBQUFBO0FBQUE7QUFBQSxLQUlqQyxpQkFBaUIsU0FBUztBQUN6QixlQUFTLFNBQVM7QUFBQSxRQUNoQixRQUFRLEtBQUssUUFBUTtBQUFBO0FBQUE7QUFBQSxLQUl4QixnQkFBZ0I7QUFFZixXQUFLLFVBQVUsVUFBVSxXQUFTO0FBQ2hDLFlBQUk7QUFDRixlQUFLLGVBQWU7QUFBQSxrQkFDcEI7QUFFQSxlQUFLLHNCQUFzQixLQUFLLEtBQUssV0FBVztBQUFBO0FBQUE7QUFBQTtBQUFBLEtBS3JELGFBQWE7QUFDWixXQUFLLFVBQVUsVUFBVSxLQUFLO0FBQUE7QUFBQTtBQUlsQyxNQUFNLGFBQWE7QUFFbkIsb0JBQWtCLFNBQVM7QUFBQSxJQUN6QjtBQUFBLEtBQ0M7QUFDRCxVQUFNLFVBQVUsU0FBUyxjQUFjO0FBQ3ZDLFlBQVEsY0FBYztBQUN0QixlQUFXLFlBQVk7QUFDdkIsV0FBTyxXQUFXLE1BQU07QUFDdEIsaUJBQVcsWUFBWTtBQUFBLE9BQ3RCO0FBQUE7QUFHTCwwQkFBd0I7QUFDdEIsVUFBTSxVQUFVLFNBQVMsY0FBYztBQUN2QyxZQUFRLGFBQWEsTUFBTTtBQUMzQixZQUFRLGFBQWEsZUFBZTtBQUNwQyxZQUFRLGFBQWEsYUFBYTtBQUNsQyxZQUFRLGFBQWEsV0FBVztBQUNoQyxZQUFRLGFBQWEsTUFBTTtBQUMzQixZQUFRLE1BQU0sV0FBVztBQUN6QixZQUFRLE1BQU0sUUFBUTtBQUN0QixZQUFRLE1BQU0sU0FBUztBQUN2QixZQUFRLE1BQU0sTUFBTTtBQUNwQixZQUFRLE1BQU0sV0FBVztBQUN6QixXQUFPO0FBQUE7QUFHVCxXQUFTLGlCQUFpQixvQkFBb0IsTUFBTTtBQUNsRCxhQUFTLEtBQUssWUFBWTtBQUFBOzs7QUN0RzVCLE1BQU0sZ0JBQWUsT0FBTztBQUM1QixNQUFNLGFBQVksT0FBTztBQUV6QixNQUFNLGtCQUFpQjtBQUV2QixnQ0FBd0IsZUFBZTtBQUFBLElBRXJDLFlBQVksV0FBVztBQUNyQixZQUFNO0FBRU4sV0FBSyxVQUFVLGtDQUNWLGtCQUNBLEtBQUs7QUFFVixXQUFLLGlCQUFnQixLQUFLLGVBQWMsS0FBSztBQUM3QyxXQUFLLGNBQWEsS0FBSyxZQUFXLEtBQUs7QUFBQTtBQUFBLElBR3pDLFNBQVM7QUFDUCxXQUFLLFVBQVUsR0FBRyx3QkFBd0IsS0FBSyxnQkFBZSxHQUFHLHFCQUFxQixLQUFLO0FBQUE7QUFBQSxJQUc3RixTQUFTO0FBQ1AsV0FBSyxVQUFVLElBQUksd0JBQXdCLEtBQUssZ0JBQWUsSUFBSSxxQkFBcUIsS0FBSztBQUU3RixXQUFLO0FBQUE7QUFBQSxJQUdQLGFBQWE7QUFDWCxhQUFPLEtBQUssVUFBVSxRQUFRLGFBQWE7QUFBQTtBQUFBLElBRzdDLGNBQWM7QUFDWixhQUFPLENBQUMsR0FBRyxLQUFLLFVBQVUsWUFBWSxHQUFHLEtBQUssVUFBVTtBQUFBO0FBQUEsS0FHekQsaUJBQWdCO0FBRWYsNEJBQXNCLE1BQU07QUFDMUIsYUFBSyxjQUFjLFFBQVEsYUFBVyxnQkFBZ0I7QUFBQTtBQUFBO0FBQUEsS0FJekQsY0FBYTtBQUVaLDRCQUFzQixNQUFNO0FBQzFCLGFBQUssY0FBYyxRQUFRLGFBQVcsYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUt6RCxNQUFNLDhCQUE4QjtBQUVwQywyQkFBeUIsU0FBUztBQUNoQyxVQUFNLHFCQUFxQixRQUFRLENBQUMsUUFBUSxhQUFhLGVBQWUsUUFBUSxhQUFhO0FBQzdGLFFBQUksb0JBQW9CO0FBQ3RCLGtDQUE0QixLQUFLO0FBQ2pDLGNBQVEsV0FBVztBQUFBO0FBQUE7QUFJdkIsd0JBQXNCLFNBQVM7QUFDN0IsVUFBTSwwQkFBMEIsNEJBQTRCLFFBQVE7QUFDcEUsUUFBSSw0QkFBNEIsSUFBSTtBQUNsQyxjQUFRLFdBQVc7QUFDbkIsa0NBQTRCLE9BQU8seUJBQXlCO0FBQUE7QUFBQTs7O0FDakVoRSxrQ0FBMEIsY0FBYztBQUFBLElBRXRDLFlBQVksTUFBTTtBQUNoQixZQUFNO0FBQ04sV0FBSyxPQUFPO0FBQUE7QUFBQSxRQUdWLFNBQVM7QUFDWCxhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixpQkFBaUI7QUFDbkIsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBLFFBR2Ysa0JBQWtCO0FBQ3BCLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQSxRQUdmLGNBQWM7QUFDaEIsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBLFFBR2YsWUFBWTtBQUNkLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQSxRQUdmLGdCQUFnQjtBQUNsQixVQUFJLEtBQUssYUFBYTtBQUNwQixlQUFPLEtBQUssWUFBWTtBQUFBO0FBRTFCLGFBQU87QUFBQTtBQUFBO0FBSVgsd0NBQWdDLFlBQVk7QUFBQTtBQUM1QyxvQkFBa0IsT0FBTztBQUV6Qix5Q0FBaUMsWUFBWTtBQUFBLFFBRXZDLFNBQVM7QUFDWCxhQUFPLEtBQUssS0FBSztBQUFBO0FBQUE7QUFHckIscUJBQW1CLE9BQU87QUFFMUIsMENBQWtDLFlBQVk7QUFBQSxRQUV4QyxTQUFTO0FBQ1gsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3JCLHNCQUFvQixPQUFPO0FBRTNCLHNDQUE4QixZQUFZO0FBQUEsUUFFcEMsU0FBUztBQUNYLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQSxRQUdmLGdCQUFnQjtBQUNsQixhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixnQkFBZ0I7QUFDbEIsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3JCLGtCQUFnQixPQUFPO0FBQ3ZCLGtCQUFnQixhQUFhO0FBRTdCLHVDQUErQixZQUFZO0FBQUEsUUFFckMsU0FBUztBQUNYLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQSxRQUdmLGdCQUFnQjtBQUNsQixhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixnQkFBZ0I7QUFDbEIsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3JCLG1CQUFpQixPQUFPO0FBRXhCLHlDQUFpQyxZQUFZO0FBQUEsUUFFdkMsU0FBUztBQUNYLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUdyQixxQkFBbUIsT0FBTztBQUMxQixxQkFBbUIsYUFBYTs7O0FDN0ZoQyxNQUFNLGVBQWMsT0FBTztBQUMzQixNQUFNLGNBQWEsT0FBTztBQUMxQixNQUFNLGNBQWEsT0FBTztBQUMxQixNQUFNLG1CQUFrQixPQUFPO0FBQy9CLE1BQU0sZUFBZSxPQUFPO0FBQzVCLE1BQU0sV0FBVyxPQUFPO0FBQ3hCLE1BQU0seUJBQXlCLE9BQU87QUFFdEMsTUFBTSxrQkFBaUI7QUFBQSxJQUNyQixxQkFBcUI7QUFBQSxJQUNyQixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxlQUFlO0FBQUEsSUFDZixlQUFlO0FBQUEsSUFDZixZQUFZO0FBQUEsSUFDWixZQUFZO0FBQUE7QUFHZCw2QkFBcUIsZUFBZTtBQUFBLElBRWxDLFlBQVksV0FBVztBQUNyQixZQUFNO0FBRU4sV0FBSyxVQUFVLGtDQUNWLGtCQUNBLEtBQUs7QUFHVixXQUFLLGVBQWU7QUFBQSxRQUNsQixHQUFHO0FBQUEsUUFDSCxHQUFHO0FBQUE7QUFHTCxXQUFLLHNCQUFzQjtBQUFBLFFBQ3pCLEdBQUcsT0FBTztBQUFBLFFBQ1YsR0FBRyxPQUFPO0FBQUE7QUFFWixXQUFLLGdCQUFlLEtBQUssY0FBYSxLQUFLO0FBQzNDLFdBQUssZUFBYyxLQUFLLGFBQVksS0FBSztBQUN6QyxXQUFLLGVBQWMsS0FBSyxhQUFZLEtBQUs7QUFDekMsV0FBSyxvQkFBbUIsS0FBSyxrQkFBaUIsS0FBSztBQUNuRCxXQUFLLGdCQUFnQixLQUFLLGNBQWMsS0FBSztBQUM3QyxXQUFLLFlBQVksS0FBSyxVQUFVLEtBQUs7QUFBQTtBQUFBLElBR3ZDLFNBQVM7QUFDUCxXQUFLLFVBQVUsR0FBRyxjQUFjLEtBQUssZUFBYyxHQUFHLGFBQWEsS0FBSyxjQUFhLEdBQUcsYUFBYSxLQUFLLGNBQWEsR0FBRyxrQkFBa0IsS0FBSyxtQkFBa0IsR0FBRyxlQUFlLEtBQUs7QUFBQTtBQUFBLElBRzVMLFNBQVM7QUFDUCxXQUFLLFVBQVUsSUFBSSxjQUFjLEtBQUssZUFBYyxJQUFJLGFBQWEsS0FBSyxjQUFhLElBQUksYUFBYSxLQUFLLGNBQWEsSUFBSSxrQkFBa0IsS0FBSyxtQkFBa0IsSUFBSSxlQUFlLEtBQUs7QUFBQTtBQUFBLElBR2pNLGFBQWE7QUFDWCxhQUFPLEtBQUssVUFBVSxRQUFRLFVBQVU7QUFBQTtBQUFBLEtBRXpDLGNBQWEsV0FBVztBQUN2QixVQUFJLFVBQVUsWUFBWTtBQUN4QjtBQUFBO0FBRUYsVUFBSSxrQkFBa0IsUUFBUTtBQUM1QixpQkFBUyxpQkFBaUIsVUFBVSxLQUFLLFdBQVc7QUFBQTtBQUV0RCxXQUFLLHNCQUFzQjtBQUFBLFFBQ3pCLEdBQUcsT0FBTztBQUFBLFFBQ1YsR0FBRyxPQUFPO0FBQUE7QUFFWixZQUFNO0FBQUEsUUFDSjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFVBQ0U7QUFFSixXQUFLLHdCQUF3QjtBQUFBLFFBQzNCLEdBQUcsWUFBWTtBQUFBLFFBQ2YsR0FBRyxZQUFZO0FBQUE7QUFFakIsWUFBTSxvQkFBb0IsSUFBSSxrQkFBa0I7QUFBQSxRQUM5QztBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQTtBQUVGLFdBQUssVUFBVSxRQUFRO0FBQ3ZCLFVBQUksa0JBQWtCLGdCQUFnQixrQkFBa0IsWUFBWTtBQUNsRTtBQUFBO0FBRUYsWUFBTSxzQkFBc0IsS0FBSyx3QkFBd0IsV0FBVztBQUNwRSxXQUFLLFNBQVMsT0FBTyxVQUFVO0FBQy9CLFlBQU0scUJBQXFCLElBQUksbUJBQW1CO0FBQUEsUUFDaEQ7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQSxRQUFRLEtBQUs7QUFBQTtBQUVmLFlBQU0sc0JBQXNCLElBQUksb0JBQW9CO0FBQUEsUUFDbEQ7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQSxRQUFRLEtBQUs7QUFBQTtBQUVmLFdBQUssVUFBVSxRQUFRO0FBQ3ZCLDBCQUFvQixZQUFZLEtBQUs7QUFDckMsV0FBSyxVQUFVLFFBQVE7QUFBQTtBQUFBLEtBRXhCLGFBQVksV0FBVztBQUN0QixVQUFJLENBQUMsS0FBSyxVQUFVLFVBQVUsWUFBWTtBQUN4QztBQUFBO0FBRUYsWUFBTTtBQUFBLFFBQ0o7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxVQUNFO0FBQ0osVUFBSSxnQkFBZ0I7QUFDcEIsVUFBSSxnQkFBZ0I7QUFDcEIsVUFBSSxLQUFLLFFBQVEsY0FBYyxLQUFLLFFBQVEsWUFBWTtBQUN0RCxjQUFNO0FBQUEsVUFDSixHQUFHO0FBQUEsVUFDSCxHQUFHO0FBQUEsWUFDRCxLQUFLO0FBQ1QsWUFBSSxLQUFLLElBQUksUUFBUSxZQUFZLFdBQVcsS0FBSyxRQUFRLFlBQVk7QUFDbkUsMEJBQWdCO0FBQUEsZUFDWDtBQUNMLGVBQUssc0JBQXNCLElBQUksWUFBWTtBQUFBO0FBRTdDLFlBQUksS0FBSyxJQUFJLFFBQVEsWUFBWSxXQUFXLEtBQUssUUFBUSxZQUFZO0FBQ25FLDBCQUFnQjtBQUFBLGVBQ1g7QUFDTCxlQUFLLHNCQUFzQixJQUFJLFlBQVk7QUFBQTtBQUU3QyxZQUFJLENBQUMsaUJBQWlCLENBQUMsZUFBZTtBQUNwQztBQUFBO0FBQUE7QUFHSixZQUFNLGtCQUFrQixJQUFJLGdCQUFnQjtBQUFBLFFBQzFDO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0EsUUFBUSxLQUFLO0FBQUEsUUFDYjtBQUFBLFFBQ0E7QUFBQTtBQUVGLFdBQUssVUFBVSxRQUFRO0FBQUE7QUFBQSxLQUV4QixhQUFZLFdBQVc7QUFDdEIsVUFBSSxrQkFBa0IsUUFBUTtBQUM1QixpQkFBUyxvQkFBb0IsVUFBVSxLQUFLLFdBQVc7QUFBQTtBQUV6RCxXQUFLLHNCQUFzQjtBQUFBLFFBQ3pCLEdBQUc7QUFBQSxRQUNILEdBQUc7QUFBQTtBQUVMLFdBQUssZUFBZTtBQUFBLFFBQ2xCLEdBQUc7QUFBQSxRQUNILEdBQUc7QUFBQTtBQUVMLFVBQUksQ0FBQyxLQUFLLFFBQVE7QUFDaEI7QUFBQTtBQUVGLFlBQU07QUFBQSxRQUNKO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxVQUNFO0FBQ0osWUFBTSxxQkFBcUIsSUFBSSxtQkFBbUI7QUFBQSxRQUNoRDtBQUFBLFFBQ0EsUUFBUSxLQUFLO0FBQUEsUUFDYjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUE7QUFFRixXQUFLLFVBQVUsUUFBUTtBQUN2QixVQUFJLENBQUMsbUJBQW1CLFlBQVk7QUFDbEMsYUFBSyxPQUFPO0FBQUE7QUFBQTtBQUFBLEtBR2YsWUFBWTtBQUNYLFdBQUssZUFBZTtBQUFBLFFBQ2xCLEdBQUcsT0FBTyxVQUFVLEtBQUssb0JBQW9CO0FBQUEsUUFDN0MsR0FBRyxPQUFPLFVBQVUsS0FBSyxvQkFBb0I7QUFBQTtBQUFBO0FBQUEsS0FJaEQsa0JBQWlCO0FBQUEsTUFDaEI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE9BQ0M7QUFDRCxZQUFNLGdCQUFnQixLQUFLLFVBQVUsaUJBQWlCO0FBQ3RELFlBQU0sV0FBVyxDQUFDLE9BS1o7QUFMWSxxQkFDaEI7QUFBQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsWUFIZ0IsSUFJYixpQkFKYSxJQUliO0FBQUEsVUFISDtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUE7QUFHQSxhQUFLLGVBQWU7QUFDcEIsYUFBSyxXQUFXO0FBQ2hCLGFBQUssV0FBVztBQUNoQixhQUFLLGFBQWE7QUFDbEIsYUFBSyxhQUFhO0FBQ2xCLGVBQU87QUFBQSxVQUNMO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxXQUNHO0FBQUE7QUFHUCxhQUFPLE1BQU0sVUFBVTtBQUN2QixZQUFNLGVBQWU7QUFBQSxRQUNuQjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0EsY0FBYyxLQUFLO0FBQUEsUUFDbkIsU0FBUyxLQUFLO0FBQUEsUUFDZCxlQUFlO0FBQUEsUUFDZixlQUFlO0FBQUE7QUFFakIsYUFBTyxRQUFRLFFBQVEsY0FFdEIsS0FBSyx5QkFBeUIsS0FBSyx1QkFBdUIsS0FBSyxhQUFhLEtBQUssa0JBQWtCLEtBQUssZUFBZTtBQUFBLFFBQ3RILFNBQVM7QUFBQSxVQUNQLEtBQUssZ0JBQWdCLEtBQUs7QUFBQTtBQUFBLEtBRy9CLGNBQWMsYUFBYTtBQUMxQixVQUFJLFlBQVksWUFBWTtBQUMxQixlQUFPO0FBQUE7QUFFVCxZQUFNLFdBQVcsQ0FBQyxPQUlaO0FBSlkscUJBQ2hCO0FBQUE7QUFBQSxVQUNBO0FBQUEsWUFGZ0IsSUFHYixpQkFIYSxJQUdiO0FBQUEsVUFGSDtBQUFBLFVBQ0E7QUFBQTtBQUdBLGFBQUssYUFBYTtBQUNsQixhQUFLLGFBQWE7QUFDbEIsZUFBTztBQUFBLFVBQ0w7QUFBQSxVQUNBO0FBQUEsV0FDRztBQUFBO0FBR1AsWUFBTSxlQUFlLFVBQVE7QUFDM0IsY0FBTSxtQkFBbUIsSUFBSSxpQkFBaUI7QUFBQSxVQUM1QyxRQUFRLFlBQVk7QUFBQSxVQUNwQixnQkFBZ0IsWUFBWTtBQUFBLFVBQzVCLGlCQUFpQixZQUFZO0FBQUEsVUFDN0IsYUFBYSxZQUFZO0FBQUEsVUFDekIsV0FBVyxZQUFZO0FBQUEsVUFDdkIsUUFBUSxLQUFLO0FBQUEsVUFDYixlQUFlLFlBQVk7QUFBQSxVQUMzQixlQUFlLFlBQVk7QUFBQTtBQUU3QixhQUFLLFVBQVUsUUFBUTtBQUN2QixlQUFPO0FBQUE7QUFFVCxZQUFNLGVBQWU7QUFBQSxRQUNuQixRQUFRLFlBQVk7QUFBQSxRQUNwQixhQUFhLFlBQVk7QUFBQSxRQUN6QixjQUFjLEtBQUs7QUFBQSxRQUNuQixTQUFTLEtBQUs7QUFBQSxRQUNkLFVBQVUsS0FBSztBQUFBLFFBQ2YsVUFBVSxLQUFLO0FBQUEsUUFDZixjQUFjLEtBQUs7QUFBQSxRQUNuQixlQUFlLFlBQVk7QUFBQSxRQUMzQixlQUFlLFlBQVk7QUFBQSxRQUMzQixZQUFZLEtBQUs7QUFBQSxRQUNqQixZQUFZLEtBQUs7QUFBQTtBQUVuQixhQUFPLFFBQVEsUUFBUSxjQUFjLEtBQUssZUFBZTtBQUFBLFFBQ3ZELEtBQUs7QUFBQSxVQUNILEtBQUssVUFBVSxLQUFLO0FBQUE7QUFBQSxLQUd6Qix3QkFBd0IsUUFBUTtBQUMvQixZQUFNLFdBQVcsS0FBSyxRQUFRO0FBQzlCLFVBQUksT0FBTyxhQUFhLFVBQVU7QUFDaEMsZUFBTyxTQUFTLGNBQWM7QUFBQSxpQkFDckIsb0JBQW9CLGFBQWE7QUFDMUMsZUFBTztBQUFBLGlCQUNFLE9BQU8sYUFBYSxZQUFZO0FBQ3pDLGVBQU8sU0FBUztBQUFBLGFBQ1g7QUFDTCxlQUFPLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFLcEIsbUNBQWlDLElBRzlCO0FBSDhCLGlCQUMvQjtBQUFBO0FBQUEsUUFEK0IsSUFFNUIsaUJBRjRCLElBRTVCO0FBQUEsTUFESDtBQUFBO0FBR0EsV0FBTyxZQUFZLGFBQVc7QUFDNUIsWUFBTSxhQUFhLE9BQU87QUFDMUIsY0FBUTtBQUFBLFFBQ047QUFBQSxRQUNBO0FBQUEsU0FDRztBQUFBO0FBQUE7QUFLVCxpQ0FBK0IsSUFLNUI7QUFMNEIsaUJBQzdCO0FBQUE7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLFFBSDZCLElBSTFCLGlCQUowQixJQUkxQjtBQUFBLE1BSEg7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBR0EsV0FBTyxZQUFZLGFBQVc7QUFDNUIsWUFBTSxNQUFNLFFBQVEsa0JBQWtCLE9BQU8sWUFBWSxVQUFVLFdBQVcsTUFBTSxRQUFRO0FBQzVGLFlBQU0sT0FBTyxRQUFRLGtCQUFrQixPQUFPLFlBQVksVUFBVSxXQUFXLE9BQU8sUUFBUTtBQUM5RixZQUFNLGVBQWU7QUFBQSxRQUNuQjtBQUFBLFFBQ0E7QUFBQTtBQUVGLGNBQVE7QUFBQSxRQUNOO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsU0FDRztBQUFBO0FBQUE7QUFLVCx1QkFBcUIsSUFLbEI7QUFMa0IsaUJBQ25CO0FBQUE7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLFFBSG1CLElBSWhCLGlCQUpnQixJQUloQjtBQUFBLE1BSEg7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBR0EsV0FBTyxZQUFZLGFBQVc7QUFDNUIsVUFBSTtBQUNKLFVBQUk7QUFDSixVQUFJLFFBQVEscUJBQXFCO0FBQy9CLGNBQU0sdUJBQXVCLGlCQUFpQjtBQUM5Qyx1QkFBZSxxQkFBcUIsaUJBQWlCO0FBQ3JELHNCQUFjLHFCQUFxQixpQkFBaUI7QUFBQTtBQUV0RCxhQUFPLE1BQU0sVUFBVTtBQUN2QixhQUFPLE1BQU0sV0FBVztBQUN4QixhQUFPLE1BQU0sZ0JBQWdCO0FBQzdCLGFBQU8sTUFBTSxNQUFNO0FBQ25CLGFBQU8sTUFBTSxPQUFPO0FBQ3BCLGFBQU8sTUFBTSxTQUFTO0FBQ3RCLFVBQUksUUFBUSxxQkFBcUI7QUFDL0IsZUFBTyxNQUFNLFNBQVM7QUFDdEIsZUFBTyxNQUFNLFFBQVE7QUFBQTtBQUV2QixjQUFRO0FBQUEsUUFDTjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsU0FDRztBQUFBO0FBQUE7QUFLVCw0QkFBMEIsSUFJdkI7QUFKdUIsaUJBQ3hCO0FBQUE7QUFBQSxNQUNBO0FBQUEsUUFGd0IsSUFHckIsaUJBSHFCLElBR3JCO0FBQUEsTUFGSDtBQUFBLE1BQ0E7QUFBQTtBQUdBLFdBQU8sWUFBWSxhQUFXO0FBQzVCLGFBQU8sVUFBVSxJQUFJLEdBQUc7QUFDeEIsY0FBUTtBQUFBLFFBQ047QUFBQSxRQUNBO0FBQUEsU0FDRztBQUFBO0FBQUE7QUFLVCwwQkFBd0IsSUFHckI7QUFIcUIsaUJBQ3RCO0FBQUE7QUFBQSxRQURzQixJQUVuQixpQkFGbUIsSUFFbkI7QUFBQSxNQURIO0FBQUE7QUFHQSxXQUFPLFlBQVksYUFBVztBQUM1QixhQUFPLGdCQUFnQjtBQUN2QixhQUFPLE9BQU87QUFDZCxjQUFRO0FBQUEsUUFDTjtBQUFBLFNBQ0c7QUFBQTtBQUFBO0FBS1QsMEJBQXdCO0FBQUEsSUFDdEIsWUFBWTtBQUFBLElBQ1osVUFBVTtBQUFBLE1BQ1IsSUFBSTtBQUNOLFdBQU8sQ0FBQyxPQWFGO0FBYkUsbUJBQ047QUFBQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxVQVhNLElBWUgsaUJBWkcsSUFZSDtBQUFBLFFBWEg7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUE7QUFHQSxhQUFPLFlBQVksYUFBVztBQUM1QixjQUFNLFNBQVM7QUFBQSxVQUNiO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsV0FDRztBQUVMLFlBQUksY0FBYztBQUNoQixnQkFBTSxJQUFJLGdCQUFnQixLQUFLLE1BQU8sYUFBWSxVQUFVLGFBQWEsT0FBTyxhQUFhLEtBQU0sU0FBUSxjQUFjLE1BQU8sU0FBUSxjQUFjLEtBQUssS0FBSyxNQUFNO0FBQ3RLLGdCQUFNLElBQUksZ0JBQWdCLEtBQUssTUFBTyxhQUFZLFVBQVUsYUFBYSxNQUFNLGFBQWEsS0FBTSxTQUFRLGNBQWMsTUFBTyxTQUFRLGNBQWMsS0FBSyxLQUFLLE1BQU07QUFDckssY0FBSSxRQUFRLFNBQVMsUUFBUSxTQUFTLFNBQVM7QUFDN0MsbUJBQU8sTUFBTSxZQUFZLGVBQWUsUUFBUTtBQUFBLHFCQUN2QyxRQUFRLFNBQVMsQ0FBQyxRQUFRLE9BQU87QUFDMUMsbUJBQU8sTUFBTSxZQUFZLGVBQWUsUUFBUTtBQUFBLHFCQUN2QyxRQUFRLFNBQVMsQ0FBQyxRQUFRLE9BQU87QUFDMUMsbUJBQU8sTUFBTSxZQUFZLGVBQWUsZUFBZTtBQUFBO0FBRXpELGNBQUksU0FBUztBQUNYLG1CQUFPLFdBQVc7QUFDbEIsbUJBQU8sV0FBVztBQUFBO0FBRXBCLGlCQUFPLGFBQWE7QUFDcEIsaUJBQU8sYUFBYTtBQUFBO0FBRXRCLGdCQUFRO0FBQUEsU0FDUDtBQUFBLFFBQ0QsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUtiLHVCQUFxQixVQUFVO0FBQUEsSUFDN0IsTUFBTTtBQUFBLE1BQ0osSUFBSTtBQUNOLFdBQU8sSUFBSSxRQUFRLENBQUMsU0FBUyxXQUFXO0FBQ3RDLFVBQUksS0FBSztBQUNQLDhCQUFzQixNQUFNO0FBQzFCLG1CQUFTLFNBQVM7QUFBQTtBQUFBLGFBRWY7QUFDTCxpQkFBUyxTQUFTO0FBQUE7QUFBQTtBQUFBO0FBS3hCLDZCQUEyQixhQUFhO0FBQ3RDLFdBQU8sUUFBUSxLQUFLLFlBQVksY0FBYztBQUFBOzs7QUM5Y2hELE1BQU0sZUFBYyxPQUFPO0FBQzNCLE1BQU0sY0FBYSxPQUFPO0FBQzFCLE1BQU0sY0FBYSxPQUFPO0FBQzFCLE1BQU0sU0FBUyxPQUFPO0FBRXRCLE1BQU0sa0JBQWlCO0FBQUEsSUFDckIsT0FBTztBQUFBLElBQ1AsYUFBYTtBQUFBLElBQ2Isb0JBQW9CO0FBQUE7QUFHdEIsaUNBQXlCLGVBQWU7QUFBQSxJQUV0QyxZQUFZLFdBQVc7QUFDckIsWUFBTTtBQUVOLFdBQUssVUFBVSxrQ0FDVixrQkFDQSxLQUFLO0FBR1YsV0FBSyx1QkFBdUI7QUFFNUIsV0FBSyx1QkFBdUI7QUFFNUIsV0FBSyxvQkFBb0I7QUFFekIsV0FBSyw2QkFBNkI7QUFDbEMsV0FBSyxnQkFBZSxLQUFLLGNBQWEsS0FBSztBQUMzQyxXQUFLLGVBQWMsS0FBSyxhQUFZLEtBQUs7QUFDekMsV0FBSyxlQUFjLEtBQUssYUFBWSxLQUFLO0FBQ3pDLFdBQUssVUFBVSxLQUFLLFFBQVEsS0FBSztBQUFBO0FBQUEsSUFHbkMsU0FBUztBQUNQLFdBQUssVUFBVSxHQUFHLGNBQWMsS0FBSyxlQUFjLEdBQUcsYUFBYSxLQUFLLGNBQWEsR0FBRyxhQUFhLEtBQUs7QUFBQTtBQUFBLElBRzVHLFNBQVM7QUFDUCxXQUFLLFVBQVUsSUFBSSxjQUFjLEtBQUssZUFBYyxJQUFJLGFBQWEsS0FBSyxjQUFhLElBQUksYUFBYSxLQUFLO0FBQUE7QUFBQSxJQUcvRyxhQUFhO0FBQ1gsYUFBTyxLQUFLLFVBQVUsUUFBUSxjQUFjO0FBQUE7QUFBQSxJQUc5QyxxQkFBcUIsUUFBUTtBQUMzQixVQUFJLEtBQUssZ0NBQWdDO0FBQ3ZDLGVBQU8sUUFBUSxRQUFRLEtBQUssUUFBUSx1QkFBdUIsU0FBUztBQUFBLGFBQy9EO0FBQ0wsZUFBTyx5QkFBeUI7QUFBQTtBQUFBO0FBQUEsSUFJcEMsK0JBQStCO0FBQzdCLGFBQU8sUUFBUSxLQUFLLFFBQVEsbUJBQW1CLFdBQVc7QUFBQTtBQUFBLEtBRzNELGNBQWEsV0FBVztBQUN2QixXQUFLLDZCQUE2QixzQkFBc0IsTUFBTTtBQUM1RCxhQUFLLG9CQUFvQixLQUFLLHFCQUFxQixVQUFVO0FBQUE7QUFBQTtBQUFBLEtBSWhFLGFBQVksV0FBVztBQUN0QixXQUFLLDZCQUE2QixzQkFBc0IsTUFBTTtBQUM1RCxhQUFLLG9CQUFvQixLQUFLLHFCQUFxQixVQUFVLFlBQVk7QUFBQTtBQUUzRSxVQUFJLENBQUMsS0FBSyxtQkFBbUI7QUFDM0I7QUFBQTtBQUVGLFlBQU0sY0FBYyxVQUFVO0FBQzlCLFlBQU0sZUFBZTtBQUFBLFFBQ25CLEdBQUc7QUFBQSxRQUNILEdBQUc7QUFBQTtBQUVMLFVBQUksa0JBQWtCLFFBQVE7QUFDNUIscUJBQWEsSUFBSSxPQUFPLGVBQWUsU0FBUyxnQkFBZ0IsYUFBYSxTQUFTLEtBQUssYUFBYTtBQUN4RyxxQkFBYSxJQUFJLE9BQU8sZUFBZSxTQUFTLGdCQUFnQixjQUFjLFNBQVMsS0FBSyxjQUFjO0FBQUE7QUFFNUcsV0FBSyx1QkFBdUI7QUFBQSxRQUMxQixTQUFTLFlBQVksVUFBVSxhQUFhO0FBQUEsUUFDNUMsU0FBUyxZQUFZLFVBQVUsYUFBYTtBQUFBO0FBRTlDLFdBQUssdUJBQXVCLHNCQUFzQixLQUFLO0FBQUE7QUFBQSxLQUd4RCxlQUFjO0FBQ2IsMkJBQXFCLEtBQUs7QUFDMUIsMkJBQXFCLEtBQUs7QUFDMUIsV0FBSyxvQkFBb0I7QUFDekIsV0FBSyx1QkFBdUI7QUFDNUIsV0FBSyw2QkFBNkI7QUFDbEMsV0FBSyx1QkFBdUI7QUFBQTtBQUFBLEtBRzdCLFVBQVU7QUFDVCxVQUFJLENBQUMsS0FBSyxxQkFBcUIsQ0FBQyxLQUFLLHNCQUFzQjtBQUN6RDtBQUFBO0FBRUYsMkJBQXFCLEtBQUs7QUFDMUIsWUFBTTtBQUFBLFFBQ0o7QUFBQSxRQUNBO0FBQUEsVUFDRSxLQUFLO0FBQ1QsWUFBTSxPQUFPLEtBQUssa0JBQWtCO0FBQ3BDLFlBQU0sZUFBZSxLQUFLLFNBQVMsT0FBTztBQUMxQyxZQUFNLFlBQVksS0FBSyxNQUFNO0FBQzdCLFlBQU0sU0FBUyxhQUFhO0FBQzVCLFlBQU0sMkJBQTJCO0FBQ2pDLFlBQU0sb0JBQW9CLEtBQUs7QUFDL0IsWUFBTSxVQUFVLEtBQUsscUJBQXFCO0FBQzFDLFlBQU0sVUFBVSxLQUFLLHFCQUFxQjtBQUMxQyxVQUFJLHNCQUFzQixTQUFTLFFBQVEsc0JBQXNCLFNBQVMsbUJBQW1CLENBQUMsUUFBUTtBQUNwRyxjQUFNO0FBQUEsVUFDSjtBQUFBLFVBQ0E7QUFBQSxZQUNFO0FBQ0osWUFBSSxLQUFLLE1BQU0sZUFBZSxVQUFVLGFBQWE7QUFDbkQsNEJBQWtCLGFBQWE7QUFBQSxtQkFDdEIsVUFBVSxLQUFLLE1BQU0sYUFBYTtBQUMzQyw0QkFBa0IsYUFBYTtBQUFBO0FBRWpDLFlBQUksS0FBSyxPQUFPLGNBQWMsVUFBVSxhQUFhO0FBQ25ELDRCQUFrQixjQUFjO0FBQUEsbUJBQ3ZCLFVBQVUsS0FBSyxPQUFPLGFBQWE7QUFDNUMsNEJBQWtCLGNBQWM7QUFBQTtBQUFBLGFBRTdCO0FBQ0wsY0FBTTtBQUFBLFVBQ0o7QUFBQSxVQUNBO0FBQUEsWUFDRTtBQUNKLFlBQUksVUFBVSxhQUFhO0FBQ3pCLG1DQUF5QixhQUFhO0FBQUEsbUJBQzdCLGNBQWMsVUFBVSxhQUFhO0FBQzlDLG1DQUF5QixhQUFhO0FBQUE7QUFFeEMsWUFBSSxVQUFVLGFBQWE7QUFDekIsbUNBQXlCLGNBQWM7QUFBQSxtQkFDOUIsYUFBYSxVQUFVLGFBQWE7QUFDN0MsbUNBQXlCLGNBQWM7QUFBQTtBQUFBO0FBRzNDLFdBQUssdUJBQXVCLHNCQUFzQixLQUFLO0FBQUE7QUFBQTtBQUkzRCx1QkFBcUIsU0FBUztBQUM1QixVQUFNLGdCQUFnQjtBQUN0QixVQUFNLGlCQUFpQixpQkFBaUIsU0FBUztBQUNqRCxVQUFNLFdBQVcsZUFBZSxpQkFBaUIsY0FBYyxlQUFlLGlCQUFpQixnQkFBZ0IsZUFBZSxpQkFBaUI7QUFDL0ksV0FBTyxjQUFjLEtBQUs7QUFBQTtBQUc1QixrQ0FBZ0MsU0FBUztBQUN2QyxVQUFNLFdBQVcsaUJBQWlCLFNBQVMsaUJBQWlCO0FBQzVELFdBQU8sYUFBYTtBQUFBO0FBR3RCLG9DQUFrQyxTQUFTO0FBQ3pDLFFBQUksQ0FBQyxTQUFTO0FBQ1osYUFBTztBQUFBO0FBRVQsVUFBTSxXQUFXLGlCQUFpQixTQUFTLGlCQUFpQjtBQUM1RCxVQUFNLHVCQUF1QixhQUFhO0FBQzFDLFVBQU0sb0JBQW9CLFFBQVEsU0FBUyxZQUFVO0FBQ25ELFVBQUksd0JBQXdCLHVCQUF1QixTQUFTO0FBQzFELGVBQU87QUFBQTtBQUVULGFBQU8sWUFBWTtBQUFBO0FBRXJCLFFBQUksYUFBYSxXQUFXLENBQUMsbUJBQW1CO0FBQzlDLGFBQU87QUFBQSxXQUNGO0FBQ0wsYUFBTztBQUFBO0FBQUE7QUFJWCx5Q0FBdUM7QUFDckMsV0FBTyxTQUFTLG9CQUFvQixTQUFTO0FBQUE7OztBQ3ZML0Msc0JBQWM7QUFBQSxJQUNaLGNBQWM7QUFDWixXQUFLLFlBQVk7QUFBQTtBQUFBLElBR25CLEdBQUcsU0FBUyxXQUFXO0FBQ3JCLFVBQUksQ0FBQyxLQUFLLFVBQVUsT0FBTztBQUN6QixhQUFLLFVBQVUsUUFBUTtBQUFBO0FBRXpCLFdBQUssVUFBVSxNQUFNLEtBQUssR0FBRztBQUM3QixhQUFPO0FBQUE7QUFBQSxJQUdULElBQUksTUFBTSxVQUFVO0FBQ2xCLFVBQUksQ0FBQyxLQUFLLFVBQVUsT0FBTztBQUN6QixlQUFPO0FBQUE7QUFFVCxZQUFNLE9BQU8sS0FBSyxVQUFVLE1BQU0sTUFBTTtBQUN4QyxlQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQ3BDLFlBQUksYUFBYSxLQUFLLElBQUk7QUFDeEIsZUFBSyxVQUFVLE1BQU0sT0FBTyxHQUFHO0FBQUE7QUFBQTtBQUduQyxhQUFPO0FBQUE7QUFBQSxJQUdULFFBQVEsT0FBTztBQUNiLFVBQUksQ0FBQyxLQUFLLFVBQVUsTUFBTSxPQUFPO0FBQy9CLGVBQU87QUFBQTtBQUVULFlBQU0sWUFBWSxDQUFDLEdBQUcsS0FBSyxVQUFVLE1BQU07QUFDM0MsWUFBTSxlQUFlO0FBQ3JCLGVBQVMsSUFBSSxVQUFVLFNBQVMsR0FBRyxLQUFLLEdBQUcsS0FBSztBQUM5QyxjQUFNLFdBQVcsVUFBVTtBQUMzQixZQUFJO0FBQ0YsbUJBQVM7QUFBQSxpQkFDRixPQUFQO0FBQ0EsdUJBQWEsS0FBSztBQUFBO0FBQUE7QUFHdEIsVUFBSSxhQUFhLFFBQVE7QUFFdkIsZ0JBQVEsTUFBTSw2Q0FBNkMsTUFBTSxTQUFTO0FBQUE7QUFJNUUsYUFBTztBQUFBO0FBQUE7OztBQzVDWCxxQ0FBNkIsY0FBYztBQUFBLFFBRXJDLFlBQVk7QUFDZCxhQUFPLEtBQUssS0FBSztBQUFBO0FBQUE7QUFJckIsaUJBQWUsT0FBTztBQUN0QixnREFBd0MsZUFBZTtBQUFBO0FBRXZELDRCQUEwQixPQUFPO0FBQ2pDLDRDQUFvQyxlQUFlO0FBQUE7QUFDbkQsd0JBQXNCLE9BQU87OztBQ0Y3QixNQUFNLGVBQWMsT0FBTztBQUMzQixNQUFNLGNBQWEsT0FBTztBQUMxQixNQUFNLGNBQWEsT0FBTztBQUMxQixNQUFNLGlCQUFpQixPQUFPO0FBQzlCLE1BQU0sV0FBVyxPQUFPO0FBRXhCLE1BQU0sdUJBQXVCO0FBQUEsSUFDM0IsY0FBYyxXQUFTLGFBQWEsTUFBTSxPQUFPLFlBQVksVUFBVSxNQUFNLE9BQU8sTUFBTTtBQUFBLElBQzFGLGFBQWEsV0FBUyxZQUFZLE1BQU0sT0FBTyxZQUFZLFVBQVUsTUFBTSxPQUFPLE1BQU07QUFBQTtBQUUxRixNQUFNLGlCQUFpQjtBQUFBLElBQ3JCLHNCQUFzQjtBQUFBLElBQ3RCLG1CQUFtQjtBQUFBLElBQ25CLGlCQUFpQjtBQUFBLElBQ2pCLG9CQUFvQjtBQUFBLElBQ3BCLGlCQUFpQjtBQUFBLElBQ2pCLGtCQUFrQjtBQUFBLElBQ2xCLGtCQUFrQjtBQUFBLElBQ2xCLG1CQUFtQjtBQUFBLElBQ25CLFFBQVE7QUFBQTtBQUVWLE1BQU0sa0JBQWlCO0FBQUEsSUFDckIsV0FBVztBQUFBLElBQ1gsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsVUFBVTtBQUFBLElBQ1YsZUFBZTtBQUFBLElBQ2YsU0FBUztBQUFBLElBQ1QsU0FBUztBQUFBLElBQ1QsU0FBUztBQUFBLE1BQ1AsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBO0FBQUE7QUFJYix3QkFBZ0I7QUFBQSxJQUVkLFlBQVksYUFBYSxDQUFDLFNBQVMsT0FBTyxVQUFVLElBQUk7QUFFdEQsVUFBSSxzQkFBc0IsWUFBWSxzQkFBc0IsT0FBTztBQUNqRSxhQUFLLGFBQWEsQ0FBQyxHQUFHO0FBQUEsaUJBQ2Isc0JBQXNCLGFBQWE7QUFDNUMsYUFBSyxhQUFhLENBQUM7QUFBQSxhQUNkO0FBQ0wsY0FBTSxJQUFJLE1BQU07QUFBQTtBQUVsQixXQUFLLFVBQVUsZ0RBQ1Ysa0JBQ0EsVUFGVTtBQUFBLFFBR2IsU0FBUyxrQ0FDSixpQkFDQyxRQUFRLFdBQVc7QUFBQSxRQUV6QixlQUFlLGtDQUNWLHVCQUNDLFFBQVEsaUJBQWlCO0FBQUEsUUFFL0IsU0FBUztBQUFBLFVBQ1AsU0FBUyxRQUFRLFdBQVcsUUFBUSxRQUFRLFdBQVc7QUFBQSxVQUN2RCxTQUFTLFFBQVEsV0FBVyxRQUFRLFFBQVEsV0FBVztBQUFBO0FBQUE7QUFJM0QsV0FBSyxVQUFVLElBQUk7QUFFbkIsV0FBSyxXQUFXO0FBRWhCLFdBQUssVUFBVTtBQUVmLFdBQUssVUFBVTtBQUNmLFdBQUssZ0JBQWUsS0FBSyxjQUFhLEtBQUs7QUFDM0MsV0FBSyxlQUFjLEtBQUssYUFBWSxLQUFLO0FBQ3pDLFdBQUssZUFBYyxLQUFLLGFBQVksS0FBSztBQUN6QyxXQUFLLGtCQUFrQixLQUFLLGdCQUFnQixLQUFLO0FBQ2pELFdBQUssWUFBWSxLQUFLLFVBQVUsS0FBSztBQUNyQyxlQUFTLGlCQUFpQixjQUFjLEtBQUssZUFBYztBQUMzRCxlQUFTLGlCQUFpQixhQUFhLEtBQUssY0FBYTtBQUN6RCxlQUFTLGlCQUFpQixhQUFhLEtBQUssY0FBYTtBQUN6RCxlQUFTLGlCQUFpQixpQkFBaUIsS0FBSyxpQkFBaUI7QUFDakUsWUFBTSxpQkFBaUIsT0FBTyxPQUFPLFVBQVUsU0FBUyxPQUFPLFlBQVUsQ0FBQyxLQUFLLFFBQVEsUUFBUSxRQUFRLFNBQVM7QUFDaEgsWUFBTSxpQkFBaUIsT0FBTyxPQUFPLFVBQVUsU0FBUyxPQUFPLFlBQVUsQ0FBQyxLQUFLLFFBQVEsUUFBUSxRQUFRLFNBQVM7QUFDaEgsV0FBSyxVQUFVLEdBQUcsQ0FBQyxHQUFHLGdCQUFnQixHQUFHLEtBQUssUUFBUTtBQUN0RCxXQUFLLFVBQVUsR0FBRyxDQUFDLEdBQUcsZ0JBQWdCLEdBQUcsS0FBSyxRQUFRO0FBQ3RELFlBQU0sNEJBQTRCLElBQUksMEJBQTBCO0FBQUEsUUFDOUQsV0FBVztBQUFBO0FBRWIsV0FBSyxHQUFHLGtCQUFrQixDQUFDO0FBQUEsUUFDekI7QUFBQSxZQUNJLEtBQUssU0FBUztBQUNwQixXQUFLLEdBQUcsa0JBQWtCLE1BQU0sS0FBSyxTQUFTO0FBQzlDLFdBQUssUUFBUTtBQUFBO0FBQUEsSUFHZixVQUFVO0FBQ1IsZUFBUyxvQkFBb0IsY0FBYyxLQUFLLGVBQWM7QUFDOUQsZUFBUyxvQkFBb0IsYUFBYSxLQUFLLGNBQWE7QUFDNUQsZUFBUyxvQkFBb0IsYUFBYSxLQUFLLGNBQWE7QUFDNUQsZUFBUyxvQkFBb0IsaUJBQWlCLEtBQUssaUJBQWlCO0FBQ3BFLFlBQU0sd0JBQXdCLElBQUksc0JBQXNCO0FBQUEsUUFDdEQsV0FBVztBQUFBO0FBRWIsV0FBSyxRQUFRO0FBQ2IsV0FBSyxhQUFhLEdBQUcsS0FBSyxRQUFRLElBQUksWUFBVSxPQUFPO0FBQ3ZELFdBQUssYUFBYSxHQUFHLEtBQUssUUFBUSxJQUFJLFlBQVUsT0FBTztBQUFBO0FBQUEsSUFHekQsYUFBYSxTQUFTO0FBQ3BCLFlBQU0sZ0JBQWdCLFFBQVEsSUFBSSxZQUFVLElBQUksT0FBTztBQUN2RCxvQkFBYyxRQUFRLFlBQVUsT0FBTztBQUN2QyxXQUFLLFVBQVUsQ0FBQyxHQUFHLEtBQUssU0FBUyxHQUFHO0FBQ3BDLGFBQU87QUFBQTtBQUFBLElBR1QsZ0JBQWdCLFNBQVM7QUFDdkIsWUFBTSxpQkFBaUIsS0FBSyxRQUFRLE9BQU8sWUFBVSxRQUFRLFNBQVMsT0FBTztBQUM3RSxxQkFBZSxRQUFRLFlBQVUsT0FBTztBQUN4QyxXQUFLLFVBQVUsS0FBSyxRQUFRLE9BQU8sWUFBVSxDQUFDLFFBQVEsU0FBUyxPQUFPO0FBQ3RFLGFBQU87QUFBQTtBQUFBLElBR1QsYUFBYSxTQUFTO0FBQ3BCLFlBQU0sZ0JBQWdCLFFBQVEsSUFBSSxhQUFVLElBQUksUUFBTyxLQUFLLFlBQVksS0FBSztBQUM3RSxvQkFBYyxRQUFRLFlBQVUsT0FBTztBQUN2QyxXQUFLLFVBQVUsQ0FBQyxHQUFHLEtBQUssU0FBUyxHQUFHO0FBQ3BDLGFBQU87QUFBQTtBQUFBLElBR1QsZ0JBQWdCLFNBQVM7QUFDdkIsWUFBTSxpQkFBaUIsS0FBSyxRQUFRLE9BQU8sWUFBVSxRQUFRLFNBQVMsT0FBTztBQUM3RSxxQkFBZSxRQUFRLFlBQVUsT0FBTztBQUN4QyxXQUFLLFVBQVUsS0FBSyxRQUFRLE9BQU8sWUFBVSxDQUFDLFFBQVEsU0FBUyxPQUFPO0FBQ3RFLGFBQU87QUFBQTtBQUFBLElBR1QsZ0JBQWdCLFlBQVk7QUFDMUIsV0FBSyxhQUFhLENBQUMsR0FBRyxLQUFLLFlBQVksR0FBRztBQUMxQyxXQUFLLFFBQVEsUUFBUSxZQUFVLE9BQU8sYUFBYSxHQUFHO0FBQ3RELGFBQU87QUFBQTtBQUFBLElBR1QsbUJBQW1CLFlBQVk7QUFDN0IsV0FBSyxhQUFhLEtBQUssV0FBVyxPQUFPLGVBQWEsQ0FBQyxXQUFXLFNBQVM7QUFDM0UsV0FBSyxRQUFRLFFBQVEsWUFBVSxPQUFPLGdCQUFnQixHQUFHO0FBQ3pELGFBQU87QUFBQTtBQUFBLElBR1QsR0FBRyxTQUFTLFdBQVc7QUFDckIsV0FBSyxRQUFRLEdBQUcsTUFBTSxHQUFHO0FBQ3pCLGFBQU87QUFBQTtBQUFBLElBR1QsSUFBSSxNQUFNLFVBQVU7QUFDbEIsV0FBSyxRQUFRLElBQUksTUFBTTtBQUN2QixhQUFPO0FBQUE7QUFBQSxJQUdULFFBQVEsT0FBTztBQUNiLFdBQUssUUFBUSxRQUFRO0FBQ3JCLGFBQU87QUFBQTtBQUFBLElBR1QsZ0JBQWdCLE1BQU07QUFDcEIsYUFBTyxLQUFLLGlCQUFpQixNQUFNO0FBQUE7QUFBQSxJQUdyQyxpQkFBaUIsTUFBTTtBQUNyQixZQUFNLGFBQWEsS0FBSyxRQUFRLFFBQVE7QUFDeEMsVUFBSSxzQkFBc0IsT0FBTztBQUMvQixlQUFPO0FBQUEsaUJBQ0UsT0FBTyxlQUFlLFlBQVksc0JBQXNCLFFBQVE7QUFDekUsZUFBTyxDQUFDO0FBQUEsYUFDSDtBQUNMLGVBQU87QUFBQTtBQUFBO0FBQUEsSUFJWCxhQUFhO0FBQ1gsYUFBTyxRQUFRLEtBQUs7QUFBQTtBQUFBLElBR3RCLHVCQUF1QjtBQUNyQixhQUFPLEtBQUssV0FBVyxPQUFPLENBQUMsU0FBUyxjQUFjO0FBQ3BELGVBQU8sQ0FBQyxHQUFHLFNBQVMsR0FBRyxLQUFLLGlDQUFpQztBQUFBLFNBQzVEO0FBQUE7QUFBQSxJQUdMLGlDQUFpQyxXQUFXO0FBQzFDLFlBQU0sdUJBQXVCLFVBQVUsaUJBQWlCLEtBQUssUUFBUTtBQUNyRSxhQUFPLENBQUMsR0FBRyxzQkFBc0IsT0FBTyxrQkFBZ0I7QUFDdEQsZUFBTyxpQkFBaUIsS0FBSyxrQkFBa0IsaUJBQWlCLEtBQUs7QUFBQTtBQUFBO0FBQUEsSUFJekUsU0FBUztBQUNQLFdBQUs7QUFBQTtBQUFBLEtBR04sY0FBYSxPQUFPO0FBQ25CLFlBQU0sY0FBYyxlQUFlO0FBQ25DLFlBQU07QUFBQSxRQUNKO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxVQUNFO0FBQ0osVUFBSSxDQUFDLEtBQUssV0FBVyxTQUFTLFlBQVk7QUFDeEM7QUFBQTtBQUVGLFVBQUksS0FBSyxRQUFRLFVBQVUsVUFBVSxDQUFDLFFBQVEsUUFBUSxLQUFLLFFBQVEsU0FBUztBQUMxRSxvQkFBWTtBQUNaO0FBQUE7QUFFRixXQUFLLGlCQUFpQjtBQUN0QixXQUFLLGtCQUFrQjtBQUN2QixVQUFJLEtBQUssb0JBQW9CLEtBQUsscUJBQXFCO0FBQ3JELHFCQUFhLEtBQUs7QUFDbEIsYUFBSyxpQkFBaUIsVUFBVSxPQUFPLEdBQUcsS0FBSyxpQkFBaUI7QUFDaEUsYUFBSyxvQkFBb0IsVUFBVSxPQUFPLEdBQUcsS0FBSyxpQkFBaUI7QUFBQTtBQUVyRSxXQUFLLFNBQVMsS0FBSyxlQUFlLFVBQVU7QUFDNUMsV0FBSyxlQUFlLFdBQVcsYUFBYSxLQUFLLFFBQVEsS0FBSztBQUM5RCxXQUFLLGVBQWUsTUFBTSxVQUFVO0FBQ3BDLFlBQU0saUJBQWlCLElBQUksZUFBZTtBQUFBLFFBQ3hDLFFBQVEsS0FBSztBQUFBLFFBQ2IsZ0JBQWdCLEtBQUs7QUFBQSxRQUNyQixpQkFBaUI7QUFBQSxRQUNqQjtBQUFBO0FBRUYsV0FBSyxRQUFRO0FBQ2IsV0FBSyxXQUFXLENBQUMsZUFBZTtBQUNoQyxVQUFJLGVBQWUsWUFBWTtBQUM3QixhQUFLLE9BQU87QUFDWixhQUFLLGVBQWUsTUFBTSxVQUFVO0FBQ3BDO0FBQUE7QUFFRixXQUFLLGVBQWUsVUFBVSxJQUFJLEdBQUcsS0FBSyxpQkFBaUI7QUFDM0QsV0FBSyxPQUFPLFVBQVUsSUFBSSxHQUFHLEtBQUssaUJBQWlCO0FBQ25ELFdBQUssZ0JBQWdCLFVBQVUsSUFBSSxHQUFHLEtBQUssaUJBQWlCO0FBQzVELGVBQVMsS0FBSyxVQUFVLElBQUksR0FBRyxLQUFLLGlCQUFpQjtBQUNyRCxzQkFBZ0IsU0FBUyxNQUFNO0FBQy9CLDRCQUFzQixNQUFNO0FBQzFCLGNBQU0saUJBQWlCLGVBQWU7QUFDdEMsY0FBTSxpQkFBaUIsZUFBZSxNQUFNO0FBQUEsVUFDMUMsUUFBUSxLQUFLO0FBQUE7QUFFZixhQUFLLGFBQVksaUNBQ1osUUFEWTtBQUFBLFVBRWYsUUFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBS2IsYUFBWSxPQUFPO0FBQ2xCLFVBQUksQ0FBQyxLQUFLLFVBQVU7QUFDbEI7QUFBQTtBQUVGLFlBQU0sY0FBYyxlQUFlO0FBQ25DLFlBQU07QUFBQSxRQUNKO0FBQUEsVUFDRTtBQUNKLFVBQUksU0FBUyxZQUFZO0FBQ3pCLFlBQU0sZ0JBQWdCLElBQUksY0FBYztBQUFBLFFBQ3RDLFFBQVEsS0FBSztBQUFBLFFBQ2IsZ0JBQWdCLEtBQUs7QUFBQSxRQUNyQixpQkFBaUI7QUFBQSxRQUNqQjtBQUFBO0FBRUYsV0FBSyxRQUFRO0FBQ2IsVUFBSSxjQUFjLFlBQVk7QUFDNUIsb0JBQVk7QUFBQTtBQUVkLGVBQVMsUUFBUSxRQUFRLEtBQUssUUFBUTtBQUN0QyxZQUFNLHlCQUF5QixRQUFRLFlBQVksUUFBUSxLQUFLO0FBQ2hFLFlBQU0sZ0JBQWdCLFlBQVksaUJBQWlCO0FBQ25ELFlBQU0scUJBQXFCLEtBQUssd0JBQXdCLGtCQUFrQixLQUFLO0FBQy9FLFlBQU0scUJBQXFCLEtBQUssZUFBZSxXQUFXLEtBQUs7QUFDL0QsWUFBTSxrQkFBa0IsaUJBQWlCLEtBQUsseUJBQXlCO0FBQ3ZFLFlBQU0sa0JBQWtCLDBCQUEwQixVQUFVLEtBQUssZ0JBQWdCO0FBQ2pGLFVBQUksb0JBQW9CO0FBQ3RCLGNBQU0sZUFBZSxJQUFJLGFBQWE7QUFBQSxVQUNwQyxRQUFRLEtBQUs7QUFBQSxVQUNiLGdCQUFnQixLQUFLO0FBQUEsVUFDckIsaUJBQWlCO0FBQUEsVUFDakI7QUFBQSxVQUNBLE1BQU0sS0FBSztBQUFBLFVBQ1gsZUFBZSxLQUFLO0FBQUE7QUFFdEIsYUFBSyxZQUFZLFVBQVUsT0FBTyxHQUFHLEtBQUssaUJBQWlCO0FBQzNELGFBQUssY0FBYztBQUNuQixhQUFLLFFBQVE7QUFBQTtBQUVmLFVBQUksb0JBQW9CO0FBQ3RCLGNBQU0sd0JBQXdCLElBQUksc0JBQXNCO0FBQUEsVUFDdEQsUUFBUSxLQUFLO0FBQUEsVUFDYixnQkFBZ0IsS0FBSztBQUFBLFVBQ3JCLGlCQUFpQjtBQUFBLFVBQ2pCO0FBQUEsVUFDQSxlQUFlLEtBQUs7QUFBQTtBQUV0QixhQUFLLHFCQUFxQixVQUFVLE9BQU8sR0FBRyxLQUFLLGlCQUFpQjtBQUNwRSxhQUFLLHVCQUF1QjtBQUM1QixhQUFLLFFBQVE7QUFBQTtBQUVmLFVBQUksaUJBQWlCO0FBQ25CLHNCQUFjLFVBQVUsSUFBSSxHQUFHLEtBQUssaUJBQWlCO0FBQ3JELGNBQU0seUJBQXlCLElBQUksdUJBQXVCO0FBQUEsVUFDeEQsUUFBUSxLQUFLO0FBQUEsVUFDYixnQkFBZ0IsS0FBSztBQUFBLFVBQ3JCLGlCQUFpQjtBQUFBLFVBQ2pCO0FBQUEsVUFDQTtBQUFBO0FBRUYsYUFBSyx1QkFBdUI7QUFDNUIsYUFBSyxRQUFRO0FBQUE7QUFFZixVQUFJLGlCQUFpQjtBQUNuQixlQUFPLFVBQVUsSUFBSSxHQUFHLEtBQUssaUJBQWlCO0FBQzlDLGNBQU0sZ0JBQWdCLElBQUksY0FBYztBQUFBLFVBQ3RDLFFBQVEsS0FBSztBQUFBLFVBQ2IsZ0JBQWdCLEtBQUs7QUFBQSxVQUNyQixpQkFBaUI7QUFBQSxVQUNqQjtBQUFBLFVBQ0E7QUFBQSxVQUNBLE1BQU07QUFBQTtBQUVSLGFBQUssY0FBYztBQUNuQixhQUFLLFFBQVE7QUFBQTtBQUFBO0FBQUEsS0FJaEIsVUFBVSxPQUFPO0FBQ2hCLFVBQUksQ0FBQyxLQUFLLFVBQVU7QUFDbEI7QUFBQTtBQUVGLFdBQUssV0FBVztBQUNoQixZQUFNLGdCQUFnQixJQUFJLGNBQWM7QUFBQSxRQUN0QyxRQUFRLEtBQUs7QUFBQSxRQUNiLGdCQUFnQixLQUFLO0FBQUEsUUFDckIsYUFBYSxRQUFRLE1BQU0sY0FBYztBQUFBLFFBQ3pDLGlCQUFpQixLQUFLO0FBQUE7QUFFeEIsV0FBSyxRQUFRO0FBQ2IsVUFBSSxDQUFDLGNBQWM7QUFBWSxhQUFLLE9BQU8sV0FBVyxhQUFhLEtBQUssZ0JBQWdCLEtBQUs7QUFDN0YsV0FBSyxPQUFPO0FBQ1osV0FBSyxlQUFlLE1BQU0sVUFBVTtBQUNwQyxXQUFLLE9BQU8sVUFBVSxPQUFPLEdBQUcsS0FBSyxpQkFBaUI7QUFDdEQsV0FBSyxlQUFlLFVBQVUsT0FBTyxHQUFHLEtBQUssaUJBQWlCO0FBQzlELFdBQUssZUFBZSxVQUFVLElBQUksR0FBRyxLQUFLLGlCQUFpQjtBQUMzRCxXQUFLLGdCQUFnQixVQUFVLElBQUksR0FBRyxLQUFLLGlCQUFpQjtBQUM1RCxXQUFLLGdCQUFnQixVQUFVLE9BQU8sR0FBRyxLQUFLLGlCQUFpQjtBQUMvRCxlQUFTLEtBQUssVUFBVSxPQUFPLEdBQUcsS0FBSyxpQkFBaUI7QUFDeEQsc0JBQWdCLFNBQVMsTUFBTTtBQUMvQixVQUFJLEtBQUssYUFBYTtBQUNwQixhQUFLLFlBQVksVUFBVSxPQUFPLEdBQUcsS0FBSyxpQkFBaUI7QUFBQTtBQUU3RCxVQUFJLEtBQUssc0JBQXNCO0FBQzdCLGFBQUsscUJBQXFCLFVBQVUsT0FBTyxHQUFHLEtBQUssaUJBQWlCO0FBQUE7QUFFdEUsV0FBSyxtQkFBbUIsS0FBSztBQUM3QixXQUFLLHNCQUFzQixLQUFLO0FBQ2hDLFdBQUssa0JBQWtCLFdBQVcsTUFBTTtBQUN0QyxZQUFJLEtBQUssa0JBQWtCO0FBQ3pCLGVBQUssaUJBQWlCLFVBQVUsT0FBTyxHQUFHLEtBQUssaUJBQWlCO0FBQUE7QUFFbEUsWUFBSSxLQUFLLHFCQUFxQjtBQUM1QixlQUFLLG9CQUFvQixVQUFVLE9BQU8sR0FBRyxLQUFLLGlCQUFpQjtBQUFBO0FBRXJFLGFBQUssbUJBQW1CO0FBQ3hCLGFBQUssc0JBQXNCO0FBQUEsU0FDMUIsS0FBSyxRQUFRO0FBQ2hCLFlBQU0sbUJBQW1CLElBQUksaUJBQWlCO0FBQUEsUUFDNUMsUUFBUSxLQUFLO0FBQUEsUUFDYixnQkFBZ0IsS0FBSztBQUFBLFFBQ3JCLGFBQWEsUUFBUSxNQUFNLGNBQWM7QUFBQSxRQUN6QyxpQkFBaUIsS0FBSztBQUFBO0FBRXhCLFdBQUssUUFBUTtBQUNiLFdBQUssU0FBUztBQUNkLFdBQUssaUJBQWlCO0FBQ3RCLFdBQUssdUJBQXVCO0FBQzVCLFdBQUssY0FBYztBQUNuQixXQUFLLGtCQUFrQjtBQUFBO0FBQUEsS0FHeEIsYUFBWSxPQUFPO0FBQ2xCLFdBQUssVUFBVTtBQUFBO0FBQUEsS0FHaEIsZ0JBQWdCLE9BQU87QUFDdEIsVUFBSSxDQUFDLEtBQUssVUFBVTtBQUNsQjtBQUFBO0FBRUYsWUFBTSxjQUFjLGVBQWU7QUFDbkMsWUFBTSxTQUFTLEtBQUssVUFBVSxRQUFRLFlBQVksY0FBYyxRQUFRLEtBQUssUUFBUTtBQUNyRixZQUFNLG9CQUFvQixJQUFJLGtCQUFrQjtBQUFBLFFBQzlDO0FBQUEsUUFDQTtBQUFBLFFBQ0EsVUFBVSxZQUFZO0FBQUE7QUFFeEIsV0FBSyxRQUFRO0FBQUE7QUFBQTtBQUlqQixZQUFVLFVBQVU7QUFBQSxJQUNsQjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBO0FBR0YsWUFBVSxVQUFVO0FBQUEsSUFDbEI7QUFBQSxJQUNBO0FBQUE7QUFFRiwwQkFBd0IsT0FBTztBQUM3QixXQUFPLE1BQU07QUFBQTtBQUVmLDJCQUF5QixTQUFTLE9BQU87QUFDdkMsWUFBUSxNQUFNLG1CQUFtQjtBQUNqQyxZQUFRLE1BQU0sZ0JBQWdCO0FBQzlCLFlBQVEsTUFBTSxlQUFlO0FBQzdCLFlBQVEsTUFBTSxjQUFjO0FBQzVCLFlBQVEsTUFBTSxhQUFhO0FBQUE7OztBQy9hN0IscUNBQTZCLGNBQWM7QUFBQSxJQUV6QyxZQUFZLE1BQU07QUFDaEIsWUFBTTtBQUNOLFdBQUssT0FBTztBQUFBO0FBQUEsUUFHVixZQUFZO0FBQ2QsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3JCLGlCQUFlLE9BQU87QUFFdEIsMENBQWtDLGVBQWU7QUFBQSxRQUUzQyxXQUFXO0FBQ2IsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3JCLHNCQUFvQixPQUFPO0FBQzNCLHNCQUFvQixhQUFhO0FBRWpDLDRDQUFvQyxlQUFlO0FBQUEsUUFFN0MsV0FBVztBQUNiLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUdyQix3QkFBc0IsT0FBTztBQUM3Qix3QkFBc0IsYUFBYTtBQUVuQyw2Q0FBcUMsZUFBZTtBQUFBLFFBRTlDLFdBQVc7QUFDYixhQUFPLEtBQUssS0FBSztBQUFBO0FBQUE7QUFHckIseUJBQXVCLE9BQU87QUFDOUIseUJBQXVCLGFBQWE7QUFFcEMseUNBQWlDLGVBQWU7QUFBQSxRQUUxQyxXQUFXO0FBQ2IsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3JCLHFCQUFtQixPQUFPO0FBQzFCLHFCQUFtQixhQUFhOzs7QUN2Q2hDLE1BQU0sZUFBYyxPQUFPO0FBQzNCLE1BQU0sY0FBYSxPQUFPO0FBQzFCLE1BQU0sY0FBYSxPQUFPO0FBQzFCLE1BQU0saUJBQWlCLE9BQU87QUFDOUIsTUFBTSwyQkFBMkIsT0FBTztBQUN4QyxNQUFNLGtCQUFrQixPQUFPO0FBQy9CLE1BQU0sZUFBZSxPQUFPOzs7QUNkNUIscUNBQTZCLGNBQWM7QUFBQSxJQUV6QyxZQUFZLE1BQU07QUFDaEIsWUFBTTtBQUNOLFdBQUssT0FBTztBQUFBO0FBQUEsUUFHVixZQUFZO0FBQ2QsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBSXJCLGlCQUFlLE9BQU87QUFDdEIsMENBQWtDLGVBQWU7QUFBQTtBQUNqRCxzQkFBb0IsT0FBTztBQUMzQixzQkFBb0IsYUFBYTtBQUVqQyx5Q0FBaUMsZUFBZTtBQUFBLFFBRTFDLE9BQU87QUFDVCxhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixnQkFBZ0I7QUFDbEIsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3JCLHFCQUFtQixPQUFPO0FBQzFCLHFCQUFtQixhQUFhO0FBRWhDLDRDQUFvQyxlQUFlO0FBQUEsUUFFN0MsaUJBQWlCO0FBQ25CLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUlyQix3QkFBc0IsT0FBTztBQUM3Qix5Q0FBaUMsZUFBZTtBQUFBO0FBQ2hELHFCQUFtQixPQUFPOzs7QUNoQzFCLE1BQU0sZUFBYyxPQUFPO0FBQzNCLE1BQU0sY0FBYSxPQUFPO0FBQzFCLE1BQU0sY0FBYSxPQUFPOzs7QUNUMUIsb0NBQTRCLGNBQWM7QUFBQSxJQUV4QyxZQUFZLE1BQU07QUFDaEIsWUFBTTtBQUNOLFdBQUssT0FBTztBQUFBO0FBQUEsUUFHVixZQUFZO0FBQ2QsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBO0FBR3JCLGdCQUFjLE9BQU87QUFFckIseUNBQWlDLGNBQWM7QUFBQSxRQUV6QyxhQUFhO0FBQ2YsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBLFFBR2YsaUJBQWlCO0FBQ25CLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUdyQixxQkFBbUIsT0FBTztBQUMxQixxQkFBbUIsYUFBYTtBQUVoQyx3Q0FBZ0MsY0FBYztBQUFBLFFBRXhDLGVBQWU7QUFDakIsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBLFFBR2YsT0FBTztBQUNULGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQSxRQUdmLGdCQUFnQjtBQUNsQixhQUFPLEtBQUssS0FBSyxVQUFVO0FBQUE7QUFBQTtBQUcvQixvQkFBa0IsT0FBTztBQUN6QixvQkFBa0IsYUFBYTtBQUUvQiwwQ0FBa0MsY0FBYztBQUFBLFFBRTFDLFdBQVc7QUFDYixhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixXQUFXO0FBQ2IsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBLFFBR2YsZUFBZTtBQUNqQixhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixlQUFlO0FBQ2pCLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUdyQixzQkFBb0IsT0FBTztBQUUzQix3Q0FBZ0MsY0FBYztBQUFBLFFBRXhDLFdBQVc7QUFDYixhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixXQUFXO0FBQ2IsYUFBTyxLQUFLLEtBQUs7QUFBQTtBQUFBLFFBR2YsZUFBZTtBQUNqQixhQUFPLEtBQUssS0FBSztBQUFBO0FBQUEsUUFHZixlQUFlO0FBQ2pCLGFBQU8sS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUdyQixvQkFBa0IsT0FBTzs7O0FDMUV6QixNQUFNLGVBQWMsT0FBTztBQUMzQixNQUFNLHNCQUFzQixPQUFPO0FBQ25DLE1BQU0sY0FBYSxPQUFPO0FBQzFCLE1BQU0sY0FBYSxPQUFPO0FBRTFCLCtDQUE2QztBQUFBLElBQzNDO0FBQUEsS0FDQztBQUNELFVBQU0sYUFBYSxVQUFVLE9BQU8sWUFBWSxVQUFVLFVBQVUsT0FBTyxNQUFNO0FBQ2pGLFFBQUksVUFBVSxNQUFNO0FBQ2xCLFlBQU0sV0FBVyxVQUFVLEtBQUssWUFBWSxVQUFVLFVBQVUsS0FBSyxNQUFNO0FBQzNFLFlBQU0sY0FBYyxVQUFVLE9BQU8sd0JBQXdCLFVBQVUsUUFBUSxLQUFLO0FBQ3BGLFVBQUksYUFBYTtBQUNmLGVBQU8sVUFBVSxvQkFBb0I7QUFBQSxhQUNoQztBQUNMLGVBQU8sVUFBVSxxQkFBcUI7QUFBQTtBQUFBLFdBRW5DO0FBRUwsYUFBTyxVQUFVO0FBQUE7QUFBQTtBQUlyQixNQUFNLHdCQUF1QjtBQUFBLElBQzNCLG1CQUFtQjtBQUFBO0FBR3JCLCtCQUF1QixVQUFVO0FBQUEsSUFFL0IsWUFBWSxhQUFhLElBQUksVUFBVSxJQUFJO0FBQ3pDLFlBQU0sWUFBWSxpQ0FDYixVQURhO0FBQUEsUUFFaEIsZUFBZSxrQ0FDVix3QkFDQyxRQUFRLGlCQUFpQjtBQUFBO0FBSWpDLFdBQUssYUFBYTtBQUVsQixXQUFLLGlCQUFpQjtBQUN0QixXQUFLLGdCQUFlLEtBQUssY0FBYSxLQUFLO0FBQzNDLFdBQUssdUJBQXVCLEtBQUsscUJBQXFCLEtBQUs7QUFDM0QsV0FBSyxlQUFjLEtBQUssYUFBWSxLQUFLO0FBQ3pDLFdBQUssZUFBYyxLQUFLLGFBQVksS0FBSztBQUN6QyxXQUFLLEdBQUcsY0FBYyxLQUFLLGVBQWMsR0FBRyx1QkFBdUIsS0FBSyxzQkFBc0IsR0FBRyxhQUFhLEtBQUssY0FBYSxHQUFHLGFBQWEsS0FBSztBQUFBO0FBQUEsSUFHdkosVUFBVTtBQUNSLFlBQU07QUFDTixXQUFLLElBQUksY0FBYyxLQUFLLGVBQWMsSUFBSSx1QkFBdUIsS0FBSyxzQkFBc0IsSUFBSSxhQUFhLEtBQUssY0FBYSxJQUFJLGFBQWEsS0FBSztBQUFBO0FBQUEsSUFHM0osTUFBTSxTQUFTO0FBQ2IsYUFBTyxLQUFLLGdDQUFnQyxRQUFRLFlBQVksUUFBUTtBQUFBO0FBQUEsSUFHMUUsZ0NBQWdDLFdBQVc7QUFDekMsWUFBTSxzQkFBc0IsVUFBVSxpQkFBaUIsS0FBSyxRQUFRO0FBQ3BFLGFBQU8sQ0FBQyxHQUFHLHFCQUFxQixPQUFPLGtCQUFnQjtBQUNyRCxlQUFPLGlCQUFpQixLQUFLLGtCQUFrQixpQkFBaUIsS0FBSyxVQUFVLGFBQWEsZUFBZTtBQUFBO0FBQUE7QUFBQSxLQUk5RyxjQUFhLE9BQU87QUFDbkIsV0FBSyxpQkFBaUIsTUFBTSxPQUFPO0FBQ25DLFdBQUssYUFBYSxLQUFLLE1BQU0sTUFBTTtBQUNuQyxZQUFNLHFCQUFxQixJQUFJLG1CQUFtQjtBQUFBLFFBQ2hELFdBQVc7QUFBQSxRQUNYLFlBQVksS0FBSztBQUFBLFFBQ2pCLGdCQUFnQixLQUFLO0FBQUE7QUFFdkIsV0FBSyxRQUFRO0FBQ2IsVUFBSSxtQkFBbUIsWUFBWTtBQUNqQyxjQUFNO0FBQUE7QUFBQTtBQUFBLEtBSVQscUJBQXFCLE9BQU87QUFDM0IsVUFBSSxNQUFNLFlBQVk7QUFDcEI7QUFBQTtBQUVGLFlBQU07QUFBQSxRQUNKO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxVQUNFO0FBQ0osWUFBTSxXQUFXLEtBQUssTUFBTTtBQUM1QixZQUFNLG9CQUFvQixJQUFJLGtCQUFrQjtBQUFBLFFBQzlDLFdBQVc7QUFBQSxRQUNYLGNBQWM7QUFBQSxRQUNkO0FBQUEsUUFDQTtBQUFBO0FBRUYsV0FBSyxRQUFRO0FBQ2IsVUFBSSxrQkFBa0IsWUFBWTtBQUNoQztBQUFBO0FBRUYsWUFBTSxXQUFXLEtBQUssZ0NBQWdDO0FBQ3RELFlBQU0sUUFBUSxLQUFLO0FBQUEsUUFDakI7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQTtBQUVGLFVBQUksQ0FBQyxPQUFPO0FBQ1Y7QUFBQTtBQUVGLFlBQU07QUFBQSxRQUNKO0FBQUEsUUFDQTtBQUFBLFVBQ0U7QUFDSixZQUFNLFdBQVcsS0FBSyxNQUFNLE1BQU07QUFDbEMsWUFBTSxzQkFBc0IsSUFBSSxvQkFBb0I7QUFBQSxRQUNsRCxXQUFXO0FBQUEsUUFDWDtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBO0FBRUYsV0FBSyxRQUFRO0FBQUE7QUFBQSxLQUdkLGFBQVksT0FBTztBQUNsQixVQUFJLE1BQU0sU0FBUyxNQUFNLGtCQUFrQixNQUFNLFNBQVMsTUFBTSxRQUFRO0FBQ3RFO0FBQUE7QUFFRixZQUFNO0FBQUEsUUFDSjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsVUFDRTtBQUNKLFlBQU0sV0FBVyxLQUFLLE1BQU07QUFDNUIsWUFBTSxvQkFBb0IsSUFBSSxrQkFBa0I7QUFBQSxRQUM5QyxXQUFXO0FBQUEsUUFDWCxjQUFjO0FBQUEsUUFDZDtBQUFBLFFBQ0E7QUFBQTtBQUVGLFdBQUssUUFBUTtBQUNiLFVBQUksa0JBQWtCLFlBQVk7QUFDaEM7QUFBQTtBQUVGLFlBQU0sV0FBVyxLQUFLLGlDQUFpQztBQUN2RCxZQUFNLFFBQVEsS0FBSztBQUFBLFFBQ2pCO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUE7QUFFRixVQUFJLENBQUMsT0FBTztBQUNWO0FBQUE7QUFFRixZQUFNO0FBQUEsUUFDSjtBQUFBLFFBQ0E7QUFBQSxVQUNFO0FBQ0osWUFBTSxXQUFXLEtBQUssTUFBTTtBQUM1QixZQUFNLHNCQUFzQixJQUFJLG9CQUFvQjtBQUFBLFFBQ2xELFdBQVc7QUFBQSxRQUNYO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUE7QUFFRixXQUFLLFFBQVE7QUFBQTtBQUFBLEtBR2QsYUFBWSxPQUFPO0FBQ2xCLFlBQU0sb0JBQW9CLElBQUksa0JBQWtCO0FBQUEsUUFDOUMsV0FBVztBQUFBLFFBQ1gsVUFBVSxLQUFLO0FBQUEsUUFDZixVQUFVLEtBQUssTUFBTSxNQUFNO0FBQUEsUUFDM0IsY0FBYyxLQUFLO0FBQUEsUUFDbkIsY0FBYyxNQUFNLE9BQU87QUFBQTtBQUU3QixXQUFLLFFBQVE7QUFDYixXQUFLLGFBQWE7QUFDbEIsV0FBSyxpQkFBaUI7QUFBQTtBQUFBO0FBRzFCLGlCQUFlLFNBQVM7QUFDdEIsV0FBTyxNQUFNLFVBQVUsUUFBUSxLQUFLLFFBQVEsV0FBVyxVQUFVO0FBQUE7QUFFbkUsZ0JBQWM7QUFBQSxJQUNaO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsS0FDQztBQUNELFVBQU0scUJBQXFCLENBQUMsU0FBUztBQUNyQyxVQUFNLHFCQUFxQixPQUFPLGVBQWU7QUFDakQsVUFBTSxnQkFBZ0IsUUFBUSxPQUFPLGVBQWUsS0FBSztBQUN6RCxRQUFJLG9CQUFvQjtBQUN0QixhQUFPLHlCQUF5QixRQUFRO0FBQUEsZUFDL0IsZUFBZTtBQUN4QixhQUFPLG9CQUFvQixRQUFRO0FBQUEsZUFDMUIsb0JBQW9CO0FBQzdCLGFBQU8scUJBQXFCLFFBQVEsTUFBTTtBQUFBLFdBQ3JDO0FBQ0wsYUFBTztBQUFBO0FBQUE7QUFHWCxvQ0FBa0MsUUFBUSxlQUFlO0FBQ3ZELFVBQU0sZUFBZSxPQUFPO0FBQzVCLGtCQUFjLFlBQVk7QUFDMUIsV0FBTztBQUFBLE1BQ0w7QUFBQSxNQUNBLGNBQWM7QUFBQTtBQUFBO0FBR2xCLCtCQUE2QixRQUFRLE1BQU07QUFDekMsVUFBTSxXQUFXLE1BQU07QUFDdkIsVUFBTSxXQUFXLE1BQU07QUFDdkIsUUFBSSxXQUFXLFVBQVU7QUFDdkIsYUFBTyxXQUFXLGFBQWEsUUFBUSxLQUFLO0FBQUEsV0FDdkM7QUFDTCxhQUFPLFdBQVcsYUFBYSxRQUFRO0FBQUE7QUFFekMsV0FBTztBQUFBLE1BQ0wsY0FBYyxPQUFPO0FBQUEsTUFDckIsY0FBYyxPQUFPO0FBQUE7QUFBQTtBQUd6QixnQ0FBOEIsUUFBUSxNQUFNLGVBQWU7QUFDekQsVUFBTSxlQUFlLE9BQU87QUFDNUIsUUFBSSxNQUFNO0FBQ1IsV0FBSyxXQUFXLGFBQWEsUUFBUTtBQUFBLFdBQ2hDO0FBRUwsb0JBQWMsWUFBWTtBQUFBO0FBRTVCLFdBQU87QUFBQSxNQUNMO0FBQUEsTUFDQSxjQUFjLE9BQU87QUFBQTtBQUFBOzs7QWpFMUl6QixzQkFBbUI7OztBa0V6R25CLHFCQUFrQjtBQUNsQix5Q0FBNEI7OztBQ0Q1QixHQUFDLFNBQVMsR0FBRTtBQUFDLElBQVksT0FBTyxVQUFuQixjQUEyQixPQUFPLE1BQUksT0FBTyxLQUFHO0FBQUEsSUFBTSxXQUFVO0FBQUM7QUFDOUUsQUFPSyxLQUFDLFdBQVU7QUFBQyxVQUFHLEFBQWEsT0FBTyxTQUFwQjtBQUEwQixlQUFPLEtBQUssUUFBUSxNQUFNO0FBQTZCLFlBQU0sSUFBRSxNQUFNO0FBQVEsTUFBWSxPQUFPLE9BQU8sVUFBMUIsY0FBbUMsUUFBTyxTQUFPLFNBQVMsSUFBRTtBQUFDLFlBQUcsQ0FBQztBQUFFLGdCQUFNLElBQUksVUFBVTtBQUE4QyxjQUFNLEtBQUUsT0FBTztBQUFHLGlCQUFRLEtBQUUsR0FBRSxLQUFFLFVBQVUsUUFBTyxNQUFJO0FBQUMsZ0JBQU0sS0FBRSxVQUFVO0FBQUcsY0FBRztBQUFFLHVCQUFVLE1BQUs7QUFBRSxxQkFBTyxVQUFVLGVBQWUsS0FBSyxJQUFFLE9BQUssSUFBRSxNQUFHLEdBQUU7QUFBQTtBQUFJLGVBQU87QUFBQTtBQUFJLFlBQU0sSUFBRTtBQUFHLG1CQUFZO0FBQUMsYUFBSyxrQkFBZ0IsS0FBSyxnQkFBZ0IsS0FBSztBQUFBO0FBQU0saUJBQVcsSUFBRTtBQUFDLGNBQU0sS0FBRSxHQUFFLFNBQVMsTUFBTSxPQUFPO0FBQVEsZUFBTSxDQUFFLEVBQUMsR0FBRSxXQUFTLENBQUMsR0FBRSxRQUFRLFlBQVUsQ0FBQyxDQUFDLEdBQUUsUUFBUSxRQUFRO0FBQUE7QUFBTyxPQUFDLE9BQU0sWUFBVyxhQUFZLE9BQU8sUUFBUyxTQUFTLElBQUU7QUFBQyxVQUFFLE1BQUc7QUFBQSxVQUFNLEVBQUUsVUFBVSxRQUFNLFNBQVMsSUFBRSxJQUFFO0FBQUMsYUFBSyxRQUFNLElBQUUsS0FBSyxNQUFJLEdBQUUsS0FBSSxLQUFLLE9BQUssSUFBRyxLQUFLLFdBQVM7QUFBRyxjQUFNLEtBQUUsR0FBRSxPQUFPO0FBQVEsYUFBSyxVQUFRLE9BQU8sT0FBTyxFQUFDLFVBQVMsV0FBVSxXQUFVLEdBQUUsVUFBUyxHQUFFLE9BQUssR0FBRSxLQUFLLE9BQUssSUFBRyxXQUFVLEdBQUUsU0FBTyxXQUFVLFdBQVUsR0FBRSxPQUFLLEdBQUUsS0FBSyxRQUFNLFVBQVMsWUFBVyxHQUFFLE9BQUssR0FBRSxLQUFLLFNBQU8sc0RBQXFELGVBQWMsR0FBRSxlQUFjLEdBQUUsYUFBWSxtQkFBa0IsWUFBVyxHQUFFLFFBQU8sSUFBRyxnQkFBZSxHQUFFLFlBQVcsR0FBRSxTQUFRLFFBQUksS0FBRyxBQUFRLEdBQUUsT0FBTyxTQUFqQixTQUF3QixNQUFLLFFBQVEsV0FBUyxXQUFVLEtBQUssUUFBUSxNQUFJLE9BQUcsS0FBSyxRQUFRLFVBQVE7QUFBQSxTQUFLLEVBQUUsVUFBVSxTQUFPLFdBQVU7QUFBQyxhQUFLLGNBQVksSUFBRyxLQUFLLE1BQU0sS0FBSyxTQUFTLFFBQVEsS0FBSztBQUFBLFNBQWtCLEVBQUUsVUFBVSxrQkFBZ0IsU0FBUyxJQUFFLElBQUU7QUFBQyxhQUFLLGtCQUFnQixHQUFFLEtBQUssUUFBTTtBQUFLLGNBQU0sS0FBRSxLQUFLLEtBQUs7QUFBRyxXQUFFLEtBQUssS0FBSyxRQUFRLFNBQVMsSUFBRSxJQUFFO0FBQUMsZUFBSyxnQkFBZ0IsSUFBRSxJQUFFLElBQUU7QUFBQSxVQUFJLEtBQUs7QUFBQSxTQUFRLEVBQUUsVUFBVSxrQkFBZ0IsU0FBUyxJQUFFLElBQUUsSUFBRSxHQUFFO0FBQUMsWUFBRyxDQUFDLEtBQUssc0JBQXNCLEdBQUUsTUFBSztBQUFHO0FBQU8sYUFBSyxhQUFXO0FBQUssY0FBTSxJQUFFLEtBQUssU0FBUyxJQUFFLElBQUU7QUFBRyxZQUFHLENBQUM7QUFBRTtBQUFPLGNBQU0sSUFBRSxLQUFLO0FBQUksVUFBRSxRQUFPLEVBQUUsT0FBSyxFQUFFLFdBQVcsS0FBSyxRQUFRLFVBQVMsS0FBSyxRQUFRLFdBQVUsS0FBSyxRQUFRO0FBQVksY0FBTSxJQUFFLEtBQUssY0FBYyxJQUFFO0FBQUcsYUFBSyxTQUFTLElBQUUsR0FBRSxLQUFJLEdBQUUsYUFBWSxFQUFFLFlBQVUsS0FBSyxhQUFhLElBQUUsSUFBRSxJQUFHLEtBQUssWUFBWSxHQUFFLElBQUcsRUFBRSxhQUFXLEVBQUU7QUFBQSxTQUFXLEVBQUUsVUFBVSxjQUFZLFNBQVMsSUFBRSxJQUFFO0FBQUMsZUFBTyxLQUFLLFFBQVEsTUFBSSxLQUFLLGVBQWUsSUFBRSxNQUFHLEtBQUssZ0JBQWdCLElBQUU7QUFBQSxTQUFJLEVBQUUsVUFBVSxrQkFBZ0IsU0FBUyxJQUFFLElBQUU7QUFBQyxjQUFNLEtBQUUsS0FBSztBQUFJLFlBQUcsQUFBVSxPQUFPLE1BQWpCO0FBQW1CLGFBQUUsVUFBVSxJQUFFLEdBQUUsSUFBRSxHQUFFLFFBQU0sR0FBRSxHQUFFLElBQUUsR0FBRSxTQUFPLEdBQUUsR0FBRSxPQUFNLEdBQUU7QUFBQSxhQUFZO0FBQUMsYUFBRSxRQUFPLEdBQUUsZUFBYSxPQUFNLEdBQUUsWUFBVSxVQUFTLEtBQUssUUFBUSxjQUFhLElBQUUsZ0JBQWMsS0FBSyxRQUFRLGVBQWMsR0FBRSxnQkFBYyxLQUFLLFFBQVEsZUFBYyxHQUFFLGNBQVksS0FBSyxRQUFRLGFBQVksR0FBRSxhQUFXLEtBQUssUUFBUTtBQUFZLGdCQUFNLEtBQUUsR0FBRSxNQUFNO0FBQU0sbUJBQVEsS0FBRSxHQUFFLEtBQUUsR0FBRSxRQUFPLE1BQUk7QUFBQyxrQkFBTSxJQUFFLEdBQUUsSUFBRSxLQUFLLFFBQVEsV0FBUyxJQUFFLEdBQUUsU0FBTyxLQUFLLFFBQVEsV0FBUztBQUFFLGVBQUUsU0FBUyxHQUFFLEtBQUcsR0FBRSxHQUFFO0FBQUE7QUFBRyxhQUFFO0FBQUE7QUFBQSxTQUFZLEVBQUUsVUFBVSxpQkFBZSxTQUFTLElBQUUsSUFBRTtBQUFDLGNBQU0sS0FBRSxLQUFLLEtBQUksS0FBRSxHQUFFLFFBQU8sSUFBRSxHQUFFO0FBQUssWUFBRyxHQUFFLFFBQU8sR0FBRSxVQUFVLEVBQUUsR0FBRSxFQUFFLElBQUcsQUFBVSxPQUFPLE1BQWpCLFVBQW1CO0FBQUMsYUFBRSxPQUFPLEdBQUUsYUFBWSxHQUFFLGVBQWEsVUFBUyxHQUFFLFlBQVU7QUFBTyxnQkFBTSxLQUFFLEdBQUUsTUFBTTtBQUFNLGNBQUksSUFBRTtBQUFFLGdCQUFNLElBQUU7QUFBRyxjQUFJLEdBQUUsSUFBRTtBQUFFLFVBQVcsS0FBSyxRQUFRLGFBQXhCLFlBQW1DLEtBQUcsSUFBRSxTQUFPLEtBQUcsS0FBSyxRQUFRLFdBQVM7QUFBRyxtQkFBUSxLQUFFLEdBQUUsS0FBRSxHQUFFLFFBQU8sRUFBRTtBQUFFLGdCQUFFLEdBQUUsWUFBWSxHQUFFLE1BQUksRUFBRSxRQUFNLEtBQUksS0FBRSxFQUFFLFFBQU8sRUFBRSxLQUFLLEVBQUU7QUFBTyxtQkFBUSxLQUFFLEdBQUUsS0FBRSxHQUFFLFFBQU8sRUFBRSxJQUFFO0FBQUMsa0JBQU0sS0FBRSxHQUFFLEtBQUcsSUFBRyxJQUFFLFNBQU8sSUFBRSxNQUFHLENBQUMsS0FBSyxRQUFRLFdBQVM7QUFBRSxlQUFFO0FBQU8sa0JBQU0sSUFBRyxLQUFFLEVBQUUsT0FBSTtBQUFFLGVBQUUsT0FBTyxJQUFFO0FBQUcscUJBQVEsS0FBRSxHQUFFLEtBQUUsR0FBRSxRQUFPLE1BQUk7QUFBQyxvQkFBTSxLQUFFLEdBQUUsT0FBTztBQUFHLGtCQUFFLEdBQUUsWUFBWSxLQUFHLEdBQUUsUUFBTyxHQUFFLFVBQVUsR0FBRSxLQUFHLEtBQUcsR0FBRSxTQUFTLElBQUUsR0FBRSxJQUFHLEdBQUUsV0FBVSxHQUFFLE9BQU8sRUFBRSxRQUFNO0FBQUE7QUFBRyxlQUFFO0FBQUE7QUFBQTtBQUFnQixhQUFFLE9BQVEsR0FBRSxhQUFXLEtBQUssS0FBRyxJQUFFLEdBQUUsWUFBVSxJQUFHLEdBQUUsVUFBVSxHQUFFLEtBQUcsS0FBRyxLQUFLLFlBQVksSUFBRSxFQUFDLEdBQUUsR0FBRSxHQUFFO0FBQUksV0FBRTtBQUFBLFNBQVcsRUFBRSxVQUFVLHdCQUFzQixTQUFTLElBQUUsSUFBRTtBQUFDLGVBQU0sQ0FBQyxHQUFFLFVBQVMsTUFBSyxRQUFRLFlBQVUsQUFBYyxLQUFLLE1BQU0sT0FBTyxTQUFoQyxjQUFxQyxBQUFJLEdBQUUsZ0JBQU4sSUFBa0IsQUFBSSxHQUFFLGtCQUFOO0FBQUEsU0FBc0IsRUFBRSxVQUFVLFdBQVMsU0FBUyxJQUFFLElBQUUsSUFBRTtBQUFDLFlBQUk7QUFBRSxZQUFHLEFBQVksT0FBTyxLQUFLLFFBQVEsVUFBaEM7QUFBdUMsZUFBRSxLQUFLLFFBQVEsT0FBTyxFQUFDLE9BQU0sS0FBSyxNQUFNLE9BQU8sS0FBSyxPQUFPLEtBQUcsT0FBTSxHQUFFLEtBQUssS0FBRyxZQUFXLEtBQUssY0FBYyxJQUFFLElBQUUsS0FBRyxTQUFRLElBQUUsT0FBTTtBQUFBO0FBQVMsa0JBQU8sS0FBSyxRQUFRO0FBQUEsaUJBQVk7QUFBUSxtQkFBRSxHQUFFLEtBQUs7QUFBRztBQUFBLGlCQUFVO0FBQVEsbUJBQUUsS0FBSyxNQUFNLE9BQU8sS0FBSyxPQUFPO0FBQUc7QUFBQSxpQkFBVTtBQUFRLG1CQUFFLEtBQUssUUFBUSxPQUFPLE1BQUcsS0FBSyxVQUFVLEtBQUssUUFBUSxPQUFPLE9BQUk7QUFBRztBQUFBO0FBQWMsbUJBQUUsS0FBSyxjQUFjLElBQUUsSUFBRSxNQUFHO0FBQUE7QUFBSSxlQUFNLEFBQVUsT0FBTyxNQUFqQixXQUFtQixLQUFFLEtBQUssVUFBVSxNQUFHLE1BQUksTUFBRSxHQUFFLGFBQVk7QUFBQSxTQUFHLEVBQUUsVUFBVSxlQUFhLFNBQVMsSUFBRSxJQUFFLElBQUU7QUFBQyxZQUFJLEtBQUUsS0FBSyxRQUFRO0FBQVUsZUFBTSxBQUFZLE9BQU8sTUFBbkIsYUFBcUIsS0FBRSxHQUFFLEVBQUMsT0FBTSxLQUFLLE1BQU0sT0FBTyxLQUFLLE9BQU8sS0FBRyxPQUFNLEdBQUUsS0FBSyxLQUFHLFlBQVcsS0FBSyxjQUFjLElBQUUsSUFBRSxLQUFHLGlCQUFnQixHQUFFLGdCQUFnQixLQUFHLFNBQVEsSUFBRSxPQUFNLFFBQUksQUFBVSxPQUFPLE1BQWpCLFlBQXFCLE1BQUUsR0FBRSxPQUFJLEtBQUssTUFBTSxPQUFPLFFBQVEsUUFBTztBQUFBLFNBQUcsRUFBRSxVQUFVLGdCQUFjLFNBQVMsSUFBRSxJQUFFLElBQUU7QUFBQyxZQUFHLEtBQUs7QUFBVyxpQkFBTyxLQUFLO0FBQVcsWUFBSTtBQUFFLFlBQUcsQUFBYyxLQUFLLE1BQU0sT0FBTyxTQUFoQyxlQUFzQyxBQUFhLEtBQUssTUFBTSxPQUFPLFNBQS9CLGNBQXFDLEFBQVEsS0FBSyxNQUFNLE9BQU8sU0FBMUIsT0FBK0I7QUFBQyxjQUFHLENBQUMsS0FBSyxPQUFNO0FBQUMsaUJBQUssUUFBTTtBQUFFLHFCQUFRLEtBQUUsR0FBRSxLQUFFLEdBQUUsS0FBSyxRQUFPLEVBQUU7QUFBRSxtQkFBSyxTQUFPLEdBQUUsS0FBSztBQUFBO0FBQUcsZUFBRSxHQUFFLEtBQUssTUFBRyxLQUFLLFFBQU07QUFBQSxtQkFBWSxBQUFRLEtBQUssTUFBTSxPQUFPLFNBQTFCLE9BQStCO0FBQUMsY0FBRyxDQUFDLEtBQUssU0FBUyxLQUFHO0FBQUMsaUJBQUssU0FBUyxNQUFHO0FBQUUscUJBQVEsS0FBRSxHQUFFLEtBQUUsS0FBSyxNQUFNLEtBQUssU0FBUyxRQUFPLEVBQUU7QUFBRSxtQkFBSyxTQUFTLE9BQUksS0FBSyxNQUFNLEtBQUssU0FBUyxJQUFHLEtBQUs7QUFBQTtBQUFHLGVBQUUsR0FBRSxLQUFLLE1BQUcsS0FBSyxTQUFTLE1BQUc7QUFBQTtBQUFTLGVBQUUsR0FBRSxnQkFBYyxLQUFLLE1BQU0sT0FBTyxRQUFRLGdCQUFjO0FBQUksZUFBTyxLQUFFLFdBQVcsR0FBRSxRQUFRLEtBQUssUUFBUSxhQUFZLEtBQUssUUFBUSx5QkFBd0IsQ0FBUSxLQUFLLE1BQU0sT0FBTyxTQUExQixTQUFpQyxNQUFLLGtCQUFnQixLQUFLLG1CQUFtQixPQUFJLElBQUcsS0FBSyxtQkFBaUIsSUFBRSxLQUFLLGtCQUFnQixPQUFNLE9BQUcsS0FBSyxrQkFBZ0IsS0FBSSxLQUFFLFdBQVcsR0FBRSxRQUFRLEtBQUssUUFBUSxjQUFhLEFBQVEsS0FBSyxNQUFNLE9BQU8sU0FBMUIsU0FBaUMsTUFBSyxtQkFBbUIsTUFBRyxLQUFLLG1CQUFrQixLQUFLLGFBQVcsSUFBRTtBQUFBLFNBQUcsRUFBRSxVQUFVLGdCQUFjLFNBQVMsSUFBRSxJQUFFO0FBQUMsZUFBTSxBQUFRLEtBQUssTUFBTSxPQUFPLFNBQTFCLFFBQStCLEtBQUssaUJBQWlCLElBQUUsTUFBRyxLQUFLLFFBQVEsTUFBSSxLQUFLLGlCQUFpQixJQUFFLE1BQUcsS0FBSyxrQkFBa0IsSUFBRTtBQUFBLFNBQUksRUFBRSxVQUFVLG9CQUFrQixTQUFTLElBQUUsSUFBRTtBQUFDLFlBQUcsQUFBWSxLQUFLLFFBQVEsYUFBekIsYUFBbUMsQUFBVyxLQUFLLFFBQVEsYUFBeEIsVUFBaUM7QUFBQyxjQUFJLElBQUUsS0FBRTtBQUFHLGdCQUFNLElBQUUsSUFBRSxJQUFFLEVBQUUsYUFBWSxHQUFFLFdBQVMsRUFBRSxjQUFZLEdBQUUsSUFBRSxFQUFFLGNBQVk7QUFBRSxjQUFHLEFBQVcsS0FBSyxRQUFRLGFBQXhCLFdBQWlDLEtBQUcsR0FBRSxjQUFZLEtBQUcsSUFBRSxJQUFFLEFBQVksS0FBSyxRQUFRLGFBQXpCLGFBQW9DLE1BQUUsRUFBRSxjQUFZLElBQUUsSUFBRSxLQUFLLFFBQVEsYUFBWSxLQUFFLEVBQUMsR0FBRSxFQUFFLElBQUUsS0FBSyxJQUFJLEtBQUcsSUFBRSxHQUFFLEVBQUUsSUFBRSxLQUFLLElBQUksS0FBRyxNQUFHLEFBQVksS0FBSyxRQUFRLGFBQXpCLFdBQWtDO0FBQUMsa0JBQU0sS0FBRSxLQUFLLFFBQVEsYUFBVyxLQUFLLGFBQWEsSUFBRyxRQUFNO0FBQUUsZUFBRSxLQUFHLEdBQUUsSUFBRSxFQUFFLElBQUUsQ0FBQyxLQUFFO0FBQUE7QUFBRSxpQkFBTztBQUFBO0FBQUUsZUFBTyxHQUFFO0FBQUEsU0FBbUIsRUFBRSxVQUFVLG1CQUFpQixTQUFTLElBQUUsSUFBRTtBQUFDLFlBQUk7QUFBRSxjQUFNLEtBQUU7QUFBRSxhQUFFLEFBQVksS0FBSyxRQUFRLGFBQXpCLFlBQWtDLEdBQUUsY0FBWSxLQUFLLFFBQVEsV0FBUyxLQUFLLFFBQVEsYUFBVyxBQUFXLEtBQUssUUFBUSxhQUF4QixXQUFrQyxJQUFFLGNBQVksSUFBRSxHQUFFLGVBQWEsSUFBRyxJQUFFLGNBQVksR0FBRSxlQUFhO0FBQUUsWUFBSSxJQUFFLEdBQUUsWUFBVyxJQUFFLEdBQUU7QUFBUyxjQUFNLElBQUUsSUFBRTtBQUFFLGFBQUcsS0FBSyxLQUFHLEdBQUUsS0FBRyxLQUFLLEtBQUc7QUFBRSxlQUFPLEtBQUksS0FBRyxNQUFLLGFBQWEsSUFBRyxRQUFNLEtBQUUsTUFBSSxHQUFFLEVBQUMsUUFBTyxJQUFFLFlBQVcsR0FBRSxVQUFTLEdBQUUsWUFBVyxHQUFFLE1BQUs7QUFBQSxTQUFJLEVBQUUsVUFBVSxtQkFBaUIsU0FBUyxJQUFFLElBQUU7QUFBQyxjQUFNLEtBQUUsR0FBRTtBQUFrQixlQUFPLEdBQUUsS0FBRyxLQUFLLGFBQWEsSUFBRyxTQUFPLElBQUUsS0FBSyxRQUFRLFlBQVc7QUFBQSxTQUFHLEVBQUUsVUFBVSxXQUFTLFNBQVMsSUFBRSxJQUFFLElBQUU7QUFBQyxZQUFHLEtBQUssUUFBUTtBQUFRLGlCQUFNO0FBQUcsWUFBRyxLQUFLLFFBQVE7QUFBSSxpQkFBTyxHQUFFLFdBQVMsR0FBRSxjQUFZLEdBQUU7QUFBVztBQUFDLGdCQUFNLEtBQUUsS0FBSyxhQUFhLEtBQUcsSUFBRSxHQUFFLElBQUUsR0FBRSxRQUFNLEdBQUUsSUFBRSxHQUFFLElBQUUsR0FBRSxRQUFNLEdBQUUsSUFBRSxHQUFFLElBQUUsR0FBRSxTQUFPLEdBQUUsSUFBRSxHQUFFLElBQUUsR0FBRSxTQUFPO0FBQUUsaUJBQU0sQUFBWSxLQUFLLFFBQVEsYUFBekIsWUFBa0MsS0FBSyxlQUFlLEdBQUUsR0FBRSxHQUFFLEtBQUcsR0FBRSxRQUFRLEdBQUUsTUFBSSxHQUFFLFFBQVEsR0FBRSxNQUFJLEdBQUUsUUFBUSxHQUFFLE1BQUksR0FBRSxRQUFRLEdBQUU7QUFBQTtBQUFBLFNBQUssRUFBRSxVQUFVLGlCQUFlLFNBQVMsSUFBRSxJQUFFLElBQUUsSUFBRTtBQUFDLGNBQU0sSUFBRSxLQUFLO0FBQVksaUJBQVEsSUFBRSxHQUFFLElBQUUsRUFBRSxRQUFPLEVBQUUsR0FBRTtBQUFDLGdCQUFNLElBQUUsRUFBRTtBQUFHLGNBQUksSUFBRSxDQUFDLENBQUMsSUFBRSxLQUFHLENBQUMsSUFBRSxLQUFHLENBQUMsSUFBRSxLQUFHLENBQUMsSUFBRTtBQUFJLG1CQUFRLEtBQUUsR0FBRSxLQUFFLEVBQUUsUUFBTyxFQUFFLElBQUU7QUFBQyxrQkFBTSxLQUFFLEVBQUUsSUFBRyxJQUFHLEtBQUUsRUFBRSxJQUFHO0FBQUcsZ0JBQUcsTUFBRyxFQUFFLFFBQU0sTUFBRyxFQUFFLFNBQU8sTUFBRyxFQUFFLE9BQUssTUFBRyxFQUFFO0FBQU8scUJBQU07QUFBQTtBQUFHLGNBQUUsQ0FBQyxDQUFDLEVBQUUsTUFBSyxFQUFFLE1BQUssQ0FBQyxFQUFFLE1BQUssRUFBRSxTQUFRLENBQUMsRUFBRSxPQUFNLEVBQUUsTUFBSyxDQUFDLEVBQUUsT0FBTSxFQUFFO0FBQVMsbUJBQVEsS0FBRSxHQUFFLEtBQUUsRUFBRSxRQUFPLEVBQUUsSUFBRTtBQUFDLGtCQUFNLEtBQUUsRUFBRSxJQUFHLElBQUcsS0FBRSxFQUFFLElBQUc7QUFBRyxnQkFBRyxNQUFHLE1BQUcsTUFBRyxNQUFHLE1BQUcsTUFBRyxNQUFHO0FBQUUscUJBQU07QUFBQTtBQUFBO0FBQUksZUFBTyxFQUFFLEtBQUssRUFBQyxNQUFLLElBQUUsT0FBTSxJQUFFLEtBQUksSUFBRSxRQUFPLE9BQUk7QUFBQSxTQUFJLEVBQUUsVUFBVSxlQUFhLFNBQVMsSUFBRTtBQUFDLFlBQUcsQUFBVSxPQUFPLE1BQWpCO0FBQW1CLGlCQUFNLEVBQUMsT0FBTSxHQUFFLE9BQU0sUUFBTyxHQUFFO0FBQVE7QUFBQyxjQUFJLEtBQUU7QUFBRSxnQkFBTSxLQUFFLEdBQUUsTUFBTTtBQUFNLG1CQUFRLEtBQUUsR0FBRSxLQUFFLEdBQUUsUUFBTyxFQUFFLElBQUU7QUFBQyxrQkFBTSxLQUFFLEtBQUssSUFBSSxZQUFZLEdBQUU7QUFBSSxlQUFFLFFBQU0sTUFBSSxNQUFFLEdBQUU7QUFBQTtBQUFPLGlCQUFNLEVBQUMsT0FBTSxJQUFFLFFBQU8sS0FBSyxRQUFRLFdBQVMsR0FBRTtBQUFBO0FBQUEsU0FBVSxFQUFFLFVBQVUsWUFBVSxTQUFTLElBQUU7QUFBQyxjQUFNLEtBQUUsSUFBSTtBQUFNLGVBQU8sR0FBRSxNQUFJLEdBQUUsS0FBSSxHQUFFLFFBQU0sR0FBRSxPQUFNLEdBQUUsU0FBTyxHQUFFLFFBQU87QUFBQSxTQUFHLE1BQU0sU0FBUyxFQUFDLElBQUcsVUFBUyxzQkFBcUIsU0FBUyxJQUFFLEdBQUUsR0FBRTtBQUFDLFlBQUcsQ0FBQyxFQUFFLEdBQUUsT0FBTyxTQUFPLENBQUMsRUFBRTtBQUFHO0FBQU8sVUFBRSxVQUFTLEtBQUUsQ0FBQztBQUFJLGNBQU0sSUFBRSxFQUFFO0FBQU8sV0FBRSxXQUFTLE1BQUksR0FBRSxRQUFRLFVBQVMsSUFBRSxVQUFRLEVBQUUsSUFBSyxXQUFVO0FBQUMsaUJBQU8sSUFBSTtBQUFBO0FBQU0sWUFBSSxJQUFFLE9BQUcsSUFBRTtBQUFFLGlCQUFRLEtBQUUsR0FBRSxLQUFFLEdBQUUsRUFBRSxJQUFFO0FBQUMsZ0JBQU0sS0FBRSxHQUFFLFFBQVE7QUFBRyxjQUFHLEdBQUUsTUFBTSxJQUFFLEVBQUUsTUFBSSxBQUFZLEdBQUUsUUFBUSxhQUF0QixXQUErQjtBQUFDLGdCQUFFO0FBQUcsa0JBQU0sS0FBRSxNQUFJLEdBQUUsUUFBUSxXQUFTLEdBQUUsUUFBUTtBQUFlLGlCQUFFLEtBQUksS0FBRTtBQUFBO0FBQUE7QUFBSSxhQUFJLElBQUUsVUFBVSxPQUFLLEdBQUUsR0FBRSxVQUFVLFVBQVE7QUFBQSxTQUFJLG9CQUFtQixTQUFTLElBQUUsSUFBRSxHQUFFO0FBUnB2UTtBQVFxdlEsVUFBRSxHQUFFLE9BQU8sU0FBTyxFQUFFLE1BQUksVUFBRSxZQUFGLG1CQUFXLFFBQVMsU0FBUyxJQUFFO0FBQUMsYUFBRSxLQUFLLEdBQUUsU0FBTztBQUFBO0FBQUEsU0FBTSxZQUFXLFNBQVMsSUFBRSxJQUFFLEdBQUU7QUFSNzFRO0FBUTgxUSxVQUFFLEdBQUUsT0FBTyxTQUFPLEVBQUUsTUFBSSxVQUFFLFlBQUYsbUJBQVcsUUFBUyxTQUFTLElBQUU7QUFBQyxhQUFFLHFCQUFtQjtBQUFBO0FBQUEsU0FBTyxtQkFBa0IsU0FBUyxJQUFFLElBQUUsR0FBRTtBQVJuOVE7QUFRbzlRLFVBQUUsR0FBRSxPQUFPLFNBQU8sRUFBRSxNQUFJLFVBQUUsWUFBRixtQkFBVyxRQUFTLFNBQVMsSUFBRTtBQUFDLGFBQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FESjlnUixNQUFNLFNBQVMsQ0FBQztBQUNoQixNQUFNLFFBQVE7QUFBQSxJQUNaO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQTtBQUdGLE1BQU0sU0FBUztBQUFBLElBQ2I7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQTtBQWtDRixpQ0FBeUI7QUFBQSxJQUN2QixZQUFZLEtBQUssUUFBUSxRQUFRO0FBQy9CLFdBQUssUUFBUSxJQUFJLHFCQUFNLEtBQUs7QUFBQSxRQUMxQixNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsVUFDSjtBQUFBLFVBQ0EsVUFBVTtBQUFBLFlBQ1I7QUFBQSxjQUNFLE1BQU07QUFBQSxjQUNOLE9BQU87QUFBQSxjQUNQLE1BQU07QUFBQSxjQUNOLE1BQU07QUFBQSxjQUNOLGFBQWE7QUFBQSxjQUNiLGlCQUFpQjtBQUFBLGNBQ2pCLGFBQWE7QUFBQSxjQUNiLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUliLFNBQVM7QUFBQSxVQUNQLFdBQVc7QUFBQSxVQUNYLFlBQVk7QUFBQSxVQUNaLFNBQVM7QUFBQSxZQUNQLFFBQVE7QUFBQSxjQUNOLFFBQVE7QUFBQSxjQUNSLFdBQVc7QUFBQSxjQUNYLFVBQVU7QUFBQTtBQUFBLFlBRVosUUFBUTtBQUFBLGNBQ04sVUFBVTtBQUFBO0FBQUEsWUFFWixPQUFPO0FBQUEsY0FDTCxTQUFTO0FBQUEsY0FDVCxNQUFNO0FBQUE7QUFBQSxZQUVSLFlBQVk7QUFBQSxjQUNWLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRbkIsOEJBQXNCO0FBQUEsSUFDcEIsWUFDRSxLQUNBLFlBQ0EsZUFDQSxtQkFDQSxrQkFDQSxnQkFDQTtBQUNBLFdBQUssUUFBUSxJQUFJLHFCQUFNLEtBQUs7QUFBQSxRQUMxQixNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsVUFDSixRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsWUFDUjtBQUFBLGNBQ0UsT0FBTztBQUFBLGNBQ1AsTUFBTTtBQUFBLGNBQ04saUJBQWlCO0FBQUE7QUFBQSxZQUVuQjtBQUFBLGNBQ0UsT0FBTztBQUFBLGNBQ1AsTUFBTTtBQUFBLGNBQ04saUJBQWlCO0FBQUE7QUFBQSxZQUVuQjtBQUFBLGNBQ0UsT0FBTztBQUFBLGNBQ1AsTUFBTTtBQUFBLGNBQ04saUJBQWlCO0FBQUE7QUFBQSxZQUVuQjtBQUFBLGNBQ0UsT0FBTztBQUFBLGNBQ1AsTUFBTTtBQUFBLGNBQ04saUJBQWlCO0FBQUE7QUFBQSxZQUVuQjtBQUFBLGNBQ0UsT0FBTztBQUFBLGNBQ1AsTUFBTTtBQUFBLGNBQ04saUJBQWlCO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFJdkIsU0FBUztBQUFBLFVBQ1AsU0FBUztBQUFBLFlBQ1AsUUFBUTtBQUFBLGNBQ04sUUFBUTtBQUFBLGNBQ1IsV0FBVztBQUFBLGNBQ1gsVUFBVTtBQUFBO0FBQUEsWUFFWixRQUFRO0FBQUEsY0FDTixVQUFVO0FBQUE7QUFBQSxZQUVaLE9BQU87QUFBQSxjQUNMLFNBQVM7QUFBQSxjQUNULE1BQU07QUFBQTtBQUFBO0FBQUEsVUFHVixZQUFZO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF1RnBCLDBCQUFrQjtBQUFBLElBQ2hCLFlBQVksS0FBSyxRQUFRO0FBQ3ZCLFdBQUssUUFBUSxJQUFJLHFCQUFNLEtBQUs7QUFBQSxRQUMxQixNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsVUFDSixRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsWUFDUjtBQUFBLGNBQ0UsTUFBTTtBQUFBLGNBQ04sT0FBTztBQUFBLGNBQ1AsTUFBTTtBQUFBLGNBQ04sTUFBTTtBQUFBLGNBQ04sYUFBYTtBQUFBLGNBQ2IsaUJBQWlCO0FBQUEsY0FDakIsYUFBYTtBQUFBLGNBQ2IsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLFFBSWIsU0FBUztBQUFBLFVBQ1AscUJBQXFCO0FBQUEsVUFDckIsV0FBVztBQUFBLFVBQ1gsWUFBWTtBQUFBLFVBQ1osU0FBUztBQUFBLFlBQ1AsUUFBUTtBQUFBLGNBQ04sUUFBUTtBQUFBLGNBQ1IsV0FBVztBQUFBLGNBQ1gsVUFBVTtBQUFBO0FBQUEsWUFFWixRQUFRO0FBQUEsY0FDTixVQUFVO0FBQUE7QUFBQSxZQUVaLE9BQU87QUFBQSxjQUNMLFNBQVM7QUFBQSxjQUNULE1BQU07QUFBQTtBQUFBLFlBRVIsWUFBWTtBQUFBLGNBQ1YsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FsRXpLbkIsc0JBQWtCO0FBckdsQixXQUFTLGlCQUFpQixvQkFBb0IsV0FBWTtBQUV4RCxVQUFNLFlBQVksU0FBUyxlQUFlO0FBQzFDLFVBQU0sYUFBYSxTQUFTLGVBQWU7QUFDM0MsVUFBTSxnQkFBZ0IsU0FBUyxlQUFlO0FBRzlDLFFBQUksYUFBYSxjQUFjLGVBQWU7QUFFNUMsWUFBTSxTQUFTLGNBQWMsUUFBUTtBQUVyQyxZQUFNLE9BQU8sY0FBYyxRQUFRO0FBRW5DLFlBQU0sV0FBVyxjQUFjLFFBQVE7QUFHdkMsWUFBTSxXQUFXLEtBQUssTUFBTSxjQUFjLFFBQVE7QUFJbEQsaUJBQVcsaUJBQWlCLFNBQVMsV0FBWTtBQUUvQyx1QkFBZSxpQkFBaUI7QUFDaEMsZ0JBQVEsSUFBSTtBQUNaLFlBQUksQ0FBQyxjQUFjO0FBQ2pCLGlCQUFPLFdBQVcsNEJBQVcsUUFBUSxNQUFNLFVBQVU7QUFBQSxlQUVuRDtBQUVGLGNBQUksYUFBYSxTQUFTLGNBQWM7QUFDeEMsa0JBQVEsSUFBSTtBQUNaLHFCQUFXLFVBQVUsSUFBSTtBQUN6QixxQkFBVyxNQUFNLFNBQVM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWlEbEM7QUFDQTtBQXNCQSxNQUFNLFNBQVE7QUFrQmQsU0FBTSxhQUFhO0FBQUEsSUFDakIsVUFBVTtBQUNSLFlBQU0sUUFBUSxLQUFLO0FBRW5CLFlBQU0saUJBQWlCLFlBQVksUUFBUSxTQUFPO0FBQ2hELFlBQUksZUFBZTtBQUVuQixZQUFJLGlCQUFpQixhQUFhLE1BQU07QUFDdEMseUJBQWUsSUFBSSxNQUFNO0FBQ3pCLGNBQUksTUFBTSxrQkFBa0I7QUFBQTtBQUc5QixZQUFJLGlCQUFpQixZQUFZLE1BQU07QUFDckMsY0FBSSxNQUFNLGtCQUFrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTXBDLFNBQU0scUJBQXFCO0FBQUEsSUFDekIsVUFBVTtBQUNSLGNBQVEsSUFBSTtBQUdaLFVBQUksZ0JBQWdCLFNBQVMsZUFBZTtBQUc1QyxVQUFJLGVBQWU7QUFDakIsZ0JBQVEsSUFBSSxrQkFBa0I7QUFHOUIsWUFBSSxDQUFDLGNBQWMsV0FBVztBQUM1Qix3QkFBYyxZQUFZLElBQUksMkJBQVUsZUFBZTtBQUFBLFlBRXJELFFBQVE7QUFBQSxZQUNSLFdBQVc7QUFBQSxjQUNULE9BQU87QUFBQSxjQUNQLFdBQVc7QUFBQTtBQUFBO0FBR2Ysa0JBQVEsSUFBSSxzQkFBc0IsY0FBYyxVQUFVO0FBQUE7QUFBQSxhQUV2RDtBQUNMLGdCQUFRLE1BQU07QUFBQTtBQUFBO0FBQUEsSUFHbEIsVUFBVTtBQUNSLGNBQVEsSUFBSTtBQUdaLFVBQUksZ0JBQWdCLFNBQVMsZUFBZTtBQUc1QyxVQUFJLGlCQUFpQixjQUFjLFdBQVc7QUFDNUMsZ0JBQVEsSUFBSSxrQkFBa0I7QUFHOUIsc0JBQWMsVUFBVTtBQUd4QixZQUFJLGdCQUFnQixjQUFjLGlCQUFpQjtBQUNuRCxzQkFBYyxRQUFRLFNBQVUsUUFBUTtBQUN0Qyx3QkFBYyxVQUFVLFVBQVU7QUFBQSxZQUNoQyxPQUFPLE9BQU87QUFBQSxZQUNkLE1BQU0sT0FBTztBQUFBO0FBQUE7QUFLakIsc0JBQWMsVUFBVTtBQUFBLGFBQ25CO0FBQ0wsZ0JBQVEsTUFBTTtBQUFBO0FBQUE7QUFBQTtBQVVwQixTQUFNLGdCQUFnQjtBQUFBLElBQ3BCLFVBQVU7QUFDUixXQUFLLG9CQUFvQixLQUFLLGtCQUFrQixLQUFLO0FBQ3JELFdBQUssR0FBRyxpQkFBaUIsU0FBUyxLQUFLO0FBQUE7QUFBQSxJQUV6QyxZQUFZO0FBQ1YsV0FBSyxHQUFHLG9CQUFvQixTQUFTLEtBQUs7QUFBQTtBQUFBLElBTTVDLGtCQUFrQixPQUFPO0FBTXZCLFVBQUksVUFBVSxLQUFLLEdBQUcsYUFBYTtBQUNuQyxjQUFRLElBQUksV0FBVztBQUN2QixnQkFBVSxRQUFRLFFBQVEsV0FBVztBQUVyQyxjQUFRLElBQUssV0FBVztBQUV4QixZQUFNLE9BQU8sSUFBSSxLQUFLLENBQUMsVUFBVSxFQUFFLE1BQU07QUFHekMsWUFBTSxPQUFPLFNBQVMsY0FBYztBQUNwQyxXQUFLLE9BQU8sT0FBTyxJQUFJLGdCQUFnQjtBQUN2QyxXQUFLLFdBQVc7QUFHaEIsZUFBUyxLQUFLLFlBQVk7QUFHMUIsV0FBSztBQUdMLGVBQVMsS0FBSyxZQUFZO0FBQUE7QUFBQTtBQVE5QixTQUFNLHFCQUFxQjtBQUFBLElBQ3pCLFVBQVU7QUFDUixZQUFNLEVBQUUsOEJBQThCLGlDQUNwQyxLQUFLLE1BQU0sS0FBSyxHQUFHLFFBQVE7QUFDN0IsV0FBSyxRQUFRLElBQUksbUJBQ2YsS0FBSyxJQUNMLDhCQUNBO0FBQUE7QUFBQTtBQUtOLFNBQU0sa0JBQWtCO0FBQUEsSUFDdEIsVUFBVTtBQUNSLFlBQU07QUFBQSxRQUNKO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFVBQ0UsS0FBSyxNQUFNLEtBQUssR0FBRyxRQUFRO0FBQy9CLFdBQUssUUFBUSxJQUFJLGdCQUNmLEtBQUssSUFDTCw0QkFDQSxnQ0FDQSxtQ0FDQSxrQ0FDQTtBQUFBO0FBQUE7QUFNTixTQUFNLGNBQWM7QUFBQSxJQUNsQixVQUFVO0FBQ1IsY0FBUSxJQUFJO0FBRVosWUFBTSxFQUFFLFdBQVcsS0FBSyxNQUFNLEtBQUssR0FBRyxRQUFRO0FBRTlDLFdBQUssVUFBVSxJQUFJLFlBQVksS0FBSyxJQUFJO0FBQUE7QUFBQTtBQVc1QyxTQUFNLFFBQVE7QUFBQSxJQUNaLFVBQVU7QUFDUixXQUFLO0FBQUE7QUFBQSxJQUdQLFVBQVU7QUFDUixXQUFLLGFBQWE7QUFDbEIsV0FBSyxjQUFjO0FBQ25CLFdBQUs7QUFBQTtBQUFBLElBR1AsaUJBQWlCO0FBQ2YsV0FBSyxlQUFlLElBQUksU0FDdEIsU0FBUyxpQkFBaUIsa0JBQzFCO0FBQUEsUUFDRSxXQUFXO0FBQUEsUUFDWCxRQUFRO0FBQUEsVUFDTixxQkFBcUI7QUFBQTtBQUFBLFFBRXZCLGVBQWU7QUFBQSxVQUNiLFVBQVU7QUFBQSxVQUNWLGdCQUFnQjtBQUFBO0FBQUEsUUFFbEIsU0FBUyxDQUFDLGdCQUFRO0FBQUE7QUFJdEIsV0FBSyxhQUFhLEdBQUcsaUJBQWlCLENBQUMsVUFBVTtBQUMvQyxjQUFNLFNBQVMsTUFBTSxLQUFLLFVBQVUsS0FBSztBQUN6QyxjQUFNLFNBQVMsU0FBUyxPQUFPLGFBQWE7QUFDNUMsY0FBTSxhQUFhLFNBQ2pCLE1BQU0sS0FBSyxhQUFhLGFBQWE7QUFFdkMsY0FBTSxXQUFXLFNBQVMsTUFBTSxLQUFLO0FBQ3JDLGNBQU0sY0FBYztBQUFBLFVBQ2xCLE1BQU07QUFBQSxZQUNKLElBQUk7QUFBQSxZQUNKLFVBQVU7QUFBQSxZQUNWLFVBQVU7QUFBQTtBQUFBO0FBR2QsYUFBSyxVQUFVLGVBQWU7QUFBQTtBQUdoQyxXQUFLLGdCQUFnQixJQUFJLFNBQVMsU0FBUyxpQkFBaUIsV0FBVztBQUFBLFFBQ3JFLFdBQVc7QUFBQSxRQUNYLFFBQVE7QUFBQSxRQUNSLFFBQVE7QUFBQSxVQUNOLHFCQUFxQjtBQUFBLFVBQ3JCLE9BQU87QUFBQTtBQUFBO0FBSVgsV0FBSyxjQUFjLEdBQUcsaUJBQWlCLENBQUMsVUFBVTtBQUNoRCxjQUFNLFNBQVMsTUFBTSxLQUFLLFVBQVUsS0FBSztBQUN6QyxjQUFNLFVBQVUsU0FBUyxPQUFPLGFBQWE7QUFDN0MsY0FBTSxXQUFXLFNBQVMsTUFBTSxLQUFLO0FBQ3JDLGNBQU0sZUFBZTtBQUFBLFVBQ25CLE9BQU87QUFBQSxZQUNMLElBQUk7QUFBQSxZQUNKLFVBQVU7QUFBQTtBQUFBO0FBR2QsYUFBSyxVQUFVLGdCQUFnQjtBQUFBO0FBQUE7QUFBQTtBQUtyQyxTQUFNLGVBQWU7QUFBQSxJQUNuQixVQUFVO0FBRVIsV0FBSyxZQUFZLGdCQUFnQixDQUFDLE9BQU8sS0FBSztBQUFBO0FBQUEsSUFFaEQsVUFBVTtBQUFBO0FBQUEsSUFDVixnQkFBZ0I7QUFDZCxVQUFJLFNBQVEsU0FBUyxjQUFjO0FBQ25DLGFBQU0sTUFBTSxVQUFVO0FBQ3RCLGFBQU8sV0FBVyxXQUFZO0FBRTVCLGVBQU0sTUFBTSxVQUFVO0FBQUEsU0FDckI7QUFBQTtBQUFBLElBRUwsY0FBYztBQUNaLFVBQUksVUFBUyxTQUFTLGlCQUFpQjtBQUd2QyxjQUFPLFFBQVEsQ0FBQyxTQUFTO0FBQ3ZCLGFBQUssTUFBTSxVQUFVO0FBQ3JCLGFBQUssU0FBUyxPQUFPLFdBQVcsV0FBWTtBQUMxQyxlQUFLLE1BQU0sVUFBVTtBQUFBLFdBQ3BCO0FBQUE7QUFHTCxlQUFTLElBQUksR0FBRyxJQUFJLFFBQU8sUUFBUSxLQUFLO0FBQ3RDLGdCQUFPLEdBQUcsTUFBTSxVQUFVO0FBQzFCLGdCQUFPLEdBQUcsU0FBUyxPQUFPLFdBQVcsV0FBWTtBQUMvQyxrQkFBTyxHQUFHLE1BQU0sVUFBVTtBQUFBLFdBQ3pCO0FBQUE7QUFBQTtBQUFBO0FBS1QsU0FBTSxXQUFXO0FBQUEsSUFDZixVQUFVO0FBRVIsV0FBSyxZQUFZLFlBQVksQ0FBQyxFQUFFLFFBQVEsYUFFdEMsS0FBSztBQUFBO0FBQUEsSUFHVCxXQUFXO0FBQ1QsVUFBSSxPQUFPLFNBQVM7QUFDcEIsVUFBSSxlQUFlLFNBQVMsY0FBYztBQUkxQyxXQUFLLE1BQU0sVUFBVTtBQUtyQixtQkFBYSxNQUFNLFVBQVU7QUFBQTtBQUFBO0FBSWpDLFNBQU0sY0FBYztBQUFBLElBQ2xCLFVBQVU7QUFDUixVQUFJLGNBQWMsU0FBUyxjQUFjO0FBQ3pDLFdBQUssWUFDSCxnQkFDQSxDQUFDLE9BQ0UsWUFBWSxZQUNYLFlBQVksZUFBZSxZQUFZO0FBQUE7QUFBQTtBQU1qRCxTQUFNLGFBQWE7QUFBQSxJQUNqQixVQUFVO0FBQ1IsVUFBSSxPQUFPLFNBQVMsY0FBYztBQUVsQyxVQUFJLE1BQU0sT0FBTyxTQUFTO0FBRzFCLFVBQUksU0FBUyxXQUNULEtBQUssVUFBVSxPQUFPLGVBQ3RCLEtBQUssVUFBVSxJQUFJO0FBQUE7QUFBQTtBQUkzQixTQUFNLFdBQVc7QUFBQSxJQUNmLFVBQVU7QUFFUixXQUFLLFlBQVksWUFBWSxDQUFDLE9BQU8sS0FBSztBQUMxQyxXQUFLLFlBQVksZUFBZSxDQUFDLE9BQU8sS0FBSztBQUFBO0FBQUEsSUFFL0MsWUFBWTtBQUNWLFVBQUksUUFBUSxTQUFTLGlCQUFpQjtBQU10QyxZQUFNLFFBQVEsQ0FBQyxTQUFTO0FBQ3RCLGFBQUssVUFBVSxJQUFJO0FBQUE7QUFHckIsWUFBTSxRQUFRLENBQUMsU0FBUztBQUN0QixlQUFPLFdBQVcsV0FBWTtBQUM1QixlQUFLLFVBQVUsT0FBTztBQUFBLFdBQ3JCO0FBQUE7QUFBQTtBQUFBLElBR1Asb0JBQW9CO0FBRWxCLFVBQUksZ0JBQWdCLFNBQVMsZUFBZTtBQUU1QyxvQkFBYyxVQUFVLElBQUk7QUFFNUIsYUFBTyxXQUFXLFdBQVk7QUFDNUIsc0JBQWMsVUFBVSxPQUFPO0FBQUEsU0FDOUI7QUFBQTtBQUFBO0FBS1AsTUFBSSxZQUFZLFNBQVMsY0FBYztBQUN2QyxNQUFJLGFBQWEsU0FBUyxjQUFjO0FBQ3hDLFlBQVUsaUJBQWlCLFNBQVMsV0FBWTtBQUM5QyxRQUFJLFdBQVcsVUFBVSxTQUFTLFdBQVc7QUFDM0MsV0FBSyxhQUFhLGlCQUFpQjtBQUNuQyxXQUFLLGFBQWEsY0FBYztBQUNoQyxpQkFBVyxVQUFVLE9BQU87QUFBQSxXQUN2QjtBQUNMLGlCQUFXLFVBQVUsSUFBSTtBQUN6QixXQUFLLGFBQWEsY0FBYztBQUNoQyxXQUFLLGFBQWEsaUJBQWlCO0FBQUE7QUFBQTtBQUl0QyxNQUFJLGdCQUFnQixTQUFTLGVBQWU7QUFHNUMsTUFBSSxlQUFlO0FBQ2Ysa0JBQWMsWUFBWTtBQUFBO0FBRS9CLE1BQU0sVUFBVSxTQUFTLGNBQWM7QUFDdkMsTUFBSSxXQUFXO0FBQ2YsVUFBUSxpQkFBaUIsU0FBUyxNQUFNO0FBQ3RDLFFBQUksQ0FBQyxVQUFVO0FBQ2IsY0FBUSxVQUFVLElBQUk7QUFDdEIsaUJBQVc7QUFBQSxXQUNOO0FBQ0wsY0FBUSxVQUFVLE9BQU87QUFDekIsaUJBQVc7QUFBQTtBQUFBO0FBSWYsTUFBSSxTQUFTLFNBQVMsaUJBQWlCO0FBRXZDLFNBQU8sUUFBUSxDQUFDLFNBQVM7QUFDdkIsU0FBSyxNQUFNLFVBQVU7QUFDckIsU0FBSyxTQUFTLE9BQU8sV0FBVyxXQUFZO0FBQzFDLFdBQUssTUFBTSxVQUFVO0FBQUEsT0FDcEI7QUFBQTtBQUdMLE1BQUksWUFBWSxTQUNiLGNBQWMsMkJBQ2QsYUFBYTtBQUNoQixNQUFJLGFBQWEsSUFBSSxXQUFXLFNBQVMsUUFBUTtBQUFBLElBQy9DLFFBQVEsRUFBRSxhQUFhO0FBQUEsSUFDdkIsT0FBTztBQUFBO0FBTVQsd0JBQU8sT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLFVBQVUsYUFBYTtBQUV2RCxTQUFPLGlCQUFpQiwwQkFBMEIsQ0FBQyxTQUFTLHNCQUFPO0FBQ25FLFNBQU8saUJBQWlCLHlCQUF5QixDQUFDLFNBQVMsc0JBQU87QUFHbEUsYUFBVztBQU1YLFNBQU8sYUFBYTsiLAogICJuYW1lcyI6IFtdCn0K
