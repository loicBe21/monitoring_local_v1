(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/tom-select/dist/js/tom-select.complete.js
  var require_tom_select_complete = __commonJS({
    "node_modules/tom-select/dist/js/tom-select.complete.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.TomSelect = factory());
      })(exports, function() {
        "use strict";
        function forEvents(events, callback) {
          events.split(/\s+/).forEach((event) => {
            callback(event);
          });
        }
        class MicroEvent {
          constructor() {
            this._events = void 0;
            this._events = {};
          }
          on(events, fct) {
            forEvents(events, (event) => {
              const event_array = this._events[event] || [];
              event_array.push(fct);
              this._events[event] = event_array;
            });
          }
          off(events, fct) {
            var n = arguments.length;
            if (n === 0) {
              this._events = {};
              return;
            }
            forEvents(events, (event) => {
              if (n === 1) {
                delete this._events[event];
                return;
              }
              const event_array = this._events[event];
              if (event_array === void 0)
                return;
              event_array.splice(event_array.indexOf(fct), 1);
              this._events[event] = event_array;
            });
          }
          trigger(events, ...args) {
            var self2 = this;
            forEvents(events, (event) => {
              const event_array = self2._events[event];
              if (event_array === void 0)
                return;
              event_array.forEach((fct) => {
                fct.apply(self2, args);
              });
            });
          }
        }
        function MicroPlugin(Interface) {
          Interface.plugins = {};
          return class extends Interface {
            constructor(...args) {
              super(...args);
              this.plugins = {
                names: [],
                settings: {},
                requested: {},
                loaded: {}
              };
            }
            static define(name, fn) {
              Interface.plugins[name] = {
                "name": name,
                "fn": fn
              };
            }
            initializePlugins(plugins) {
              var key, name;
              const self2 = this;
              const queue = [];
              if (Array.isArray(plugins)) {
                plugins.forEach((plugin) => {
                  if (typeof plugin === "string") {
                    queue.push(plugin);
                  } else {
                    self2.plugins.settings[plugin.name] = plugin.options;
                    queue.push(plugin.name);
                  }
                });
              } else if (plugins) {
                for (key in plugins) {
                  if (plugins.hasOwnProperty(key)) {
                    self2.plugins.settings[key] = plugins[key];
                    queue.push(key);
                  }
                }
              }
              while (name = queue.shift()) {
                self2.require(name);
              }
            }
            loadPlugin(name) {
              var self2 = this;
              var plugins = self2.plugins;
              var plugin = Interface.plugins[name];
              if (!Interface.plugins.hasOwnProperty(name)) {
                throw new Error('Unable to find "' + name + '" plugin');
              }
              plugins.requested[name] = true;
              plugins.loaded[name] = plugin.fn.apply(self2, [self2.plugins.settings[name] || {}]);
              plugins.names.push(name);
            }
            require(name) {
              var self2 = this;
              var plugins = self2.plugins;
              if (!self2.plugins.loaded.hasOwnProperty(name)) {
                if (plugins.requested[name]) {
                  throw new Error('Plugin has circular dependency ("' + name + '")');
                }
                self2.loadPlugin(name);
              }
              return plugins.loaded[name];
            }
          };
        }
        const arrayToPattern = (chars) => {
          chars = chars.filter(Boolean);
          if (chars.length < 2) {
            return chars[0] || "";
          }
          return maxValueLength(chars) == 1 ? "[" + chars.join("") + "]" : "(?:" + chars.join("|") + ")";
        };
        const sequencePattern = (array) => {
          if (!hasDuplicates(array)) {
            return array.join("");
          }
          let pattern = "";
          let prev_char_count = 0;
          const prev_pattern = () => {
            if (prev_char_count > 1) {
              pattern += "{" + prev_char_count + "}";
            }
          };
          array.forEach((char, i) => {
            if (char === array[i - 1]) {
              prev_char_count++;
              return;
            }
            prev_pattern();
            pattern += char;
            prev_char_count = 1;
          });
          prev_pattern();
          return pattern;
        };
        const setToPattern = (chars) => {
          let array = toArray(chars);
          return arrayToPattern(array);
        };
        const hasDuplicates = (array) => {
          return new Set(array).size !== array.length;
        };
        const escape_regex = (str) => {
          return (str + "").replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, "\\$1");
        };
        const maxValueLength = (array) => {
          return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);
        };
        const unicodeLength = (str) => {
          return toArray(str).length;
        };
        const toArray = (p) => Array.from(p);
        const allSubstrings = (input) => {
          if (input.length === 1)
            return [[input]];
          let result = [];
          const start = input.substring(1);
          const suba = allSubstrings(start);
          suba.forEach(function(subresult) {
            let tmp = subresult.slice(0);
            tmp[0] = input.charAt(0) + tmp[0];
            result.push(tmp);
            tmp = subresult.slice(0);
            tmp.unshift(input.charAt(0));
            result.push(tmp);
          });
          return result;
        };
        const code_points = [[0, 65535]];
        const accent_pat = "[\u0300-\u036F\xB7\u02BE\u02BC]";
        let unicode_map;
        let multi_char_reg;
        const max_char_length = 3;
        const latin_convert = {};
        const latin_condensed = {
          "/": "\u2044\u2215",
          "0": "\u07C0",
          "a": "\u2C65\u0250\u0251",
          "aa": "\uA733",
          "ae": "\xE6\u01FD\u01E3",
          "ao": "\uA735",
          "au": "\uA737",
          "av": "\uA739\uA73B",
          "ay": "\uA73D",
          "b": "\u0180\u0253\u0183",
          "c": "\uA73F\u0188\u023C\u2184",
          "d": "\u0111\u0257\u0256\u1D05\u018C\uABB7\u0501\u0266",
          "e": "\u025B\u01DD\u1D07\u0247",
          "f": "\uA77C\u0192",
          "g": "\u01E5\u0260\uA7A1\u1D79\uA77F\u0262",
          "h": "\u0127\u2C68\u2C76\u0265",
          "i": "\u0268\u0131",
          "j": "\u0249\u0237",
          "k": "\u0199\u2C6A\uA741\uA743\uA745\uA7A3",
          "l": "\u0142\u019A\u026B\u2C61\uA749\uA747\uA781\u026D",
          "m": "\u0271\u026F\u03FB",
          "n": "\uA7A5\u019E\u0272\uA791\u1D0E\u043B\u0509",
          "o": "\xF8\u01FF\u0254\u0275\uA74B\uA74D\u1D11",
          "oe": "\u0153",
          "oi": "\u01A3",
          "oo": "\uA74F",
          "ou": "\u0223",
          "p": "\u01A5\u1D7D\uA751\uA753\uA755\u03C1",
          "q": "\uA757\uA759\u024B",
          "r": "\u024D\u027D\uA75B\uA7A7\uA783",
          "s": "\xDF\u023F\uA7A9\uA785\u0282",
          "t": "\u0167\u01AD\u0288\u2C66\uA787",
          "th": "\xFE",
          "tz": "\uA729",
          "u": "\u0289",
          "v": "\u028B\uA75F\u028C",
          "vy": "\uA761",
          "w": "\u2C73",
          "y": "\u01B4\u024F\u1EFF",
          "z": "\u01B6\u0225\u0240\u2C6C\uA763",
          "hv": "\u0195"
        };
        for (let latin in latin_condensed) {
          let unicode = latin_condensed[latin] || "";
          for (let i = 0; i < unicode.length; i++) {
            let char = unicode.substring(i, i + 1);
            latin_convert[char] = latin;
          }
        }
        const convert_pat = new RegExp(Object.keys(latin_convert).join("|") + "|" + accent_pat, "gu");
        const initialize = (_code_points) => {
          if (unicode_map !== void 0)
            return;
          unicode_map = generateMap(_code_points || code_points);
        };
        const normalize = (str, form = "NFKD") => str.normalize(form);
        const asciifold = (str) => {
          return toArray(str).reduce((result, char) => {
            return result + _asciifold(char);
          }, "");
        };
        const _asciifold = (str) => {
          str = normalize(str).toLowerCase().replace(convert_pat, (char) => {
            return latin_convert[char] || "";
          });
          return normalize(str, "NFC");
        };
        function* generator(code_points2) {
          for (const [code_point_min, code_point_max] of code_points2) {
            for (let i = code_point_min; i <= code_point_max; i++) {
              let composed = String.fromCharCode(i);
              let folded = asciifold(composed);
              if (folded == composed.toLowerCase()) {
                continue;
              }
              if (folded.length > max_char_length) {
                continue;
              }
              if (folded.length == 0) {
                continue;
              }
              yield {
                folded,
                composed,
                code_point: i
              };
            }
          }
        }
        const generateSets = (code_points2) => {
          const unicode_sets = {};
          const addMatching = (folded, to_add) => {
            const folded_set = unicode_sets[folded] || /* @__PURE__ */ new Set();
            const patt = new RegExp("^" + setToPattern(folded_set) + "$", "iu");
            if (to_add.match(patt)) {
              return;
            }
            folded_set.add(escape_regex(to_add));
            unicode_sets[folded] = folded_set;
          };
          for (let value of generator(code_points2)) {
            addMatching(value.folded, value.folded);
            addMatching(value.folded, value.composed);
          }
          return unicode_sets;
        };
        const generateMap = (code_points2) => {
          const unicode_sets = generateSets(code_points2);
          const unicode_map2 = {};
          let multi_char = [];
          for (let folded in unicode_sets) {
            let set = unicode_sets[folded];
            if (set) {
              unicode_map2[folded] = setToPattern(set);
            }
            if (folded.length > 1) {
              multi_char.push(escape_regex(folded));
            }
          }
          multi_char.sort((a, b) => b.length - a.length);
          const multi_char_patt = arrayToPattern(multi_char);
          multi_char_reg = new RegExp("^" + multi_char_patt, "u");
          return unicode_map2;
        };
        const mapSequence = (strings, min_replacement = 1) => {
          let chars_replaced = 0;
          strings = strings.map((str) => {
            if (unicode_map[str]) {
              chars_replaced += str.length;
            }
            return unicode_map[str] || str;
          });
          if (chars_replaced >= min_replacement) {
            return sequencePattern(strings);
          }
          return "";
        };
        const substringsToPattern = (str, min_replacement = 1) => {
          min_replacement = Math.max(min_replacement, str.length - 1);
          return arrayToPattern(allSubstrings(str).map((sub_pat) => {
            return mapSequence(sub_pat, min_replacement);
          }));
        };
        const sequencesToPattern = (sequences, all = true) => {
          let min_replacement = sequences.length > 1 ? 1 : 0;
          return arrayToPattern(sequences.map((sequence) => {
            let seq = [];
            const len = all ? sequence.length() : sequence.length() - 1;
            for (let j = 0; j < len; j++) {
              seq.push(substringsToPattern(sequence.substrs[j] || "", min_replacement));
            }
            return sequencePattern(seq);
          }));
        };
        const inSequences = (needle_seq, sequences) => {
          for (const seq of sequences) {
            if (seq.start != needle_seq.start || seq.end != needle_seq.end) {
              continue;
            }
            if (seq.substrs.join("") !== needle_seq.substrs.join("")) {
              continue;
            }
            let needle_parts = needle_seq.parts;
            const filter = (part) => {
              for (const needle_part of needle_parts) {
                if (needle_part.start === part.start && needle_part.substr === part.substr) {
                  return false;
                }
                if (part.length == 1 || needle_part.length == 1) {
                  continue;
                }
                if (part.start < needle_part.start && part.end > needle_part.start) {
                  return true;
                }
                if (needle_part.start < part.start && needle_part.end > part.start) {
                  return true;
                }
              }
              return false;
            };
            let filtered = seq.parts.filter(filter);
            if (filtered.length > 0) {
              continue;
            }
            return true;
          }
          return false;
        };
        class Sequence {
          constructor() {
            this.parts = [];
            this.substrs = [];
            this.start = 0;
            this.end = 0;
          }
          add(part) {
            if (part) {
              this.parts.push(part);
              this.substrs.push(part.substr);
              this.start = Math.min(part.start, this.start);
              this.end = Math.max(part.end, this.end);
            }
          }
          last() {
            return this.parts[this.parts.length - 1];
          }
          length() {
            return this.parts.length;
          }
          clone(position, last_piece) {
            let clone2 = new Sequence();
            let parts = JSON.parse(JSON.stringify(this.parts));
            let last_part = parts.pop();
            for (const part of parts) {
              clone2.add(part);
            }
            let last_substr = last_piece.substr.substring(0, position - last_part.start);
            let clone_last_len = last_substr.length;
            clone2.add({
              start: last_part.start,
              end: last_part.start + clone_last_len,
              length: clone_last_len,
              substr: last_substr
            });
            return clone2;
          }
        }
        const getPattern = (str) => {
          initialize();
          str = asciifold(str);
          let pattern = "";
          let sequences = [new Sequence()];
          for (let i = 0; i < str.length; i++) {
            let substr = str.substring(i);
            let match = substr.match(multi_char_reg);
            const char = str.substring(i, i + 1);
            const match_str = match ? match[0] : null;
            let overlapping = [];
            let added_types = /* @__PURE__ */ new Set();
            for (const sequence of sequences) {
              const last_piece = sequence.last();
              if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {
                if (match_str) {
                  const len = match_str.length;
                  sequence.add({
                    start: i,
                    end: i + len,
                    length: len,
                    substr: match_str
                  });
                  added_types.add("1");
                } else {
                  sequence.add({
                    start: i,
                    end: i + 1,
                    length: 1,
                    substr: char
                  });
                  added_types.add("2");
                }
              } else if (match_str) {
                let clone2 = sequence.clone(i, last_piece);
                const len = match_str.length;
                clone2.add({
                  start: i,
                  end: i + len,
                  length: len,
                  substr: match_str
                });
                overlapping.push(clone2);
              } else {
                added_types.add("3");
              }
            }
            if (overlapping.length > 0) {
              overlapping = overlapping.sort((a, b) => {
                return a.length() - b.length();
              });
              for (let clone2 of overlapping) {
                if (inSequences(clone2, sequences)) {
                  continue;
                }
                sequences.push(clone2);
              }
              continue;
            }
            if (i > 0 && added_types.size == 1 && !added_types.has("3")) {
              pattern += sequencesToPattern(sequences, false);
              let new_seq = new Sequence();
              const old_seq = sequences[0];
              if (old_seq) {
                new_seq.add(old_seq.last());
              }
              sequences = [new_seq];
            }
          }
          pattern += sequencesToPattern(sequences, true);
          return pattern;
        };
        const getAttr = (obj, name) => {
          if (!obj)
            return;
          return obj[name];
        };
        const getAttrNesting = (obj, name) => {
          if (!obj)
            return;
          var part, names = name.split(".");
          while ((part = names.shift()) && (obj = obj[part]))
            ;
          return obj;
        };
        const scoreValue = (value, token, weight) => {
          var score, pos;
          if (!value)
            return 0;
          value = value + "";
          if (token.regex == null)
            return 0;
          pos = value.search(token.regex);
          if (pos === -1)
            return 0;
          score = token.string.length / value.length;
          if (pos === 0)
            score += 0.5;
          return score * weight;
        };
        const propToArray = (obj, key) => {
          var value = obj[key];
          if (typeof value == "function")
            return value;
          if (value && !Array.isArray(value)) {
            obj[key] = [value];
          }
        };
        const iterate$1 = (object, callback) => {
          if (Array.isArray(object)) {
            object.forEach(callback);
          } else {
            for (var key in object) {
              if (object.hasOwnProperty(key)) {
                callback(object[key], key);
              }
            }
          }
        };
        const cmp = (a, b) => {
          if (typeof a === "number" && typeof b === "number") {
            return a > b ? 1 : a < b ? -1 : 0;
          }
          a = asciifold(a + "").toLowerCase();
          b = asciifold(b + "").toLowerCase();
          if (a > b)
            return 1;
          if (b > a)
            return -1;
          return 0;
        };
        class Sifter {
          constructor(items, settings) {
            this.items = void 0;
            this.settings = void 0;
            this.items = items;
            this.settings = settings || {
              diacritics: true
            };
          }
          tokenize(query, respect_word_boundaries, weights) {
            if (!query || !query.length)
              return [];
            const tokens = [];
            const words = query.split(/\s+/);
            var field_regex;
            if (weights) {
              field_regex = new RegExp("^(" + Object.keys(weights).map(escape_regex).join("|") + "):(.*)$");
            }
            words.forEach((word) => {
              let field_match;
              let field = null;
              let regex = null;
              if (field_regex && (field_match = word.match(field_regex))) {
                field = field_match[1];
                word = field_match[2];
              }
              if (word.length > 0) {
                if (this.settings.diacritics) {
                  regex = getPattern(word) || null;
                } else {
                  regex = escape_regex(word);
                }
                if (regex && respect_word_boundaries)
                  regex = "\\b" + regex;
              }
              tokens.push({
                string: word,
                regex: regex ? new RegExp(regex, "iu") : null,
                field
              });
            });
            return tokens;
          }
          getScoreFunction(query, options) {
            var search = this.prepareSearch(query, options);
            return this._getScoreFunction(search);
          }
          _getScoreFunction(search) {
            const tokens = search.tokens, token_count = tokens.length;
            if (!token_count) {
              return function() {
                return 0;
              };
            }
            const fields = search.options.fields, weights = search.weights, field_count = fields.length, getAttrFn = search.getAttrFn;
            if (!field_count) {
              return function() {
                return 1;
              };
            }
            const scoreObject = function() {
              if (field_count === 1) {
                return function(token, data) {
                  const field = fields[0].field;
                  return scoreValue(getAttrFn(data, field), token, weights[field] || 1);
                };
              }
              return function(token, data) {
                var sum = 0;
                if (token.field) {
                  const value = getAttrFn(data, token.field);
                  if (!token.regex && value) {
                    sum += 1 / field_count;
                  } else {
                    sum += scoreValue(value, token, 1);
                  }
                } else {
                  iterate$1(weights, (weight, field) => {
                    sum += scoreValue(getAttrFn(data, field), token, weight);
                  });
                }
                return sum / field_count;
              };
            }();
            if (token_count === 1) {
              return function(data) {
                return scoreObject(tokens[0], data);
              };
            }
            if (search.options.conjunction === "and") {
              return function(data) {
                var score, sum = 0;
                for (let token of tokens) {
                  score = scoreObject(token, data);
                  if (score <= 0)
                    return 0;
                  sum += score;
                }
                return sum / token_count;
              };
            } else {
              return function(data) {
                var sum = 0;
                iterate$1(tokens, (token) => {
                  sum += scoreObject(token, data);
                });
                return sum / token_count;
              };
            }
          }
          getSortFunction(query, options) {
            var search = this.prepareSearch(query, options);
            return this._getSortFunction(search);
          }
          _getSortFunction(search) {
            var implicit_score, sort_flds = [];
            const self2 = this, options = search.options, sort = !search.query && options.sort_empty ? options.sort_empty : options.sort;
            if (typeof sort == "function") {
              return sort.bind(this);
            }
            const get_field = function get_field2(name, result) {
              if (name === "$score")
                return result.score;
              return search.getAttrFn(self2.items[result.id], name);
            };
            if (sort) {
              for (let s of sort) {
                if (search.query || s.field !== "$score") {
                  sort_flds.push(s);
                }
              }
            }
            if (search.query) {
              implicit_score = true;
              for (let fld of sort_flds) {
                if (fld.field === "$score") {
                  implicit_score = false;
                  break;
                }
              }
              if (implicit_score) {
                sort_flds.unshift({
                  field: "$score",
                  direction: "desc"
                });
              }
            } else {
              sort_flds = sort_flds.filter((fld) => fld.field !== "$score");
            }
            const sort_flds_count = sort_flds.length;
            if (!sort_flds_count) {
              return null;
            }
            return function(a, b) {
              var result, field;
              for (let sort_fld of sort_flds) {
                field = sort_fld.field;
                let multiplier = sort_fld.direction === "desc" ? -1 : 1;
                result = multiplier * cmp(get_field(field, a), get_field(field, b));
                if (result)
                  return result;
              }
              return 0;
            };
          }
          prepareSearch(query, optsUser) {
            const weights = {};
            var options = Object.assign({}, optsUser);
            propToArray(options, "sort");
            propToArray(options, "sort_empty");
            if (options.fields) {
              propToArray(options, "fields");
              const fields = [];
              options.fields.forEach((field) => {
                if (typeof field == "string") {
                  field = {
                    field,
                    weight: 1
                  };
                }
                fields.push(field);
                weights[field.field] = "weight" in field ? field.weight : 1;
              });
              options.fields = fields;
            }
            return {
              options,
              query: query.toLowerCase().trim(),
              tokens: this.tokenize(query, options.respect_word_boundaries, weights),
              total: 0,
              items: [],
              weights,
              getAttrFn: options.nesting ? getAttrNesting : getAttr
            };
          }
          search(query, options) {
            var self2 = this, score, search;
            search = this.prepareSearch(query, options);
            options = search.options;
            query = search.query;
            const fn_score = options.score || self2._getScoreFunction(search);
            if (query.length) {
              iterate$1(self2.items, (item, id) => {
                score = fn_score(item);
                if (options.filter === false || score > 0) {
                  search.items.push({
                    "score": score,
                    "id": id
                  });
                }
              });
            } else {
              iterate$1(self2.items, (_, id) => {
                search.items.push({
                  "score": 1,
                  "id": id
                });
              });
            }
            const fn_sort = self2._getSortFunction(search);
            if (fn_sort)
              search.items.sort(fn_sort);
            search.total = search.items.length;
            if (typeof options.limit === "number") {
              search.items = search.items.slice(0, options.limit);
            }
            return search;
          }
        }
        const iterate = (object, callback) => {
          if (Array.isArray(object)) {
            object.forEach(callback);
          } else {
            for (var key in object) {
              if (object.hasOwnProperty(key)) {
                callback(object[key], key);
              }
            }
          }
        };
        const getDom = (query) => {
          if (query.jquery) {
            return query[0];
          }
          if (query instanceof HTMLElement) {
            return query;
          }
          if (isHtmlString(query)) {
            var tpl = document.createElement("template");
            tpl.innerHTML = query.trim();
            return tpl.content.firstChild;
          }
          return document.querySelector(query);
        };
        const isHtmlString = (arg) => {
          if (typeof arg === "string" && arg.indexOf("<") > -1) {
            return true;
          }
          return false;
        };
        const escapeQuery = (query) => {
          return query.replace(/['"\\]/g, "\\$&");
        };
        const triggerEvent = (dom_el, event_name) => {
          var event = document.createEvent("HTMLEvents");
          event.initEvent(event_name, true, false);
          dom_el.dispatchEvent(event);
        };
        const applyCSS = (dom_el, css) => {
          Object.assign(dom_el.style, css);
        };
        const addClasses = (elmts, ...classes) => {
          var norm_classes = classesArray(classes);
          elmts = castAsArray(elmts);
          elmts.map((el) => {
            norm_classes.map((cls) => {
              el.classList.add(cls);
            });
          });
        };
        const removeClasses = (elmts, ...classes) => {
          var norm_classes = classesArray(classes);
          elmts = castAsArray(elmts);
          elmts.map((el) => {
            norm_classes.map((cls) => {
              el.classList.remove(cls);
            });
          });
        };
        const classesArray = (args) => {
          var classes = [];
          iterate(args, (_classes) => {
            if (typeof _classes === "string") {
              _classes = _classes.trim().split(/[\11\12\14\15\40]/);
            }
            if (Array.isArray(_classes)) {
              classes = classes.concat(_classes);
            }
          });
          return classes.filter(Boolean);
        };
        const castAsArray = (arg) => {
          if (!Array.isArray(arg)) {
            arg = [arg];
          }
          return arg;
        };
        const parentMatch = (target, selector, wrapper) => {
          if (wrapper && !wrapper.contains(target)) {
            return;
          }
          while (target && target.matches) {
            if (target.matches(selector)) {
              return target;
            }
            target = target.parentNode;
          }
        };
        const getTail = (list, direction = 0) => {
          if (direction > 0) {
            return list[list.length - 1];
          }
          return list[0];
        };
        const isEmptyObject = (obj) => {
          return Object.keys(obj).length === 0;
        };
        const nodeIndex = (el, amongst) => {
          if (!el)
            return -1;
          amongst = amongst || el.nodeName;
          var i = 0;
          while (el = el.previousElementSibling) {
            if (el.matches(amongst)) {
              i++;
            }
          }
          return i;
        };
        const setAttr = (el, attrs) => {
          iterate(attrs, (val2, attr) => {
            if (val2 == null) {
              el.removeAttribute(attr);
            } else {
              el.setAttribute(attr, "" + val2);
            }
          });
        };
        const replaceNode = (existing, replacement) => {
          if (existing.parentNode)
            existing.parentNode.replaceChild(replacement, existing);
        };
        const highlight = (element, regex) => {
          if (regex === null)
            return;
          if (typeof regex === "string") {
            if (!regex.length)
              return;
            regex = new RegExp(regex, "i");
          }
          const highlightText = (node) => {
            var match = node.data.match(regex);
            if (match && node.data.length > 0) {
              var spannode = document.createElement("span");
              spannode.className = "highlight";
              var middlebit = node.splitText(match.index);
              middlebit.splitText(match[0].length);
              var middleclone = middlebit.cloneNode(true);
              spannode.appendChild(middleclone);
              replaceNode(middlebit, spannode);
              return 1;
            }
            return 0;
          };
          const highlightChildren = (node) => {
            if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== "highlight" || node.tagName !== "SPAN")) {
              Array.from(node.childNodes).forEach((element2) => {
                highlightRecursive(element2);
              });
            }
          };
          const highlightRecursive = (node) => {
            if (node.nodeType === 3) {
              return highlightText(node);
            }
            highlightChildren(node);
            return 0;
          };
          highlightRecursive(element);
        };
        const removeHighlight = (el) => {
          var elements = el.querySelectorAll("span.highlight");
          Array.prototype.forEach.call(elements, function(el2) {
            var parent = el2.parentNode;
            parent.replaceChild(el2.firstChild, el2);
            parent.normalize();
          });
        };
        const KEY_A = 65;
        const KEY_RETURN = 13;
        const KEY_ESC = 27;
        const KEY_LEFT = 37;
        const KEY_UP = 38;
        const KEY_RIGHT = 39;
        const KEY_DOWN = 40;
        const KEY_BACKSPACE = 8;
        const KEY_DELETE = 46;
        const KEY_TAB = 9;
        const IS_MAC = typeof navigator === "undefined" ? false : /Mac/.test(navigator.userAgent);
        const KEY_SHORTCUT = IS_MAC ? "metaKey" : "ctrlKey";
        var defaults = {
          options: [],
          optgroups: [],
          plugins: [],
          delimiter: ",",
          splitOn: null,
          persist: true,
          diacritics: true,
          create: null,
          createOnBlur: false,
          createFilter: null,
          highlight: true,
          openOnFocus: true,
          shouldOpen: null,
          maxOptions: 50,
          maxItems: null,
          hideSelected: null,
          duplicates: false,
          addPrecedence: false,
          selectOnTab: false,
          preload: null,
          allowEmptyOption: false,
          refreshThrottle: 300,
          loadThrottle: 300,
          loadingClass: "loading",
          dataAttr: null,
          optgroupField: "optgroup",
          valueField: "value",
          labelField: "text",
          disabledField: "disabled",
          optgroupLabelField: "label",
          optgroupValueField: "value",
          lockOptgroupOrder: false,
          sortField: "$order",
          searchField: ["text"],
          searchConjunction: "and",
          mode: null,
          wrapperClass: "ts-wrapper",
          controlClass: "ts-control",
          dropdownClass: "ts-dropdown",
          dropdownContentClass: "ts-dropdown-content",
          itemClass: "item",
          optionClass: "option",
          dropdownParent: null,
          controlInput: '<input type="text" autocomplete="off" size="1" />',
          copyClassesToDropdown: false,
          placeholder: null,
          hidePlaceholder: null,
          shouldLoad: function(query) {
            return query.length > 0;
          },
          render: {}
        };
        const hash_key = (value) => {
          if (typeof value === "undefined" || value === null)
            return null;
          return get_hash(value);
        };
        const get_hash = (value) => {
          if (typeof value === "boolean")
            return value ? "1" : "0";
          return value + "";
        };
        const escape_html = (str) => {
          return (str + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
        };
        const timeout = (fn, timeout2) => {
          if (timeout2 > 0) {
            return setTimeout(fn, timeout2);
          }
          fn.call(null);
          return null;
        };
        const loadDebounce = (fn, delay) => {
          var timeout2;
          return function(value, callback) {
            var self2 = this;
            if (timeout2) {
              self2.loading = Math.max(self2.loading - 1, 0);
              clearTimeout(timeout2);
            }
            timeout2 = setTimeout(function() {
              timeout2 = null;
              self2.loadedSearches[value] = true;
              fn.call(self2, value, callback);
            }, delay);
          };
        };
        const debounce_events = (self2, types, fn) => {
          var type;
          var trigger = self2.trigger;
          var event_args = {};
          self2.trigger = function() {
            var type2 = arguments[0];
            if (types.indexOf(type2) !== -1) {
              event_args[type2] = arguments;
            } else {
              return trigger.apply(self2, arguments);
            }
          };
          fn.apply(self2, []);
          self2.trigger = trigger;
          for (type of types) {
            if (type in event_args) {
              trigger.apply(self2, event_args[type]);
            }
          }
        };
        const getSelection = (input) => {
          return {
            start: input.selectionStart || 0,
            length: (input.selectionEnd || 0) - (input.selectionStart || 0)
          };
        };
        const preventDefault = (evt, stop = false) => {
          if (evt) {
            evt.preventDefault();
            if (stop) {
              evt.stopPropagation();
            }
          }
        };
        const addEvent = (target, type, callback, options) => {
          target.addEventListener(type, callback, options);
        };
        const isKeyDown = (key_name, evt) => {
          if (!evt) {
            return false;
          }
          if (!evt[key_name]) {
            return false;
          }
          var count = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);
          if (count === 1) {
            return true;
          }
          return false;
        };
        const getId = (el, id) => {
          const existing_id = el.getAttribute("id");
          if (existing_id) {
            return existing_id;
          }
          el.setAttribute("id", id);
          return id;
        };
        const addSlashes = (str) => {
          return str.replace(/[\\"']/g, "\\$&");
        };
        const append = (parent, node) => {
          if (node)
            parent.append(node);
        };
        function getSettings(input, settings_user) {
          var settings = Object.assign({}, defaults, settings_user);
          var attr_data = settings.dataAttr;
          var field_label = settings.labelField;
          var field_value = settings.valueField;
          var field_disabled = settings.disabledField;
          var field_optgroup = settings.optgroupField;
          var field_optgroup_label = settings.optgroupLabelField;
          var field_optgroup_value = settings.optgroupValueField;
          var tag_name = input.tagName.toLowerCase();
          var placeholder = input.getAttribute("placeholder") || input.getAttribute("data-placeholder");
          if (!placeholder && !settings.allowEmptyOption) {
            let option = input.querySelector('option[value=""]');
            if (option) {
              placeholder = option.textContent;
            }
          }
          var settings_element = {
            placeholder,
            options: [],
            optgroups: [],
            items: [],
            maxItems: null
          };
          var init_select = () => {
            var tagName;
            var options = settings_element.options;
            var optionsMap = {};
            var group_count = 1;
            let $order = 0;
            var readData = (el) => {
              var data = Object.assign({}, el.dataset);
              var json = attr_data && data[attr_data];
              if (typeof json === "string" && json.length) {
                data = Object.assign(data, JSON.parse(json));
              }
              return data;
            };
            var addOption = (option, group) => {
              var value = hash_key(option.value);
              if (value == null)
                return;
              if (!value && !settings.allowEmptyOption)
                return;
              if (optionsMap.hasOwnProperty(value)) {
                if (group) {
                  var arr = optionsMap[value][field_optgroup];
                  if (!arr) {
                    optionsMap[value][field_optgroup] = group;
                  } else if (!Array.isArray(arr)) {
                    optionsMap[value][field_optgroup] = [arr, group];
                  } else {
                    arr.push(group);
                  }
                }
              } else {
                var option_data = readData(option);
                option_data[field_label] = option_data[field_label] || option.textContent;
                option_data[field_value] = option_data[field_value] || value;
                option_data[field_disabled] = option_data[field_disabled] || option.disabled;
                option_data[field_optgroup] = option_data[field_optgroup] || group;
                option_data.$option = option;
                option_data.$order = option_data.$order || ++$order;
                optionsMap[value] = option_data;
                options.push(option_data);
              }
              if (option.selected) {
                settings_element.items.push(value);
              }
            };
            var addGroup = (optgroup) => {
              var id, optgroup_data;
              optgroup_data = readData(optgroup);
              optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute("label") || "";
              optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;
              optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;
              optgroup_data.$order = optgroup_data.$order || ++$order;
              settings_element.optgroups.push(optgroup_data);
              id = optgroup_data[field_optgroup_value];
              iterate(optgroup.children, (option) => {
                addOption(option, id);
              });
            };
            settings_element.maxItems = input.hasAttribute("multiple") ? null : 1;
            iterate(input.children, (child) => {
              tagName = child.tagName.toLowerCase();
              if (tagName === "optgroup") {
                addGroup(child);
              } else if (tagName === "option") {
                addOption(child);
              }
            });
          };
          var init_textbox = () => {
            const data_raw = input.getAttribute(attr_data);
            if (!data_raw) {
              var value = input.value.trim() || "";
              if (!settings.allowEmptyOption && !value.length)
                return;
              const values = value.split(settings.delimiter);
              iterate(values, (value2) => {
                const option = {};
                option[field_label] = value2;
                option[field_value] = value2;
                settings_element.options.push(option);
              });
              settings_element.items = values;
            } else {
              settings_element.options = JSON.parse(data_raw);
              iterate(settings_element.options, (opt) => {
                settings_element.items.push(opt[field_value]);
              });
            }
          };
          if (tag_name === "select") {
            init_select();
          } else {
            init_textbox();
          }
          return Object.assign({}, defaults, settings_element, settings_user);
        }
        var instance_i = 0;
        class TomSelect4 extends MicroPlugin(MicroEvent) {
          constructor(input_arg, user_settings) {
            super();
            this.control_input = void 0;
            this.wrapper = void 0;
            this.dropdown = void 0;
            this.control = void 0;
            this.dropdown_content = void 0;
            this.focus_node = void 0;
            this.order = 0;
            this.settings = void 0;
            this.input = void 0;
            this.tabIndex = void 0;
            this.is_select_tag = void 0;
            this.rtl = void 0;
            this.inputId = void 0;
            this._destroy = void 0;
            this.sifter = void 0;
            this.isOpen = false;
            this.isDisabled = false;
            this.isReadOnly = false;
            this.isRequired = void 0;
            this.isInvalid = false;
            this.isValid = true;
            this.isLocked = false;
            this.isFocused = false;
            this.isInputHidden = false;
            this.isSetup = false;
            this.ignoreFocus = false;
            this.ignoreHover = false;
            this.hasOptions = false;
            this.currentResults = void 0;
            this.lastValue = "";
            this.caretPos = 0;
            this.loading = 0;
            this.loadedSearches = {};
            this.activeOption = null;
            this.activeItems = [];
            this.optgroups = {};
            this.options = {};
            this.userOptions = {};
            this.items = [];
            this.refreshTimeout = null;
            instance_i++;
            var dir;
            var input = getDom(input_arg);
            if (input.tomselect) {
              throw new Error("Tom Select already initialized on this element");
            }
            input.tomselect = this;
            var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
            dir = computedStyle.getPropertyValue("direction");
            const settings = getSettings(input, user_settings);
            this.settings = settings;
            this.input = input;
            this.tabIndex = input.tabIndex || 0;
            this.is_select_tag = input.tagName.toLowerCase() === "select";
            this.rtl = /rtl/i.test(dir);
            this.inputId = getId(input, "tomselect-" + instance_i);
            this.isRequired = input.required;
            this.sifter = new Sifter(this.options, {
              diacritics: settings.diacritics
            });
            settings.mode = settings.mode || (settings.maxItems === 1 ? "single" : "multi");
            if (typeof settings.hideSelected !== "boolean") {
              settings.hideSelected = settings.mode === "multi";
            }
            if (typeof settings.hidePlaceholder !== "boolean") {
              settings.hidePlaceholder = settings.mode !== "multi";
            }
            var filter = settings.createFilter;
            if (typeof filter !== "function") {
              if (typeof filter === "string") {
                filter = new RegExp(filter);
              }
              if (filter instanceof RegExp) {
                settings.createFilter = (input2) => filter.test(input2);
              } else {
                settings.createFilter = (value) => {
                  return this.settings.duplicates || !this.options[value];
                };
              }
            }
            this.initializePlugins(settings.plugins);
            this.setupCallbacks();
            this.setupTemplates();
            const wrapper = getDom("<div>");
            const control = getDom("<div>");
            const dropdown = this._render("dropdown");
            const dropdown_content = getDom(`<div role="listbox" tabindex="-1">`);
            const classes = this.input.getAttribute("class") || "";
            const inputMode = settings.mode;
            var control_input;
            addClasses(wrapper, settings.wrapperClass, classes, inputMode);
            addClasses(control, settings.controlClass);
            append(wrapper, control);
            addClasses(dropdown, settings.dropdownClass, inputMode);
            if (settings.copyClassesToDropdown) {
              addClasses(dropdown, classes);
            }
            addClasses(dropdown_content, settings.dropdownContentClass);
            append(dropdown, dropdown_content);
            getDom(settings.dropdownParent || wrapper).appendChild(dropdown);
            if (isHtmlString(settings.controlInput)) {
              control_input = getDom(settings.controlInput);
              var attrs = ["autocorrect", "autocapitalize", "autocomplete", "spellcheck"];
              iterate$1(attrs, (attr) => {
                if (input.getAttribute(attr)) {
                  setAttr(control_input, {
                    [attr]: input.getAttribute(attr)
                  });
                }
              });
              control_input.tabIndex = -1;
              control.appendChild(control_input);
              this.focus_node = control_input;
            } else if (settings.controlInput) {
              control_input = getDom(settings.controlInput);
              this.focus_node = control_input;
            } else {
              control_input = getDom("<input/>");
              this.focus_node = control;
            }
            this.wrapper = wrapper;
            this.dropdown = dropdown;
            this.dropdown_content = dropdown_content;
            this.control = control;
            this.control_input = control_input;
            this.setup();
          }
          setup() {
            const self2 = this;
            const settings = self2.settings;
            const control_input = self2.control_input;
            const dropdown = self2.dropdown;
            const dropdown_content = self2.dropdown_content;
            const wrapper = self2.wrapper;
            const control = self2.control;
            const input = self2.input;
            const focus_node = self2.focus_node;
            const passive_event = {
              passive: true
            };
            const listboxId = self2.inputId + "-ts-dropdown";
            setAttr(dropdown_content, {
              id: listboxId
            });
            setAttr(focus_node, {
              role: "combobox",
              "aria-haspopup": "listbox",
              "aria-expanded": "false",
              "aria-controls": listboxId
            });
            const control_id = getId(focus_node, self2.inputId + "-ts-control");
            const query = "label[for='" + escapeQuery(self2.inputId) + "']";
            const label = document.querySelector(query);
            const label_click = self2.focus.bind(self2);
            if (label) {
              addEvent(label, "click", label_click);
              setAttr(label, {
                for: control_id
              });
              const label_id = getId(label, self2.inputId + "-ts-label");
              setAttr(focus_node, {
                "aria-labelledby": label_id
              });
              setAttr(dropdown_content, {
                "aria-labelledby": label_id
              });
            }
            wrapper.style.width = input.style.width;
            if (self2.plugins.names.length) {
              const classes_plugins = "plugin-" + self2.plugins.names.join(" plugin-");
              addClasses([wrapper, dropdown], classes_plugins);
            }
            if ((settings.maxItems === null || settings.maxItems > 1) && self2.is_select_tag) {
              setAttr(input, {
                multiple: "multiple"
              });
            }
            if (settings.placeholder) {
              setAttr(control_input, {
                placeholder: settings.placeholder
              });
            }
            if (!settings.splitOn && settings.delimiter) {
              settings.splitOn = new RegExp("\\s*" + escape_regex(settings.delimiter) + "+\\s*");
            }
            if (settings.load && settings.loadThrottle) {
              settings.load = loadDebounce(settings.load, settings.loadThrottle);
            }
            addEvent(dropdown, "mousemove", () => {
              self2.ignoreHover = false;
            });
            addEvent(dropdown, "mouseenter", (e) => {
              var target_match = parentMatch(e.target, "[data-selectable]", dropdown);
              if (target_match)
                self2.onOptionHover(e, target_match);
            }, {
              capture: true
            });
            addEvent(dropdown, "click", (evt) => {
              const option = parentMatch(evt.target, "[data-selectable]");
              if (option) {
                self2.onOptionSelect(evt, option);
                preventDefault(evt, true);
              }
            });
            addEvent(control, "click", (evt) => {
              var target_match = parentMatch(evt.target, "[data-ts-item]", control);
              if (target_match && self2.onItemSelect(evt, target_match)) {
                preventDefault(evt, true);
                return;
              }
              if (control_input.value != "") {
                return;
              }
              self2.onClick();
              preventDefault(evt, true);
            });
            addEvent(focus_node, "keydown", (e) => self2.onKeyDown(e));
            addEvent(control_input, "keypress", (e) => self2.onKeyPress(e));
            addEvent(control_input, "input", (e) => self2.onInput(e));
            addEvent(focus_node, "blur", (e) => self2.onBlur(e));
            addEvent(focus_node, "focus", (e) => self2.onFocus(e));
            addEvent(control_input, "paste", (e) => self2.onPaste(e));
            const doc_mousedown = (evt) => {
              const target = evt.composedPath()[0];
              if (!wrapper.contains(target) && !dropdown.contains(target)) {
                if (self2.isFocused) {
                  self2.blur();
                }
                self2.inputState();
                return;
              }
              if (target == control_input && self2.isOpen) {
                evt.stopPropagation();
              } else {
                preventDefault(evt, true);
              }
            };
            const win_scroll = () => {
              if (self2.isOpen) {
                self2.positionDropdown();
              }
            };
            addEvent(document, "mousedown", doc_mousedown);
            addEvent(window, "scroll", win_scroll, passive_event);
            addEvent(window, "resize", win_scroll, passive_event);
            this._destroy = () => {
              document.removeEventListener("mousedown", doc_mousedown);
              window.removeEventListener("scroll", win_scroll);
              window.removeEventListener("resize", win_scroll);
              if (label)
                label.removeEventListener("click", label_click);
            };
            this.revertSettings = {
              innerHTML: input.innerHTML,
              tabIndex: input.tabIndex
            };
            input.tabIndex = -1;
            input.insertAdjacentElement("afterend", self2.wrapper);
            self2.sync(false);
            settings.items = [];
            delete settings.optgroups;
            delete settings.options;
            addEvent(input, "invalid", () => {
              if (self2.isValid) {
                self2.isValid = false;
                self2.isInvalid = true;
                self2.refreshState();
              }
            });
            self2.updateOriginalInput();
            self2.refreshItems();
            self2.close(false);
            self2.inputState();
            self2.isSetup = true;
            if (input.disabled) {
              self2.disable();
            } else if (input.readOnly) {
              self2.setReadOnly(true);
            } else {
              self2.enable();
            }
            self2.on("change", this.onChange);
            addClasses(input, "tomselected", "ts-hidden-accessible");
            self2.trigger("initialize");
            if (settings.preload === true) {
              self2.preload();
            }
          }
          setupOptions(options = [], optgroups = []) {
            this.addOptions(options);
            iterate$1(optgroups, (optgroup) => {
              this.registerOptionGroup(optgroup);
            });
          }
          setupTemplates() {
            var self2 = this;
            var field_label = self2.settings.labelField;
            var field_optgroup = self2.settings.optgroupLabelField;
            var templates = {
              "optgroup": (data) => {
                let optgroup = document.createElement("div");
                optgroup.className = "optgroup";
                optgroup.appendChild(data.options);
                return optgroup;
              },
              "optgroup_header": (data, escape) => {
                return '<div class="optgroup-header">' + escape(data[field_optgroup]) + "</div>";
              },
              "option": (data, escape) => {
                return "<div>" + escape(data[field_label]) + "</div>";
              },
              "item": (data, escape) => {
                return "<div>" + escape(data[field_label]) + "</div>";
              },
              "option_create": (data, escape) => {
                return '<div class="create">Add <strong>' + escape(data.input) + "</strong>&hellip;</div>";
              },
              "no_results": () => {
                return '<div class="no-results">No results found</div>';
              },
              "loading": () => {
                return '<div class="spinner"></div>';
              },
              "not_loading": () => {
              },
              "dropdown": () => {
                return "<div></div>";
              }
            };
            self2.settings.render = Object.assign({}, templates, self2.settings.render);
          }
          setupCallbacks() {
            var key, fn;
            var callbacks = {
              "initialize": "onInitialize",
              "change": "onChange",
              "item_add": "onItemAdd",
              "item_remove": "onItemRemove",
              "item_select": "onItemSelect",
              "clear": "onClear",
              "option_add": "onOptionAdd",
              "option_remove": "onOptionRemove",
              "option_clear": "onOptionClear",
              "optgroup_add": "onOptionGroupAdd",
              "optgroup_remove": "onOptionGroupRemove",
              "optgroup_clear": "onOptionGroupClear",
              "dropdown_open": "onDropdownOpen",
              "dropdown_close": "onDropdownClose",
              "type": "onType",
              "load": "onLoad",
              "focus": "onFocus",
              "blur": "onBlur"
            };
            for (key in callbacks) {
              fn = this.settings[callbacks[key]];
              if (fn)
                this.on(key, fn);
            }
          }
          sync(get_settings = true) {
            const self2 = this;
            const settings = get_settings ? getSettings(self2.input, {
              delimiter: self2.settings.delimiter
            }) : self2.settings;
            self2.setupOptions(settings.options, settings.optgroups);
            self2.setValue(settings.items || [], true);
            self2.lastQuery = null;
          }
          onClick() {
            var self2 = this;
            if (self2.activeItems.length > 0) {
              self2.clearActiveItems();
              self2.focus();
              return;
            }
            if (self2.isFocused && self2.isOpen) {
              self2.blur();
            } else {
              self2.focus();
            }
          }
          onMouseDown() {
          }
          onChange() {
            triggerEvent(this.input, "input");
            triggerEvent(this.input, "change");
          }
          onPaste(e) {
            var self2 = this;
            if (self2.isInputHidden || self2.isLocked) {
              preventDefault(e);
              return;
            }
            if (!self2.settings.splitOn) {
              return;
            }
            setTimeout(() => {
              var pastedText = self2.inputValue();
              if (!pastedText.match(self2.settings.splitOn)) {
                return;
              }
              var splitInput = pastedText.trim().split(self2.settings.splitOn);
              iterate$1(splitInput, (piece) => {
                const hash = hash_key(piece);
                if (hash) {
                  if (this.options[piece]) {
                    self2.addItem(piece);
                  } else {
                    self2.createItem(piece);
                  }
                }
              });
            }, 0);
          }
          onKeyPress(e) {
            var self2 = this;
            if (self2.isLocked) {
              preventDefault(e);
              return;
            }
            var character = String.fromCharCode(e.keyCode || e.which);
            if (self2.settings.create && self2.settings.mode === "multi" && character === self2.settings.delimiter) {
              self2.createItem();
              preventDefault(e);
              return;
            }
          }
          onKeyDown(e) {
            var self2 = this;
            self2.ignoreHover = true;
            if (self2.isLocked) {
              if (e.keyCode !== KEY_TAB) {
                preventDefault(e);
              }
              return;
            }
            switch (e.keyCode) {
              case KEY_A:
                if (isKeyDown(KEY_SHORTCUT, e)) {
                  if (self2.control_input.value == "") {
                    preventDefault(e);
                    self2.selectAll();
                    return;
                  }
                }
                break;
              case KEY_ESC:
                if (self2.isOpen) {
                  preventDefault(e, true);
                  self2.close();
                }
                self2.clearActiveItems();
                return;
              case KEY_DOWN:
                if (!self2.isOpen && self2.hasOptions) {
                  self2.open();
                } else if (self2.activeOption) {
                  let next = self2.getAdjacent(self2.activeOption, 1);
                  if (next)
                    self2.setActiveOption(next);
                }
                preventDefault(e);
                return;
              case KEY_UP:
                if (self2.activeOption) {
                  let prev = self2.getAdjacent(self2.activeOption, -1);
                  if (prev)
                    self2.setActiveOption(prev);
                }
                preventDefault(e);
                return;
              case KEY_RETURN:
                if (self2.canSelect(self2.activeOption)) {
                  self2.onOptionSelect(e, self2.activeOption);
                  preventDefault(e);
                } else if (self2.settings.create && self2.createItem()) {
                  preventDefault(e);
                } else if (document.activeElement == self2.control_input && self2.isOpen) {
                  preventDefault(e);
                }
                return;
              case KEY_LEFT:
                self2.advanceSelection(-1, e);
                return;
              case KEY_RIGHT:
                self2.advanceSelection(1, e);
                return;
              case KEY_TAB:
                if (self2.settings.selectOnTab) {
                  if (self2.canSelect(self2.activeOption)) {
                    self2.onOptionSelect(e, self2.activeOption);
                    preventDefault(e);
                  }
                  if (self2.settings.create && self2.createItem()) {
                    preventDefault(e);
                  }
                }
                return;
              case KEY_BACKSPACE:
              case KEY_DELETE:
                self2.deleteSelection(e);
                return;
            }
            if (self2.isInputHidden && !isKeyDown(KEY_SHORTCUT, e)) {
              preventDefault(e);
            }
          }
          onInput(e) {
            if (this.isLocked) {
              return;
            }
            const value = this.inputValue();
            if (this.lastValue === value)
              return;
            this.lastValue = value;
            if (value == "") {
              this._onInput();
              return;
            }
            if (this.refreshTimeout) {
              clearTimeout(this.refreshTimeout);
            }
            this.refreshTimeout = timeout(() => {
              this.refreshTimeout = null;
              this._onInput();
            }, this.settings.refreshThrottle);
          }
          _onInput() {
            const value = this.lastValue;
            if (this.settings.shouldLoad.call(this, value)) {
              this.load(value);
            }
            this.refreshOptions();
            this.trigger("type", value);
          }
          onOptionHover(evt, option) {
            if (this.ignoreHover)
              return;
            this.setActiveOption(option, false);
          }
          onFocus(e) {
            var self2 = this;
            var wasFocused = self2.isFocused;
            if (self2.isDisabled || self2.isReadOnly) {
              self2.blur();
              preventDefault(e);
              return;
            }
            if (self2.ignoreFocus)
              return;
            self2.isFocused = true;
            if (self2.settings.preload === "focus")
              self2.preload();
            if (!wasFocused)
              self2.trigger("focus");
            if (!self2.activeItems.length) {
              self2.inputState();
              self2.refreshOptions(!!self2.settings.openOnFocus);
            }
            self2.refreshState();
          }
          onBlur(e) {
            if (document.hasFocus() === false)
              return;
            var self2 = this;
            if (!self2.isFocused)
              return;
            self2.isFocused = false;
            self2.ignoreFocus = false;
            var deactivate = () => {
              self2.close();
              self2.setActiveItem();
              self2.setCaret(self2.items.length);
              self2.trigger("blur");
            };
            if (self2.settings.create && self2.settings.createOnBlur) {
              self2.createItem(null, deactivate);
            } else {
              deactivate();
            }
          }
          onOptionSelect(evt, option) {
            var value, self2 = this;
            if (option.parentElement && option.parentElement.matches("[data-disabled]")) {
              return;
            }
            if (option.classList.contains("create")) {
              self2.createItem(null, () => {
                if (self2.settings.closeAfterSelect) {
                  self2.close();
                }
              });
            } else {
              value = option.dataset.value;
              if (typeof value !== "undefined") {
                self2.lastQuery = null;
                self2.addItem(value);
                if (self2.settings.closeAfterSelect) {
                  self2.close();
                }
                if (!self2.settings.hideSelected && evt.type && /click/.test(evt.type)) {
                  self2.setActiveOption(option);
                }
              }
            }
          }
          canSelect(option) {
            if (this.isOpen && option && this.dropdown_content.contains(option)) {
              return true;
            }
            return false;
          }
          onItemSelect(evt, item) {
            var self2 = this;
            if (!self2.isLocked && self2.settings.mode === "multi") {
              preventDefault(evt);
              self2.setActiveItem(item, evt);
              return true;
            }
            return false;
          }
          canLoad(value) {
            if (!this.settings.load)
              return false;
            if (this.loadedSearches.hasOwnProperty(value))
              return false;
            return true;
          }
          load(value) {
            const self2 = this;
            if (!self2.canLoad(value))
              return;
            addClasses(self2.wrapper, self2.settings.loadingClass);
            self2.loading++;
            const callback = self2.loadCallback.bind(self2);
            self2.settings.load.call(self2, value, callback);
          }
          loadCallback(options, optgroups) {
            const self2 = this;
            self2.loading = Math.max(self2.loading - 1, 0);
            self2.lastQuery = null;
            self2.clearActiveOption();
            self2.setupOptions(options, optgroups);
            self2.refreshOptions(self2.isFocused && !self2.isInputHidden);
            if (!self2.loading) {
              removeClasses(self2.wrapper, self2.settings.loadingClass);
            }
            self2.trigger("load", options, optgroups);
          }
          preload() {
            var classList = this.wrapper.classList;
            if (classList.contains("preloaded"))
              return;
            classList.add("preloaded");
            this.load("");
          }
          setTextboxValue(value = "") {
            var input = this.control_input;
            var changed = input.value !== value;
            if (changed) {
              input.value = value;
              triggerEvent(input, "update");
              this.lastValue = value;
            }
          }
          getValue() {
            if (this.is_select_tag && this.input.hasAttribute("multiple")) {
              return this.items;
            }
            return this.items.join(this.settings.delimiter);
          }
          setValue(value, silent) {
            var events = silent ? [] : ["change"];
            debounce_events(this, events, () => {
              this.clear(silent);
              this.addItems(value, silent);
            });
          }
          setMaxItems(value) {
            if (value === 0)
              value = null;
            this.settings.maxItems = value;
            this.refreshState();
          }
          setActiveItem(item, e) {
            var self2 = this;
            var eventName;
            var i, begin, end, swap;
            var last;
            if (self2.settings.mode === "single")
              return;
            if (!item) {
              self2.clearActiveItems();
              if (self2.isFocused) {
                self2.inputState();
              }
              return;
            }
            eventName = e && e.type.toLowerCase();
            if (eventName === "click" && isKeyDown("shiftKey", e) && self2.activeItems.length) {
              last = self2.getLastActive();
              begin = Array.prototype.indexOf.call(self2.control.children, last);
              end = Array.prototype.indexOf.call(self2.control.children, item);
              if (begin > end) {
                swap = begin;
                begin = end;
                end = swap;
              }
              for (i = begin; i <= end; i++) {
                item = self2.control.children[i];
                if (self2.activeItems.indexOf(item) === -1) {
                  self2.setActiveItemClass(item);
                }
              }
              preventDefault(e);
            } else if (eventName === "click" && isKeyDown(KEY_SHORTCUT, e) || eventName === "keydown" && isKeyDown("shiftKey", e)) {
              if (item.classList.contains("active")) {
                self2.removeActiveItem(item);
              } else {
                self2.setActiveItemClass(item);
              }
            } else {
              self2.clearActiveItems();
              self2.setActiveItemClass(item);
            }
            self2.inputState();
            if (!self2.isFocused) {
              self2.focus();
            }
          }
          setActiveItemClass(item) {
            const self2 = this;
            const last_active = self2.control.querySelector(".last-active");
            if (last_active)
              removeClasses(last_active, "last-active");
            addClasses(item, "active last-active");
            self2.trigger("item_select", item);
            if (self2.activeItems.indexOf(item) == -1) {
              self2.activeItems.push(item);
            }
          }
          removeActiveItem(item) {
            var idx = this.activeItems.indexOf(item);
            this.activeItems.splice(idx, 1);
            removeClasses(item, "active");
          }
          clearActiveItems() {
            removeClasses(this.activeItems, "active");
            this.activeItems = [];
          }
          setActiveOption(option, scroll2 = true) {
            if (option === this.activeOption) {
              return;
            }
            this.clearActiveOption();
            if (!option)
              return;
            this.activeOption = option;
            setAttr(this.focus_node, {
              "aria-activedescendant": option.getAttribute("id")
            });
            setAttr(option, {
              "aria-selected": "true"
            });
            addClasses(option, "active");
            if (scroll2)
              this.scrollToOption(option);
          }
          scrollToOption(option, behavior) {
            if (!option)
              return;
            const content = this.dropdown_content;
            const height_menu = content.clientHeight;
            const scrollTop = content.scrollTop || 0;
            const height_item = option.offsetHeight;
            const y = option.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;
            if (y + height_item > height_menu + scrollTop) {
              this.scroll(y - height_menu + height_item, behavior);
            } else if (y < scrollTop) {
              this.scroll(y, behavior);
            }
          }
          scroll(scrollTop, behavior) {
            const content = this.dropdown_content;
            if (behavior) {
              content.style.scrollBehavior = behavior;
            }
            content.scrollTop = scrollTop;
            content.style.scrollBehavior = "";
          }
          clearActiveOption() {
            if (this.activeOption) {
              removeClasses(this.activeOption, "active");
              setAttr(this.activeOption, {
                "aria-selected": null
              });
            }
            this.activeOption = null;
            setAttr(this.focus_node, {
              "aria-activedescendant": null
            });
          }
          selectAll() {
            const self2 = this;
            if (self2.settings.mode === "single")
              return;
            const activeItems = self2.controlChildren();
            if (!activeItems.length)
              return;
            self2.inputState();
            self2.close();
            self2.activeItems = activeItems;
            iterate$1(activeItems, (item) => {
              self2.setActiveItemClass(item);
            });
          }
          inputState() {
            var self2 = this;
            if (!self2.control.contains(self2.control_input))
              return;
            setAttr(self2.control_input, {
              placeholder: self2.settings.placeholder
            });
            if (self2.activeItems.length > 0 || !self2.isFocused && self2.settings.hidePlaceholder && self2.items.length > 0) {
              self2.setTextboxValue();
              self2.isInputHidden = true;
            } else {
              if (self2.settings.hidePlaceholder && self2.items.length > 0) {
                setAttr(self2.control_input, {
                  placeholder: ""
                });
              }
              self2.isInputHidden = false;
            }
            self2.wrapper.classList.toggle("input-hidden", self2.isInputHidden);
          }
          inputValue() {
            return this.control_input.value.trim();
          }
          focus() {
            var self2 = this;
            if (self2.isDisabled || self2.isReadOnly)
              return;
            self2.ignoreFocus = true;
            if (self2.control_input.offsetWidth) {
              self2.control_input.focus();
            } else {
              self2.focus_node.focus();
            }
            setTimeout(() => {
              self2.ignoreFocus = false;
              self2.onFocus();
            }, 0);
          }
          blur() {
            this.focus_node.blur();
            this.onBlur();
          }
          getScoreFunction(query) {
            return this.sifter.getScoreFunction(query, this.getSearchOptions());
          }
          getSearchOptions() {
            var settings = this.settings;
            var sort = settings.sortField;
            if (typeof settings.sortField === "string") {
              sort = [{
                field: settings.sortField
              }];
            }
            return {
              fields: settings.searchField,
              conjunction: settings.searchConjunction,
              sort,
              nesting: settings.nesting
            };
          }
          search(query) {
            var result, calculateScore;
            var self2 = this;
            var options = this.getSearchOptions();
            if (self2.settings.score) {
              calculateScore = self2.settings.score.call(self2, query);
              if (typeof calculateScore !== "function") {
                throw new Error('Tom Select "score" setting must be a function that returns a function');
              }
            }
            if (query !== self2.lastQuery) {
              self2.lastQuery = query;
              result = self2.sifter.search(query, Object.assign(options, {
                score: calculateScore
              }));
              self2.currentResults = result;
            } else {
              result = Object.assign({}, self2.currentResults);
            }
            if (self2.settings.hideSelected) {
              result.items = result.items.filter((item) => {
                let hashed = hash_key(item.id);
                return !(hashed && self2.items.indexOf(hashed) !== -1);
              });
            }
            return result;
          }
          refreshOptions(triggerDropdown = true) {
            var i, j, k, n, optgroup, optgroups, html, has_create_option, active_group;
            var create;
            const groups = {};
            const groups_order = [];
            var self2 = this;
            var query = self2.inputValue();
            const same_query = query === self2.lastQuery || query == "" && self2.lastQuery == null;
            var results = self2.search(query);
            var active_option = null;
            var show_dropdown = self2.settings.shouldOpen || false;
            var dropdown_content = self2.dropdown_content;
            if (same_query) {
              active_option = self2.activeOption;
              if (active_option) {
                active_group = active_option.closest("[data-group]");
              }
            }
            n = results.items.length;
            if (typeof self2.settings.maxOptions === "number") {
              n = Math.min(n, self2.settings.maxOptions);
            }
            if (n > 0) {
              show_dropdown = true;
            }
            const getGroupFragment = (optgroup2, order) => {
              let group_order_i = groups[optgroup2];
              if (group_order_i !== void 0) {
                let order_group = groups_order[group_order_i];
                if (order_group !== void 0) {
                  return [group_order_i, order_group.fragment];
                }
              }
              let group_fragment = document.createDocumentFragment();
              group_order_i = groups_order.length;
              groups_order.push({
                fragment: group_fragment,
                order,
                optgroup: optgroup2
              });
              return [group_order_i, group_fragment];
            };
            for (i = 0; i < n; i++) {
              let item = results.items[i];
              if (!item)
                continue;
              let opt_value = item.id;
              let option = self2.options[opt_value];
              if (option === void 0)
                continue;
              let opt_hash = get_hash(opt_value);
              let option_el = self2.getOption(opt_hash, true);
              if (!self2.settings.hideSelected) {
                option_el.classList.toggle("selected", self2.items.includes(opt_hash));
              }
              optgroup = option[self2.settings.optgroupField] || "";
              optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];
              for (j = 0, k = optgroups && optgroups.length; j < k; j++) {
                optgroup = optgroups[j];
                let order = option.$order;
                let self_optgroup = self2.optgroups[optgroup];
                if (self_optgroup === void 0) {
                  optgroup = "";
                } else {
                  order = self_optgroup.$order;
                }
                const [group_order_i, group_fragment] = getGroupFragment(optgroup, order);
                if (j > 0) {
                  option_el = option_el.cloneNode(true);
                  setAttr(option_el, {
                    id: option.$id + "-clone-" + j,
                    "aria-selected": null
                  });
                  option_el.classList.add("ts-cloned");
                  removeClasses(option_el, "active");
                  if (self2.activeOption && self2.activeOption.dataset.value == opt_value) {
                    if (active_group && active_group.dataset.group === optgroup.toString()) {
                      active_option = option_el;
                    }
                  }
                }
                group_fragment.appendChild(option_el);
                if (optgroup != "") {
                  groups[optgroup] = group_order_i;
                }
              }
            }
            if (self2.settings.lockOptgroupOrder) {
              groups_order.sort((a, b) => {
                return a.order - b.order;
              });
            }
            html = document.createDocumentFragment();
            iterate$1(groups_order, (group_order) => {
              let group_fragment = group_order.fragment;
              let optgroup2 = group_order.optgroup;
              if (!group_fragment || !group_fragment.children.length)
                return;
              let group_heading = self2.optgroups[optgroup2];
              if (group_heading !== void 0) {
                let group_options = document.createDocumentFragment();
                let header = self2.render("optgroup_header", group_heading);
                append(group_options, header);
                append(group_options, group_fragment);
                let group_html = self2.render("optgroup", {
                  group: group_heading,
                  options: group_options
                });
                append(html, group_html);
              } else {
                append(html, group_fragment);
              }
            });
            dropdown_content.innerHTML = "";
            append(dropdown_content, html);
            if (self2.settings.highlight) {
              removeHighlight(dropdown_content);
              if (results.query.length && results.tokens.length) {
                iterate$1(results.tokens, (tok) => {
                  highlight(dropdown_content, tok.regex);
                });
              }
            }
            var add_template = (template) => {
              let content = self2.render(template, {
                input: query
              });
              if (content) {
                show_dropdown = true;
                dropdown_content.insertBefore(content, dropdown_content.firstChild);
              }
              return content;
            };
            if (self2.loading) {
              add_template("loading");
            } else if (!self2.settings.shouldLoad.call(self2, query)) {
              add_template("not_loading");
            } else if (results.items.length === 0) {
              add_template("no_results");
            }
            has_create_option = self2.canCreate(query);
            if (has_create_option) {
              create = add_template("option_create");
            }
            self2.hasOptions = results.items.length > 0 || has_create_option;
            if (show_dropdown) {
              if (results.items.length > 0) {
                if (!active_option && self2.settings.mode === "single" && self2.items[0] != void 0) {
                  active_option = self2.getOption(self2.items[0]);
                }
                if (!dropdown_content.contains(active_option)) {
                  let active_index = 0;
                  if (create && !self2.settings.addPrecedence) {
                    active_index = 1;
                  }
                  active_option = self2.selectable()[active_index];
                }
              } else if (create) {
                active_option = create;
              }
              if (triggerDropdown && !self2.isOpen) {
                self2.open();
                self2.scrollToOption(active_option, "auto");
              }
              self2.setActiveOption(active_option);
            } else {
              self2.clearActiveOption();
              if (triggerDropdown && self2.isOpen) {
                self2.close(false);
              }
            }
          }
          selectable() {
            return this.dropdown_content.querySelectorAll("[data-selectable]");
          }
          addOption(data, user_created = false) {
            const self2 = this;
            if (Array.isArray(data)) {
              self2.addOptions(data, user_created);
              return false;
            }
            const key = hash_key(data[self2.settings.valueField]);
            if (key === null || self2.options.hasOwnProperty(key)) {
              return false;
            }
            data.$order = data.$order || ++self2.order;
            data.$id = self2.inputId + "-opt-" + data.$order;
            self2.options[key] = data;
            self2.lastQuery = null;
            if (user_created) {
              self2.userOptions[key] = user_created;
              self2.trigger("option_add", key, data);
            }
            return key;
          }
          addOptions(data, user_created = false) {
            iterate$1(data, (dat) => {
              this.addOption(dat, user_created);
            });
          }
          registerOption(data) {
            return this.addOption(data);
          }
          registerOptionGroup(data) {
            var key = hash_key(data[this.settings.optgroupValueField]);
            if (key === null)
              return false;
            data.$order = data.$order || ++this.order;
            this.optgroups[key] = data;
            return key;
          }
          addOptionGroup(id, data) {
            var hashed_id;
            data[this.settings.optgroupValueField] = id;
            if (hashed_id = this.registerOptionGroup(data)) {
              this.trigger("optgroup_add", hashed_id, data);
            }
          }
          removeOptionGroup(id) {
            if (this.optgroups.hasOwnProperty(id)) {
              delete this.optgroups[id];
              this.clearCache();
              this.trigger("optgroup_remove", id);
            }
          }
          clearOptionGroups() {
            this.optgroups = {};
            this.clearCache();
            this.trigger("optgroup_clear");
          }
          updateOption(value, data) {
            const self2 = this;
            var item_new;
            var index_item;
            const value_old = hash_key(value);
            const value_new = hash_key(data[self2.settings.valueField]);
            if (value_old === null)
              return;
            const data_old = self2.options[value_old];
            if (data_old == void 0)
              return;
            if (typeof value_new !== "string")
              throw new Error("Value must be set in option data");
            const option = self2.getOption(value_old);
            const item = self2.getItem(value_old);
            data.$order = data.$order || data_old.$order;
            delete self2.options[value_old];
            self2.uncacheValue(value_new);
            self2.options[value_new] = data;
            if (option) {
              if (self2.dropdown_content.contains(option)) {
                const option_new = self2._render("option", data);
                replaceNode(option, option_new);
                if (self2.activeOption === option) {
                  self2.setActiveOption(option_new);
                }
              }
              option.remove();
            }
            if (item) {
              index_item = self2.items.indexOf(value_old);
              if (index_item !== -1) {
                self2.items.splice(index_item, 1, value_new);
              }
              item_new = self2._render("item", data);
              if (item.classList.contains("active"))
                addClasses(item_new, "active");
              replaceNode(item, item_new);
            }
            self2.lastQuery = null;
          }
          removeOption(value, silent) {
            const self2 = this;
            value = get_hash(value);
            self2.uncacheValue(value);
            delete self2.userOptions[value];
            delete self2.options[value];
            self2.lastQuery = null;
            self2.trigger("option_remove", value);
            self2.removeItem(value, silent);
          }
          clearOptions(filter) {
            const boundFilter = (filter || this.clearFilter).bind(this);
            this.loadedSearches = {};
            this.userOptions = {};
            this.clearCache();
            const selected = {};
            iterate$1(this.options, (option, key) => {
              if (boundFilter(option, key)) {
                selected[key] = option;
              }
            });
            this.options = this.sifter.items = selected;
            this.lastQuery = null;
            this.trigger("option_clear");
          }
          clearFilter(option, value) {
            if (this.items.indexOf(value) >= 0) {
              return true;
            }
            return false;
          }
          getOption(value, create = false) {
            const hashed = hash_key(value);
            if (hashed === null)
              return null;
            const option = this.options[hashed];
            if (option != void 0) {
              if (option.$div) {
                return option.$div;
              }
              if (create) {
                return this._render("option", option);
              }
            }
            return null;
          }
          getAdjacent(option, direction, type = "option") {
            var self2 = this, all;
            if (!option) {
              return null;
            }
            if (type == "item") {
              all = self2.controlChildren();
            } else {
              all = self2.dropdown_content.querySelectorAll("[data-selectable]");
            }
            for (let i = 0; i < all.length; i++) {
              if (all[i] != option) {
                continue;
              }
              if (direction > 0) {
                return all[i + 1];
              }
              return all[i - 1];
            }
            return null;
          }
          getItem(item) {
            if (typeof item == "object") {
              return item;
            }
            var value = hash_key(item);
            return value !== null ? this.control.querySelector(`[data-value="${addSlashes(value)}"]`) : null;
          }
          addItems(values, silent) {
            var self2 = this;
            var items = Array.isArray(values) ? values : [values];
            items = items.filter((x) => self2.items.indexOf(x) === -1);
            const last_item = items[items.length - 1];
            items.forEach((item) => {
              self2.isPending = item !== last_item;
              self2.addItem(item, silent);
            });
          }
          addItem(value, silent) {
            var events = silent ? [] : ["change", "dropdown_close"];
            debounce_events(this, events, () => {
              var item, wasFull;
              const self2 = this;
              const inputMode = self2.settings.mode;
              const hashed = hash_key(value);
              if (hashed && self2.items.indexOf(hashed) !== -1) {
                if (inputMode === "single") {
                  self2.close();
                }
                if (inputMode === "single" || !self2.settings.duplicates) {
                  return;
                }
              }
              if (hashed === null || !self2.options.hasOwnProperty(hashed))
                return;
              if (inputMode === "single")
                self2.clear(silent);
              if (inputMode === "multi" && self2.isFull())
                return;
              item = self2._render("item", self2.options[hashed]);
              if (self2.control.contains(item)) {
                item = item.cloneNode(true);
              }
              wasFull = self2.isFull();
              self2.items.splice(self2.caretPos, 0, hashed);
              self2.insertAtCaret(item);
              if (self2.isSetup) {
                if (!self2.isPending && self2.settings.hideSelected) {
                  let option = self2.getOption(hashed);
                  let next = self2.getAdjacent(option, 1);
                  if (next) {
                    self2.setActiveOption(next);
                  }
                }
                if (!self2.isPending && !self2.settings.closeAfterSelect) {
                  self2.refreshOptions(self2.isFocused && inputMode !== "single");
                }
                if (self2.settings.closeAfterSelect != false && self2.isFull()) {
                  self2.close();
                } else if (!self2.isPending) {
                  self2.positionDropdown();
                }
                self2.trigger("item_add", hashed, item);
                if (!self2.isPending) {
                  self2.updateOriginalInput({
                    silent
                  });
                }
              }
              if (!self2.isPending || !wasFull && self2.isFull()) {
                self2.inputState();
                self2.refreshState();
              }
            });
          }
          removeItem(item = null, silent) {
            const self2 = this;
            item = self2.getItem(item);
            if (!item)
              return;
            var i, idx;
            const value = item.dataset.value;
            i = nodeIndex(item);
            item.remove();
            if (item.classList.contains("active")) {
              idx = self2.activeItems.indexOf(item);
              self2.activeItems.splice(idx, 1);
              removeClasses(item, "active");
            }
            self2.items.splice(i, 1);
            self2.lastQuery = null;
            if (!self2.settings.persist && self2.userOptions.hasOwnProperty(value)) {
              self2.removeOption(value, silent);
            }
            if (i < self2.caretPos) {
              self2.setCaret(self2.caretPos - 1);
            }
            self2.updateOriginalInput({
              silent
            });
            self2.refreshState();
            self2.positionDropdown();
            self2.trigger("item_remove", value, item);
          }
          createItem(input = null, callback = () => {
          }) {
            if (arguments.length === 3) {
              callback = arguments[2];
            }
            if (typeof callback != "function") {
              callback = () => {
              };
            }
            var self2 = this;
            var caret = self2.caretPos;
            var output;
            input = input || self2.inputValue();
            if (!self2.canCreate(input)) {
              callback();
              return false;
            }
            self2.lock();
            var created = false;
            var create = (data) => {
              self2.unlock();
              if (!data || typeof data !== "object")
                return callback();
              var value = hash_key(data[self2.settings.valueField]);
              if (typeof value !== "string") {
                return callback();
              }
              self2.setTextboxValue();
              self2.addOption(data, true);
              self2.setCaret(caret);
              self2.addItem(value);
              callback(data);
              created = true;
            };
            if (typeof self2.settings.create === "function") {
              output = self2.settings.create.call(this, input, create);
            } else {
              output = {
                [self2.settings.labelField]: input,
                [self2.settings.valueField]: input
              };
            }
            if (!created) {
              create(output);
            }
            return true;
          }
          refreshItems() {
            var self2 = this;
            self2.lastQuery = null;
            if (self2.isSetup) {
              self2.addItems(self2.items);
            }
            self2.updateOriginalInput();
            self2.refreshState();
          }
          refreshState() {
            const self2 = this;
            self2.refreshValidityState();
            const isFull = self2.isFull();
            const isLocked = self2.isLocked;
            self2.wrapper.classList.toggle("rtl", self2.rtl);
            const wrap_classList = self2.wrapper.classList;
            wrap_classList.toggle("focus", self2.isFocused);
            wrap_classList.toggle("disabled", self2.isDisabled);
            wrap_classList.toggle("readonly", self2.isReadOnly);
            wrap_classList.toggle("required", self2.isRequired);
            wrap_classList.toggle("invalid", !self2.isValid);
            wrap_classList.toggle("locked", isLocked);
            wrap_classList.toggle("full", isFull);
            wrap_classList.toggle("input-active", self2.isFocused && !self2.isInputHidden);
            wrap_classList.toggle("dropdown-active", self2.isOpen);
            wrap_classList.toggle("has-options", isEmptyObject(self2.options));
            wrap_classList.toggle("has-items", self2.items.length > 0);
          }
          refreshValidityState() {
            var self2 = this;
            if (!self2.input.validity) {
              return;
            }
            self2.isValid = self2.input.validity.valid;
            self2.isInvalid = !self2.isValid;
          }
          isFull() {
            return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
          }
          updateOriginalInput(opts = {}) {
            const self2 = this;
            var option, label;
            const empty_option = self2.input.querySelector('option[value=""]');
            if (self2.is_select_tag) {
              let AddSelected = function(option_el, value, label2) {
                if (!option_el) {
                  option_el = getDom('<option value="' + escape_html(value) + '">' + escape_html(label2) + "</option>");
                }
                if (option_el != empty_option) {
                  self2.input.append(option_el);
                }
                selected.push(option_el);
                if (option_el != empty_option || has_selected > 0) {
                  option_el.selected = true;
                }
                return option_el;
              };
              const selected = [];
              const has_selected = self2.input.querySelectorAll("option:checked").length;
              self2.input.querySelectorAll("option:checked").forEach((option_el) => {
                option_el.selected = false;
              });
              if (self2.items.length == 0 && self2.settings.mode == "single") {
                AddSelected(empty_option, "", "");
              } else {
                self2.items.forEach((value) => {
                  option = self2.options[value];
                  label = option[self2.settings.labelField] || "";
                  if (selected.includes(option.$option)) {
                    const reuse_opt = self2.input.querySelector(`option[value="${addSlashes(value)}"]:not(:checked)`);
                    AddSelected(reuse_opt, value, label);
                  } else {
                    option.$option = AddSelected(option.$option, value, label);
                  }
                });
              }
            } else {
              self2.input.value = self2.getValue();
            }
            if (self2.isSetup) {
              if (!opts.silent) {
                self2.trigger("change", self2.getValue());
              }
            }
          }
          open() {
            var self2 = this;
            if (self2.isLocked || self2.isOpen || self2.settings.mode === "multi" && self2.isFull())
              return;
            self2.isOpen = true;
            setAttr(self2.focus_node, {
              "aria-expanded": "true"
            });
            self2.refreshState();
            applyCSS(self2.dropdown, {
              visibility: "hidden",
              display: "block"
            });
            self2.positionDropdown();
            applyCSS(self2.dropdown, {
              visibility: "visible",
              display: "block"
            });
            self2.focus();
            self2.trigger("dropdown_open", self2.dropdown);
          }
          close(setTextboxValue = true) {
            var self2 = this;
            var trigger = self2.isOpen;
            if (setTextboxValue) {
              self2.setTextboxValue();
              if (self2.settings.mode === "single" && self2.items.length) {
                self2.inputState();
              }
            }
            self2.isOpen = false;
            setAttr(self2.focus_node, {
              "aria-expanded": "false"
            });
            applyCSS(self2.dropdown, {
              display: "none"
            });
            if (self2.settings.hideSelected) {
              self2.clearActiveOption();
            }
            self2.refreshState();
            if (trigger)
              self2.trigger("dropdown_close", self2.dropdown);
          }
          positionDropdown() {
            if (this.settings.dropdownParent !== "body") {
              return;
            }
            var context = this.control;
            var rect = context.getBoundingClientRect();
            var top = context.offsetHeight + rect.top + window.scrollY;
            var left = rect.left + window.scrollX;
            applyCSS(this.dropdown, {
              width: rect.width + "px",
              top: top + "px",
              left: left + "px"
            });
          }
          clear(silent) {
            var self2 = this;
            if (!self2.items.length)
              return;
            var items = self2.controlChildren();
            iterate$1(items, (item) => {
              self2.removeItem(item, true);
            });
            self2.inputState();
            if (!silent)
              self2.updateOriginalInput();
            self2.trigger("clear");
          }
          insertAtCaret(el) {
            const self2 = this;
            const caret = self2.caretPos;
            const target = self2.control;
            target.insertBefore(el, target.children[caret] || null);
            self2.setCaret(caret + 1);
          }
          deleteSelection(e) {
            var direction, selection, caret, tail;
            var self2 = this;
            direction = e && e.keyCode === KEY_BACKSPACE ? -1 : 1;
            selection = getSelection(self2.control_input);
            const rm_items = [];
            if (self2.activeItems.length) {
              tail = getTail(self2.activeItems, direction);
              caret = nodeIndex(tail);
              if (direction > 0) {
                caret++;
              }
              iterate$1(self2.activeItems, (item) => rm_items.push(item));
            } else if ((self2.isFocused || self2.settings.mode === "single") && self2.items.length) {
              const items = self2.controlChildren();
              let rm_item;
              if (direction < 0 && selection.start === 0 && selection.length === 0) {
                rm_item = items[self2.caretPos - 1];
              } else if (direction > 0 && selection.start === self2.inputValue().length) {
                rm_item = items[self2.caretPos];
              }
              if (rm_item !== void 0) {
                rm_items.push(rm_item);
              }
            }
            if (!self2.shouldDelete(rm_items, e)) {
              return false;
            }
            preventDefault(e, true);
            if (typeof caret !== "undefined") {
              self2.setCaret(caret);
            }
            while (rm_items.length) {
              self2.removeItem(rm_items.pop());
            }
            self2.inputState();
            self2.positionDropdown();
            self2.refreshOptions(false);
            return true;
          }
          shouldDelete(items, evt) {
            const values = items.map((item) => item.dataset.value);
            if (!values.length || typeof this.settings.onDelete === "function" && this.settings.onDelete(values, evt) === false) {
              return false;
            }
            return true;
          }
          advanceSelection(direction, e) {
            var last_active, adjacent, self2 = this;
            if (self2.rtl)
              direction *= -1;
            if (self2.inputValue().length)
              return;
            if (isKeyDown(KEY_SHORTCUT, e) || isKeyDown("shiftKey", e)) {
              last_active = self2.getLastActive(direction);
              if (last_active) {
                if (!last_active.classList.contains("active")) {
                  adjacent = last_active;
                } else {
                  adjacent = self2.getAdjacent(last_active, direction, "item");
                }
              } else if (direction > 0) {
                adjacent = self2.control_input.nextElementSibling;
              } else {
                adjacent = self2.control_input.previousElementSibling;
              }
              if (adjacent) {
                if (adjacent.classList.contains("active")) {
                  self2.removeActiveItem(last_active);
                }
                self2.setActiveItemClass(adjacent);
              }
            } else {
              self2.moveCaret(direction);
            }
          }
          moveCaret(direction) {
          }
          getLastActive(direction) {
            let last_active = this.control.querySelector(".last-active");
            if (last_active) {
              return last_active;
            }
            var result = this.control.querySelectorAll(".active");
            if (result) {
              return getTail(result, direction);
            }
          }
          setCaret(new_pos) {
            this.caretPos = this.items.length;
          }
          controlChildren() {
            return Array.from(this.control.querySelectorAll("[data-ts-item]"));
          }
          lock() {
            this.setLocked(true);
          }
          unlock() {
            this.setLocked(false);
          }
          setLocked(lock = this.isReadOnly || this.isDisabled) {
            this.isLocked = lock;
            this.refreshState();
          }
          disable() {
            this.setDisabled(true);
            this.close();
          }
          enable() {
            this.setDisabled(false);
          }
          setDisabled(disabled) {
            this.focus_node.tabIndex = disabled ? -1 : this.tabIndex;
            this.isDisabled = disabled;
            this.input.disabled = disabled;
            this.control_input.disabled = disabled;
            this.setLocked();
          }
          setReadOnly(isReadOnly) {
            this.isReadOnly = isReadOnly;
            this.input.readOnly = isReadOnly;
            this.control_input.readOnly = isReadOnly;
            this.setLocked();
          }
          destroy() {
            var self2 = this;
            var revertSettings = self2.revertSettings;
            self2.trigger("destroy");
            self2.off();
            self2.wrapper.remove();
            self2.dropdown.remove();
            self2.input.innerHTML = revertSettings.innerHTML;
            self2.input.tabIndex = revertSettings.tabIndex;
            removeClasses(self2.input, "tomselected", "ts-hidden-accessible");
            self2._destroy();
            delete self2.input.tomselect;
          }
          render(templateName, data) {
            var id, html;
            const self2 = this;
            if (typeof this.settings.render[templateName] !== "function") {
              return null;
            }
            html = self2.settings.render[templateName].call(this, data, escape_html);
            if (!html) {
              return null;
            }
            html = getDom(html);
            if (templateName === "option" || templateName === "option_create") {
              if (data[self2.settings.disabledField]) {
                setAttr(html, {
                  "aria-disabled": "true"
                });
              } else {
                setAttr(html, {
                  "data-selectable": ""
                });
              }
            } else if (templateName === "optgroup") {
              id = data.group[self2.settings.optgroupValueField];
              setAttr(html, {
                "data-group": id
              });
              if (data.group[self2.settings.disabledField]) {
                setAttr(html, {
                  "data-disabled": ""
                });
              }
            }
            if (templateName === "option" || templateName === "item") {
              const value = get_hash(data[self2.settings.valueField]);
              setAttr(html, {
                "data-value": value
              });
              if (templateName === "item") {
                addClasses(html, self2.settings.itemClass);
                setAttr(html, {
                  "data-ts-item": ""
                });
              } else {
                addClasses(html, self2.settings.optionClass);
                setAttr(html, {
                  role: "option",
                  id: data.$id
                });
                data.$div = html;
                self2.options[value] = data;
              }
            }
            return html;
          }
          _render(templateName, data) {
            const html = this.render(templateName, data);
            if (html == null) {
              throw "HTMLElement expected";
            }
            return html;
          }
          clearCache() {
            iterate$1(this.options, (option) => {
              if (option.$div) {
                option.$div.remove();
                delete option.$div;
              }
            });
          }
          uncacheValue(value) {
            const option_el = this.getOption(value);
            if (option_el)
              option_el.remove();
          }
          canCreate(input) {
            return this.settings.create && input.length > 0 && this.settings.createFilter.call(this, input);
          }
          hook(when, method, new_fn) {
            var self2 = this;
            var orig_method = self2[method];
            self2[method] = function() {
              var result, result_new;
              if (when === "after") {
                result = orig_method.apply(self2, arguments);
              }
              result_new = new_fn.apply(self2, arguments);
              if (when === "instead") {
                return result_new;
              }
              if (when === "before") {
                result = orig_method.apply(self2, arguments);
              }
              return result;
            };
          }
        }
        function change_listener() {
          addEvent(this.input, "change", () => {
            this.sync();
          });
        }
        function checkbox_options(userOptions) {
          var self2 = this;
          var orig_onOptionSelect = self2.onOptionSelect;
          self2.settings.hideSelected = false;
          const cbOptions = Object.assign({
            className: "tomselect-checkbox",
            checkedClassNames: void 0,
            uncheckedClassNames: void 0
          }, userOptions);
          var UpdateChecked = function UpdateChecked2(checkbox, toCheck) {
            if (toCheck) {
              checkbox.checked = true;
              if (cbOptions.uncheckedClassNames) {
                checkbox.classList.remove(...cbOptions.uncheckedClassNames);
              }
              if (cbOptions.checkedClassNames) {
                checkbox.classList.add(...cbOptions.checkedClassNames);
              }
            } else {
              checkbox.checked = false;
              if (cbOptions.checkedClassNames) {
                checkbox.classList.remove(...cbOptions.checkedClassNames);
              }
              if (cbOptions.uncheckedClassNames) {
                checkbox.classList.add(...cbOptions.uncheckedClassNames);
              }
            }
          };
          var UpdateCheckbox = function UpdateCheckbox2(option) {
            setTimeout(() => {
              var checkbox = option.querySelector("input." + cbOptions.className);
              if (checkbox instanceof HTMLInputElement) {
                UpdateChecked(checkbox, option.classList.contains("selected"));
              }
            }, 1);
          };
          self2.hook("after", "setupTemplates", () => {
            var orig_render_option = self2.settings.render.option;
            self2.settings.render.option = (data, escape_html2) => {
              var rendered = getDom(orig_render_option.call(self2, data, escape_html2));
              var checkbox = document.createElement("input");
              if (cbOptions.className) {
                checkbox.classList.add(cbOptions.className);
              }
              checkbox.addEventListener("click", function(evt) {
                preventDefault(evt);
              });
              checkbox.type = "checkbox";
              const hashed = hash_key(data[self2.settings.valueField]);
              UpdateChecked(checkbox, !!(hashed && self2.items.indexOf(hashed) > -1));
              rendered.prepend(checkbox);
              return rendered;
            };
          });
          self2.on("item_remove", (value) => {
            var option = self2.getOption(value);
            if (option) {
              option.classList.remove("selected");
              UpdateCheckbox(option);
            }
          });
          self2.on("item_add", (value) => {
            var option = self2.getOption(value);
            if (option) {
              UpdateCheckbox(option);
            }
          });
          self2.hook("instead", "onOptionSelect", (evt, option) => {
            if (option.classList.contains("selected")) {
              option.classList.remove("selected");
              self2.removeItem(option.dataset.value);
              self2.refreshOptions();
              preventDefault(evt, true);
              return;
            }
            orig_onOptionSelect.call(self2, evt, option);
            UpdateCheckbox(option);
          });
        }
        function clear_button(userOptions) {
          const self2 = this;
          const options = Object.assign({
            className: "clear-button",
            title: "Clear All",
            html: (data) => {
              return `<div class="${data.className}" title="${data.title}">&#10799;</div>`;
            }
          }, userOptions);
          self2.on("initialize", () => {
            var button = getDom(options.html(options));
            button.addEventListener("click", (evt) => {
              if (self2.isLocked)
                return;
              self2.clear();
              if (self2.settings.mode === "single" && self2.settings.allowEmptyOption) {
                self2.addItem("");
              }
              evt.preventDefault();
              evt.stopPropagation();
            });
            self2.control.appendChild(button);
          });
        }
        const insertAfter = (referenceNode, newNode) => {
          var _referenceNode$parent;
          (_referenceNode$parent = referenceNode.parentNode) == null || _referenceNode$parent.insertBefore(newNode, referenceNode.nextSibling);
        };
        const insertBefore = (referenceNode, newNode) => {
          var _referenceNode$parent2;
          (_referenceNode$parent2 = referenceNode.parentNode) == null || _referenceNode$parent2.insertBefore(newNode, referenceNode);
        };
        const isBefore = (referenceNode, newNode) => {
          do {
            var _newNode;
            newNode = (_newNode = newNode) == null ? void 0 : _newNode.previousElementSibling;
            if (referenceNode == newNode) {
              return true;
            }
          } while (newNode && newNode.previousElementSibling);
          return false;
        };
        function drag_drop() {
          var self2 = this;
          if (self2.settings.mode !== "multi")
            return;
          var orig_lock = self2.lock;
          var orig_unlock = self2.unlock;
          let sortable = true;
          let drag_item;
          self2.hook("after", "setupTemplates", () => {
            var orig_render_item = self2.settings.render.item;
            self2.settings.render.item = (data, escape) => {
              const item = getDom(orig_render_item.call(self2, data, escape));
              setAttr(item, {
                "draggable": "true"
              });
              const mousedown = (evt) => {
                if (!sortable)
                  preventDefault(evt);
                evt.stopPropagation();
              };
              const dragStart = (evt) => {
                drag_item = item;
                setTimeout(() => {
                  item.classList.add("ts-dragging");
                }, 0);
              };
              const dragOver = (evt) => {
                evt.preventDefault();
                item.classList.add("ts-drag-over");
                moveitem(item, drag_item);
              };
              const dragLeave = () => {
                item.classList.remove("ts-drag-over");
              };
              const moveitem = (targetitem, dragitem) => {
                if (dragitem === void 0)
                  return;
                if (isBefore(dragitem, item)) {
                  insertAfter(targetitem, dragitem);
                } else {
                  insertBefore(targetitem, dragitem);
                }
              };
              const dragend = () => {
                var _drag_item;
                document.querySelectorAll(".ts-drag-over").forEach((el) => el.classList.remove("ts-drag-over"));
                (_drag_item = drag_item) == null || _drag_item.classList.remove("ts-dragging");
                drag_item = void 0;
                var values = [];
                self2.control.querySelectorAll(`[data-value]`).forEach((el) => {
                  if (el.dataset.value) {
                    let value = el.dataset.value;
                    if (value) {
                      values.push(value);
                    }
                  }
                });
                self2.setValue(values);
              };
              addEvent(item, "mousedown", mousedown);
              addEvent(item, "dragstart", dragStart);
              addEvent(item, "dragenter", dragOver);
              addEvent(item, "dragover", dragOver);
              addEvent(item, "dragleave", dragLeave);
              addEvent(item, "dragend", dragend);
              return item;
            };
          });
          self2.hook("instead", "lock", () => {
            sortable = false;
            return orig_lock.call(self2);
          });
          self2.hook("instead", "unlock", () => {
            sortable = true;
            return orig_unlock.call(self2);
          });
        }
        function dropdown_header(userOptions) {
          const self2 = this;
          const options = Object.assign({
            title: "Untitled",
            headerClass: "dropdown-header",
            titleRowClass: "dropdown-header-title",
            labelClass: "dropdown-header-label",
            closeClass: "dropdown-header-close",
            html: (data) => {
              return '<div class="' + data.headerClass + '"><div class="' + data.titleRowClass + '"><span class="' + data.labelClass + '">' + data.title + '</span><a class="' + data.closeClass + '">&times;</a></div></div>';
            }
          }, userOptions);
          self2.on("initialize", () => {
            var header = getDom(options.html(options));
            var close_link = header.querySelector("." + options.closeClass);
            if (close_link) {
              close_link.addEventListener("click", (evt) => {
                preventDefault(evt, true);
                self2.close();
              });
            }
            self2.dropdown.insertBefore(header, self2.dropdown.firstChild);
          });
        }
        function caret_position() {
          var self2 = this;
          self2.hook("instead", "setCaret", (new_pos) => {
            if (self2.settings.mode === "single" || !self2.control.contains(self2.control_input)) {
              new_pos = self2.items.length;
            } else {
              new_pos = Math.max(0, Math.min(self2.items.length, new_pos));
              if (new_pos != self2.caretPos && !self2.isPending) {
                self2.controlChildren().forEach((child, j) => {
                  if (j < new_pos) {
                    self2.control_input.insertAdjacentElement("beforebegin", child);
                  } else {
                    self2.control.appendChild(child);
                  }
                });
              }
            }
            self2.caretPos = new_pos;
          });
          self2.hook("instead", "moveCaret", (direction) => {
            if (!self2.isFocused)
              return;
            const last_active = self2.getLastActive(direction);
            if (last_active) {
              const idx = nodeIndex(last_active);
              self2.setCaret(direction > 0 ? idx + 1 : idx);
              self2.setActiveItem();
              removeClasses(last_active, "last-active");
            } else {
              self2.setCaret(self2.caretPos + direction);
            }
          });
        }
        function dropdown_input() {
          const self2 = this;
          self2.settings.shouldOpen = true;
          self2.hook("before", "setup", () => {
            self2.focus_node = self2.control;
            addClasses(self2.control_input, "dropdown-input");
            const div = getDom('<div class="dropdown-input-wrap">');
            div.append(self2.control_input);
            self2.dropdown.insertBefore(div, self2.dropdown.firstChild);
            const placeholder = getDom('<input class="items-placeholder" tabindex="-1" />');
            placeholder.placeholder = self2.settings.placeholder || "";
            self2.control.append(placeholder);
          });
          self2.on("initialize", () => {
            self2.control_input.addEventListener("keydown", (evt) => {
              switch (evt.keyCode) {
                case KEY_ESC:
                  if (self2.isOpen) {
                    preventDefault(evt, true);
                    self2.close();
                  }
                  self2.clearActiveItems();
                  return;
                case KEY_TAB:
                  self2.focus_node.tabIndex = -1;
                  break;
              }
              return self2.onKeyDown.call(self2, evt);
            });
            self2.on("blur", () => {
              self2.focus_node.tabIndex = self2.isDisabled ? -1 : self2.tabIndex;
            });
            self2.on("dropdown_open", () => {
              self2.control_input.focus();
            });
            const orig_onBlur = self2.onBlur;
            self2.hook("instead", "onBlur", (evt) => {
              if (evt && evt.relatedTarget == self2.control_input)
                return;
              return orig_onBlur.call(self2);
            });
            addEvent(self2.control_input, "blur", () => self2.onBlur());
            self2.hook("before", "close", () => {
              if (!self2.isOpen)
                return;
              self2.focus_node.focus({
                preventScroll: true
              });
            });
          });
        }
        function input_autogrow() {
          var self2 = this;
          self2.on("initialize", () => {
            var test_input = document.createElement("span");
            var control = self2.control_input;
            test_input.style.cssText = "position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ";
            self2.wrapper.appendChild(test_input);
            var transfer_styles = ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"];
            for (const style_name of transfer_styles) {
              test_input.style[style_name] = control.style[style_name];
            }
            var resize = () => {
              test_input.textContent = control.value;
              control.style.width = test_input.clientWidth + "px";
            };
            resize();
            self2.on("update item_add item_remove", resize);
            addEvent(control, "input", resize);
            addEvent(control, "keyup", resize);
            addEvent(control, "blur", resize);
            addEvent(control, "update", resize);
          });
        }
        function no_backspace_delete() {
          var self2 = this;
          var orig_deleteSelection = self2.deleteSelection;
          this.hook("instead", "deleteSelection", (evt) => {
            if (self2.activeItems.length) {
              return orig_deleteSelection.call(self2, evt);
            }
            return false;
          });
        }
        function no_active_items() {
          this.hook("instead", "setActiveItem", () => {
          });
          this.hook("instead", "selectAll", () => {
          });
        }
        function optgroup_columns() {
          var self2 = this;
          var orig_keydown = self2.onKeyDown;
          self2.hook("instead", "onKeyDown", (evt) => {
            var index2, option, options, optgroup;
            if (!self2.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {
              return orig_keydown.call(self2, evt);
            }
            self2.ignoreHover = true;
            optgroup = parentMatch(self2.activeOption, "[data-group]");
            index2 = nodeIndex(self2.activeOption, "[data-selectable]");
            if (!optgroup) {
              return;
            }
            if (evt.keyCode === KEY_LEFT) {
              optgroup = optgroup.previousSibling;
            } else {
              optgroup = optgroup.nextSibling;
            }
            if (!optgroup) {
              return;
            }
            options = optgroup.querySelectorAll("[data-selectable]");
            option = options[Math.min(options.length - 1, index2)];
            if (option) {
              self2.setActiveOption(option);
            }
          });
        }
        function remove_button(userOptions) {
          const options = Object.assign({
            label: "&times;",
            title: "Remove",
            className: "remove",
            append: true
          }, userOptions);
          var self2 = this;
          if (!options.append) {
            return;
          }
          var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + "</a>";
          self2.hook("after", "setupTemplates", () => {
            var orig_render_item = self2.settings.render.item;
            self2.settings.render.item = (data, escape) => {
              var item = getDom(orig_render_item.call(self2, data, escape));
              var close_button = getDom(html);
              item.appendChild(close_button);
              addEvent(close_button, "mousedown", (evt) => {
                preventDefault(evt, true);
              });
              addEvent(close_button, "click", (evt) => {
                if (self2.isLocked)
                  return;
                preventDefault(evt, true);
                if (self2.isLocked)
                  return;
                if (!self2.shouldDelete([item], evt))
                  return;
                self2.removeItem(item);
                self2.refreshOptions(false);
                self2.inputState();
              });
              return item;
            };
          });
        }
        function restore_on_backspace(userOptions) {
          const self2 = this;
          const options = Object.assign({
            text: (option) => {
              return option[self2.settings.labelField];
            }
          }, userOptions);
          self2.on("item_remove", function(value) {
            if (!self2.isFocused) {
              return;
            }
            if (self2.control_input.value.trim() === "") {
              var option = self2.options[value];
              if (option) {
                self2.setTextboxValue(options.text.call(self2, option));
              }
            }
          });
        }
        function virtual_scroll() {
          const self2 = this;
          const orig_canLoad = self2.canLoad;
          const orig_clearActiveOption = self2.clearActiveOption;
          const orig_loadCallback = self2.loadCallback;
          var pagination = {};
          var dropdown_content;
          var loading_more = false;
          var load_more_opt;
          var default_values = [];
          if (!self2.settings.shouldLoadMore) {
            self2.settings.shouldLoadMore = () => {
              const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);
              if (scroll_percent > 0.9) {
                return true;
              }
              if (self2.activeOption) {
                var selectable = self2.selectable();
                var index2 = Array.from(selectable).indexOf(self2.activeOption);
                if (index2 >= selectable.length - 2) {
                  return true;
                }
              }
              return false;
            };
          }
          if (!self2.settings.firstUrl) {
            throw "virtual_scroll plugin requires a firstUrl() method";
          }
          self2.settings.sortField = [{
            field: "$order"
          }, {
            field: "$score"
          }];
          const canLoadMore = (query) => {
            if (typeof self2.settings.maxOptions === "number" && dropdown_content.children.length >= self2.settings.maxOptions) {
              return false;
            }
            if (query in pagination && pagination[query]) {
              return true;
            }
            return false;
          };
          const clearFilter = (option, value) => {
            if (self2.items.indexOf(value) >= 0 || default_values.indexOf(value) >= 0) {
              return true;
            }
            return false;
          };
          self2.setNextUrl = (value, next_url) => {
            pagination[value] = next_url;
          };
          self2.getUrl = (query) => {
            if (query in pagination) {
              const next_url = pagination[query];
              pagination[query] = false;
              return next_url;
            }
            self2.clearPagination();
            return self2.settings.firstUrl.call(self2, query);
          };
          self2.clearPagination = () => {
            pagination = {};
          };
          self2.hook("instead", "clearActiveOption", () => {
            if (loading_more) {
              return;
            }
            return orig_clearActiveOption.call(self2);
          });
          self2.hook("instead", "canLoad", (query) => {
            if (!(query in pagination)) {
              return orig_canLoad.call(self2, query);
            }
            return canLoadMore(query);
          });
          self2.hook("instead", "loadCallback", (options, optgroups) => {
            if (!loading_more) {
              self2.clearOptions(clearFilter);
            } else if (load_more_opt) {
              const first_option = options[0];
              if (first_option !== void 0) {
                load_more_opt.dataset.value = first_option[self2.settings.valueField];
              }
            }
            orig_loadCallback.call(self2, options, optgroups);
            loading_more = false;
          });
          self2.hook("after", "refreshOptions", () => {
            const query = self2.lastValue;
            var option;
            if (canLoadMore(query)) {
              option = self2.render("loading_more", {
                query
              });
              if (option) {
                option.setAttribute("data-selectable", "");
                load_more_opt = option;
              }
            } else if (query in pagination && !dropdown_content.querySelector(".no-results")) {
              option = self2.render("no_more_results", {
                query
              });
            }
            if (option) {
              addClasses(option, self2.settings.optionClass);
              dropdown_content.append(option);
            }
          });
          self2.on("initialize", () => {
            default_values = Object.keys(self2.options);
            dropdown_content = self2.dropdown_content;
            self2.settings.render = Object.assign({}, {
              loading_more: () => {
                return `<div class="loading-more-results">Loading more results ... </div>`;
              },
              no_more_results: () => {
                return `<div class="no-more-results">No more results</div>`;
              }
            }, self2.settings.render);
            dropdown_content.addEventListener("scroll", () => {
              if (!self2.settings.shouldLoadMore.call(self2)) {
                return;
              }
              if (!canLoadMore(self2.lastValue)) {
                return;
              }
              if (loading_more)
                return;
              loading_more = true;
              self2.load.call(self2, self2.lastValue);
            });
          });
        }
        TomSelect4.define("change_listener", change_listener);
        TomSelect4.define("checkbox_options", checkbox_options);
        TomSelect4.define("clear_button", clear_button);
        TomSelect4.define("drag_drop", drag_drop);
        TomSelect4.define("dropdown_header", dropdown_header);
        TomSelect4.define("caret_position", caret_position);
        TomSelect4.define("dropdown_input", dropdown_input);
        TomSelect4.define("input_autogrow", input_autogrow);
        TomSelect4.define("no_backspace_delete", no_backspace_delete);
        TomSelect4.define("no_active_items", no_active_items);
        TomSelect4.define("optgroup_columns", optgroup_columns);
        TomSelect4.define("remove_button", remove_button);
        TomSelect4.define("restore_on_backspace", restore_on_backspace);
        TomSelect4.define("virtual_scroll", virtual_scroll);
        return TomSelect4;
      });
    }
  });

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback, element) {
              var currTime = new Date().getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, progressTimerId, fadeTimerId, currentProgress, showing, addEvent = function(elem, type, handler) {
          if (elem.addEventListener)
            elem.addEventListener(type, handler, false);
          else if (elem.attachEvent)
            elem.attachEvent("on" + type, handler);
          else
            elem["on" + type] = handler;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop in options.barColors)
            lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(Math.ceil(currentProgress * canvas.width), options.barThickness / 2);
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document2.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className)
            canvas.classList.add(options.className);
          document2.body.appendChild(canvas);
          addEvent(window2, "resize", repaint);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts)
              if (options.hasOwnProperty(key))
                options[key] = opts[key];
          },
          show: function() {
            if (showing)
              return;
            showing = true;
            if (fadeTimerId !== null)
              window2.cancelAnimationFrame(fadeTimerId);
            if (!canvas)
              createCanvas();
            canvas.style.opacity = 1;
            canvas.style.display = "block";
            topbar2.progress(0);
            if (options.autoRun) {
              (function loop() {
                progressTimerId = window2.requestAnimationFrame(loop);
                topbar2.progress("+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2));
              })();
            }
          },
          progress: function(to) {
            if (typeof to === "undefined")
              return currentProgress;
            if (typeof to === "string") {
              to = (to.indexOf("+") >= 0 || to.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to);
            }
            currentProgress = to > 1 ? 1 : to;
            repaint();
            return currentProgress;
          },
          hide: function() {
            if (!showing)
              return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            (function loop() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // node_modules/chart.js/dist/chart.js
  var require_chart = __commonJS({
    "node_modules/chart.js/dist/chart.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Chart = factory());
      })(exports, function() {
        "use strict";
        function noop2() {
        }
        const uid = function() {
          let id = 0;
          return function() {
            return id++;
          };
        }();
        function isNullOrUndef(value) {
          return value === null || typeof value === "undefined";
        }
        function isArray(value) {
          if (Array.isArray && Array.isArray(value)) {
            return true;
          }
          const type = Object.prototype.toString.call(value);
          if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
            return true;
          }
          return false;
        }
        function isObject2(value) {
          return value !== null && Object.prototype.toString.call(value) === "[object Object]";
        }
        const isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
        function finiteOrDefault(value, defaultValue) {
          return isNumberFinite(value) ? value : defaultValue;
        }
        function valueOrDefault(value, defaultValue) {
          return typeof value === "undefined" ? defaultValue : value;
        }
        const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
        const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
        function callback(fn, args, thisArg) {
          if (fn && typeof fn.call === "function") {
            return fn.apply(thisArg, args);
          }
        }
        function each(loopable, fn, thisArg, reverse) {
          let i, len, keys;
          if (isArray(loopable)) {
            len = loopable.length;
            if (reverse) {
              for (i = len - 1; i >= 0; i--) {
                fn.call(thisArg, loopable[i], i);
              }
            } else {
              for (i = 0; i < len; i++) {
                fn.call(thisArg, loopable[i], i);
              }
            }
          } else if (isObject2(loopable)) {
            keys = Object.keys(loopable);
            len = keys.length;
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[keys[i]], keys[i]);
            }
          }
        }
        function _elementsEqual(a0, a1) {
          let i, ilen, v0, v1;
          if (!a0 || !a1 || a0.length !== a1.length) {
            return false;
          }
          for (i = 0, ilen = a0.length; i < ilen; ++i) {
            v0 = a0[i];
            v1 = a1[i];
            if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
              return false;
            }
          }
          return true;
        }
        function clone$1(source) {
          if (isArray(source)) {
            return source.map(clone$1);
          }
          if (isObject2(source)) {
            const target = Object.create(null);
            const keys = Object.keys(source);
            const klen = keys.length;
            let k = 0;
            for (; k < klen; ++k) {
              target[keys[k]] = clone$1(source[keys[k]]);
            }
            return target;
          }
          return source;
        }
        function isValidKey(key) {
          return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
        }
        function _merger(key, target, source, options) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject2(tval) && isObject2(sval)) {
            merge(tval, sval, options);
          } else {
            target[key] = clone$1(sval);
          }
        }
        function merge(target, source, options) {
          const sources = isArray(source) ? source : [source];
          const ilen = sources.length;
          if (!isObject2(target)) {
            return target;
          }
          options = options || {};
          const merger = options.merger || _merger;
          for (let i = 0; i < ilen; ++i) {
            source = sources[i];
            if (!isObject2(source)) {
              continue;
            }
            const keys = Object.keys(source);
            for (let k = 0, klen = keys.length; k < klen; ++k) {
              merger(keys[k], target, source, options);
            }
          }
          return target;
        }
        function mergeIf(target, source) {
          return merge(target, source, { merger: _mergerIf });
        }
        function _mergerIf(key, target, source) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject2(tval) && isObject2(sval)) {
            mergeIf(tval, sval);
          } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
            target[key] = clone$1(sval);
          }
        }
        function _deprecated(scope, value, previous, current) {
          if (value !== void 0) {
            console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
          }
        }
        const keyResolvers = {
          "": (v) => v,
          x: (o) => o.x,
          y: (o) => o.y
        };
        function resolveObjectKey(obj, key) {
          const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
          return resolver(obj);
        }
        function _getKeyResolver(key) {
          const keys = _splitKey(key);
          return (obj) => {
            for (const k of keys) {
              if (k === "") {
                break;
              }
              obj = obj && obj[k];
            }
            return obj;
          };
        }
        function _splitKey(key) {
          const parts = key.split(".");
          const keys = [];
          let tmp = "";
          for (const part of parts) {
            tmp += part;
            if (tmp.endsWith("\\")) {
              tmp = tmp.slice(0, -1) + ".";
            } else {
              keys.push(tmp);
              tmp = "";
            }
          }
          return keys;
        }
        function _capitalize(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        }
        const defined = (value) => typeof value !== "undefined";
        const isFunction2 = (value) => typeof value === "function";
        const setsEqual = (a, b) => {
          if (a.size !== b.size) {
            return false;
          }
          for (const item of a) {
            if (!b.has(item)) {
              return false;
            }
          }
          return true;
        };
        function _isClickEvent(e) {
          return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
        }
        const PI = Math.PI;
        const TAU = 2 * PI;
        const PITAU = TAU + PI;
        const INFINITY = Number.POSITIVE_INFINITY;
        const RAD_PER_DEG = PI / 180;
        const HALF_PI = PI / 2;
        const QUARTER_PI = PI / 4;
        const TWO_THIRDS_PI = PI * 2 / 3;
        const log10 = Math.log10;
        const sign = Math.sign;
        function niceNum(range2) {
          const roundedRange = Math.round(range2);
          range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
          const niceRange = Math.pow(10, Math.floor(log10(range2)));
          const fraction = range2 / niceRange;
          const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
          return niceFraction * niceRange;
        }
        function _factorize(value) {
          const result = [];
          const sqrt = Math.sqrt(value);
          let i;
          for (i = 1; i < sqrt; i++) {
            if (value % i === 0) {
              result.push(i);
              result.push(value / i);
            }
          }
          if (sqrt === (sqrt | 0)) {
            result.push(sqrt);
          }
          result.sort((a, b) => a - b).pop();
          return result;
        }
        function isNumber(n) {
          return !isNaN(parseFloat(n)) && isFinite(n);
        }
        function almostEquals(x, y, epsilon) {
          return Math.abs(x - y) < epsilon;
        }
        function almostWhole(x, epsilon) {
          const rounded = Math.round(x);
          return rounded - epsilon <= x && rounded + epsilon >= x;
        }
        function _setMinAndMaxByKey(array, target, property) {
          let i, ilen, value;
          for (i = 0, ilen = array.length; i < ilen; i++) {
            value = array[i][property];
            if (!isNaN(value)) {
              target.min = Math.min(target.min, value);
              target.max = Math.max(target.max, value);
            }
          }
        }
        function toRadians(degrees) {
          return degrees * (PI / 180);
        }
        function toDegrees(radians) {
          return radians * (180 / PI);
        }
        function _decimalPlaces(x) {
          if (!isNumberFinite(x)) {
            return;
          }
          let e = 1;
          let p = 0;
          while (Math.round(x * e) / e !== x) {
            e *= 10;
            p++;
          }
          return p;
        }
        function getAngleFromPoint(centrePoint, anglePoint) {
          const distanceFromXCenter = anglePoint.x - centrePoint.x;
          const distanceFromYCenter = anglePoint.y - centrePoint.y;
          const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
          let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
          if (angle < -0.5 * PI) {
            angle += TAU;
          }
          return {
            angle,
            distance: radialDistanceFromCenter
          };
        }
        function distanceBetweenPoints(pt1, pt2) {
          return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
        }
        function _angleDiff(a, b) {
          return (a - b + PITAU) % TAU - PI;
        }
        function _normalizeAngle(a) {
          return (a % TAU + TAU) % TAU;
        }
        function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
          const a = _normalizeAngle(angle);
          const s = _normalizeAngle(start);
          const e = _normalizeAngle(end);
          const angleToStart = _normalizeAngle(s - a);
          const angleToEnd = _normalizeAngle(e - a);
          const startToAngle = _normalizeAngle(a - s);
          const endToAngle = _normalizeAngle(a - e);
          return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
        }
        function _limitValue(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }
        function _int16Range(value) {
          return _limitValue(value, -32768, 32767);
        }
        function _isBetween(value, start, end, epsilon = 1e-6) {
          return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
        }
        function _lookup(table, value, cmp) {
          cmp = cmp || ((index3) => table[index3] < value);
          let hi = table.length - 1;
          let lo = 0;
          let mid;
          while (hi - lo > 1) {
            mid = lo + hi >> 1;
            if (cmp(mid)) {
              lo = mid;
            } else {
              hi = mid;
            }
          }
          return { lo, hi };
        }
        const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index3) => table[index3][key] <= value : (index3) => table[index3][key] < value);
        const _rlookupByKey = (table, key, value) => _lookup(table, value, (index3) => table[index3][key] >= value);
        function _filterBetween(values, min, max) {
          let start = 0;
          let end = values.length;
          while (start < end && values[start] < min) {
            start++;
          }
          while (end > start && values[end - 1] > max) {
            end--;
          }
          return start > 0 || end < values.length ? values.slice(start, end) : values;
        }
        const arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, "_chartjs", {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener]
            }
          });
          arrayEvents.forEach((key) => {
            const method = "_onData" + _capitalize(key);
            const base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value(...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object) => {
                  if (typeof object[method] === "function") {
                    object[method](...args);
                  }
                });
                return res;
              }
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          const stub = array._chartjs;
          if (!stub) {
            return;
          }
          const listeners = stub.listeners;
          const index3 = listeners.indexOf(listener);
          if (index3 !== -1) {
            listeners.splice(index3, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach((key) => {
            delete array[key];
          });
          delete array._chartjs;
        }
        function _arrayUnique(items) {
          const set2 = /* @__PURE__ */ new Set();
          let i, ilen;
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            set2.add(items[i]);
          }
          if (set2.size === ilen) {
            return items;
          }
          return Array.from(set2);
        }
        function fontString(pixelSize, fontStyle, fontFamily) {
          return fontStyle + " " + pixelSize + "px " + fontFamily;
        }
        const requestAnimFrame = function() {
          if (typeof window === "undefined") {
            return function(callback2) {
              return callback2();
            };
          }
          return window.requestAnimationFrame;
        }();
        function throttled(fn, thisArg, updateFn) {
          const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
          let ticking = false;
          let args = [];
          return function(...rest) {
            args = updateArgs(rest);
            if (!ticking) {
              ticking = true;
              requestAnimFrame.call(window, () => {
                ticking = false;
                fn.apply(thisArg, args);
              });
            }
          };
        }
        function debounce(fn, delay) {
          let timeout;
          return function(...args) {
            if (delay) {
              clearTimeout(timeout);
              timeout = setTimeout(fn, delay, args);
            } else {
              fn.apply(this, args);
            }
            return delay;
          };
        }
        const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
        const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
        const _textX = (align, left, right, rtl) => {
          const check = rtl ? "left" : "right";
          return align === check ? right : align === "center" ? (left + right) / 2 : left;
        };
        function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
          const pointCount = points.length;
          let start = 0;
          let count = pointCount;
          if (meta._sorted) {
            const { iScale, _parsed } = meta;
            const axis = iScale.axis;
            const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
            if (minDefined) {
              start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
            }
            if (maxDefined) {
              count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
            } else {
              count = pointCount - start;
            }
          }
          return { start, count };
        }
        function _scaleRangesChanged(meta) {
          const { xScale, yScale, _scaleRanges } = meta;
          const newRanges = {
            xmin: xScale.min,
            xmax: xScale.max,
            ymin: yScale.min,
            ymax: yScale.max
          };
          if (!_scaleRanges) {
            meta._scaleRanges = newRanges;
            return true;
          }
          const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
          Object.assign(_scaleRanges, newRanges);
          return changed;
        }
        class Animator {
          constructor() {
            this._request = null;
            this._charts = /* @__PURE__ */ new Map();
            this._running = false;
            this._lastDate = void 0;
          }
          _notify(chart2, anims, date, type) {
            const callbacks = anims.listeners[type];
            const numSteps = anims.duration;
            callbacks.forEach((fn) => fn({
              chart: chart2,
              initial: anims.initial,
              numSteps,
              currentStep: Math.min(date - anims.start, numSteps)
            }));
          }
          _refresh() {
            if (this._request) {
              return;
            }
            this._running = true;
            this._request = requestAnimFrame.call(window, () => {
              this._update();
              this._request = null;
              if (this._running) {
                this._refresh();
              }
            });
          }
          _update(date = Date.now()) {
            let remaining = 0;
            this._charts.forEach((anims, chart2) => {
              if (!anims.running || !anims.items.length) {
                return;
              }
              const items = anims.items;
              let i = items.length - 1;
              let draw2 = false;
              let item;
              for (; i >= 0; --i) {
                item = items[i];
                if (item._active) {
                  if (item._total > anims.duration) {
                    anims.duration = item._total;
                  }
                  item.tick(date);
                  draw2 = true;
                } else {
                  items[i] = items[items.length - 1];
                  items.pop();
                }
              }
              if (draw2) {
                chart2.draw();
                this._notify(chart2, anims, date, "progress");
              }
              if (!items.length) {
                anims.running = false;
                this._notify(chart2, anims, date, "complete");
                anims.initial = false;
              }
              remaining += items.length;
            });
            this._lastDate = date;
            if (remaining === 0) {
              this._running = false;
            }
          }
          _getAnims(chart2) {
            const charts = this._charts;
            let anims = charts.get(chart2);
            if (!anims) {
              anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                  complete: [],
                  progress: []
                }
              };
              charts.set(chart2, anims);
            }
            return anims;
          }
          listen(chart2, event, cb) {
            this._getAnims(chart2).listeners[event].push(cb);
          }
          add(chart2, items) {
            if (!items || !items.length) {
              return;
            }
            this._getAnims(chart2).items.push(...items);
          }
          has(chart2) {
            return this._getAnims(chart2).items.length > 0;
          }
          start(chart2) {
            const anims = this._charts.get(chart2);
            if (!anims) {
              return;
            }
            anims.running = true;
            anims.start = Date.now();
            anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
            this._refresh();
          }
          running(chart2) {
            if (!this._running) {
              return false;
            }
            const anims = this._charts.get(chart2);
            if (!anims || !anims.running || !anims.items.length) {
              return false;
            }
            return true;
          }
          stop(chart2) {
            const anims = this._charts.get(chart2);
            if (!anims || !anims.items.length) {
              return;
            }
            const items = anims.items;
            let i = items.length - 1;
            for (; i >= 0; --i) {
              items[i].cancel();
            }
            anims.items = [];
            this._notify(chart2, anims, Date.now(), "complete");
          }
          remove(chart2) {
            return this._charts.delete(chart2);
          }
        }
        var animator = new Animator();
        function round(v) {
          return v + 0.5 | 0;
        }
        const lim = (v, l, h) => Math.max(Math.min(v, h), l);
        function p2b(v) {
          return lim(round(v * 2.55), 0, 255);
        }
        function n2b(v) {
          return lim(round(v * 255), 0, 255);
        }
        function b2n(v) {
          return lim(round(v / 2.55) / 100, 0, 1);
        }
        function n2p(v) {
          return lim(round(v * 100), 0, 100);
        }
        const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
        const hex = [..."0123456789ABCDEF"];
        const h1 = (b) => hex[b & 15];
        const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
        const eq = (b) => (b & 240) >> 4 === (b & 15);
        const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
        function hexParse(str) {
          var len = str.length;
          var ret;
          if (str[0] === "#") {
            if (len === 4 || len === 5) {
              ret = {
                r: 255 & map$1[str[1]] * 17,
                g: 255 & map$1[str[2]] * 17,
                b: 255 & map$1[str[3]] * 17,
                a: len === 5 ? map$1[str[4]] * 17 : 255
              };
            } else if (len === 7 || len === 9) {
              ret = {
                r: map$1[str[1]] << 4 | map$1[str[2]],
                g: map$1[str[3]] << 4 | map$1[str[4]],
                b: map$1[str[5]] << 4 | map$1[str[6]],
                a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
              };
            }
          }
          return ret;
        }
        const alpha = (a, f) => a < 255 ? f(a) : "";
        function hexString(v) {
          var f = isShort(v) ? h1 : h2;
          return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
        }
        const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
        function hsl2rgbn(h, s, l) {
          const a = s * Math.min(l, 1 - l);
          const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return [f(0), f(8), f(4)];
        }
        function hsv2rgbn(h, s, v) {
          const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
          return [f(5), f(3), f(1)];
        }
        function hwb2rgbn(h, w, b) {
          const rgb = hsl2rgbn(h, 1, 0.5);
          let i;
          if (w + b > 1) {
            i = 1 / (w + b);
            w *= i;
            b *= i;
          }
          for (i = 0; i < 3; i++) {
            rgb[i] *= 1 - w - b;
            rgb[i] += w;
          }
          return rgb;
        }
        function hueValue(r, g, b, d, max) {
          if (r === max) {
            return (g - b) / d + (g < b ? 6 : 0);
          }
          if (g === max) {
            return (b - r) / d + 2;
          }
          return (r - g) / d + 4;
        }
        function rgb2hsl(v) {
          const range2 = 255;
          const r = v.r / range2;
          const g = v.g / range2;
          const b = v.b / range2;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const l = (max + min) / 2;
          let h, s, d;
          if (max !== min) {
            d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            h = hueValue(r, g, b, d, max);
            h = h * 60 + 0.5;
          }
          return [h | 0, s || 0, l];
        }
        function calln(f, a, b, c) {
          return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
        }
        function hsl2rgb(h, s, l) {
          return calln(hsl2rgbn, h, s, l);
        }
        function hwb2rgb(h, w, b) {
          return calln(hwb2rgbn, h, w, b);
        }
        function hsv2rgb(h, s, v) {
          return calln(hsv2rgbn, h, s, v);
        }
        function hue(h) {
          return (h % 360 + 360) % 360;
        }
        function hueParse(str) {
          const m = HUE_RE.exec(str);
          let a = 255;
          let v;
          if (!m) {
            return;
          }
          if (m[5] !== v) {
            a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
          }
          const h = hue(+m[2]);
          const p1 = +m[3] / 100;
          const p2 = +m[4] / 100;
          if (m[1] === "hwb") {
            v = hwb2rgb(h, p1, p2);
          } else if (m[1] === "hsv") {
            v = hsv2rgb(h, p1, p2);
          } else {
            v = hsl2rgb(h, p1, p2);
          }
          return {
            r: v[0],
            g: v[1],
            b: v[2],
            a
          };
        }
        function rotate(v, deg) {
          var h = rgb2hsl(v);
          h[0] = hue(h[0] + deg);
          h = hsl2rgb(h);
          v.r = h[0];
          v.g = h[1];
          v.b = h[2];
        }
        function hslString(v) {
          if (!v) {
            return;
          }
          const a = rgb2hsl(v);
          const h = a[0];
          const s = n2p(a[1]);
          const l = n2p(a[2]);
          return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
        }
        const map$2 = {
          x: "dark",
          Z: "light",
          Y: "re",
          X: "blu",
          W: "gr",
          V: "medium",
          U: "slate",
          A: "ee",
          T: "ol",
          S: "or",
          B: "ra",
          C: "lateg",
          D: "ights",
          R: "in",
          Q: "turquois",
          E: "hi",
          P: "ro",
          O: "al",
          N: "le",
          M: "de",
          L: "yello",
          F: "en",
          K: "ch",
          G: "arks",
          H: "ea",
          I: "ightg",
          J: "wh"
        };
        const names$1 = {
          OiceXe: "f0f8ff",
          antiquewEte: "faebd7",
          aqua: "ffff",
          aquamarRe: "7fffd4",
          azuY: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "0",
          blanKedOmond: "ffebcd",
          Xe: "ff",
          XeviTet: "8a2be2",
          bPwn: "a52a2a",
          burlywood: "deb887",
          caMtXe: "5f9ea0",
          KartYuse: "7fff00",
          KocTate: "d2691e",
          cSO: "ff7f50",
          cSnflowerXe: "6495ed",
          cSnsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "ffff",
          xXe: "8b",
          xcyan: "8b8b",
          xgTMnPd: "b8860b",
          xWay: "a9a9a9",
          xgYF: "6400",
          xgYy: "a9a9a9",
          xkhaki: "bdb76b",
          xmagFta: "8b008b",
          xTivegYF: "556b2f",
          xSange: "ff8c00",
          xScEd: "9932cc",
          xYd: "8b0000",
          xsOmon: "e9967a",
          xsHgYF: "8fbc8f",
          xUXe: "483d8b",
          xUWay: "2f4f4f",
          xUgYy: "2f4f4f",
          xQe: "ced1",
          xviTet: "9400d3",
          dAppRk: "ff1493",
          dApskyXe: "bfff",
          dimWay: "696969",
          dimgYy: "696969",
          dodgerXe: "1e90ff",
          fiYbrick: "b22222",
          flSOwEte: "fffaf0",
          foYstWAn: "228b22",
          fuKsia: "ff00ff",
          gaRsbSo: "dcdcdc",
          ghostwEte: "f8f8ff",
          gTd: "ffd700",
          gTMnPd: "daa520",
          Way: "808080",
          gYF: "8000",
          gYFLw: "adff2f",
          gYy: "808080",
          honeyMw: "f0fff0",
          hotpRk: "ff69b4",
          RdianYd: "cd5c5c",
          Rdigo: "4b0082",
          ivSy: "fffff0",
          khaki: "f0e68c",
          lavFMr: "e6e6fa",
          lavFMrXsh: "fff0f5",
          lawngYF: "7cfc00",
          NmoncEffon: "fffacd",
          ZXe: "add8e6",
          ZcSO: "f08080",
          Zcyan: "e0ffff",
          ZgTMnPdLw: "fafad2",
          ZWay: "d3d3d3",
          ZgYF: "90ee90",
          ZgYy: "d3d3d3",
          ZpRk: "ffb6c1",
          ZsOmon: "ffa07a",
          ZsHgYF: "20b2aa",
          ZskyXe: "87cefa",
          ZUWay: "778899",
          ZUgYy: "778899",
          ZstAlXe: "b0c4de",
          ZLw: "ffffe0",
          lime: "ff00",
          limegYF: "32cd32",
          lRF: "faf0e6",
          magFta: "ff00ff",
          maPon: "800000",
          VaquamarRe: "66cdaa",
          VXe: "cd",
          VScEd: "ba55d3",
          VpurpN: "9370db",
          VsHgYF: "3cb371",
          VUXe: "7b68ee",
          VsprRggYF: "fa9a",
          VQe: "48d1cc",
          VviTetYd: "c71585",
          midnightXe: "191970",
          mRtcYam: "f5fffa",
          mistyPse: "ffe4e1",
          moccasR: "ffe4b5",
          navajowEte: "ffdead",
          navy: "80",
          Tdlace: "fdf5e6",
          Tive: "808000",
          TivedBb: "6b8e23",
          Sange: "ffa500",
          SangeYd: "ff4500",
          ScEd: "da70d6",
          pOegTMnPd: "eee8aa",
          pOegYF: "98fb98",
          pOeQe: "afeeee",
          pOeviTetYd: "db7093",
          papayawEp: "ffefd5",
          pHKpuff: "ffdab9",
          peru: "cd853f",
          pRk: "ffc0cb",
          plum: "dda0dd",
          powMrXe: "b0e0e6",
          purpN: "800080",
          YbeccapurpN: "663399",
          Yd: "ff0000",
          Psybrown: "bc8f8f",
          PyOXe: "4169e1",
          saddNbPwn: "8b4513",
          sOmon: "fa8072",
          sandybPwn: "f4a460",
          sHgYF: "2e8b57",
          sHshell: "fff5ee",
          siFna: "a0522d",
          silver: "c0c0c0",
          skyXe: "87ceeb",
          UXe: "6a5acd",
          UWay: "708090",
          UgYy: "708090",
          snow: "fffafa",
          sprRggYF: "ff7f",
          stAlXe: "4682b4",
          tan: "d2b48c",
          teO: "8080",
          tEstN: "d8bfd8",
          tomato: "ff6347",
          Qe: "40e0d0",
          viTet: "ee82ee",
          JHt: "f5deb3",
          wEte: "ffffff",
          wEtesmoke: "f5f5f5",
          Lw: "ffff00",
          LwgYF: "9acd32"
        };
        function unpack() {
          const unpacked = {};
          const keys = Object.keys(names$1);
          const tkeys = Object.keys(map$2);
          let i, j, k, ok, nk;
          for (i = 0; i < keys.length; i++) {
            ok = nk = keys[i];
            for (j = 0; j < tkeys.length; j++) {
              k = tkeys[j];
              nk = nk.replace(k, map$2[k]);
            }
            k = parseInt(names$1[ok], 16);
            unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
          }
          return unpacked;
        }
        let names;
        function nameParse(str) {
          if (!names) {
            names = unpack();
            names.transparent = [0, 0, 0, 0];
          }
          const a = names[str.toLowerCase()];
          return a && {
            r: a[0],
            g: a[1],
            b: a[2],
            a: a.length === 4 ? a[3] : 255
          };
        }
        const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        function rgbParse(str) {
          const m = RGB_RE.exec(str);
          let a = 255;
          let r, g, b;
          if (!m) {
            return;
          }
          if (m[7] !== r) {
            const v = +m[7];
            a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
          }
          r = +m[1];
          g = +m[3];
          b = +m[5];
          r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
          g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
          b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
          return {
            r,
            g,
            b,
            a
          };
        }
        function rgbString(v) {
          return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
        }
        const to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
        const from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
        function interpolate$1(rgb1, rgb2, t) {
          const r = from(b2n(rgb1.r));
          const g = from(b2n(rgb1.g));
          const b = from(b2n(rgb1.b));
          return {
            r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
            g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
            b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
            a: rgb1.a + t * (rgb2.a - rgb1.a)
          };
        }
        function modHSL(v, i, ratio) {
          if (v) {
            let tmp = rgb2hsl(v);
            tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
            tmp = hsl2rgb(tmp);
            v.r = tmp[0];
            v.g = tmp[1];
            v.b = tmp[2];
          }
        }
        function clone2(v, proto) {
          return v ? Object.assign(proto || {}, v) : v;
        }
        function fromObject(input) {
          var v = { r: 0, g: 0, b: 0, a: 255 };
          if (Array.isArray(input)) {
            if (input.length >= 3) {
              v = { r: input[0], g: input[1], b: input[2], a: 255 };
              if (input.length > 3) {
                v.a = n2b(input[3]);
              }
            }
          } else {
            v = clone2(input, { r: 0, g: 0, b: 0, a: 1 });
            v.a = n2b(v.a);
          }
          return v;
        }
        function functionParse(str) {
          if (str.charAt(0) === "r") {
            return rgbParse(str);
          }
          return hueParse(str);
        }
        class Color {
          constructor(input) {
            if (input instanceof Color) {
              return input;
            }
            const type = typeof input;
            let v;
            if (type === "object") {
              v = fromObject(input);
            } else if (type === "string") {
              v = hexParse(input) || nameParse(input) || functionParse(input);
            }
            this._rgb = v;
            this._valid = !!v;
          }
          get valid() {
            return this._valid;
          }
          get rgb() {
            var v = clone2(this._rgb);
            if (v) {
              v.a = b2n(v.a);
            }
            return v;
          }
          set rgb(obj) {
            this._rgb = fromObject(obj);
          }
          rgbString() {
            return this._valid ? rgbString(this._rgb) : void 0;
          }
          hexString() {
            return this._valid ? hexString(this._rgb) : void 0;
          }
          hslString() {
            return this._valid ? hslString(this._rgb) : void 0;
          }
          mix(color2, weight) {
            if (color2) {
              const c1 = this.rgb;
              const c2 = color2.rgb;
              let w2;
              const p = weight === w2 ? 0.5 : weight;
              const w = 2 * p - 1;
              const a = c1.a - c2.a;
              const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
              w2 = 1 - w1;
              c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
              c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
              c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
              c1.a = p * c1.a + (1 - p) * c2.a;
              this.rgb = c1;
            }
            return this;
          }
          interpolate(color2, t) {
            if (color2) {
              this._rgb = interpolate$1(this._rgb, color2._rgb, t);
            }
            return this;
          }
          clone() {
            return new Color(this.rgb);
          }
          alpha(a) {
            this._rgb.a = n2b(a);
            return this;
          }
          clearer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 - ratio;
            return this;
          }
          greyscale() {
            const rgb = this._rgb;
            const val2 = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
            rgb.r = rgb.g = rgb.b = val2;
            return this;
          }
          opaquer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 + ratio;
            return this;
          }
          negate() {
            const v = this._rgb;
            v.r = 255 - v.r;
            v.g = 255 - v.g;
            v.b = 255 - v.b;
            return this;
          }
          lighten(ratio) {
            modHSL(this._rgb, 2, ratio);
            return this;
          }
          darken(ratio) {
            modHSL(this._rgb, 2, -ratio);
            return this;
          }
          saturate(ratio) {
            modHSL(this._rgb, 1, ratio);
            return this;
          }
          desaturate(ratio) {
            modHSL(this._rgb, 1, -ratio);
            return this;
          }
          rotate(deg) {
            rotate(this._rgb, deg);
            return this;
          }
        }
        function index_esm(input) {
          return new Color(input);
        }
        function isPatternOrGradient(value) {
          if (value && typeof value === "object") {
            const type = value.toString();
            return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
          }
          return false;
        }
        function color(value) {
          return isPatternOrGradient(value) ? value : index_esm(value);
        }
        function getHoverColor(value) {
          return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
        }
        const overrides = Object.create(null);
        const descriptors = Object.create(null);
        function getScope$1(node, key) {
          if (!key) {
            return node;
          }
          const keys = key.split(".");
          for (let i = 0, n = keys.length; i < n; ++i) {
            const k = keys[i];
            node = node[k] || (node[k] = Object.create(null));
          }
          return node;
        }
        function set(root, scope, values) {
          if (typeof scope === "string") {
            return merge(getScope$1(root, scope), values);
          }
          return merge(getScope$1(root, ""), scope);
        }
        class Defaults {
          constructor(_descriptors2) {
            this.animation = void 0;
            this.backgroundColor = "rgba(0,0,0,0.1)";
            this.borderColor = "rgba(0,0,0,0.1)";
            this.color = "#666";
            this.datasets = {};
            this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
            this.elements = {};
            this.events = [
              "mousemove",
              "mouseout",
              "click",
              "touchstart",
              "touchmove"
            ];
            this.font = {
              family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
              size: 12,
              style: "normal",
              lineHeight: 1.2,
              weight: null
            };
            this.hover = {};
            this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
            this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
            this.hoverColor = (ctx, options) => getHoverColor(options.color);
            this.indexAxis = "x";
            this.interaction = {
              mode: "nearest",
              intersect: true,
              includeInvisible: false
            };
            this.maintainAspectRatio = true;
            this.onHover = null;
            this.onClick = null;
            this.parsing = true;
            this.plugins = {};
            this.responsive = true;
            this.scale = void 0;
            this.scales = {};
            this.showLine = true;
            this.drawActiveElementsOnTop = true;
            this.describe(_descriptors2);
          }
          set(scope, values) {
            return set(this, scope, values);
          }
          get(scope) {
            return getScope$1(this, scope);
          }
          describe(scope, values) {
            return set(descriptors, scope, values);
          }
          override(scope, values) {
            return set(overrides, scope, values);
          }
          route(scope, name, targetScope, targetName) {
            const scopeObject = getScope$1(this, scope);
            const targetScopeObject = getScope$1(this, targetScope);
            const privateName = "_" + name;
            Object.defineProperties(scopeObject, {
              [privateName]: {
                value: scopeObject[name],
                writable: true
              },
              [name]: {
                enumerable: true,
                get() {
                  const local = this[privateName];
                  const target = targetScopeObject[targetName];
                  if (isObject2(local)) {
                    return Object.assign({}, target, local);
                  }
                  return valueOrDefault(local, target);
                },
                set(value) {
                  this[privateName] = value;
                }
              }
            });
          }
        }
        var defaults = new Defaults({
          _scriptable: (name) => !name.startsWith("on"),
          _indexable: (name) => name !== "events",
          hover: {
            _fallback: "interaction"
          },
          interaction: {
            _scriptable: false,
            _indexable: false
          }
        });
        function _isDomSupported() {
          return typeof window !== "undefined" && typeof document !== "undefined";
        }
        function _getParentNode(domNode) {
          let parent = domNode.parentNode;
          if (parent && parent.toString() === "[object ShadowRoot]") {
            parent = parent.host;
          }
          return parent;
        }
        function parseMaxStyle(styleValue, node, parentProperty) {
          let valueInPixels;
          if (typeof styleValue === "string") {
            valueInPixels = parseInt(styleValue, 10);
            if (styleValue.indexOf("%") !== -1) {
              valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
            }
          } else {
            valueInPixels = styleValue;
          }
          return valueInPixels;
        }
        const getComputedStyle2 = (element) => window.getComputedStyle(element, null);
        function getStyle(el, property) {
          return getComputedStyle2(el).getPropertyValue(property);
        }
        const positions = ["top", "right", "bottom", "left"];
        function getPositionedStyle(styles, style, suffix) {
          const result = {};
          suffix = suffix ? "-" + suffix : "";
          for (let i = 0; i < 4; i++) {
            const pos = positions[i];
            result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
          }
          result.width = result.left + result.right;
          result.height = result.top + result.bottom;
          return result;
        }
        const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
        function getCanvasPosition(e, canvas) {
          const touches = e.touches;
          const source = touches && touches.length ? touches[0] : e;
          const { offsetX, offsetY } = source;
          let box = false;
          let x, y;
          if (useOffsetPos(offsetX, offsetY, e.target)) {
            x = offsetX;
            y = offsetY;
          } else {
            const rect = canvas.getBoundingClientRect();
            x = source.clientX - rect.left;
            y = source.clientY - rect.top;
            box = true;
          }
          return { x, y, box };
        }
        function getRelativePosition(evt, chart2) {
          if ("native" in evt) {
            return evt;
          }
          const { canvas, currentDevicePixelRatio } = chart2;
          const style = getComputedStyle2(canvas);
          const borderBox = style.boxSizing === "border-box";
          const paddings = getPositionedStyle(style, "padding");
          const borders = getPositionedStyle(style, "border", "width");
          const { x, y, box } = getCanvasPosition(evt, canvas);
          const xOffset = paddings.left + (box && borders.left);
          const yOffset = paddings.top + (box && borders.top);
          let { width, height } = chart2;
          if (borderBox) {
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          return {
            x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
            y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
          };
        }
        function getContainerSize(canvas, width, height) {
          let maxWidth, maxHeight;
          if (width === void 0 || height === void 0) {
            const container = _getParentNode(canvas);
            if (!container) {
              width = canvas.clientWidth;
              height = canvas.clientHeight;
            } else {
              const rect = container.getBoundingClientRect();
              const containerStyle = getComputedStyle2(container);
              const containerBorder = getPositionedStyle(containerStyle, "border", "width");
              const containerPadding = getPositionedStyle(containerStyle, "padding");
              width = rect.width - containerPadding.width - containerBorder.width;
              height = rect.height - containerPadding.height - containerBorder.height;
              maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
              maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
            }
          }
          return {
            width,
            height,
            maxWidth: maxWidth || INFINITY,
            maxHeight: maxHeight || INFINITY
          };
        }
        const round1 = (v) => Math.round(v * 10) / 10;
        function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
          const style = getComputedStyle2(canvas);
          const margins = getPositionedStyle(style, "margin");
          const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
          const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
          const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
          let { width, height } = containerSize;
          if (style.boxSizing === "content-box") {
            const borders = getPositionedStyle(style, "border", "width");
            const paddings = getPositionedStyle(style, "padding");
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          width = Math.max(0, width - margins.width);
          height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
          width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
          height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
          if (width && !height) {
            height = round1(width / 2);
          }
          return {
            width,
            height
          };
        }
        function retinaScale(chart2, forceRatio, forceStyle) {
          const pixelRatio = forceRatio || 1;
          const deviceHeight = Math.floor(chart2.height * pixelRatio);
          const deviceWidth = Math.floor(chart2.width * pixelRatio);
          chart2.height = deviceHeight / pixelRatio;
          chart2.width = deviceWidth / pixelRatio;
          const canvas = chart2.canvas;
          if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
            canvas.style.height = `${chart2.height}px`;
            canvas.style.width = `${chart2.width}px`;
          }
          if (chart2.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
            chart2.currentDevicePixelRatio = pixelRatio;
            canvas.height = deviceHeight;
            canvas.width = deviceWidth;
            chart2.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            return true;
          }
          return false;
        }
        const supportsEventListenerOptions = function() {
          let passiveSupported = false;
          try {
            const options = {
              get passive() {
                passiveSupported = true;
                return false;
              }
            };
            window.addEventListener("test", null, options);
            window.removeEventListener("test", null, options);
          } catch (e) {
          }
          return passiveSupported;
        }();
        function readUsedSize(element, property) {
          const value = getStyle(element, property);
          const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
          return matches ? +matches[1] : void 0;
        }
        function toFontString(font) {
          if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
            return null;
          }
          return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        function _measureText(ctx, data, gc, longest, string) {
          let textWidth = data[string];
          if (!textWidth) {
            textWidth = data[string] = ctx.measureText(string).width;
            gc.push(string);
          }
          if (textWidth > longest) {
            longest = textWidth;
          }
          return longest;
        }
        function _longestText(ctx, font, arrayOfThings, cache) {
          cache = cache || {};
          let data = cache.data = cache.data || {};
          let gc = cache.garbageCollect = cache.garbageCollect || [];
          if (cache.font !== font) {
            data = cache.data = {};
            gc = cache.garbageCollect = [];
            cache.font = font;
          }
          ctx.save();
          ctx.font = font;
          let longest = 0;
          const ilen = arrayOfThings.length;
          let i, j, jlen, thing, nestedThing;
          for (i = 0; i < ilen; i++) {
            thing = arrayOfThings[i];
            if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
              longest = _measureText(ctx, data, gc, longest, thing);
            } else if (isArray(thing)) {
              for (j = 0, jlen = thing.length; j < jlen; j++) {
                nestedThing = thing[j];
                if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
                  longest = _measureText(ctx, data, gc, longest, nestedThing);
                }
              }
            }
          }
          ctx.restore();
          const gcLen = gc.length / 2;
          if (gcLen > arrayOfThings.length) {
            for (i = 0; i < gcLen; i++) {
              delete data[gc[i]];
            }
            gc.splice(0, gcLen);
          }
          return longest;
        }
        function _alignPixel(chart2, pixel, width) {
          const devicePixelRatio = chart2.currentDevicePixelRatio;
          const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
          return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
        }
        function clearCanvas(canvas, ctx) {
          ctx = ctx || canvas.getContext("2d");
          ctx.save();
          ctx.resetTransform();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }
        function drawPoint(ctx, options, x, y) {
          drawPointLegend(ctx, options, x, y, null);
        }
        function drawPointLegend(ctx, options, x, y, w) {
          let type, xOffset, yOffset, size, cornerRadius, width;
          const style = options.pointStyle;
          const rotation = options.rotation;
          const radius = options.radius;
          let rad = (rotation || 0) * RAD_PER_DEG;
          if (style && typeof style === "object") {
            type = style.toString();
            if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate(rad);
              ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
              ctx.restore();
              return;
            }
          }
          if (isNaN(radius) || radius <= 0) {
            return;
          }
          ctx.beginPath();
          switch (style) {
            default:
              if (w) {
                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
              } else {
                ctx.arc(x, y, radius, 0, TAU);
              }
              ctx.closePath();
              break;
            case "triangle":
              ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              ctx.closePath();
              break;
            case "rectRounded":
              cornerRadius = radius * 0.516;
              size = radius - cornerRadius;
              xOffset = Math.cos(rad + QUARTER_PI) * size;
              yOffset = Math.sin(rad + QUARTER_PI) * size;
              ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
              ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
              ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
              ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
              ctx.closePath();
              break;
            case "rect":
              if (!rotation) {
                size = Math.SQRT1_2 * radius;
                width = w ? w / 2 : size;
                ctx.rect(x - width, y - size, 2 * width, 2 * size);
                break;
              }
              rad += QUARTER_PI;
            case "rectRot":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + yOffset, y - xOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              ctx.closePath();
              break;
            case "crossRot":
              rad += QUARTER_PI;
            case "cross":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              break;
            case "star":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              rad += QUARTER_PI;
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              break;
            case "line":
              xOffset = w ? w / 2 : Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              break;
            case "dash":
              ctx.moveTo(x, y);
              ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
              break;
          }
          ctx.fill();
          if (options.borderWidth > 0) {
            ctx.stroke();
          }
        }
        function _isPointInArea(point, area, margin) {
          margin = margin || 0.5;
          return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
        }
        function clipArea(ctx, area) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
          ctx.clip();
        }
        function unclipArea(ctx) {
          ctx.restore();
        }
        function _steppedLineTo(ctx, previous, target, flip, mode) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          if (mode === "middle") {
            const midpoint = (previous.x + target.x) / 2;
            ctx.lineTo(midpoint, previous.y);
            ctx.lineTo(midpoint, target.y);
          } else if (mode === "after" !== !!flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }
          ctx.lineTo(target.x, target.y);
        }
        function _bezierCurveTo(ctx, previous, target, flip) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
        }
        function renderText(ctx, text, x, y, font, opts = {}) {
          const lines = isArray(text) ? text : [text];
          const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
          let i, line;
          ctx.save();
          ctx.font = font.string;
          setRenderOpts(ctx, opts);
          for (i = 0; i < lines.length; ++i) {
            line = lines[i];
            if (stroke) {
              if (opts.strokeColor) {
                ctx.strokeStyle = opts.strokeColor;
              }
              if (!isNullOrUndef(opts.strokeWidth)) {
                ctx.lineWidth = opts.strokeWidth;
              }
              ctx.strokeText(line, x, y, opts.maxWidth);
            }
            ctx.fillText(line, x, y, opts.maxWidth);
            decorateText(ctx, x, y, line, opts);
            y += font.lineHeight;
          }
          ctx.restore();
        }
        function setRenderOpts(ctx, opts) {
          if (opts.translation) {
            ctx.translate(opts.translation[0], opts.translation[1]);
          }
          if (!isNullOrUndef(opts.rotation)) {
            ctx.rotate(opts.rotation);
          }
          if (opts.color) {
            ctx.fillStyle = opts.color;
          }
          if (opts.textAlign) {
            ctx.textAlign = opts.textAlign;
          }
          if (opts.textBaseline) {
            ctx.textBaseline = opts.textBaseline;
          }
        }
        function decorateText(ctx, x, y, line, opts) {
          if (opts.strikethrough || opts.underline) {
            const metrics = ctx.measureText(line);
            const left = x - metrics.actualBoundingBoxLeft;
            const right = x + metrics.actualBoundingBoxRight;
            const top = y - metrics.actualBoundingBoxAscent;
            const bottom = y + metrics.actualBoundingBoxDescent;
            const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.beginPath();
            ctx.lineWidth = opts.decorationWidth || 2;
            ctx.moveTo(left, yDecoration);
            ctx.lineTo(right, yDecoration);
            ctx.stroke();
          }
        }
        function addRoundedRectPath(ctx, rect) {
          const { x, y, w, h, radius } = rect;
          ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
          ctx.lineTo(x, y + h - radius.bottomLeft);
          ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
          ctx.lineTo(x + w - radius.bottomRight, y + h);
          ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
          ctx.lineTo(x + w, y + radius.topRight);
          ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
          ctx.lineTo(x + radius.topLeft, y);
        }
        function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
          if (!defined(fallback)) {
            fallback = _resolve("_fallback", scopes);
          }
          const cache = {
            [Symbol.toStringTag]: "Object",
            _cacheable: true,
            _scopes: scopes,
            _rootScopes: rootScopes,
            _fallback: fallback,
            _getTarget: getTarget,
            override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
          };
          return new Proxy(cache, {
            deleteProperty(target, prop) {
              delete target[prop];
              delete target._keys;
              delete scopes[0][prop];
              return true;
            },
            get(target, prop) {
              return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
            },
            getOwnPropertyDescriptor(target, prop) {
              return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
            },
            getPrototypeOf() {
              return Reflect.getPrototypeOf(scopes[0]);
            },
            has(target, prop) {
              return getKeysFromAllScopes(target).includes(prop);
            },
            ownKeys(target) {
              return getKeysFromAllScopes(target);
            },
            set(target, prop, value) {
              const storage = target._storage || (target._storage = getTarget());
              target[prop] = storage[prop] = value;
              delete target._keys;
              return true;
            }
          });
        }
        function _attachContext(proxy, context, subProxy, descriptorDefaults) {
          const cache = {
            _cacheable: false,
            _proxy: proxy,
            _context: context,
            _subProxy: subProxy,
            _stack: /* @__PURE__ */ new Set(),
            _descriptors: _descriptors(proxy, descriptorDefaults),
            setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
            override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
          };
          return new Proxy(cache, {
            deleteProperty(target, prop) {
              delete target[prop];
              delete proxy[prop];
              return true;
            },
            get(target, prop, receiver) {
              return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
            },
            getOwnPropertyDescriptor(target, prop) {
              return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
            },
            getPrototypeOf() {
              return Reflect.getPrototypeOf(proxy);
            },
            has(target, prop) {
              return Reflect.has(proxy, prop);
            },
            ownKeys() {
              return Reflect.ownKeys(proxy);
            },
            set(target, prop, value) {
              proxy[prop] = value;
              delete target[prop];
              return true;
            }
          });
        }
        function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
          const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
          return {
            allKeys: _allKeys,
            scriptable: _scriptable,
            indexable: _indexable,
            isScriptable: isFunction2(_scriptable) ? _scriptable : () => _scriptable,
            isIndexable: isFunction2(_indexable) ? _indexable : () => _indexable
          };
        }
        const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
        const needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
        function _cached(target, prop, resolve2) {
          if (Object.prototype.hasOwnProperty.call(target, prop)) {
            return target[prop];
          }
          const value = resolve2();
          target[prop] = value;
          return value;
        }
        function _resolveWithContext(target, prop, receiver) {
          const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
          let value = _proxy[prop];
          if (isFunction2(value) && descriptors2.isScriptable(prop)) {
            value = _resolveScriptable(prop, value, target, receiver);
          }
          if (isArray(value) && value.length) {
            value = _resolveArray(prop, value, target, descriptors2.isIndexable);
          }
          if (needsSubResolver(prop, value)) {
            value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
          }
          return value;
        }
        function _resolveScriptable(prop, value, target, receiver) {
          const { _proxy, _context, _subProxy, _stack } = target;
          if (_stack.has(prop)) {
            throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
          }
          _stack.add(prop);
          value = value(_context, _subProxy || receiver);
          _stack.delete(prop);
          if (needsSubResolver(prop, value)) {
            value = createSubResolver(_proxy._scopes, _proxy, prop, value);
          }
          return value;
        }
        function _resolveArray(prop, value, target, isIndexable) {
          const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
          if (defined(_context.index) && isIndexable(prop)) {
            value = value[_context.index % value.length];
          } else if (isObject2(value[0])) {
            const arr = value;
            const scopes = _proxy._scopes.filter((s) => s !== arr);
            value = [];
            for (const item of arr) {
              const resolver = createSubResolver(scopes, _proxy, prop, item);
              value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
            }
          }
          return value;
        }
        function resolveFallback(fallback, prop, value) {
          return isFunction2(fallback) ? fallback(prop, value) : fallback;
        }
        const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
        function addScopes(set2, parentScopes, key, parentFallback, value) {
          for (const parent of parentScopes) {
            const scope = getScope(key, parent);
            if (scope) {
              set2.add(scope);
              const fallback = resolveFallback(scope._fallback, key, value);
              if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
                return fallback;
              }
            } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
              return null;
            }
          }
          return false;
        }
        function createSubResolver(parentScopes, resolver, prop, value) {
          const rootScopes = resolver._rootScopes;
          const fallback = resolveFallback(resolver._fallback, prop, value);
          const allScopes = [...parentScopes, ...rootScopes];
          const set2 = /* @__PURE__ */ new Set();
          set2.add(value);
          let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
          if (key === null) {
            return false;
          }
          if (defined(fallback) && fallback !== prop) {
            key = addScopesFromKey(set2, allScopes, fallback, key, value);
            if (key === null) {
              return false;
            }
          }
          return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
        }
        function addScopesFromKey(set2, allScopes, key, fallback, item) {
          while (key) {
            key = addScopes(set2, allScopes, key, fallback, item);
          }
          return key;
        }
        function subGetTarget(resolver, prop, value) {
          const parent = resolver._getTarget();
          if (!(prop in parent)) {
            parent[prop] = {};
          }
          const target = parent[prop];
          if (isArray(target) && isObject2(value)) {
            return value;
          }
          return target;
        }
        function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
          let value;
          for (const prefix of prefixes) {
            value = _resolve(readKey(prefix, prop), scopes);
            if (defined(value)) {
              return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
            }
          }
        }
        function _resolve(key, scopes) {
          for (const scope of scopes) {
            if (!scope) {
              continue;
            }
            const value = scope[key];
            if (defined(value)) {
              return value;
            }
          }
        }
        function getKeysFromAllScopes(target) {
          let keys = target._keys;
          if (!keys) {
            keys = target._keys = resolveKeysFromAllScopes(target._scopes);
          }
          return keys;
        }
        function resolveKeysFromAllScopes(scopes) {
          const set2 = /* @__PURE__ */ new Set();
          for (const scope of scopes) {
            for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
              set2.add(key);
            }
          }
          return Array.from(set2);
        }
        function _parseObjectDataRadialScale(meta, data, start, count) {
          const { iScale } = meta;
          const { key = "r" } = this._parsing;
          const parsed = new Array(count);
          let i, ilen, index3, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index3 = i + start;
            item = data[index3];
            parsed[i] = {
              r: iScale.parse(resolveObjectKey(item, key), index3)
            };
          }
          return parsed;
        }
        const EPSILON = Number.EPSILON || 1e-14;
        const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
        const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
        function splineCurve(firstPoint, middlePoint, afterPoint, t) {
          const previous = firstPoint.skip ? middlePoint : firstPoint;
          const current = middlePoint;
          const next = afterPoint.skip ? middlePoint : afterPoint;
          const d01 = distanceBetweenPoints(current, previous);
          const d12 = distanceBetweenPoints(next, current);
          let s01 = d01 / (d01 + d12);
          let s12 = d12 / (d01 + d12);
          s01 = isNaN(s01) ? 0 : s01;
          s12 = isNaN(s12) ? 0 : s12;
          const fa = t * s01;
          const fb = t * s12;
          return {
            previous: {
              x: current.x - fa * (next.x - previous.x),
              y: current.y - fa * (next.y - previous.y)
            },
            next: {
              x: current.x + fb * (next.x - previous.x),
              y: current.y + fb * (next.y - previous.y)
            }
          };
        }
        function monotoneAdjust(points, deltaK, mK) {
          const pointsLen = points.length;
          let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen - 1; ++i) {
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent || !pointAfter) {
              continue;
            }
            if (almostEquals(deltaK[i], 0, EPSILON)) {
              mK[i] = mK[i + 1] = 0;
              continue;
            }
            alphaK = mK[i] / deltaK[i];
            betaK = mK[i + 1] / deltaK[i];
            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
            if (squaredMagnitude <= 9) {
              continue;
            }
            tauK = 3 / Math.sqrt(squaredMagnitude);
            mK[i] = alphaK * tauK * deltaK[i];
            mK[i + 1] = betaK * tauK * deltaK[i];
          }
        }
        function monotoneCompute(points, mK, indexAxis = "x") {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          let delta, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            const iPixel = pointCurrent[indexAxis];
            const vPixel = pointCurrent[valueAxis];
            if (pointBefore) {
              delta = (iPixel - pointBefore[indexAxis]) / 3;
              pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
              pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
            }
            if (pointAfter) {
              delta = (pointAfter[indexAxis] - iPixel) / 3;
              pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
              pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
            }
          }
        }
        function splineCurveMonotone(points, indexAxis = "x") {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          const deltaK = Array(pointsLen).fill(0);
          const mK = Array(pointsLen);
          let i, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            if (pointAfter) {
              const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
              deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
            }
            mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
          }
          monotoneAdjust(points, deltaK, mK);
          monotoneCompute(points, mK, indexAxis);
        }
        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }
        function capBezierPoints(points, area) {
          let i, ilen, point, inArea, inAreaPrev;
          let inAreaNext = _isPointInArea(points[0], area);
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            inAreaPrev = inArea;
            inArea = inAreaNext;
            inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
            if (!inArea) {
              continue;
            }
            point = points[i];
            if (inAreaPrev) {
              point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
              point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
            }
            if (inAreaNext) {
              point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
              point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
            }
          }
        }
        function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
          let i, ilen, point, controlPoints;
          if (options.spanGaps) {
            points = points.filter((pt) => !pt.skip);
          }
          if (options.cubicInterpolationMode === "monotone") {
            splineCurveMonotone(points, indexAxis);
          } else {
            let prev = loop ? points[points.length - 1] : points[0];
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              point = points[i];
              controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
              point.cp1x = controlPoints.previous.x;
              point.cp1y = controlPoints.previous.y;
              point.cp2x = controlPoints.next.x;
              point.cp2y = controlPoints.next.y;
              prev = point;
            }
          }
          if (options.capBezierPoints) {
            capBezierPoints(points, area);
          }
        }
        const atEdge = (t) => t === 0 || t === 1;
        const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
        const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
        const effects = {
          linear: (t) => t,
          easeInQuad: (t) => t * t,
          easeOutQuad: (t) => -t * (t - 2),
          easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
          easeInCubic: (t) => t * t * t,
          easeOutCubic: (t) => (t -= 1) * t * t + 1,
          easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
          easeInQuart: (t) => t * t * t * t,
          easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
          easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
          easeInQuint: (t) => t * t * t * t * t,
          easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
          easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
          easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
          easeOutSine: (t) => Math.sin(t * HALF_PI),
          easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
          easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
          easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
          easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
          easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
          easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
          easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
          easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
          easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
          easeInOutElastic(t) {
            const s = 0.1125;
            const p = 0.45;
            return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
          },
          easeInBack(t) {
            const s = 1.70158;
            return t * t * ((s + 1) * t - s);
          },
          easeOutBack(t) {
            const s = 1.70158;
            return (t -= 1) * t * ((s + 1) * t + s) + 1;
          },
          easeInOutBack(t) {
            let s = 1.70158;
            if ((t /= 0.5) < 1) {
              return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
            }
            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
          },
          easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
          easeOutBounce(t) {
            const m = 7.5625;
            const d = 2.75;
            if (t < 1 / d) {
              return m * t * t;
            }
            if (t < 2 / d) {
              return m * (t -= 1.5 / d) * t + 0.75;
            }
            if (t < 2.5 / d) {
              return m * (t -= 2.25 / d) * t + 0.9375;
            }
            return m * (t -= 2.625 / d) * t + 0.984375;
          },
          easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
        };
        function _pointInLine(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y: p1.y + t * (p2.y - p1.y)
          };
        }
        function _steppedInterpolation(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
          };
        }
        function _bezierInterpolation(p1, p2, t, mode) {
          const cp1 = { x: p1.cp2x, y: p1.cp2y };
          const cp2 = { x: p2.cp1x, y: p2.cp1y };
          const a = _pointInLine(p1, cp1, t);
          const b = _pointInLine(cp1, cp2, t);
          const c = _pointInLine(cp2, p2, t);
          const d = _pointInLine(a, b, t);
          const e = _pointInLine(b, c, t);
          return _pointInLine(d, e, t);
        }
        const intlCache = /* @__PURE__ */ new Map();
        function getNumberFormat(locale, options) {
          options = options || {};
          const cacheKey = locale + JSON.stringify(options);
          let formatter = intlCache.get(cacheKey);
          if (!formatter) {
            formatter = new Intl.NumberFormat(locale, options);
            intlCache.set(cacheKey, formatter);
          }
          return formatter;
        }
        function formatNumber(num, locale, options) {
          return getNumberFormat(locale, options).format(num);
        }
        const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
        const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
        function toLineHeight(value, size) {
          const matches = ("" + value).match(LINE_HEIGHT);
          if (!matches || matches[1] === "normal") {
            return size * 1.2;
          }
          value = +matches[2];
          switch (matches[3]) {
            case "px":
              return value;
            case "%":
              value /= 100;
              break;
          }
          return size * value;
        }
        const numberOrZero = (v) => +v || 0;
        function _readValueToProps(value, props) {
          const ret = {};
          const objProps = isObject2(props);
          const keys = objProps ? Object.keys(props) : props;
          const read = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
          for (const prop of keys) {
            ret[prop] = numberOrZero(read(prop));
          }
          return ret;
        }
        function toTRBL(value) {
          return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
        }
        function toTRBLCorners(value) {
          return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
        }
        function toPadding(value) {
          const obj = toTRBL(value);
          obj.width = obj.left + obj.right;
          obj.height = obj.top + obj.bottom;
          return obj;
        }
        function toFont(options, fallback) {
          options = options || {};
          fallback = fallback || defaults.font;
          let size = valueOrDefault(options.size, fallback.size);
          if (typeof size === "string") {
            size = parseInt(size, 10);
          }
          let style = valueOrDefault(options.style, fallback.style);
          if (style && !("" + style).match(FONT_STYLE)) {
            console.warn('Invalid font style specified: "' + style + '"');
            style = "";
          }
          const font = {
            family: valueOrDefault(options.family, fallback.family),
            lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
            size,
            style,
            weight: valueOrDefault(options.weight, fallback.weight),
            string: ""
          };
          font.string = toFontString(font);
          return font;
        }
        function resolve(inputs, context, index3, info) {
          let cacheable = true;
          let i, ilen, value;
          for (i = 0, ilen = inputs.length; i < ilen; ++i) {
            value = inputs[i];
            if (value === void 0) {
              continue;
            }
            if (context !== void 0 && typeof value === "function") {
              value = value(context);
              cacheable = false;
            }
            if (index3 !== void 0 && isArray(value)) {
              value = value[index3 % value.length];
              cacheable = false;
            }
            if (value !== void 0) {
              if (info && !cacheable) {
                info.cacheable = false;
              }
              return value;
            }
          }
        }
        function _addGrace(minmax, grace, beginAtZero) {
          const { min, max } = minmax;
          const change = toDimension(grace, (max - min) / 2);
          const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
          return {
            min: keepZero(min, -Math.abs(change)),
            max: keepZero(max, change)
          };
        }
        function createContext(parentContext, context) {
          return Object.assign(Object.create(parentContext), context);
        }
        const getRightToLeftAdapter = function(rectX, width) {
          return {
            x(x) {
              return rectX + rectX + width - x;
            },
            setWidth(w) {
              width = w;
            },
            textAlign(align) {
              if (align === "center") {
                return align;
              }
              return align === "right" ? "left" : "right";
            },
            xPlus(x, value) {
              return x - value;
            },
            leftForLtr(x, itemWidth) {
              return x - itemWidth;
            }
          };
        };
        const getLeftToRightAdapter = function() {
          return {
            x(x) {
              return x;
            },
            setWidth(w) {
            },
            textAlign(align) {
              return align;
            },
            xPlus(x, value) {
              return x + value;
            },
            leftForLtr(x, _itemWidth) {
              return x;
            }
          };
        };
        function getRtlAdapter(rtl, rectX, width) {
          return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
        }
        function overrideTextDirection(ctx, direction) {
          let style, original;
          if (direction === "ltr" || direction === "rtl") {
            style = ctx.canvas.style;
            original = [
              style.getPropertyValue("direction"),
              style.getPropertyPriority("direction")
            ];
            style.setProperty("direction", direction, "important");
            ctx.prevTextDirection = original;
          }
        }
        function restoreTextDirection(ctx, original) {
          if (original !== void 0) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty("direction", original[0], original[1]);
          }
        }
        function propertyFn(property) {
          if (property === "angle") {
            return {
              between: _angleBetween,
              compare: _angleDiff,
              normalize: _normalizeAngle
            };
          }
          return {
            between: _isBetween,
            compare: (a, b) => a - b,
            normalize: (x) => x
          };
        }
        function normalizeSegment({ start, end, count, loop, style }) {
          return {
            start: start % count,
            end: end % count,
            loop: loop && (end - start + 1) % count === 0,
            style
          };
        }
        function getSegment(segment, points, bounds) {
          const { property, start: startBound, end: endBound } = bounds;
          const { between, normalize } = propertyFn(property);
          const count = points.length;
          let { start, end, loop } = segment;
          let i, ilen;
          if (loop) {
            start += count;
            end += count;
            for (i = 0, ilen = count; i < ilen; ++i) {
              if (!between(normalize(points[start % count][property]), startBound, endBound)) {
                break;
              }
              start--;
              end--;
            }
            start %= count;
            end %= count;
          }
          if (end < start) {
            end += count;
          }
          return { start, end, loop, style: segment.style };
        }
        function _boundSegment(segment, points, bounds) {
          if (!bounds) {
            return [segment];
          }
          const { property, start: startBound, end: endBound } = bounds;
          const count = points.length;
          const { compare, between, normalize } = propertyFn(property);
          const { start, end, loop, style } = getSegment(segment, points, bounds);
          const result = [];
          let inside = false;
          let subStart = null;
          let value, point, prevValue;
          const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
          const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
          const shouldStart = () => inside || startIsBefore();
          const shouldStop = () => !inside || endIsBefore();
          for (let i = start, prev = start; i <= end; ++i) {
            point = points[i % count];
            if (point.skip) {
              continue;
            }
            value = normalize(point[property]);
            if (value === prevValue) {
              continue;
            }
            inside = between(value, startBound, endBound);
            if (subStart === null && shouldStart()) {
              subStart = compare(value, startBound) === 0 ? i : prev;
            }
            if (subStart !== null && shouldStop()) {
              result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
              subStart = null;
            }
            prev = i;
            prevValue = value;
          }
          if (subStart !== null) {
            result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
          }
          return result;
        }
        function _boundSegments(line, bounds) {
          const result = [];
          const segments = line.segments;
          for (let i = 0; i < segments.length; i++) {
            const sub = _boundSegment(segments[i], line.points, bounds);
            if (sub.length) {
              result.push(...sub);
            }
          }
          return result;
        }
        function findStartAndEnd(points, count, loop, spanGaps) {
          let start = 0;
          let end = count - 1;
          if (loop && !spanGaps) {
            while (start < count && !points[start].skip) {
              start++;
            }
          }
          while (start < count && points[start].skip) {
            start++;
          }
          start %= count;
          if (loop) {
            end += start;
          }
          while (end > start && points[end % count].skip) {
            end--;
          }
          end %= count;
          return { start, end };
        }
        function solidSegments(points, start, max, loop) {
          const count = points.length;
          const result = [];
          let last = start;
          let prev = points[start];
          let end;
          for (end = start + 1; end <= max; ++end) {
            const cur = points[end % count];
            if (cur.skip || cur.stop) {
              if (!prev.skip) {
                loop = false;
                result.push({ start: start % count, end: (end - 1) % count, loop });
                start = last = cur.stop ? end : null;
              }
            } else {
              last = end;
              if (prev.skip) {
                start = end;
              }
            }
            prev = cur;
          }
          if (last !== null) {
            result.push({ start: start % count, end: last % count, loop });
          }
          return result;
        }
        function _computeSegments(line, segmentOptions) {
          const points = line.points;
          const spanGaps = line.options.spanGaps;
          const count = points.length;
          if (!count) {
            return [];
          }
          const loop = !!line._loop;
          const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
          if (spanGaps === true) {
            return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
          }
          const max = end < start ? end + count : end;
          const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
          return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
        }
        function splitByStyles(line, segments, points, segmentOptions) {
          if (!segmentOptions || !segmentOptions.setContext || !points) {
            return segments;
          }
          return doSplitByStyles(line, segments, points, segmentOptions);
        }
        function doSplitByStyles(line, segments, points, segmentOptions) {
          const chartContext = line._chart.getContext();
          const baseStyle = readStyle(line.options);
          const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
          const count = points.length;
          const result = [];
          let prevStyle = baseStyle;
          let start = segments[0].start;
          let i = start;
          function addStyle(s, e, l, st) {
            const dir = spanGaps ? -1 : 1;
            if (s === e) {
              return;
            }
            s += count;
            while (points[s % count].skip) {
              s -= dir;
            }
            while (points[e % count].skip) {
              e += dir;
            }
            if (s % count !== e % count) {
              result.push({ start: s % count, end: e % count, loop: l, style: st });
              prevStyle = st;
              start = e % count;
            }
          }
          for (const segment of segments) {
            start = spanGaps ? start : segment.start;
            let prev = points[start % count];
            let style;
            for (i = start + 1; i <= segment.end; i++) {
              const pt = points[i % count];
              style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                type: "segment",
                p0: prev,
                p1: pt,
                p0DataIndex: (i - 1) % count,
                p1DataIndex: i % count,
                datasetIndex
              })));
              if (styleChanged(style, prevStyle)) {
                addStyle(start, i - 1, segment.loop, prevStyle);
              }
              prev = pt;
              prevStyle = style;
            }
            if (start < i - 1) {
              addStyle(start, i - 1, segment.loop, prevStyle);
            }
          }
          return result;
        }
        function readStyle(options) {
          return {
            backgroundColor: options.backgroundColor,
            borderCapStyle: options.borderCapStyle,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderJoinStyle: options.borderJoinStyle,
            borderWidth: options.borderWidth,
            borderColor: options.borderColor
          };
        }
        function styleChanged(style, prevStyle) {
          return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
        }
        var helpers = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          easingEffects: effects,
          isPatternOrGradient,
          color,
          getHoverColor,
          noop: noop2,
          uid,
          isNullOrUndef,
          isArray,
          isObject: isObject2,
          isFinite: isNumberFinite,
          finiteOrDefault,
          valueOrDefault,
          toPercentage,
          toDimension,
          callback,
          each,
          _elementsEqual,
          clone: clone$1,
          _merger,
          merge,
          mergeIf,
          _mergerIf,
          _deprecated,
          resolveObjectKey,
          _splitKey,
          _capitalize,
          defined,
          isFunction: isFunction2,
          setsEqual,
          _isClickEvent,
          toFontString,
          _measureText,
          _longestText,
          _alignPixel,
          clearCanvas,
          drawPoint,
          drawPointLegend,
          _isPointInArea,
          clipArea,
          unclipArea,
          _steppedLineTo,
          _bezierCurveTo,
          renderText,
          addRoundedRectPath,
          _lookup,
          _lookupByKey,
          _rlookupByKey,
          _filterBetween,
          listenArrayEvents,
          unlistenArrayEvents,
          _arrayUnique,
          _createResolver,
          _attachContext,
          _descriptors,
          _parseObjectDataRadialScale,
          splineCurve,
          splineCurveMonotone,
          _updateBezierControlPoints,
          _isDomSupported,
          _getParentNode,
          getStyle,
          getRelativePosition,
          getMaximumSize,
          retinaScale,
          supportsEventListenerOptions,
          readUsedSize,
          fontString,
          requestAnimFrame,
          throttled,
          debounce,
          _toLeftRightCenter,
          _alignStartEnd,
          _textX,
          _getStartAndCountOfVisiblePoints,
          _scaleRangesChanged,
          _pointInLine,
          _steppedInterpolation,
          _bezierInterpolation,
          formatNumber,
          toLineHeight,
          _readValueToProps,
          toTRBL,
          toTRBLCorners,
          toPadding,
          toFont,
          resolve,
          _addGrace,
          createContext,
          PI,
          TAU,
          PITAU,
          INFINITY,
          RAD_PER_DEG,
          HALF_PI,
          QUARTER_PI,
          TWO_THIRDS_PI,
          log10,
          sign,
          niceNum,
          _factorize,
          isNumber,
          almostEquals,
          almostWhole,
          _setMinAndMaxByKey,
          toRadians,
          toDegrees,
          _decimalPlaces,
          getAngleFromPoint,
          distanceBetweenPoints,
          _angleDiff,
          _normalizeAngle,
          _angleBetween,
          _limitValue,
          _int16Range,
          _isBetween,
          getRtlAdapter,
          overrideTextDirection,
          restoreTextDirection,
          _boundSegment,
          _boundSegments,
          _computeSegments
        });
        function binarySearch(metaset, axis, value, intersect) {
          const { controller, data, _sorted } = metaset;
          const iScale = controller._cachedMeta.iScale;
          if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
            const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
            if (!intersect) {
              return lookupMethod(data, axis, value);
            } else if (controller._sharedOptions) {
              const el = data[0];
              const range2 = typeof el.getRange === "function" && el.getRange(axis);
              if (range2) {
                const start = lookupMethod(data, axis, value - range2);
                const end = lookupMethod(data, axis, value + range2);
                return { lo: start.lo, hi: end.hi };
              }
            }
          }
          return { lo: 0, hi: data.length - 1 };
        }
        function evaluateInteractionItems(chart2, axis, position, handler, intersect) {
          const metasets = chart2.getSortedVisibleDatasetMetas();
          const value = position[axis];
          for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
            const { index: index3, data } = metasets[i];
            const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
            for (let j = lo; j <= hi; ++j) {
              const element = data[j];
              if (!element.skip) {
                handler(element, index3, j);
              }
            }
          }
        }
        function getDistanceMetricForAxis(axis) {
          const useX = axis.indexOf("x") !== -1;
          const useY = axis.indexOf("y") !== -1;
          return function(pt1, pt2) {
            const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        }
        function getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) {
          const items = [];
          if (!includeInvisible && !chart2.isPointInArea(position)) {
            return items;
          }
          const evaluationFunc = function(element, datasetIndex, index3) {
            if (!includeInvisible && !_isPointInArea(element, chart2.chartArea, 0)) {
              return;
            }
            if (element.inRange(position.x, position.y, useFinalPosition)) {
              items.push({ element, datasetIndex, index: index3 });
            }
          };
          evaluateInteractionItems(chart2, axis, position, evaluationFunc, true);
          return items;
        }
        function getNearestRadialItems(chart2, position, axis, useFinalPosition) {
          let items = [];
          function evaluationFunc(element, datasetIndex, index3) {
            const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
            const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
            if (_angleBetween(angle, startAngle, endAngle)) {
              items.push({ element, datasetIndex, index: index3 });
            }
          }
          evaluateInteractionItems(chart2, axis, position, evaluationFunc);
          return items;
        }
        function getNearestCartesianItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible) {
          let items = [];
          const distanceMetric = getDistanceMetricForAxis(axis);
          let minDistance = Number.POSITIVE_INFINITY;
          function evaluationFunc(element, datasetIndex, index3) {
            const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
            if (intersect && !inRange2) {
              return;
            }
            const center = element.getCenterPoint(useFinalPosition);
            const pointInArea = !!includeInvisible || chart2.isPointInArea(center);
            if (!pointInArea && !inRange2) {
              return;
            }
            const distance2 = distanceMetric(position, center);
            if (distance2 < minDistance) {
              items = [{ element, datasetIndex, index: index3 }];
              minDistance = distance2;
            } else if (distance2 === minDistance) {
              items.push({ element, datasetIndex, index: index3 });
            }
          }
          evaluateInteractionItems(chart2, axis, position, evaluationFunc);
          return items;
        }
        function getNearestItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible) {
          if (!includeInvisible && !chart2.isPointInArea(position)) {
            return [];
          }
          return axis === "r" && !intersect ? getNearestRadialItems(chart2, position, axis, useFinalPosition) : getNearestCartesianItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible);
        }
        function getAxisItems(chart2, position, axis, intersect, useFinalPosition) {
          const items = [];
          const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
          let intersectsItem = false;
          evaluateInteractionItems(chart2, axis, position, (element, datasetIndex, index3) => {
            if (element[rangeMethod](position[axis], useFinalPosition)) {
              items.push({ element, datasetIndex, index: index3 });
              intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
            }
          });
          if (intersect && !intersectsItem) {
            return [];
          }
          return items;
        }
        var Interaction = {
          evaluateInteractionItems,
          modes: {
            index(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "x";
              const includeInvisible = options.includeInvisible || false;
              const items = options.intersect ? getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart2, position, axis, false, useFinalPosition, includeInvisible);
              const elements2 = [];
              if (!items.length) {
                return [];
              }
              chart2.getSortedVisibleDatasetMetas().forEach((meta) => {
                const index3 = items[0].index;
                const element = meta.data[index3];
                if (element && !element.skip) {
                  elements2.push({ element, datasetIndex: meta.index, index: index3 });
                }
              });
              return elements2;
            },
            dataset(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              let items = options.intersect ? getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart2, position, axis, false, useFinalPosition, includeInvisible);
              if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart2.getDatasetMeta(datasetIndex).data;
                items = [];
                for (let i = 0; i < data.length; ++i) {
                  items.push({ element: data[i], datasetIndex, index: i });
                }
              }
              return items;
            },
            point(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              return getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible);
            },
            nearest(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              return getNearestItems(chart2, position, axis, options.intersect, useFinalPosition, includeInvisible);
            },
            x(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              return getAxisItems(chart2, position, "x", options.intersect, useFinalPosition);
            },
            y(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              return getAxisItems(chart2, position, "y", options.intersect, useFinalPosition);
            }
          }
        };
        const STATIC_POSITIONS = ["left", "top", "right", "bottom"];
        function filterByPosition(array, position) {
          return array.filter((v) => v.pos === position);
        }
        function filterDynamicPositionByAxis(array, axis) {
          return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
        }
        function sortByWeight(array, reverse) {
          return array.sort((a, b) => {
            const v0 = reverse ? b : a;
            const v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
          });
        }
        function wrapBoxes(boxes) {
          const layoutBoxes = [];
          let i, ilen, box, pos, stack, stackWeight;
          for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
            box = boxes[i];
            ({ position: pos, options: { stack, stackWeight = 1 } } = box);
            layoutBoxes.push({
              index: i,
              box,
              pos,
              horizontal: box.isHorizontal(),
              weight: box.weight,
              stack: stack && pos + stack,
              stackWeight
            });
          }
          return layoutBoxes;
        }
        function buildStacks(layouts2) {
          const stacks = {};
          for (const wrap of layouts2) {
            const { stack, pos, stackWeight } = wrap;
            if (!stack || !STATIC_POSITIONS.includes(pos)) {
              continue;
            }
            const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
            _stack.count++;
            _stack.weight += stackWeight;
          }
          return stacks;
        }
        function setLayoutDims(layouts2, params) {
          const stacks = buildStacks(layouts2);
          const { vBoxMaxWidth, hBoxMaxHeight } = params;
          let i, ilen, layout;
          for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
            layout = layouts2[i];
            const { fullSize } = layout.box;
            const stack = stacks[layout.stack];
            const factor = stack && layout.stackWeight / stack.weight;
            if (layout.horizontal) {
              layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
              layout.height = hBoxMaxHeight;
            } else {
              layout.width = vBoxMaxWidth;
              layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
            }
          }
          return stacks;
        }
        function buildLayoutBoxes(boxes) {
          const layoutBoxes = wrapBoxes(boxes);
          const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
          const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
          const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
          const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
          const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
          const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
          const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
          return {
            fullSize,
            leftAndTop: left.concat(top),
            rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
            chartArea: filterByPosition(layoutBoxes, "chartArea"),
            vertical: left.concat(right).concat(centerVertical),
            horizontal: top.concat(bottom).concat(centerHorizontal)
          };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
          return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateMaxPadding(maxPadding, boxPadding) {
          maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
          maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
          maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
          maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
        }
        function updateDims(chartArea, params, layout, stacks) {
          const { pos, box } = layout;
          const maxPadding = chartArea.maxPadding;
          if (!isObject2(pos)) {
            if (layout.size) {
              chartArea[pos] -= layout.size;
            }
            const stack = stacks[layout.stack] || { size: 0, count: 1 };
            stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
            layout.size = stack.size / stack.count;
            chartArea[pos] += layout.size;
          }
          if (box.getPadding) {
            updateMaxPadding(maxPadding, box.getPadding());
          }
          const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
          const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
          const widthChanged = newWidth !== chartArea.w;
          const heightChanged = newHeight !== chartArea.h;
          chartArea.w = newWidth;
          chartArea.h = newHeight;
          return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
        }
        function handleMaxPadding(chartArea) {
          const maxPadding = chartArea.maxPadding;
          function updatePos(pos) {
            const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
          }
          chartArea.y += updatePos("top");
          chartArea.x += updatePos("left");
          updatePos("right");
          updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
          const maxPadding = chartArea.maxPadding;
          function marginForPositions(positions2) {
            const margin = { left: 0, top: 0, right: 0, bottom: 0 };
            positions2.forEach((pos) => {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
          }
          return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
        }
        function fitBoxes(boxes, chartArea, params, stacks) {
          const refitBoxes = [];
          let i, ilen, layout, box, refit, changed;
          for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
            const { same, other } = updateDims(chartArea, params, layout, stacks);
            refit |= same && refitBoxes.length;
            changed = changed || other;
            if (!box.fullSize) {
              refitBoxes.push(layout);
            }
          }
          return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
        }
        function setBoxDims(box, left, top, width, height) {
          box.top = top;
          box.left = left;
          box.right = left + width;
          box.bottom = top + height;
          box.width = width;
          box.height = height;
        }
        function placeBoxes(boxes, chartArea, params, stacks) {
          const userPadding = params.padding;
          let { x, y } = chartArea;
          for (const layout of boxes) {
            const box = layout.box;
            const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
            const weight = layout.stackWeight / stack.weight || 1;
            if (layout.horizontal) {
              const width = chartArea.w * weight;
              const height = stack.size || box.height;
              if (defined(stack.start)) {
                y = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
              } else {
                setBoxDims(box, chartArea.left + stack.placed, y, width, height);
              }
              stack.start = y;
              stack.placed += width;
              y = box.bottom;
            } else {
              const height = chartArea.h * weight;
              const width = stack.size || box.width;
              if (defined(stack.start)) {
                x = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
              } else {
                setBoxDims(box, x, chartArea.top + stack.placed, width, height);
              }
              stack.start = x;
              stack.placed += height;
              x = box.right;
            }
          }
          chartArea.x = x;
          chartArea.y = y;
        }
        defaults.set("layout", {
          autoPadding: true,
          padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }
        });
        var layouts = {
          addBox(chart2, item) {
            if (!chart2.boxes) {
              chart2.boxes = [];
            }
            item.fullSize = item.fullSize || false;
            item.position = item.position || "top";
            item.weight = item.weight || 0;
            item._layers = item._layers || function() {
              return [{
                z: 0,
                draw(chartArea) {
                  item.draw(chartArea);
                }
              }];
            };
            chart2.boxes.push(item);
          },
          removeBox(chart2, layoutItem) {
            const index3 = chart2.boxes ? chart2.boxes.indexOf(layoutItem) : -1;
            if (index3 !== -1) {
              chart2.boxes.splice(index3, 1);
            }
          },
          configure(chart2, item, options) {
            item.fullSize = options.fullSize;
            item.position = options.position;
            item.weight = options.weight;
          },
          update(chart2, width, height, minPadding) {
            if (!chart2) {
              return;
            }
            const padding = toPadding(chart2.options.layout.padding);
            const availableWidth = Math.max(width - padding.width, 0);
            const availableHeight = Math.max(height - padding.height, 0);
            const boxes = buildLayoutBoxes(chart2.boxes);
            const verticalBoxes = boxes.vertical;
            const horizontalBoxes = boxes.horizontal;
            each(chart2.boxes, (box) => {
              if (typeof box.beforeLayout === "function") {
                box.beforeLayout();
              }
            });
            const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
            const params = Object.freeze({
              outerWidth: width,
              outerHeight: height,
              padding,
              availableWidth,
              availableHeight,
              vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
              hBoxMaxHeight: availableHeight / 2
            });
            const maxPadding = Object.assign({}, padding);
            updateMaxPadding(maxPadding, toPadding(minPadding));
            const chartArea = Object.assign({
              maxPadding,
              w: availableWidth,
              h: availableHeight,
              x: padding.left,
              y: padding.top
            }, padding);
            const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
            fitBoxes(boxes.fullSize, chartArea, params, stacks);
            fitBoxes(verticalBoxes, chartArea, params, stacks);
            if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
              fitBoxes(verticalBoxes, chartArea, params, stacks);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
            chart2.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h,
              height: chartArea.h,
              width: chartArea.w
            };
            each(boxes.chartArea, (layout) => {
              const box = layout.box;
              Object.assign(box, chart2.chartArea);
              box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
            });
          }
        };
        class BasePlatform {
          acquireContext(canvas, aspectRatio) {
          }
          releaseContext(context) {
            return false;
          }
          addEventListener(chart2, type, listener) {
          }
          removeEventListener(chart2, type, listener) {
          }
          getDevicePixelRatio() {
            return 1;
          }
          getMaximumSize(element, width, height, aspectRatio) {
            width = Math.max(0, width || element.width);
            height = height || element.height;
            return {
              width,
              height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
            };
          }
          isAttached(canvas) {
            return true;
          }
          updateConfig(config) {
          }
        }
        class BasicPlatform extends BasePlatform {
          acquireContext(item) {
            return item && item.getContext && item.getContext("2d") || null;
          }
          updateConfig(config) {
            config.options.animation = false;
          }
        }
        const EXPANDO_KEY = "$chartjs";
        const EVENT_TYPES = {
          touchstart: "mousedown",
          touchmove: "mousemove",
          touchend: "mouseup",
          pointerenter: "mouseenter",
          pointerdown: "mousedown",
          pointermove: "mousemove",
          pointerup: "mouseup",
          pointerleave: "mouseout",
          pointerout: "mouseout"
        };
        const isNullOrEmpty = (value) => value === null || value === "";
        function initCanvas(canvas, aspectRatio) {
          const style = canvas.style;
          const renderHeight = canvas.getAttribute("height");
          const renderWidth = canvas.getAttribute("width");
          canvas[EXPANDO_KEY] = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width
              }
            }
          };
          style.display = style.display || "block";
          style.boxSizing = style.boxSizing || "border-box";
          if (isNullOrEmpty(renderWidth)) {
            const displayWidth = readUsedSize(canvas, "width");
            if (displayWidth !== void 0) {
              canvas.width = displayWidth;
            }
          }
          if (isNullOrEmpty(renderHeight)) {
            if (canvas.style.height === "") {
              canvas.height = canvas.width / (aspectRatio || 2);
            } else {
              const displayHeight = readUsedSize(canvas, "height");
              if (displayHeight !== void 0) {
                canvas.height = displayHeight;
              }
            }
          }
          return canvas;
        }
        const eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
        function addListener(node, type, listener) {
          node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(chart2, type, listener) {
          chart2.canvas.removeEventListener(type, listener, eventListenerOptions);
        }
        function fromNativeEvent(event, chart2) {
          const type = EVENT_TYPES[event.type] || event.type;
          const { x, y } = getRelativePosition(event, chart2);
          return {
            type,
            chart: chart2,
            native: event,
            x: x !== void 0 ? x : null,
            y: y !== void 0 ? y : null
          };
        }
        function nodeListContains(nodeList, canvas) {
          for (const node of nodeList) {
            if (node === canvas || node.contains(canvas)) {
              return true;
            }
          }
        }
        function createAttachObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.addedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, { childList: true, subtree: true });
          return observer;
        }
        function createDetachObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.removedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, { childList: true, subtree: true });
          return observer;
        }
        const drpListeningCharts = /* @__PURE__ */ new Map();
        let oldDevicePixelRatio = 0;
        function onWindowResize() {
          const dpr = window.devicePixelRatio;
          if (dpr === oldDevicePixelRatio) {
            return;
          }
          oldDevicePixelRatio = dpr;
          drpListeningCharts.forEach((resize, chart2) => {
            if (chart2.currentDevicePixelRatio !== dpr) {
              resize();
            }
          });
        }
        function listenDevicePixelRatioChanges(chart2, resize) {
          if (!drpListeningCharts.size) {
            window.addEventListener("resize", onWindowResize);
          }
          drpListeningCharts.set(chart2, resize);
        }
        function unlistenDevicePixelRatioChanges(chart2) {
          drpListeningCharts.delete(chart2);
          if (!drpListeningCharts.size) {
            window.removeEventListener("resize", onWindowResize);
          }
        }
        function createResizeObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const container = canvas && _getParentNode(canvas);
          if (!container) {
            return;
          }
          const resize = throttled((width, height) => {
            const w = container.clientWidth;
            listener(width, height);
            if (w < container.clientWidth) {
              listener();
            }
          }, window);
          const observer = new ResizeObserver((entries) => {
            const entry = entries[0];
            const width = entry.contentRect.width;
            const height = entry.contentRect.height;
            if (width === 0 && height === 0) {
              return;
            }
            resize(width, height);
          });
          observer.observe(container);
          listenDevicePixelRatioChanges(chart2, resize);
          return observer;
        }
        function releaseObserver(chart2, type, observer) {
          if (observer) {
            observer.disconnect();
          }
          if (type === "resize") {
            unlistenDevicePixelRatioChanges(chart2);
          }
        }
        function createProxyAndListen(chart2, type, listener) {
          const canvas = chart2.canvas;
          const proxy = throttled((event) => {
            if (chart2.ctx !== null) {
              listener(fromNativeEvent(event, chart2));
            }
          }, chart2, (args) => {
            const event = args[0];
            return [event, event.offsetX, event.offsetY];
          });
          addListener(canvas, type, proxy);
          return proxy;
        }
        class DomPlatform extends BasePlatform {
          acquireContext(canvas, aspectRatio) {
            const context = canvas && canvas.getContext && canvas.getContext("2d");
            if (context && context.canvas === canvas) {
              initCanvas(canvas, aspectRatio);
              return context;
            }
            return null;
          }
          releaseContext(context) {
            const canvas = context.canvas;
            if (!canvas[EXPANDO_KEY]) {
              return false;
            }
            const initial = canvas[EXPANDO_KEY].initial;
            ["height", "width"].forEach((prop) => {
              const value = initial[prop];
              if (isNullOrUndef(value)) {
                canvas.removeAttribute(prop);
              } else {
                canvas.setAttribute(prop, value);
              }
            });
            const style = initial.style || {};
            Object.keys(style).forEach((key) => {
              canvas.style[key] = style[key];
            });
            canvas.width = canvas.width;
            delete canvas[EXPANDO_KEY];
            return true;
          }
          addEventListener(chart2, type, listener) {
            this.removeEventListener(chart2, type);
            const proxies = chart2.$proxies || (chart2.$proxies = {});
            const handlers = {
              attach: createAttachObserver,
              detach: createDetachObserver,
              resize: createResizeObserver
            };
            const handler = handlers[type] || createProxyAndListen;
            proxies[type] = handler(chart2, type, listener);
          }
          removeEventListener(chart2, type) {
            const proxies = chart2.$proxies || (chart2.$proxies = {});
            const proxy = proxies[type];
            if (!proxy) {
              return;
            }
            const handlers = {
              attach: releaseObserver,
              detach: releaseObserver,
              resize: releaseObserver
            };
            const handler = handlers[type] || removeListener;
            handler(chart2, type, proxy);
            proxies[type] = void 0;
          }
          getDevicePixelRatio() {
            return window.devicePixelRatio;
          }
          getMaximumSize(canvas, width, height, aspectRatio) {
            return getMaximumSize(canvas, width, height, aspectRatio);
          }
          isAttached(canvas) {
            const container = _getParentNode(canvas);
            return !!(container && container.isConnected);
          }
        }
        function _detectPlatform(canvas) {
          if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
            return BasicPlatform;
          }
          return DomPlatform;
        }
        var platforms = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          _detectPlatform,
          BasePlatform,
          BasicPlatform,
          DomPlatform
        });
        const transparent = "transparent";
        const interpolators = {
          boolean(from2, to2, factor) {
            return factor > 0.5 ? to2 : from2;
          },
          color(from2, to2, factor) {
            const c0 = color(from2 || transparent);
            const c1 = c0.valid && color(to2 || transparent);
            return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
          },
          number(from2, to2, factor) {
            return from2 + (to2 - from2) * factor;
          }
        };
        class Animation {
          constructor(cfg, target, prop, to2) {
            const currentValue = target[prop];
            to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
            const from2 = resolve([cfg.from, currentValue, to2]);
            this._active = true;
            this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
            this._easing = effects[cfg.easing] || effects.linear;
            this._start = Math.floor(Date.now() + (cfg.delay || 0));
            this._duration = this._total = Math.floor(cfg.duration);
            this._loop = !!cfg.loop;
            this._target = target;
            this._prop = prop;
            this._from = from2;
            this._to = to2;
            this._promises = void 0;
          }
          active() {
            return this._active;
          }
          update(cfg, to2, date) {
            if (this._active) {
              this._notify(false);
              const currentValue = this._target[this._prop];
              const elapsed = date - this._start;
              const remain = this._duration - elapsed;
              this._start = date;
              this._duration = Math.floor(Math.max(remain, cfg.duration));
              this._total += elapsed;
              this._loop = !!cfg.loop;
              this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
              this._from = resolve([cfg.from, currentValue, to2]);
            }
          }
          cancel() {
            if (this._active) {
              this.tick(Date.now());
              this._active = false;
              this._notify(false);
            }
          }
          tick(date) {
            const elapsed = date - this._start;
            const duration = this._duration;
            const prop = this._prop;
            const from2 = this._from;
            const loop = this._loop;
            const to2 = this._to;
            let factor;
            this._active = from2 !== to2 && (loop || elapsed < duration);
            if (!this._active) {
              this._target[prop] = to2;
              this._notify(true);
              return;
            }
            if (elapsed < 0) {
              this._target[prop] = from2;
              return;
            }
            factor = elapsed / duration % 2;
            factor = loop && factor > 1 ? 2 - factor : factor;
            factor = this._easing(Math.min(1, Math.max(0, factor)));
            this._target[prop] = this._fn(from2, to2, factor);
          }
          wait() {
            const promises = this._promises || (this._promises = []);
            return new Promise((res, rej) => {
              promises.push({ res, rej });
            });
          }
          _notify(resolved) {
            const method = resolved ? "res" : "rej";
            const promises = this._promises || [];
            for (let i = 0; i < promises.length; i++) {
              promises[i][method]();
            }
          }
        }
        const numbers = ["x", "y", "borderWidth", "radius", "tension"];
        const colors2 = ["color", "borderColor", "backgroundColor"];
        defaults.set("animation", {
          delay: void 0,
          duration: 1e3,
          easing: "easeOutQuart",
          fn: void 0,
          from: void 0,
          loop: void 0,
          to: void 0,
          type: void 0
        });
        const animationOptions = Object.keys(defaults.animation);
        defaults.describe("animation", {
          _fallback: false,
          _indexable: false,
          _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
        });
        defaults.set("animations", {
          colors: {
            type: "color",
            properties: colors2
          },
          numbers: {
            type: "number",
            properties: numbers
          }
        });
        defaults.describe("animations", {
          _fallback: "animation"
        });
        defaults.set("transitions", {
          active: {
            animation: {
              duration: 400
            }
          },
          resize: {
            animation: {
              duration: 0
            }
          },
          show: {
            animations: {
              colors: {
                from: "transparent"
              },
              visible: {
                type: "boolean",
                duration: 0
              }
            }
          },
          hide: {
            animations: {
              colors: {
                to: "transparent"
              },
              visible: {
                type: "boolean",
                easing: "linear",
                fn: (v) => v | 0
              }
            }
          }
        });
        class Animations {
          constructor(chart2, config) {
            this._chart = chart2;
            this._properties = /* @__PURE__ */ new Map();
            this.configure(config);
          }
          configure(config) {
            if (!isObject2(config)) {
              return;
            }
            const animatedProps = this._properties;
            Object.getOwnPropertyNames(config).forEach((key) => {
              const cfg = config[key];
              if (!isObject2(cfg)) {
                return;
              }
              const resolved = {};
              for (const option of animationOptions) {
                resolved[option] = cfg[option];
              }
              (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
                if (prop === key || !animatedProps.has(prop)) {
                  animatedProps.set(prop, resolved);
                }
              });
            });
          }
          _animateOptions(target, values) {
            const newOptions = values.options;
            const options = resolveTargetOptions(target, newOptions);
            if (!options) {
              return [];
            }
            const animations = this._createAnimations(options, newOptions);
            if (newOptions.$shared) {
              awaitAll(target.options.$animations, newOptions).then(() => {
                target.options = newOptions;
              }, () => {
              });
            }
            return animations;
          }
          _createAnimations(target, values) {
            const animatedProps = this._properties;
            const animations = [];
            const running = target.$animations || (target.$animations = {});
            const props = Object.keys(values);
            const date = Date.now();
            let i;
            for (i = props.length - 1; i >= 0; --i) {
              const prop = props[i];
              if (prop.charAt(0) === "$") {
                continue;
              }
              if (prop === "options") {
                animations.push(...this._animateOptions(target, values));
                continue;
              }
              const value = values[prop];
              let animation = running[prop];
              const cfg = animatedProps.get(prop);
              if (animation) {
                if (cfg && animation.active()) {
                  animation.update(cfg, value, date);
                  continue;
                } else {
                  animation.cancel();
                }
              }
              if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
              }
              running[prop] = animation = new Animation(cfg, target, prop, value);
              animations.push(animation);
            }
            return animations;
          }
          update(target, values) {
            if (this._properties.size === 0) {
              Object.assign(target, values);
              return;
            }
            const animations = this._createAnimations(target, values);
            if (animations.length) {
              animator.add(this._chart, animations);
              return true;
            }
          }
        }
        function awaitAll(animations, properties) {
          const running = [];
          const keys = Object.keys(properties);
          for (let i = 0; i < keys.length; i++) {
            const anim = animations[keys[i]];
            if (anim && anim.active()) {
              running.push(anim.wait());
            }
          }
          return Promise.all(running);
        }
        function resolveTargetOptions(target, newOptions) {
          if (!newOptions) {
            return;
          }
          let options = target.options;
          if (!options) {
            target.options = newOptions;
            return;
          }
          if (options.$shared) {
            target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
          }
          return options;
        }
        function scaleClip(scale, allowedOverflow) {
          const opts = scale && scale.options || {};
          const reverse = opts.reverse;
          const min = opts.min === void 0 ? allowedOverflow : 0;
          const max = opts.max === void 0 ? allowedOverflow : 0;
          return {
            start: reverse ? max : min,
            end: reverse ? min : max
          };
        }
        function defaultClip(xScale, yScale, allowedOverflow) {
          if (allowedOverflow === false) {
            return false;
          }
          const x = scaleClip(xScale, allowedOverflow);
          const y = scaleClip(yScale, allowedOverflow);
          return {
            top: y.end,
            right: x.end,
            bottom: y.start,
            left: x.start
          };
        }
        function toClip(value) {
          let t, r, b, l;
          if (isObject2(value)) {
            t = value.top;
            r = value.right;
            b = value.bottom;
            l = value.left;
          } else {
            t = r = b = l = value;
          }
          return {
            top: t,
            right: r,
            bottom: b,
            left: l,
            disabled: value === false
          };
        }
        function getSortedDatasetIndices(chart2, filterVisible) {
          const keys = [];
          const metasets = chart2._getSortedDatasetMetas(filterVisible);
          let i, ilen;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            keys.push(metasets[i].index);
          }
          return keys;
        }
        function applyStack(stack, value, dsIndex, options = {}) {
          const keys = stack.keys;
          const singleMode = options.mode === "single";
          let i, ilen, datasetIndex, otherValue;
          if (value === null) {
            return;
          }
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            datasetIndex = +keys[i];
            if (datasetIndex === dsIndex) {
              if (options.all) {
                continue;
              }
              break;
            }
            otherValue = stack.values[datasetIndex];
            if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
              value += otherValue;
            }
          }
          return value;
        }
        function convertObjectDataToArray(data) {
          const keys = Object.keys(data);
          const adata = new Array(keys.length);
          let i, ilen, key;
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            adata[i] = {
              x: key,
              y: data[key]
            };
          }
          return adata;
        }
        function isStacked(scale, meta) {
          const stacked = scale && scale.options.stacked;
          return stacked || stacked === void 0 && meta.stack !== void 0;
        }
        function getStackKey(indexScale, valueScale, meta) {
          return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
        }
        function getUserBounds(scale) {
          const { min, max, minDefined, maxDefined } = scale.getUserBounds();
          return {
            min: minDefined ? min : Number.NEGATIVE_INFINITY,
            max: maxDefined ? max : Number.POSITIVE_INFINITY
          };
        }
        function getOrCreateStack(stacks, stackKey, indexValue) {
          const subStack = stacks[stackKey] || (stacks[stackKey] = {});
          return subStack[indexValue] || (subStack[indexValue] = {});
        }
        function getLastIndexInStack(stack, vScale, positive, type) {
          for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
            const value = stack[meta.index];
            if (positive && value > 0 || !positive && value < 0) {
              return meta.index;
            }
          }
          return null;
        }
        function updateStacks(controller, parsed) {
          const { chart: chart2, _cachedMeta: meta } = controller;
          const stacks = chart2._stacks || (chart2._stacks = {});
          const { iScale, vScale, index: datasetIndex } = meta;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const key = getStackKey(iScale, vScale, meta);
          const ilen = parsed.length;
          let stack;
          for (let i = 0; i < ilen; ++i) {
            const item = parsed[i];
            const { [iAxis]: index3, [vAxis]: value } = item;
            const itemStacks = item._stacks || (item._stacks = {});
            stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index3);
            stack[datasetIndex] = value;
            stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
            stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
          }
        }
        function getFirstScaleId(chart2, axis) {
          const scales2 = chart2.scales;
          return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
        }
        function createDatasetContext(parent, index3) {
          return createContext(parent, {
            active: false,
            dataset: void 0,
            datasetIndex: index3,
            index: index3,
            mode: "default",
            type: "dataset"
          });
        }
        function createDataContext(parent, index3, element) {
          return createContext(parent, {
            active: false,
            dataIndex: index3,
            parsed: void 0,
            raw: void 0,
            element,
            index: index3,
            mode: "default",
            type: "data"
          });
        }
        function clearStacks(meta, items) {
          const datasetIndex = meta.controller.index;
          const axis = meta.vScale && meta.vScale.axis;
          if (!axis) {
            return;
          }
          items = items || meta._parsed;
          for (const parsed of items) {
            const stacks = parsed._stacks;
            if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
              return;
            }
            delete stacks[axis][datasetIndex];
          }
        }
        const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
        const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
        const createStack = (canStack, meta, chart2) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart2, true), values: null };
        class DatasetController {
          constructor(chart2, datasetIndex) {
            this.chart = chart2;
            this._ctx = chart2.ctx;
            this.index = datasetIndex;
            this._cachedDataOpts = {};
            this._cachedMeta = this.getMeta();
            this._type = this._cachedMeta.type;
            this.options = void 0;
            this._parsing = false;
            this._data = void 0;
            this._objectData = void 0;
            this._sharedOptions = void 0;
            this._drawStart = void 0;
            this._drawCount = void 0;
            this.enableOptionSharing = false;
            this.supportsDecimation = false;
            this.$context = void 0;
            this._syncList = [];
            this.initialize();
          }
          initialize() {
            const meta = this._cachedMeta;
            this.configure();
            this.linkScales();
            meta._stacked = isStacked(meta.vScale, meta);
            this.addElements();
          }
          updateIndex(datasetIndex) {
            if (this.index !== datasetIndex) {
              clearStacks(this._cachedMeta);
            }
            this.index = datasetIndex;
          }
          linkScales() {
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
            const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart2, "x"));
            const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart2, "y"));
            const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart2, "r"));
            const indexAxis = meta.indexAxis;
            const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
            const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
            meta.xScale = this.getScaleForId(xid);
            meta.yScale = this.getScaleForId(yid);
            meta.rScale = this.getScaleForId(rid);
            meta.iScale = this.getScaleForId(iid);
            meta.vScale = this.getScaleForId(vid);
          }
          getDataset() {
            return this.chart.data.datasets[this.index];
          }
          getMeta() {
            return this.chart.getDatasetMeta(this.index);
          }
          getScaleForId(scaleID) {
            return this.chart.scales[scaleID];
          }
          _getOtherScale(scale) {
            const meta = this._cachedMeta;
            return scale === meta.iScale ? meta.vScale : meta.iScale;
          }
          reset() {
            this._update("reset");
          }
          _destroy() {
            const meta = this._cachedMeta;
            if (this._data) {
              unlistenArrayEvents(this._data, this);
            }
            if (meta._stacked) {
              clearStacks(meta);
            }
          }
          _dataCheck() {
            const dataset = this.getDataset();
            const data = dataset.data || (dataset.data = []);
            const _data = this._data;
            if (isObject2(data)) {
              this._data = convertObjectDataToArray(data);
            } else if (_data !== data) {
              if (_data) {
                unlistenArrayEvents(_data, this);
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
              }
              if (data && Object.isExtensible(data)) {
                listenArrayEvents(data, this);
              }
              this._syncList = [];
              this._data = data;
            }
          }
          addElements() {
            const meta = this._cachedMeta;
            this._dataCheck();
            if (this.datasetElementType) {
              meta.dataset = new this.datasetElementType();
            }
          }
          buildOrUpdateElements(resetNewElements) {
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            let stackChanged = false;
            this._dataCheck();
            const oldStacked = meta._stacked;
            meta._stacked = isStacked(meta.vScale, meta);
            if (meta.stack !== dataset.stack) {
              stackChanged = true;
              clearStacks(meta);
              meta.stack = dataset.stack;
            }
            this._resyncElements(resetNewElements);
            if (stackChanged || oldStacked !== meta._stacked) {
              updateStacks(this, meta._parsed);
            }
          }
          configure() {
            const config = this.chart.config;
            const scopeKeys = config.datasetScopeKeys(this._type);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
            this.options = config.createResolver(scopes, this.getContext());
            this._parsing = this.options.parsing;
            this._cachedDataOpts = {};
          }
          parse(start, count) {
            const { _cachedMeta: meta, _data: data } = this;
            const { iScale, _stacked } = meta;
            const iAxis = iScale.axis;
            let sorted = start === 0 && count === data.length ? true : meta._sorted;
            let prev = start > 0 && meta._parsed[start - 1];
            let i, cur, parsed;
            if (this._parsing === false) {
              meta._parsed = data;
              meta._sorted = true;
              parsed = data;
            } else {
              if (isArray(data[start])) {
                parsed = this.parseArrayData(meta, data, start, count);
              } else if (isObject2(data[start])) {
                parsed = this.parseObjectData(meta, data, start, count);
              } else {
                parsed = this.parsePrimitiveData(meta, data, start, count);
              }
              const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
              for (i = 0; i < count; ++i) {
                meta._parsed[i + start] = cur = parsed[i];
                if (sorted) {
                  if (isNotInOrderComparedToPrev()) {
                    sorted = false;
                  }
                  prev = cur;
                }
              }
              meta._sorted = sorted;
            }
            if (_stacked) {
              updateStacks(this, parsed);
            }
          }
          parsePrimitiveData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const labels = iScale.getLabels();
            const singleScale = iScale === vScale;
            const parsed = new Array(count);
            let i, ilen, index3;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index3 = i + start;
              parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index3], index3),
                [vAxis]: vScale.parse(data[index3], index3)
              };
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const parsed = new Array(count);
            let i, ilen, index3, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index3 = i + start;
              item = data[index3];
              parsed[i] = {
                x: xScale.parse(item[0], index3),
                y: yScale.parse(item[1], index3)
              };
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
            const parsed = new Array(count);
            let i, ilen, index3, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index3 = i + start;
              item = data[index3];
              parsed[i] = {
                x: xScale.parse(resolveObjectKey(item, xAxisKey), index3),
                y: yScale.parse(resolveObjectKey(item, yAxisKey), index3)
              };
            }
            return parsed;
          }
          getParsed(index3) {
            return this._cachedMeta._parsed[index3];
          }
          getDataElement(index3) {
            return this._cachedMeta.data[index3];
          }
          applyStack(scale, parsed, mode) {
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const value = parsed[scale.axis];
            const stack = {
              keys: getSortedDatasetIndices(chart2, true),
              values: parsed._stacks[scale.axis]
            };
            return applyStack(stack, value, meta.index, { mode });
          }
          updateRangeFromParsed(range2, scale, parsed, stack) {
            const parsedValue = parsed[scale.axis];
            let value = parsedValue === null ? NaN : parsedValue;
            const values = stack && parsed._stacks[scale.axis];
            if (stack && values) {
              stack.values = values;
              value = applyStack(stack, parsedValue, this._cachedMeta.index);
            }
            range2.min = Math.min(range2.min, value);
            range2.max = Math.max(range2.max, value);
          }
          getMinMax(scale, canStack) {
            const meta = this._cachedMeta;
            const _parsed = meta._parsed;
            const sorted = meta._sorted && scale === meta.iScale;
            const ilen = _parsed.length;
            const otherScale = this._getOtherScale(scale);
            const stack = createStack(canStack, meta, this.chart);
            const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
            const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
            let i, parsed;
            function _skip() {
              parsed = _parsed[i];
              const otherValue = parsed[otherScale.axis];
              return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
            }
            for (i = 0; i < ilen; ++i) {
              if (_skip()) {
                continue;
              }
              this.updateRangeFromParsed(range2, scale, parsed, stack);
              if (sorted) {
                break;
              }
            }
            if (sorted) {
              for (i = ilen - 1; i >= 0; --i) {
                if (_skip()) {
                  continue;
                }
                this.updateRangeFromParsed(range2, scale, parsed, stack);
                break;
              }
            }
            return range2;
          }
          getAllParsedValues(scale) {
            const parsed = this._cachedMeta._parsed;
            const values = [];
            let i, ilen, value;
            for (i = 0, ilen = parsed.length; i < ilen; ++i) {
              value = parsed[i][scale.axis];
              if (isNumberFinite(value)) {
                values.push(value);
              }
            }
            return values;
          }
          getMaxOverflow() {
            return false;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const vScale = meta.vScale;
            const parsed = this.getParsed(index3);
            return {
              label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
              value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
            };
          }
          _update(mode) {
            const meta = this._cachedMeta;
            this.update(mode || "default");
            meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
          }
          update(mode) {
          }
          draw() {
            const ctx = this._ctx;
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const elements2 = meta.data || [];
            const area = chart2.chartArea;
            const active = [];
            const start = this._drawStart || 0;
            const count = this._drawCount || elements2.length - start;
            const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
            let i;
            if (meta.dataset) {
              meta.dataset.draw(ctx, area, start, count);
            }
            for (i = start; i < start + count; ++i) {
              const element = elements2[i];
              if (element.hidden) {
                continue;
              }
              if (element.active && drawActiveElementsOnTop) {
                active.push(element);
              } else {
                element.draw(ctx, area);
              }
            }
            for (i = 0; i < active.length; ++i) {
              active[i].draw(ctx, area);
            }
          }
          getStyle(index3, active) {
            const mode = active ? "active" : "default";
            return index3 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index3 || 0, mode);
          }
          getContext(index3, active, mode) {
            const dataset = this.getDataset();
            let context;
            if (index3 >= 0 && index3 < this._cachedMeta.data.length) {
              const element = this._cachedMeta.data[index3];
              context = element.$context || (element.$context = createDataContext(this.getContext(), index3, element));
              context.parsed = this.getParsed(index3);
              context.raw = dataset.data[index3];
              context.index = context.dataIndex = index3;
            } else {
              context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
              context.dataset = dataset;
              context.index = context.datasetIndex = this.index;
            }
            context.active = !!active;
            context.mode = mode;
            return context;
          }
          resolveDatasetElementOptions(mode) {
            return this._resolveElementOptions(this.datasetElementType.id, mode);
          }
          resolveDataElementOptions(index3, mode) {
            return this._resolveElementOptions(this.dataElementType.id, mode, index3);
          }
          _resolveElementOptions(elementType, mode = "default", index3) {
            const active = mode === "active";
            const cache = this._cachedDataOpts;
            const cacheKey = elementType + "-" + mode;
            const cached = cache[cacheKey];
            const sharing = this.enableOptionSharing && defined(index3);
            if (cached) {
              return cloneIfNotShared(cached, sharing);
            }
            const config = this.chart.config;
            const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
            const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            const names2 = Object.keys(defaults.elements[elementType]);
            const context = () => this.getContext(index3, active);
            const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
            if (values.$shared) {
              values.$shared = sharing;
              cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
            }
            return values;
          }
          _resolveAnimations(index3, transition, active) {
            const chart2 = this.chart;
            const cache = this._cachedDataOpts;
            const cacheKey = `animation-${transition}`;
            const cached = cache[cacheKey];
            if (cached) {
              return cached;
            }
            let options;
            if (chart2.options.animation !== false) {
              const config = this.chart.config;
              const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
              const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
              options = config.createResolver(scopes, this.getContext(index3, active, transition));
            }
            const animations = new Animations(chart2, options && options.animations);
            if (options && options._cacheable) {
              cache[cacheKey] = Object.freeze(animations);
            }
            return animations;
          }
          getSharedOptions(options) {
            if (!options.$shared) {
              return;
            }
            return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
          }
          includeOptions(mode, sharedOptions) {
            return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
          }
          _getSharedOptions(start, mode) {
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const previouslySharedOptions = this._sharedOptions;
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
            return { sharedOptions, includeOptions };
          }
          updateElement(element, index3, properties, mode) {
            if (isDirectUpdateMode(mode)) {
              Object.assign(element, properties);
            } else {
              this._resolveAnimations(index3, mode).update(element, properties);
            }
          }
          updateSharedOptions(sharedOptions, mode, newOptions) {
            if (sharedOptions && !isDirectUpdateMode(mode)) {
              this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
            }
          }
          _setStyle(element, index3, mode, active) {
            element.active = active;
            const options = this.getStyle(index3, active);
            this._resolveAnimations(index3, mode, active).update(element, {
              options: !active && this.getSharedOptions(options) || options
            });
          }
          removeHoverStyle(element, datasetIndex, index3) {
            this._setStyle(element, index3, "active", false);
          }
          setHoverStyle(element, datasetIndex, index3) {
            this._setStyle(element, index3, "active", true);
          }
          _removeDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, void 0, "active", false);
            }
          }
          _setDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, void 0, "active", true);
            }
          }
          _resyncElements(resetNewElements) {
            const data = this._data;
            const elements2 = this._cachedMeta.data;
            for (const [method, arg1, arg2] of this._syncList) {
              this[method](arg1, arg2);
            }
            this._syncList = [];
            const numMeta = elements2.length;
            const numData = data.length;
            const count = Math.min(numData, numMeta);
            if (count) {
              this.parse(0, count);
            }
            if (numData > numMeta) {
              this._insertElements(numMeta, numData - numMeta, resetNewElements);
            } else if (numData < numMeta) {
              this._removeElements(numData, numMeta - numData);
            }
          }
          _insertElements(start, count, resetNewElements = true) {
            const meta = this._cachedMeta;
            const data = meta.data;
            const end = start + count;
            let i;
            const move2 = (arr) => {
              arr.length += count;
              for (i = arr.length - 1; i >= end; i--) {
                arr[i] = arr[i - count];
              }
            };
            move2(data);
            for (i = start; i < end; ++i) {
              data[i] = new this.dataElementType();
            }
            if (this._parsing) {
              move2(meta._parsed);
            }
            this.parse(start, count);
            if (resetNewElements) {
              this.updateElements(data, start, count, "reset");
            }
          }
          updateElements(element, start, count, mode) {
          }
          _removeElements(start, count) {
            const meta = this._cachedMeta;
            if (this._parsing) {
              const removed = meta._parsed.splice(start, count);
              if (meta._stacked) {
                clearStacks(meta, removed);
              }
            }
            meta.data.splice(start, count);
          }
          _sync(args) {
            if (this._parsing) {
              this._syncList.push(args);
            } else {
              const [method, arg1, arg2] = args;
              this[method](arg1, arg2);
            }
            this.chart._dataChanges.push([this.index, ...args]);
          }
          _onDataPush() {
            const count = arguments.length;
            this._sync(["_insertElements", this.getDataset().data.length - count, count]);
          }
          _onDataPop() {
            this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
          }
          _onDataShift() {
            this._sync(["_removeElements", 0, 1]);
          }
          _onDataSplice(start, count) {
            if (count) {
              this._sync(["_removeElements", start, count]);
            }
            const newCount = arguments.length - 2;
            if (newCount) {
              this._sync(["_insertElements", start, newCount]);
            }
          }
          _onDataUnshift() {
            this._sync(["_insertElements", 0, arguments.length]);
          }
        }
        DatasetController.defaults = {};
        DatasetController.prototype.datasetElementType = null;
        DatasetController.prototype.dataElementType = null;
        class Element2 {
          constructor() {
            this.x = void 0;
            this.y = void 0;
            this.active = false;
            this.options = void 0;
            this.$animations = void 0;
          }
          tooltipPosition(useFinalPosition) {
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return { x, y };
          }
          hasValue() {
            return isNumber(this.x) && isNumber(this.y);
          }
          getProps(props, final) {
            const anims = this.$animations;
            if (!final || !anims) {
              return this;
            }
            const ret = {};
            props.forEach((prop) => {
              ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
            });
            return ret;
          }
        }
        Element2.defaults = {};
        Element2.defaultRoutes = void 0;
        const formatters = {
          values(value) {
            return isArray(value) ? value : "" + value;
          },
          numeric(tickValue, index3, ticks) {
            if (tickValue === 0) {
              return "0";
            }
            const locale = this.chart.options.locale;
            let notation;
            let delta = tickValue;
            if (ticks.length > 1) {
              const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
              if (maxTick < 1e-4 || maxTick > 1e15) {
                notation = "scientific";
              }
              delta = calculateDelta(tickValue, ticks);
            }
            const logDelta = log10(Math.abs(delta));
            const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
            const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
            Object.assign(options, this.options.ticks.format);
            return formatNumber(tickValue, locale, options);
          },
          logarithmic(tickValue, index3, ticks) {
            if (tickValue === 0) {
              return "0";
            }
            const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
            if (remain === 1 || remain === 2 || remain === 5) {
              return formatters.numeric.call(this, tickValue, index3, ticks);
            }
            return "";
          }
        };
        function calculateDelta(tickValue, ticks) {
          let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
          if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
            delta = tickValue - Math.floor(tickValue);
          }
          return delta;
        }
        var Ticks = { formatters };
        defaults.set("scale", {
          display: true,
          offset: false,
          reverse: false,
          beginAtZero: false,
          bounds: "ticks",
          grace: 0,
          grid: {
            display: true,
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options) => options.lineWidth,
            tickColor: (_ctx, options) => options.color,
            offset: false,
            borderDash: [],
            borderDashOffset: 0,
            borderWidth: 1
          },
          title: {
            display: false,
            text: "",
            padding: {
              top: 4,
              bottom: 4
            }
          },
          ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: false,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
          }
        });
        defaults.route("scale.ticks", "color", "", "color");
        defaults.route("scale.grid", "color", "", "borderColor");
        defaults.route("scale.grid", "borderColor", "", "borderColor");
        defaults.route("scale.title", "color", "", "color");
        defaults.describe("scale", {
          _fallback: false,
          _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
          _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
        });
        defaults.describe("scales", {
          _fallback: "scale"
        });
        defaults.describe("scale.ticks", {
          _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
          _indexable: (name) => name !== "backdropPadding"
        });
        function autoSkip(scale, ticks) {
          const tickOpts = scale.options.ticks;
          const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
          const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
          const numMajorIndices = majorIndices.length;
          const first = majorIndices[0];
          const last = majorIndices[numMajorIndices - 1];
          const newTicks = [];
          if (numMajorIndices > ticksLimit) {
            skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
            return newTicks;
          }
          const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
          if (numMajorIndices > 0) {
            let i, ilen;
            const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
            skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
            for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
              skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
            }
            skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
            return newTicks;
          }
          skip(ticks, newTicks, spacing);
          return newTicks;
        }
        function determineMaxTicks(scale) {
          const offset = scale.options.offset;
          const tickLength = scale._tickSize();
          const maxScale = scale._length / tickLength + (offset ? 0 : 1);
          const maxChart = scale._maxLength / tickLength;
          return Math.floor(Math.min(maxScale, maxChart));
        }
        function calculateSpacing(majorIndices, ticks, ticksLimit) {
          const evenMajorSpacing = getEvenSpacing(majorIndices);
          const spacing = ticks.length / ticksLimit;
          if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
          }
          const factors = _factorize(evenMajorSpacing);
          for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
            const factor = factors[i];
            if (factor > spacing) {
              return factor;
            }
          }
          return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
          const result = [];
          let i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (ticks[i].major) {
              result.push(i);
            }
          }
          return result;
        }
        function skipMajors(ticks, newTicks, majorIndices, spacing) {
          let count = 0;
          let next = majorIndices[0];
          let i;
          spacing = Math.ceil(spacing);
          for (i = 0; i < ticks.length; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = majorIndices[count * spacing];
            }
          }
        }
        function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
          const start = valueOrDefault(majorStart, 0);
          const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
          let count = 0;
          let length, i, next;
          spacing = Math.ceil(spacing);
          if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
          }
          next = start;
          while (next < 0) {
            count++;
            next = Math.round(start + count * spacing);
          }
          for (i = Math.max(start, 0); i < end; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = Math.round(start + count * spacing);
            }
          }
        }
        function getEvenSpacing(arr) {
          const len = arr.length;
          let i, diff;
          if (len < 2) {
            return false;
          }
          for (diff = arr[0], i = 1; i < len; ++i) {
            if (arr[i] - arr[i - 1] !== diff) {
              return false;
            }
          }
          return diff;
        }
        const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
        const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
        function sample(arr, numItems) {
          const result = [];
          const increment = arr.length / numItems;
          const len = arr.length;
          let i = 0;
          for (; i < len; i += increment) {
            result.push(arr[Math.floor(i)]);
          }
          return result;
        }
        function getPixelForGridLine(scale, index3, offsetGridLines) {
          const length = scale.ticks.length;
          const validIndex2 = Math.min(index3, length - 1);
          const start = scale._startPixel;
          const end = scale._endPixel;
          const epsilon = 1e-6;
          let lineValue = scale.getPixelForTick(validIndex2);
          let offset;
          if (offsetGridLines) {
            if (length === 1) {
              offset = Math.max(lineValue - start, end - lineValue);
            } else if (index3 === 0) {
              offset = (scale.getPixelForTick(1) - lineValue) / 2;
            } else {
              offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
            }
            lineValue += validIndex2 < index3 ? offset : -offset;
            if (lineValue < start - epsilon || lineValue > end + epsilon) {
              return;
            }
          }
          return lineValue;
        }
        function garbageCollect(caches, length) {
          each(caches, (cache) => {
            const gc = cache.gc;
            const gcLen = gc.length / 2;
            let i;
            if (gcLen > length) {
              for (i = 0; i < gcLen; ++i) {
                delete cache.data[gc[i]];
              }
              gc.splice(0, gcLen);
            }
          });
        }
        function getTickMarkLength(options) {
          return options.drawTicks ? options.tickLength : 0;
        }
        function getTitleHeight(options, fallback) {
          if (!options.display) {
            return 0;
          }
          const font = toFont(options.font, fallback);
          const padding = toPadding(options.padding);
          const lines = isArray(options.text) ? options.text.length : 1;
          return lines * font.lineHeight + padding.height;
        }
        function createScaleContext(parent, scale) {
          return createContext(parent, {
            scale,
            type: "scale"
          });
        }
        function createTickContext(parent, index3, tick) {
          return createContext(parent, {
            tick,
            index: index3,
            type: "tick"
          });
        }
        function titleAlign(align, position, reverse) {
          let ret = _toLeftRightCenter(align);
          if (reverse && position !== "right" || !reverse && position === "right") {
            ret = reverseAlign(ret);
          }
          return ret;
        }
        function titleArgs(scale, offset, position, align) {
          const { top, left, bottom, right, chart: chart2 } = scale;
          const { chartArea, scales: scales2 } = chart2;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          const height = bottom - top;
          const width = right - left;
          if (scale.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
            } else if (position === "center") {
              titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
            } else {
              titleY = offsetFromEdge(scale, position, offset);
            }
            maxWidth = right - left;
          } else {
            if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
            } else if (position === "center") {
              titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
            } else {
              titleX = offsetFromEdge(scale, position, offset);
            }
            titleY = _alignStartEnd(align, bottom, top);
            rotation = position === "left" ? -HALF_PI : HALF_PI;
          }
          return { titleX, titleY, maxWidth, rotation };
        }
        class Scale extends Element2 {
          constructor(cfg) {
            super();
            this.id = cfg.id;
            this.type = cfg.type;
            this.options = void 0;
            this.ctx = cfg.ctx;
            this.chart = cfg.chart;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this._margins = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            };
            this.maxWidth = void 0;
            this.maxHeight = void 0;
            this.paddingTop = void 0;
            this.paddingBottom = void 0;
            this.paddingLeft = void 0;
            this.paddingRight = void 0;
            this.axis = void 0;
            this.labelRotation = void 0;
            this.min = void 0;
            this.max = void 0;
            this._range = void 0;
            this.ticks = [];
            this._gridLineItems = null;
            this._labelItems = null;
            this._labelSizes = null;
            this._length = 0;
            this._maxLength = 0;
            this._longestTextCache = {};
            this._startPixel = void 0;
            this._endPixel = void 0;
            this._reversePixels = false;
            this._userMax = void 0;
            this._userMin = void 0;
            this._suggestedMax = void 0;
            this._suggestedMin = void 0;
            this._ticksLength = 0;
            this._borderValue = 0;
            this._cache = {};
            this._dataLimitsCached = false;
            this.$context = void 0;
          }
          init(options) {
            this.options = options.setContext(this.getContext());
            this.axis = options.axis;
            this._userMin = this.parse(options.min);
            this._userMax = this.parse(options.max);
            this._suggestedMin = this.parse(options.suggestedMin);
            this._suggestedMax = this.parse(options.suggestedMax);
          }
          parse(raw, index3) {
            return raw;
          }
          getUserBounds() {
            let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
            _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
            _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
            _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
            _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
            return {
              min: finiteOrDefault(_userMin, _suggestedMin),
              max: finiteOrDefault(_userMax, _suggestedMax),
              minDefined: isNumberFinite(_userMin),
              maxDefined: isNumberFinite(_userMax)
            };
          }
          getMinMax(canStack) {
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            let range2;
            if (minDefined && maxDefined) {
              return { min, max };
            }
            const metas = this.getMatchingVisibleMetas();
            for (let i = 0, ilen = metas.length; i < ilen; ++i) {
              range2 = metas[i].controller.getMinMax(this, canStack);
              if (!minDefined) {
                min = Math.min(min, range2.min);
              }
              if (!maxDefined) {
                max = Math.max(max, range2.max);
              }
            }
            min = maxDefined && min > max ? max : min;
            max = minDefined && min > max ? min : max;
            return {
              min: finiteOrDefault(min, finiteOrDefault(max, min)),
              max: finiteOrDefault(max, finiteOrDefault(min, max))
            };
          }
          getPadding() {
            return {
              left: this.paddingLeft || 0,
              top: this.paddingTop || 0,
              right: this.paddingRight || 0,
              bottom: this.paddingBottom || 0
            };
          }
          getTicks() {
            return this.ticks;
          }
          getLabels() {
            const data = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
          }
          beforeLayout() {
            this._cache = {};
            this._dataLimitsCached = false;
          }
          beforeUpdate() {
            callback(this.options.beforeUpdate, [this]);
          }
          update(maxWidth, maxHeight, margins) {
            const { beginAtZero, grace, ticks: tickOpts } = this.options;
            const sampleSize = tickOpts.sampleSize;
            this.beforeUpdate();
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins = Object.assign({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }, margins);
            this.ticks = null;
            this._labelSizes = null;
            this._gridLineItems = null;
            this._labelItems = null;
            this.beforeSetDimensions();
            this.setDimensions();
            this.afterSetDimensions();
            this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
            if (!this._dataLimitsCached) {
              this.beforeDataLimits();
              this.determineDataLimits();
              this.afterDataLimits();
              this._range = _addGrace(this, grace, beginAtZero);
              this._dataLimitsCached = true;
            }
            this.beforeBuildTicks();
            this.ticks = this.buildTicks() || [];
            this.afterBuildTicks();
            const samplingEnabled = sampleSize < this.ticks.length;
            this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
            this.configure();
            this.beforeCalculateLabelRotation();
            this.calculateLabelRotation();
            this.afterCalculateLabelRotation();
            if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
              this.ticks = autoSkip(this, this.ticks);
              this._labelSizes = null;
              this.afterAutoSkip();
            }
            if (samplingEnabled) {
              this._convertTicksToLabels(this.ticks);
            }
            this.beforeFit();
            this.fit();
            this.afterFit();
            this.afterUpdate();
          }
          configure() {
            let reversePixels = this.options.reverse;
            let startPixel, endPixel;
            if (this.isHorizontal()) {
              startPixel = this.left;
              endPixel = this.right;
            } else {
              startPixel = this.top;
              endPixel = this.bottom;
              reversePixels = !reversePixels;
            }
            this._startPixel = startPixel;
            this._endPixel = endPixel;
            this._reversePixels = reversePixels;
            this._length = endPixel - startPixel;
            this._alignToPixels = this.options.alignToPixels;
          }
          afterUpdate() {
            callback(this.options.afterUpdate, [this]);
          }
          beforeSetDimensions() {
            callback(this.options.beforeSetDimensions, [this]);
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = 0;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = 0;
              this.bottom = this.height;
            }
            this.paddingLeft = 0;
            this.paddingTop = 0;
            this.paddingRight = 0;
            this.paddingBottom = 0;
          }
          afterSetDimensions() {
            callback(this.options.afterSetDimensions, [this]);
          }
          _callHooks(name) {
            this.chart.notifyPlugins(name, this.getContext());
            callback(this.options[name], [this]);
          }
          beforeDataLimits() {
            this._callHooks("beforeDataLimits");
          }
          determineDataLimits() {
          }
          afterDataLimits() {
            this._callHooks("afterDataLimits");
          }
          beforeBuildTicks() {
            this._callHooks("beforeBuildTicks");
          }
          buildTicks() {
            return [];
          }
          afterBuildTicks() {
            this._callHooks("afterBuildTicks");
          }
          beforeTickToLabelConversion() {
            callback(this.options.beforeTickToLabelConversion, [this]);
          }
          generateTickLabels(ticks) {
            const tickOpts = this.options.ticks;
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              tick = ticks[i];
              tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
            }
          }
          afterTickToLabelConversion() {
            callback(this.options.afterTickToLabelConversion, [this]);
          }
          beforeCalculateLabelRotation() {
            callback(this.options.beforeCalculateLabelRotation, [this]);
          }
          calculateLabelRotation() {
            const options = this.options;
            const tickOpts = options.ticks;
            const numTicks = this.ticks.length;
            const minRotation = tickOpts.minRotation || 0;
            const maxRotation = tickOpts.maxRotation;
            let labelRotation = minRotation;
            let tickWidth, maxHeight, maxLabelDiagonal;
            if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
              this.labelRotation = minRotation;
              return;
            }
            const labelSizes = this._getLabelSizes();
            const maxLabelWidth = labelSizes.widest.width;
            const maxLabelHeight = labelSizes.highest.height;
            const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
            tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
              maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
              maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
              labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
              labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
            }
            this.labelRotation = labelRotation;
          }
          afterCalculateLabelRotation() {
            callback(this.options.afterCalculateLabelRotation, [this]);
          }
          afterAutoSkip() {
          }
          beforeFit() {
            callback(this.options.beforeFit, [this]);
          }
          fit() {
            const minSize = {
              width: 0,
              height: 0
            };
            const { chart: chart2, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
            const display = this._isVisible();
            const isHorizontal = this.isHorizontal();
            if (display) {
              const titleHeight = getTitleHeight(titleOpts, chart2.options.font);
              if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
              } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
              }
              if (tickOpts.display && this.ticks.length) {
                const { first, last, widest, highest } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = toRadians(this.labelRotation);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                  const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                  minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                } else {
                  const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                  minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                }
                this._calculatePadding(first, last, sin, cos);
              }
            }
            this._handleMargins();
            if (isHorizontal) {
              this.width = this._length = chart2.width - this._margins.left - this._margins.right;
              this.height = minSize.height;
            } else {
              this.width = minSize.width;
              this.height = this._length = chart2.height - this._margins.top - this._margins.bottom;
            }
          }
          _calculatePadding(first, last, sin, cos) {
            const { ticks: { align, padding }, position } = this.options;
            const isRotated = this.labelRotation !== 0;
            const labelsBelowTicks = position !== "top" && this.axis === "x";
            if (this.isHorizontal()) {
              const offsetLeft = this.getPixelForTick(0) - this.left;
              const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
              let paddingLeft = 0;
              let paddingRight = 0;
              if (isRotated) {
                if (labelsBelowTicks) {
                  paddingLeft = cos * first.width;
                  paddingRight = sin * last.height;
                } else {
                  paddingLeft = sin * first.height;
                  paddingRight = cos * last.width;
                }
              } else if (align === "start") {
                paddingRight = last.width;
              } else if (align === "end") {
                paddingLeft = first.width;
              } else if (align !== "inner") {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
              }
              this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
              this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
            } else {
              let paddingTop = last.height / 2;
              let paddingBottom = first.height / 2;
              if (align === "start") {
                paddingTop = 0;
                paddingBottom = first.height;
              } else if (align === "end") {
                paddingTop = last.height;
                paddingBottom = 0;
              }
              this.paddingTop = paddingTop + padding;
              this.paddingBottom = paddingBottom + padding;
            }
          }
          _handleMargins() {
            if (this._margins) {
              this._margins.left = Math.max(this.paddingLeft, this._margins.left);
              this._margins.top = Math.max(this.paddingTop, this._margins.top);
              this._margins.right = Math.max(this.paddingRight, this._margins.right);
              this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
            }
          }
          afterFit() {
            callback(this.options.afterFit, [this]);
          }
          isHorizontal() {
            const { axis, position } = this.options;
            return position === "top" || position === "bottom" || axis === "x";
          }
          isFullSize() {
            return this.options.fullSize;
          }
          _convertTicksToLabels(ticks) {
            this.beforeTickToLabelConversion();
            this.generateTickLabels(ticks);
            let i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              if (isNullOrUndef(ticks[i].label)) {
                ticks.splice(i, 1);
                ilen--;
                i--;
              }
            }
            this.afterTickToLabelConversion();
          }
          _getLabelSizes() {
            let labelSizes = this._labelSizes;
            if (!labelSizes) {
              const sampleSize = this.options.ticks.sampleSize;
              let ticks = this.ticks;
              if (sampleSize < ticks.length) {
                ticks = sample(ticks, sampleSize);
              }
              this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
            }
            return labelSizes;
          }
          _computeLabelSizes(ticks, length) {
            const { ctx, _longestTextCache: caches } = this;
            const widths = [];
            const heights = [];
            let widestLabelSize = 0;
            let highestLabelSize = 0;
            let i, j, jlen, label, tickFont, fontString2, cache, lineHeight, width, height, nestedLabel;
            for (i = 0; i < length; ++i) {
              label = ticks[i].label;
              tickFont = this._resolveTickFontOptions(i);
              ctx.font = fontString2 = tickFont.string;
              cache = caches[fontString2] = caches[fontString2] || { data: {}, gc: [] };
              lineHeight = tickFont.lineHeight;
              width = height = 0;
              if (!isNullOrUndef(label) && !isArray(label)) {
                width = _measureText(ctx, cache.data, cache.gc, width, label);
                height = lineHeight;
              } else if (isArray(label)) {
                for (j = 0, jlen = label.length; j < jlen; ++j) {
                  nestedLabel = label[j];
                  if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                    width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                    height += lineHeight;
                  }
                }
              }
              widths.push(width);
              heights.push(height);
              widestLabelSize = Math.max(width, widestLabelSize);
              highestLabelSize = Math.max(height, highestLabelSize);
            }
            garbageCollect(caches, length);
            const widest = widths.indexOf(widestLabelSize);
            const highest = heights.indexOf(highestLabelSize);
            const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
            return {
              first: valueAt(0),
              last: valueAt(length - 1),
              widest: valueAt(widest),
              highest: valueAt(highest),
              widths,
              heights
            };
          }
          getLabelForValue(value) {
            return value;
          }
          getPixelForValue(value, index3) {
            return NaN;
          }
          getValueForPixel(pixel) {
          }
          getPixelForTick(index3) {
            const ticks = this.ticks;
            if (index3 < 0 || index3 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index3].value);
          }
          getPixelForDecimal(decimal) {
            if (this._reversePixels) {
              decimal = 1 - decimal;
            }
            const pixel = this._startPixel + decimal * this._length;
            return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
          }
          getDecimalForPixel(pixel) {
            const decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
          }
          getBasePixel() {
            return this.getPixelForValue(this.getBaseValue());
          }
          getBaseValue() {
            const { min, max } = this;
            return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
          }
          getContext(index3) {
            const ticks = this.ticks || [];
            if (index3 >= 0 && index3 < ticks.length) {
              const tick = ticks[index3];
              return tick.$context || (tick.$context = createTickContext(this.getContext(), index3, tick));
            }
            return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
          }
          _tickSize() {
            const optionTicks = this.options.ticks;
            const rot = toRadians(this.labelRotation);
            const cos = Math.abs(Math.cos(rot));
            const sin = Math.abs(Math.sin(rot));
            const labelSizes = this._getLabelSizes();
            const padding = optionTicks.autoSkipPadding || 0;
            const w = labelSizes ? labelSizes.widest.width + padding : 0;
            const h = labelSizes ? labelSizes.highest.height + padding : 0;
            return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
          }
          _isVisible() {
            const display = this.options.display;
            if (display !== "auto") {
              return !!display;
            }
            return this.getMatchingVisibleMetas().length > 0;
          }
          _computeGridLineItems(chartArea) {
            const axis = this.axis;
            const chart2 = this.chart;
            const options = this.options;
            const { grid, position } = options;
            const offset = grid.offset;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const ticksLength = ticks.length + (offset ? 1 : 0);
            const tl = getTickMarkLength(grid);
            const items = [];
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
            const axisHalfWidth = axisWidth / 2;
            const alignBorderValue = function(pixel) {
              return _alignPixel(chart2, pixel, axisWidth);
            };
            let borderValue, i, lineValue, alignedLineValue;
            let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
            if (position === "top") {
              borderValue = alignBorderValue(this.bottom);
              ty1 = this.bottom - tl;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
            } else if (position === "bottom") {
              borderValue = alignBorderValue(this.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = this.top + tl;
            } else if (position === "left") {
              borderValue = alignBorderValue(this.right);
              tx1 = this.right - tl;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
            } else if (position === "right") {
              borderValue = alignBorderValue(this.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = this.left + tl;
            } else if (axis === "x") {
              if (position === "center") {
                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              y1 = chartArea.top;
              y2 = chartArea.bottom;
              ty1 = borderValue + axisHalfWidth;
              ty2 = ty1 + tl;
            } else if (axis === "y") {
              if (position === "center") {
                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              tx1 = borderValue - axisHalfWidth;
              tx2 = tx1 - tl;
              x1 = chartArea.left;
              x2 = chartArea.right;
            }
            const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
            const step = Math.max(1, Math.ceil(ticksLength / limit));
            for (i = 0; i < ticksLength; i += step) {
              const optsAtIndex = grid.setContext(this.getContext(i));
              const lineWidth = optsAtIndex.lineWidth;
              const lineColor = optsAtIndex.color;
              const borderDash = optsAtIndex.borderDash || [];
              const borderDashOffset = optsAtIndex.borderDashOffset;
              const tickWidth = optsAtIndex.tickWidth;
              const tickColor = optsAtIndex.tickColor;
              const tickBorderDash = optsAtIndex.tickBorderDash || [];
              const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
              lineValue = getPixelForGridLine(this, i, offset);
              if (lineValue === void 0) {
                continue;
              }
              alignedLineValue = _alignPixel(chart2, lineValue, lineWidth);
              if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset
              });
            }
            this._ticksLength = ticksLength;
            this._borderValue = borderValue;
            return items;
          }
          _computeLabelItems(chartArea) {
            const axis = this.axis;
            const options = this.options;
            const { position, ticks: optionTicks } = options;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const { align, crossAlign, padding, mirror } = optionTicks;
            const tl = getTickMarkLength(options.grid);
            const tickAndPadding = tl + padding;
            const hTickAndPadding = mirror ? -padding : tickAndPadding;
            const rotation = -toRadians(this.labelRotation);
            const items = [];
            let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
            let textBaseline = "middle";
            if (position === "top") {
              y = this.bottom - hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === "bottom") {
              y = this.top + hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === "left") {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (position === "right") {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (axis === "x") {
              if (position === "center") {
                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
              }
              textAlign = this._getXAxisLabelAlignment();
            } else if (axis === "y") {
              if (position === "center") {
                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x = this.chart.scales[positionAxisID].getPixelForValue(value);
              }
              textAlign = this._getYAxisLabelAlignment(tl).textAlign;
            }
            if (axis === "y") {
              if (align === "start") {
                textBaseline = "top";
              } else if (align === "end") {
                textBaseline = "bottom";
              }
            }
            const labelSizes = this._getLabelSizes();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              label = tick.label;
              const optsAtIndex = optionTicks.setContext(this.getContext(i));
              pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
              font = this._resolveTickFontOptions(i);
              lineHeight = font.lineHeight;
              lineCount = isArray(label) ? label.length : 1;
              const halfCount = lineCount / 2;
              const color2 = optsAtIndex.color;
              const strokeColor = optsAtIndex.textStrokeColor;
              const strokeWidth = optsAtIndex.textStrokeWidth;
              let tickTextAlign = textAlign;
              if (isHorizontal) {
                x = pixel;
                if (textAlign === "inner") {
                  if (i === ilen - 1) {
                    tickTextAlign = !this.options.reverse ? "right" : "left";
                  } else if (i === 0) {
                    tickTextAlign = !this.options.reverse ? "left" : "right";
                  } else {
                    tickTextAlign = "center";
                  }
                }
                if (position === "top") {
                  if (crossAlign === "near" || rotation !== 0) {
                    textOffset = -lineCount * lineHeight + lineHeight / 2;
                  } else if (crossAlign === "center") {
                    textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                  } else {
                    textOffset = -labelSizes.highest.height + lineHeight / 2;
                  }
                } else {
                  if (crossAlign === "near" || rotation !== 0) {
                    textOffset = lineHeight / 2;
                  } else if (crossAlign === "center") {
                    textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                  } else {
                    textOffset = labelSizes.highest.height - lineCount * lineHeight;
                  }
                }
                if (mirror) {
                  textOffset *= -1;
                }
              } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
              }
              let backdrop;
              if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = toPadding(optsAtIndex.backdropPadding);
                const height = labelSizes.heights[i];
                const width = labelSizes.widths[i];
                let top = y + textOffset - labelPadding.top;
                let left = x - labelPadding.left;
                switch (textBaseline) {
                  case "middle":
                    top -= height / 2;
                    break;
                  case "bottom":
                    top -= height;
                    break;
                }
                switch (textAlign) {
                  case "center":
                    left -= width / 2;
                    break;
                  case "right":
                    left -= width;
                    break;
                }
                backdrop = {
                  left,
                  top,
                  width: width + labelPadding.width,
                  height: height + labelPadding.height,
                  color: optsAtIndex.backdropColor
                };
              }
              items.push({
                rotation,
                label,
                font,
                color: color2,
                strokeColor,
                strokeWidth,
                textOffset,
                textAlign: tickTextAlign,
                textBaseline,
                translation: [x, y],
                backdrop
              });
            }
            return items;
          }
          _getXAxisLabelAlignment() {
            const { position, ticks } = this.options;
            const rotation = -toRadians(this.labelRotation);
            if (rotation) {
              return position === "top" ? "left" : "right";
            }
            let align = "center";
            if (ticks.align === "start") {
              align = "left";
            } else if (ticks.align === "end") {
              align = "right";
            } else if (ticks.align === "inner") {
              align = "inner";
            }
            return align;
          }
          _getYAxisLabelAlignment(tl) {
            const { position, ticks: { crossAlign, mirror, padding } } = this.options;
            const labelSizes = this._getLabelSizes();
            const tickAndPadding = tl + padding;
            const widest = labelSizes.widest.width;
            let textAlign;
            let x;
            if (position === "left") {
              if (mirror) {
                x = this.right + padding;
                if (crossAlign === "near") {
                  textAlign = "left";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x += widest / 2;
                } else {
                  textAlign = "right";
                  x += widest;
                }
              } else {
                x = this.right - tickAndPadding;
                if (crossAlign === "near") {
                  textAlign = "right";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x -= widest / 2;
                } else {
                  textAlign = "left";
                  x = this.left;
                }
              }
            } else if (position === "right") {
              if (mirror) {
                x = this.left + padding;
                if (crossAlign === "near") {
                  textAlign = "right";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x -= widest / 2;
                } else {
                  textAlign = "left";
                  x -= widest;
                }
              } else {
                x = this.left + tickAndPadding;
                if (crossAlign === "near") {
                  textAlign = "left";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x += widest / 2;
                } else {
                  textAlign = "right";
                  x = this.right;
                }
              }
            } else {
              textAlign = "right";
            }
            return { textAlign, x };
          }
          _computeLabelArea() {
            if (this.options.ticks.mirror) {
              return;
            }
            const chart2 = this.chart;
            const position = this.options.position;
            if (position === "left" || position === "right") {
              return { top: 0, left: this.left, bottom: chart2.height, right: this.right };
            }
            if (position === "top" || position === "bottom") {
              return { top: this.top, left: 0, bottom: this.bottom, right: chart2.width };
            }
          }
          drawBackground() {
            const { ctx, options: { backgroundColor }, left, top, width, height } = this;
            if (backgroundColor) {
              ctx.save();
              ctx.fillStyle = backgroundColor;
              ctx.fillRect(left, top, width, height);
              ctx.restore();
            }
          }
          getLineWidthForValue(value) {
            const grid = this.options.grid;
            if (!this._isVisible() || !grid.display) {
              return 0;
            }
            const ticks = this.ticks;
            const index3 = ticks.findIndex((t) => t.value === value);
            if (index3 >= 0) {
              const opts = grid.setContext(this.getContext(index3));
              return opts.lineWidth;
            }
            return 0;
          }
          drawGrid(chartArea) {
            const grid = this.options.grid;
            const ctx = this.ctx;
            const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
            let i, ilen;
            const drawLine = (p1, p2, style) => {
              if (!style.width || !style.color) {
                return;
              }
              ctx.save();
              ctx.lineWidth = style.width;
              ctx.strokeStyle = style.color;
              ctx.setLineDash(style.borderDash || []);
              ctx.lineDashOffset = style.borderDashOffset;
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
              ctx.restore();
            };
            if (grid.display) {
              for (i = 0, ilen = items.length; i < ilen; ++i) {
                const item = items[i];
                if (grid.drawOnChartArea) {
                  drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
                }
                if (grid.drawTicks) {
                  drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
                    color: item.tickColor,
                    width: item.tickWidth,
                    borderDash: item.tickBorderDash,
                    borderDashOffset: item.tickBorderDashOffset
                  });
                }
              }
            }
          }
          drawBorder() {
            const { chart: chart2, ctx, options: { grid } } = this;
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
            if (!axisWidth) {
              return;
            }
            const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
            const borderValue = this._borderValue;
            let x1, x2, y1, y2;
            if (this.isHorizontal()) {
              x1 = _alignPixel(chart2, this.left, axisWidth) - axisWidth / 2;
              x2 = _alignPixel(chart2, this.right, lastLineWidth) + lastLineWidth / 2;
              y1 = y2 = borderValue;
            } else {
              y1 = _alignPixel(chart2, this.top, axisWidth) - axisWidth / 2;
              y2 = _alignPixel(chart2, this.bottom, lastLineWidth) + lastLineWidth / 2;
              x1 = x2 = borderValue;
            }
            ctx.save();
            ctx.lineWidth = borderOpts.borderWidth;
            ctx.strokeStyle = borderOpts.borderColor;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
          }
          drawLabels(chartArea) {
            const optionTicks = this.options.ticks;
            if (!optionTicks.display) {
              return;
            }
            const ctx = this.ctx;
            const area = this._computeLabelArea();
            if (area) {
              clipArea(ctx, area);
            }
            const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
            let i, ilen;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              const item = items[i];
              const tickFont = item.font;
              const label = item.label;
              if (item.backdrop) {
                ctx.fillStyle = item.backdrop.color;
                ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
              }
              let y = item.textOffset;
              renderText(ctx, label, 0, y, tickFont, item);
            }
            if (area) {
              unclipArea(ctx);
            }
          }
          drawTitle() {
            const { ctx, options: { position, title, reverse } } = this;
            if (!title.display) {
              return;
            }
            const font = toFont(title.font);
            const padding = toPadding(title.padding);
            const align = title.align;
            let offset = font.lineHeight / 2;
            if (position === "bottom" || position === "center" || isObject2(position)) {
              offset += padding.bottom;
              if (isArray(title.text)) {
                offset += font.lineHeight * (title.text.length - 1);
              }
            } else {
              offset += padding.top;
            }
            const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
            renderText(ctx, title.text, 0, 0, font, {
              color: title.color,
              maxWidth,
              rotation,
              textAlign: titleAlign(align, position, reverse),
              textBaseline: "middle",
              translation: [titleX, titleY]
            });
          }
          draw(chartArea) {
            if (!this._isVisible()) {
              return;
            }
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawBorder();
            this.drawTitle();
            this.drawLabels(chartArea);
          }
          _layers() {
            const opts = this.options;
            const tz = opts.ticks && opts.ticks.z || 0;
            const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
            if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
              return [{
                z: tz,
                draw: (chartArea) => {
                  this.draw(chartArea);
                }
              }];
            }
            return [{
              z: gz,
              draw: (chartArea) => {
                this.drawBackground();
                this.drawGrid(chartArea);
                this.drawTitle();
              }
            }, {
              z: gz + 1,
              draw: () => {
                this.drawBorder();
              }
            }, {
              z: tz,
              draw: (chartArea) => {
                this.drawLabels(chartArea);
              }
            }];
          }
          getMatchingVisibleMetas(type) {
            const metas = this.chart.getSortedVisibleDatasetMetas();
            const axisID = this.axis + "AxisID";
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              const meta = metas[i];
              if (meta[axisID] === this.id && (!type || meta.type === type)) {
                result.push(meta);
              }
            }
            return result;
          }
          _resolveTickFontOptions(index3) {
            const opts = this.options.ticks.setContext(this.getContext(index3));
            return toFont(opts.font);
          }
          _maxDigits() {
            const fontSize = this._resolveTickFontOptions(0).lineHeight;
            return (this.isHorizontal() ? this.width : this.height) / fontSize;
          }
        }
        class TypedRegistry {
          constructor(type, scope, override) {
            this.type = type;
            this.scope = scope;
            this.override = override;
            this.items = Object.create(null);
          }
          isForType(type) {
            return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
          }
          register(item) {
            const proto = Object.getPrototypeOf(item);
            let parentScope;
            if (isIChartComponent(proto)) {
              parentScope = this.register(proto);
            }
            const items = this.items;
            const id = item.id;
            const scope = this.scope + "." + id;
            if (!id) {
              throw new Error("class does not have id: " + item);
            }
            if (id in items) {
              return scope;
            }
            items[id] = item;
            registerDefaults(item, scope, parentScope);
            if (this.override) {
              defaults.override(item.id, item.overrides);
            }
            return scope;
          }
          get(id) {
            return this.items[id];
          }
          unregister(item) {
            const items = this.items;
            const id = item.id;
            const scope = this.scope;
            if (id in items) {
              delete items[id];
            }
            if (scope && id in defaults[scope]) {
              delete defaults[scope][id];
              if (this.override) {
                delete overrides[id];
              }
            }
          }
        }
        function registerDefaults(item, scope, parentScope) {
          const itemDefaults = merge(Object.create(null), [
            parentScope ? defaults.get(parentScope) : {},
            defaults.get(scope),
            item.defaults
          ]);
          defaults.set(scope, itemDefaults);
          if (item.defaultRoutes) {
            routeDefaults(scope, item.defaultRoutes);
          }
          if (item.descriptors) {
            defaults.describe(scope, item.descriptors);
          }
        }
        function routeDefaults(scope, routes) {
          Object.keys(routes).forEach((property) => {
            const propertyParts = property.split(".");
            const sourceName = propertyParts.pop();
            const sourceScope = [scope].concat(propertyParts).join(".");
            const parts = routes[property].split(".");
            const targetName = parts.pop();
            const targetScope = parts.join(".");
            defaults.route(sourceScope, sourceName, targetScope, targetName);
          });
        }
        function isIChartComponent(proto) {
          return "id" in proto && "defaults" in proto;
        }
        class Registry {
          constructor() {
            this.controllers = new TypedRegistry(DatasetController, "datasets", true);
            this.elements = new TypedRegistry(Element2, "elements");
            this.plugins = new TypedRegistry(Object, "plugins");
            this.scales = new TypedRegistry(Scale, "scales");
            this._typedRegistries = [this.controllers, this.scales, this.elements];
          }
          add(...args) {
            this._each("register", args);
          }
          remove(...args) {
            this._each("unregister", args);
          }
          addControllers(...args) {
            this._each("register", args, this.controllers);
          }
          addElements(...args) {
            this._each("register", args, this.elements);
          }
          addPlugins(...args) {
            this._each("register", args, this.plugins);
          }
          addScales(...args) {
            this._each("register", args, this.scales);
          }
          getController(id) {
            return this._get(id, this.controllers, "controller");
          }
          getElement(id) {
            return this._get(id, this.elements, "element");
          }
          getPlugin(id) {
            return this._get(id, this.plugins, "plugin");
          }
          getScale(id) {
            return this._get(id, this.scales, "scale");
          }
          removeControllers(...args) {
            this._each("unregister", args, this.controllers);
          }
          removeElements(...args) {
            this._each("unregister", args, this.elements);
          }
          removePlugins(...args) {
            this._each("unregister", args, this.plugins);
          }
          removeScales(...args) {
            this._each("unregister", args, this.scales);
          }
          _each(method, args, typedRegistry) {
            [...args].forEach((arg) => {
              const reg = typedRegistry || this._getRegistryForType(arg);
              if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
                this._exec(method, reg, arg);
              } else {
                each(arg, (item) => {
                  const itemReg = typedRegistry || this._getRegistryForType(item);
                  this._exec(method, itemReg, item);
                });
              }
            });
          }
          _exec(method, registry2, component) {
            const camelMethod = _capitalize(method);
            callback(component["before" + camelMethod], [], component);
            registry2[method](component);
            callback(component["after" + camelMethod], [], component);
          }
          _getRegistryForType(type) {
            for (let i = 0; i < this._typedRegistries.length; i++) {
              const reg = this._typedRegistries[i];
              if (reg.isForType(type)) {
                return reg;
              }
            }
            return this.plugins;
          }
          _get(id, typedRegistry, type) {
            const item = typedRegistry.get(id);
            if (item === void 0) {
              throw new Error('"' + id + '" is not a registered ' + type + ".");
            }
            return item;
          }
        }
        var registry = new Registry();
        class PluginService {
          constructor() {
            this._init = [];
          }
          notify(chart2, hook, args, filter) {
            if (hook === "beforeInit") {
              this._init = this._createDescriptors(chart2, true);
              this._notify(this._init, chart2, "install");
            }
            const descriptors2 = filter ? this._descriptors(chart2).filter(filter) : this._descriptors(chart2);
            const result = this._notify(descriptors2, chart2, hook, args);
            if (hook === "afterDestroy") {
              this._notify(descriptors2, chart2, "stop");
              this._notify(this._init, chart2, "uninstall");
            }
            return result;
          }
          _notify(descriptors2, chart2, hook, args) {
            args = args || {};
            for (const descriptor of descriptors2) {
              const plugin = descriptor.plugin;
              const method = plugin[hook];
              const params = [chart2, args, descriptor.options];
              if (callback(method, params, plugin) === false && args.cancelable) {
                return false;
              }
            }
            return true;
          }
          invalidate() {
            if (!isNullOrUndef(this._cache)) {
              this._oldCache = this._cache;
              this._cache = void 0;
            }
          }
          _descriptors(chart2) {
            if (this._cache) {
              return this._cache;
            }
            const descriptors2 = this._cache = this._createDescriptors(chart2);
            this._notifyStateChanges(chart2);
            return descriptors2;
          }
          _createDescriptors(chart2, all) {
            const config = chart2 && chart2.config;
            const options = valueOrDefault(config.options && config.options.plugins, {});
            const plugins2 = allPlugins(config);
            return options === false && !all ? [] : createDescriptors(chart2, plugins2, options, all);
          }
          _notifyStateChanges(chart2) {
            const previousDescriptors = this._oldCache || [];
            const descriptors2 = this._cache;
            const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
            this._notify(diff(previousDescriptors, descriptors2), chart2, "stop");
            this._notify(diff(descriptors2, previousDescriptors), chart2, "start");
          }
        }
        function allPlugins(config) {
          const localIds = {};
          const plugins2 = [];
          const keys = Object.keys(registry.plugins.items);
          for (let i = 0; i < keys.length; i++) {
            plugins2.push(registry.getPlugin(keys[i]));
          }
          const local = config.plugins || [];
          for (let i = 0; i < local.length; i++) {
            const plugin = local[i];
            if (plugins2.indexOf(plugin) === -1) {
              plugins2.push(plugin);
              localIds[plugin.id] = true;
            }
          }
          return { plugins: plugins2, localIds };
        }
        function getOpts(options, all) {
          if (!all && options === false) {
            return null;
          }
          if (options === true) {
            return {};
          }
          return options;
        }
        function createDescriptors(chart2, { plugins: plugins2, localIds }, options, all) {
          const result = [];
          const context = chart2.getContext();
          for (const plugin of plugins2) {
            const id = plugin.id;
            const opts = getOpts(options[id], all);
            if (opts === null) {
              continue;
            }
            result.push({
              plugin,
              options: pluginOpts(chart2.config, { plugin, local: localIds[id] }, opts, context)
            });
          }
          return result;
        }
        function pluginOpts(config, { plugin, local }, opts, context) {
          const keys = config.pluginScopeKeys(plugin);
          const scopes = config.getOptionScopes(opts, keys);
          if (local && plugin.defaults) {
            scopes.push(plugin.defaults);
          }
          return config.createResolver(scopes, context, [""], {
            scriptable: false,
            indexable: false,
            allKeys: true
          });
        }
        function getIndexAxis(type, options) {
          const datasetDefaults = defaults.datasets[type] || {};
          const datasetOptions = (options.datasets || {})[type] || {};
          return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
        }
        function getAxisFromDefaultScaleID(id, indexAxis) {
          let axis = id;
          if (id === "_index_") {
            axis = indexAxis;
          } else if (id === "_value_") {
            axis = indexAxis === "x" ? "y" : "x";
          }
          return axis;
        }
        function getDefaultScaleIDFromAxis(axis, indexAxis) {
          return axis === indexAxis ? "_index_" : "_value_";
        }
        function axisFromPosition(position) {
          if (position === "top" || position === "bottom") {
            return "x";
          }
          if (position === "left" || position === "right") {
            return "y";
          }
        }
        function determineAxis(id, scaleOptions) {
          if (id === "x" || id === "y") {
            return id;
          }
          return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
        }
        function mergeScaleConfig(config, options) {
          const chartDefaults = overrides[config.type] || { scales: {} };
          const configScales = options.scales || {};
          const chartIndexAxis = getIndexAxis(config.type, options);
          const firstIDs = Object.create(null);
          const scales2 = Object.create(null);
          Object.keys(configScales).forEach((id) => {
            const scaleConf = configScales[id];
            if (!isObject2(scaleConf)) {
              return console.error(`Invalid scale configuration for scale: ${id}`);
            }
            if (scaleConf._proxy) {
              return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
            }
            const axis = determineAxis(id, scaleConf);
            const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
            const defaultScaleOptions = chartDefaults.scales || {};
            firstIDs[axis] = firstIDs[axis] || id;
            scales2[id] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
          });
          config.data.datasets.forEach((dataset) => {
            const type = dataset.type || config.type;
            const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
            const datasetDefaults = overrides[type] || {};
            const defaultScaleOptions = datasetDefaults.scales || {};
            Object.keys(defaultScaleOptions).forEach((defaultID) => {
              const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
              const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
              scales2[id] = scales2[id] || Object.create(null);
              mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
            });
          });
          Object.keys(scales2).forEach((key) => {
            const scale = scales2[key];
            mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
          });
          return scales2;
        }
        function initOptions(config) {
          const options = config.options || (config.options = {});
          options.plugins = valueOrDefault(options.plugins, {});
          options.scales = mergeScaleConfig(config, options);
        }
        function initData(data) {
          data = data || {};
          data.datasets = data.datasets || [];
          data.labels = data.labels || [];
          return data;
        }
        function initConfig(config) {
          config = config || {};
          config.data = initData(config.data);
          initOptions(config);
          return config;
        }
        const keyCache = /* @__PURE__ */ new Map();
        const keysCached = /* @__PURE__ */ new Set();
        function cachedKeys(cacheKey, generate) {
          let keys = keyCache.get(cacheKey);
          if (!keys) {
            keys = generate();
            keyCache.set(cacheKey, keys);
            keysCached.add(keys);
          }
          return keys;
        }
        const addIfFound = (set2, obj, key) => {
          const opts = resolveObjectKey(obj, key);
          if (opts !== void 0) {
            set2.add(opts);
          }
        };
        class Config {
          constructor(config) {
            this._config = initConfig(config);
            this._scopeCache = /* @__PURE__ */ new Map();
            this._resolverCache = /* @__PURE__ */ new Map();
          }
          get platform() {
            return this._config.platform;
          }
          get type() {
            return this._config.type;
          }
          set type(type) {
            this._config.type = type;
          }
          get data() {
            return this._config.data;
          }
          set data(data) {
            this._config.data = initData(data);
          }
          get options() {
            return this._config.options;
          }
          set options(options) {
            this._config.options = options;
          }
          get plugins() {
            return this._config.plugins;
          }
          update() {
            const config = this._config;
            this.clearCache();
            initOptions(config);
          }
          clearCache() {
            this._scopeCache.clear();
            this._resolverCache.clear();
          }
          datasetScopeKeys(datasetType) {
            return cachedKeys(datasetType, () => [[
              `datasets.${datasetType}`,
              ""
            ]]);
          }
          datasetAnimationScopeKeys(datasetType, transition) {
            return cachedKeys(`${datasetType}.transition.${transition}`, () => [
              [
                `datasets.${datasetType}.transitions.${transition}`,
                `transitions.${transition}`
              ],
              [
                `datasets.${datasetType}`,
                ""
              ]
            ]);
          }
          datasetElementScopeKeys(datasetType, elementType) {
            return cachedKeys(`${datasetType}-${elementType}`, () => [[
              `datasets.${datasetType}.elements.${elementType}`,
              `datasets.${datasetType}`,
              `elements.${elementType}`,
              ""
            ]]);
          }
          pluginScopeKeys(plugin) {
            const id = plugin.id;
            const type = this.type;
            return cachedKeys(`${type}-plugin-${id}`, () => [[
              `plugins.${id}`,
              ...plugin.additionalOptionScopes || []
            ]]);
          }
          _cachedScopes(mainScope, resetCache) {
            const _scopeCache = this._scopeCache;
            let cache = _scopeCache.get(mainScope);
            if (!cache || resetCache) {
              cache = /* @__PURE__ */ new Map();
              _scopeCache.set(mainScope, cache);
            }
            return cache;
          }
          getOptionScopes(mainScope, keyLists, resetCache) {
            const { options, type } = this;
            const cache = this._cachedScopes(mainScope, resetCache);
            const cached = cache.get(keyLists);
            if (cached) {
              return cached;
            }
            const scopes = /* @__PURE__ */ new Set();
            keyLists.forEach((keys) => {
              if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key) => addIfFound(scopes, mainScope, key));
              }
              keys.forEach((key) => addIfFound(scopes, options, key));
              keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
              keys.forEach((key) => addIfFound(scopes, defaults, key));
              keys.forEach((key) => addIfFound(scopes, descriptors, key));
            });
            const array = Array.from(scopes);
            if (array.length === 0) {
              array.push(Object.create(null));
            }
            if (keysCached.has(keyLists)) {
              cache.set(keyLists, array);
            }
            return array;
          }
          chartOptionScopes() {
            const { options, type } = this;
            return [
              options,
              overrides[type] || {},
              defaults.datasets[type] || {},
              { type },
              defaults,
              descriptors
            ];
          }
          resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
            const result = { $shared: true };
            const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
            let options = resolver;
            if (needContext(resolver, names2)) {
              result.$shared = false;
              context = isFunction2(context) ? context() : context;
              const subResolver = this.createResolver(scopes, context, subPrefixes);
              options = _attachContext(resolver, context, subResolver);
            }
            for (const prop of names2) {
              result[prop] = options[prop];
            }
            return result;
          }
          createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
            const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
            return isObject2(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
          }
        }
        function getResolver(resolverCache, scopes, prefixes) {
          let cache = resolverCache.get(scopes);
          if (!cache) {
            cache = /* @__PURE__ */ new Map();
            resolverCache.set(scopes, cache);
          }
          const cacheKey = prefixes.join();
          let cached = cache.get(cacheKey);
          if (!cached) {
            const resolver = _createResolver(scopes, prefixes);
            cached = {
              resolver,
              subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
            };
            cache.set(cacheKey, cached);
          }
          return cached;
        }
        const hasFunction = (value) => isObject2(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction2(value[key]), false);
        function needContext(proxy, names2) {
          const { isScriptable, isIndexable } = _descriptors(proxy);
          for (const prop of names2) {
            const scriptable = isScriptable(prop);
            const indexable = isIndexable(prop);
            const value = (indexable || scriptable) && proxy[prop];
            if (scriptable && (isFunction2(value) || hasFunction(value)) || indexable && isArray(value)) {
              return true;
            }
          }
          return false;
        }
        var version = "3.9.1";
        const KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
        function positionIsHorizontal(position, axis) {
          return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
        }
        function compare2Level(l1, l2) {
          return function(a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
          };
        }
        function onAnimationsComplete(context) {
          const chart2 = context.chart;
          const animationOptions2 = chart2.options.animation;
          chart2.notifyPlugins("afterRender");
          callback(animationOptions2 && animationOptions2.onComplete, [context], chart2);
        }
        function onAnimationProgress(context) {
          const chart2 = context.chart;
          const animationOptions2 = chart2.options.animation;
          callback(animationOptions2 && animationOptions2.onProgress, [context], chart2);
        }
        function getCanvas(item) {
          if (_isDomSupported() && typeof item === "string") {
            item = document.getElementById(item);
          } else if (item && item.length) {
            item = item[0];
          }
          if (item && item.canvas) {
            item = item.canvas;
          }
          return item;
        }
        const instances = {};
        const getChart = (key) => {
          const canvas = getCanvas(key);
          return Object.values(instances).filter((c) => c.canvas === canvas).pop();
        };
        function moveNumericKeys(obj, start, move2) {
          const keys = Object.keys(obj);
          for (const key of keys) {
            const intKey = +key;
            if (intKey >= start) {
              const value = obj[key];
              delete obj[key];
              if (move2 > 0 || intKey > start) {
                obj[intKey + move2] = value;
              }
            }
          }
        }
        function determineLastEvent(e, lastEvent, inChartArea, isClick) {
          if (!inChartArea || e.type === "mouseout") {
            return null;
          }
          if (isClick) {
            return lastEvent;
          }
          return e;
        }
        class Chart3 {
          constructor(item, userConfig) {
            const config = this.config = new Config(userConfig);
            const initialCanvas = getCanvas(item);
            const existingChart = getChart(initialCanvas);
            if (existingChart) {
              throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
            }
            const options = config.createResolver(config.chartOptionScopes(), this.getContext());
            this.platform = new (config.platform || _detectPlatform(initialCanvas))();
            this.platform.updateConfig(config);
            const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
            const canvas = context && context.canvas;
            const height = canvas && canvas.height;
            const width = canvas && canvas.width;
            this.id = uid();
            this.ctx = context;
            this.canvas = canvas;
            this.width = width;
            this.height = height;
            this._options = options;
            this._aspectRatio = this.aspectRatio;
            this._layers = [];
            this._metasets = [];
            this._stacks = void 0;
            this.boxes = [];
            this.currentDevicePixelRatio = void 0;
            this.chartArea = void 0;
            this._active = [];
            this._lastEvent = void 0;
            this._listeners = {};
            this._responsiveListeners = void 0;
            this._sortedMetasets = [];
            this.scales = {};
            this._plugins = new PluginService();
            this.$proxies = {};
            this._hiddenIndices = {};
            this.attached = false;
            this._animationsDisabled = void 0;
            this.$context = void 0;
            this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
            this._dataChanges = [];
            instances[this.id] = this;
            if (!context || !canvas) {
              console.error("Failed to create chart: can't acquire context from the given item");
              return;
            }
            animator.listen(this, "complete", onAnimationsComplete);
            animator.listen(this, "progress", onAnimationProgress);
            this._initialize();
            if (this.attached) {
              this.update();
            }
          }
          get aspectRatio() {
            const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
            if (!isNullOrUndef(aspectRatio)) {
              return aspectRatio;
            }
            if (maintainAspectRatio && _aspectRatio) {
              return _aspectRatio;
            }
            return height ? width / height : null;
          }
          get data() {
            return this.config.data;
          }
          set data(data) {
            this.config.data = data;
          }
          get options() {
            return this._options;
          }
          set options(options) {
            this.config.options = options;
          }
          _initialize() {
            this.notifyPlugins("beforeInit");
            if (this.options.responsive) {
              this.resize();
            } else {
              retinaScale(this, this.options.devicePixelRatio);
            }
            this.bindEvents();
            this.notifyPlugins("afterInit");
            return this;
          }
          clear() {
            clearCanvas(this.canvas, this.ctx);
            return this;
          }
          stop() {
            animator.stop(this);
            return this;
          }
          resize(width, height) {
            if (!animator.running(this)) {
              this._resize(width, height);
            } else {
              this._resizeBeforeDraw = { width, height };
            }
          }
          _resize(width, height) {
            const options = this.options;
            const canvas = this.canvas;
            const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
            const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
            const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
            const mode = this.width ? "resize" : "attach";
            this.width = newSize.width;
            this.height = newSize.height;
            this._aspectRatio = this.aspectRatio;
            if (!retinaScale(this, newRatio, true)) {
              return;
            }
            this.notifyPlugins("resize", { size: newSize });
            callback(options.onResize, [this, newSize], this);
            if (this.attached) {
              if (this._doResize(mode)) {
                this.render();
              }
            }
          }
          ensureScalesHaveIDs() {
            const options = this.options;
            const scalesOptions = options.scales || {};
            each(scalesOptions, (axisOptions, axisID) => {
              axisOptions.id = axisID;
            });
          }
          buildOrUpdateScales() {
            const options = this.options;
            const scaleOpts = options.scales;
            const scales2 = this.scales;
            const updated = Object.keys(scales2).reduce((obj, id) => {
              obj[id] = false;
              return obj;
            }, {});
            let items = [];
            if (scaleOpts) {
              items = items.concat(Object.keys(scaleOpts).map((id) => {
                const scaleOptions = scaleOpts[id];
                const axis = determineAxis(id, scaleOptions);
                const isRadial = axis === "r";
                const isHorizontal = axis === "x";
                return {
                  options: scaleOptions,
                  dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                  dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
                };
              }));
            }
            each(items, (item) => {
              const scaleOptions = item.options;
              const id = scaleOptions.id;
              const axis = determineAxis(id, scaleOptions);
              const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
              if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
                scaleOptions.position = item.dposition;
              }
              updated[id] = true;
              let scale = null;
              if (id in scales2 && scales2[id].type === scaleType) {
                scale = scales2[id];
              } else {
                const scaleClass = registry.getScale(scaleType);
                scale = new scaleClass({
                  id,
                  type: scaleType,
                  ctx: this.ctx,
                  chart: this
                });
                scales2[scale.id] = scale;
              }
              scale.init(scaleOptions, options);
            });
            each(updated, (hasUpdated, id) => {
              if (!hasUpdated) {
                delete scales2[id];
              }
            });
            each(scales2, (scale) => {
              layouts.configure(this, scale, scale.options);
              layouts.addBox(this, scale);
            });
          }
          _updateMetasets() {
            const metasets = this._metasets;
            const numData = this.data.datasets.length;
            const numMeta = metasets.length;
            metasets.sort((a, b) => a.index - b.index);
            if (numMeta > numData) {
              for (let i = numData; i < numMeta; ++i) {
                this._destroyDatasetMeta(i);
              }
              metasets.splice(numData, numMeta - numData);
            }
            this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
          }
          _removeUnreferencedMetasets() {
            const { _metasets: metasets, data: { datasets } } = this;
            if (metasets.length > datasets.length) {
              delete this._stacks;
            }
            metasets.forEach((meta, index3) => {
              if (datasets.filter((x) => x === meta._dataset).length === 0) {
                this._destroyDatasetMeta(index3);
              }
            });
          }
          buildOrUpdateControllers() {
            const newControllers = [];
            const datasets = this.data.datasets;
            let i, ilen;
            this._removeUnreferencedMetasets();
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              const dataset = datasets[i];
              let meta = this.getDatasetMeta(i);
              const type = dataset.type || this.config.type;
              if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i);
                meta = this.getDatasetMeta(i);
              }
              meta.type = type;
              meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
              meta.order = dataset.order || 0;
              meta.index = i;
              meta.label = "" + dataset.label;
              meta.visible = this.isDatasetVisible(i);
              if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
              } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType, dataElementType } = defaults.datasets[type];
                Object.assign(ControllerClass.prototype, {
                  dataElementType: registry.getElement(dataElementType),
                  datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                });
                meta.controller = new ControllerClass(this, i);
                newControllers.push(meta.controller);
              }
            }
            this._updateMetasets();
            return newControllers;
          }
          _resetElements() {
            each(this.data.datasets, (dataset, datasetIndex) => {
              this.getDatasetMeta(datasetIndex).controller.reset();
            }, this);
          }
          reset() {
            this._resetElements();
            this.notifyPlugins("reset");
          }
          update(mode) {
            const config = this.config;
            config.update();
            const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
            const animsDisabled = this._animationsDisabled = !options.animation;
            this._updateScales();
            this._checkEventBindings();
            this._updateHiddenIndices();
            this._plugins.invalidate();
            if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
              return;
            }
            const newControllers = this.buildOrUpdateControllers();
            this.notifyPlugins("beforeElementsUpdate");
            let minPadding = 0;
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
              const { controller } = this.getDatasetMeta(i);
              const reset2 = !animsDisabled && newControllers.indexOf(controller) === -1;
              controller.buildOrUpdateElements(reset2);
              minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
            }
            minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
            this._updateLayout(minPadding);
            if (!animsDisabled) {
              each(newControllers, (controller) => {
                controller.reset();
              });
            }
            this._updateDatasets(mode);
            this.notifyPlugins("afterUpdate", { mode });
            this._layers.sort(compare2Level("z", "_idx"));
            const { _active, _lastEvent } = this;
            if (_lastEvent) {
              this._eventHandler(_lastEvent, true);
            } else if (_active.length) {
              this._updateHoverStyles(_active, _active, true);
            }
            this.render();
          }
          _updateScales() {
            each(this.scales, (scale) => {
              layouts.removeBox(this, scale);
            });
            this.ensureScalesHaveIDs();
            this.buildOrUpdateScales();
          }
          _checkEventBindings() {
            const options = this.options;
            const existingEvents = new Set(Object.keys(this._listeners));
            const newEvents = new Set(options.events);
            if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
              this.unbindEvents();
              this.bindEvents();
            }
          }
          _updateHiddenIndices() {
            const { _hiddenIndices } = this;
            const changes = this._getUniformDataChanges() || [];
            for (const { method, start, count } of changes) {
              const move2 = method === "_removeElements" ? -count : count;
              moveNumericKeys(_hiddenIndices, start, move2);
            }
          }
          _getUniformDataChanges() {
            const _dataChanges = this._dataChanges;
            if (!_dataChanges || !_dataChanges.length) {
              return;
            }
            this._dataChanges = [];
            const datasetCount = this.data.datasets.length;
            const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
            const changeSet = makeSet(0);
            for (let i = 1; i < datasetCount; i++) {
              if (!setsEqual(changeSet, makeSet(i))) {
                return;
              }
            }
            return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
          }
          _updateLayout(minPadding) {
            if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
              return;
            }
            layouts.update(this, this.width, this.height, minPadding);
            const area = this.chartArea;
            const noArea = area.width <= 0 || area.height <= 0;
            this._layers = [];
            each(this.boxes, (box) => {
              if (noArea && box.position === "chartArea") {
                return;
              }
              if (box.configure) {
                box.configure();
              }
              this._layers.push(...box._layers());
            }, this);
            this._layers.forEach((item, index3) => {
              item._idx = index3;
            });
            this.notifyPlugins("afterLayout");
          }
          _updateDatasets(mode) {
            if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
              return;
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this.getDatasetMeta(i).controller.configure();
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._updateDataset(i, isFunction2(mode) ? mode({ datasetIndex: i }) : mode);
            }
            this.notifyPlugins("afterDatasetsUpdate", { mode });
          }
          _updateDataset(index3, mode) {
            const meta = this.getDatasetMeta(index3);
            const args = { meta, index: index3, mode, cancelable: true };
            if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
              return;
            }
            meta.controller._update(mode);
            args.cancelable = false;
            this.notifyPlugins("afterDatasetUpdate", args);
          }
          render() {
            if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
              return;
            }
            if (animator.has(this)) {
              if (this.attached && !animator.running(this)) {
                animator.start(this);
              }
            } else {
              this.draw();
              onAnimationsComplete({ chart: this });
            }
          }
          draw() {
            let i;
            if (this._resizeBeforeDraw) {
              const { width, height } = this._resizeBeforeDraw;
              this._resize(width, height);
              this._resizeBeforeDraw = null;
            }
            this.clear();
            if (this.width <= 0 || this.height <= 0) {
              return;
            }
            if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
              return;
            }
            const layers = this._layers;
            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
              layers[i].draw(this.chartArea);
            }
            this._drawDatasets();
            for (; i < layers.length; ++i) {
              layers[i].draw(this.chartArea);
            }
            this.notifyPlugins("afterDraw");
          }
          _getSortedDatasetMetas(filterVisible) {
            const metasets = this._sortedMetasets;
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metasets.length; i < ilen; ++i) {
              const meta = metasets[i];
              if (!filterVisible || meta.visible) {
                result.push(meta);
              }
            }
            return result;
          }
          getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(true);
          }
          _drawDatasets() {
            if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
              return;
            }
            const metasets = this.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              this._drawDataset(metasets[i]);
            }
            this.notifyPlugins("afterDatasetsDraw");
          }
          _drawDataset(meta) {
            const ctx = this.ctx;
            const clip = meta._clip;
            const useClip = !clip.disabled;
            const area = this.chartArea;
            const args = {
              meta,
              index: meta.index,
              cancelable: true
            };
            if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
              return;
            }
            if (useClip) {
              clipArea(ctx, {
                left: clip.left === false ? 0 : area.left - clip.left,
                right: clip.right === false ? this.width : area.right + clip.right,
                top: clip.top === false ? 0 : area.top - clip.top,
                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
              });
            }
            meta.controller.draw();
            if (useClip) {
              unclipArea(ctx);
            }
            args.cancelable = false;
            this.notifyPlugins("afterDatasetDraw", args);
          }
          isPointInArea(point) {
            return _isPointInArea(point, this.chartArea, this._minPadding);
          }
          getElementsAtEventForMode(e, mode, options, useFinalPosition) {
            const method = Interaction.modes[mode];
            if (typeof method === "function") {
              return method(this, e, options, useFinalPosition);
            }
            return [];
          }
          getDatasetMeta(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            const metasets = this._metasets;
            let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
            if (!meta) {
              meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset && dataset.order || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false
              };
              metasets.push(meta);
            }
            return meta;
          }
          getContext() {
            return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
          }
          getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length;
          }
          isDatasetVisible(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            if (!dataset) {
              return false;
            }
            const meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
          }
          setDatasetVisibility(datasetIndex, visible) {
            const meta = this.getDatasetMeta(datasetIndex);
            meta.hidden = !visible;
          }
          toggleDataVisibility(index3) {
            this._hiddenIndices[index3] = !this._hiddenIndices[index3];
          }
          getDataVisibility(index3) {
            return !this._hiddenIndices[index3];
          }
          _updateVisibility(datasetIndex, dataIndex, visible) {
            const mode = visible ? "show" : "hide";
            const meta = this.getDatasetMeta(datasetIndex);
            const anims = meta.controller._resolveAnimations(void 0, mode);
            if (defined(dataIndex)) {
              meta.data[dataIndex].hidden = !visible;
              this.update();
            } else {
              this.setDatasetVisibility(datasetIndex, visible);
              anims.update(meta, { visible });
              this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
            }
          }
          hide(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, false);
          }
          show(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, true);
          }
          _destroyDatasetMeta(datasetIndex) {
            const meta = this._metasets[datasetIndex];
            if (meta && meta.controller) {
              meta.controller._destroy();
            }
            delete this._metasets[datasetIndex];
          }
          _stop() {
            let i, ilen;
            this.stop();
            animator.remove(this);
            for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._destroyDatasetMeta(i);
            }
          }
          destroy() {
            this.notifyPlugins("beforeDestroy");
            const { canvas, ctx } = this;
            this._stop();
            this.config.clearCache();
            if (canvas) {
              this.unbindEvents();
              clearCanvas(canvas, ctx);
              this.platform.releaseContext(ctx);
              this.canvas = null;
              this.ctx = null;
            }
            this.notifyPlugins("destroy");
            delete instances[this.id];
            this.notifyPlugins("afterDestroy");
          }
          toBase64Image(...args) {
            return this.canvas.toDataURL(...args);
          }
          bindEvents() {
            this.bindUserEvents();
            if (this.options.responsive) {
              this.bindResponsiveEvents();
            } else {
              this.attached = true;
            }
          }
          bindUserEvents() {
            const listeners = this._listeners;
            const platform = this.platform;
            const _add = (type, listener2) => {
              platform.addEventListener(this, type, listener2);
              listeners[type] = listener2;
            };
            const listener = (e, x, y) => {
              e.offsetX = x;
              e.offsetY = y;
              this._eventHandler(e);
            };
            each(this.options.events, (type) => _add(type, listener));
          }
          bindResponsiveEvents() {
            if (!this._responsiveListeners) {
              this._responsiveListeners = {};
            }
            const listeners = this._responsiveListeners;
            const platform = this.platform;
            const _add = (type, listener2) => {
              platform.addEventListener(this, type, listener2);
              listeners[type] = listener2;
            };
            const _remove = (type, listener2) => {
              if (listeners[type]) {
                platform.removeEventListener(this, type, listener2);
                delete listeners[type];
              }
            };
            const listener = (width, height) => {
              if (this.canvas) {
                this.resize(width, height);
              }
            };
            let detached;
            const attached = () => {
              _remove("attach", attached);
              this.attached = true;
              this.resize();
              _add("resize", listener);
              _add("detach", detached);
            };
            detached = () => {
              this.attached = false;
              _remove("resize", listener);
              this._stop();
              this._resize(0, 0);
              _add("attach", attached);
            };
            if (platform.isAttached(this.canvas)) {
              attached();
            } else {
              detached();
            }
          }
          unbindEvents() {
            each(this._listeners, (listener, type) => {
              this.platform.removeEventListener(this, type, listener);
            });
            this._listeners = {};
            each(this._responsiveListeners, (listener, type) => {
              this.platform.removeEventListener(this, type, listener);
            });
            this._responsiveListeners = void 0;
          }
          updateHoverStyle(items, mode, enabled) {
            const prefix = enabled ? "set" : "remove";
            let meta, item, i, ilen;
            if (mode === "dataset") {
              meta = this.getDatasetMeta(items[0].datasetIndex);
              meta.controller["_" + prefix + "DatasetHoverStyle"]();
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item = items[i];
              const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
              if (controller) {
                controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
              }
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements) {
            const lastActive = this._active || [];
            const active = activeElements.map(({ datasetIndex, index: index3 }) => {
              const meta = this.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error("No dataset found at index " + datasetIndex);
              }
              return {
                datasetIndex,
                element: meta.data[index3],
                index: index3
              };
            });
            const changed = !_elementsEqual(active, lastActive);
            if (changed) {
              this._active = active;
              this._lastEvent = null;
              this._updateHoverStyles(active, lastActive);
            }
          }
          notifyPlugins(hook, args, filter) {
            return this._plugins.notify(this, hook, args, filter);
          }
          _updateHoverStyles(active, lastActive, replay) {
            const hoverOptions = this.options.hover;
            const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
            const deactivated = diff(lastActive, active);
            const activated = replay ? active : diff(active, lastActive);
            if (deactivated.length) {
              this.updateHoverStyle(deactivated, hoverOptions.mode, false);
            }
            if (activated.length && hoverOptions.mode) {
              this.updateHoverStyle(activated, hoverOptions.mode, true);
            }
          }
          _eventHandler(e, replay) {
            const args = {
              event: e,
              replay,
              cancelable: true,
              inChartArea: this.isPointInArea(e)
            };
            const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
            if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
              return;
            }
            const changed = this._handleEvent(e, replay, args.inChartArea);
            args.cancelable = false;
            this.notifyPlugins("afterEvent", args, eventFilter);
            if (changed || args.changed) {
              this.render();
            }
            return this;
          }
          _handleEvent(e, replay, inChartArea) {
            const { _active: lastActive = [], options } = this;
            const useFinalPosition = replay;
            const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
            const isClick = _isClickEvent(e);
            const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
            if (inChartArea) {
              this._lastEvent = null;
              callback(options.onHover, [e, active, this], this);
              if (isClick) {
                callback(options.onClick, [e, active, this], this);
              }
            }
            const changed = !_elementsEqual(active, lastActive);
            if (changed || replay) {
              this._active = active;
              this._updateHoverStyles(active, lastActive, replay);
            }
            this._lastEvent = lastEvent;
            return changed;
          }
          _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
            if (e.type === "mouseout") {
              return [];
            }
            if (!inChartArea) {
              return lastActive;
            }
            const hoverOptions = this.options.hover;
            return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
          }
        }
        const invalidatePlugins = () => each(Chart3.instances, (chart2) => chart2._plugins.invalidate());
        const enumerable = true;
        Object.defineProperties(Chart3, {
          defaults: {
            enumerable,
            value: defaults
          },
          instances: {
            enumerable,
            value: instances
          },
          overrides: {
            enumerable,
            value: overrides
          },
          registry: {
            enumerable,
            value: registry
          },
          version: {
            enumerable,
            value: version
          },
          getChart: {
            enumerable,
            value: getChart
          },
          register: {
            enumerable,
            value: (...items) => {
              registry.add(...items);
              invalidatePlugins();
            }
          },
          unregister: {
            enumerable,
            value: (...items) => {
              registry.remove(...items);
              invalidatePlugins();
            }
          }
        });
        function abstract() {
          throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
        }
        class DateAdapter {
          constructor(options) {
            this.options = options || {};
          }
          init(chartOptions) {
          }
          formats() {
            return abstract();
          }
          parse(value, format) {
            return abstract();
          }
          format(timestamp, format) {
            return abstract();
          }
          add(timestamp, amount, unit) {
            return abstract();
          }
          diff(a, b, unit) {
            return abstract();
          }
          startOf(timestamp, unit, weekday) {
            return abstract();
          }
          endOf(timestamp, unit) {
            return abstract();
          }
        }
        DateAdapter.override = function(members) {
          Object.assign(DateAdapter.prototype, members);
        };
        var _adapters = {
          _date: DateAdapter
        };
        function getAllScaleValues(scale, type) {
          if (!scale._cache.$bar) {
            const visibleMetas = scale.getMatchingVisibleMetas(type);
            let values = [];
            for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
              values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
            }
            scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
          }
          return scale._cache.$bar;
        }
        function computeMinSampleSize(meta) {
          const scale = meta.iScale;
          const values = getAllScaleValues(scale, meta.type);
          let min = scale._length;
          let i, ilen, curr, prev;
          const updateMinAndPrev = () => {
            if (curr === 32767 || curr === -32768) {
              return;
            }
            if (defined(prev)) {
              min = Math.min(min, Math.abs(curr - prev) || min);
            }
            prev = curr;
          };
          for (i = 0, ilen = values.length; i < ilen; ++i) {
            curr = scale.getPixelForValue(values[i]);
            updateMinAndPrev();
          }
          prev = void 0;
          for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
            curr = scale.getPixelForTick(i);
            updateMinAndPrev();
          }
          return min;
        }
        function computeFitCategoryTraits(index3, ruler, options, stackCount) {
          const thickness = options.barThickness;
          let size, ratio;
          if (isNullOrUndef(thickness)) {
            size = ruler.min * options.categoryPercentage;
            ratio = options.barPercentage;
          } else {
            size = thickness * stackCount;
            ratio = 1;
          }
          return {
            chunk: size / stackCount,
            ratio,
            start: ruler.pixels[index3] - size / 2
          };
        }
        function computeFlexCategoryTraits(index3, ruler, options, stackCount) {
          const pixels = ruler.pixels;
          const curr = pixels[index3];
          let prev = index3 > 0 ? pixels[index3 - 1] : null;
          let next = index3 < pixels.length - 1 ? pixels[index3 + 1] : null;
          const percent = options.categoryPercentage;
          if (prev === null) {
            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
          }
          if (next === null) {
            next = curr + curr - prev;
          }
          const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
          const size = Math.abs(next - prev) / 2 * percent;
          return {
            chunk: size / stackCount,
            ratio: options.barPercentage,
            start
          };
        }
        function parseFloatBar(entry, item, vScale, i) {
          const startValue = vScale.parse(entry[0], i);
          const endValue = vScale.parse(entry[1], i);
          const min = Math.min(startValue, endValue);
          const max = Math.max(startValue, endValue);
          let barStart = min;
          let barEnd = max;
          if (Math.abs(min) > Math.abs(max)) {
            barStart = max;
            barEnd = min;
          }
          item[vScale.axis] = barEnd;
          item._custom = {
            barStart,
            barEnd,
            start: startValue,
            end: endValue,
            min,
            max
          };
        }
        function parseValue(entry, item, vScale, i) {
          if (isArray(entry)) {
            parseFloatBar(entry, item, vScale, i);
          } else {
            item[vScale.axis] = vScale.parse(entry, i);
          }
          return item;
        }
        function parseArrayOrPrimitive(meta, data, start, count) {
          const iScale = meta.iScale;
          const vScale = meta.vScale;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = [];
          let i, ilen, item, entry;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            entry = data[i];
            item = {};
            item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
            parsed.push(parseValue(entry, item, vScale, i));
          }
          return parsed;
        }
        function isFloatBar(custom) {
          return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
        }
        function barSign(size, vScale, actualBase) {
          if (size !== 0) {
            return sign(size);
          }
          return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
        }
        function borderProps(properties) {
          let reverse, start, end, top, bottom;
          if (properties.horizontal) {
            reverse = properties.base > properties.x;
            start = "left";
            end = "right";
          } else {
            reverse = properties.base < properties.y;
            start = "bottom";
            end = "top";
          }
          if (reverse) {
            top = "end";
            bottom = "start";
          } else {
            top = "start";
            bottom = "end";
          }
          return { start, end, reverse, top, bottom };
        }
        function setBorderSkipped(properties, options, stack, index3) {
          let edge = options.borderSkipped;
          const res = {};
          if (!edge) {
            properties.borderSkipped = res;
            return;
          }
          if (edge === true) {
            properties.borderSkipped = { top: true, right: true, bottom: true, left: true };
            return;
          }
          const { start, end, reverse, top, bottom } = borderProps(properties);
          if (edge === "middle" && stack) {
            properties.enableBorderRadius = true;
            if ((stack._top || 0) === index3) {
              edge = top;
            } else if ((stack._bottom || 0) === index3) {
              edge = bottom;
            } else {
              res[parseEdge(bottom, start, end, reverse)] = true;
              edge = top;
            }
          }
          res[parseEdge(edge, start, end, reverse)] = true;
          properties.borderSkipped = res;
        }
        function parseEdge(edge, a, b, reverse) {
          if (reverse) {
            edge = swap(edge, a, b);
            edge = startEnd(edge, b, a);
          } else {
            edge = startEnd(edge, a, b);
          }
          return edge;
        }
        function swap(orig, v1, v2) {
          return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function startEnd(v, start, end) {
          return v === "start" ? start : v === "end" ? end : v;
        }
        function setInflateAmount(properties, { inflateAmount }, ratio) {
          properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
        }
        class BarController extends DatasetController {
          parsePrimitiveData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseArrayData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseObjectData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
            const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
            const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
            const parsed = [];
            let i, ilen, item, obj;
            for (i = start, ilen = start + count; i < ilen; ++i) {
              obj = data[i];
              item = {};
              item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
              parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
            }
            return parsed;
          }
          updateRangeFromParsed(range2, scale, parsed, stack) {
            super.updateRangeFromParsed(range2, scale, parsed, stack);
            const custom = parsed._custom;
            if (custom && scale === this._cachedMeta.vScale) {
              range2.min = Math.min(range2.min, custom.min);
              range2.max = Math.max(range2.max, custom.max);
            }
          }
          getMaxOverflow() {
            return 0;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const { iScale, vScale } = meta;
            const parsed = this.getParsed(index3);
            const custom = parsed._custom;
            const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
            return {
              label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
              value
            };
          }
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
            const meta = this._cachedMeta;
            meta.stack = this.getDataset().stack;
          }
          update(mode) {
            const meta = this._cachedMeta;
            this.updateElements(meta.data, 0, meta.data.length, mode);
          }
          updateElements(bars, start, count, mode) {
            const reset2 = mode === "reset";
            const { index: index3, _cachedMeta: { vScale } } = this;
            const base = vScale.getBasePixel();
            const horizontal = vScale.isHorizontal();
            const ruler = this._getRuler();
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            for (let i = start; i < start + count; i++) {
              const parsed = this.getParsed(i);
              const vpixels = reset2 || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
              const ipixels = this._calculateBarIndexPixels(i, ruler);
              const stack = (parsed._stacks || {})[vScale.axis];
              const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index3 === stack._top || index3 === stack._bottom),
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size
              };
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
              }
              const options = properties.options || bars[i].options;
              setBorderSkipped(properties, options, stack, index3);
              setInflateAmount(properties, options, ruler.ratio);
              this.updateElement(bars[i], i, properties, mode);
            }
          }
          _getStacks(last, dataIndex) {
            const { iScale } = this._cachedMeta;
            const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
            const stacked = iScale.options.stacked;
            const stacks = [];
            const skipNull = (meta) => {
              const parsed = meta.controller.getParsed(dataIndex);
              const val2 = parsed && parsed[meta.vScale.axis];
              if (isNullOrUndef(val2) || isNaN(val2)) {
                return true;
              }
            };
            for (const meta of metasets) {
              if (dataIndex !== void 0 && skipNull(meta)) {
                continue;
              }
              if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
                stacks.push(meta.stack);
              }
              if (meta.index === last) {
                break;
              }
            }
            if (!stacks.length) {
              stacks.push(void 0);
            }
            return stacks;
          }
          _getStackCount(index3) {
            return this._getStacks(void 0, index3).length;
          }
          _getStackIndex(datasetIndex, name, dataIndex) {
            const stacks = this._getStacks(datasetIndex, dataIndex);
            const index3 = name !== void 0 ? stacks.indexOf(name) : -1;
            return index3 === -1 ? stacks.length - 1 : index3;
          }
          _getRuler() {
            const opts = this.options;
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const pixels = [];
            let i, ilen;
            for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
              pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
            }
            const barThickness = opts.barThickness;
            const min = barThickness || computeMinSampleSize(meta);
            return {
              min,
              pixels,
              start: iScale._startPixel,
              end: iScale._endPixel,
              stackCount: this._getStackCount(),
              scale: iScale,
              grouped: opts.grouped,
              ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
            };
          }
          _calculateBarValuePixels(index3) {
            const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
            const actualBase = baseValue || 0;
            const parsed = this.getParsed(index3);
            const custom = parsed._custom;
            const floating = isFloatBar(custom);
            let value = parsed[vScale.axis];
            let start = 0;
            let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
            let head, size;
            if (length !== value) {
              start = length - value;
              length = value;
            }
            if (floating) {
              value = custom.barStart;
              length = custom.barEnd - custom.barStart;
              if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
                start = 0;
              }
              start += value;
            }
            const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
            let base = vScale.getPixelForValue(startValue);
            if (this.chart.getDataVisibility(index3)) {
              head = vScale.getPixelForValue(start + length);
            } else {
              head = base;
            }
            size = head - base;
            if (Math.abs(size) < minBarLength) {
              size = barSign(size, vScale, actualBase) * minBarLength;
              if (value === actualBase) {
                base -= size / 2;
              }
              const startPixel = vScale.getPixelForDecimal(0);
              const endPixel = vScale.getPixelForDecimal(1);
              const min = Math.min(startPixel, endPixel);
              const max = Math.max(startPixel, endPixel);
              base = Math.max(Math.min(base, max), min);
              head = base + size;
            }
            if (base === vScale.getPixelForValue(actualBase)) {
              const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
              base += halfGrid;
              size -= halfGrid;
            }
            return {
              size,
              base,
              head,
              center: head + size / 2
            };
          }
          _calculateBarIndexPixels(index3, ruler) {
            const scale = ruler.scale;
            const options = this.options;
            const skipNull = options.skipNull;
            const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
            let center, size;
            if (ruler.grouped) {
              const stackCount = skipNull ? this._getStackCount(index3) : ruler.stackCount;
              const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index3, ruler, options, stackCount) : computeFitCategoryTraits(index3, ruler, options, stackCount);
              const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index3 : void 0);
              center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
              size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
            } else {
              center = scale.getPixelForValue(this.getParsed(index3)[scale.axis], index3);
              size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
            }
            return {
              base: center - size / 2,
              head: center + size / 2,
              center,
              size
            };
          }
          draw() {
            const meta = this._cachedMeta;
            const vScale = meta.vScale;
            const rects = meta.data;
            const ilen = rects.length;
            let i = 0;
            for (; i < ilen; ++i) {
              if (this.getParsed(i)[vScale.axis] !== null) {
                rects[i].draw(this._ctx);
              }
            }
          }
        }
        BarController.id = "bar";
        BarController.defaults = {
          datasetElementType: false,
          dataElementType: "bar",
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          grouped: true,
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "base", "width", "height"]
            }
          }
        };
        BarController.overrides = {
          scales: {
            _index_: {
              type: "category",
              offset: true,
              grid: {
                offset: true
              }
            },
            _value_: {
              type: "linear",
              beginAtZero: true
            }
          }
        };
        class BubbleController extends DatasetController {
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
          }
          parsePrimitiveData(meta, data, start, count) {
            const parsed = super.parsePrimitiveData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const parsed = super.parseArrayData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const parsed = super.parseObjectData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
          }
          getMaxOverflow() {
            const data = this._cachedMeta.data;
            let max = 0;
            for (let i = data.length - 1; i >= 0; --i) {
              max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            }
            return max > 0 && max;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const { xScale, yScale } = meta;
            const parsed = this.getParsed(index3);
            const x = xScale.getLabelForValue(parsed.x);
            const y = yScale.getLabelForValue(parsed.y);
            const r = parsed._custom;
            return {
              label: meta.label,
              value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
            };
          }
          update(mode) {
            const points = this._cachedMeta.data;
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const reset2 = mode === "reset";
            const { iScale, vScale } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const parsed = !reset2 && this.getParsed(i);
              const properties = {};
              const iPixel = properties[iAxis] = reset2 ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
              const vPixel = properties[vAxis] = reset2 ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
              properties.skip = isNaN(iPixel) || isNaN(vPixel);
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                if (reset2) {
                  properties.options.radius = 0;
                }
              }
              this.updateElement(point, i, properties, mode);
            }
          }
          resolveDataElementOptions(index3, mode) {
            const parsed = this.getParsed(index3);
            let values = super.resolveDataElementOptions(index3, mode);
            if (values.$shared) {
              values = Object.assign({}, values, { $shared: false });
            }
            const radius = values.radius;
            if (mode !== "active") {
              values.radius = 0;
            }
            values.radius += valueOrDefault(parsed && parsed._custom, radius);
            return values;
          }
        }
        BubbleController.id = "bubble";
        BubbleController.defaults = {
          datasetElementType: false,
          dataElementType: "point",
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "borderWidth", "radius"]
            }
          }
        };
        BubbleController.overrides = {
          scales: {
            x: {
              type: "linear"
            },
            y: {
              type: "linear"
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title() {
                  return "";
                }
              }
            }
          }
        };
        function getRatioAndOffset(rotation, circumference, cutout) {
          let ratioX = 1;
          let ratioY = 1;
          let offsetX = 0;
          let offsetY = 0;
          if (circumference < TAU) {
            const startAngle = rotation;
            const endAngle = startAngle + circumference;
            const startX = Math.cos(startAngle);
            const startY = Math.sin(startAngle);
            const endX = Math.cos(endAngle);
            const endY = Math.sin(endAngle);
            const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
            const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
            const maxX = calcMax(0, startX, endX);
            const maxY = calcMax(HALF_PI, startY, endY);
            const minX = calcMin(PI, startX, endX);
            const minY = calcMin(PI + HALF_PI, startY, endY);
            ratioX = (maxX - minX) / 2;
            ratioY = (maxY - minY) / 2;
            offsetX = -(maxX + minX) / 2;
            offsetY = -(maxY + minY) / 2;
          }
          return { ratioX, ratioY, offsetX, offsetY };
        }
        class DoughnutController extends DatasetController {
          constructor(chart2, datasetIndex) {
            super(chart2, datasetIndex);
            this.enableOptionSharing = true;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.offsetX = void 0;
            this.offsetY = void 0;
          }
          linkScales() {
          }
          parse(start, count) {
            const data = this.getDataset().data;
            const meta = this._cachedMeta;
            if (this._parsing === false) {
              meta._parsed = data;
            } else {
              let getter = (i2) => +data[i2];
              if (isObject2(data[start])) {
                const { key = "value" } = this._parsing;
                getter = (i2) => +resolveObjectKey(data[i2], key);
              }
              let i, ilen;
              for (i = start, ilen = start + count; i < ilen; ++i) {
                meta._parsed[i] = getter(i);
              }
            }
          }
          _getRotation() {
            return toRadians(this.options.rotation - 90);
          }
          _getCircumference() {
            return toRadians(this.options.circumference);
          }
          _getRotationExtents() {
            let min = TAU;
            let max = -TAU;
            for (let i = 0; i < this.chart.data.datasets.length; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                const controller = this.chart.getDatasetMeta(i).controller;
                const rotation = controller._getRotation();
                const circumference = controller._getCircumference();
                min = Math.min(min, rotation);
                max = Math.max(max, rotation + circumference);
              }
            }
            return {
              rotation: min,
              circumference: max - min
            };
          }
          update(mode) {
            const chart2 = this.chart;
            const { chartArea } = chart2;
            const meta = this._cachedMeta;
            const arcs = meta.data;
            const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
            const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
            const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
            const chartWeight = this._getRingWeight(this.index);
            const { circumference, rotation } = this._getRotationExtents();
            const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
            const maxWidth = (chartArea.width - spacing) / ratioX;
            const maxHeight = (chartArea.height - spacing) / ratioY;
            const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            const outerRadius = toDimension(this.options.radius, maxRadius);
            const innerRadius = Math.max(outerRadius * cutout, 0);
            const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
            this.offsetX = offsetX * outerRadius;
            this.offsetY = offsetY * outerRadius;
            meta.total = this.calculateTotal();
            this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
            this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          _circumference(i, reset2) {
            const opts = this.options;
            const meta = this._cachedMeta;
            const circumference = this._getCircumference();
            if (reset2 && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
              return 0;
            }
            return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
          }
          updateElements(arcs, start, count, mode) {
            const reset2 = mode === "reset";
            const chart2 = this.chart;
            const chartArea = chart2.chartArea;
            const opts = chart2.options;
            const animationOpts = opts.animation;
            const centerX = (chartArea.left + chartArea.right) / 2;
            const centerY = (chartArea.top + chartArea.bottom) / 2;
            const animateScale = reset2 && animationOpts.animateScale;
            const innerRadius = animateScale ? 0 : this.innerRadius;
            const outerRadius = animateScale ? 0 : this.outerRadius;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            let startAngle = this._getRotation();
            let i;
            for (i = 0; i < start; ++i) {
              startAngle += this._circumference(i, reset2);
            }
            for (i = start; i < start + count; ++i) {
              const circumference = this._circumference(i, reset2);
              const arc = arcs[i];
              const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius
              };
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
              }
              startAngle += circumference;
              this.updateElement(arc, i, properties, mode);
            }
          }
          calculateTotal() {
            const meta = this._cachedMeta;
            const metaData = meta.data;
            let total = 0;
            let i;
            for (i = 0; i < metaData.length; i++) {
              const value = meta._parsed[i];
              if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
                total += Math.abs(value);
              }
            }
            return total;
          }
          calculateCircumference(value) {
            const total = this._cachedMeta.total;
            if (total > 0 && !isNaN(value)) {
              return TAU * (Math.abs(value) / total);
            }
            return 0;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const chart2 = this.chart;
            const labels = chart2.data.labels || [];
            const value = formatNumber(meta._parsed[index3], chart2.options.locale);
            return {
              label: labels[index3] || "",
              value
            };
          }
          getMaxBorderWidth(arcs) {
            let max = 0;
            const chart2 = this.chart;
            let i, ilen, meta, controller, options;
            if (!arcs) {
              for (i = 0, ilen = chart2.data.datasets.length; i < ilen; ++i) {
                if (chart2.isDatasetVisible(i)) {
                  meta = chart2.getDatasetMeta(i);
                  arcs = meta.data;
                  controller = meta.controller;
                  break;
                }
              }
            }
            if (!arcs) {
              return 0;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              options = controller.resolveDataElementOptions(i);
              if (options.borderAlign !== "inner") {
                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
              }
            }
            return max;
          }
          getMaxOffset(arcs) {
            let max = 0;
            for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
              const options = this.resolveDataElementOptions(i);
              max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
            }
            return max;
          }
          _getRingWeightOffset(datasetIndex) {
            let ringWeightOffset = 0;
            for (let i = 0; i < datasetIndex; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
              }
            }
            return ringWeightOffset;
          }
          _getRingWeight(datasetIndex) {
            return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
          }
          _getVisibleDatasetWeightTotal() {
            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
          }
        }
        DoughnutController.id = "doughnut";
        DoughnutController.defaults = {
          datasetElementType: false,
          dataElementType: "arc",
          animation: {
            animateRotate: true,
            animateScale: false
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
            }
          },
          cutout: "50%",
          rotation: 0,
          circumference: 360,
          radius: "100%",
          spacing: 0,
          indexAxis: "r"
        };
        DoughnutController.descriptors = {
          _scriptable: (name) => name !== "spacing",
          _indexable: (name) => name !== "spacing"
        };
        DoughnutController.overrides = {
          aspectRatio: 1,
          plugins: {
            legend: {
              labels: {
                generateLabels(chart2) {
                  const data = chart2.data;
                  if (data.labels.length && data.datasets.length) {
                    const { labels: { pointStyle } } = chart2.legend.options;
                    return data.labels.map((label, i) => {
                      const meta = chart2.getDatasetMeta(0);
                      const style = meta.controller.getStyle(i);
                      return {
                        text: label,
                        fillStyle: style.backgroundColor,
                        strokeStyle: style.borderColor,
                        lineWidth: style.borderWidth,
                        pointStyle,
                        hidden: !chart2.getDataVisibility(i),
                        index: i
                      };
                    });
                  }
                  return [];
                }
              },
              onClick(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
              }
            },
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(tooltipItem) {
                  let dataLabel = tooltipItem.label;
                  const value = ": " + tooltipItem.formattedValue;
                  if (isArray(dataLabel)) {
                    dataLabel = dataLabel.slice();
                    dataLabel[0] += value;
                  } else {
                    dataLabel += value;
                  }
                  return dataLabel;
                }
              }
            }
          }
        };
        class LineController extends DatasetController {
          initialize() {
            this.enableOptionSharing = true;
            this.supportsDecimation = true;
            super.initialize();
          }
          update(mode) {
            const meta = this._cachedMeta;
            const { dataset: line, data: points = [], _dataset } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
            this._drawStart = start;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
              start = 0;
              count = points.length;
            }
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
              options.borderWidth = 0;
            }
            options.segment = this.options.segment;
            this.updateElement(line, void 0, {
              animated: !animationsDisabled,
              options
            }, mode);
            this.updateElements(points, start, count, mode);
          }
          updateElements(points, start, count, mode) {
            const reset2 = mode === "reset";
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
            const directUpdate = this.chart._animationsDisabled || reset2 || mode === "none";
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = start; i < start + count; ++i) {
              const point = points[i];
              const parsed = this.getParsed(i);
              const properties = directUpdate ? point : {};
              const nullData = isNullOrUndef(parsed[vAxis]);
              const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
              const vPixel = properties[vAxis] = reset2 || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
              }
              if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
            }
          }
          getMaxOverflow() {
            const meta = this._cachedMeta;
            const dataset = meta.dataset;
            const border = dataset.options && dataset.options.borderWidth || 0;
            const data = meta.data || [];
            if (!data.length) {
              return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2;
          }
          draw() {
            const meta = this._cachedMeta;
            meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
            super.draw();
          }
        }
        LineController.id = "line";
        LineController.defaults = {
          datasetElementType: "line",
          dataElementType: "point",
          showLine: true,
          spanGaps: false
        };
        LineController.overrides = {
          scales: {
            _index_: {
              type: "category"
            },
            _value_: {
              type: "linear"
            }
          }
        };
        class PolarAreaController extends DatasetController {
          constructor(chart2, datasetIndex) {
            super(chart2, datasetIndex);
            this.innerRadius = void 0;
            this.outerRadius = void 0;
          }
          getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const chart2 = this.chart;
            const labels = chart2.data.labels || [];
            const value = formatNumber(meta._parsed[index3].r, chart2.options.locale);
            return {
              label: labels[index3] || "",
              value
            };
          }
          parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
          }
          update(mode) {
            const arcs = this._cachedMeta.data;
            this._updateRadius();
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          getMinMax() {
            const meta = this._cachedMeta;
            const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
            meta.data.forEach((element, index3) => {
              const parsed = this.getParsed(index3).r;
              if (!isNaN(parsed) && this.chart.getDataVisibility(index3)) {
                if (parsed < range2.min) {
                  range2.min = parsed;
                }
                if (parsed > range2.max) {
                  range2.max = parsed;
                }
              }
            });
            return range2;
          }
          _updateRadius() {
            const chart2 = this.chart;
            const chartArea = chart2.chartArea;
            const opts = chart2.options;
            const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            const outerRadius = Math.max(minSize / 2, 0);
            const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            const radiusLength = (outerRadius - innerRadius) / chart2.getVisibleDatasetCount();
            this.outerRadius = outerRadius - radiusLength * this.index;
            this.innerRadius = this.outerRadius - radiusLength;
          }
          updateElements(arcs, start, count, mode) {
            const reset2 = mode === "reset";
            const chart2 = this.chart;
            const opts = chart2.options;
            const animationOpts = opts.animation;
            const scale = this._cachedMeta.rScale;
            const centerX = scale.xCenter;
            const centerY = scale.yCenter;
            const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
            let angle = datasetStartAngle;
            let i;
            const defaultAngle = 360 / this.countVisibleElements();
            for (i = 0; i < start; ++i) {
              angle += this._computeAngle(i, mode, defaultAngle);
            }
            for (i = start; i < start + count; i++) {
              const arc = arcs[i];
              let startAngle = angle;
              let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
              let outerRadius = chart2.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
              angle = endAngle;
              if (reset2) {
                if (animationOpts.animateScale) {
                  outerRadius = 0;
                }
                if (animationOpts.animateRotate) {
                  startAngle = endAngle = datasetStartAngle;
                }
              }
              const properties = {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle,
                options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
              };
              this.updateElement(arc, i, properties, mode);
            }
          }
          countVisibleElements() {
            const meta = this._cachedMeta;
            let count = 0;
            meta.data.forEach((element, index3) => {
              if (!isNaN(this.getParsed(index3).r) && this.chart.getDataVisibility(index3)) {
                count++;
              }
            });
            return count;
          }
          _computeAngle(index3, mode, defaultAngle) {
            return this.chart.getDataVisibility(index3) ? toRadians(this.resolveDataElementOptions(index3, mode).angle || defaultAngle) : 0;
          }
        }
        PolarAreaController.id = "polarArea";
        PolarAreaController.defaults = {
          dataElementType: "arc",
          animation: {
            animateRotate: true,
            animateScale: true
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
            }
          },
          indexAxis: "r",
          startAngle: 0
        };
        PolarAreaController.overrides = {
          aspectRatio: 1,
          plugins: {
            legend: {
              labels: {
                generateLabels(chart2) {
                  const data = chart2.data;
                  if (data.labels.length && data.datasets.length) {
                    const { labels: { pointStyle } } = chart2.legend.options;
                    return data.labels.map((label, i) => {
                      const meta = chart2.getDatasetMeta(0);
                      const style = meta.controller.getStyle(i);
                      return {
                        text: label,
                        fillStyle: style.backgroundColor,
                        strokeStyle: style.borderColor,
                        lineWidth: style.borderWidth,
                        pointStyle,
                        hidden: !chart2.getDataVisibility(i),
                        index: i
                      };
                    });
                  }
                  return [];
                }
              },
              onClick(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
              }
            },
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(context) {
                  return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
                }
              }
            }
          },
          scales: {
            r: {
              type: "radialLinear",
              angleLines: {
                display: false
              },
              beginAtZero: true,
              grid: {
                circular: true
              },
              pointLabels: {
                display: false
              },
              startAngle: 0
            }
          }
        };
        class PieController extends DoughnutController {
        }
        PieController.id = "pie";
        PieController.defaults = {
          cutout: 0,
          rotation: 0,
          circumference: 360,
          radius: "100%"
        };
        class RadarController extends DatasetController {
          getLabelAndValue(index3) {
            const vScale = this._cachedMeta.vScale;
            const parsed = this.getParsed(index3);
            return {
              label: vScale.getLabels()[index3],
              value: "" + vScale.getLabelForValue(parsed[vScale.axis])
            };
          }
          parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
          }
          update(mode) {
            const meta = this._cachedMeta;
            const line = meta.dataset;
            const points = meta.data || [];
            const labels = meta.iScale.getLabels();
            line.points = points;
            if (mode !== "resize") {
              const options = this.resolveDatasetElementOptions(mode);
              if (!this.options.showLine) {
                options.borderWidth = 0;
              }
              const properties = {
                _loop: true,
                _fullLoop: labels.length === points.length,
                options
              };
              this.updateElement(line, void 0, properties, mode);
            }
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const scale = this._cachedMeta.rScale;
            const reset2 = mode === "reset";
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
              const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
              const x = reset2 ? scale.xCenter : pointPosition.x;
              const y = reset2 ? scale.yCenter : pointPosition.y;
              const properties = {
                x,
                y,
                angle: pointPosition.angle,
                skip: isNaN(x) || isNaN(y),
                options
              };
              this.updateElement(point, i, properties, mode);
            }
          }
        }
        RadarController.id = "radar";
        RadarController.defaults = {
          datasetElementType: "line",
          dataElementType: "point",
          indexAxis: "r",
          showLine: true,
          elements: {
            line: {
              fill: "start"
            }
          }
        };
        RadarController.overrides = {
          aspectRatio: 1,
          scales: {
            r: {
              type: "radialLinear"
            }
          }
        };
        class ScatterController extends DatasetController {
          update(mode) {
            const meta = this._cachedMeta;
            const { data: points = [] } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
            this._drawStart = start;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
              start = 0;
              count = points.length;
            }
            if (this.options.showLine) {
              const { dataset: line, _dataset } = meta;
              line._chart = this.chart;
              line._datasetIndex = this.index;
              line._decimated = !!_dataset._decimated;
              line.points = points;
              const options = this.resolveDatasetElementOptions(mode);
              options.segment = this.options.segment;
              this.updateElement(line, void 0, {
                animated: !animationsDisabled,
                options
              }, mode);
            }
            this.updateElements(points, start, count, mode);
          }
          addElements() {
            const { showLine } = this.options;
            if (!this.datasetElementType && showLine) {
              this.datasetElementType = registry.getElement("line");
            }
            super.addElements();
          }
          updateElements(points, start, count, mode) {
            const reset2 = mode === "reset";
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
            const directUpdate = this.chart._animationsDisabled || reset2 || mode === "none";
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = start; i < start + count; ++i) {
              const point = points[i];
              const parsed = this.getParsed(i);
              const properties = directUpdate ? point : {};
              const nullData = isNullOrUndef(parsed[vAxis]);
              const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
              const vPixel = properties[vAxis] = reset2 || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
              }
              if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
          }
          getMaxOverflow() {
            const meta = this._cachedMeta;
            const data = meta.data || [];
            if (!this.options.showLine) {
              let max = 0;
              for (let i = data.length - 1; i >= 0; --i) {
                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
              }
              return max > 0 && max;
            }
            const dataset = meta.dataset;
            const border = dataset.options && dataset.options.borderWidth || 0;
            if (!data.length) {
              return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2;
          }
        }
        ScatterController.id = "scatter";
        ScatterController.defaults = {
          datasetElementType: false,
          dataElementType: "point",
          showLine: false,
          fill: false
        };
        ScatterController.overrides = {
          interaction: {
            mode: "point"
          },
          plugins: {
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(item) {
                  return "(" + item.label + ", " + item.formattedValue + ")";
                }
              }
            }
          },
          scales: {
            x: {
              type: "linear"
            },
            y: {
              type: "linear"
            }
          }
        };
        var controllers = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          BarController,
          BubbleController,
          DoughnutController,
          LineController,
          PolarAreaController,
          PieController,
          RadarController,
          ScatterController
        });
        function clipArc(ctx, element, endAngle) {
          const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
          let angleMargin = pixelMargin / outerRadius;
          ctx.beginPath();
          ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
          if (innerRadius > pixelMargin) {
            angleMargin = pixelMargin / innerRadius;
            ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
          } else {
            ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
          }
          ctx.closePath();
          ctx.clip();
        }
        function toRadiusCorners(value) {
          return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
        }
        function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
          const o = toRadiusCorners(arc.options.borderRadius);
          const halfThickness = (outerRadius - innerRadius) / 2;
          const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
          const computeOuterLimit = (val2) => {
            const outerArcLimit = (outerRadius - Math.min(halfThickness, val2)) * angleDelta / 2;
            return _limitValue(val2, 0, Math.min(halfThickness, outerArcLimit));
          };
          return {
            outerStart: computeOuterLimit(o.outerStart),
            outerEnd: computeOuterLimit(o.outerEnd),
            innerStart: _limitValue(o.innerStart, 0, innerLimit),
            innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
          };
        }
        function rThetaToXY(r, theta, x, y) {
          return {
            x: x + r * Math.cos(theta),
            y: y + r * Math.sin(theta)
          };
        }
        function pathArc(ctx, element, offset, spacing, end, circular) {
          const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
          const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
          const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
          let spacingOffset = 0;
          const alpha2 = end - start;
          if (spacing) {
            const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
            const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
            const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
            const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
            spacingOffset = (alpha2 - adjustedAngle) / 2;
          }
          const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
          const angleOffset = (alpha2 - beta) / 2;
          const startAngle = start + angleOffset + spacingOffset;
          const endAngle = end - angleOffset - spacingOffset;
          const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
          const outerStartAdjustedRadius = outerRadius - outerStart;
          const outerEndAdjustedRadius = outerRadius - outerEnd;
          const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
          const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
          const innerStartAdjustedRadius = innerRadius + innerStart;
          const innerEndAdjustedRadius = innerRadius + innerEnd;
          const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
          const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
          ctx.beginPath();
          if (circular) {
            ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
            if (outerEnd > 0) {
              const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
            }
            const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
            ctx.lineTo(p4.x, p4.y);
            if (innerEnd > 0) {
              const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
            }
            ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
            if (innerStart > 0) {
              const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
            }
            const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
            ctx.lineTo(p8.x, p8.y);
            if (outerStart > 0) {
              const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
            }
          } else {
            ctx.moveTo(x, y);
            const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
            const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerStartX, outerStartY);
            const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
            const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerEndX, outerEndY);
          }
          ctx.closePath();
        }
        function drawArc(ctx, element, offset, spacing, circular) {
          const { fullCircles, startAngle, circumference } = element;
          let endAngle = element.endAngle;
          if (fullCircles) {
            pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);
            for (let i = 0; i < fullCircles; ++i) {
              ctx.fill();
            }
            if (!isNaN(circumference)) {
              endAngle = startAngle + circumference % TAU;
              if (circumference % TAU === 0) {
                endAngle += TAU;
              }
            }
          }
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          ctx.fill();
          return endAngle;
        }
        function drawFullCircleBorders(ctx, element, inner) {
          const { x, y, startAngle, pixelMargin, fullCircles } = element;
          const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
          const innerRadius = element.innerRadius + pixelMargin;
          let i;
          if (inner) {
            clipArc(ctx, element, startAngle + TAU);
          }
          ctx.beginPath();
          ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
          for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
          for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
          }
        }
        function drawBorder(ctx, element, offset, spacing, endAngle, circular) {
          const { options } = element;
          const { borderWidth, borderJoinStyle } = options;
          const inner = options.borderAlign === "inner";
          if (!borderWidth) {
            return;
          }
          if (inner) {
            ctx.lineWidth = borderWidth * 2;
            ctx.lineJoin = borderJoinStyle || "round";
          } else {
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = borderJoinStyle || "bevel";
          }
          if (element.fullCircles) {
            drawFullCircleBorders(ctx, element, inner);
          }
          if (inner) {
            clipArc(ctx, element, endAngle);
          }
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          ctx.stroke();
        }
        class ArcElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.circumference = void 0;
            this.startAngle = void 0;
            this.endAngle = void 0;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.pixelMargin = 0;
            this.fullCircles = 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(chartX, chartY, useFinalPosition) {
            const point = this.getProps(["x", "y"], useFinalPosition);
            const { angle, distance: distance2 } = getAngleFromPoint(point, { x: chartX, y: chartY });
            const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "circumference"
            ], useFinalPosition);
            const rAdjust = this.options.spacing / 2;
            const _circumference = valueOrDefault(circumference, endAngle - startAngle);
            const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
            const withinRadius = _isBetween(distance2, innerRadius + rAdjust, outerRadius + rAdjust);
            return betweenAngles && withinRadius;
          }
          getCenterPoint(useFinalPosition) {
            const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
              "x",
              "y",
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "circumference"
            ], useFinalPosition);
            const { offset, spacing } = this.options;
            const halfAngle = (startAngle + endAngle) / 2;
            const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
            return {
              x: x + Math.cos(halfAngle) * halfRadius,
              y: y + Math.sin(halfAngle) * halfRadius
            };
          }
          tooltipPosition(useFinalPosition) {
            return this.getCenterPoint(useFinalPosition);
          }
          draw(ctx) {
            const { options, circumference } = this;
            const offset = (options.offset || 0) / 2;
            const spacing = (options.spacing || 0) / 2;
            const circular = options.circular;
            this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
            this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
            if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
              return;
            }
            ctx.save();
            let radiusOffset = 0;
            if (offset) {
              radiusOffset = offset / 2;
              const halfAngle = (this.startAngle + this.endAngle) / 2;
              ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
              if (this.circumference >= PI) {
                radiusOffset = offset;
              }
            }
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
            drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
            ctx.restore();
          }
        }
        ArcElement.id = "arc";
        ArcElement.defaults = {
          borderAlign: "center",
          borderColor: "#fff",
          borderJoinStyle: void 0,
          borderRadius: 0,
          borderWidth: 2,
          offset: 0,
          spacing: 0,
          angle: void 0,
          circular: true
        };
        ArcElement.defaultRoutes = {
          backgroundColor: "backgroundColor"
        };
        function setStyle(ctx, options, style = options) {
          ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
          ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
          ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
          ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
          ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
          ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
        }
        function lineTo(ctx, previous, target) {
          ctx.lineTo(target.x, target.y);
        }
        function getLineMethod(options) {
          if (options.stepped) {
            return _steppedLineTo;
          }
          if (options.tension || options.cubicInterpolationMode === "monotone") {
            return _bezierCurveTo;
          }
          return lineTo;
        }
        function pathVars(points, segment, params = {}) {
          const count = points.length;
          const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
          const { start: segmentStart, end: segmentEnd } = segment;
          const start = Math.max(paramsStart, segmentStart);
          const end = Math.min(paramsEnd, segmentEnd);
          const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
          return {
            count,
            start,
            loop: segment.loop,
            ilen: end < start && !outside ? count + end - start : end - start
          };
        }
        function pathSegment(ctx, line, segment, params) {
          const { points, options } = line;
          const { count, start, loop, ilen } = pathVars(points, segment, params);
          const lineMethod = getLineMethod(options);
          let { move: move2 = true, reverse } = params || {};
          let i, point, prev;
          for (i = 0; i <= ilen; ++i) {
            point = points[(start + (reverse ? ilen - i : i)) % count];
            if (point.skip) {
              continue;
            } else if (move2) {
              ctx.moveTo(point.x, point.y);
              move2 = false;
            } else {
              lineMethod(ctx, prev, point, reverse, options.stepped);
            }
            prev = point;
          }
          if (loop) {
            point = points[(start + (reverse ? ilen : 0)) % count];
            lineMethod(ctx, prev, point, reverse, options.stepped);
          }
          return !!loop;
        }
        function fastPathSegment(ctx, line, segment, params) {
          const points = line.points;
          const { count, start, ilen } = pathVars(points, segment, params);
          const { move: move2 = true, reverse } = params || {};
          let avgX = 0;
          let countX = 0;
          let i, point, prevX, minY, maxY, lastY;
          const pointIndex = (index3) => (start + (reverse ? ilen - index3 : index3)) % count;
          const drawX = () => {
            if (minY !== maxY) {
              ctx.lineTo(avgX, maxY);
              ctx.lineTo(avgX, minY);
              ctx.lineTo(avgX, lastY);
            }
          };
          if (move2) {
            point = points[pointIndex(0)];
            ctx.moveTo(point.x, point.y);
          }
          for (i = 0; i <= ilen; ++i) {
            point = points[pointIndex(i)];
            if (point.skip) {
              continue;
            }
            const x = point.x;
            const y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y < minY) {
                minY = y;
              } else if (y > maxY) {
                maxY = y;
              }
              avgX = (countX * avgX + x) / ++countX;
            } else {
              drawX();
              ctx.lineTo(x, y);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
            }
            lastY = y;
          }
          drawX();
        }
        function _getSegmentMethod(line) {
          const opts = line.options;
          const borderDash = opts.borderDash && opts.borderDash.length;
          const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
          return useFastPath ? fastPathSegment : pathSegment;
        }
        function _getInterpolationMethod(options) {
          if (options.stepped) {
            return _steppedInterpolation;
          }
          if (options.tension || options.cubicInterpolationMode === "monotone") {
            return _bezierInterpolation;
          }
          return _pointInLine;
        }
        function strokePathWithCache(ctx, line, start, count) {
          let path = line._path;
          if (!path) {
            path = line._path = new Path2D();
            if (line.path(path, start, count)) {
              path.closePath();
            }
          }
          setStyle(ctx, line.options);
          ctx.stroke(path);
        }
        function strokePathDirect(ctx, line, start, count) {
          const { segments, options } = line;
          const segmentMethod = _getSegmentMethod(line);
          for (const segment of segments) {
            setStyle(ctx, options, segment.style);
            ctx.beginPath();
            if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
              ctx.closePath();
            }
            ctx.stroke();
          }
        }
        const usePath2D = typeof Path2D === "function";
        function draw(ctx, line, start, count) {
          if (usePath2D && !line.options.segment) {
            strokePathWithCache(ctx, line, start, count);
          } else {
            strokePathDirect(ctx, line, start, count);
          }
        }
        class LineElement extends Element2 {
          constructor(cfg) {
            super();
            this.animated = true;
            this.options = void 0;
            this._chart = void 0;
            this._loop = void 0;
            this._fullLoop = void 0;
            this._path = void 0;
            this._points = void 0;
            this._segments = void 0;
            this._decimated = false;
            this._pointsUpdated = false;
            this._datasetIndex = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          updateControlPoints(chartArea, indexAxis) {
            const options = this.options;
            if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
              const loop = options.spanGaps ? this._loop : this._fullLoop;
              _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
              this._pointsUpdated = true;
            }
          }
          set points(points) {
            this._points = points;
            delete this._segments;
            delete this._path;
            this._pointsUpdated = false;
          }
          get points() {
            return this._points;
          }
          get segments() {
            return this._segments || (this._segments = _computeSegments(this, this.options.segment));
          }
          first() {
            const segments = this.segments;
            const points = this.points;
            return segments.length && points[segments[0].start];
          }
          last() {
            const segments = this.segments;
            const points = this.points;
            const count = segments.length;
            return count && points[segments[count - 1].end];
          }
          interpolate(point, property) {
            const options = this.options;
            const value = point[property];
            const points = this.points;
            const segments = _boundSegments(this, { property, start: value, end: value });
            if (!segments.length) {
              return;
            }
            const result = [];
            const _interpolate = _getInterpolationMethod(options);
            let i, ilen;
            for (i = 0, ilen = segments.length; i < ilen; ++i) {
              const { start, end } = segments[i];
              const p1 = points[start];
              const p2 = points[end];
              if (p1 === p2) {
                result.push(p1);
                continue;
              }
              const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
              const interpolated = _interpolate(p1, p2, t, options.stepped);
              interpolated[property] = point[property];
              result.push(interpolated);
            }
            return result.length === 1 ? result[0] : result;
          }
          pathSegment(ctx, segment, params) {
            const segmentMethod = _getSegmentMethod(this);
            return segmentMethod(ctx, this, segment, params);
          }
          path(ctx, start, count) {
            const segments = this.segments;
            const segmentMethod = _getSegmentMethod(this);
            let loop = this._loop;
            start = start || 0;
            count = count || this.points.length - start;
            for (const segment of segments) {
              loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
            }
            return !!loop;
          }
          draw(ctx, chartArea, start, count) {
            const options = this.options || {};
            const points = this.points || [];
            if (points.length && options.borderWidth) {
              ctx.save();
              draw(ctx, this, start, count);
              ctx.restore();
            }
            if (this.animated) {
              this._pointsUpdated = false;
              this._path = void 0;
            }
          }
        }
        LineElement.id = "line";
        LineElement.defaults = {
          borderCapStyle: "butt",
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: "miter",
          borderWidth: 3,
          capBezierPoints: true,
          cubicInterpolationMode: "default",
          fill: false,
          spanGaps: false,
          stepped: false,
          tension: 0
        };
        LineElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        LineElement.descriptors = {
          _scriptable: true,
          _indexable: (name) => name !== "borderDash" && name !== "fill"
        };
        function inRange$1(el, pos, axis, useFinalPosition) {
          const options = el.options;
          const { [axis]: value } = el.getProps([axis], useFinalPosition);
          return Math.abs(pos - value) < options.radius + options.hitRadius;
        }
        class PointElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.parsed = void 0;
            this.skip = void 0;
            this.stop = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            const options = this.options;
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange$1(this, mouseX, "x", useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange$1(this, mouseY, "y", useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return { x, y };
          }
          size(options) {
            options = options || this.options || {};
            let radius = options.radius || 0;
            radius = Math.max(radius, radius && options.hoverRadius || 0);
            const borderWidth = radius && options.borderWidth || 0;
            return (radius + borderWidth) * 2;
          }
          draw(ctx, area) {
            const options = this.options;
            if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
              return;
            }
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.fillStyle = options.backgroundColor;
            drawPoint(ctx, options, this.x, this.y);
          }
          getRange() {
            const options = this.options || {};
            return options.radius + options.hitRadius;
          }
        }
        PointElement.id = "point";
        PointElement.defaults = {
          borderWidth: 1,
          hitRadius: 1,
          hoverBorderWidth: 1,
          hoverRadius: 4,
          pointStyle: "circle",
          radius: 3,
          rotation: 0
        };
        PointElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        function getBarBounds(bar, useFinalPosition) {
          const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
          let left, right, top, bottom, half;
          if (bar.horizontal) {
            half = height / 2;
            left = Math.min(x, base);
            right = Math.max(x, base);
            top = y - half;
            bottom = y + half;
          } else {
            half = width / 2;
            left = x - half;
            right = x + half;
            top = Math.min(y, base);
            bottom = Math.max(y, base);
          }
          return { left, top, right, bottom };
        }
        function skipOrLimit(skip2, value, min, max) {
          return skip2 ? 0 : _limitValue(value, min, max);
        }
        function parseBorderWidth(bar, maxW, maxH) {
          const value = bar.options.borderWidth;
          const skip2 = bar.borderSkipped;
          const o = toTRBL(value);
          return {
            t: skipOrLimit(skip2.top, o.top, 0, maxH),
            r: skipOrLimit(skip2.right, o.right, 0, maxW),
            b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
            l: skipOrLimit(skip2.left, o.left, 0, maxW)
          };
        }
        function parseBorderRadius(bar, maxW, maxH) {
          const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
          const value = bar.options.borderRadius;
          const o = toTRBLCorners(value);
          const maxR = Math.min(maxW, maxH);
          const skip2 = bar.borderSkipped;
          const enableBorder = enableBorderRadius || isObject2(value);
          return {
            topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
            topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
            bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
            bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
          };
        }
        function boundingRects(bar) {
          const bounds = getBarBounds(bar);
          const width = bounds.right - bounds.left;
          const height = bounds.bottom - bounds.top;
          const border = parseBorderWidth(bar, width / 2, height / 2);
          const radius = parseBorderRadius(bar, width / 2, height / 2);
          return {
            outer: {
              x: bounds.left,
              y: bounds.top,
              w: width,
              h: height,
              radius
            },
            inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width - border.l - border.r,
              h: height - border.t - border.b,
              radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
              }
            }
          };
        }
        function inRange(bar, x, y, useFinalPosition) {
          const skipX = x === null;
          const skipY = y === null;
          const skipBoth = skipX && skipY;
          const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
          return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
        }
        function hasRadius(radius) {
          return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
        }
        function addNormalRectPath(ctx, rect) {
          ctx.rect(rect.x, rect.y, rect.w, rect.h);
        }
        function inflateRect(rect, amount, refRect = {}) {
          const x = rect.x !== refRect.x ? -amount : 0;
          const y = rect.y !== refRect.y ? -amount : 0;
          const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
          const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
          return {
            x: rect.x + x,
            y: rect.y + y,
            w: rect.w + w,
            h: rect.h + h,
            radius: rect.radius
          };
        }
        class BarElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.horizontal = void 0;
            this.base = void 0;
            this.width = void 0;
            this.height = void 0;
            this.inflateAmount = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          draw(ctx) {
            const { inflateAmount, options: { borderColor, backgroundColor } } = this;
            const { inner, outer } = boundingRects(this);
            const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
            ctx.save();
            if (outer.w !== inner.w || outer.h !== inner.h) {
              ctx.beginPath();
              addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
              ctx.clip();
              addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
              ctx.fillStyle = borderColor;
              ctx.fill("evenodd");
            }
            ctx.beginPath();
            addRectPath(ctx, inflateRect(inner, inflateAmount));
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            return inRange(this, mouseX, mouseY, useFinalPosition);
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange(this, mouseX, null, useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange(this, null, mouseY, useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
            return {
              x: horizontal ? (x + base) / 2 : x,
              y: horizontal ? y : (y + base) / 2
            };
          }
          getRange(axis) {
            return axis === "x" ? this.width / 2 : this.height / 2;
          }
        }
        BarElement.id = "bar";
        BarElement.defaults = {
          borderSkipped: "start",
          borderWidth: 0,
          borderRadius: 0,
          inflateAmount: "auto",
          pointStyle: void 0
        };
        BarElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        var elements = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          ArcElement,
          LineElement,
          PointElement,
          BarElement
        });
        function lttbDecimation(data, start, count, availableWidth, options) {
          const samples = options.samples || availableWidth;
          if (samples >= count) {
            return data.slice(start, start + count);
          }
          const decimated = [];
          const bucketWidth = (count - 2) / (samples - 2);
          let sampledIndex = 0;
          const endIndex = start + count - 1;
          let a = start;
          let i, maxAreaPoint, maxArea, area, nextA;
          decimated[sampledIndex++] = data[a];
          for (i = 0; i < samples - 2; i++) {
            let avgX = 0;
            let avgY = 0;
            let j;
            const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
            const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
            const avgRangeLength = avgRangeEnd - avgRangeStart;
            for (j = avgRangeStart; j < avgRangeEnd; j++) {
              avgX += data[j].x;
              avgY += data[j].y;
            }
            avgX /= avgRangeLength;
            avgY /= avgRangeLength;
            const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
            const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
            const { x: pointAx, y: pointAy } = data[a];
            maxArea = area = -1;
            for (j = rangeOffs; j < rangeTo; j++) {
              area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
              if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j];
                nextA = j;
              }
            }
            decimated[sampledIndex++] = maxAreaPoint;
            a = nextA;
          }
          decimated[sampledIndex++] = data[endIndex];
          return decimated;
        }
        function minMaxDecimation(data, start, count, availableWidth) {
          let avgX = 0;
          let countX = 0;
          let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
          const decimated = [];
          const endIndex = start + count - 1;
          const xMin = data[start].x;
          const xMax = data[endIndex].x;
          const dx = xMax - xMin;
          for (i = start; i < start + count; ++i) {
            point = data[i];
            x = (point.x - xMin) / dx * availableWidth;
            y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y < minY) {
                minY = y;
                minIndex = i;
              } else if (y > maxY) {
                maxY = y;
                maxIndex = i;
              }
              avgX = (countX * avgX + point.x) / ++countX;
            } else {
              const lastIndex = i - 1;
              if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
                const intermediateIndex1 = Math.min(minIndex, maxIndex);
                const intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                  decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
                    x: avgX
                  }));
                }
                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                  decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
                    x: avgX
                  }));
                }
              }
              if (i > 0 && lastIndex !== startIndex) {
                decimated.push(data[lastIndex]);
              }
              decimated.push(point);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
              minIndex = maxIndex = startIndex = i;
            }
          }
          return decimated;
        }
        function cleanDecimatedDataset(dataset) {
          if (dataset._decimated) {
            const data = dataset._data;
            delete dataset._decimated;
            delete dataset._data;
            Object.defineProperty(dataset, "data", { value: data });
          }
        }
        function cleanDecimatedData(chart2) {
          chart2.data.datasets.forEach((dataset) => {
            cleanDecimatedDataset(dataset);
          });
        }
        function getStartAndCountOfVisiblePointsSimplified(meta, points) {
          const pointCount = points.length;
          let start = 0;
          let count;
          const { iScale } = meta;
          const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
          if (minDefined) {
            start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
          }
          if (maxDefined) {
            count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
          } else {
            count = pointCount - start;
          }
          return { start, count };
        }
        var plugin_decimation = {
          id: "decimation",
          defaults: {
            algorithm: "min-max",
            enabled: false
          },
          beforeElementsUpdate: (chart2, args, options) => {
            if (!options.enabled) {
              cleanDecimatedData(chart2);
              return;
            }
            const availableWidth = chart2.width;
            chart2.data.datasets.forEach((dataset, datasetIndex) => {
              const { _data, indexAxis } = dataset;
              const meta = chart2.getDatasetMeta(datasetIndex);
              const data = _data || dataset.data;
              if (resolve([indexAxis, chart2.options.indexAxis]) === "y") {
                return;
              }
              if (!meta.controller.supportsDecimation) {
                return;
              }
              const xAxis = chart2.scales[meta.xAxisID];
              if (xAxis.type !== "linear" && xAxis.type !== "time") {
                return;
              }
              if (chart2.options.parsing) {
                return;
              }
              let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
              const threshold = options.threshold || 4 * availableWidth;
              if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
              }
              if (isNullOrUndef(_data)) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, "data", {
                  configurable: true,
                  enumerable: true,
                  get: function() {
                    return this._decimated;
                  },
                  set: function(d) {
                    this._data = d;
                  }
                });
              }
              let decimated;
              switch (options.algorithm) {
                case "lttb":
                  decimated = lttbDecimation(data, start, count, availableWidth, options);
                  break;
                case "min-max":
                  decimated = minMaxDecimation(data, start, count, availableWidth);
                  break;
                default:
                  throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
              }
              dataset._decimated = decimated;
            });
          },
          destroy(chart2) {
            cleanDecimatedData(chart2);
          }
        };
        function _segments(line, target, property) {
          const segments = line.segments;
          const points = line.points;
          const tpoints = target.points;
          const parts = [];
          for (const segment of segments) {
            let { start, end } = segment;
            end = _findSegmentEnd(start, end, points);
            const bounds = _getBounds(property, points[start], points[end], segment.loop);
            if (!target.segments) {
              parts.push({
                source: segment,
                target: bounds,
                start: points[start],
                end: points[end]
              });
              continue;
            }
            const targetSegments = _boundSegments(target, bounds);
            for (const tgt of targetSegments) {
              const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
              const fillSources = _boundSegment(segment, points, subBounds);
              for (const fillSource of fillSources) {
                parts.push({
                  source: fillSource,
                  target: tgt,
                  start: {
                    [property]: _getEdge(bounds, subBounds, "start", Math.max)
                  },
                  end: {
                    [property]: _getEdge(bounds, subBounds, "end", Math.min)
                  }
                });
              }
            }
          }
          return parts;
        }
        function _getBounds(property, first, last, loop) {
          if (loop) {
            return;
          }
          let start = first[property];
          let end = last[property];
          if (property === "angle") {
            start = _normalizeAngle(start);
            end = _normalizeAngle(end);
          }
          return { property, start, end };
        }
        function _pointsFromSegments(boundary, line) {
          const { x = null, y = null } = boundary || {};
          const linePoints = line.points;
          const points = [];
          line.segments.forEach(({ start, end }) => {
            end = _findSegmentEnd(start, end, linePoints);
            const first = linePoints[start];
            const last = linePoints[end];
            if (y !== null) {
              points.push({ x: first.x, y });
              points.push({ x: last.x, y });
            } else if (x !== null) {
              points.push({ x, y: first.y });
              points.push({ x, y: last.y });
            }
          });
          return points;
        }
        function _findSegmentEnd(start, end, points) {
          for (; end > start; end--) {
            const point = points[end];
            if (!isNaN(point.x) && !isNaN(point.y)) {
              break;
            }
          }
          return end;
        }
        function _getEdge(a, b, prop, fn) {
          if (a && b) {
            return fn(a[prop], b[prop]);
          }
          return a ? a[prop] : b ? b[prop] : 0;
        }
        function _createBoundaryLine(boundary, line) {
          let points = [];
          let _loop = false;
          if (isArray(boundary)) {
            _loop = true;
            points = boundary;
          } else {
            points = _pointsFromSegments(boundary, line);
          }
          return points.length ? new LineElement({
            points,
            options: { tension: 0 },
            _loop,
            _fullLoop: _loop
          }) : null;
        }
        function _shouldApplyFill(source) {
          return source && source.fill !== false;
        }
        function _resolveTarget(sources, index3, propagate) {
          const source = sources[index3];
          let fill2 = source.fill;
          const visited = [index3];
          let target;
          if (!propagate) {
            return fill2;
          }
          while (fill2 !== false && visited.indexOf(fill2) === -1) {
            if (!isNumberFinite(fill2)) {
              return fill2;
            }
            target = sources[fill2];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill2;
            }
            visited.push(fill2);
            fill2 = target.fill;
          }
          return false;
        }
        function _decodeFill(line, index3, count) {
          const fill2 = parseFillOption(line);
          if (isObject2(fill2)) {
            return isNaN(fill2.value) ? false : fill2;
          }
          let target = parseFloat(fill2);
          if (isNumberFinite(target) && Math.floor(target) === target) {
            return decodeTargetIndex(fill2[0], index3, target, count);
          }
          return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
        }
        function decodeTargetIndex(firstCh, index3, target, count) {
          if (firstCh === "-" || firstCh === "+") {
            target = index3 + target;
          }
          if (target === index3 || target < 0 || target >= count) {
            return false;
          }
          return target;
        }
        function _getTargetPixel(fill2, scale) {
          let pixel = null;
          if (fill2 === "start") {
            pixel = scale.bottom;
          } else if (fill2 === "end") {
            pixel = scale.top;
          } else if (isObject2(fill2)) {
            pixel = scale.getPixelForValue(fill2.value);
          } else if (scale.getBasePixel) {
            pixel = scale.getBasePixel();
          }
          return pixel;
        }
        function _getTargetValue(fill2, scale, startValue) {
          let value;
          if (fill2 === "start") {
            value = startValue;
          } else if (fill2 === "end") {
            value = scale.options.reverse ? scale.min : scale.max;
          } else if (isObject2(fill2)) {
            value = fill2.value;
          } else {
            value = scale.getBaseValue();
          }
          return value;
        }
        function parseFillOption(line) {
          const options = line.options;
          const fillOption = options.fill;
          let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
          if (fill2 === void 0) {
            fill2 = !!options.backgroundColor;
          }
          if (fill2 === false || fill2 === null) {
            return false;
          }
          if (fill2 === true) {
            return "origin";
          }
          return fill2;
        }
        function _buildStackLine(source) {
          const { scale, index: index3, line } = source;
          const points = [];
          const segments = line.segments;
          const sourcePoints = line.points;
          const linesBelow = getLinesBelow(scale, index3);
          linesBelow.push(_createBoundaryLine({ x: null, y: scale.bottom }, line));
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            for (let j = segment.start; j <= segment.end; j++) {
              addPointsBelow(points, sourcePoints[j], linesBelow);
            }
          }
          return new LineElement({ points, options: {} });
        }
        function getLinesBelow(scale, index3) {
          const below = [];
          const metas = scale.getMatchingVisibleMetas("line");
          for (let i = 0; i < metas.length; i++) {
            const meta = metas[i];
            if (meta.index === index3) {
              break;
            }
            if (!meta.hidden) {
              below.unshift(meta.dataset);
            }
          }
          return below;
        }
        function addPointsBelow(points, sourcePoint, linesBelow) {
          const postponed = [];
          for (let j = 0; j < linesBelow.length; j++) {
            const line = linesBelow[j];
            const { first, last, point } = findPoint(line, sourcePoint, "x");
            if (!point || first && last) {
              continue;
            }
            if (first) {
              postponed.unshift(point);
            } else {
              points.push(point);
              if (!last) {
                break;
              }
            }
          }
          points.push(...postponed);
        }
        function findPoint(line, sourcePoint, property) {
          const point = line.interpolate(sourcePoint, property);
          if (!point) {
            return {};
          }
          const pointValue = point[property];
          const segments = line.segments;
          const linePoints = line.points;
          let first = false;
          let last = false;
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            const firstValue = linePoints[segment.start][property];
            const lastValue = linePoints[segment.end][property];
            if (_isBetween(pointValue, firstValue, lastValue)) {
              first = pointValue === firstValue;
              last = pointValue === lastValue;
              break;
            }
          }
          return { first, last, point };
        }
        class simpleArc {
          constructor(opts) {
            this.x = opts.x;
            this.y = opts.y;
            this.radius = opts.radius;
          }
          pathSegment(ctx, bounds, opts) {
            const { x, y, radius } = this;
            bounds = bounds || { start: 0, end: TAU };
            ctx.arc(x, y, radius, bounds.end, bounds.start, true);
            return !opts.bounds;
          }
          interpolate(point) {
            const { x, y, radius } = this;
            const angle = point.angle;
            return {
              x: x + Math.cos(angle) * radius,
              y: y + Math.sin(angle) * radius,
              angle
            };
          }
        }
        function _getTarget(source) {
          const { chart: chart2, fill: fill2, line } = source;
          if (isNumberFinite(fill2)) {
            return getLineByIndex(chart2, fill2);
          }
          if (fill2 === "stack") {
            return _buildStackLine(source);
          }
          if (fill2 === "shape") {
            return true;
          }
          const boundary = computeBoundary(source);
          if (boundary instanceof simpleArc) {
            return boundary;
          }
          return _createBoundaryLine(boundary, line);
        }
        function getLineByIndex(chart2, index3) {
          const meta = chart2.getDatasetMeta(index3);
          const visible = meta && chart2.isDatasetVisible(index3);
          return visible ? meta.dataset : null;
        }
        function computeBoundary(source) {
          const scale = source.scale || {};
          if (scale.getPointPositionForValue) {
            return computeCircularBoundary(source);
          }
          return computeLinearBoundary(source);
        }
        function computeLinearBoundary(source) {
          const { scale = {}, fill: fill2 } = source;
          const pixel = _getTargetPixel(fill2, scale);
          if (isNumberFinite(pixel)) {
            const horizontal = scale.isHorizontal();
            return {
              x: horizontal ? pixel : null,
              y: horizontal ? null : pixel
            };
          }
          return null;
        }
        function computeCircularBoundary(source) {
          const { scale, fill: fill2 } = source;
          const options = scale.options;
          const length = scale.getLabels().length;
          const start = options.reverse ? scale.max : scale.min;
          const value = _getTargetValue(fill2, scale, start);
          const target = [];
          if (options.grid.circular) {
            const center = scale.getPointPositionForValue(0, start);
            return new simpleArc({
              x: center.x,
              y: center.y,
              radius: scale.getDistanceFromCenterForValue(value)
            });
          }
          for (let i = 0; i < length; ++i) {
            target.push(scale.getPointPositionForValue(i, value));
          }
          return target;
        }
        function _drawfill(ctx, source, area) {
          const target = _getTarget(source);
          const { line, scale, axis } = source;
          const lineOpts = line.options;
          const fillOption = lineOpts.fill;
          const color2 = lineOpts.backgroundColor;
          const { above = color2, below = color2 } = fillOption || {};
          if (target && line.points.length) {
            clipArea(ctx, area);
            doFill(ctx, { line, target, above, below, area, scale, axis });
            unclipArea(ctx);
          }
        }
        function doFill(ctx, cfg) {
          const { line, target, above, below, area, scale } = cfg;
          const property = line._loop ? "angle" : cfg.axis;
          ctx.save();
          if (property === "x" && below !== above) {
            clipVertical(ctx, target, area.top);
            fill(ctx, { line, target, color: above, scale, property });
            ctx.restore();
            ctx.save();
            clipVertical(ctx, target, area.bottom);
          }
          fill(ctx, { line, target, color: below, scale, property });
          ctx.restore();
        }
        function clipVertical(ctx, target, clipY) {
          const { segments, points } = target;
          let first = true;
          let lineLoop = false;
          ctx.beginPath();
          for (const segment of segments) {
            const { start, end } = segment;
            const firstPoint = points[start];
            const lastPoint = points[_findSegmentEnd(start, end, points)];
            if (first) {
              ctx.moveTo(firstPoint.x, firstPoint.y);
              first = false;
            } else {
              ctx.lineTo(firstPoint.x, clipY);
              ctx.lineTo(firstPoint.x, firstPoint.y);
            }
            lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
            if (lineLoop) {
              ctx.closePath();
            } else {
              ctx.lineTo(lastPoint.x, clipY);
            }
          }
          ctx.lineTo(target.first().x, clipY);
          ctx.closePath();
          ctx.clip();
        }
        function fill(ctx, cfg) {
          const { line, target, property, color: color2, scale } = cfg;
          const segments = _segments(line, target, property);
          for (const { source: src, target: tgt, start, end } of segments) {
            const { style: { backgroundColor = color2 } = {} } = src;
            const notShape = target !== true;
            ctx.save();
            ctx.fillStyle = backgroundColor;
            clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
            ctx.beginPath();
            const lineLoop = !!line.pathSegment(ctx, src);
            let loop;
            if (notShape) {
              if (lineLoop) {
                ctx.closePath();
              } else {
                interpolatedLineTo(ctx, target, end, property);
              }
              const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
              loop = lineLoop && targetLoop;
              if (!loop) {
                interpolatedLineTo(ctx, target, start, property);
              }
            }
            ctx.closePath();
            ctx.fill(loop ? "evenodd" : "nonzero");
            ctx.restore();
          }
        }
        function clipBounds(ctx, scale, bounds) {
          const { top, bottom } = scale.chart.chartArea;
          const { property, start, end } = bounds || {};
          if (property === "x") {
            ctx.beginPath();
            ctx.rect(start, top, end - start, bottom - top);
            ctx.clip();
          }
        }
        function interpolatedLineTo(ctx, target, point, property) {
          const interpolatedPoint = target.interpolate(point, property);
          if (interpolatedPoint) {
            ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
          }
        }
        var index2 = {
          id: "filler",
          afterDatasetsUpdate(chart2, _args, options) {
            const count = (chart2.data.datasets || []).length;
            const sources = [];
            let meta, i, line, source;
            for (i = 0; i < count; ++i) {
              meta = chart2.getDatasetMeta(i);
              line = meta.dataset;
              source = null;
              if (line && line.options && line instanceof LineElement) {
                source = {
                  visible: chart2.isDatasetVisible(i),
                  index: i,
                  fill: _decodeFill(line, i, count),
                  chart: chart2,
                  axis: meta.controller.options.indexAxis,
                  scale: meta.vScale,
                  line
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i = 0; i < count; ++i) {
              source = sources[i];
              if (!source || source.fill === false) {
                continue;
              }
              source.fill = _resolveTarget(sources, i, options.propagate);
            }
          },
          beforeDraw(chart2, _args, options) {
            const draw2 = options.drawTime === "beforeDraw";
            const metasets = chart2.getSortedVisibleDatasetMetas();
            const area = chart2.chartArea;
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (!source) {
                continue;
              }
              source.line.updateControlPoints(area, source.axis);
              if (draw2 && source.fill) {
                _drawfill(chart2.ctx, source, area);
              }
            }
          },
          beforeDatasetsDraw(chart2, _args, options) {
            if (options.drawTime !== "beforeDatasetsDraw") {
              return;
            }
            const metasets = chart2.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (_shouldApplyFill(source)) {
                _drawfill(chart2.ctx, source, chart2.chartArea);
              }
            }
          },
          beforeDatasetDraw(chart2, args, options) {
            const source = args.meta.$filler;
            if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
              return;
            }
            _drawfill(chart2.ctx, source, chart2.chartArea);
          },
          defaults: {
            propagate: true,
            drawTime: "beforeDatasetDraw"
          }
        };
        const getBoxSize = (labelOpts, fontSize) => {
          let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
          if (labelOpts.usePointStyle) {
            boxHeight = Math.min(boxHeight, fontSize);
            boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
          }
          return {
            boxWidth,
            boxHeight,
            itemHeight: Math.max(fontSize, boxHeight)
          };
        };
        const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
        class Legend extends Element2 {
          constructor(config) {
            super();
            this._added = false;
            this.legendHitBoxes = [];
            this._hoveredItem = null;
            this.doughnutMode = false;
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this.legendItems = void 0;
            this.columnSizes = void 0;
            this.lineWidths = void 0;
            this.maxHeight = void 0;
            this.maxWidth = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.height = void 0;
            this.width = void 0;
            this._margins = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
          }
          update(maxWidth, maxHeight, margins) {
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins;
            this.setDimensions();
            this.buildLabels();
            this.fit();
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = this._margins.left;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = this._margins.top;
              this.bottom = this.height;
            }
          }
          buildLabels() {
            const labelOpts = this.options.labels || {};
            let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
            if (labelOpts.filter) {
              legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
            }
            if (labelOpts.sort) {
              legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
            }
            if (this.options.reverse) {
              legendItems.reverse();
            }
            this.legendItems = legendItems;
          }
          fit() {
            const { options, ctx } = this;
            if (!options.display) {
              this.width = this.height = 0;
              return;
            }
            const labelOpts = options.labels;
            const labelFont = toFont(labelOpts.font);
            const fontSize = labelFont.size;
            const titleHeight = this._computeTitleHeight();
            const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
            let width, height;
            ctx.font = labelFont.string;
            if (this.isHorizontal()) {
              width = this.maxWidth;
              height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            } else {
              height = this.maxHeight;
              width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            }
            this.width = Math.min(width, options.maxWidth || this.maxWidth);
            this.height = Math.min(height, options.maxHeight || this.maxHeight);
          }
          _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
            const { ctx, maxWidth, options: { labels: { padding } } } = this;
            const hitboxes = this.legendHitBoxes = [];
            const lineWidths = this.lineWidths = [0];
            const lineHeight = itemHeight + padding;
            let totalHeight = titleHeight;
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            let row = -1;
            let top = -lineHeight;
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
              if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
              }
              hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
              lineWidths[lineWidths.length - 1] += itemWidth + padding;
            });
            return totalHeight;
          }
          _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
            const { ctx, maxHeight, options: { labels: { padding } } } = this;
            const hitboxes = this.legendHitBoxes = [];
            const columnSizes = this.columnSizes = [];
            const heightLimit = maxHeight - titleHeight;
            let totalWidth = padding;
            let currentColWidth = 0;
            let currentColHeight = 0;
            let left = 0;
            let col = 0;
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
              if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({ width: currentColWidth, height: currentColHeight });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
              }
              hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight + padding;
            });
            totalWidth += currentColWidth;
            columnSizes.push({ width: currentColWidth, height: currentColHeight });
            return totalWidth;
          }
          adjustHitBoxes() {
            if (!this.options.display) {
              return;
            }
            const titleHeight = this._computeTitleHeight();
            const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
            const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
            if (this.isHorizontal()) {
              let row = 0;
              let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
              for (const hitbox of hitboxes) {
                if (row !== hitbox.row) {
                  row = hitbox.row;
                  left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                left += hitbox.width + padding;
              }
            } else {
              let col = 0;
              let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
              for (const hitbox of hitboxes) {
                if (hitbox.col !== col) {
                  col = hitbox.col;
                  top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                top += hitbox.height + padding;
              }
            }
          }
          isHorizontal() {
            return this.options.position === "top" || this.options.position === "bottom";
          }
          draw() {
            if (this.options.display) {
              const ctx = this.ctx;
              clipArea(ctx, this);
              this._draw();
              unclipArea(ctx);
            }
          }
          _draw() {
            const { options: opts, columnSizes, lineWidths, ctx } = this;
            const { align, labels: labelOpts } = opts;
            const defaultColor = defaults.color;
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const labelFont = toFont(labelOpts.font);
            const { color: fontColor, padding } = labelOpts;
            const fontSize = labelFont.size;
            const halfFontSize = fontSize / 2;
            let cursor;
            this.drawTitle();
            ctx.textAlign = rtlHelper.textAlign("left");
            ctx.textBaseline = "middle";
            ctx.lineWidth = 0.5;
            ctx.font = labelFont.string;
            const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
            const drawLegendBox = function(x, y, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
                return;
              }
              ctx.save();
              const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
              ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
              ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
              ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
              ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
              ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
              if (labelOpts.usePointStyle) {
                const drawOptions = {
                  radius: boxHeight * Math.SQRT2 / 2,
                  pointStyle: legendItem.pointStyle,
                  rotation: legendItem.rotation,
                  borderWidth: lineWidth
                };
                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                const centerY = y + halfFontSize;
                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
              } else {
                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                const borderRadius = toTRBLCorners(legendItem.borderRadius);
                ctx.beginPath();
                if (Object.values(borderRadius).some((v) => v !== 0)) {
                  addRoundedRectPath(ctx, {
                    x: xBoxLeft,
                    y: yBoxTop,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                  });
                } else {
                  ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                }
                ctx.fill();
                if (lineWidth !== 0) {
                  ctx.stroke();
                }
              }
              ctx.restore();
            };
            const fillText = function(x, y, legendItem) {
              renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                strikethrough: legendItem.hidden,
                textAlign: rtlHelper.textAlign(legendItem.textAlign)
              });
            };
            const isHorizontal = this.isHorizontal();
            const titleHeight = this._computeTitleHeight();
            if (isHorizontal) {
              cursor = {
                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                y: this.top + padding + titleHeight,
                line: 0
              };
            } else {
              cursor = {
                x: this.left + padding,
                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                line: 0
              };
            }
            overrideTextDirection(this.ctx, opts.textDirection);
            const lineHeight = itemHeight + padding;
            this.legendItems.forEach((legendItem, i) => {
              ctx.strokeStyle = legendItem.fontColor || fontColor;
              ctx.fillStyle = legendItem.fontColor || fontColor;
              const textWidth = ctx.measureText(legendItem.text).width;
              const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
              const width = boxWidth + halfFontSize + textWidth;
              let x = cursor.x;
              let y = cursor.y;
              rtlHelper.setWidth(this.width);
              if (isHorizontal) {
                if (i > 0 && x + width + padding > this.right) {
                  y = cursor.y += lineHeight;
                  cursor.line++;
                  x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
                }
              } else if (i > 0 && y + lineHeight > this.bottom) {
                x = cursor.x = x + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
              }
              const realX = rtlHelper.x(x);
              drawLegendBox(realX, y, legendItem);
              x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
              fillText(rtlHelper.x(x), y, legendItem);
              if (isHorizontal) {
                cursor.x += width + padding;
              } else {
                cursor.y += lineHeight;
              }
            });
            restoreTextDirection(this.ctx, opts.textDirection);
          }
          drawTitle() {
            const opts = this.options;
            const titleOpts = opts.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            if (!titleOpts.display) {
              return;
            }
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const ctx = this.ctx;
            const position = titleOpts.position;
            const halfFontSize = titleFont.size / 2;
            const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
            let y;
            let left = this.left;
            let maxWidth = this.width;
            if (this.isHorizontal()) {
              maxWidth = Math.max(...this.lineWidths);
              y = this.top + topPaddingPlusHalfFontSize;
              left = _alignStartEnd(opts.align, left, this.right - maxWidth);
            } else {
              const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
              y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
            }
            const x = _alignStartEnd(position, left, left + maxWidth);
            ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
            ctx.textBaseline = "middle";
            ctx.strokeStyle = titleOpts.color;
            ctx.fillStyle = titleOpts.color;
            ctx.font = titleFont.string;
            renderText(ctx, titleOpts.text, x, y, titleFont);
          }
          _computeTitleHeight() {
            const titleOpts = this.options.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
          }
          _getLegendItemAt(x, y) {
            let i, hitBox, lh;
            if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
              lh = this.legendHitBoxes;
              for (i = 0; i < lh.length; ++i) {
                hitBox = lh[i];
                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
                  return this.legendItems[i];
                }
              }
            }
            return null;
          }
          handleEvent(e) {
            const opts = this.options;
            if (!isListened(e.type, opts)) {
              return;
            }
            const hoveredItem = this._getLegendItemAt(e.x, e.y);
            if (e.type === "mousemove" || e.type === "mouseout") {
              const previous = this._hoveredItem;
              const sameItem = itemsEqual(previous, hoveredItem);
              if (previous && !sameItem) {
                callback(opts.onLeave, [e, previous, this], this);
              }
              this._hoveredItem = hoveredItem;
              if (hoveredItem && !sameItem) {
                callback(opts.onHover, [e, hoveredItem, this], this);
              }
            } else if (hoveredItem) {
              callback(opts.onClick, [e, hoveredItem, this], this);
            }
          }
        }
        function isListened(type, opts) {
          if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
            return true;
          }
          if (opts.onClick && (type === "click" || type === "mouseup")) {
            return true;
          }
          return false;
        }
        var plugin_legend = {
          id: "legend",
          _element: Legend,
          start(chart2, _args, options) {
            const legend = chart2.legend = new Legend({ ctx: chart2.ctx, options, chart: chart2 });
            layouts.configure(chart2, legend, options);
            layouts.addBox(chart2, legend);
          },
          stop(chart2) {
            layouts.removeBox(chart2, chart2.legend);
            delete chart2.legend;
          },
          beforeUpdate(chart2, _args, options) {
            const legend = chart2.legend;
            layouts.configure(chart2, legend, options);
            legend.options = options;
          },
          afterUpdate(chart2) {
            const legend = chart2.legend;
            legend.buildLabels();
            legend.adjustHitBoxes();
          },
          afterEvent(chart2, args) {
            if (!args.replay) {
              chart2.legend.handleEvent(args.event);
            }
          },
          defaults: {
            display: true,
            position: "top",
            align: "center",
            fullSize: true,
            reverse: false,
            weight: 1e3,
            onClick(e, legendItem, legend) {
              const index3 = legendItem.datasetIndex;
              const ci = legend.chart;
              if (ci.isDatasetVisible(index3)) {
                ci.hide(index3);
                legendItem.hidden = true;
              } else {
                ci.show(index3);
                legendItem.hidden = false;
              }
            },
            onHover: null,
            onLeave: null,
            labels: {
              color: (ctx) => ctx.chart.options.color,
              boxWidth: 40,
              padding: 10,
              generateLabels(chart2) {
                const datasets = chart2.data.datasets;
                const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart2.legend.options;
                return chart2._getSortedDatasetMetas().map((meta) => {
                  const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                  const borderWidth = toPadding(style.borderWidth);
                  return {
                    text: datasets[meta.index].label,
                    fillStyle: style.backgroundColor,
                    fontColor: color2,
                    hidden: !meta.visible,
                    lineCap: style.borderCapStyle,
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: (borderWidth.width + borderWidth.height) / 4,
                    strokeStyle: style.borderColor,
                    pointStyle: pointStyle || style.pointStyle,
                    rotation: style.rotation,
                    textAlign: textAlign || style.textAlign,
                    borderRadius: 0,
                    datasetIndex: meta.index
                  };
                }, this);
              }
            },
            title: {
              color: (ctx) => ctx.chart.options.color,
              display: false,
              position: "center",
              text: ""
            }
          },
          descriptors: {
            _scriptable: (name) => !name.startsWith("on"),
            labels: {
              _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
            }
          }
        };
        class Title extends Element2 {
          constructor(config) {
            super();
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this._padding = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
          }
          update(maxWidth, maxHeight) {
            const opts = this.options;
            this.left = 0;
            this.top = 0;
            if (!opts.display) {
              this.width = this.height = this.right = this.bottom = 0;
              return;
            }
            this.width = this.right = maxWidth;
            this.height = this.bottom = maxHeight;
            const lineCount = isArray(opts.text) ? opts.text.length : 1;
            this._padding = toPadding(opts.padding);
            const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
            if (this.isHorizontal()) {
              this.height = textSize;
            } else {
              this.width = textSize;
            }
          }
          isHorizontal() {
            const pos = this.options.position;
            return pos === "top" || pos === "bottom";
          }
          _drawArgs(offset) {
            const { top, left, bottom, right, options } = this;
            const align = options.align;
            let rotation = 0;
            let maxWidth, titleX, titleY;
            if (this.isHorizontal()) {
              titleX = _alignStartEnd(align, left, right);
              titleY = top + offset;
              maxWidth = right - left;
            } else {
              if (options.position === "left") {
                titleX = left + offset;
                titleY = _alignStartEnd(align, bottom, top);
                rotation = PI * -0.5;
              } else {
                titleX = right - offset;
                titleY = _alignStartEnd(align, top, bottom);
                rotation = PI * 0.5;
              }
              maxWidth = bottom - top;
            }
            return { titleX, titleY, maxWidth, rotation };
          }
          draw() {
            const ctx = this.ctx;
            const opts = this.options;
            if (!opts.display) {
              return;
            }
            const fontOpts = toFont(opts.font);
            const lineHeight = fontOpts.lineHeight;
            const offset = lineHeight / 2 + this._padding.top;
            const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
            renderText(ctx, opts.text, 0, 0, fontOpts, {
              color: opts.color,
              maxWidth,
              rotation,
              textAlign: _toLeftRightCenter(opts.align),
              textBaseline: "middle",
              translation: [titleX, titleY]
            });
          }
        }
        function createTitle(chart2, titleOpts) {
          const title = new Title({
            ctx: chart2.ctx,
            options: titleOpts,
            chart: chart2
          });
          layouts.configure(chart2, title, titleOpts);
          layouts.addBox(chart2, title);
          chart2.titleBlock = title;
        }
        var plugin_title = {
          id: "title",
          _element: Title,
          start(chart2, _args, options) {
            createTitle(chart2, options);
          },
          stop(chart2) {
            const titleBlock = chart2.titleBlock;
            layouts.removeBox(chart2, titleBlock);
            delete chart2.titleBlock;
          },
          beforeUpdate(chart2, _args, options) {
            const title = chart2.titleBlock;
            layouts.configure(chart2, title, options);
            title.options = options;
          },
          defaults: {
            align: "center",
            display: false,
            font: {
              weight: "bold"
            },
            fullSize: true,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
          },
          defaultRoutes: {
            color: "color"
          },
          descriptors: {
            _scriptable: true,
            _indexable: false
          }
        };
        const map = new WeakMap();
        var plugin_subtitle = {
          id: "subtitle",
          start(chart2, _args, options) {
            const title = new Title({
              ctx: chart2.ctx,
              options,
              chart: chart2
            });
            layouts.configure(chart2, title, options);
            layouts.addBox(chart2, title);
            map.set(chart2, title);
          },
          stop(chart2) {
            layouts.removeBox(chart2, map.get(chart2));
            map.delete(chart2);
          },
          beforeUpdate(chart2, _args, options) {
            const title = map.get(chart2);
            layouts.configure(chart2, title, options);
            title.options = options;
          },
          defaults: {
            align: "center",
            display: false,
            font: {
              weight: "normal"
            },
            fullSize: true,
            padding: 0,
            position: "top",
            text: "",
            weight: 1500
          },
          defaultRoutes: {
            color: "color"
          },
          descriptors: {
            _scriptable: true,
            _indexable: false
          }
        };
        const positioners = {
          average(items) {
            if (!items.length) {
              return false;
            }
            let i, len;
            let x = 0;
            let y = 0;
            let count = 0;
            for (i = 0, len = items.length; i < len; ++i) {
              const el = items[i].element;
              if (el && el.hasValue()) {
                const pos = el.tooltipPosition();
                x += pos.x;
                y += pos.y;
                ++count;
              }
            }
            return {
              x: x / count,
              y: y / count
            };
          },
          nearest(items, eventPosition) {
            if (!items.length) {
              return false;
            }
            let x = eventPosition.x;
            let y = eventPosition.y;
            let minDistance = Number.POSITIVE_INFINITY;
            let i, len, nearestElement;
            for (i = 0, len = items.length; i < len; ++i) {
              const el = items[i].element;
              if (el && el.hasValue()) {
                const center = el.getCenterPoint();
                const d = distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                  minDistance = d;
                  nearestElement = el;
                }
              }
            }
            if (nearestElement) {
              const tp = nearestElement.tooltipPosition();
              x = tp.x;
              y = tp.y;
            }
            return {
              x,
              y
            };
          }
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (isArray(toPush)) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function splitNewlines(str) {
          if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
            return str.split("\n");
          }
          return str;
        }
        function createTooltipItem(chart2, item) {
          const { element, datasetIndex, index: index3 } = item;
          const controller = chart2.getDatasetMeta(datasetIndex).controller;
          const { label, value } = controller.getLabelAndValue(index3);
          return {
            chart: chart2,
            label,
            parsed: controller.getParsed(index3),
            raw: chart2.data.datasets[datasetIndex].data[index3],
            formattedValue: value,
            dataset: controller.getDataset(),
            dataIndex: index3,
            datasetIndex,
            element
          };
        }
        function getTooltipSize(tooltip, options) {
          const ctx = tooltip.chart.ctx;
          const { body, footer, title } = tooltip;
          const { boxWidth, boxHeight } = options;
          const bodyFont = toFont(options.bodyFont);
          const titleFont = toFont(options.titleFont);
          const footerFont = toFont(options.footerFont);
          const titleLineCount = title.length;
          const footerLineCount = footer.length;
          const bodyLineItemCount = body.length;
          const padding = toPadding(options.padding);
          let height = padding.height;
          let width = 0;
          let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
          combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
          if (titleLineCount) {
            height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
          }
          if (combinedBodyLength) {
            const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
            height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
          }
          if (footerLineCount) {
            height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
          }
          let widthPadding = 0;
          const maxLineWidth = function(line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
          };
          ctx.save();
          ctx.font = titleFont.string;
          each(tooltip.title, maxLineWidth);
          ctx.font = bodyFont.string;
          each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
          widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
          each(body, (bodyItem) => {
            each(bodyItem.before, maxLineWidth);
            each(bodyItem.lines, maxLineWidth);
            each(bodyItem.after, maxLineWidth);
          });
          widthPadding = 0;
          ctx.font = footerFont.string;
          each(tooltip.footer, maxLineWidth);
          ctx.restore();
          width += padding.width;
          return { width, height };
        }
        function determineYAlign(chart2, size) {
          const { y, height } = size;
          if (y < height / 2) {
            return "top";
          } else if (y > chart2.height - height / 2) {
            return "bottom";
          }
          return "center";
        }
        function doesNotFitWithAlign(xAlign, chart2, options, size) {
          const { x, width } = size;
          const caret = options.caretSize + options.caretPadding;
          if (xAlign === "left" && x + width + caret > chart2.width) {
            return true;
          }
          if (xAlign === "right" && x - width - caret < 0) {
            return true;
          }
        }
        function determineXAlign(chart2, options, size, yAlign) {
          const { x, width } = size;
          const { width: chartWidth, chartArea: { left, right } } = chart2;
          let xAlign = "center";
          if (yAlign === "center") {
            xAlign = x <= (left + right) / 2 ? "left" : "right";
          } else if (x <= width / 2) {
            xAlign = "left";
          } else if (x >= chartWidth - width / 2) {
            xAlign = "right";
          }
          if (doesNotFitWithAlign(xAlign, chart2, options, size)) {
            xAlign = "center";
          }
          return xAlign;
        }
        function determineAlignment(chart2, options, size) {
          const yAlign = size.yAlign || options.yAlign || determineYAlign(chart2, size);
          return {
            xAlign: size.xAlign || options.xAlign || determineXAlign(chart2, options, size, yAlign),
            yAlign
          };
        }
        function alignX(size, xAlign) {
          let { x, width } = size;
          if (xAlign === "right") {
            x -= width;
          } else if (xAlign === "center") {
            x -= width / 2;
          }
          return x;
        }
        function alignY(size, yAlign, paddingAndSize) {
          let { y, height } = size;
          if (yAlign === "top") {
            y += paddingAndSize;
          } else if (yAlign === "bottom") {
            y -= height + paddingAndSize;
          } else {
            y -= height / 2;
          }
          return y;
        }
        function getBackgroundPoint(options, size, alignment, chart2) {
          const { caretSize, caretPadding, cornerRadius } = options;
          const { xAlign, yAlign } = alignment;
          const paddingAndSize = caretSize + caretPadding;
          const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
          let x = alignX(size, xAlign);
          const y = alignY(size, yAlign, paddingAndSize);
          if (yAlign === "center") {
            if (xAlign === "left") {
              x += paddingAndSize;
            } else if (xAlign === "right") {
              x -= paddingAndSize;
            }
          } else if (xAlign === "left") {
            x -= Math.max(topLeft, bottomLeft) + caretSize;
          } else if (xAlign === "right") {
            x += Math.max(topRight, bottomRight) + caretSize;
          }
          return {
            x: _limitValue(x, 0, chart2.width - size.width),
            y: _limitValue(y, 0, chart2.height - size.height)
          };
        }
        function getAlignedX(tooltip, align, options) {
          const padding = toPadding(options.padding);
          return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
        }
        function getBeforeAfterBodyLines(callback2) {
          return pushOrConcat([], splitNewlines(callback2));
        }
        function createTooltipContext(parent, tooltip, tooltipItems) {
          return createContext(parent, {
            tooltip,
            tooltipItems,
            type: "tooltip"
          });
        }
        function overrideCallbacks(callbacks, context) {
          const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
          return override ? callbacks.override(override) : callbacks;
        }
        class Tooltip extends Element2 {
          constructor(config) {
            super();
            this.opacity = 0;
            this._active = [];
            this._eventPosition = void 0;
            this._size = void 0;
            this._cachedAnimations = void 0;
            this._tooltipItems = [];
            this.$animations = void 0;
            this.$context = void 0;
            this.chart = config.chart || config._chart;
            this._chart = this.chart;
            this.options = config.options;
            this.dataPoints = void 0;
            this.title = void 0;
            this.beforeBody = void 0;
            this.body = void 0;
            this.afterBody = void 0;
            this.footer = void 0;
            this.xAlign = void 0;
            this.yAlign = void 0;
            this.x = void 0;
            this.y = void 0;
            this.height = void 0;
            this.width = void 0;
            this.caretX = void 0;
            this.caretY = void 0;
            this.labelColors = void 0;
            this.labelPointStyles = void 0;
            this.labelTextColors = void 0;
          }
          initialize(options) {
            this.options = options;
            this._cachedAnimations = void 0;
            this.$context = void 0;
          }
          _resolveAnimations() {
            const cached = this._cachedAnimations;
            if (cached) {
              return cached;
            }
            const chart2 = this.chart;
            const options = this.options.setContext(this.getContext());
            const opts = options.enabled && chart2.options.animation && options.animations;
            const animations = new Animations(this.chart, opts);
            if (opts._cacheable) {
              this._cachedAnimations = Object.freeze(animations);
            }
            return animations;
          }
          getContext() {
            return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
          }
          getTitle(context, options) {
            const { callbacks } = options;
            const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
            const title = callbacks.title.apply(this, [context]);
            const afterTitle = callbacks.afterTitle.apply(this, [context]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
          }
          getBeforeBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
          }
          getBody(tooltipItems, options) {
            const { callbacks } = options;
            const bodyItems = [];
            each(tooltipItems, (context) => {
              const bodyItem = {
                before: [],
                lines: [],
                after: []
              };
              const scoped = overrideCallbacks(callbacks, context);
              pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
              pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
              pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
              bodyItems.push(bodyItem);
            });
            return bodyItems;
          }
          getAfterBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
          }
          getFooter(tooltipItems, options) {
            const { callbacks } = options;
            const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
            const footer = callbacks.footer.apply(this, [tooltipItems]);
            const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
          }
          _createItems(options) {
            const active = this._active;
            const data = this.chart.data;
            const labelColors = [];
            const labelPointStyles = [];
            const labelTextColors = [];
            let tooltipItems = [];
            let i, len;
            for (i = 0, len = active.length; i < len; ++i) {
              tooltipItems.push(createTooltipItem(this.chart, active[i]));
            }
            if (options.filter) {
              tooltipItems = tooltipItems.filter((element, index3, array) => options.filter(element, index3, array, data));
            }
            if (options.itemSort) {
              tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
            }
            each(tooltipItems, (context) => {
              const scoped = overrideCallbacks(options.callbacks, context);
              labelColors.push(scoped.labelColor.call(this, context));
              labelPointStyles.push(scoped.labelPointStyle.call(this, context));
              labelTextColors.push(scoped.labelTextColor.call(this, context));
            });
            this.labelColors = labelColors;
            this.labelPointStyles = labelPointStyles;
            this.labelTextColors = labelTextColors;
            this.dataPoints = tooltipItems;
            return tooltipItems;
          }
          update(changed, replay) {
            const options = this.options.setContext(this.getContext());
            const active = this._active;
            let properties;
            let tooltipItems = [];
            if (!active.length) {
              if (this.opacity !== 0) {
                properties = {
                  opacity: 0
                };
              }
            } else {
              const position = positioners[options.position].call(this, active, this._eventPosition);
              tooltipItems = this._createItems(options);
              this.title = this.getTitle(tooltipItems, options);
              this.beforeBody = this.getBeforeBody(tooltipItems, options);
              this.body = this.getBody(tooltipItems, options);
              this.afterBody = this.getAfterBody(tooltipItems, options);
              this.footer = this.getFooter(tooltipItems, options);
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, size);
              const alignment = determineAlignment(this.chart, options, positionAndSize);
              const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
              this.xAlign = alignment.xAlign;
              this.yAlign = alignment.yAlign;
              properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y
              };
            }
            this._tooltipItems = tooltipItems;
            this.$context = void 0;
            if (properties) {
              this._resolveAnimations().update(this, properties);
            }
            if (changed && options.external) {
              options.external.call(this, { chart: this.chart, tooltip: this, replay });
            }
          }
          drawCaret(tooltipPoint, ctx, size, options) {
            const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          }
          getCaretPosition(tooltipPoint, size, options) {
            const { xAlign, yAlign } = this;
            const { caretSize, cornerRadius } = options;
            const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
            const { x: ptX, y: ptY } = tooltipPoint;
            const { width, height } = size;
            let x1, x2, x3, y1, y2, y3;
            if (yAlign === "center") {
              y2 = ptY + height / 2;
              if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
              x3 = x1;
            } else {
              if (xAlign === "left") {
                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
              } else if (xAlign === "right") {
                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
              } else {
                x2 = this.caretX;
              }
              if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
              }
              y3 = y1;
            }
            return { x1, x2, x3, y1, y2, y3 };
          }
          drawTitle(pt, ctx, options) {
            const title = this.title;
            const length = title.length;
            let titleFont, titleSpacing, i;
            if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt.x = getAlignedX(this, options.titleAlign, options);
              ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
              ctx.textBaseline = "middle";
              titleFont = toFont(options.titleFont);
              titleSpacing = options.titleSpacing;
              ctx.fillStyle = options.titleColor;
              ctx.font = titleFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                pt.y += titleFont.lineHeight + titleSpacing;
                if (i + 1 === length) {
                  pt.y += options.titleMarginBottom - titleSpacing;
                }
              }
            }
          }
          _drawColorBox(ctx, pt, i, rtlHelper, options) {
            const labelColors = this.labelColors[i];
            const labelPointStyle = this.labelPointStyles[i];
            const { boxHeight, boxWidth, boxPadding } = options;
            const bodyFont = toFont(options.bodyFont);
            const colorX = getAlignedX(this, "left", options);
            const rtlColorX = rtlHelper.x(colorX);
            const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
            const colorY = pt.y + yOffSet;
            if (options.usePointStyle) {
              const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1
              };
              const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
              const centerY = colorY + boxHeight / 2;
              ctx.strokeStyle = options.multiKeyBackground;
              ctx.fillStyle = options.multiKeyBackground;
              drawPoint(ctx, drawOptions, centerX, centerY);
              ctx.strokeStyle = labelColors.borderColor;
              ctx.fillStyle = labelColors.backgroundColor;
              drawPoint(ctx, drawOptions, centerX, centerY);
            } else {
              ctx.lineWidth = isObject2(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
              ctx.strokeStyle = labelColors.borderColor;
              ctx.setLineDash(labelColors.borderDash || []);
              ctx.lineDashOffset = labelColors.borderDashOffset || 0;
              const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
              const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
              const borderRadius = toTRBLCorners(labelColors.borderRadius);
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                addRoundedRectPath(ctx, {
                  x: outerX,
                  y: colorY,
                  w: boxWidth,
                  h: boxHeight,
                  radius: borderRadius
                });
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                  x: innerX,
                  y: colorY + 1,
                  w: boxWidth - 2,
                  h: boxHeight - 2,
                  radius: borderRadius
                });
                ctx.fill();
              } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
              }
            }
            ctx.fillStyle = this.labelTextColors[i];
          }
          drawBody(pt, ctx, options) {
            const { body } = this;
            const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
            const bodyFont = toFont(options.bodyFont);
            let bodyLineHeight = bodyFont.lineHeight;
            let xLinePadding = 0;
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            const fillLineOfText = function(line) {
              ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
              pt.y += bodyLineHeight + bodySpacing;
            };
            const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            let bodyItem, textColor, lines, i, j, ilen, jlen;
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = "middle";
            ctx.font = bodyFont.string;
            pt.x = getAlignedX(this, bodyAlignForCalculation, options);
            ctx.fillStyle = options.bodyColor;
            each(this.beforeBody, fillLineOfText);
            xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
            for (i = 0, ilen = body.length; i < ilen; ++i) {
              bodyItem = body[i];
              textColor = this.labelTextColors[i];
              ctx.fillStyle = textColor;
              each(bodyItem.before, fillLineOfText);
              lines = bodyItem.lines;
              if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt, i, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
              }
              for (j = 0, jlen = lines.length; j < jlen; ++j) {
                fillLineOfText(lines[j]);
                bodyLineHeight = bodyFont.lineHeight;
              }
              each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            bodyLineHeight = bodyFont.lineHeight;
            each(this.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
          }
          drawFooter(pt, ctx, options) {
            const footer = this.footer;
            const length = footer.length;
            let footerFont, i;
            if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt.x = getAlignedX(this, options.footerAlign, options);
              pt.y += options.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
              ctx.textBaseline = "middle";
              footerFont = toFont(options.footerFont);
              ctx.fillStyle = options.footerColor;
              ctx.font = footerFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                pt.y += footerFont.lineHeight + options.footerSpacing;
              }
            }
          }
          drawBackground(pt, ctx, tooltipSize, options) {
            const { xAlign, yAlign } = this;
            const { x, y } = pt;
            const { width, height } = tooltipSize;
            const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.beginPath();
            ctx.moveTo(x + topLeft, y);
            if (yAlign === "top") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width - topRight, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
            if (yAlign === "center" && xAlign === "right") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width, y + height - bottomRight);
            ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
            if (yAlign === "bottom") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + bottomLeft, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
            if (yAlign === "center" && xAlign === "left") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x, y + topLeft);
            ctx.quadraticCurveTo(x, y, x + topLeft, y);
            ctx.closePath();
            ctx.fill();
            if (options.borderWidth > 0) {
              ctx.stroke();
            }
          }
          _updateAnimationTarget(options) {
            const chart2 = this.chart;
            const anims = this.$animations;
            const animX = anims && anims.x;
            const animY = anims && anims.y;
            if (animX || animY) {
              const position = positioners[options.position].call(this, this._active, this._eventPosition);
              if (!position) {
                return;
              }
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, this._size);
              const alignment = determineAlignment(chart2, options, positionAndSize);
              const point = getBackgroundPoint(options, positionAndSize, alignment, chart2);
              if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
              }
            }
          }
          _willRender() {
            return !!this.opacity;
          }
          draw(ctx) {
            const options = this.options.setContext(this.getContext());
            let opacity = this.opacity;
            if (!opacity) {
              return;
            }
            this._updateAnimationTarget(options);
            const tooltipSize = {
              width: this.width,
              height: this.height
            };
            const pt = {
              x: this.x,
              y: this.y
            };
            opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
            const padding = toPadding(options.padding);
            const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
            if (options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt, ctx, tooltipSize, options);
              overrideTextDirection(ctx, options.textDirection);
              pt.y += padding.top;
              this.drawTitle(pt, ctx, options);
              this.drawBody(pt, ctx, options);
              this.drawFooter(pt, ctx, options);
              restoreTextDirection(ctx, options.textDirection);
              ctx.restore();
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements, eventPosition) {
            const lastActive = this._active;
            const active = activeElements.map(({ datasetIndex, index: index3 }) => {
              const meta = this.chart.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error("Cannot find a dataset at index " + datasetIndex);
              }
              return {
                datasetIndex,
                element: meta.data[index3],
                index: index3
              };
            });
            const changed = !_elementsEqual(lastActive, active);
            const positionChanged = this._positionChanged(active, eventPosition);
            if (changed || positionChanged) {
              this._active = active;
              this._eventPosition = eventPosition;
              this._ignoreReplayEvents = true;
              this.update(true);
            }
          }
          handleEvent(e, replay, inChartArea = true) {
            if (replay && this._ignoreReplayEvents) {
              return false;
            }
            this._ignoreReplayEvents = false;
            const options = this.options;
            const lastActive = this._active || [];
            const active = this._getActiveElements(e, lastActive, replay, inChartArea);
            const positionChanged = this._positionChanged(active, e);
            const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
            if (changed) {
              this._active = active;
              if (options.enabled || options.external) {
                this._eventPosition = {
                  x: e.x,
                  y: e.y
                };
                this.update(true, replay);
              }
            }
            return changed;
          }
          _getActiveElements(e, lastActive, replay, inChartArea) {
            const options = this.options;
            if (e.type === "mouseout") {
              return [];
            }
            if (!inChartArea) {
              return lastActive;
            }
            const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
            if (options.reverse) {
              active.reverse();
            }
            return active;
          }
          _positionChanged(active, e) {
            const { caretX, caretY, options } = this;
            const position = positioners[options.position].call(this, active, e);
            return position !== false && (caretX !== position.x || caretY !== position.y);
          }
        }
        Tooltip.positioners = positioners;
        var plugin_tooltip = {
          id: "tooltip",
          _element: Tooltip,
          positioners,
          afterInit(chart2, _args, options) {
            if (options) {
              chart2.tooltip = new Tooltip({ chart: chart2, options });
            }
          },
          beforeUpdate(chart2, _args, options) {
            if (chart2.tooltip) {
              chart2.tooltip.initialize(options);
            }
          },
          reset(chart2, _args, options) {
            if (chart2.tooltip) {
              chart2.tooltip.initialize(options);
            }
          },
          afterDraw(chart2) {
            const tooltip = chart2.tooltip;
            if (tooltip && tooltip._willRender()) {
              const args = {
                tooltip
              };
              if (chart2.notifyPlugins("beforeTooltipDraw", args) === false) {
                return;
              }
              tooltip.draw(chart2.ctx);
              chart2.notifyPlugins("afterTooltipDraw", args);
            }
          },
          afterEvent(chart2, args) {
            if (chart2.tooltip) {
              const useFinalPosition = args.replay;
              if (chart2.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
                args.changed = true;
              }
            }
          },
          defaults: {
            enabled: true,
            external: null,
            position: "average",
            backgroundColor: "rgba(0,0,0,0.8)",
            titleColor: "#fff",
            titleFont: {
              weight: "bold"
            },
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleAlign: "left",
            bodyColor: "#fff",
            bodySpacing: 2,
            bodyFont: {},
            bodyAlign: "left",
            footerColor: "#fff",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFont: {
              weight: "bold"
            },
            footerAlign: "left",
            padding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            boxHeight: (ctx, opts) => opts.bodyFont.size,
            boxWidth: (ctx, opts) => opts.bodyFont.size,
            multiKeyBackground: "#fff",
            displayColors: true,
            boxPadding: 0,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            animation: {
              duration: 400,
              easing: "easeOutQuart"
            },
            animations: {
              numbers: {
                type: "number",
                properties: ["x", "y", "width", "height", "caretX", "caretY"]
              },
              opacity: {
                easing: "linear",
                duration: 200
              }
            },
            callbacks: {
              beforeTitle: noop2,
              title(tooltipItems) {
                if (tooltipItems.length > 0) {
                  const item = tooltipItems[0];
                  const labels = item.chart.data.labels;
                  const labelCount = labels ? labels.length : 0;
                  if (this && this.options && this.options.mode === "dataset") {
                    return item.dataset.label || "";
                  } else if (item.label) {
                    return item.label;
                  } else if (labelCount > 0 && item.dataIndex < labelCount) {
                    return labels[item.dataIndex];
                  }
                }
                return "";
              },
              afterTitle: noop2,
              beforeBody: noop2,
              beforeLabel: noop2,
              label(tooltipItem) {
                if (this && this.options && this.options.mode === "dataset") {
                  return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
                }
                let label = tooltipItem.dataset.label || "";
                if (label) {
                  label += ": ";
                }
                const value = tooltipItem.formattedValue;
                if (!isNullOrUndef(value)) {
                  label += value;
                }
                return label;
              },
              labelColor(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                  borderColor: options.borderColor,
                  backgroundColor: options.backgroundColor,
                  borderWidth: options.borderWidth,
                  borderDash: options.borderDash,
                  borderDashOffset: options.borderDashOffset,
                  borderRadius: 0
                };
              },
              labelTextColor() {
                return this.options.bodyColor;
              },
              labelPointStyle(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                  pointStyle: options.pointStyle,
                  rotation: options.rotation
                };
              },
              afterLabel: noop2,
              afterBody: noop2,
              beforeFooter: noop2,
              footer: noop2,
              afterFooter: noop2
            }
          },
          defaultRoutes: {
            bodyFont: "font",
            footerFont: "font",
            titleFont: "font"
          },
          descriptors: {
            _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
            _indexable: false,
            callbacks: {
              _scriptable: false,
              _indexable: false
            },
            animation: {
              _fallback: false
            },
            animations: {
              _fallback: "animation"
            }
          },
          additionalOptionScopes: ["interaction"]
        };
        var plugins = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          Decimation: plugin_decimation,
          Filler: index2,
          Legend: plugin_legend,
          SubTitle: plugin_subtitle,
          Title: plugin_title,
          Tooltip: plugin_tooltip
        });
        const addIfString = (labels, raw, index3, addedLabels) => {
          if (typeof raw === "string") {
            index3 = labels.push(raw) - 1;
            addedLabels.unshift({ index: index3, label: raw });
          } else if (isNaN(raw)) {
            index3 = null;
          }
          return index3;
        };
        function findOrAddLabel(labels, raw, index3, addedLabels) {
          const first = labels.indexOf(raw);
          if (first === -1) {
            return addIfString(labels, raw, index3, addedLabels);
          }
          const last = labels.lastIndexOf(raw);
          return first !== last ? index3 : first;
        }
        const validIndex = (index3, max) => index3 === null ? null : _limitValue(Math.round(index3), 0, max);
        class CategoryScale extends Scale {
          constructor(cfg) {
            super(cfg);
            this._startValue = void 0;
            this._valueRange = 0;
            this._addedLabels = [];
          }
          init(scaleOptions) {
            const added = this._addedLabels;
            if (added.length) {
              const labels = this.getLabels();
              for (const { index: index3, label } of added) {
                if (labels[index3] === label) {
                  labels.splice(index3, 1);
                }
              }
              this._addedLabels = [];
            }
            super.init(scaleOptions);
          }
          parse(raw, index3) {
            if (isNullOrUndef(raw)) {
              return null;
            }
            const labels = this.getLabels();
            index3 = isFinite(index3) && labels[index3] === raw ? index3 : findOrAddLabel(labels, raw, valueOrDefault(index3, raw), this._addedLabels);
            return validIndex(index3, labels.length - 1);
          }
          determineDataLimits() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this.getMinMax(true);
            if (this.options.bounds === "ticks") {
              if (!minDefined) {
                min = 0;
              }
              if (!maxDefined) {
                max = this.getLabels().length - 1;
              }
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const min = this.min;
            const max = this.max;
            const offset = this.options.offset;
            const ticks = [];
            let labels = this.getLabels();
            labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
            this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
            this._startValue = this.min - (offset ? 0.5 : 0);
            for (let value = min; value <= max; value++) {
              ticks.push({ value });
            }
            return ticks;
          }
          getLabelForValue(value) {
            const labels = this.getLabels();
            if (value >= 0 && value < labels.length) {
              return labels[value];
            }
            return value;
          }
          configure() {
            super.configure();
            if (!this.isHorizontal()) {
              this._reversePixels = !this._reversePixels;
            }
          }
          getPixelForValue(value) {
            if (typeof value !== "number") {
              value = this.parse(value);
            }
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
          }
          getPixelForTick(index3) {
            const ticks = this.ticks;
            if (index3 < 0 || index3 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index3].value);
          }
          getValueForPixel(pixel) {
            return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
          }
          getBasePixel() {
            return this.bottom;
          }
        }
        CategoryScale.id = "category";
        CategoryScale.defaults = {
          ticks: {
            callback: CategoryScale.prototype.getLabelForValue
          }
        };
        function generateTicks$1(generationOptions, dataRange) {
          const ticks = [];
          const MIN_SPACING = 1e-14;
          const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
          const unit = step || 1;
          const maxSpaces = maxTicks - 1;
          const { min: rmin, max: rmax } = dataRange;
          const minDefined = !isNullOrUndef(min);
          const maxDefined = !isNullOrUndef(max);
          const countDefined = !isNullOrUndef(count);
          const minSpacing = (rmax - rmin) / (maxDigits + 1);
          let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
          let factor, niceMin, niceMax, numSpaces;
          if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
            return [{ value: rmin }, { value: rmax }];
          }
          numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
          if (numSpaces > maxSpaces) {
            spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
          }
          if (!isNullOrUndef(precision)) {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
          }
          if (bounds === "ticks") {
            niceMin = Math.floor(rmin / spacing) * spacing;
            niceMax = Math.ceil(rmax / spacing) * spacing;
          } else {
            niceMin = rmin;
            niceMax = rmax;
          }
          if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
            numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
            spacing = (max - min) / numSpaces;
            niceMin = min;
            niceMax = max;
          } else if (countDefined) {
            niceMin = minDefined ? min : niceMin;
            niceMax = maxDefined ? max : niceMax;
            numSpaces = count - 1;
            spacing = (niceMax - niceMin) / numSpaces;
          } else {
            numSpaces = (niceMax - niceMin) / spacing;
            if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
              numSpaces = Math.round(numSpaces);
            } else {
              numSpaces = Math.ceil(numSpaces);
            }
          }
          const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
          factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
          niceMin = Math.round(niceMin * factor) / factor;
          niceMax = Math.round(niceMax * factor) / factor;
          let j = 0;
          if (minDefined) {
            if (includeBounds && niceMin !== min) {
              ticks.push({ value: min });
              if (niceMin < min) {
                j++;
              }
              if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
                j++;
              }
            } else if (niceMin < min) {
              j++;
            }
          }
          for (; j < numSpaces; ++j) {
            ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
          }
          if (maxDefined && includeBounds && niceMax !== max) {
            if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
              ticks[ticks.length - 1].value = max;
            } else {
              ticks.push({ value: max });
            }
          } else if (!maxDefined || niceMax === max) {
            ticks.push({ value: niceMax });
          }
          return ticks;
        }
        function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
          const rad = toRadians(minRotation);
          const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
          const length = 0.75 * minSpacing * ("" + value).length;
          return Math.min(minSpacing / ratio, length);
        }
        class LinearScaleBase extends Scale {
          constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._endValue = void 0;
            this._valueRange = 0;
          }
          parse(raw, index3) {
            if (isNullOrUndef(raw)) {
              return null;
            }
            if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
              return null;
            }
            return +raw;
          }
          handleTickRangeOptions() {
            const { beginAtZero } = this.options;
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this;
            const setMin = (v) => min = minDefined ? min : v;
            const setMax = (v) => max = maxDefined ? max : v;
            if (beginAtZero) {
              const minSign = sign(min);
              const maxSign = sign(max);
              if (minSign < 0 && maxSign < 0) {
                setMax(0);
              } else if (minSign > 0 && maxSign > 0) {
                setMin(0);
              }
            }
            if (min === max) {
              let offset = 1;
              if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
                offset = Math.abs(max * 0.05);
              }
              setMax(max + offset);
              if (!beginAtZero) {
                setMin(min - offset);
              }
            }
            this.min = min;
            this.max = max;
          }
          getTickLimit() {
            const tickOpts = this.options.ticks;
            let { maxTicksLimit, stepSize } = tickOpts;
            let maxTicks;
            if (stepSize) {
              maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
              if (maxTicks > 1e3) {
                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                maxTicks = 1e3;
              }
            } else {
              maxTicks = this.computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
          }
          computeTickLimit() {
            return Number.POSITIVE_INFINITY;
          }
          buildTicks() {
            const opts = this.options;
            const tickOpts = opts.ticks;
            let maxTicks = this.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            const numericGeneratorOptions = {
              maxTicks,
              bounds: opts.bounds,
              min: opts.min,
              max: opts.max,
              precision: tickOpts.precision,
              step: tickOpts.stepSize,
              count: tickOpts.count,
              maxDigits: this._maxDigits(),
              horizontal: this.isHorizontal(),
              minRotation: tickOpts.minRotation || 0,
              includeBounds: tickOpts.includeBounds !== false
            };
            const dataRange = this._range || this;
            const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
            if (opts.bounds === "ticks") {
              _setMinAndMaxByKey(ticks, this, "value");
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          configure() {
            const ticks = this.ticks;
            let start = this.min;
            let end = this.max;
            super.configure();
            if (this.options.offset && ticks.length) {
              const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
              start -= offset;
              end += offset;
            }
            this._startValue = start;
            this._endValue = end;
            this._valueRange = end - start;
          }
          getLabelForValue(value) {
            return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
          }
        }
        class LinearScale extends LinearScaleBase {
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? min : 0;
            this.max = isNumberFinite(max) ? max : 1;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            const horizontal = this.isHorizontal();
            const length = horizontal ? this.width : this.height;
            const minRotation = toRadians(this.options.ticks.minRotation);
            const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
            const tickFont = this._resolveTickFontOptions(0);
            return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
          }
          getPixelForValue(value) {
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
          }
          getValueForPixel(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
          }
        }
        LinearScale.id = "linear";
        LinearScale.defaults = {
          ticks: {
            callback: Ticks.formatters.numeric
          }
        };
        function isMajor(tickVal) {
          const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
          return remain === 1;
        }
        function generateTicks(generationOptions, dataRange) {
          const endExp = Math.floor(log10(dataRange.max));
          const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
          const ticks = [];
          let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
          let exp = Math.floor(log10(tickVal));
          let significand = Math.floor(tickVal / Math.pow(10, exp));
          let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
          do {
            ticks.push({ value: tickVal, major: isMajor(tickVal) });
            ++significand;
            if (significand === 10) {
              significand = 1;
              ++exp;
              precision = exp >= 0 ? 1 : precision;
            }
            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
          } while (exp < endExp || exp === endExp && significand < endSignificand);
          const lastTick = finiteOrDefault(generationOptions.max, tickVal);
          ticks.push({ value: lastTick, major: isMajor(tickVal) });
          return ticks;
        }
        class LogarithmicScale extends Scale {
          constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._valueRange = 0;
          }
          parse(raw, index3) {
            const value = LinearScaleBase.prototype.parse.apply(this, [raw, index3]);
            if (value === 0) {
              this._zero = true;
              return void 0;
            }
            return isNumberFinite(value) && value > 0 ? value : null;
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? Math.max(0, min) : null;
            this.max = isNumberFinite(max) ? Math.max(0, max) : null;
            if (this.options.beginAtZero) {
              this._zero = true;
            }
            this.handleTickRangeOptions();
          }
          handleTickRangeOptions() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let min = this.min;
            let max = this.max;
            const setMin = (v) => min = minDefined ? min : v;
            const setMax = (v) => max = maxDefined ? max : v;
            const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
            if (min === max) {
              if (min <= 0) {
                setMin(1);
                setMax(10);
              } else {
                setMin(exp(min, -1));
                setMax(exp(max, 1));
              }
            }
            if (min <= 0) {
              setMin(exp(max, -1));
            }
            if (max <= 0) {
              setMax(exp(min, 1));
            }
            if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
              setMin(exp(min, -1));
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const opts = this.options;
            const generationOptions = {
              min: this._userMin,
              max: this._userMax
            };
            const ticks = generateTicks(generationOptions, this);
            if (opts.bounds === "ticks") {
              _setMinAndMaxByKey(ticks, this, "value");
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          getLabelForValue(value) {
            return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
          }
          configure() {
            const start = this.min;
            super.configure();
            this._startValue = log10(start);
            this._valueRange = log10(this.max) - log10(start);
          }
          getPixelForValue(value) {
            if (value === void 0 || value === 0) {
              value = this.min;
            }
            if (value === null || isNaN(value)) {
              return NaN;
            }
            return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
          }
          getValueForPixel(pixel) {
            const decimal = this.getDecimalForPixel(pixel);
            return Math.pow(10, this._startValue + decimal * this._valueRange);
          }
        }
        LogarithmicScale.id = "logarithmic";
        LogarithmicScale.defaults = {
          ticks: {
            callback: Ticks.formatters.logarithmic,
            major: {
              enabled: true
            }
          }
        };
        function getTickBackdropHeight(opts) {
          const tickOpts = opts.ticks;
          if (tickOpts.display && opts.display) {
            const padding = toPadding(tickOpts.backdropPadding);
            return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
          }
          return 0;
        }
        function measureLabelSize(ctx, font, label) {
          label = isArray(label) ? label : [label];
          return {
            w: _longestText(ctx, font.string, label),
            h: label.length * font.lineHeight
          };
        }
        function determineLimits(angle, pos, size, min, max) {
          if (angle === min || angle === max) {
            return {
              start: pos - size / 2,
              end: pos + size / 2
            };
          } else if (angle < min || angle > max) {
            return {
              start: pos - size,
              end: pos
            };
          }
          return {
            start: pos,
            end: pos + size
          };
        }
        function fitWithPointLabels(scale) {
          const orig = {
            l: scale.left + scale._padding.left,
            r: scale.right - scale._padding.right,
            t: scale.top + scale._padding.top,
            b: scale.bottom - scale._padding.bottom
          };
          const limits = Object.assign({}, orig);
          const labelSizes = [];
          const padding = [];
          const valueCount = scale._pointLabels.length;
          const pointLabelOpts = scale.options.pointLabels;
          const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
          for (let i = 0; i < valueCount; i++) {
            const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
            padding[i] = opts.padding;
            const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
            const plFont = toFont(opts.font);
            const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
            labelSizes[i] = textSize;
            const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
            const angle = Math.round(toDegrees(angleRadians));
            const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            updateLimits(limits, orig, angleRadians, hLimits, vLimits);
          }
          scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
          scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
        }
        function updateLimits(limits, orig, angle, hLimits, vLimits) {
          const sin = Math.abs(Math.sin(angle));
          const cos = Math.abs(Math.cos(angle));
          let x = 0;
          let y = 0;
          if (hLimits.start < orig.l) {
            x = (orig.l - hLimits.start) / sin;
            limits.l = Math.min(limits.l, orig.l - x);
          } else if (hLimits.end > orig.r) {
            x = (hLimits.end - orig.r) / sin;
            limits.r = Math.max(limits.r, orig.r + x);
          }
          if (vLimits.start < orig.t) {
            y = (orig.t - vLimits.start) / cos;
            limits.t = Math.min(limits.t, orig.t - y);
          } else if (vLimits.end > orig.b) {
            y = (vLimits.end - orig.b) / cos;
            limits.b = Math.max(limits.b, orig.b + y);
          }
        }
        function buildPointLabelItems(scale, labelSizes, padding) {
          const items = [];
          const valueCount = scale._pointLabels.length;
          const opts = scale.options;
          const extra = getTickBackdropHeight(opts) / 2;
          const outerDistance = scale.drawingArea;
          const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
          for (let i = 0; i < valueCount; i++) {
            const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
            const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
            const size = labelSizes[i];
            const y = yForAngle(pointLabelPosition.y, size.h, angle);
            const textAlign = getTextAlignForAngle(angle);
            const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
            items.push({
              x: pointLabelPosition.x,
              y,
              textAlign,
              left,
              top: y,
              right: left + size.w,
              bottom: y + size.h
            });
          }
          return items;
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return "center";
          } else if (angle < 180) {
            return "left";
          }
          return "right";
        }
        function leftForTextAlign(x, w, align) {
          if (align === "right") {
            x -= w;
          } else if (align === "center") {
            x -= w / 2;
          }
          return x;
        }
        function yForAngle(y, h, angle) {
          if (angle === 90 || angle === 270) {
            y -= h / 2;
          } else if (angle > 270 || angle < 90) {
            y -= h;
          }
          return y;
        }
        function drawPointLabels(scale, labelCount) {
          const { ctx, options: { pointLabels } } = scale;
          for (let i = labelCount - 1; i >= 0; i--) {
            const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
            const plFont = toFont(optsAtIndex.font);
            const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
            const { backdropColor } = optsAtIndex;
            if (!isNullOrUndef(backdropColor)) {
              const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
              const padding = toPadding(optsAtIndex.backdropPadding);
              ctx.fillStyle = backdropColor;
              const backdropLeft = left - padding.left;
              const backdropTop = top - padding.top;
              const backdropWidth = right - left + padding.width;
              const backdropHeight = bottom - top + padding.height;
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                  x: backdropLeft,
                  y: backdropTop,
                  w: backdropWidth,
                  h: backdropHeight,
                  radius: borderRadius
                });
                ctx.fill();
              } else {
                ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
              }
            }
            renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
              color: optsAtIndex.color,
              textAlign,
              textBaseline: "middle"
            });
          }
        }
        function pathRadiusLine(scale, radius, circular, labelCount) {
          const { ctx } = scale;
          if (circular) {
            ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
          } else {
            let pointPosition = scale.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (let i = 1; i < labelCount; i++) {
              pointPosition = scale.getPointPosition(i, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
          }
        }
        function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
          const ctx = scale.ctx;
          const circular = gridLineOpts.circular;
          const { color: color2, lineWidth } = gridLineOpts;
          if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
            return;
          }
          ctx.save();
          ctx.strokeStyle = color2;
          ctx.lineWidth = lineWidth;
          ctx.setLineDash(gridLineOpts.borderDash);
          ctx.lineDashOffset = gridLineOpts.borderDashOffset;
          ctx.beginPath();
          pathRadiusLine(scale, radius, circular, labelCount);
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        function createPointLabelContext(parent, index3, label) {
          return createContext(parent, {
            label,
            index: index3,
            type: "pointLabel"
          });
        }
        class RadialLinearScale extends LinearScaleBase {
          constructor(cfg) {
            super(cfg);
            this.xCenter = void 0;
            this.yCenter = void 0;
            this.drawingArea = void 0;
            this._pointLabels = [];
            this._pointLabelItems = [];
          }
          setDimensions() {
            const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
            const w = this.width = this.maxWidth - padding.width;
            const h = this.height = this.maxHeight - padding.height;
            this.xCenter = Math.floor(this.left + w / 2 + padding.left);
            this.yCenter = Math.floor(this.top + h / 2 + padding.top);
            this.drawingArea = Math.floor(Math.min(w, h) / 2);
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(false);
            this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
            this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
          }
          generateTickLabels(ticks) {
            LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
            this._pointLabels = this.getLabels().map((value, index3) => {
              const label = callback(this.options.pointLabels.callback, [value, index3], this);
              return label || label === 0 ? label : "";
            }).filter((v, i) => this.chart.getDataVisibility(i));
          }
          fit() {
            const opts = this.options;
            if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(this);
            } else {
              this.setCenterPoint(0, 0, 0, 0);
            }
          }
          setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
            this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
            this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
            this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
          }
          getIndexAngle(index3) {
            const angleMultiplier = TAU / (this._pointLabels.length || 1);
            const startAngle = this.options.startAngle || 0;
            return _normalizeAngle(index3 * angleMultiplier + toRadians(startAngle));
          }
          getDistanceFromCenterForValue(value) {
            if (isNullOrUndef(value)) {
              return NaN;
            }
            const scalingFactor = this.drawingArea / (this.max - this.min);
            if (this.options.reverse) {
              return (this.max - value) * scalingFactor;
            }
            return (value - this.min) * scalingFactor;
          }
          getValueForDistanceFromCenter(distance2) {
            if (isNullOrUndef(distance2)) {
              return NaN;
            }
            const scaledDistance = distance2 / (this.drawingArea / (this.max - this.min));
            return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
          }
          getPointLabelContext(index3) {
            const pointLabels = this._pointLabels || [];
            if (index3 >= 0 && index3 < pointLabels.length) {
              const pointLabel = pointLabels[index3];
              return createPointLabelContext(this.getContext(), index3, pointLabel);
            }
          }
          getPointPosition(index3, distanceFromCenter, additionalAngle = 0) {
            const angle = this.getIndexAngle(index3) - HALF_PI + additionalAngle;
            return {
              x: Math.cos(angle) * distanceFromCenter + this.xCenter,
              y: Math.sin(angle) * distanceFromCenter + this.yCenter,
              angle
            };
          }
          getPointPositionForValue(index3, value) {
            return this.getPointPosition(index3, this.getDistanceFromCenterForValue(value));
          }
          getBasePosition(index3) {
            return this.getPointPositionForValue(index3 || 0, this.getBaseValue());
          }
          getPointLabelPosition(index3) {
            const { left, top, right, bottom } = this._pointLabelItems[index3];
            return {
              left,
              top,
              right,
              bottom
            };
          }
          drawBackground() {
            const { backgroundColor, grid: { circular } } = this.options;
            if (backgroundColor) {
              const ctx = this.ctx;
              ctx.save();
              ctx.beginPath();
              pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
              ctx.closePath();
              ctx.fillStyle = backgroundColor;
              ctx.fill();
              ctx.restore();
            }
          }
          drawGrid() {
            const ctx = this.ctx;
            const opts = this.options;
            const { angleLines, grid } = opts;
            const labelCount = this._pointLabels.length;
            let i, offset, position;
            if (opts.pointLabels.display) {
              drawPointLabels(this, labelCount);
            }
            if (grid.display) {
              this.ticks.forEach((tick, index3) => {
                if (index3 !== 0) {
                  offset = this.getDistanceFromCenterForValue(tick.value);
                  const optsAtIndex = grid.setContext(this.getContext(index3 - 1));
                  drawRadiusLine(this, optsAtIndex, offset, labelCount);
                }
              });
            }
            if (angleLines.display) {
              ctx.save();
              for (i = labelCount - 1; i >= 0; i--) {
                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                const { color: color2, lineWidth } = optsAtIndex;
                if (!lineWidth || !color2) {
                  continue;
                }
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color2;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
                position = this.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
              }
              ctx.restore();
            }
          }
          drawBorder() {
          }
          drawLabels() {
            const ctx = this.ctx;
            const opts = this.options;
            const tickOpts = opts.ticks;
            if (!tickOpts.display) {
              return;
            }
            const startAngle = this.getIndexAngle(0);
            let offset, width;
            ctx.save();
            ctx.translate(this.xCenter, this.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            this.ticks.forEach((tick, index3) => {
              if (index3 === 0 && !opts.reverse) {
                return;
              }
              const optsAtIndex = tickOpts.setContext(this.getContext(index3));
              const tickFont = toFont(optsAtIndex.font);
              offset = this.getDistanceFromCenterForValue(this.ticks[index3].value);
              if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = toPadding(optsAtIndex.backdropPadding);
                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
              }
              renderText(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color
              });
            });
            ctx.restore();
          }
          drawTitle() {
          }
        }
        RadialLinearScale.id = "radialLinear";
        RadialLinearScale.defaults = {
          display: true,
          animate: true,
          position: "chartArea",
          angleLines: {
            display: true,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
          },
          grid: {
            circular: false
          },
          startAngle: 0,
          ticks: {
            showLabelBackdrop: true,
            callback: Ticks.formatters.numeric
          },
          pointLabels: {
            backdropColor: void 0,
            backdropPadding: 2,
            display: true,
            font: {
              size: 10
            },
            callback(label) {
              return label;
            },
            padding: 5,
            centerPointLabels: false
          }
        };
        RadialLinearScale.defaultRoutes = {
          "angleLines.color": "borderColor",
          "pointLabels.color": "color",
          "ticks.color": "color"
        };
        RadialLinearScale.descriptors = {
          angleLines: {
            _fallback: "grid"
          }
        };
        const INTERVALS = {
          millisecond: { common: true, size: 1, steps: 1e3 },
          second: { common: true, size: 1e3, steps: 60 },
          minute: { common: true, size: 6e4, steps: 60 },
          hour: { common: true, size: 36e5, steps: 24 },
          day: { common: true, size: 864e5, steps: 30 },
          week: { common: false, size: 6048e5, steps: 4 },
          month: { common: true, size: 2628e6, steps: 12 },
          quarter: { common: false, size: 7884e6, steps: 4 },
          year: { common: true, size: 3154e7 }
        };
        const UNITS = Object.keys(INTERVALS);
        function sorter(a, b) {
          return a - b;
        }
        function parse(scale, input) {
          if (isNullOrUndef(input)) {
            return null;
          }
          const adapter = scale._adapter;
          const { parser, round: round2, isoWeekday } = scale._parseOpts;
          let value = input;
          if (typeof parser === "function") {
            value = parser(value);
          }
          if (!isNumberFinite(value)) {
            value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
          }
          if (value === null) {
            return null;
          }
          if (round2) {
            value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
          }
          return +value;
        }
        function determineUnitForAutoTicks(minUnit, min, max, capacity) {
          const ilen = UNITS.length;
          for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            const interval = INTERVALS[UNITS[i]];
            const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
              return UNITS[i];
            }
          }
          return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
          for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
            const unit = UNITS[i];
            if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
              return unit;
            }
          }
          return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
          for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
            if (INTERVALS[UNITS[i]].common) {
              return UNITS[i];
            }
          }
        }
        function addTick(ticks, time, timestamps) {
          if (!timestamps) {
            ticks[time] = true;
          } else if (timestamps.length) {
            const { lo, hi } = _lookup(timestamps, time);
            const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
            ticks[timestamp] = true;
          }
        }
        function setMajorTicks(scale, ticks, map2, majorUnit) {
          const adapter = scale._adapter;
          const first = +adapter.startOf(ticks[0].value, majorUnit);
          const last = ticks[ticks.length - 1].value;
          let major, index3;
          for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
            index3 = map2[major];
            if (index3 >= 0) {
              ticks[index3].major = true;
            }
          }
          return ticks;
        }
        function ticksFromTimestamps(scale, values, majorUnit) {
          const ticks = [];
          const map2 = {};
          const ilen = values.length;
          let i, value;
          for (i = 0; i < ilen; ++i) {
            value = values[i];
            map2[value] = i;
            ticks.push({
              value,
              major: false
            });
          }
          return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
        }
        class TimeScale extends Scale {
          constructor(props) {
            super(props);
            this._cache = {
              data: [],
              labels: [],
              all: []
            };
            this._unit = "day";
            this._majorUnit = void 0;
            this._offsets = {};
            this._normalized = false;
            this._parseOpts = void 0;
          }
          init(scaleOpts, opts) {
            const time = scaleOpts.time || (scaleOpts.time = {});
            const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);
            adapter.init(opts);
            mergeIf(time.displayFormats, adapter.formats());
            this._parseOpts = {
              parser: time.parser,
              round: time.round,
              isoWeekday: time.isoWeekday
            };
            super.init(scaleOpts);
            this._normalized = opts.normalized;
          }
          parse(raw, index3) {
            if (raw === void 0) {
              return null;
            }
            return parse(this, raw);
          }
          beforeLayout() {
            super.beforeLayout();
            this._cache = {
              data: [],
              labels: [],
              all: []
            };
          }
          determineDataLimits() {
            const options = this.options;
            const adapter = this._adapter;
            const unit = options.time.unit || "day";
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            function _applyBounds(bounds) {
              if (!minDefined && !isNaN(bounds.min)) {
                min = Math.min(min, bounds.min);
              }
              if (!maxDefined && !isNaN(bounds.max)) {
                max = Math.max(max, bounds.max);
              }
            }
            if (!minDefined || !maxDefined) {
              _applyBounds(this._getLabelBounds());
              if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
                _applyBounds(this.getMinMax(false));
              }
            }
            min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
            max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
            this.min = Math.min(min, max - 1);
            this.max = Math.max(min + 1, max);
          }
          _getLabelBounds() {
            const arr = this.getLabelTimestamps();
            let min = Number.POSITIVE_INFINITY;
            let max = Number.NEGATIVE_INFINITY;
            if (arr.length) {
              min = arr[0];
              max = arr[arr.length - 1];
            }
            return { min, max };
          }
          buildTicks() {
            const options = this.options;
            const timeOpts = options.time;
            const tickOpts = options.ticks;
            const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
            if (options.bounds === "ticks" && timestamps.length) {
              this.min = this._userMin || timestamps[0];
              this.max = this._userMax || timestamps[timestamps.length - 1];
            }
            const min = this.min;
            const max = this.max;
            const ticks = _filterBetween(timestamps, min, max);
            this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
            this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
            this.initOffsets(timestamps);
            if (options.reverse) {
              ticks.reverse();
            }
            return ticksFromTimestamps(this, ticks, this._majorUnit);
          }
          afterAutoSkip() {
            if (this.options.offsetAfterAutoskip) {
              this.initOffsets(this.ticks.map((tick) => +tick.value));
            }
          }
          initOffsets(timestamps) {
            let start = 0;
            let end = 0;
            let first, last;
            if (this.options.offset && timestamps.length) {
              first = this.getDecimalForValue(timestamps[0]);
              if (timestamps.length === 1) {
                start = 1 - first;
              } else {
                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
              }
              last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
              if (timestamps.length === 1) {
                end = last;
              } else {
                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
              }
            }
            const limit = timestamps.length < 3 ? 0.5 : 0.25;
            start = _limitValue(start, 0, limit);
            end = _limitValue(end, 0, limit);
            this._offsets = { start, end, factor: 1 / (start + 1 + end) };
          }
          _generate() {
            const adapter = this._adapter;
            const min = this.min;
            const max = this.max;
            const options = this.options;
            const timeOpts = options.time;
            const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
            const stepSize = valueOrDefault(timeOpts.stepSize, 1);
            const weekday = minor === "week" ? timeOpts.isoWeekday : false;
            const hasWeekday = isNumber(weekday) || weekday === true;
            const ticks = {};
            let first = min;
            let time, count;
            if (hasWeekday) {
              first = +adapter.startOf(first, "isoWeek", weekday);
            }
            first = +adapter.startOf(first, hasWeekday ? "day" : minor);
            if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
              throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
            }
            const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
            for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
              addTick(ticks, time, timestamps);
            }
            if (time === max || options.bounds === "ticks" || count === 1) {
              addTick(ticks, time, timestamps);
            }
            return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
          }
          getLabelForValue(value) {
            const adapter = this._adapter;
            const timeOpts = this.options.time;
            if (timeOpts.tooltipFormat) {
              return adapter.format(value, timeOpts.tooltipFormat);
            }
            return adapter.format(value, timeOpts.displayFormats.datetime);
          }
          _tickFormatFunction(time, index3, ticks, format) {
            const options = this.options;
            const formats = options.time.displayFormats;
            const unit = this._unit;
            const majorUnit = this._majorUnit;
            const minorFormat = unit && formats[unit];
            const majorFormat = majorUnit && formats[majorUnit];
            const tick = ticks[index3];
            const major = majorUnit && majorFormat && tick && tick.major;
            const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
            const formatter = options.ticks.callback;
            return formatter ? callback(formatter, [label, index3, ticks], this) : label;
          }
          generateTickLabels(ticks) {
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              tick.label = this._tickFormatFunction(tick.value, i, ticks);
            }
          }
          getDecimalForValue(value) {
            return value === null ? NaN : (value - this.min) / (this.max - this.min);
          }
          getPixelForValue(value) {
            const offsets = this._offsets;
            const pos = this.getDecimalForValue(value);
            return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return this.min + pos * (this.max - this.min);
          }
          _getLabelSize(label) {
            const ticksOpts = this.options.ticks;
            const tickLabelWidth = this.ctx.measureText(label).width;
            const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
            const cosRotation = Math.cos(angle);
            const sinRotation = Math.sin(angle);
            const tickFontSize = this._resolveTickFontOptions(0).size;
            return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            };
          }
          _getLabelCapacity(exampleTime) {
            const timeOpts = this.options.time;
            const displayFormats = timeOpts.displayFormats;
            const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
            const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
            const size = this._getLabelSize(exampleLabel);
            const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
            return capacity > 0 ? capacity : 1;
          }
          getDataTimestamps() {
            let timestamps = this._cache.data || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const metas = this.getMatchingVisibleMetas();
            if (this._normalized && metas.length) {
              return this._cache.data = metas[0].controller.getAllParsedValues(this);
            }
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
            }
            return this._cache.data = this.normalize(timestamps);
          }
          getLabelTimestamps() {
            const timestamps = this._cache.labels || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const labels = this.getLabels();
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              timestamps.push(parse(this, labels[i]));
            }
            return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
          }
          normalize(values) {
            return _arrayUnique(values.sort(sorter));
          }
        }
        TimeScale.id = "time";
        TimeScale.defaults = {
          bounds: "data",
          adapters: {},
          time: {
            parser: false,
            unit: false,
            round: false,
            isoWeekday: false,
            minUnit: "millisecond",
            displayFormats: {}
          },
          ticks: {
            source: "auto",
            major: {
              enabled: false
            }
          }
        };
        function interpolate(table, val2, reverse) {
          let lo = 0;
          let hi = table.length - 1;
          let prevSource, nextSource, prevTarget, nextTarget;
          if (reverse) {
            if (val2 >= table[lo].pos && val2 <= table[hi].pos) {
              ({ lo, hi } = _lookupByKey(table, "pos", val2));
            }
            ({ pos: prevSource, time: prevTarget } = table[lo]);
            ({ pos: nextSource, time: nextTarget } = table[hi]);
          } else {
            if (val2 >= table[lo].time && val2 <= table[hi].time) {
              ({ lo, hi } = _lookupByKey(table, "time", val2));
            }
            ({ time: prevSource, pos: prevTarget } = table[lo]);
            ({ time: nextSource, pos: nextTarget } = table[hi]);
          }
          const span = nextSource - prevSource;
          return span ? prevTarget + (nextTarget - prevTarget) * (val2 - prevSource) / span : prevTarget;
        }
        class TimeSeriesScale extends TimeScale {
          constructor(props) {
            super(props);
            this._table = [];
            this._minPos = void 0;
            this._tableRange = void 0;
          }
          initOffsets() {
            const timestamps = this._getTimestampsForTable();
            const table = this._table = this.buildLookupTable(timestamps);
            this._minPos = interpolate(table, this.min);
            this._tableRange = interpolate(table, this.max) - this._minPos;
            super.initOffsets(timestamps);
          }
          buildLookupTable(timestamps) {
            const { min, max } = this;
            const items = [];
            const table = [];
            let i, ilen, prev, curr, next;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
              curr = timestamps[i];
              if (curr >= min && curr <= max) {
                items.push(curr);
              }
            }
            if (items.length < 2) {
              return [
                { time: min, pos: 0 },
                { time: max, pos: 1 }
              ];
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              next = items[i + 1];
              prev = items[i - 1];
              curr = items[i];
              if (Math.round((next + prev) / 2) !== curr) {
                table.push({ time: curr, pos: i / (ilen - 1) });
              }
            }
            return table;
          }
          _getTimestampsForTable() {
            let timestamps = this._cache.all || [];
            if (timestamps.length) {
              return timestamps;
            }
            const data = this.getDataTimestamps();
            const label = this.getLabelTimestamps();
            if (data.length && label.length) {
              timestamps = this.normalize(data.concat(label));
            } else {
              timestamps = data.length ? data : label;
            }
            timestamps = this._cache.all = timestamps;
            return timestamps;
          }
          getDecimalForValue(value) {
            return (interpolate(this._table, value) - this._minPos) / this._tableRange;
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
          }
        }
        TimeSeriesScale.id = "timeseries";
        TimeSeriesScale.defaults = TimeScale.defaults;
        var scales = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          CategoryScale,
          LinearScale,
          LogarithmicScale,
          RadialLinearScale,
          TimeScale,
          TimeSeriesScale
        });
        Chart3.register(controllers, scales, elements, plugins);
        Chart3.helpers = __spreadValues({}, helpers);
        Chart3._adapters = _adapters;
        Chart3.Animation = Animation;
        Chart3.Animations = Animations;
        Chart3.animator = animator;
        Chart3.controllers = registry.controllers.items;
        Chart3.DatasetController = DatasetController;
        Chart3.Element = Element2;
        Chart3.elements = elements;
        Chart3.Interaction = Interaction;
        Chart3.layouts = layouts;
        Chart3.platforms = platforms;
        Chart3.Scale = Scale;
        Chart3.Ticks = Ticks;
        Object.assign(Chart3, controllers, scales, elements, plugins, platforms);
        Chart3.Chart = Chart3;
        if (typeof window !== "undefined") {
          window.Chart = Chart3;
        }
        return Chart3;
      });
    }
  });

  // node_modules/chart.js/helpers/helpers.js
  var require_helpers = __commonJS({
    "node_modules/chart.js/helpers/helpers.js"(exports, module) {
      module.exports = require_chart().helpers;
    }
  });

  // node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.js
  var require_chartjs_plugin_datalabels = __commonJS({
    "node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_helpers(), require_chart()) : typeof define === "function" && define.amd ? define(["chart.js/helpers", "chart.js"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.ChartDataLabels = factory(global2.Chart.helpers, global2.Chart));
      })(exports, function(helpers, chart_js) {
        "use strict";
        var devicePixelRatio = function() {
          if (typeof window !== "undefined") {
            if (window.devicePixelRatio) {
              return window.devicePixelRatio;
            }
            var screen = window.screen;
            if (screen) {
              return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
            }
          }
          return 1;
        }();
        var utils = {
          toTextLines: function(inputs) {
            var lines = [];
            var input;
            inputs = [].concat(inputs);
            while (inputs.length) {
              input = inputs.pop();
              if (typeof input === "string") {
                lines.unshift.apply(lines, input.split("\n"));
              } else if (Array.isArray(input)) {
                inputs.push.apply(inputs, input);
              } else if (!helpers.isNullOrUndef(inputs)) {
                lines.unshift("" + input);
              }
            }
            return lines;
          },
          textSize: function(ctx, lines, font) {
            var items = [].concat(lines);
            var ilen = items.length;
            var prev = ctx.font;
            var width = 0;
            var i;
            ctx.font = font.string;
            for (i = 0; i < ilen; ++i) {
              width = Math.max(ctx.measureText(items[i]).width, width);
            }
            ctx.font = prev;
            return {
              height: ilen * font.lineHeight,
              width
            };
          },
          bound: function(min, value, max) {
            return Math.max(min, Math.min(value, max));
          },
          arrayDiff: function(a0, a1) {
            var prev = a0.slice();
            var updates = [];
            var i, j, ilen, v;
            for (i = 0, ilen = a1.length; i < ilen; ++i) {
              v = a1[i];
              j = prev.indexOf(v);
              if (j === -1) {
                updates.push([v, 1]);
              } else {
                prev.splice(j, 1);
              }
            }
            for (i = 0, ilen = prev.length; i < ilen; ++i) {
              updates.push([prev[i], -1]);
            }
            return updates;
          },
          rasterize: function(v) {
            return Math.round(v * devicePixelRatio) / devicePixelRatio;
          }
        };
        function orient(point, origin) {
          var x0 = origin.x;
          var y0 = origin.y;
          if (x0 === null) {
            return { x: 0, y: -1 };
          }
          if (y0 === null) {
            return { x: 1, y: 0 };
          }
          var dx = point.x - x0;
          var dy = point.y - y0;
          var ln = Math.sqrt(dx * dx + dy * dy);
          return {
            x: ln ? dx / ln : 0,
            y: ln ? dy / ln : -1
          };
        }
        function aligned(x, y, vx, vy, align) {
          switch (align) {
            case "center":
              vx = vy = 0;
              break;
            case "bottom":
              vx = 0;
              vy = 1;
              break;
            case "right":
              vx = 1;
              vy = 0;
              break;
            case "left":
              vx = -1;
              vy = 0;
              break;
            case "top":
              vx = 0;
              vy = -1;
              break;
            case "start":
              vx = -vx;
              vy = -vy;
              break;
            case "end":
              break;
            default:
              align *= Math.PI / 180;
              vx = Math.cos(align);
              vy = Math.sin(align);
              break;
          }
          return {
            x,
            y,
            vx,
            vy
          };
        }
        var R_INSIDE = 0;
        var R_LEFT = 1;
        var R_RIGHT = 2;
        var R_BOTTOM = 4;
        var R_TOP = 8;
        function region(x, y, rect) {
          var res = R_INSIDE;
          if (x < rect.left) {
            res |= R_LEFT;
          } else if (x > rect.right) {
            res |= R_RIGHT;
          }
          if (y < rect.top) {
            res |= R_TOP;
          } else if (y > rect.bottom) {
            res |= R_BOTTOM;
          }
          return res;
        }
        function clipped(segment, area) {
          var x0 = segment.x0;
          var y0 = segment.y0;
          var x1 = segment.x1;
          var y1 = segment.y1;
          var r0 = region(x0, y0, area);
          var r1 = region(x1, y1, area);
          var r, x, y;
          while (true) {
            if (!(r0 | r1) || r0 & r1) {
              break;
            }
            r = r0 || r1;
            if (r & R_TOP) {
              x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);
              y = area.top;
            } else if (r & R_BOTTOM) {
              x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);
              y = area.bottom;
            } else if (r & R_RIGHT) {
              y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);
              x = area.right;
            } else if (r & R_LEFT) {
              y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);
              x = area.left;
            }
            if (r === r0) {
              x0 = x;
              y0 = y;
              r0 = region(x0, y0, area);
            } else {
              x1 = x;
              y1 = y;
              r1 = region(x1, y1, area);
            }
          }
          return {
            x0,
            x1,
            y0,
            y1
          };
        }
        function compute$1(range2, config) {
          var anchor = config.anchor;
          var segment = range2;
          var x, y;
          if (config.clamp) {
            segment = clipped(segment, config.area);
          }
          if (anchor === "start") {
            x = segment.x0;
            y = segment.y0;
          } else if (anchor === "end") {
            x = segment.x1;
            y = segment.y1;
          } else {
            x = (segment.x0 + segment.x1) / 2;
            y = (segment.y0 + segment.y1) / 2;
          }
          return aligned(x, y, range2.vx, range2.vy, config.align);
        }
        var positioners = {
          arc: function(el, config) {
            var angle = (el.startAngle + el.endAngle) / 2;
            var vx = Math.cos(angle);
            var vy = Math.sin(angle);
            var r0 = el.innerRadius;
            var r1 = el.outerRadius;
            return compute$1({
              x0: el.x + vx * r0,
              y0: el.y + vy * r0,
              x1: el.x + vx * r1,
              y1: el.y + vy * r1,
              vx,
              vy
            }, config);
          },
          point: function(el, config) {
            var v = orient(el, config.origin);
            var rx = v.x * el.options.radius;
            var ry = v.y * el.options.radius;
            return compute$1({
              x0: el.x - rx,
              y0: el.y - ry,
              x1: el.x + rx,
              y1: el.y + ry,
              vx: v.x,
              vy: v.y
            }, config);
          },
          bar: function(el, config) {
            var v = orient(el, config.origin);
            var x = el.x;
            var y = el.y;
            var sx = 0;
            var sy = 0;
            if (el.horizontal) {
              x = Math.min(el.x, el.base);
              sx = Math.abs(el.base - el.x);
            } else {
              y = Math.min(el.y, el.base);
              sy = Math.abs(el.base - el.y);
            }
            return compute$1({
              x0: x,
              y0: y + sy,
              x1: x + sx,
              y1: y,
              vx: v.x,
              vy: v.y
            }, config);
          },
          fallback: function(el, config) {
            var v = orient(el, config.origin);
            return compute$1({
              x0: el.x,
              y0: el.y,
              x1: el.x + (el.width || 0),
              y1: el.y + (el.height || 0),
              vx: v.x,
              vy: v.y
            }, config);
          }
        };
        var rasterize = utils.rasterize;
        function boundingRects(model) {
          var borderWidth = model.borderWidth || 0;
          var padding = model.padding;
          var th = model.size.height;
          var tw = model.size.width;
          var tx = -tw / 2;
          var ty = -th / 2;
          return {
            frame: {
              x: tx - padding.left - borderWidth,
              y: ty - padding.top - borderWidth,
              w: tw + padding.width + borderWidth * 2,
              h: th + padding.height + borderWidth * 2
            },
            text: {
              x: tx,
              y: ty,
              w: tw,
              h: th
            }
          };
        }
        function getScaleOrigin(el, context) {
          var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;
          if (!scale) {
            return null;
          }
          if (scale.xCenter !== void 0 && scale.yCenter !== void 0) {
            return { x: scale.xCenter, y: scale.yCenter };
          }
          var pixel = scale.getBasePixel();
          return el.horizontal ? { x: pixel, y: null } : { x: null, y: pixel };
        }
        function getPositioner(el) {
          if (el instanceof chart_js.ArcElement) {
            return positioners.arc;
          }
          if (el instanceof chart_js.PointElement) {
            return positioners.point;
          }
          if (el instanceof chart_js.BarElement) {
            return positioners.bar;
          }
          return positioners.fallback;
        }
        function drawRoundedRect(ctx, x, y, w, h, radius) {
          var HALF_PI = Math.PI / 2;
          if (radius) {
            var r = Math.min(radius, h / 2, w / 2);
            var left = x + r;
            var top = y + r;
            var right = x + w - r;
            var bottom = y + h - r;
            ctx.moveTo(x, top);
            if (left < right && top < bottom) {
              ctx.arc(left, top, r, -Math.PI, -HALF_PI);
              ctx.arc(right, top, r, -HALF_PI, 0);
              ctx.arc(right, bottom, r, 0, HALF_PI);
              ctx.arc(left, bottom, r, HALF_PI, Math.PI);
            } else if (left < right) {
              ctx.moveTo(left, y);
              ctx.arc(right, top, r, -HALF_PI, HALF_PI);
              ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);
            } else if (top < bottom) {
              ctx.arc(left, top, r, -Math.PI, 0);
              ctx.arc(left, bottom, r, 0, Math.PI);
            } else {
              ctx.arc(left, top, r, -Math.PI, Math.PI);
            }
            ctx.closePath();
            ctx.moveTo(x, y);
          } else {
            ctx.rect(x, y, w, h);
          }
        }
        function drawFrame(ctx, rect, model) {
          var bgColor = model.backgroundColor;
          var borderColor = model.borderColor;
          var borderWidth = model.borderWidth;
          if (!bgColor && (!borderColor || !borderWidth)) {
            return;
          }
          ctx.beginPath();
          drawRoundedRect(ctx, rasterize(rect.x) + borderWidth / 2, rasterize(rect.y) + borderWidth / 2, rasterize(rect.w) - borderWidth, rasterize(rect.h) - borderWidth, model.borderRadius);
          ctx.closePath();
          if (bgColor) {
            ctx.fillStyle = bgColor;
            ctx.fill();
          }
          if (borderColor && borderWidth) {
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = "miter";
            ctx.stroke();
          }
        }
        function textGeometry(rect, align, font) {
          var h = font.lineHeight;
          var w = rect.w;
          var x = rect.x;
          var y = rect.y + h / 2;
          if (align === "center") {
            x += w / 2;
          } else if (align === "end" || align === "right") {
            x += w;
          }
          return {
            h,
            w,
            x,
            y
          };
        }
        function drawTextLine(ctx, text, cfg) {
          var shadow = ctx.shadowBlur;
          var stroked = cfg.stroked;
          var x = rasterize(cfg.x);
          var y = rasterize(cfg.y);
          var w = rasterize(cfg.w);
          if (stroked) {
            ctx.strokeText(text, x, y, w);
          }
          if (cfg.filled) {
            if (shadow && stroked) {
              ctx.shadowBlur = 0;
            }
            ctx.fillText(text, x, y, w);
            if (shadow && stroked) {
              ctx.shadowBlur = shadow;
            }
          }
        }
        function drawText(ctx, lines, rect, model) {
          var align = model.textAlign;
          var color = model.color;
          var filled = !!color;
          var font = model.font;
          var ilen = lines.length;
          var strokeColor = model.textStrokeColor;
          var strokeWidth = model.textStrokeWidth;
          var stroked = strokeColor && strokeWidth;
          var i;
          if (!ilen || !filled && !stroked) {
            return;
          }
          rect = textGeometry(rect, align, font);
          ctx.font = font.string;
          ctx.textAlign = align;
          ctx.textBaseline = "middle";
          ctx.shadowBlur = model.textShadowBlur;
          ctx.shadowColor = model.textShadowColor;
          if (filled) {
            ctx.fillStyle = color;
          }
          if (stroked) {
            ctx.lineJoin = "round";
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
          }
          for (i = 0, ilen = lines.length; i < ilen; ++i) {
            drawTextLine(ctx, lines[i], {
              stroked,
              filled,
              w: rect.w,
              x: rect.x,
              y: rect.y + rect.h * i
            });
          }
        }
        var Label = function(config, ctx, el, index2) {
          var me = this;
          me._config = config;
          me._index = index2;
          me._model = null;
          me._rects = null;
          me._ctx = ctx;
          me._el = el;
        };
        helpers.merge(Label.prototype, {
          _modelize: function(display, lines, config, context) {
            var me = this;
            var index2 = me._index;
            var font = helpers.toFont(helpers.resolve([config.font, {}], context, index2));
            var color = helpers.resolve([config.color, chart_js.defaults.color], context, index2);
            return {
              align: helpers.resolve([config.align, "center"], context, index2),
              anchor: helpers.resolve([config.anchor, "center"], context, index2),
              area: context.chart.chartArea,
              backgroundColor: helpers.resolve([config.backgroundColor, null], context, index2),
              borderColor: helpers.resolve([config.borderColor, null], context, index2),
              borderRadius: helpers.resolve([config.borderRadius, 0], context, index2),
              borderWidth: helpers.resolve([config.borderWidth, 0], context, index2),
              clamp: helpers.resolve([config.clamp, false], context, index2),
              clip: helpers.resolve([config.clip, false], context, index2),
              color,
              display,
              font,
              lines,
              offset: helpers.resolve([config.offset, 4], context, index2),
              opacity: helpers.resolve([config.opacity, 1], context, index2),
              origin: getScaleOrigin(me._el, context),
              padding: helpers.toPadding(helpers.resolve([config.padding, 4], context, index2)),
              positioner: getPositioner(me._el),
              rotation: helpers.resolve([config.rotation, 0], context, index2) * (Math.PI / 180),
              size: utils.textSize(me._ctx, lines, font),
              textAlign: helpers.resolve([config.textAlign, "start"], context, index2),
              textShadowBlur: helpers.resolve([config.textShadowBlur, 0], context, index2),
              textShadowColor: helpers.resolve([config.textShadowColor, color], context, index2),
              textStrokeColor: helpers.resolve([config.textStrokeColor, color], context, index2),
              textStrokeWidth: helpers.resolve([config.textStrokeWidth, 0], context, index2)
            };
          },
          update: function(context) {
            var me = this;
            var model = null;
            var rects = null;
            var index2 = me._index;
            var config = me._config;
            var value, label, lines;
            var display = helpers.resolve([config.display, true], context, index2);
            if (display) {
              value = context.dataset.data[index2];
              label = helpers.valueOrDefault(helpers.callback(config.formatter, [value, context]), value);
              lines = helpers.isNullOrUndef(label) ? [] : utils.toTextLines(label);
              if (lines.length) {
                model = me._modelize(display, lines, config, context);
                rects = boundingRects(model);
              }
            }
            me._model = model;
            me._rects = rects;
          },
          geometry: function() {
            return this._rects ? this._rects.frame : {};
          },
          rotation: function() {
            return this._model ? this._model.rotation : 0;
          },
          visible: function() {
            return this._model && this._model.opacity;
          },
          model: function() {
            return this._model;
          },
          draw: function(chart2, center) {
            var me = this;
            var ctx = chart2.ctx;
            var model = me._model;
            var rects = me._rects;
            var area;
            if (!this.visible()) {
              return;
            }
            ctx.save();
            if (model.clip) {
              area = model.area;
              ctx.beginPath();
              ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
              ctx.clip();
            }
            ctx.globalAlpha = utils.bound(0, model.opacity, 1);
            ctx.translate(rasterize(center.x), rasterize(center.y));
            ctx.rotate(model.rotation);
            drawFrame(ctx, rects.frame, model);
            drawText(ctx, model.lines, rects.text, model);
            ctx.restore();
          }
        });
        var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
        var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        function rotated(point, center, angle) {
          var cos = Math.cos(angle);
          var sin = Math.sin(angle);
          var cx = center.x;
          var cy = center.y;
          return {
            x: cx + cos * (point.x - cx) - sin * (point.y - cy),
            y: cy + sin * (point.x - cx) + cos * (point.y - cy)
          };
        }
        function projected(points, axis) {
          var min = MAX_INTEGER;
          var max = MIN_INTEGER;
          var origin = axis.origin;
          var i, pt, vx, vy, dp;
          for (i = 0; i < points.length; ++i) {
            pt = points[i];
            vx = pt.x - origin.x;
            vy = pt.y - origin.y;
            dp = axis.vx * vx + axis.vy * vy;
            min = Math.min(min, dp);
            max = Math.max(max, dp);
          }
          return {
            min,
            max
          };
        }
        function toAxis(p0, p1) {
          var vx = p1.x - p0.x;
          var vy = p1.y - p0.y;
          var ln = Math.sqrt(vx * vx + vy * vy);
          return {
            vx: (p1.x - p0.x) / ln,
            vy: (p1.y - p0.y) / ln,
            origin: p0,
            ln
          };
        }
        var HitBox = function() {
          this._rotation = 0;
          this._rect = {
            x: 0,
            y: 0,
            w: 0,
            h: 0
          };
        };
        helpers.merge(HitBox.prototype, {
          center: function() {
            var r = this._rect;
            return {
              x: r.x + r.w / 2,
              y: r.y + r.h / 2
            };
          },
          update: function(center, rect, rotation) {
            this._rotation = rotation;
            this._rect = {
              x: rect.x + center.x,
              y: rect.y + center.y,
              w: rect.w,
              h: rect.h
            };
          },
          contains: function(point) {
            var me = this;
            var margin = 1;
            var rect = me._rect;
            point = rotated(point, me.center(), -me._rotation);
            return !(point.x < rect.x - margin || point.y < rect.y - margin || point.x > rect.x + rect.w + margin * 2 || point.y > rect.y + rect.h + margin * 2);
          },
          intersects: function(other) {
            var r0 = this._points();
            var r1 = other._points();
            var axes = [
              toAxis(r0[0], r0[1]),
              toAxis(r0[0], r0[3])
            ];
            var i, pr0, pr1;
            if (this._rotation !== other._rotation) {
              axes.push(toAxis(r1[0], r1[1]), toAxis(r1[0], r1[3]));
            }
            for (i = 0; i < axes.length; ++i) {
              pr0 = projected(r0, axes[i]);
              pr1 = projected(r1, axes[i]);
              if (pr0.max < pr1.min || pr1.max < pr0.min) {
                return false;
              }
            }
            return true;
          },
          _points: function() {
            var me = this;
            var rect = me._rect;
            var angle = me._rotation;
            var center = me.center();
            return [
              rotated({ x: rect.x, y: rect.y }, center, angle),
              rotated({ x: rect.x + rect.w, y: rect.y }, center, angle),
              rotated({ x: rect.x + rect.w, y: rect.y + rect.h }, center, angle),
              rotated({ x: rect.x, y: rect.y + rect.h }, center, angle)
            ];
          }
        });
        function coordinates(el, model, geometry) {
          var point = model.positioner(el, model);
          var vx = point.vx;
          var vy = point.vy;
          if (!vx && !vy) {
            return { x: point.x, y: point.y };
          }
          var w = geometry.w;
          var h = geometry.h;
          var rotation = model.rotation;
          var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));
          var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));
          var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
          dx *= vx * vs;
          dy *= vy * vs;
          dx += model.offset * vx;
          dy += model.offset * vy;
          return {
            x: point.x + dx,
            y: point.y + dy
          };
        }
        function collide(labels, collider) {
          var i, j, s0, s1;
          for (i = labels.length - 1; i >= 0; --i) {
            s0 = labels[i].$layout;
            for (j = i - 1; j >= 0 && s0._visible; --j) {
              s1 = labels[j].$layout;
              if (s1._visible && s0._box.intersects(s1._box)) {
                collider(s0, s1);
              }
            }
          }
          return labels;
        }
        function compute(labels) {
          var i, ilen, label, state, geometry, center, proxy;
          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            label = labels[i];
            state = label.$layout;
            if (state._visible) {
              proxy = new Proxy(label._el, { get: (el, p) => el.getProps([p], true)[p] });
              geometry = label.geometry();
              center = coordinates(proxy, label.model(), geometry);
              state._box.update(center, geometry, label.rotation());
            }
          }
          return collide(labels, function(s0, s1) {
            var h0 = s0._hidable;
            var h1 = s1._hidable;
            if (h0 && h1 || h1) {
              s1._visible = false;
            } else if (h0) {
              s0._visible = false;
            }
          });
        }
        var layout = {
          prepare: function(datasets) {
            var labels = [];
            var i, j, ilen, jlen, label;
            for (i = 0, ilen = datasets.length; i < ilen; ++i) {
              for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {
                label = datasets[i][j];
                labels.push(label);
                label.$layout = {
                  _box: new HitBox(),
                  _hidable: false,
                  _visible: true,
                  _set: i,
                  _idx: label._index
                };
              }
            }
            labels.sort(function(a, b) {
              var sa = a.$layout;
              var sb = b.$layout;
              return sa._idx === sb._idx ? sb._set - sa._set : sb._idx - sa._idx;
            });
            this.update(labels);
            return labels;
          },
          update: function(labels) {
            var dirty = false;
            var i, ilen, label, model, state;
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              label = labels[i];
              model = label.model();
              state = label.$layout;
              state._hidable = model && model.display === "auto";
              state._visible = label.visible();
              dirty |= state._hidable;
            }
            if (dirty) {
              compute(labels);
            }
          },
          lookup: function(labels, point) {
            var i, state;
            for (i = labels.length - 1; i >= 0; --i) {
              state = labels[i].$layout;
              if (state && state._visible && state._box.contains(point)) {
                return labels[i];
              }
            }
            return null;
          },
          draw: function(chart2, labels) {
            var i, ilen, label, state, geometry, center;
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              label = labels[i];
              state = label.$layout;
              if (state._visible) {
                geometry = label.geometry();
                center = coordinates(label._el, label.model(), geometry);
                state._box.update(center, geometry, label.rotation());
                label.draw(chart2, center);
              }
            }
          }
        };
        var formatter = function(value) {
          if (helpers.isNullOrUndef(value)) {
            return null;
          }
          var label = value;
          var keys, klen, k;
          if (helpers.isObject(value)) {
            if (!helpers.isNullOrUndef(value.label)) {
              label = value.label;
            } else if (!helpers.isNullOrUndef(value.r)) {
              label = value.r;
            } else {
              label = "";
              keys = Object.keys(value);
              for (k = 0, klen = keys.length; k < klen; ++k) {
                label += (k !== 0 ? ", " : "") + keys[k] + ": " + value[keys[k]];
              }
            }
          }
          return "" + label;
        };
        var defaults = {
          align: "center",
          anchor: "center",
          backgroundColor: null,
          borderColor: null,
          borderRadius: 0,
          borderWidth: 0,
          clamp: false,
          clip: false,
          color: void 0,
          display: true,
          font: {
            family: void 0,
            lineHeight: 1.2,
            size: void 0,
            style: void 0,
            weight: null
          },
          formatter,
          labels: void 0,
          listeners: {},
          offset: 4,
          opacity: 1,
          padding: {
            top: 4,
            right: 4,
            bottom: 4,
            left: 4
          },
          rotation: 0,
          textAlign: "start",
          textStrokeColor: void 0,
          textStrokeWidth: 0,
          textShadowBlur: 0,
          textShadowColor: void 0
        };
        var EXPANDO_KEY = "$datalabels";
        var DEFAULT_KEY = "$default";
        function configure(dataset, options) {
          var override = dataset.datalabels;
          var listeners = {};
          var configs = [];
          var labels, keys;
          if (override === false) {
            return null;
          }
          if (override === true) {
            override = {};
          }
          options = helpers.merge({}, [options, override]);
          labels = options.labels || {};
          keys = Object.keys(labels);
          delete options.labels;
          if (keys.length) {
            keys.forEach(function(key) {
              if (labels[key]) {
                configs.push(helpers.merge({}, [
                  options,
                  labels[key],
                  { _key: key }
                ]));
              }
            });
          } else {
            configs.push(options);
          }
          listeners = configs.reduce(function(target, config) {
            helpers.each(config.listeners || {}, function(fn, event) {
              target[event] = target[event] || {};
              target[event][config._key || DEFAULT_KEY] = fn;
            });
            delete config.listeners;
            return target;
          }, {});
          return {
            labels: configs,
            listeners
          };
        }
        function dispatchEvent(chart2, listeners, label, event) {
          if (!listeners) {
            return;
          }
          var context = label.$context;
          var groups = label.$groups;
          var callback;
          if (!listeners[groups._set]) {
            return;
          }
          callback = listeners[groups._set][groups._key];
          if (!callback) {
            return;
          }
          if (helpers.callback(callback, [context, event]) === true) {
            chart2[EXPANDO_KEY]._dirty = true;
            label.update(context);
          }
        }
        function dispatchMoveEvents(chart2, listeners, previous, label, event) {
          var enter, leave;
          if (!previous && !label) {
            return;
          }
          if (!previous) {
            enter = true;
          } else if (!label) {
            leave = true;
          } else if (previous !== label) {
            leave = enter = true;
          }
          if (leave) {
            dispatchEvent(chart2, listeners.leave, previous, event);
          }
          if (enter) {
            dispatchEvent(chart2, listeners.enter, label, event);
          }
        }
        function handleMoveEvents(chart2, event) {
          var expando = chart2[EXPANDO_KEY];
          var listeners = expando._listeners;
          var previous, label;
          if (!listeners.enter && !listeners.leave) {
            return;
          }
          if (event.type === "mousemove") {
            label = layout.lookup(expando._labels, event);
          } else if (event.type !== "mouseout") {
            return;
          }
          previous = expando._hovered;
          expando._hovered = label;
          dispatchMoveEvents(chart2, listeners, previous, label, event);
        }
        function handleClickEvents(chart2, event) {
          var expando = chart2[EXPANDO_KEY];
          var handlers = expando._listeners.click;
          var label = handlers && layout.lookup(expando._labels, event);
          if (label) {
            dispatchEvent(chart2, handlers, label, event);
          }
        }
        var plugin = {
          id: "datalabels",
          defaults,
          beforeInit: function(chart2) {
            chart2[EXPANDO_KEY] = {
              _actives: []
            };
          },
          beforeUpdate: function(chart2) {
            var expando = chart2[EXPANDO_KEY];
            expando._listened = false;
            expando._listeners = {};
            expando._datasets = [];
            expando._labels = [];
          },
          afterDatasetUpdate: function(chart2, args, options) {
            var datasetIndex = args.index;
            var expando = chart2[EXPANDO_KEY];
            var labels = expando._datasets[datasetIndex] = [];
            var visible = chart2.isDatasetVisible(datasetIndex);
            var dataset = chart2.data.datasets[datasetIndex];
            var config = configure(dataset, options);
            var elements = args.meta.data || [];
            var ctx = chart2.ctx;
            var i, j, ilen, jlen, cfg, key, el, label;
            ctx.save();
            for (i = 0, ilen = elements.length; i < ilen; ++i) {
              el = elements[i];
              el[EXPANDO_KEY] = [];
              if (visible && el && chart2.getDataVisibility(i) && !el.skip) {
                for (j = 0, jlen = config.labels.length; j < jlen; ++j) {
                  cfg = config.labels[j];
                  key = cfg._key;
                  label = new Label(cfg, ctx, el, i);
                  label.$groups = {
                    _set: datasetIndex,
                    _key: key || DEFAULT_KEY
                  };
                  label.$context = {
                    active: false,
                    chart: chart2,
                    dataIndex: i,
                    dataset,
                    datasetIndex
                  };
                  label.update(label.$context);
                  el[EXPANDO_KEY].push(label);
                  labels.push(label);
                }
              }
            }
            ctx.restore();
            helpers.merge(expando._listeners, config.listeners, {
              merger: function(event, target, source) {
                target[event] = target[event] || {};
                target[event][args.index] = source[event];
                expando._listened = true;
              }
            });
          },
          afterUpdate: function(chart2) {
            chart2[EXPANDO_KEY]._labels = layout.prepare(chart2[EXPANDO_KEY]._datasets);
          },
          afterDatasetsDraw: function(chart2) {
            layout.draw(chart2, chart2[EXPANDO_KEY]._labels);
          },
          beforeEvent: function(chart2, args) {
            if (chart2[EXPANDO_KEY]._listened) {
              var event = args.event;
              switch (event.type) {
                case "mousemove":
                case "mouseout":
                  handleMoveEvents(chart2, event);
                  break;
                case "click":
                  handleClickEvents(chart2, event);
                  break;
              }
            }
          },
          afterEvent: function(chart2) {
            var expando = chart2[EXPANDO_KEY];
            var previous = expando._actives;
            var actives = expando._actives = chart2.getActiveElements();
            var updates = utils.arrayDiff(previous, actives);
            var i, ilen, j, jlen, update, label, labels;
            for (i = 0, ilen = updates.length; i < ilen; ++i) {
              update = updates[i];
              if (update[1]) {
                labels = update[0].element[EXPANDO_KEY] || [];
                for (j = 0, jlen = labels.length; j < jlen; ++j) {
                  label = labels[j];
                  label.$context.active = update[1] === 1;
                  label.update(label.$context);
                }
              }
            }
            if (expando._dirty || updates.length) {
              layout.update(expando._labels);
              chart2.render();
            }
            delete expando._dirty;
          }
        };
        return plugin;
      });
    }
  });

  // node_modules/bootstrap-icons/font/bootstrap-icons.css
  var require_ = __commonJS({
    "node_modules/bootstrap-icons/font/bootstrap-icons.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/material-icons/iconfont/material-icons.css
  var require_2 = __commonJS({
    "node_modules/material-icons/iconfont/material-icons.css"(exports, module) {
      module.exports = {};
    }
  });

  // js/app.js
  var import_tom_select2 = __toModule(require_tom_select_complete());

  // js/tom_select_saisie_page.js
  var import_tom_select = __toModule(require_tom_select_complete());
  function saveRow(icon) {
    const row = icon.closest("tr");
    const inputs = row.querySelectorAll("input, select");
    const rowData = {};
    inputs.forEach((input) => {
      rowData[input.name] = input.value;
    });
    console.log("Donn\xE9es \xE0 sauvegarder:", rowData);
    const csrfToken2 = document.querySelector('meta[name="csrf-token"]').getAttribute("content");
    fetch("/save_saisie", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRF-Token": csrfToken2
      },
      body: JSON.stringify(rowData)
    }).then((response) => {
      console.log(" response : ", response);
      if (!response.ok) {
        throw new Error("Erreur lors de la sauvegarde des donn\xE9es");
      }
      return response.json();
    }).then((data) => {
      console.log("Succ\xE8s:", data.message);
      window.location.reload();
    }).catch((error) => {
      console.error("Erreur :", error);
      alert("Une erreur est survenue lors de la sauvegarde. Veuillez v\xE9rifier que tous les champs sont bien remplis et au bon format");
    });
  }
  function removeRow(icon) {
    icon.closest("tr").remove();
  }
  function isDecimalValid(inputValue) {
    const numericValue = parseFloat(inputValue);
    return !isNaN(numericValue) && numericValue >= 0 && numericValue <= 20;
  }
  function isLabelValid(inputValue) {
    return inputValue.trim() !== "" && inputValue.length <= 255;
  }
  function isProjectIdValid(value) {
    return value.trim() !== "";
  }
  function isTaskValid(selectedTask) {
    return selectedTask !== "";
  }
  function handleDecimalInput(event) {
    if (this.value.includes("+") || this.value.includes("-")) {
      const formattedValue = stringFormat.replace(/[+-]/g, "");
      this.value = formattedValue;
    }
    if (!isDecimalValid(this.value)) {
      this.style.borderColor = "red";
    } else {
      const decimalLength = (this.value.split(".")[1] || "").length;
      console.log(decimalLength);
      if (decimalLength > 2) {
        valeur = parseFloat(this.value).toFixed(2);
        this.value = valeur;
      }
      this.style.borderColor = "green";
    }
  }
  function handleLabelInput(event) {
    if (!isLabelValid(this.value)) {
      this.style.borderColor = "red";
    } else {
      this.style.borderColor = "green";
    }
  }
  function handleProjectSelectChange(event, task_tom_select2) {
    const projectElement = document.querySelector(".project_id");
    const tsControlElement = projectElement.querySelector(".ts-control");
    const selectedProjectId = event.target.value;
    if (!isProjectIdValid(selectedProjectId)) {
      console.log("makato amin red");
      tsControlElement.style.borderColor = "red";
    } else {
      console.log("makato amin green");
      tsControlElement.style.borderColor = "green";
    }
    updateTaskOptions(selectedProjectId, task_tom_select2);
  }
  function handleTaskSelectChange(event) {
    const taskElement = document.querySelector(".task");
    const tsControlElement = taskElement.querySelector(".ts-control");
    const selectedTask = event.target.value;
    if (!isTaskValid(selectedTask)) {
      console.log("La t\xE2che s\xE9lectionn\xE9e est invalide");
      tsControlElement.style.borderColor = "red";
    } else {
      console.log("La t\xE2che s\xE9lectionn\xE9e est valide");
      tsControlElement.style.borderColor = "green";
    }
  }
  function applyFieldValidations(tableBody) {
    const taskElement = tableBody.querySelector(".task");
    const tsControlElement1 = taskElement.querySelector(".ts-control");
    tsControlElement1.style.borderColor = "red";
    const projectElement = tableBody.querySelector(".project_id");
    const tsControlElement = projectElement.querySelector(".ts-control");
    tsControlElement.style.borderColor = "red";
    const labelInput = tableBody.querySelector('tr:last-child input[name="labels"]');
    labelInput.style.borderColor = "red";
  }
  function lineValidation(tableBody) {
    const labelInput = tableBody.querySelector('tr:last-child input[name="labels"]');
    const taskSelect = tableBody.querySelector('tr:last-child select[name="task"]');
    const projectSelect = tableBody.querySelector('tr:last-child select[name="project_id"]');
    const decimalInput = tableBody.querySelector('tr:last-child input[name="hours"]');
    const isLabelValidResult = isLabelValid(labelInput.value);
    const isTaskValidResult = isTaskValid(taskSelect.value);
    const isProjectIdValidResult = isProjectIdValid(projectSelect.value);
    const isDecimalValidResult = isDecimalValid(decimalInput.value);
    return isLabelValidResult && isTaskValidResult && isProjectIdValidResult && isDecimalValidResult;
  }
  function haveLineNotSaved(tableBody) {
    const newTaskSelect = tableBody.querySelector('tr:last-child select[name="task"]');
    if (newTaskSelect != null)
      return true;
    else
      return false;
  }
  function addRow(tableBody, TomSelect4, userId, date, username, projects) {
    const newRow = `
        <tr>
            <input type="hidden" name="user_id" value="${userId}">
            <td class="date"><input type="date" name="date" value="${date}"></td>
            <td class="user"><input type="text" name="user" value="${username}" readonly></td>
            <td class="project_id">
                <select name="project_id" id="tom_select">
                    <option value="">S\xE9lectionner un projet</option>
                    ${projects.map((project) => `<option value="${project.id}">${project.title}</option>`).join("")}
                </select>
            </td>
            <td class="client">
                <input type="text" name="client_name" value="" readonly>
            </td>
            <td class="task">
                <select name="task" id="tasks_select" placeholder="S\xE9lectioner une t\xE2che"></select>
            </td>
            <td class="labels"><input type="text" name="labels" placeholder="Libell\xE9"></td>
            <td class="temps">
                <input type="number" id="decimal_input" name="hours" step="0.1" value="0.0">
            </td>
            <td class="actions">
                <i title="Sauvegarder" class="bi bi-save" style="cursor: pointer;"></i>
                <i title="Supprimer" id="suppr" class="bi bi-trash" style="cursor: pointer;" ></i>
            </td>
        </tr>
    `;
    tableBody.insertAdjacentHTML("beforeend", newRow);
    const newProjectSelect = tableBody.querySelector('tr:last-child select[name="project_id"]');
    new TomSelect4(newProjectSelect, {
      searchable: true,
      sortField: {
        field: "text",
        direction: "asc"
      }
    });
    const newTaskSelect = tableBody.querySelector('tr:last-child select[name="task"]');
    newTaskSelect.addEventListener("change", handleTaskSelectChange);
    task_tom_select = new TomSelect4(newTaskSelect, {
      searchable: true,
      sortField: {
        field: "text",
        direction: "asc"
      }
    });
    applyFieldValidations(tableBody);
    const projectSelect = document.querySelector('select[name="project_id"]');
    projectSelect.addEventListener("change", function(event) {
      handleProjectSelectChange(event, task_tom_select);
    });
    const decimalInput = tableBody.querySelector('tr:last-child input[name="hours"]');
    decimalInput.addEventListener("input", handleDecimalInput);
    const labelInput = tableBody.querySelector('tr:last-child input[name="labels"]');
    labelInput.addEventListener("input", handleLabelInput);
    const newSaveIcon = tableBody.querySelector(".bi-save");
    newSaveIcon.addEventListener("click", function() {
      const isValid = lineValidation(tableBody);
      if (isValid) {
        saveRow(newSaveIcon);
      } else {
        console.log("Les champs ne sont pas valides. Veuillez v\xE9rifier vos saisies.");
      }
    });
    const newRemoveIcon = tableBody.querySelector("#suppr");
    console.log(newRemoveIcon);
    newRemoveIcon.addEventListener("click", function() {
      removeRow(newRemoveIcon);
      resetAddRowIcon();
    });
  }
  function updateTaskOptions(selectedProjectId, taskTomSelect) {
    fetch(`/tasks/${selectedProjectId}`).then((response) => {
      console.log(response);
      if (!response.ok) {
        throw new Error("Erreur lors de la r\xE9cup\xE9ration des t\xE2ches");
      }
      return response.json();
    }).then((data) => {
      console.log(data);
      const tasks = data.tasks;
      taskTomSelect.clear();
      taskTomSelect.clearOptions();
      tasks.forEach((task) => {
        taskTomSelect.addOption({ value: task.id, text: task.title });
      });
      const clientDetails = data.client_details;
      const clientNameInput = document.querySelector('input[name="client_name"]');
      clientNameInput.value = clientDetails.clients_name;
    }).catch((error) => {
      const clientNameInput = document.querySelector('input[name="client_name"]');
      clientNameInput.value = "";
      taskTomSelect.clear();
      taskTomSelect.clearOptions();
      console.log(taskTomSelect);
      console.error("Erreur :", error);
    });
  }
  function resetAddRowIcon() {
    var addRowLink = document.getElementById("addRowIcon");
    var addRowIcon = document.querySelector("#addRowIcon i");
    addRowLink.classList.remove("non-cliquable");
    addRowIcon.style.cursor = "pointer";
  }

  // js/app.js
  var import_tom_select3 = __toModule(require_tom_select_complete());

  // js/showing_task.js
  var authorizedInputs = {
    Admin: [
      "task_title",
      "task_description",
      "parent_task",
      "assigned_person",
      "due_date",
      "start_date",
      "original_estimate",
      "progress",
      "save",
      "curr_user",
      "pro_id",
      "status_id",
      "priority_id",
      "task_deadline"
    ],
    Attributeur: [
      "task_title",
      "task_description",
      "parent_task",
      "assigned_person",
      "due_date",
      "start_date",
      "original_estimate",
      "progress",
      "save",
      "curr_user",
      "pro_id",
      "status_id",
      "priority_id",
      "task_deadline"
    ],
    Contributeur: [
      "task_title",
      "task_description",
      "progress",
      "save",
      "curr_user",
      "pro_id",
      "status_id",
      "priority_id",
      "task_deadline"
    ]
  };
  function toggleInputs(profile) {
    const inputs = document.querySelectorAll("input, textarea, select");
    const profileInputs = authorizedInputs[profile];
    inputs.forEach(function(input) {
      if (profileInputs && profileInputs.includes(input.name)) {
        input.removeAttribute("disabled");
      } else {
        input.disabled = true;
      }
    });
  }
  function isFirstDateBeforeSecondDate(date1, date2) {
    var firstDate = new Date(date1);
    var secondDate = new Date(date2);
    return firstDate < secondDate;
  }
  function desactivateAllinputs() {
    var mainDiv = document.getElementById("showing_task");
    var inputs = mainDiv.querySelectorAll("input, textarea, select");
    inputs.forEach(function(input) {
      input.disabled = true;
    });
  }
  function handleClickOnModifBtn(profile) {
    var saveBtn = document.getElementById("save");
    var cancelBtn = document.getElementById("cancel");
    var modifBtn = document.getElementById("modify");
    saveBtn.style.display = "inline-block";
    saveBtn.style.cursor = "pointer";
    cancelBtn.style.display = "inline-block";
    cancelBtn.style.cursor = "pointer";
    modifBtn.style.display = "contents";
    modifBtn.style.cursor = "default";
    toggleInputs(profile);
  }
  function handleClickOnCancelBtn() {
    var saveBtn = document.getElementById("save");
    var cancelBtn = document.getElementById("cancel");
    var modifBtn = document.getElementById("modify");
    saveBtn.style.display = "contents";
    saveBtn.style.cursor = "default";
    cancelBtn.style.display = "contents";
    cancelBtn.style.cursor = "default";
    modifBtn.style.display = "inline-block";
    modifBtn.style.cursor = "pointer";
    desactivateAllinputs();
  }
  function validateProgressInput(value) {
    if (!isNaN(value)) {
      if (value >= 0 && value <= 100) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
  function validateDateInputs() {
    var startDateInput = document.getElementById("start_date");
    var dueDateInput = document.getElementById("due_date");
    var startDateValue = startDateInput.value;
    var dueDateValue = dueDateInput.value;
    document.getElementById("start_date_error").textContent = "La date d'\xE9ch\xE9ance ne peut pas \xEAtre ant\xE9rieure \xE0 la date de d\xE9but";
    document.getElementById("start_date_error").style.visibility = "hidden";
    document.getElementById("due_date_error").textContent = "La date d'\xE9ch\xE9ance ne peut pas \xEAtre ant\xE9rieure \xE0 la date de d\xE9but";
    document.getElementById("due_date_error").style.visibility = "hidden";
    if (!startDateValue) {
      document.getElementById("start_date_error").textContent = "Veuillez entrer une date de d\xE9but";
      document.getElementById("start_date_error").style.visibility = "";
      return false;
    }
    if (!dueDateValue) {
      document.getElementById("due_date_error").textContent = "Veuillez entrer une date d'\xE9ch\xE9ance";
      document.getElementById("due_date_error").style.visibility = "";
      return false;
    }
    if (isNaN(Date.parse(startDateValue))) {
      document.getElementById("start_date_error").textContent = "Format de date invalide";
      document.getElementById("start_date_error").style.visibility = "";
      return false;
    }
    if (isNaN(Date.parse(dueDateValue))) {
      document.getElementById("due_date_error").textContent = "Format de date invalide";
      document.getElementById("due_date_error").style.visibility = "";
      return false;
    }
    if (isFirstDateBeforeSecondDate(dueDateValue, startDateValue)) {
      document.getElementById("due_date_error").textContent = "La date d'\xE9ch\xE9ance ne peut pas \xEAtre ant\xE9rieure \xE0 la date de d\xE9but";
      document.getElementById("due_date_error").style.visibility = "";
      return false;
    }
    return true;
  }
  function formatNumberInput(value) {
    return value.replace(/\D/g, "");
  }
  function handleProgressInput(event) {
    formated_value = formatNumberInput(this.value);
    is_valid = validateProgressInput(this.value);
    if (is_valid) {
      this.value = formated_value;
    } else
      this.value = "";
  }
  function handleDateInputChange(event) {
    var input = event.target;
    console.log("makato");
    console.log(validateDateInputs());
  }
  function handleEstimationInput(event) {
    let filtredval = this.value.replace(/[^0-9.]/g, "");
    console.log(filtredval);
    val = parseFloat(filtredval);
    console.log(isNaN(val), val, filtredval);
    if (!isNaN(val) || val > 0) {
      console.log(filtredval);
      let decimalLength = (filtredval.split(".")[1] || "").length;
      if (decimalLength > 2) {
        valeur = parseFloat(filtredval).toFixed(2);
        this.value = valeur;
      }
    } else
      this.value = "";
  }
  function loadButtonAction(profile) {
    var modifBtn = document.getElementById("modify");
    modifBtn.addEventListener("click", function() {
      handleClickOnModifBtn(profile);
    });
    var cancelBtn = document.getElementById("cancel");
    cancelBtn.addEventListener("click", function() {
      handleClickOnCancelBtn();
    });
  }
  function loadAllInputsEvent() {
    var progressInput = document.getElementById("progress");
    progressInput.addEventListener("input", handleProgressInput);
    var startDateInput = document.getElementById("start_date");
    var dueDateInput = document.getElementById("due_date");
    var estimationInput = document.getElementById("estimation_val");
    console.log(estimationInput);
    estimationInput.addEventListener("input", handleEstimationInput);
    startDateInput.addEventListener("change", handleDateInputChange);
    dueDateInput.addEventListener("change", handleDateInputChange);
  }
  function showTask(profile) {
    var saveBtn = document.getElementById("save");
    saveBtn.style.display = "contents";
    loadButtonAction(profile);
    loadAllInputsEvent();
  }

  // ../deps/phoenix_html/priv/static/phoenix_html.js
  "use strict";
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent2(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent2.prototype = window.Event.prototype;
      return CustomEvent2;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), submit = document.createElement("input"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to;
      form.style.display = "none";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      submit.type = "submit";
      form.appendChild(submit);
      submit.click();
    }
    window.addEventListener("click", function(e) {
      var element = e.target;
      if (e.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method")) {
          handleClick(element, e.metaKey || e.shiftKey);
          e.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e) {
      var message = e.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e.preventDefault();
      }
    }, false);
  })();

  // ../deps/phoenix/priv/static/phoenix.mjs
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global = globalSelf || phxWindow || global;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event, payload, timeout) {
      this.channel = channel;
      this.event = event;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    receive(status, callback) {
      if (this.hasReceived(status)) {
        callback(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback });
      return this;
    }
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback, timerCalc) {
      this.callback = callback;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(this.socket.onOpen(() => {
        this.rejoinTimer.reset();
        if (this.isErrored()) {
          this.rejoin();
        }
      }));
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    onClose(callback) {
      this.on(CHANNEL_EVENTS.close, callback);
    }
    onError(callback) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
    }
    on(event, callback) {
      let ref = this.bindingRef++;
      this.bindings.push({ event, ref, callback });
      return ref;
    }
    off(event, ref) {
      this.bindings = this.bindings.filter((bind) => {
        return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
      });
    }
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    push(event, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    onMessage(_event, payload, _ref) {
      return payload;
    }
    isMember(topic, event, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    joinRef() {
      return this.joinPush.ref;
    }
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    trigger(event, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind) => bind.event === event);
      for (let i = 0; i < eventBindings.length; i++) {
        let bind = eventBindings[i];
        bind.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {
      if (global.XDomainRequest) {
        let req = new global.XDomainRequest();
        return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
      } else {
        let req = new global.XMLHttpRequest();
        return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback && callback(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
      return req;
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => callback && callback(null);
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback) {
          let response = this.parseJSON(req.responseText);
          callback(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
      return req;
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix}${this.serialize(params)}`;
    }
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.reqs = /* @__PURE__ */ new Set();
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      this.poll();
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry(code, reason, wasClean) {
      this.close(code, reason, wasClean);
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry(1005, "timeout", false);
    }
    isActive() {
      return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
    }
    poll() {
      this.ajax("GET", null, () => this.ontimeout(), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => this.onmessage({ data: msg }), 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen({});
            this.poll();
            break;
          case 403:
            this.onerror(403);
            this.close(1008, "forbidden", false);
            break;
          case 0:
          case 500:
            this.onerror(500);
            this.closeAndRetry(1011, "internal server error", 500);
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    send(body) {
      this.ajax("POST", body, () => this.onerror("timeout"), (resp) => {
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry(1011, "internal server error", false);
        }
      });
    }
    close(code, reason, wasClean) {
      for (let req of this.reqs) {
        req.abort();
      }
      this.readyState = SOCKET_STATES.closed;
      let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
      if (typeof CloseEvent !== "undefined") {
        this.onclose(new CloseEvent("close", opts));
      } else {
        this.onclose(opts);
      }
    }
    ajax(method, body, onCallerTimeout, callback) {
      let req;
      let ontimeout = () => {
        this.reqs.delete(req);
        onCallerTimeout();
      };
      req = Ajax.request(method, this.endpointURL(), "application/json", body, this.timeout, ontimeout, (resp) => {
        this.reqs.delete(req);
        if (this.isActive()) {
          callback(resp);
        }
      });
      this.reqs.add(req);
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
        return callback({ join_ref, ref, topic, event, payload });
      }
    },
    binaryEncode(message) {
      let { join_ref, ref, event, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.push);
      view.setUint8(offset++, join_ref.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, event.length);
      Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event, payload: data };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset, offset + refSize));
      offset = offset + refSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      let payload = { status: event, response: data };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event, payload: data };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global.WebSocket || LongPoll;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimeoutTimer = null;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    getLongPollTransport() {
      return LongPoll;
    }
    replaceTransport(newTransport) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.sendBuffer = [];
      if (this.conn) {
        this.conn.close();
        this.conn = null;
      }
      this.transport = newTransport;
    }
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    endPointURL() {
      let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    disconnect(callback, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.teardown(callback, code, reason);
    }
    connect(params) {
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      this.connectClock++;
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error) => this.onConnError(error);
      this.conn.onmessage = (event) => this.onConnMessage(event);
      this.conn.onclose = (event) => this.onConnClose(event);
    }
    log(kind, msg, data) {
      this.logger(kind, msg, data);
    }
    hasLogger() {
      return this.logger !== null;
    }
    onOpen(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback]);
      return ref;
    }
    onClose(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback]);
      return ref;
    }
    onError(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback]);
      return ref;
    }
    onMessage(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback]);
      return ref;
    }
    ping(callback) {
      if (!this.isConnected()) {
        return false;
      }
      let ref = this.makeRef();
      let startTime = Date.now();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
      let onMsgRef = this.onMessage((msg) => {
        if (msg.ref === ref) {
          this.off([onMsgRef]);
          callback(Date.now() - startTime);
        }
      });
      return true;
    }
    clearHeartbeats() {
      clearTimeout(this.heartbeatTimer);
      clearTimeout(this.heartbeatTimeoutTimer);
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
    }
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.triggerChanError();
        this.closeWasClean = false;
        this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      this.clearHeartbeats();
      this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback, code, reason) {
      if (!this.conn) {
        return callback && callback();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onopen = function() {
            };
            this.conn.onerror = function() {
            };
            this.conn.onmessage = function() {
            };
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback && callback();
        });
      });
    }
    waitForBufferDone(callback, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event) {
      let closeCode = event && event.code;
      if (this.hasLogger())
        this.log("transport", "close", event);
      this.triggerChanError();
      this.clearHeartbeats();
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));
    }
    onConnError(error) {
      if (this.hasLogger())
        this.log("transport", error);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback]) => {
        callback(error, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    isConnected() {
      return this.connectionState() === "open";
    }
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());
    }
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    push(data) {
      if (this.hasLogger()) {
        let { topic, event, payload, ref, join_ref } = data;
        this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
      }
    }
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback) => callback());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          this.clearHeartbeats();
          this.pendingHeartbeatRef = null;
          this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i = 0; i < this.channels.length; i++) {
          const channel = this.channels[i];
          if (!channel.isMember(topic, event, payload, join_ref)) {
            continue;
          }
          channel.trigger(event, payload, ref, join_ref);
        }
        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
          let [, callback] = this.stateChangeCallbacks.message[i];
          callback(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // ../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 5e3;
  var RELOAD_JITTER_MAX = 1e4;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF = "data-phx-ref";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_PAGE_LOADING = "page-loading";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_DISCONNECTED_CLASS = "phx-loading";
  var PHX_NO_FEEDBACK_CLASS = "phx-no-feedback";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_FEEDBACK_FOR = "feedback-for";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_PROGRESS = "progress";
  var LOADER_TIMEOUT = 1;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var DYNAMICS = "d";
  var STATIC = "s";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var EntryUploader = class {
    constructor(entry, chunkSize, liveSocket2) {
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunkSize;
      this.chunkTimer = null;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      clearTimeout(this.chunkTimer);
      this.uploadChannel.leave();
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e) => {
        if (e.target.error === null) {
          this.offset += e.target.result.byteLength;
          this.pushChunk(e.target.result);
        } else {
          return logError("Read error: " + e.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      });
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i = 0, len = elems.length; i < len; i++) {
      if (ids.has(elems[i].id)) {
        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i].id);
      }
    }
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val2) => typeof val2 === "function" ? val2 : function() {
    return val2;
  };
  var clone = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el, binding, borderEl) => {
    do {
      if (el.matches(`[${binding}]`)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el, callback) => el && callback(el);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage, namespace, subkey) {
      return localStorage.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage, namespace, subkey) {
      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to) {
      if (this.canPushState()) {
        if (to !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to || null);
          let hashEl = this.getHashTargetEl(window.location.hash);
          if (hashEl) {
            hashEl.scrollIntoView();
          } else if (meta.type === "redirect") {
            window.scroll(0, 0);
          }
        }
      } else {
        this.redirect(to);
      }
    },
    setCookie(name, value) {
      document.cookie = `${name}=${value}`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    redirect(toURL, flash) {
      if (flash) {
        Browser.setCookie("__phoenix_flash__", flash + "; max-age=60000; path=/");
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash = maybeHash.toString().substring(1);
      if (hash === "") {
        return;
      }
      return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
    }
  };
  var browser_default = Browser;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el, className) {
      el.classList.remove(className);
      if (el.classList.length === 0) {
        el.removeAttribute("class");
      }
    },
    all(node, query, callback) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query));
      return callback ? array.forEach(callback) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el) {
      return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    findUploadInputs(node) {
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    markPhxChildDestroyed(el) {
      if (this.isPhxChild(el)) {
        el.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el, phxUpdate) {
      return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el, phxUpdate, updateTypes) {
      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el) {
      return this.all(el, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el, parentId) {
      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findParentCIDs(node, cids) {
      let initial = new Set(cids);
      return cids.reduce((acc, cid) => {
        let selector = `[${PHX_COMPONENT}="${cid}"] [${PHX_COMPONENT}]`;
        this.filterWithinSameLiveView(this.all(node, selector), node).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => acc.delete(childCID));
        return acc;
      }, initial);
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el) => this.withinSameLiveView(el, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el, key) {
      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
    },
    deletePrivate(el, key) {
      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
    },
    putPrivate(el, key, value) {
      if (!el[PHX_PRIVATE]) {
        el[PHX_PRIVATE] = {};
      }
      el[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el, key, defaultVal, updateFunc) {
      let existing = this.private(el, key);
      if (existing === void 0) {
        this.putPrivate(el, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el, key, updateFunc(existing));
      }
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      let { prefix, suffix } = titleEl.dataset;
      document.title = `${prefix || ""}${str}${suffix || ""}`;
    },
    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback) {
      let debounce = el.getAttribute(phxDebounce);
      let throttle = el.getAttribute(phxThrottle);
      if (debounce === "") {
        debounce = defaultDebounce;
      }
      if (throttle === "") {
        throttle = defaultThrottle;
      }
      let value = debounce || throttle;
      switch (value) {
        case null:
          return callback();
        case "blur":
          if (this.once(el, "debounce-blur")) {
            el.addEventListener("blur", () => callback());
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();
          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle) {
            let newKeyDown = false;
            if (event.type === "keydown") {
              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);
              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);
              newKeyDown = prevKey !== event.key;
            }
            if (!newKeyDown && this.private(el, THROTTLED)) {
              return false;
            } else {
              callback();
              this.putPrivate(el, THROTTLED, true);
              setTimeout(() => {
                if (asyncFilter()) {
                  this.triggerCycle(el, DEBOUNCE_TRIGGER);
                }
              }, timeout);
            }
          } else {
            setTimeout(() => {
              if (asyncFilter()) {
                this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);
              }
            }, timeout);
          }
          let form = el.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el, "bind-debounce")) {
            el.addEventListener("blur", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));
          }
      }
    },
    triggerCycle(el, key, currentCycle) {
      let [cycle, trigger] = this.private(el, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el, key);
        trigger();
      }
    },
    once(el, key) {
      if (this.private(el, key) === true) {
        return false;
      }
      this.putPrivate(el, key, true);
      return true;
    },
    incCycle(el, key, trigger = function() {
    }) {
      let [currentCycle] = this.private(el, key) || [0, trigger];
      currentCycle++;
      this.putPrivate(el, key, [currentCycle, trigger]);
      return currentCycle;
    },
    discardError(container, el, phxFeedbackFor) {
      let field = el.getAttribute && el.getAttribute(phxFeedbackFor);
      let input = field && container.querySelector(`[id="${field}"], [name="${field}"]`);
      if (!input) {
        return;
      }
      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input.form, PHX_HAS_SUBMITTED))) {
        el.classList.add(PHX_NO_FEEDBACK_CLASS);
      }
    },
    showError(inputEl, phxFeedbackFor) {
      if (inputEl.id || inputEl.name) {
        this.all(inputEl.form, `[${phxFeedbackFor}="${inputEl.id}"], [${phxFeedbackFor}="${inputEl.name}"]`, (el) => {
          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);
        });
      }
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    firstPhxChild(el) {
      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, name, opts = {}) {
      let bubbles = opts.bubbles === void 0 ? true : !!opts.bubbles;
      let eventOpts = { bubbles, cancelable: true, detail: opts.detail || {} };
      let event = name === "click" ? new MouseEvent("click", eventOpts) : new CustomEvent(name, eventOpts);
      target.dispatchEvent(event);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    mergeAttrs(target, source, opts = {}) {
      let exclude = opts.exclude || [];
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i = sourceAttrs.length - 1; i >= 0; i--) {
        let name = sourceAttrs[i].name;
        if (exclude.indexOf(name) < 0) {
          target.setAttribute(name, source.getAttribute(name));
        }
      }
      let targetAttrs = target.attributes;
      for (let i = targetAttrs.length - 1; i >= 0; i--) {
        let name = targetAttrs[i].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { exclude: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el) {
      return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (focused.readOnly) {
        focused.blur();
      }
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el) {
      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
    },
    syncAttrsToProps(el) {
      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
        el.checked = el.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el) {
      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
    },
    isNowTriggerFormExternal(el, phxTriggerExternal) {
      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;
    },
    syncPendingRef(fromEl, toEl, disableWith) {
      let ref = fromEl.getAttribute(PHX_REF);
      if (ref === null) {
        return true;
      }
      let refSrc = fromEl.getAttribute(PHX_REF_SRC);
      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {
        if (DOM.isUploadInput(fromEl)) {
          DOM.mergeAttrs(fromEl, toEl, { isIgnored: true });
        }
        DOM.putPrivate(fromEl, PHX_REF, toEl);
        return false;
      } else {
        PHX_EVENT_CLASSES.forEach((className) => {
          fromEl.classList.contains(className) && toEl.classList.add(className);
        });
        toEl.setAttribute(PHX_REF, ref);
        toEl.setAttribute(PHX_REF_SRC, refSrc);
        return true;
      }
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el, name, defaultVal) {
      let op = (DOM.private(el, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el, name) {
      this.updatePrivate(el, "sticky", [], (ops) => {
        return ops.filter(([existingName, _]) => existingName !== name);
      });
    },
    putSticky(el, name, op) {
      let stashedResult = op(el);
      this.updatePrivate(el, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el) {
      let ops = DOM.private(el, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    constructor(fileEl, file, view) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    cancel() {
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      LiveUploader.clearFiles(this.fileEl);
    }
    onDone(callback) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.name = file.name || entry.ref;
        entry.type = file.type;
        entry.size = file.size;
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.putPrivate(inputEl, "files", this.activeFiles(inputEl).concat(newFiles));
        inputEl.value = null;
      } else {
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f));
    }
    constructor(inputEl, view, onComplete) {
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view));
      this.numEntriesInProgress = this._entries.length;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        entry.zipPostFlight(resp);
        entry.onDone(() => {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        });
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        let { name, callback } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback, entries } = groupedEntries[name];
        callback(entries, onError, resp, liveSocket2);
      }
    }
  };
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view.cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    }
  };
  var hooks_default = Hooks;
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(curFromNodeChild, fromEl, true);
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          if (onBeforeElUpdated(fromEl, toEl) === false) {
            return;
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(curFromNodeChild, fromEl, true);
                          }
                          curFromNodeChild = matchingFromEl;
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(curFromNodeChild, fromEl, true);
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              fromEl.appendChild(matchingFromEl);
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                fromEl.appendChild(curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    static patchEl(fromEl, toEl, activeElement) {
      morphdom_esm_default(fromEl, toEl, {
        childrenOnly: false,
        onBeforeElUpdated: (fromEl2, toEl2) => {
          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {
            dom_default.mergeFocusedInput(fromEl2, toEl2);
            return false;
          }
        }
      });
    }
    constructor(view, container, id, html, targetCID) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
    }
    before(kind, callback) {
      this.callbacks[`before${kind}`].push(callback);
    }
    after(kind, callback) {
      this.callbacks[`after${kind}`].push(callback);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback) => callback(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback) => callback(...args));
    }
    markPrunableContentForRemoval() {
      dom_default.all(this.container, "[phx-update=append] > *, [phx-update=prepend] > *", (el) => {
        el.setAttribute(PHX_PRUNE, "");
      });
    }
    perform() {
      let { view, liveSocket: liveSocket2, container, html } = this;
      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxFeedbackFor = liveSocket2.binding(PHX_FEEDBACK_FOR);
      let disableWith = liveSocket2.binding(PHX_DISABLE_WITH);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let phxRemove = liveSocket2.binding("remove");
      let added = [];
      let updates = [];
      let appendPrependUpdates = [];
      let pendingRemoves = [];
      let externalFormTriggered = null;
      let diffHTML = liveSocket2.time("premorph container prep", () => {
        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);
      });
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        morphdom_esm_default(targetContainer, diffHTML, {
          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,
          getNodeKey: (node) => {
            return dom_default.isPhxDestroyed(node) ? null : node.id;
          },
          onBeforeNodeAdded: (el) => {
            this.trackBefore("added", el);
            return el;
          },
          onNodeAdded: (el) => {
            if (el instanceof HTMLImageElement && el.srcset) {
              el.srcset = el.srcset;
            } else if (el instanceof HTMLVideoElement && el.autoplay) {
              el.play();
            }
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            dom_default.discardError(targetContainer, el, phxFeedbackFor);
            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
              this.trackAfter("phxChildAdded", el);
            }
            added.push(el);
          },
          onNodeDiscarded: (el) => {
            if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
              liveSocket2.destroyViewByEl(el);
            }
            this.trackAfter("discarded", el);
          },
          onBeforeNodeDiscarded: (el) => {
            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, ["append", "prepend"]) && el.id) {
              return false;
            }
            if (el.getAttribute && el.getAttribute(phxRemove)) {
              pendingRemoves.push(el);
              return false;
            }
            if (this.skipCIDSibling(el)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el) => {
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            updates.push(el);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {
              if (dom_default.isUploadInput(fromEl)) {
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            dom_default.copyPrivates(toEl, fromEl);
            dom_default.discardError(targetContainer, toEl, phxFeedbackFor);
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            if (isFocusedFormEl) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            } else {
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              this.trackBefore("updated", fromEl, toEl);
              return true;
            }
          }
        });
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update) => update.perform());
        });
      }
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el) => this.trackAfter("added", el));
      updates.forEach((el) => this.trackAfter("updated", el));
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves);
        liveSocket2.requestDOMUpdate(() => {
          pendingRemoves.forEach((el) => {
            let child = dom_default.firstPhxChild(el);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
      if (externalFormTriggered) {
        liveSocket2.disconnect();
        externalFormTriggered.submit();
      }
      return true;
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    buildDiffHTML(container, html, phxUpdate, targetContainer) {
      let isCIDPatch = this.isCIDPatch();
      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();
      if (!isCIDPatch || isCIDWithSingleRoot) {
        return html;
      } else {
        let diffContainer = null;
        let template = document.createElement("template");
        diffContainer = dom_default.cloneNode(targetContainer);
        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);
        template.innerHTML = html;
        rest.forEach((el) => el.remove());
        Array.from(diffContainer.childNodes).forEach((child) => {
          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
        });
        Array.from(template.content.childNodes).forEach((el) => diffContainer.insertBefore(el, firstComponent));
        firstComponent.remove();
        return diffContainer.outerHTML;
      }
    }
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids };
      this.toOutputBuffer(rendered, null, output);
      return output.buffer;
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val2 = source[key];
        let targetVal = target[key];
        if (isObject(val2) && val2[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val2);
        } else {
          target[key] = val2;
        }
      }
    }
    cloneMerge(target, source) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val2 = source[key];
        let targetVal = target[key];
        if (isObject(val2) && val2[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val2);
        }
      }
      return merged;
    }
    componentToString(cid) {
      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    toOutputBuffer(rendered, templates, output) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      output.buffer += statics[0];
      for (let i = 1; i < statics.length; i++) {
        this.dynamicToBuffer(rendered[i - 1], templates, output);
        output.buffer += statics[i];
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d = 0; d < dynamics.length; d++) {
        let dynamic = dynamics[d];
        output.buffer += statics[0];
        for (let i = 1; i < statics.length; i++) {
          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output);
          output.buffer += statics[i];
        }
      }
    }
    dynamicToBuffer(rendered, templates, output) {
      if (typeof rendered === "number") {
        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output);
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let template = document.createElement("template");
      template.innerHTML = this.recursiveToString(component, components, onlyCids);
      let container = template.content;
      let skip = onlyCids && !onlyCids.has(cid);
      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {
        if (child.nodeType === Node.ELEMENT_NODE) {
          if (child.getAttribute(PHX_COMPONENT)) {
            return [hasNodes, true];
          }
          child.setAttribute(PHX_COMPONENT, cid);
          if (!child.id) {
            child.id = `${this.parentViewId()}-${cid}-${i}`;
          }
          if (skip) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
          return [true, hasComponents];
        } else {
          if (child.nodeValue.trim() !== "") {
            logError(`only HTML element tags are allowed at the root of components.

got: "${child.nodeValue.trim()}"

within:
`, template.innerHTML.trim());
            child.replaceWith(this.createSpan(child.nodeValue, cid));
            return [true, hasComponents];
          } else {
            child.remove();
            return [hasNodes, hasComponents];
          }
        }
      }, [false, false]);
      if (!hasChildNodes && !hasChildComponents) {
        logError("expected at least one HTML element tag inside a component, but the component is empty:\n", template.innerHTML.trim());
        return this.createSpan("", cid).outerHTML;
      } else if (!hasChildNodes && hasChildComponents) {
        logError("expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.", template.innerHTML.trim());
        return template.innerHTML;
      } else {
        return template.innerHTML;
      }
    }
    createSpan(text, cid) {
      let span = document.createElement("span");
      span.innerText = text;
      span.setAttribute(PHX_COMPONENT, cid);
      return span;
    }
  };
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el) {
      return el.phxHookId;
    }
    constructor(view, el, callbacks) {
      this.__view = view;
      this.liveSocket = view.liveSocket;
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      this.el = el;
      this.el.phxHookId = this.constructor.makeID();
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    pushEvent(event, payload = {}, onReply = function() {
    }) {
      return this.__view.pushHookEvent(null, event, payload, onReply);
    }
    pushEventTo(phxTarget, event, payload = {}, onReply = function() {
    }) {
      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(targetCtx, event, payload, onReply);
      });
    }
    handleEvent(event, callback) {
      let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);
      window.addEventListener(`phx:${event}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event = callbackRef(null, true);
      window.removeEventListener(`phx:${event}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view.dispatchUploads(name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view.withinTargets(phxTarget, (view) => view.dispatchUploads(name, files));
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var JS = {
    exec(eventType, phxEvent, view, sourceEl, defaults) {
      let [defaultKind, defaultArgs] = defaults || [null, {}];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind && defaultArgs.data) {
          args.data = Object.assign(args.data || {}, defaultArgs.data);
        }
        this.filterToEls(sourceEl, args).forEach((el) => {
          this[`exec_${kind}`](eventType, phxEvent, view, sourceEl, el, args);
        });
      });
    },
    isVisible(el) {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
    },
    exec_dispatch(eventType, phxEvent, view, sourceEl, el, { to, event, detail, bubbles }) {
      detail = detail || {};
      detail.dispatcher = sourceEl;
      dom_default.dispatchEvent(el, event, { detail, bubbles });
    },
    exec_push(eventType, phxEvent, view, sourceEl, el, args) {
      if (!view.isConnected()) {
        return;
      }
      let { event, data, target, page_loading, loading, value, dispatcher } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" && dispatcher ? dispatcher : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      view.withinTargets(phxTarget, (targetView, targetCtx) => {
        if (eventType === "change") {
          let { newCid, _target, callback } = args;
          _target = _target || (sourceEl instanceof HTMLInputElement ? sourceEl.name : void 0);
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback);
        } else if (eventType === "submit") {
          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, pushOpts);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts);
        }
      });
    },
    exec_add_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, names, [], transition, time, view);
    },
    exec_remove_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, [], names, transition, time, view);
    },
    exec_transition(eventType, phxEvent, view, sourceEl, el, { time, transition }) {
      let [transition_start, running, transition_end] = transition;
      let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(running), []);
      let onDone = () => this.addOrRemoveClasses(el, transition_end, transition_start.concat(running));
      view.transition(time, onStart, onDone);
    },
    exec_toggle(eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time }) {
      this.toggle(eventType, view, el, display, ins, outs, time);
    },
    exec_show(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.show(eventType, view, el, display, transition, time);
    },
    exec_hide(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.hide(eventType, view, el, display, transition, time);
    },
    exec_set_attr(eventType, phxEvent, view, sourceEl, el, { attr: [attr, val2] }) {
      this.setOrRemoveAttrs(el, [[attr, val2]], []);
    },
    exec_remove_attr(eventType, phxEvent, view, sourceEl, el, { attr }) {
      this.setOrRemoveAttrs(el, [], [attr]);
    },
    show(eventType, view, el, display, transition, time) {
      if (!this.isVisible(el)) {
        this.toggle(eventType, view, el, display, transition, null, time);
      }
    },
    hide(eventType, view, el, display, transition, time) {
      if (this.isVisible(el)) {
        this.toggle(eventType, view, el, display, null, transition, time);
      }
    },
    toggle(eventType, view, el, display, ins, outs, time) {
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el)) {
          let onStart = () => {
            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:hide-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, inClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:show-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      } else {
        if (this.isVisible(el)) {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:hide-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:show-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      }
    },
    addOrRemoveClasses(el, adds, removes, transition, time, view) {
      let [transition_run, transition_start, transition_end] = transition || [[], [], []];
      if (transition_run.length > 0) {
        let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(transition_run), []);
        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transition_end), removes.concat(transition_run).concat(transition_start));
        return view.transition(time, onStart, onDone);
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
      let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);
      let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);
      let newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);
      dom_default.putSticky(el, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val2]) => currentEl.setAttribute(attr, val2));
        return [newSets, newRemoves];
      });
    },
    hasAllClasses(el, classes) {
      return classes.every((name) => el.classList.contains(name));
    },
    isToggledOut(el, outClasses) {
      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
    },
    filterToEls(sourceEl, { to }) {
      return to ? dom_default.all(document, to) : [sourceEl];
    }
  };
  var js_default = JS;
  var serializeForm = (form, meta, onlyNames = []) => {
    let formData = new FormData(form);
    let toRemove = [];
    formData.forEach((val2, key, _index) => {
      if (val2 instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    let params = new URLSearchParams();
    for (let [key, val2] of formData.entries()) {
      if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {
        params.append(key, val2);
      }
    }
    for (let metaKey in meta) {
      params.append(metaKey, meta[metaKey]);
    }
    return params.toString();
  };
  var View = class {
    constructor(el, liveSocket2, parentView, flash) {
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el;
      this.id = this.el.id;
      this.ref = 0;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.pendingDiffs = [];
      this.pruningCIDs = [];
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.uploaders = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        return {
          redirect: this.redirect ? this.href : void 0,
          url: this.redirect ? void 0 : this.href || void 0,
          params: this.connectParams(),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.hasAttribute(PHX_MAIN);
    }
    connectParams() {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val2 = this.el.getAttribute(PHX_STATIC);
      return val2 === "" ? null : val2;
    }
    destroy(callback = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes) {
      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
      this.el.classList.add(...classes);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_DISCONNECTED_CLASS);
      }
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    withinTargets(phxTarget, callback) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(document.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback) {
      this.log(type, () => ["", clone(rawDiff)]);
      let { diff, reply, events, title } = Rendered.extract(rawDiff);
      if (title) {
        dom_default.putTitle(title);
      }
      callback({ diff, reply, events });
      return reply;
    }
    onJoin(resp) {
      let { rendered, container } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events }) => {
        this.rendered = new Rendered(this.id, diff);
        let html = this.renderContainer(null, "join");
        this.dropPendingRefs();
        let forms = this.formsForRecovery(html);
        this.joinCount++;
        if (forms.length > 0) {
          forms.forEach(([form, newForm, newCid], i) => {
            this.pushFormRecovery(form, newCid, (resp2) => {
              if (i === forms.length - 1) {
                this.onJoinComplete(resp2, html, events);
              }
            });
          });
        } else {
          this.onJoinComplete(resp, html, events);
        }
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}]`, (el) => {
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
      });
    }
    onJoinComplete({ live_patch }, html, events) {
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, events);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, events);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    applyJoinPatch(live_patch, html, events) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false);
      this.joinNewChildren();
      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        let hook = this.addHook(hookEl);
        if (hook) {
          hook.__mounted();
        }
      });
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to } = live_patch;
        this.liveSocket.historyPatch(to, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    performPatch(patch, pruneCids) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      patch.after("added", (el) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el]);
        let newHook = this.addHook(el);
        if (newHook) {
          newHook.__mounted();
        }
      });
      patch.after("phxChildAdded", (el) => {
        if (dom_default.isPhxSticky(el)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el) => {
        if (updatedHookIds.has(el.id)) {
          this.getHook(el).__updated();
        }
      });
      patch.after("discarded", (el) => {
        if (el.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform();
      this.afterElementsRemoved(removedEls, pruneCids);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements, pruneCids) {
      let destroyedCIDs = [];
      elements.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        let hooks = dom_default.all(parent, `[${this.binding(PHX_HOOK)}]`);
        components.concat(parent).forEach((el) => {
          let cid = this.componentID(el);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
        });
        hooks.concat(parent).forEach((hookEl) => {
          let hook = this.getHook(hookEl);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el) {
      if (el.id === this.id) {
        return this;
      } else {
        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el) {
      let child = this.getChildById(el.id);
      if (!child) {
        let view = new View(el, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink() && !dom_default.isPhxSticky(this.el)) {
        return this.pendingDiffs.push({ diff, events });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let html = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;
        let html = this.rendered.toString(cids);
        return `<${tag}>${html}</${tag}>`;
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let html = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el) {
      return this.viewHooks[ViewHook.elementID(el)];
    }
    addHook(el) {
      if (ViewHook.elementID(el) || !el.getAttribute) {
        return;
      }
      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
      if (hookName && !this.ownsElement(el)) {
        return;
      }
      let callbacks = this.liveSocket.getHookCallbacks(hookName);
      if (callbacks) {
        if (!el.id) {
          logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el);
        }
        let hook = new ViewHook(this, el, callbacks);
        this.viewHooks[ViewHook.elementID(hook.el)] = hook;
        return hook;
      } else if (hookName !== null) {
        logError(`unknown hook found for "${hookName}"`, el);
      }
    }
    destroyHook(hook) {
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[ViewHook.elementID(hook.el)];
    }
    applyPendingUpdates() {
      this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));
      this.pendingDiffs = [];
    }
    onChannel(event, cb) {
      this.liveSocket.onChannel(this.channel, event, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events }) => this.update(diff, events));
        });
      });
      this.onChannel("redirect", ({ to, flash }) => this.onRedirect({ to, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      for (let id in this.root.children[this.id]) {
        this.getChildById(id).destroy();
      }
    }
    onLiveRedirect(redir) {
      let { to, kind, flash } = redir;
      let url = this.expandURL(to);
      this.liveSocket.historyRedirect(url, kind, flash);
    }
    onLivePatch(redir) {
      let { to, kind } = redir;
      this.href = this.expandURL(to);
      this.liveSocket.historyPatch(to, kind);
    }
    expandURL(to) {
      return to.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to}` : to;
    }
    onRedirect({ to, flash }) {
      this.liveSocket.redirect(to, flash);
    }
    isDestroyed() {
      return this.destroyed;
    }
    join(callback) {
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback ? callback(this.joinCount, onDone) : onDone();
      };
      this.liveSocket.wrapPush(this, { timeout: false }, () => {
        return this.channel.join().receive("ok", (data) => {
          if (!this.isDestroyed()) {
            this.liveSocket.requestDOMUpdate(() => this.onJoin(data));
          }
        }).receive("error", (resp) => !this.isDestroyed() && this.onJoinError(resp)).receive("timeout", () => !this.isDestroyed() && this.onJoinError({ reason: "timeout" }));
      });
    }
    onJoinError(resp) {
      if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        return this.onRedirect({ to: this.href });
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.log("error", () => ["unable to join", resp]);
      if (this.liveSocket.isConnected()) {
        this.liveSocket.reloadWithJitter(this);
      }
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      if (this.liveSocket.isConnected()) {
        this.log("error", () => ["view crashed", reason]);
      }
      if (!this.liveSocket.isUnloaded()) {
        this.displayError();
      }
    }
    displayError() {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: { to: this.href, kind: "error" } });
      }
      this.showLoader();
      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
    }
    pushWithReply(refGenerator, event, payload, onReply = function() {
    }) {
      if (!this.isConnected()) {
        return;
      }
      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let onLoadingDone = function() {
      };
      if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return this.liveSocket.wrapPush(this, { timeout: true }, () => {
        return this.channel.push(event, payload, PUSH_TIMEOUT).receive("ok", (resp) => {
          if (ref !== null) {
            this.undoRefs(ref);
          }
          let finish = (hookReply) => {
            if (resp.redirect) {
              this.onRedirect(resp.redirect);
            }
            if (resp.live_patch) {
              this.onLivePatch(resp.live_patch);
            }
            if (resp.live_redirect) {
              this.onLiveRedirect(resp.live_redirect);
            }
            onLoadingDone();
            onReply(resp, hookReply);
          };
          if (resp.diff) {
            this.liveSocket.requestDOMUpdate(() => {
              let hookReply = this.applyDiff("update", resp.diff, ({ diff, events }) => {
                this.update(diff, events);
              });
              finish(hookReply);
            });
          } else {
            finish(null);
          }
        });
      });
    }
    undoRefs(ref) {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}="${ref}"]`, (el) => {
        let disabledVal = el.getAttribute(PHX_DISABLED);
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
        if (el.getAttribute(PHX_READONLY) !== null) {
          el.readOnly = false;
          el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          el.disabled = disabledVal === "true" ? true : false;
          el.removeAttribute(PHX_DISABLED);
        }
        PHX_EVENT_CLASSES.forEach((className) => dom_default.removeClass(el, className));
        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          el.innerText = disableRestore;
          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let toEl = dom_default.private(el, PHX_REF);
        if (toEl) {
          let hook = this.triggerBeforeUpdateHook(el, toEl);
          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());
          if (hook) {
            hook.__updated();
          }
          dom_default.deletePrivate(el, PHX_REF);
        }
      });
    }
    putRef(elements, event, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        elements = elements.concat(dom_default.all(document, opts.loading));
      }
      elements.forEach((el) => {
        el.classList.add(`phx-${event}-loading`);
        el.setAttribute(PHX_REF, newRef);
        el.setAttribute(PHX_REF_SRC, this.el.id);
        let disableText = el.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);
          }
          if (disableText !== "") {
            el.innerText = disableText;
          }
          el.setAttribute("disabled", "");
        }
      });
      return [newRef, elements, opts];
    }
    componentID(el) {
      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));
      } else {
        return null;
      }
    }
    pushHookEvent(targetCtx, event, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([], "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }, (resp, reply) => onReply(reply, ref));
      return ref;
    }
    extractMeta(el, meta, value) {
      let prefix = this.binding("value-");
      for (let i = 0; i < el.attributes.length; i++) {
        if (!meta) {
          meta = {};
        }
        let name = el.attributes[i].name;
        if (name.startsWith(prefix)) {
          meta[name.replace(prefix, "")] = el.getAttribute(name);
        }
      }
      if (el.value !== void 0) {
        if (!meta) {
          meta = {};
        }
        meta.value = el.value;
        if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}) {
      this.pushWithReply(() => this.putRef([el], type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el, meta, opts.value),
        cid: this.targetComponentID(el, targetCtx, opts)
      });
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }, onReply);
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);
      let refGenerator = () => this.putRef([inputEl, inputEl.form], "change", opts);
      let formData;
      if (inputEl.getAttribute(this.binding("change"))) {
        formData = serializeForm(inputEl.form, { _target: opts._target }, [inputEl.name]);
      } else {
        formData = serializeForm(inputEl.form, { _target: opts._target });
      }
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event = {
        type: "form",
        event: phxEvent,
        value: formData,
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event, (resp) => {
        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));
        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute("data-phx-auto-upload") !== null) {
          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
            let [ref, _els] = refGenerator();
            this.uploadFiles(inputEl.form, targetCtx, ref, cid, (_uploads) => {
              callback && callback(resp);
              this.triggerAwaitingSubmit(inputEl.form);
            });
          }
        } else {
          callback && callback(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback] = awaitingSubmit;
        this.cancelSubmit(formEl);
        callback();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback]);
    }
    cancelSubmit(formEl) {
      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {
        if (el.isSameNode(formEl)) {
          this.undoRefs(ref);
          return false;
        } else {
          return true;
        }
      });
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply) {
      let filterIgnored = (el) => {
        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);
        return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
      };
      let filterDisables = (el) => {
        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el) => el.tagName == "BUTTON";
      let filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
      let refGenerator = () => {
        let formElements = Array.from(formEl.elements);
        let disables = formElements.filter(filterDisables);
        let buttons = formElements.filter(filterButton).filter(filterIgnored);
        let inputs = formElements.filter(filterInput).filter(filterIgnored);
        buttons.forEach((button) => {
          button.setAttribute(PHX_DISABLED, button.disabled);
          button.disabled = true;
        });
        inputs.forEach((input) => {
          input.setAttribute(PHX_READONLY, input.readOnly);
          input.readOnly = true;
          if (input.files) {
            input.setAttribute(PHX_DISABLED, input.disabled);
            input.disabled = true;
          }
        });
        formEl.setAttribute(this.binding(PHX_PAGE_LOADING), "");
        return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), "submit", opts);
      };
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, targetCtx, ref, cid, (_uploads) => {
          let formData = serializeForm(formEl, {});
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            cid
          }, onReply);
        });
      } else {
        let formData = serializeForm(formEl, {});
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          cid
        }, onReply);
      }
    }
    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        this.uploaders[inputEl] = uploader;
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload, (resp) => {
          this.log("upload", () => ["got preflight response", resp]);
          if (resp.error) {
            this.undoRefs(ref);
            let [entry_ref, reason] = resp.error;
            this.log("upload", () => [`error for entry ${entry_ref}`, reason]);
          } else {
            let onError = (callback) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    dispatchUploads(name, filesOrBlobs) {
      let inputs = dom_default.findUploadInputs(this.el).filter((el) => el.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { detail: { files: filesOrBlobs } });
      }
    }
    pushFormRecovery(form, newCid, callback) {
      this.liveSocket.withinOwners(form, (view, targetCtx) => {
        let input = form.elements[0];
        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding("change"));
        js_default.exec("change", phxEvent, view, input, ["push", { _target: input.name, newCid, callback }]);
      });
    }
    pushLinkPatch(href, targetEl, callback) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let refGen = targetEl ? () => this.putRef([targetEl], "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let push = this.pushWithReply(refGen, "live_patch", { url: href }, (resp) => {
        this.liveSocket.requestDOMUpdate(() => {
          if (resp.link_redirect) {
            this.liveSocket.replaceMain(href, null, callback, linkRef);
          } else {
            if (this.liveSocket.commitPendingLink(linkRef)) {
              this.href = href;
            }
            this.applyPendingUpdates();
            callback && callback(linkRef);
          }
        });
      });
      if (push) {
        push.receive("timeout", fallback);
      } else {
        fallback();
      }
    }
    formsForRecovery(html) {
      if (this.joinCount === 0) {
        return [];
      }
      let phxChange = this.binding("change");
      let template = document.createElement("template");
      template.innerHTML = html;
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id && this.ownsElement(form)).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => {
        let newForm = template.content.querySelector(`form[id="${form.id}"][${phxChange}="${form.getAttribute(phxChange)}"]`);
        if (newForm) {
          return [form, newForm, this.targetComponentID(newForm)];
        } else {
          return [form, null, null];
        }
      }).filter(([form, newForm, newCid]) => newForm);
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        this.pruningCIDs.push(...willDestroyCIDs);
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }, () => {
          this.pruningCIDs = this.pruningCIDs.filter((cid) => willDestroyCIDs.indexOf(cid) !== -1);
          let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
            return dom_default.findComponentNodeList(this.el, cid).length === 0;
          });
          if (completelyDestroyCIDs.length > 0) {
            this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }, (resp) => {
              this.rendered.pruneCIDs(resp.cids);
            });
          }
        });
      }
    }
    ownsElement(el) {
      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), (node) => node.id) === this.id;
    }
    submitForm(form, targetCtx, phxEvent, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      let phxFeedback = this.liveSocket.binding(PHX_FEEDBACK_FOR);
      let inputs = Array.from(form.elements);
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, opts, () => {
        inputs.forEach((input) => dom_default.showError(input, phxFeedback));
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.outgoingMainEl = null;
      this.clickStartedAtTarget = null;
      this.linkRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.reloadWithJitterTimer = null;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.domCallbacks = Object.assign({ onNodeAdded: closure2(), onBeforeElUpdated: closure2() }, opts.dom || {});
      this.transitions = new TransitionSet();
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    isDebugDisabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "false";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "false");
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      if (window.location.hostname === "localhost" && !this.isDebugDisabled()) {
        this.enableDebug();
      }
      let doConnect = () => {
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        } else if (this.main) {
          this.socket.connect();
        }
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.disconnect(callback);
    }
    replaceTransport(transport) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.replaceTransport(transport);
      this.connect();
    }
    execJS(el, encodedJS, eventType = null) {
      this.owner(el, (view) => js_default.exec(eventType, encodedJS, view, el));
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback) {
      this.transitions.after(callback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event, cb) {
      channel.on(event, (data) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data);
        } else {
          console.log(`simulating ${latency}ms of latency from server to client`);
          setTimeout(() => cb(data), latency);
        }
      });
    }
    wrapPush(view, opts, push) {
      let latency = this.getLatencySim();
      let oldJoinCount = view.joinCount;
      if (!latency) {
        if (this.isConnected() && opts.timeout) {
          return push().receive("timeout", () => {
            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {
              this.reloadWithJitter(view, () => {
                this.log(view, "timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          });
        } else {
          return push();
        }
      }
      console.log(`simulating ${latency}ms of latency from client to server`);
      let fakePush = {
        receives: [],
        receive(kind, cb) {
          this.receives.push([kind, cb]);
        }
      };
      setTimeout(() => {
        if (view.isDestroyed()) {
          return;
        }
        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());
      }, latency);
      return fakePush;
    }
    reloadWithJitter(view, log) {
      clearTimeout(this.reloadWithJitterTimer);
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      if (tries > this.maxReloads) {
        afterMs = this.failsafeJitter;
      }
      this.reloadWithJitterTimer = setTimeout(() => {
        if (view.isDestroyed() || view.isConnected()) {
          return;
        }
        view.destroy();
        log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
        if (tries > this.maxReloads) {
          this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        }
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {
        if (!this.getRootById(rootEl.id)) {
          let view = this.newRootView(rootEl);
          view.setHref(this.getHref());
          view.join();
          if (rootEl.hasAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to, flash) {
      this.disconnect();
      browser_default.redirect(to, flash);
    }
    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {
      this.outgoingMainEl = this.outgoingMainEl || this.main.el;
      let newMainEl = dom_default.cloneNode(this.outgoingMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash);
      this.main.setRedirect(href);
      this.transitionRemoves();
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            dom_default.findPhxSticky(document).forEach((el) => newMainEl.appendChild(el));
            this.outgoingMainEl.replaceWith(newMainEl);
            this.outgoingMainEl = null;
            callback && requestAnimationFrame(callback);
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements) {
      let removeAttr = this.binding("remove");
      elements = elements || dom_default.all(document, `[${removeAttr}]`);
      elements.forEach((el) => {
        if (document.body.contains(el)) {
          this.execJS(el, el.getAttribute(removeAttr), "remove");
        }
      });
    }
    isPhxView(el) {
      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el, flash) {
      let view = new View(el, this, null, flash);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;
      if (view) {
        callback(view);
      }
    }
    withinOwners(childEl, callback) {
      this.owner(childEl, (view) => callback(view, childEl));
    }
    getViewByEl(el) {
      let rootId = el.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
      this.main = null;
    }
    destroyViewByEl(el) {
      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el.id);
      }
    }
    setActiveElement(target) {
      if (this.activeElement === target) {
        return;
      }
      this.activeElement = target;
      let cancel = () => {
        if (target === this.activeElement) {
          this.activeElement = null;
        }
        target.removeEventListener("mouseup", this);
        target.removeEventListener("touchend", this);
      };
      target.addEventListener("mouseup", cancel);
      target.addEventListener("touchend", cancel);
    }
    getActiveElement() {
      if (document.activeElement === document.body) {
        return this.activeElement || document.activeElement;
      } else {
        return document.activeElement || document.body;
      }
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents() {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.socket.onClose((event) => {
        if (event && event.code === 1e3 && this.main) {
          this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      this.bindNav();
      this.bindClicks();
      this.bindForms();
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e.key && e.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
        js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        if (!eventTarget) {
          let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data = this.eventMeta(type, e, targetEl);
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      window.addEventListener("dragover", (e) => e.preventDefault());
      window.addEventListener("drop", (e) => {
        e.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e) => {
        let uploadTarget = e.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e, targetEl) {
      let callback = this.metadataCallbacks[eventName];
      return callback ? callback(e, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      return this.linkRef;
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events, callback) {
      for (let event in events) {
        let browserEventName = events[event];
        this.on(browserEventName, (e) => {
          let binding = this.binding(event);
          let windowBinding = this.binding(`window-${event}`);
          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e.target, e, browserEventName, () => {
              this.withinOwners(e.target, (view) => {
                callback(e, event, view, e.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el) => {
              let phxEvent = el.getAttribute(windowBinding);
              this.debounce(el, e, browserEventName, () => {
                this.withinOwners(el, (view) => {
                  callback(e, event, view, el, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      window.addEventListener("mousedown", (e) => this.clickStartedAtTarget = e.target);
      this.bindClick("click", "click", false);
      this.bindClick("mousedown", "capture-click", true);
    }
    bindClick(eventName, bindingName, capture) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e) => {
        let target = null;
        if (capture) {
          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);
        } else {
          let clickStartedAtTarget = this.clickStartedAtTarget || e.target;
          target = closestPhxBinding(clickStartedAtTarget, click);
          this.dispatchClickAway(e, clickStartedAtTarget);
          this.clickStartedAtTarget = null;
        }
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          return;
        }
        if (target.getAttribute("href") === "#") {
          e.preventDefault();
        }
        this.debounce(target, e, "click", () => {
          this.withinOwners(target, (view) => {
            js_default.exec("click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e, target) }]);
          });
        });
      }, capture);
    }
    dispatchClickAway(e, clickStartedAt) {
      let phxClickAway = this.binding("click-away");
      dom_default.all(document, `[${phxClickAway}]`, (el) => {
        if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {
          this.withinOwners(e.target, (view) => {
            let phxEvent = el.getAttribute(phxClickAway);
            if (js_default.isVisible(el)) {
              js_default.exec("click", phxEvent, view, el, ["push", { data: this.eventMeta("click", e, e.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, id, root, scroll: scroll2 } = event.state || {};
        let href = window.location.href;
        this.requestDOMUpdate(() => {
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(href, null);
          } else {
            this.replaceMain(href, null, () => {
              if (root) {
                this.replaceRootHistory();
              }
              if (typeof scroll2 === "number") {
                setTimeout(() => {
                  window.scrollTo(0, scroll2);
                }, 0);
              }
            });
          }
        });
      }, false);
      window.addEventListener("click", (e) => {
        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;
        if (!type || !this.isConnected() || !this.main || wantsNewTab) {
          return;
        }
        let href = target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e.preventDefault();
        e.stopImmediatePropagation();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(href, linkState);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
        });
      }, false);
    }
    dispatchEvent(event, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });
    }
    dispatchEvents(events) {
      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));
    }
    withPageLoading(info, callback) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: info });
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", { detail: info });
      return callback ? callback(done) : done;
    }
    pushHistoryPatch(href, linkState, targetEl) {
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      browser_default.pushState(linkState, { type: "patch", id: this.main.id }, href);
      this.registerNewLocation(window.location);
    }
    historyRedirect(href, linkState, flash) {
      let scroll2 = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, () => {
          browser_default.pushState(linkState, { type: "redirect", id: this.main.id, scroll: scroll2 }, href);
          this.registerNewLocation(window.location);
          done();
        });
      });
    }
    replaceRootHistory() {
      browser_default.pushState("replace", { root: true, type: "patch", id: this.main.id });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      this.on("submit", (e) => {
        let phxEvent = e.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          return;
        }
        e.preventDefault();
        e.target.disabled = true;
        this.withinOwners(e.target, (view) => {
          js_default.exec("submit", phxEvent, view, e.target, ["push", {}]);
        });
      }, false);
      for (let type of ["change", "input"]) {
        this.on(type, (e) => {
          let phxChange = this.binding("change");
          let input = e.target;
          let inputEvent = input.getAttribute(phxChange);
          let formEvent = input.form && input.form.getAttribute(phxChange);
          let phxEvent = inputEvent || formEvent;
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let dispatcher = inputEvent ? input : input.form;
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type !== lastType) {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e, type, () => {
            this.withinOwners(dispatcher, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              if (!dom_default.isTextualInput(input)) {
                this.setActiveElement(input);
              }
              js_default.exec("change", phxEvent, view, input, ["push", { _target: e.target.name, dispatcher }]);
            });
          });
        }, false);
      }
    }
    debounce(el, event, eventType, callback) {
      if (eventType === "blur" || eventType === "focusout") {
        return callback();
      }
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      this.withinOwners(el, (view) => {
        let asyncFilter = () => !view.isDestroyed() && document.body.contains(el);
        dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, () => {
          callback();
        });
      });
    }
    silenceEvents(callback) {
      this.silenced = true;
      callback();
      this.silenced = false;
    }
    on(event, callback) {
      window.addEventListener(event, (e) => {
        if (!this.silenced) {
          callback(e);
        }
      });
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
      this.reset();
    }
    reset() {
      this.transitions.forEach((timer) => {
        cancelTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback) {
      if (this.size() === 0) {
        callback();
      } else {
        this.pushPendingOp(callback);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        if (this.size() === 0) {
          this.flushPendingOps();
        }
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      this.pendingOps.forEach((op) => op());
      this.pendingOps = [];
    }
  };

  // node_modules/@shopify/draggable/build/esm/shared/AbstractEvent/AbstractEvent.mjs
  var AbstractEvent = class {
    constructor(data) {
      this._canceled = false;
      this.data = data;
    }
    get type() {
      return this.constructor.type;
    }
    get cancelable() {
      return this.constructor.cancelable;
    }
    cancel() {
      this._canceled = true;
    }
    canceled() {
      return this._canceled;
    }
    clone(data) {
      return new this.constructor(__spreadValues(__spreadValues({}, this.data), data));
    }
  };
  AbstractEvent.type = "event";
  AbstractEvent.cancelable = false;

  // node_modules/@shopify/draggable/build/esm/shared/AbstractPlugin/AbstractPlugin.mjs
  var AbstractPlugin = class {
    constructor(draggable) {
      this.draggable = draggable;
    }
    attach() {
      throw new Error("Not Implemented");
    }
    detach() {
      throw new Error("Not Implemented");
    }
  };

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/Sensor/Sensor.mjs
  var defaultDelay = {
    mouse: 0,
    drag: 0,
    touch: 100
  };
  var Sensor = class {
    constructor(containers = [], options = {}) {
      this.containers = [...containers];
      this.options = __spreadValues({}, options);
      this.dragging = false;
      this.currentContainer = null;
      this.originalSource = null;
      this.startEvent = null;
      this.delay = calcDelay(options.delay);
    }
    attach() {
      return this;
    }
    detach() {
      return this;
    }
    addContainer(...containers) {
      this.containers = [...this.containers, ...containers];
    }
    removeContainer(...containers) {
      this.containers = this.containers.filter((container) => !containers.includes(container));
    }
    trigger(element, sensorEvent) {
      const event = document.createEvent("Event");
      event.detail = sensorEvent;
      event.initEvent(sensorEvent.type, true, true);
      element.dispatchEvent(event);
      this.lastEvent = sensorEvent;
      return sensorEvent;
    }
  };
  function calcDelay(optionsDelay) {
    const delay = {};
    if (optionsDelay === void 0) {
      return __spreadValues({}, defaultDelay);
    }
    if (typeof optionsDelay === "number") {
      for (const key in defaultDelay) {
        if (Object.prototype.hasOwnProperty.call(defaultDelay, key)) {
          delay[key] = optionsDelay;
        }
      }
      return delay;
    }
    for (const key in defaultDelay) {
      if (Object.prototype.hasOwnProperty.call(defaultDelay, key)) {
        if (optionsDelay[key] === void 0) {
          delay[key] = defaultDelay[key];
        } else {
          delay[key] = optionsDelay[key];
        }
      }
    }
    return delay;
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/closest/closest.mjs
  function closest(node, value) {
    if (node == null) {
      return null;
    }
    function conditionFn(currentNode) {
      if (currentNode == null || value == null) {
        return false;
      } else if (isSelector(value)) {
        return Element.prototype.matches.call(currentNode, value);
      } else if (isNodeList(value)) {
        return [...value].includes(currentNode);
      } else if (isElement(value)) {
        return value === currentNode;
      } else if (isFunction(value)) {
        return value(currentNode);
      } else {
        return false;
      }
    }
    let current = node;
    do {
      current = current.correspondingUseElement || current.correspondingElement || current;
      if (conditionFn(current)) {
        return current;
      }
      current = (current == null ? void 0 : current.parentNode) || null;
    } while (current != null && current !== document.body && current !== document);
    return null;
  }
  function isSelector(value) {
    return Boolean(typeof value === "string");
  }
  function isNodeList(value) {
    return Boolean(value instanceof NodeList || value instanceof Array);
  }
  function isElement(value) {
    return Boolean(value instanceof Node);
  }
  function isFunction(value) {
    return Boolean(typeof value === "function");
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/distance/distance.mjs
  function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/SensorEvent/SensorEvent.mjs
  var SensorEvent = class extends AbstractEvent {
    get originalEvent() {
      return this.data.originalEvent;
    }
    get clientX() {
      return this.data.clientX;
    }
    get clientY() {
      return this.data.clientY;
    }
    get target() {
      return this.data.target;
    }
    get container() {
      return this.data.container;
    }
    get originalSource() {
      return this.data.originalSource;
    }
    get pressure() {
      return this.data.pressure;
    }
  };
  var DragStartSensorEvent = class extends SensorEvent {
  };
  DragStartSensorEvent.type = "drag:start";
  var DragMoveSensorEvent = class extends SensorEvent {
  };
  DragMoveSensorEvent.type = "drag:move";
  var DragStopSensorEvent = class extends SensorEvent {
  };
  DragStopSensorEvent.type = "drag:stop";
  var DragPressureSensorEvent = class extends SensorEvent {
  };
  DragPressureSensorEvent.type = "drag:pressure";

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/MouseSensor/MouseSensor.mjs
  var onContextMenuWhileDragging = Symbol("onContextMenuWhileDragging");
  var onMouseDown = Symbol("onMouseDown");
  var onMouseMove = Symbol("onMouseMove");
  var onMouseUp = Symbol("onMouseUp");
  var startDrag = Symbol("startDrag");
  var onDistanceChange = Symbol("onDistanceChange");
  var MouseSensor = class extends Sensor {
    constructor(containers = [], options = {}) {
      super(containers, options);
      this.mouseDownTimeout = null;
      this.pageX = null;
      this.pageY = null;
      this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);
      this[onMouseDown] = this[onMouseDown].bind(this);
      this[onMouseMove] = this[onMouseMove].bind(this);
      this[onMouseUp] = this[onMouseUp].bind(this);
      this[startDrag] = this[startDrag].bind(this);
      this[onDistanceChange] = this[onDistanceChange].bind(this);
    }
    attach() {
      document.addEventListener("mousedown", this[onMouseDown], true);
    }
    detach() {
      document.removeEventListener("mousedown", this[onMouseDown], true);
    }
    [onMouseDown](event) {
      if (event.button !== 0 || event.ctrlKey || event.metaKey) {
        return;
      }
      const container = closest(event.target, this.containers);
      if (!container) {
        return;
      }
      if (this.options.handle && event.target && !closest(event.target, this.options.handle)) {
        return;
      }
      const originalSource = closest(event.target, this.options.draggable);
      if (!originalSource) {
        return;
      }
      const {
        delay
      } = this;
      const {
        pageX,
        pageY
      } = event;
      Object.assign(this, {
        pageX,
        pageY
      });
      this.onMouseDownAt = Date.now();
      this.startEvent = event;
      this.currentContainer = container;
      this.originalSource = originalSource;
      document.addEventListener("mouseup", this[onMouseUp]);
      document.addEventListener("dragstart", preventNativeDragStart);
      document.addEventListener("mousemove", this[onDistanceChange]);
      this.mouseDownTimeout = window.setTimeout(() => {
        this[onDistanceChange]({
          pageX: this.pageX,
          pageY: this.pageY
        });
      }, delay.mouse);
    }
    [startDrag]() {
      const startEvent = this.startEvent;
      const container = this.currentContainer;
      const originalSource = this.originalSource;
      const dragStartEvent = new DragStartSensorEvent({
        clientX: startEvent.clientX,
        clientY: startEvent.clientY,
        target: startEvent.target,
        container,
        originalSource,
        originalEvent: startEvent
      });
      this.trigger(this.currentContainer, dragStartEvent);
      this.dragging = !dragStartEvent.canceled();
      if (this.dragging) {
        document.addEventListener("contextmenu", this[onContextMenuWhileDragging], true);
        document.addEventListener("mousemove", this[onMouseMove]);
      }
    }
    [onDistanceChange](event) {
      const {
        pageX,
        pageY
      } = event;
      const {
        distance: distance$1
      } = this.options;
      const {
        startEvent,
        delay
      } = this;
      Object.assign(this, {
        pageX,
        pageY
      });
      if (!this.currentContainer) {
        return;
      }
      const timeElapsed = Date.now() - this.onMouseDownAt;
      const distanceTravelled = distance(startEvent.pageX, startEvent.pageY, pageX, pageY) || 0;
      clearTimeout(this.mouseDownTimeout);
      if (timeElapsed < delay.mouse) {
        document.removeEventListener("mousemove", this[onDistanceChange]);
      } else if (distanceTravelled >= distance$1) {
        document.removeEventListener("mousemove", this[onDistanceChange]);
        this[startDrag]();
      }
    }
    [onMouseMove](event) {
      if (!this.dragging) {
        return;
      }
      const target = document.elementFromPoint(event.clientX, event.clientY);
      const dragMoveEvent = new DragMoveSensorEvent({
        clientX: event.clientX,
        clientY: event.clientY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragMoveEvent);
    }
    [onMouseUp](event) {
      clearTimeout(this.mouseDownTimeout);
      if (event.button !== 0) {
        return;
      }
      document.removeEventListener("mouseup", this[onMouseUp]);
      document.removeEventListener("dragstart", preventNativeDragStart);
      document.removeEventListener("mousemove", this[onDistanceChange]);
      if (!this.dragging) {
        return;
      }
      const target = document.elementFromPoint(event.clientX, event.clientY);
      const dragStopEvent = new DragStopSensorEvent({
        clientX: event.clientX,
        clientY: event.clientY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragStopEvent);
      document.removeEventListener("contextmenu", this[onContextMenuWhileDragging], true);
      document.removeEventListener("mousemove", this[onMouseMove]);
      this.currentContainer = null;
      this.dragging = false;
      this.startEvent = null;
    }
    [onContextMenuWhileDragging](event) {
      event.preventDefault();
    }
  };
  function preventNativeDragStart(event) {
    event.preventDefault();
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/touchCoords/touchCoords.mjs
  function touchCoords(event) {
    const {
      touches,
      changedTouches
    } = event;
    return touches && touches[0] || changedTouches && changedTouches[0];
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/TouchSensor/TouchSensor.mjs
  var onTouchStart = Symbol("onTouchStart");
  var onTouchEnd = Symbol("onTouchEnd");
  var onTouchMove = Symbol("onTouchMove");
  var startDrag2 = Symbol("startDrag");
  var onDistanceChange2 = Symbol("onDistanceChange");
  var preventScrolling = false;
  window.addEventListener("touchmove", (event) => {
    if (!preventScrolling) {
      return;
    }
    event.preventDefault();
  }, {
    passive: false
  });
  var TouchSensor = class extends Sensor {
    constructor(containers = [], options = {}) {
      super(containers, options);
      this.currentScrollableParent = null;
      this.tapTimeout = null;
      this.touchMoved = false;
      this.pageX = null;
      this.pageY = null;
      this[onTouchStart] = this[onTouchStart].bind(this);
      this[onTouchEnd] = this[onTouchEnd].bind(this);
      this[onTouchMove] = this[onTouchMove].bind(this);
      this[startDrag2] = this[startDrag2].bind(this);
      this[onDistanceChange2] = this[onDistanceChange2].bind(this);
    }
    attach() {
      document.addEventListener("touchstart", this[onTouchStart]);
    }
    detach() {
      document.removeEventListener("touchstart", this[onTouchStart]);
    }
    [onTouchStart](event) {
      const container = closest(event.target, this.containers);
      if (!container) {
        return;
      }
      if (this.options.handle && event.target && !closest(event.target, this.options.handle)) {
        return;
      }
      const originalSource = closest(event.target, this.options.draggable);
      if (!originalSource) {
        return;
      }
      const {
        distance: distance2 = 0
      } = this.options;
      const {
        delay
      } = this;
      const {
        pageX,
        pageY
      } = touchCoords(event);
      Object.assign(this, {
        pageX,
        pageY
      });
      this.onTouchStartAt = Date.now();
      this.startEvent = event;
      this.currentContainer = container;
      this.originalSource = originalSource;
      document.addEventListener("touchend", this[onTouchEnd]);
      document.addEventListener("touchcancel", this[onTouchEnd]);
      document.addEventListener("touchmove", this[onDistanceChange2]);
      container.addEventListener("contextmenu", onContextMenu);
      if (distance2) {
        preventScrolling = true;
      }
      this.tapTimeout = window.setTimeout(() => {
        this[onDistanceChange2]({
          touches: [{
            pageX: this.pageX,
            pageY: this.pageY
          }]
        });
      }, delay.touch);
    }
    [startDrag2]() {
      const startEvent = this.startEvent;
      const container = this.currentContainer;
      const touch = touchCoords(startEvent);
      const originalSource = this.originalSource;
      const dragStartEvent = new DragStartSensorEvent({
        clientX: touch.pageX,
        clientY: touch.pageY,
        target: startEvent.target,
        container,
        originalSource,
        originalEvent: startEvent
      });
      this.trigger(this.currentContainer, dragStartEvent);
      this.dragging = !dragStartEvent.canceled();
      if (this.dragging) {
        document.addEventListener("touchmove", this[onTouchMove]);
      }
      preventScrolling = this.dragging;
    }
    [onDistanceChange2](event) {
      const {
        distance: distance$1
      } = this.options;
      const {
        startEvent,
        delay
      } = this;
      const start = touchCoords(startEvent);
      const current = touchCoords(event);
      const timeElapsed = Date.now() - this.onTouchStartAt;
      const distanceTravelled = distance(start.pageX, start.pageY, current.pageX, current.pageY);
      Object.assign(this, current);
      clearTimeout(this.tapTimeout);
      if (timeElapsed < delay.touch) {
        document.removeEventListener("touchmove", this[onDistanceChange2]);
      } else if (distanceTravelled >= distance$1) {
        document.removeEventListener("touchmove", this[onDistanceChange2]);
        this[startDrag2]();
      }
    }
    [onTouchMove](event) {
      if (!this.dragging) {
        return;
      }
      const {
        pageX,
        pageY
      } = touchCoords(event);
      const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);
      const dragMoveEvent = new DragMoveSensorEvent({
        clientX: pageX,
        clientY: pageY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragMoveEvent);
    }
    [onTouchEnd](event) {
      clearTimeout(this.tapTimeout);
      preventScrolling = false;
      document.removeEventListener("touchend", this[onTouchEnd]);
      document.removeEventListener("touchcancel", this[onTouchEnd]);
      document.removeEventListener("touchmove", this[onDistanceChange2]);
      if (this.currentContainer) {
        this.currentContainer.removeEventListener("contextmenu", onContextMenu);
      }
      if (!this.dragging) {
        return;
      }
      document.removeEventListener("touchmove", this[onTouchMove]);
      const {
        pageX,
        pageY
      } = touchCoords(event);
      const target = document.elementFromPoint(pageX - window.scrollX, pageY - window.scrollY);
      event.preventDefault();
      const dragStopEvent = new DragStopSensorEvent({
        clientX: pageX,
        clientY: pageY,
        target,
        container: this.currentContainer,
        originalEvent: event
      });
      this.trigger(this.currentContainer, dragStopEvent);
      this.currentContainer = null;
      this.dragging = false;
      this.startEvent = null;
    }
  };
  function onContextMenu(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/DragSensor/DragSensor.mjs
  var onMouseDown2 = Symbol("onMouseDown");
  var onMouseUp2 = Symbol("onMouseUp");
  var onDragStart = Symbol("onDragStart");
  var onDragOver = Symbol("onDragOver");
  var onDragEnd = Symbol("onDragEnd");
  var onDrop = Symbol("onDrop");
  var reset = Symbol("reset");

  // node_modules/@shopify/draggable/build/esm/Draggable/Sensors/ForceTouchSensor/ForceTouchSensor.mjs
  var onMouseForceWillBegin = Symbol("onMouseForceWillBegin");
  var onMouseForceDown = Symbol("onMouseForceDown");
  var onMouseDown3 = Symbol("onMouseDown");
  var onMouseForceChange = Symbol("onMouseForceChange");
  var onMouseMove2 = Symbol("onMouseMove");
  var onMouseUp3 = Symbol("onMouseUp");
  var onMouseForceGlobalChange = Symbol("onMouseForceGlobalChange");

  // node_modules/@shopify/draggable/build/esm/Plugins/index.mjs
  var Plugins_exports = {};
  __export(Plugins_exports, {
    Collidable: () => Collidable,
    ResizeMirror: () => ResizeMirror,
    Snappable: () => Snappable,
    SortAnimation: () => SortAnimation,
    SwapAnimation: () => SwapAnimation,
    defaultResizeMirrorOptions: () => defaultOptions,
    defaultSortAnimationOptions: () => defaultOptions3,
    defaultSwapAnimationOptions: () => defaultOptions2
  });

  // node_modules/@shopify/draggable/build/esm/Plugins/Collidable/CollidableEvent/CollidableEvent.mjs
  var CollidableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  CollidableEvent.type = "collidable";
  var CollidableInEvent = class extends CollidableEvent {
    get collidingElement() {
      return this.data.collidingElement;
    }
  };
  CollidableInEvent.type = "collidable:in";
  var CollidableOutEvent = class extends CollidableEvent {
    get collidingElement() {
      return this.data.collidingElement;
    }
  };
  CollidableOutEvent.type = "collidable:out";

  // node_modules/@shopify/draggable/build/esm/Plugins/Collidable/Collidable.mjs
  var onDragMove = Symbol("onDragMove");
  var onDragStop = Symbol("onDragStop");
  var onRequestAnimationFrame = Symbol("onRequestAnimationFrame");
  var Collidable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.currentlyCollidingElement = null;
      this.lastCollidingElement = null;
      this.currentAnimationFrame = null;
      this[onDragMove] = this[onDragMove].bind(this);
      this[onDragStop] = this[onDragStop].bind(this);
      this[onRequestAnimationFrame] = this[onRequestAnimationFrame].bind(this);
    }
    attach() {
      this.draggable.on("drag:move", this[onDragMove]).on("drag:stop", this[onDragStop]);
    }
    detach() {
      this.draggable.off("drag:move", this[onDragMove]).off("drag:stop", this[onDragStop]);
    }
    getCollidables() {
      const collidables = this.draggable.options.collidables;
      if (typeof collidables === "string") {
        return Array.prototype.slice.call(document.querySelectorAll(collidables));
      } else if (collidables instanceof NodeList || collidables instanceof Array) {
        return Array.prototype.slice.call(collidables);
      } else if (collidables instanceof HTMLElement) {
        return [collidables];
      } else if (typeof collidables === "function") {
        return collidables();
      } else {
        return [];
      }
    }
    [onDragMove](event) {
      const target = event.sensorEvent.target;
      this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));
      if (this.currentlyCollidingElement) {
        event.cancel();
      }
      const collidableInEvent = new CollidableInEvent({
        dragEvent: event,
        collidingElement: this.currentlyCollidingElement
      });
      const collidableOutEvent = new CollidableOutEvent({
        dragEvent: event,
        collidingElement: this.lastCollidingElement
      });
      const enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);
      const leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);
      if (enteringCollidable) {
        if (this.lastCollidingElement) {
          this.draggable.trigger(collidableOutEvent);
        }
        this.draggable.trigger(collidableInEvent);
      } else if (leavingCollidable) {
        this.draggable.trigger(collidableOutEvent);
      }
      this.lastCollidingElement = this.currentlyCollidingElement;
    }
    [onDragStop](event) {
      const lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;
      const collidableOutEvent = new CollidableOutEvent({
        dragEvent: event,
        collidingElement: lastCollidingElement
      });
      if (lastCollidingElement) {
        this.draggable.trigger(collidableOutEvent);
      }
      this.lastCollidingElement = null;
      this.currentlyCollidingElement = null;
    }
    [onRequestAnimationFrame](target) {
      return () => {
        const collidables = this.getCollidables();
        this.currentlyCollidingElement = closest(target, (element) => collidables.includes(element));
      };
    }
  };

  // node_modules/@shopify/draggable/build/esm/_virtual/_rollupPluginBabelHelpers.mjs
  function createAddInitializerMethod(e, t) {
    return function(r) {
      assertNotFinished(t, "addInitializer"), assertCallable(r, "An initializer"), e.push(r);
    };
  }
  function assertInstanceIfPrivate(e, t) {
    if (!e(t))
      throw new TypeError("Attempted to access private element on non-instance");
  }
  function memberDec(e, t, r, a, n, i, s, o, c, l, u) {
    var f;
    switch (i) {
      case 1:
        f = "accessor";
        break;
      case 2:
        f = "method";
        break;
      case 3:
        f = "getter";
        break;
      case 4:
        f = "setter";
        break;
      default:
        f = "field";
    }
    var d, p, h = {
      kind: f,
      name: o ? "#" + r : r,
      static: s,
      private: o,
      metadata: u
    }, v = {
      v: false
    };
    if (i !== 0 && (h.addInitializer = createAddInitializerMethod(n, v)), o || i !== 0 && i !== 2) {
      if (i === 2)
        d = function(e2) {
          return assertInstanceIfPrivate(l, e2), a.value;
        };
      else {
        var y = i === 0 || i === 1;
        (y || i === 3) && (d = o ? function(e2) {
          return assertInstanceIfPrivate(l, e2), a.get.call(e2);
        } : function(e2) {
          return a.get.call(e2);
        }), (y || i === 4) && (p = o ? function(e2, t2) {
          assertInstanceIfPrivate(l, e2), a.set.call(e2, t2);
        } : function(e2, t2) {
          a.set.call(e2, t2);
        });
      }
    } else
      d = function(e2) {
        return e2[r];
      }, i === 0 && (p = function(e2, t2) {
        e2[r] = t2;
      });
    var m = o ? l.bind() : function(e2) {
      return r in e2;
    };
    h.access = d && p ? {
      get: d,
      set: p,
      has: m
    } : d ? {
      get: d,
      has: m
    } : {
      set: p,
      has: m
    };
    try {
      return e.call(t, c, h);
    } finally {
      v.v = true;
    }
  }
  function assertNotFinished(e, t) {
    if (e.v)
      throw new Error("attempted to call " + t + " after decoration was finished");
  }
  function assertCallable(e, t) {
    if (typeof e != "function")
      throw new TypeError(t + " must be a function");
  }
  function assertValidReturnValue(e, t) {
    var r = typeof t;
    if (e === 1) {
      if (r !== "object" || t === null)
        throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
      t.get !== void 0 && assertCallable(t.get, "accessor.get"), t.set !== void 0 && assertCallable(t.set, "accessor.set"), t.init !== void 0 && assertCallable(t.init, "accessor.init");
    } else if (r !== "function") {
      var a;
      throw a = e === 0 ? "field" : e === 5 ? "class" : "method", new TypeError(a + " decorators must return a function or void 0");
    }
  }
  function curryThis1(e) {
    return function() {
      return e(this);
    };
  }
  function curryThis2(e) {
    return function(t) {
      e(this, t);
    };
  }
  function applyMemberDec(e, t, r, a, n, i, s, o, c, l, u) {
    var f, d, p, h, v, y, m = r[0];
    a || Array.isArray(m) || (m = [m]), o ? f = i === 0 || i === 1 ? {
      get: curryThis1(r[3]),
      set: curryThis2(r[4])
    } : i === 3 ? {
      get: r[3]
    } : i === 4 ? {
      set: r[3]
    } : {
      value: r[3]
    } : i !== 0 && (f = Object.getOwnPropertyDescriptor(t, n)), i === 1 ? p = {
      get: f.get,
      set: f.set
    } : i === 2 ? p = f.value : i === 3 ? p = f.get : i === 4 && (p = f.set);
    for (var g = a ? 2 : 1, b = m.length - 1; b >= 0; b -= g) {
      var I;
      if ((h = memberDec(m[b], a ? m[b - 1] : void 0, n, f, c, i, s, o, p, l, u)) !== void 0)
        assertValidReturnValue(i, h), i === 0 ? I = h : i === 1 ? (I = h.init, v = h.get || p.get, y = h.set || p.set, p = {
          get: v,
          set: y
        }) : p = h, I !== void 0 && (d === void 0 ? d = I : typeof d == "function" ? d = [d, I] : d.push(I));
    }
    if (i === 0 || i === 1) {
      if (d === void 0)
        d = function(e2, t2) {
          return t2;
        };
      else if (typeof d != "function") {
        var w = d;
        d = function(e2, t2) {
          for (var r2 = t2, a2 = w.length - 1; a2 >= 0; a2--)
            r2 = w[a2].call(e2, r2);
          return r2;
        };
      } else {
        var M = d;
        d = function(e2, t2) {
          return M.call(e2, t2);
        };
      }
      e.push(d);
    }
    i !== 0 && (i === 1 ? (f.get = p.get, f.set = p.set) : i === 2 ? f.value = p : i === 3 ? f.get = p : i === 4 && (f.set = p), o ? i === 1 ? (e.push(function(e2, t2) {
      return p.get.call(e2, t2);
    }), e.push(function(e2, t2) {
      return p.set.call(e2, t2);
    })) : i === 2 ? e.push(p) : e.push(function(e2, t2) {
      return p.call(e2, t2);
    }) : Object.defineProperty(t, n, f));
  }
  function applyMemberDecs(e, t, r, a) {
    for (var n, i, s, o = [], c = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), u = 0; u < t.length; u++) {
      var f = t[u];
      if (Array.isArray(f)) {
        var d, p, h = f[1], v = f[2], y = f.length > 3, m = 16 & h, g = !!(8 & h), b = r;
        if (h &= 7, g ? (d = e, h !== 0 && (p = i = i || []), y && !s && (s = function(t2) {
          return _checkInRHS(t2) === e;
        }), b = s) : (d = e.prototype, h !== 0 && (p = n = n || [])), h !== 0 && !y) {
          var I = g ? l : c, w = I.get(v) || 0;
          if (w === true || w === 3 && h !== 4 || w === 4 && h !== 3)
            throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + v);
          I.set(v, !(!w && h > 2) || h);
        }
        applyMemberDec(o, d, f, m, v, h, g, y, p, b, a);
      }
    }
    return pushInitializers(o, n), pushInitializers(o, i), o;
  }
  function pushInitializers(e, t) {
    t && e.push(function(e2) {
      for (var r = 0; r < t.length; r++)
        t[r].call(e2);
      return e2;
    });
  }
  function applyClassDecs(e, t, r, a) {
    if (t.length) {
      for (var n = [], i = e, s = e.name, o = r ? 2 : 1, c = t.length - 1; c >= 0; c -= o) {
        var l = {
          v: false
        };
        try {
          var u = t[c].call(r ? t[c - 1] : void 0, i, {
            kind: "class",
            name: s,
            addInitializer: createAddInitializerMethod(n, l),
            metadata: a
          });
        } finally {
          l.v = true;
        }
        u !== void 0 && (assertValidReturnValue(5, u), i = u);
      }
      return [defineMetadata(i, a), function() {
        for (var e2 = 0; e2 < n.length; e2++)
          n[e2].call(i);
      }];
    }
  }
  function defineMetadata(e, t) {
    return Object.defineProperty(e, Symbol.metadata || Symbol.for("Symbol.metadata"), {
      configurable: true,
      enumerable: true,
      value: t
    });
  }
  function _applyDecs2305(e, t, r, a, n, i) {
    if (arguments.length >= 6)
      var s = i[Symbol.metadata || Symbol.for("Symbol.metadata")];
    var o = Object.create(s === void 0 ? null : s), c = applyMemberDecs(e, t, n, o);
    return r.length || defineMetadata(e, o), {
      e: c,
      get c() {
        return applyClassDecs(e, r, a, o);
      }
    };
  }
  function _checkInRHS(e) {
    if (Object(e) !== e)
      throw TypeError("right-hand side of 'in' should be an object, got " + (e !== null ? typeof e : "null"));
    return e;
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/decorators/AutoBind.mjs
  function AutoBind(originalMethod, {
    name,
    addInitializer
  }) {
    addInitializer(function() {
      this[name] = originalMethod.bind(this);
    });
  }

  // node_modules/@shopify/draggable/build/esm/shared/utils/requestNextAnimationFrame/requestNextAnimationFrame.mjs
  function requestNextAnimationFrame(callback) {
    return requestAnimationFrame(() => {
      requestAnimationFrame(callback);
    });
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/DragEvent/DragEvent.mjs
  var DragEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get source() {
      return this.data.source;
    }
    get originalSource() {
      return this.data.originalSource;
    }
    get mirror() {
      return this.data.mirror;
    }
    get sourceContainer() {
      return this.data.sourceContainer;
    }
    get sensorEvent() {
      return this.data.sensorEvent;
    }
    get originalEvent() {
      if (this.sensorEvent) {
        return this.sensorEvent.originalEvent;
      }
      return null;
    }
  };
  DragEvent.type = "drag";
  var DragStartEvent = class extends DragEvent {
  };
  DragStartEvent.type = "drag:start";
  DragStartEvent.cancelable = true;
  var DragMoveEvent = class extends DragEvent {
  };
  DragMoveEvent.type = "drag:move";
  var DragOverEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
    get over() {
      return this.data.over;
    }
  };
  DragOverEvent.type = "drag:over";
  DragOverEvent.cancelable = true;
  function isDragOverEvent(event) {
    return event.type === DragOverEvent.type;
  }
  var DragOutEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
    get over() {
      return this.data.over;
    }
  };
  DragOutEvent.type = "drag:out";
  var DragOverContainerEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
  };
  DragOverContainerEvent.type = "drag:over:container";
  var DragOutContainerEvent = class extends DragEvent {
    get overContainer() {
      return this.data.overContainer;
    }
  };
  DragOutContainerEvent.type = "drag:out:container";
  var DragPressureEvent = class extends DragEvent {
    get pressure() {
      return this.data.pressure;
    }
  };
  DragPressureEvent.type = "drag:pressure";
  var DragStopEvent = class extends DragEvent {
  };
  DragStopEvent.type = "drag:stop";
  DragStopEvent.cancelable = true;
  var DragStoppedEvent = class extends DragEvent {
  };
  DragStoppedEvent.type = "drag:stopped";

  // node_modules/@shopify/draggable/build/esm/Plugins/ResizeMirror/ResizeMirror.mjs
  var _initProto;
  var _class;
  var defaultOptions = {};
  var ResizeMirror = class extends AbstractPlugin {
    constructor(draggable) {
      _initProto(super(draggable));
      this.lastWidth = 0;
      this.lastHeight = 0;
      this.mirror = null;
    }
    attach() {
      this.draggable.on("mirror:created", this.onMirrorCreated).on("drag:over", this.onDragOver).on("drag:over:container", this.onDragOver);
    }
    detach() {
      this.draggable.off("mirror:created", this.onMirrorCreated).off("mirror:destroy", this.onMirrorDestroy).off("drag:over", this.onDragOver).off("drag:over:container", this.onDragOver);
    }
    getOptions() {
      return this.draggable.options.resizeMirror || {};
    }
    onMirrorCreated({
      mirror
    }) {
      this.mirror = mirror;
    }
    onMirrorDestroy() {
      this.mirror = null;
    }
    onDragOver(dragEvent) {
      this.resize(dragEvent);
    }
    resize(dragEvent) {
      requestAnimationFrame(() => {
        let over = null;
        const {
          overContainer
        } = dragEvent;
        if (this.mirror == null || this.mirror.parentNode == null) {
          return;
        }
        if (this.mirror.parentNode !== overContainer) {
          overContainer.appendChild(this.mirror);
        }
        if (isDragOverEvent(dragEvent)) {
          over = dragEvent.over;
        }
        const overElement = over || this.draggable.getDraggableElementsForContainer(overContainer)[0];
        if (!overElement) {
          return;
        }
        requestNextAnimationFrame(() => {
          const overRect = overElement.getBoundingClientRect();
          if (this.mirror == null || this.lastHeight === overRect.height && this.lastWidth === overRect.width) {
            return;
          }
          this.mirror.style.width = `${overRect.width}px`;
          this.mirror.style.height = `${overRect.height}px`;
          this.lastWidth = overRect.width;
          this.lastHeight = overRect.height;
        });
      });
    }
  };
  _class = ResizeMirror;
  [_initProto] = _applyDecs2305(_class, [[AutoBind, 2, "onMirrorCreated"], [AutoBind, 2, "onMirrorDestroy"], [AutoBind, 2, "onDragOver"]], [], 0, void 0, AbstractPlugin).e;

  // node_modules/@shopify/draggable/build/esm/Plugins/Snappable/SnappableEvent/SnappableEvent.mjs
  var SnapEvent = class extends AbstractEvent {
    get dragEvent() {
      return this.data.dragEvent;
    }
    get snappable() {
      return this.data.snappable;
    }
  };
  SnapEvent.type = "snap";
  var SnapInEvent = class extends SnapEvent {
  };
  SnapInEvent.type = "snap:in";
  SnapInEvent.cancelable = true;
  var SnapOutEvent = class extends SnapEvent {
  };
  SnapOutEvent.type = "snap:out";
  SnapOutEvent.cancelable = true;

  // node_modules/@shopify/draggable/build/esm/Plugins/Snappable/Snappable.mjs
  var onDragStart2 = Symbol("onDragStart");
  var onDragStop2 = Symbol("onDragStop");
  var onDragOver2 = Symbol("onDragOver");
  var onDragOut = Symbol("onDragOut");
  var onMirrorCreated = Symbol("onMirrorCreated");
  var onMirrorDestroy = Symbol("onMirrorDestroy");
  var Snappable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.firstSource = null;
      this.mirror = null;
      this[onDragStart2] = this[onDragStart2].bind(this);
      this[onDragStop2] = this[onDragStop2].bind(this);
      this[onDragOver2] = this[onDragOver2].bind(this);
      this[onDragOut] = this[onDragOut].bind(this);
      this[onMirrorCreated] = this[onMirrorCreated].bind(this);
      this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);
    }
    attach() {
      this.draggable.on("drag:start", this[onDragStart2]).on("drag:stop", this[onDragStop2]).on("drag:over", this[onDragOver2]).on("drag:out", this[onDragOut]).on("droppable:over", this[onDragOver2]).on("droppable:out", this[onDragOut]).on("mirror:created", this[onMirrorCreated]).on("mirror:destroy", this[onMirrorDestroy]);
    }
    detach() {
      this.draggable.off("drag:start", this[onDragStart2]).off("drag:stop", this[onDragStop2]).off("drag:over", this[onDragOver2]).off("drag:out", this[onDragOut]).off("droppable:over", this[onDragOver2]).off("droppable:out", this[onDragOut]).off("mirror:created", this[onMirrorCreated]).off("mirror:destroy", this[onMirrorDestroy]);
    }
    [onDragStart2](event) {
      if (event.canceled()) {
        return;
      }
      this.firstSource = event.source;
    }
    [onDragStop2]() {
      this.firstSource = null;
    }
    [onDragOver2](event) {
      if (event.canceled()) {
        return;
      }
      const source = event.source || event.dragEvent.source;
      if (source === this.firstSource) {
        this.firstSource = null;
        return;
      }
      const snapInEvent = new SnapInEvent({
        dragEvent: event,
        snappable: event.over || event.droppable
      });
      this.draggable.trigger(snapInEvent);
      if (snapInEvent.canceled()) {
        return;
      }
      if (this.mirror) {
        this.mirror.style.display = "none";
      }
      source.classList.remove(...this.draggable.getClassNamesFor("source:dragging"));
      source.classList.add(...this.draggable.getClassNamesFor("source:placed"));
      setTimeout(() => {
        source.classList.remove(...this.draggable.getClassNamesFor("source:placed"));
      }, this.draggable.options.placedTimeout);
    }
    [onDragOut](event) {
      if (event.canceled()) {
        return;
      }
      const source = event.source || event.dragEvent.source;
      const snapOutEvent = new SnapOutEvent({
        dragEvent: event,
        snappable: event.over || event.droppable
      });
      this.draggable.trigger(snapOutEvent);
      if (snapOutEvent.canceled()) {
        return;
      }
      if (this.mirror) {
        this.mirror.style.display = "";
      }
      source.classList.add(...this.draggable.getClassNamesFor("source:dragging"));
    }
    [onMirrorCreated]({
      mirror
    }) {
      this.mirror = mirror;
    }
    [onMirrorDestroy]() {
      this.mirror = null;
    }
  };

  // node_modules/@shopify/draggable/build/esm/Plugins/SwapAnimation/SwapAnimation.mjs
  var _initProto2;
  var _class2;
  var defaultOptions2 = {
    duration: 150,
    easingFunction: "ease-in-out",
    horizontal: false
  };
  var SwapAnimation = class extends AbstractPlugin {
    constructor(draggable) {
      _initProto2(super(draggable));
      this.options = __spreadValues(__spreadValues({}, defaultOptions2), this.getOptions());
      this.lastAnimationFrame = null;
    }
    attach() {
      this.draggable.on("sortable:sorted", this.onSortableSorted);
    }
    detach() {
      this.draggable.off("sortable:sorted", this.onSortableSorted);
    }
    getOptions() {
      return this.draggable.options.swapAnimation || {};
    }
    onSortableSorted({
      oldIndex,
      newIndex,
      dragEvent
    }) {
      const {
        source,
        over
      } = dragEvent;
      if (this.lastAnimationFrame) {
        cancelAnimationFrame(this.lastAnimationFrame);
      }
      this.lastAnimationFrame = requestAnimationFrame(() => {
        if (oldIndex >= newIndex) {
          animate(source, over, this.options);
        } else {
          animate(over, source, this.options);
        }
      });
    }
  };
  _class2 = SwapAnimation;
  [_initProto2] = _applyDecs2305(_class2, [[AutoBind, 2, "onSortableSorted"]], [], 0, void 0, AbstractPlugin).e;
  function animate(from, to, {
    duration,
    easingFunction,
    horizontal
  }) {
    for (const element of [from, to]) {
      element.style.pointerEvents = "none";
    }
    if (horizontal) {
      const width = from.offsetWidth;
      from.style.transform = `translate3d(${width}px, 0, 0)`;
      to.style.transform = `translate3d(-${width}px, 0, 0)`;
    } else {
      const height = from.offsetHeight;
      from.style.transform = `translate3d(0, ${height}px, 0)`;
      to.style.transform = `translate3d(0, -${height}px, 0)`;
    }
    requestAnimationFrame(() => {
      for (const element of [from, to]) {
        element.addEventListener("transitionend", resetElementOnTransitionEnd);
        element.style.transition = `transform ${duration}ms ${easingFunction}`;
        element.style.transform = "";
      }
    });
  }
  function resetElementOnTransitionEnd(event) {
    if (event.target == null || !isHTMLElement(event.target)) {
      return;
    }
    event.target.style.transition = "";
    event.target.style.pointerEvents = "";
    event.target.removeEventListener("transitionend", resetElementOnTransitionEnd);
  }
  function isHTMLElement(eventTarget) {
    return Boolean("style" in eventTarget);
  }

  // node_modules/@shopify/draggable/build/esm/Plugins/SortAnimation/SortAnimation.mjs
  var onSortableSorted = Symbol("onSortableSorted");
  var onSortableSort = Symbol("onSortableSort");
  var defaultOptions3 = {
    duration: 150,
    easingFunction: "ease-in-out"
  };
  var SortAnimation = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions3), this.getOptions());
      this.lastAnimationFrame = null;
      this.lastElements = [];
      this[onSortableSorted] = this[onSortableSorted].bind(this);
      this[onSortableSort] = this[onSortableSort].bind(this);
    }
    attach() {
      this.draggable.on("sortable:sort", this[onSortableSort]);
      this.draggable.on("sortable:sorted", this[onSortableSorted]);
    }
    detach() {
      this.draggable.off("sortable:sort", this[onSortableSort]);
      this.draggable.off("sortable:sorted", this[onSortableSorted]);
    }
    getOptions() {
      return this.draggable.options.sortAnimation || {};
    }
    [onSortableSort]({
      dragEvent
    }) {
      const {
        sourceContainer
      } = dragEvent;
      const elements = this.draggable.getDraggableElementsForContainer(sourceContainer);
      this.lastElements = Array.from(elements).map((el) => {
        return {
          domEl: el,
          offsetTop: el.offsetTop,
          offsetLeft: el.offsetLeft
        };
      });
    }
    [onSortableSorted]({
      oldIndex,
      newIndex
    }) {
      if (oldIndex === newIndex) {
        return;
      }
      const effectedElements = [];
      let start;
      let end;
      let num;
      if (oldIndex > newIndex) {
        start = newIndex;
        end = oldIndex - 1;
        num = 1;
      } else {
        start = oldIndex + 1;
        end = newIndex;
        num = -1;
      }
      for (let i = start; i <= end; i++) {
        const from = this.lastElements[i];
        const to = this.lastElements[i + num];
        effectedElements.push({
          from,
          to
        });
      }
      cancelAnimationFrame(this.lastAnimationFrame);
      this.lastAnimationFrame = requestAnimationFrame(() => {
        effectedElements.forEach((element) => animate2(element, this.options));
      });
    }
  };
  function animate2({
    from,
    to
  }, {
    duration,
    easingFunction
  }) {
    const domEl = from.domEl;
    const x = from.offsetLeft - to.offsetLeft;
    const y = from.offsetTop - to.offsetTop;
    domEl.style.pointerEvents = "none";
    domEl.style.transform = `translate3d(${x}px, ${y}px, 0)`;
    requestAnimationFrame(() => {
      domEl.addEventListener("transitionend", resetElementOnTransitionEnd2);
      domEl.style.transition = `transform ${duration}ms ${easingFunction}`;
      domEl.style.transform = "";
    });
  }
  function resetElementOnTransitionEnd2(event) {
    event.target.style.transition = "";
    event.target.style.pointerEvents = "";
    event.target.removeEventListener("transitionend", resetElementOnTransitionEnd2);
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Announcement/Announcement.mjs
  var onInitialize = Symbol("onInitialize");
  var onDestroy = Symbol("onDestroy");
  var announceEvent = Symbol("announceEvent");
  var announceMessage = Symbol("announceMessage");
  var ARIA_RELEVANT = "aria-relevant";
  var ARIA_ATOMIC = "aria-atomic";
  var ARIA_LIVE = "aria-live";
  var ROLE = "role";
  var defaultOptions4 = {
    expire: 7e3
  };
  var Announcement = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions4), this.getOptions());
      this.originalTriggerMethod = this.draggable.trigger;
      this[onInitialize] = this[onInitialize].bind(this);
      this[onDestroy] = this[onDestroy].bind(this);
    }
    attach() {
      this.draggable.on("draggable:initialize", this[onInitialize]);
    }
    detach() {
      this.draggable.off("draggable:destroy", this[onDestroy]);
    }
    getOptions() {
      return this.draggable.options.announcements || {};
    }
    [announceEvent](event) {
      const message = this.options[event.type];
      if (message && typeof message === "string") {
        this[announceMessage](message);
      }
      if (message && typeof message === "function") {
        this[announceMessage](message(event));
      }
    }
    [announceMessage](message) {
      announce(message, {
        expire: this.options.expire
      });
    }
    [onInitialize]() {
      this.draggable.trigger = (event) => {
        try {
          this[announceEvent](event);
        } finally {
          this.originalTriggerMethod.call(this.draggable, event);
        }
      };
    }
    [onDestroy]() {
      this.draggable.trigger = this.originalTriggerMethod;
    }
  };
  var liveRegion = createRegion();
  function announce(message, {
    expire
  }) {
    const element = document.createElement("div");
    element.textContent = message;
    liveRegion.appendChild(element);
    return setTimeout(() => {
      liveRegion.removeChild(element);
    }, expire);
  }
  function createRegion() {
    const element = document.createElement("div");
    element.setAttribute("id", "draggable-live-region");
    element.setAttribute(ARIA_RELEVANT, "additions");
    element.setAttribute(ARIA_ATOMIC, "true");
    element.setAttribute(ARIA_LIVE, "assertive");
    element.setAttribute(ROLE, "log");
    element.style.position = "fixed";
    element.style.width = "1px";
    element.style.height = "1px";
    element.style.top = "-1px";
    element.style.overflow = "hidden";
    return element;
  }
  document.addEventListener("DOMContentLoaded", () => {
    document.body.appendChild(liveRegion);
  });

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Focusable/Focusable.mjs
  var onInitialize2 = Symbol("onInitialize");
  var onDestroy2 = Symbol("onDestroy");
  var defaultOptions5 = {};
  var Focusable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions5), this.getOptions());
      this[onInitialize2] = this[onInitialize2].bind(this);
      this[onDestroy2] = this[onDestroy2].bind(this);
    }
    attach() {
      this.draggable.on("draggable:initialize", this[onInitialize2]).on("draggable:destroy", this[onDestroy2]);
    }
    detach() {
      this.draggable.off("draggable:initialize", this[onInitialize2]).off("draggable:destroy", this[onDestroy2]);
      this[onDestroy2]();
    }
    getOptions() {
      return this.draggable.options.focusable || {};
    }
    getElements() {
      return [...this.draggable.containers, ...this.draggable.getDraggableElements()];
    }
    [onInitialize2]() {
      requestAnimationFrame(() => {
        this.getElements().forEach((element) => decorateElement(element));
      });
    }
    [onDestroy2]() {
      requestAnimationFrame(() => {
        this.getElements().forEach((element) => stripElement(element));
      });
    }
  };
  var elementsWithMissingTabIndex = [];
  function decorateElement(element) {
    const hasMissingTabIndex = Boolean(!element.getAttribute("tabindex") && element.tabIndex === -1);
    if (hasMissingTabIndex) {
      elementsWithMissingTabIndex.push(element);
      element.tabIndex = 0;
    }
  }
  function stripElement(element) {
    const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);
    if (tabIndexElementPosition !== -1) {
      element.tabIndex = -1;
      elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);
    }
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Mirror/MirrorEvent/MirrorEvent.mjs
  var MirrorEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get source() {
      return this.data.source;
    }
    get originalSource() {
      return this.data.originalSource;
    }
    get sourceContainer() {
      return this.data.sourceContainer;
    }
    get sensorEvent() {
      return this.data.sensorEvent;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
    get originalEvent() {
      if (this.sensorEvent) {
        return this.sensorEvent.originalEvent;
      }
      return null;
    }
  };
  var MirrorCreateEvent = class extends MirrorEvent {
  };
  MirrorCreateEvent.type = "mirror:create";
  var MirrorCreatedEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
  };
  MirrorCreatedEvent.type = "mirror:created";
  var MirrorAttachedEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
  };
  MirrorAttachedEvent.type = "mirror:attached";
  var MirrorMoveEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
    get passedThreshX() {
      return this.data.passedThreshX;
    }
    get passedThreshY() {
      return this.data.passedThreshY;
    }
  };
  MirrorMoveEvent.type = "mirror:move";
  MirrorMoveEvent.cancelable = true;
  var MirrorMovedEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
    get passedThreshX() {
      return this.data.passedThreshX;
    }
    get passedThreshY() {
      return this.data.passedThreshY;
    }
  };
  MirrorMovedEvent.type = "mirror:moved";
  var MirrorDestroyEvent = class extends MirrorEvent {
    get mirror() {
      return this.data.mirror;
    }
  };
  MirrorDestroyEvent.type = "mirror:destroy";
  MirrorDestroyEvent.cancelable = true;

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Mirror/Mirror.mjs
  var onDragStart3 = Symbol("onDragStart");
  var onDragMove2 = Symbol("onDragMove");
  var onDragStop3 = Symbol("onDragStop");
  var onMirrorCreated2 = Symbol("onMirrorCreated");
  var onMirrorMove = Symbol("onMirrorMove");
  var onScroll = Symbol("onScroll");
  var getAppendableContainer = Symbol("getAppendableContainer");
  var defaultOptions6 = {
    constrainDimensions: false,
    xAxis: true,
    yAxis: true,
    cursorOffsetX: null,
    cursorOffsetY: null,
    thresholdX: null,
    thresholdY: null
  };
  var Mirror = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions6), this.getOptions());
      this.scrollOffset = {
        x: 0,
        y: 0
      };
      this.initialScrollOffset = {
        x: window.scrollX,
        y: window.scrollY
      };
      this[onDragStart3] = this[onDragStart3].bind(this);
      this[onDragMove2] = this[onDragMove2].bind(this);
      this[onDragStop3] = this[onDragStop3].bind(this);
      this[onMirrorCreated2] = this[onMirrorCreated2].bind(this);
      this[onMirrorMove] = this[onMirrorMove].bind(this);
      this[onScroll] = this[onScroll].bind(this);
    }
    attach() {
      this.draggable.on("drag:start", this[onDragStart3]).on("drag:move", this[onDragMove2]).on("drag:stop", this[onDragStop3]).on("mirror:created", this[onMirrorCreated2]).on("mirror:move", this[onMirrorMove]);
    }
    detach() {
      this.draggable.off("drag:start", this[onDragStart3]).off("drag:move", this[onDragMove2]).off("drag:stop", this[onDragStop3]).off("mirror:created", this[onMirrorCreated2]).off("mirror:move", this[onMirrorMove]);
    }
    getOptions() {
      return this.draggable.options.mirror || {};
    }
    [onDragStart3](dragEvent) {
      if (dragEvent.canceled()) {
        return;
      }
      if ("ontouchstart" in window) {
        document.addEventListener("scroll", this[onScroll], true);
      }
      this.initialScrollOffset = {
        x: window.scrollX,
        y: window.scrollY
      };
      const {
        source,
        originalSource,
        sourceContainer,
        sensorEvent
      } = dragEvent;
      this.lastMirrorMovedClient = {
        x: sensorEvent.clientX,
        y: sensorEvent.clientY
      };
      const mirrorCreateEvent = new MirrorCreateEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent
      });
      this.draggable.trigger(mirrorCreateEvent);
      if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {
        return;
      }
      const appendableContainer = this[getAppendableContainer](source) || sourceContainer;
      this.mirror = source.cloneNode(true);
      const mirrorCreatedEvent = new MirrorCreatedEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent,
        mirror: this.mirror
      });
      const mirrorAttachedEvent = new MirrorAttachedEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent,
        mirror: this.mirror
      });
      this.draggable.trigger(mirrorCreatedEvent);
      appendableContainer.appendChild(this.mirror);
      this.draggable.trigger(mirrorAttachedEvent);
    }
    [onDragMove2](dragEvent) {
      if (!this.mirror || dragEvent.canceled()) {
        return;
      }
      const {
        source,
        originalSource,
        sourceContainer,
        sensorEvent
      } = dragEvent;
      let passedThreshX = true;
      let passedThreshY = true;
      if (this.options.thresholdX || this.options.thresholdY) {
        const {
          x: lastX,
          y: lastY
        } = this.lastMirrorMovedClient;
        if (Math.abs(lastX - sensorEvent.clientX) < this.options.thresholdX) {
          passedThreshX = false;
        } else {
          this.lastMirrorMovedClient.x = sensorEvent.clientX;
        }
        if (Math.abs(lastY - sensorEvent.clientY) < this.options.thresholdY) {
          passedThreshY = false;
        } else {
          this.lastMirrorMovedClient.y = sensorEvent.clientY;
        }
        if (!passedThreshX && !passedThreshY) {
          return;
        }
      }
      const mirrorMoveEvent = new MirrorMoveEvent({
        source,
        originalSource,
        sourceContainer,
        sensorEvent,
        dragEvent,
        mirror: this.mirror,
        passedThreshX,
        passedThreshY
      });
      this.draggable.trigger(mirrorMoveEvent);
    }
    [onDragStop3](dragEvent) {
      if ("ontouchstart" in window) {
        document.removeEventListener("scroll", this[onScroll], true);
      }
      this.initialScrollOffset = {
        x: 0,
        y: 0
      };
      this.scrollOffset = {
        x: 0,
        y: 0
      };
      if (!this.mirror) {
        return;
      }
      const {
        source,
        sourceContainer,
        sensorEvent
      } = dragEvent;
      const mirrorDestroyEvent = new MirrorDestroyEvent({
        source,
        mirror: this.mirror,
        sourceContainer,
        sensorEvent,
        dragEvent
      });
      this.draggable.trigger(mirrorDestroyEvent);
      if (!mirrorDestroyEvent.canceled()) {
        this.mirror.remove();
      }
    }
    [onScroll]() {
      this.scrollOffset = {
        x: window.scrollX - this.initialScrollOffset.x,
        y: window.scrollY - this.initialScrollOffset.y
      };
    }
    [onMirrorCreated2]({
      mirror,
      source,
      sensorEvent
    }) {
      const mirrorClasses = this.draggable.getClassNamesFor("mirror");
      const setState = (_a) => {
        var _b = _a, {
          mirrorOffset,
          initialX,
          initialY
        } = _b, args = __objRest(_b, [
          "mirrorOffset",
          "initialX",
          "initialY"
        ]);
        this.mirrorOffset = mirrorOffset;
        this.initialX = initialX;
        this.initialY = initialY;
        this.lastMovedX = initialX;
        this.lastMovedY = initialY;
        return __spreadValues({
          mirrorOffset,
          initialX,
          initialY
        }, args);
      };
      mirror.style.display = "none";
      const initialState = {
        mirror,
        source,
        sensorEvent,
        mirrorClasses,
        scrollOffset: this.scrollOffset,
        options: this.options,
        passedThreshX: true,
        passedThreshY: true
      };
      return Promise.resolve(initialState).then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({
        initial: true
      })).then(removeMirrorID).then(setState);
    }
    [onMirrorMove](mirrorEvent) {
      if (mirrorEvent.canceled()) {
        return null;
      }
      const setState = (_a) => {
        var _b = _a, {
          lastMovedX,
          lastMovedY
        } = _b, args = __objRest(_b, [
          "lastMovedX",
          "lastMovedY"
        ]);
        this.lastMovedX = lastMovedX;
        this.lastMovedY = lastMovedY;
        return __spreadValues({
          lastMovedX,
          lastMovedY
        }, args);
      };
      const triggerMoved = (args) => {
        const mirrorMovedEvent = new MirrorMovedEvent({
          source: mirrorEvent.source,
          originalSource: mirrorEvent.originalSource,
          sourceContainer: mirrorEvent.sourceContainer,
          sensorEvent: mirrorEvent.sensorEvent,
          dragEvent: mirrorEvent.dragEvent,
          mirror: this.mirror,
          passedThreshX: mirrorEvent.passedThreshX,
          passedThreshY: mirrorEvent.passedThreshY
        });
        this.draggable.trigger(mirrorMovedEvent);
        return args;
      };
      const initialState = {
        mirror: mirrorEvent.mirror,
        sensorEvent: mirrorEvent.sensorEvent,
        mirrorOffset: this.mirrorOffset,
        options: this.options,
        initialX: this.initialX,
        initialY: this.initialY,
        scrollOffset: this.scrollOffset,
        passedThreshX: mirrorEvent.passedThreshX,
        passedThreshY: mirrorEvent.passedThreshY,
        lastMovedX: this.lastMovedX,
        lastMovedY: this.lastMovedY
      };
      return Promise.resolve(initialState).then(positionMirror({
        raf: true
      })).then(setState).then(triggerMoved);
    }
    [getAppendableContainer](source) {
      const appendTo = this.options.appendTo;
      if (typeof appendTo === "string") {
        return document.querySelector(appendTo);
      } else if (appendTo instanceof HTMLElement) {
        return appendTo;
      } else if (typeof appendTo === "function") {
        return appendTo(source);
      } else {
        return source.parentNode;
      }
    }
  };
  function computeMirrorDimensions(_a) {
    var _b = _a, {
      source
    } = _b, args = __objRest(_b, [
      "source"
    ]);
    return withPromise((resolve) => {
      const sourceRect = source.getBoundingClientRect();
      resolve(__spreadValues({
        source,
        sourceRect
      }, args));
    });
  }
  function calculateMirrorOffset(_a) {
    var _b = _a, {
      sensorEvent,
      sourceRect,
      options
    } = _b, args = __objRest(_b, [
      "sensorEvent",
      "sourceRect",
      "options"
    ]);
    return withPromise((resolve) => {
      const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;
      const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;
      const mirrorOffset = {
        top,
        left
      };
      resolve(__spreadValues({
        sensorEvent,
        sourceRect,
        mirrorOffset,
        options
      }, args));
    });
  }
  function resetMirror(_a) {
    var _b = _a, {
      mirror,
      source,
      options
    } = _b, args = __objRest(_b, [
      "mirror",
      "source",
      "options"
    ]);
    return withPromise((resolve) => {
      let offsetHeight;
      let offsetWidth;
      if (options.constrainDimensions) {
        const computedSourceStyles = getComputedStyle(source);
        offsetHeight = computedSourceStyles.getPropertyValue("height");
        offsetWidth = computedSourceStyles.getPropertyValue("width");
      }
      mirror.style.display = null;
      mirror.style.position = "fixed";
      mirror.style.pointerEvents = "none";
      mirror.style.top = 0;
      mirror.style.left = 0;
      mirror.style.margin = 0;
      if (options.constrainDimensions) {
        mirror.style.height = offsetHeight;
        mirror.style.width = offsetWidth;
      }
      resolve(__spreadValues({
        mirror,
        source,
        options
      }, args));
    });
  }
  function addMirrorClasses(_a) {
    var _b = _a, {
      mirror,
      mirrorClasses
    } = _b, args = __objRest(_b, [
      "mirror",
      "mirrorClasses"
    ]);
    return withPromise((resolve) => {
      mirror.classList.add(...mirrorClasses);
      resolve(__spreadValues({
        mirror,
        mirrorClasses
      }, args));
    });
  }
  function removeMirrorID(_a) {
    var _b = _a, {
      mirror
    } = _b, args = __objRest(_b, [
      "mirror"
    ]);
    return withPromise((resolve) => {
      mirror.removeAttribute("id");
      delete mirror.id;
      resolve(__spreadValues({
        mirror
      }, args));
    });
  }
  function positionMirror({
    withFrame = false,
    initial = false
  } = {}) {
    return (_a) => {
      var _b = _a, {
        mirror,
        sensorEvent,
        mirrorOffset,
        initialY,
        initialX,
        scrollOffset,
        options,
        passedThreshX,
        passedThreshY,
        lastMovedX,
        lastMovedY
      } = _b, args = __objRest(_b, [
        "mirror",
        "sensorEvent",
        "mirrorOffset",
        "initialY",
        "initialX",
        "scrollOffset",
        "options",
        "passedThreshX",
        "passedThreshY",
        "lastMovedX",
        "lastMovedY"
      ]);
      return withPromise((resolve) => {
        const result = __spreadValues({
          mirror,
          sensorEvent,
          mirrorOffset,
          options
        }, args);
        if (mirrorOffset) {
          const x = passedThreshX ? Math.round((sensorEvent.clientX - mirrorOffset.left - scrollOffset.x) / (options.thresholdX || 1)) * (options.thresholdX || 1) : Math.round(lastMovedX);
          const y = passedThreshY ? Math.round((sensorEvent.clientY - mirrorOffset.top - scrollOffset.y) / (options.thresholdY || 1)) * (options.thresholdY || 1) : Math.round(lastMovedY);
          if (options.xAxis && options.yAxis || initial) {
            mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;
          } else if (options.xAxis && !options.yAxis) {
            mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;
          } else if (options.yAxis && !options.xAxis) {
            mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;
          }
          if (initial) {
            result.initialX = x;
            result.initialY = y;
          }
          result.lastMovedX = x;
          result.lastMovedY = y;
        }
        resolve(result);
      }, {
        frame: withFrame
      });
    };
  }
  function withPromise(callback, {
    raf = false
  } = {}) {
    return new Promise((resolve, reject) => {
      if (raf) {
        requestAnimationFrame(() => {
          callback(resolve, reject);
        });
      } else {
        callback(resolve, reject);
      }
    });
  }
  function isNativeDragEvent(sensorEvent) {
    return /^drag/.test(sensorEvent.originalEvent.type);
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Plugins/Scrollable/Scrollable.mjs
  var onDragStart4 = Symbol("onDragStart");
  var onDragMove3 = Symbol("onDragMove");
  var onDragStop4 = Symbol("onDragStop");
  var scroll = Symbol("scroll");
  var defaultOptions7 = {
    speed: 6,
    sensitivity: 50,
    scrollableElements: []
  };
  var Scrollable = class extends AbstractPlugin {
    constructor(draggable) {
      super(draggable);
      this.options = __spreadValues(__spreadValues({}, defaultOptions7), this.getOptions());
      this.currentMousePosition = null;
      this.scrollAnimationFrame = null;
      this.scrollableElement = null;
      this.findScrollableElementFrame = null;
      this[onDragStart4] = this[onDragStart4].bind(this);
      this[onDragMove3] = this[onDragMove3].bind(this);
      this[onDragStop4] = this[onDragStop4].bind(this);
      this[scroll] = this[scroll].bind(this);
    }
    attach() {
      this.draggable.on("drag:start", this[onDragStart4]).on("drag:move", this[onDragMove3]).on("drag:stop", this[onDragStop4]);
    }
    detach() {
      this.draggable.off("drag:start", this[onDragStart4]).off("drag:move", this[onDragMove3]).off("drag:stop", this[onDragStop4]);
    }
    getOptions() {
      return this.draggable.options.scrollable || {};
    }
    getScrollableElement(target) {
      if (this.hasDefinedScrollableElements()) {
        return closest(target, this.options.scrollableElements) || document.documentElement;
      } else {
        return closestScrollableElement(target);
      }
    }
    hasDefinedScrollableElements() {
      return Boolean(this.options.scrollableElements.length !== 0);
    }
    [onDragStart4](dragEvent) {
      this.findScrollableElementFrame = requestAnimationFrame(() => {
        this.scrollableElement = this.getScrollableElement(dragEvent.source);
      });
    }
    [onDragMove3](dragEvent) {
      this.findScrollableElementFrame = requestAnimationFrame(() => {
        this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);
      });
      if (!this.scrollableElement) {
        return;
      }
      const sensorEvent = dragEvent.sensorEvent;
      const scrollOffset = {
        x: 0,
        y: 0
      };
      if ("ontouchstart" in window) {
        scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
      }
      this.currentMousePosition = {
        clientX: sensorEvent.clientX - scrollOffset.x,
        clientY: sensorEvent.clientY - scrollOffset.y
      };
      this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
    }
    [onDragStop4]() {
      cancelAnimationFrame(this.scrollAnimationFrame);
      cancelAnimationFrame(this.findScrollableElementFrame);
      this.scrollableElement = null;
      this.scrollAnimationFrame = null;
      this.findScrollableElementFrame = null;
      this.currentMousePosition = null;
    }
    [scroll]() {
      if (!this.scrollableElement || !this.currentMousePosition) {
        return;
      }
      cancelAnimationFrame(this.scrollAnimationFrame);
      const {
        speed,
        sensitivity
      } = this.options;
      const rect = this.scrollableElement.getBoundingClientRect();
      const bottomCutOff = rect.bottom > window.innerHeight;
      const topCutOff = rect.top < 0;
      const cutOff = topCutOff || bottomCutOff;
      const documentScrollingElement = getDocumentScrollingElement();
      const scrollableElement = this.scrollableElement;
      const clientX = this.currentMousePosition.clientX;
      const clientY = this.currentMousePosition.clientY;
      if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {
        const {
          offsetHeight,
          offsetWidth
        } = scrollableElement;
        if (rect.top + offsetHeight - clientY < sensitivity) {
          scrollableElement.scrollTop += speed;
        } else if (clientY - rect.top < sensitivity) {
          scrollableElement.scrollTop -= speed;
        }
        if (rect.left + offsetWidth - clientX < sensitivity) {
          scrollableElement.scrollLeft += speed;
        } else if (clientX - rect.left < sensitivity) {
          scrollableElement.scrollLeft -= speed;
        }
      } else {
        const {
          innerHeight,
          innerWidth
        } = window;
        if (clientY < sensitivity) {
          documentScrollingElement.scrollTop -= speed;
        } else if (innerHeight - clientY < sensitivity) {
          documentScrollingElement.scrollTop += speed;
        }
        if (clientX < sensitivity) {
          documentScrollingElement.scrollLeft -= speed;
        } else if (innerWidth - clientX < sensitivity) {
          documentScrollingElement.scrollLeft += speed;
        }
      }
      this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
    }
  };
  function hasOverflow(element) {
    const overflowRegex = /(auto|scroll)/;
    const computedStyles = getComputedStyle(element, null);
    const overflow = computedStyles.getPropertyValue("overflow") + computedStyles.getPropertyValue("overflow-y") + computedStyles.getPropertyValue("overflow-x");
    return overflowRegex.test(overflow);
  }
  function isStaticallyPositioned(element) {
    const position = getComputedStyle(element).getPropertyValue("position");
    return position === "static";
  }
  function closestScrollableElement(element) {
    if (!element) {
      return getDocumentScrollingElement();
    }
    const position = getComputedStyle(element).getPropertyValue("position");
    const excludeStaticParents = position === "absolute";
    const scrollableElement = closest(element, (parent) => {
      if (excludeStaticParents && isStaticallyPositioned(parent)) {
        return false;
      }
      return hasOverflow(parent);
    });
    if (position === "fixed" || !scrollableElement) {
      return getDocumentScrollingElement();
    } else {
      return scrollableElement;
    }
  }
  function getDocumentScrollingElement() {
    return document.scrollingElement || document.documentElement;
  }

  // node_modules/@shopify/draggable/build/esm/Draggable/Emitter/Emitter.mjs
  var Emitter = class {
    constructor() {
      this.callbacks = {};
    }
    on(type, ...callbacks) {
      if (!this.callbacks[type]) {
        this.callbacks[type] = [];
      }
      this.callbacks[type].push(...callbacks);
      return this;
    }
    off(type, callback) {
      if (!this.callbacks[type]) {
        return null;
      }
      const copy = this.callbacks[type].slice(0);
      for (let i = 0; i < copy.length; i++) {
        if (callback === copy[i]) {
          this.callbacks[type].splice(i, 1);
        }
      }
      return this;
    }
    trigger(event) {
      if (!this.callbacks[event.type]) {
        return null;
      }
      const callbacks = [...this.callbacks[event.type]];
      const caughtErrors = [];
      for (let i = callbacks.length - 1; i >= 0; i--) {
        const callback = callbacks[i];
        try {
          callback(event);
        } catch (error) {
          caughtErrors.push(error);
        }
      }
      if (caughtErrors.length) {
        console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);
      }
      return this;
    }
  };

  // node_modules/@shopify/draggable/build/esm/Draggable/DraggableEvent/DraggableEvent.mjs
  var DraggableEvent = class extends AbstractEvent {
    get draggable() {
      return this.data.draggable;
    }
  };
  DraggableEvent.type = "draggable";
  var DraggableInitializedEvent = class extends DraggableEvent {
  };
  DraggableInitializedEvent.type = "draggable:initialize";
  var DraggableDestroyEvent = class extends DraggableEvent {
  };
  DraggableDestroyEvent.type = "draggable:destroy";

  // node_modules/@shopify/draggable/build/esm/Draggable/Draggable.mjs
  var onDragStart5 = Symbol("onDragStart");
  var onDragMove4 = Symbol("onDragMove");
  var onDragStop5 = Symbol("onDragStop");
  var onDragPressure = Symbol("onDragPressure");
  var dragStop = Symbol("dragStop");
  var defaultAnnouncements = {
    "drag:start": (event) => `Picked up ${event.source.textContent.trim() || event.source.id || "draggable element"}`,
    "drag:stop": (event) => `Released ${event.source.textContent.trim() || event.source.id || "draggable element"}`
  };
  var defaultClasses = {
    "container:dragging": "draggable-container--is-dragging",
    "source:dragging": "draggable-source--is-dragging",
    "source:placed": "draggable-source--placed",
    "container:placed": "draggable-container--placed",
    "body:dragging": "draggable--is-dragging",
    "draggable:over": "draggable--over",
    "container:over": "draggable-container--over",
    "source:original": "draggable--original",
    mirror: "draggable-mirror"
  };
  var defaultOptions8 = {
    draggable: ".draggable-source",
    handle: null,
    delay: {},
    distance: 0,
    placedTimeout: 800,
    plugins: [],
    sensors: [],
    exclude: {
      plugins: [],
      sensors: []
    }
  };
  var Draggable = class {
    constructor(containers = [document.body], options = {}) {
      if (containers instanceof NodeList || containers instanceof Array) {
        this.containers = [...containers];
      } else if (containers instanceof HTMLElement) {
        this.containers = [containers];
      } else {
        throw new Error("Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`");
      }
      this.options = __spreadProps(__spreadValues(__spreadValues({}, defaultOptions8), options), {
        classes: __spreadValues(__spreadValues({}, defaultClasses), options.classes || {}),
        announcements: __spreadValues(__spreadValues({}, defaultAnnouncements), options.announcements || {}),
        exclude: {
          plugins: options.exclude && options.exclude.plugins || [],
          sensors: options.exclude && options.exclude.sensors || []
        }
      });
      this.emitter = new Emitter();
      this.dragging = false;
      this.plugins = [];
      this.sensors = [];
      this[onDragStart5] = this[onDragStart5].bind(this);
      this[onDragMove4] = this[onDragMove4].bind(this);
      this[onDragStop5] = this[onDragStop5].bind(this);
      this[onDragPressure] = this[onDragPressure].bind(this);
      this[dragStop] = this[dragStop].bind(this);
      document.addEventListener("drag:start", this[onDragStart5], true);
      document.addEventListener("drag:move", this[onDragMove4], true);
      document.addEventListener("drag:stop", this[onDragStop5], true);
      document.addEventListener("drag:pressure", this[onDragPressure], true);
      const defaultPlugins = Object.values(Draggable.Plugins).filter((Plugin) => !this.options.exclude.plugins.includes(Plugin));
      const defaultSensors = Object.values(Draggable.Sensors).filter((sensor) => !this.options.exclude.sensors.includes(sensor));
      this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);
      this.addSensor(...[...defaultSensors, ...this.options.sensors]);
      const draggableInitializedEvent = new DraggableInitializedEvent({
        draggable: this
      });
      this.on("mirror:created", ({
        mirror
      }) => this.mirror = mirror);
      this.on("mirror:destroy", () => this.mirror = null);
      this.trigger(draggableInitializedEvent);
    }
    destroy() {
      document.removeEventListener("drag:start", this[onDragStart5], true);
      document.removeEventListener("drag:move", this[onDragMove4], true);
      document.removeEventListener("drag:stop", this[onDragStop5], true);
      document.removeEventListener("drag:pressure", this[onDragPressure], true);
      const draggableDestroyEvent = new DraggableDestroyEvent({
        draggable: this
      });
      this.trigger(draggableDestroyEvent);
      this.removePlugin(...this.plugins.map((plugin) => plugin.constructor));
      this.removeSensor(...this.sensors.map((sensor) => sensor.constructor));
    }
    addPlugin(...plugins) {
      const activePlugins = plugins.map((Plugin) => new Plugin(this));
      activePlugins.forEach((plugin) => plugin.attach());
      this.plugins = [...this.plugins, ...activePlugins];
      return this;
    }
    removePlugin(...plugins) {
      const removedPlugins = this.plugins.filter((plugin) => plugins.includes(plugin.constructor));
      removedPlugins.forEach((plugin) => plugin.detach());
      this.plugins = this.plugins.filter((plugin) => !plugins.includes(plugin.constructor));
      return this;
    }
    addSensor(...sensors) {
      const activeSensors = sensors.map((Sensor2) => new Sensor2(this.containers, this.options));
      activeSensors.forEach((sensor) => sensor.attach());
      this.sensors = [...this.sensors, ...activeSensors];
      return this;
    }
    removeSensor(...sensors) {
      const removedSensors = this.sensors.filter((sensor) => sensors.includes(sensor.constructor));
      removedSensors.forEach((sensor) => sensor.detach());
      this.sensors = this.sensors.filter((sensor) => !sensors.includes(sensor.constructor));
      return this;
    }
    addContainer(...containers) {
      this.containers = [...this.containers, ...containers];
      this.sensors.forEach((sensor) => sensor.addContainer(...containers));
      return this;
    }
    removeContainer(...containers) {
      this.containers = this.containers.filter((container) => !containers.includes(container));
      this.sensors.forEach((sensor) => sensor.removeContainer(...containers));
      return this;
    }
    on(type, ...callbacks) {
      this.emitter.on(type, ...callbacks);
      return this;
    }
    off(type, callback) {
      this.emitter.off(type, callback);
      return this;
    }
    trigger(event) {
      this.emitter.trigger(event);
      return this;
    }
    getClassNameFor(name) {
      return this.getClassNamesFor(name)[0];
    }
    getClassNamesFor(name) {
      const classNames = this.options.classes[name];
      if (classNames instanceof Array) {
        return classNames;
      } else if (typeof classNames === "string" || classNames instanceof String) {
        return [classNames];
      } else {
        return [];
      }
    }
    isDragging() {
      return Boolean(this.dragging);
    }
    getDraggableElements() {
      return this.containers.reduce((current, container) => {
        return [...current, ...this.getDraggableElementsForContainer(container)];
      }, []);
    }
    getDraggableElementsForContainer(container) {
      const allDraggableElements = container.querySelectorAll(this.options.draggable);
      return [...allDraggableElements].filter((childElement) => {
        return childElement !== this.originalSource && childElement !== this.mirror;
      });
    }
    cancel() {
      this[dragStop]();
    }
    [onDragStart5](event) {
      const sensorEvent = getSensorEvent(event);
      const {
        target,
        container,
        originalSource
      } = sensorEvent;
      if (!this.containers.includes(container)) {
        return;
      }
      if (this.options.handle && target && !closest(target, this.options.handle)) {
        sensorEvent.cancel();
        return;
      }
      this.originalSource = originalSource;
      this.sourceContainer = container;
      if (this.lastPlacedSource && this.lastPlacedContainer) {
        clearTimeout(this.placedTimeoutID);
        this.lastPlacedSource.classList.remove(...this.getClassNamesFor("source:placed"));
        this.lastPlacedContainer.classList.remove(...this.getClassNamesFor("container:placed"));
      }
      this.source = this.originalSource.cloneNode(true);
      this.originalSource.parentNode.insertBefore(this.source, this.originalSource);
      this.originalSource.style.display = "none";
      const dragStartEvent = new DragStartEvent({
        source: this.source,
        originalSource: this.originalSource,
        sourceContainer: container,
        sensorEvent
      });
      this.trigger(dragStartEvent);
      this.dragging = !dragStartEvent.canceled();
      if (dragStartEvent.canceled()) {
        this.source.remove();
        this.originalSource.style.display = null;
        return;
      }
      this.originalSource.classList.add(...this.getClassNamesFor("source:original"));
      this.source.classList.add(...this.getClassNamesFor("source:dragging"));
      this.sourceContainer.classList.add(...this.getClassNamesFor("container:dragging"));
      document.body.classList.add(...this.getClassNamesFor("body:dragging"));
      applyUserSelect(document.body, "none");
      requestAnimationFrame(() => {
        const oldSensorEvent = getSensorEvent(event);
        const newSensorEvent = oldSensorEvent.clone({
          target: this.source
        });
        this[onDragMove4](__spreadProps(__spreadValues({}, event), {
          detail: newSensorEvent
        }));
      });
    }
    [onDragMove4](event) {
      if (!this.dragging) {
        return;
      }
      const sensorEvent = getSensorEvent(event);
      const {
        container
      } = sensorEvent;
      let target = sensorEvent.target;
      const dragMoveEvent = new DragMoveEvent({
        source: this.source,
        originalSource: this.originalSource,
        sourceContainer: container,
        sensorEvent
      });
      this.trigger(dragMoveEvent);
      if (dragMoveEvent.canceled()) {
        sensorEvent.cancel();
      }
      target = closest(target, this.options.draggable);
      const withinCorrectContainer = closest(sensorEvent.target, this.containers);
      const overContainer = sensorEvent.overContainer || withinCorrectContainer;
      const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;
      const isLeavingDraggable = this.currentOver && target !== this.currentOver;
      const isOverContainer = overContainer && this.currentOverContainer !== overContainer;
      const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;
      if (isLeavingDraggable) {
        const dragOutEvent = new DragOutEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          over: this.currentOver,
          overContainer: this.currentOverContainer
        });
        this.currentOver.classList.remove(...this.getClassNamesFor("draggable:over"));
        this.currentOver = null;
        this.trigger(dragOutEvent);
      }
      if (isLeavingContainer) {
        const dragOutContainerEvent = new DragOutContainerEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          overContainer: this.currentOverContainer
        });
        this.currentOverContainer.classList.remove(...this.getClassNamesFor("container:over"));
        this.currentOverContainer = null;
        this.trigger(dragOutContainerEvent);
      }
      if (isOverContainer) {
        overContainer.classList.add(...this.getClassNamesFor("container:over"));
        const dragOverContainerEvent = new DragOverContainerEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          overContainer
        });
        this.currentOverContainer = overContainer;
        this.trigger(dragOverContainerEvent);
      }
      if (isOverDraggable) {
        target.classList.add(...this.getClassNamesFor("draggable:over"));
        const dragOverEvent = new DragOverEvent({
          source: this.source,
          originalSource: this.originalSource,
          sourceContainer: container,
          sensorEvent,
          overContainer,
          over: target
        });
        this.currentOver = target;
        this.trigger(dragOverEvent);
      }
    }
    [dragStop](event) {
      if (!this.dragging) {
        return;
      }
      this.dragging = false;
      const dragStopEvent = new DragStopEvent({
        source: this.source,
        originalSource: this.originalSource,
        sensorEvent: event ? event.sensorEvent : null,
        sourceContainer: this.sourceContainer
      });
      this.trigger(dragStopEvent);
      if (!dragStopEvent.canceled())
        this.source.parentNode.insertBefore(this.originalSource, this.source);
      this.source.remove();
      this.originalSource.style.display = "";
      this.source.classList.remove(...this.getClassNamesFor("source:dragging"));
      this.originalSource.classList.remove(...this.getClassNamesFor("source:original"));
      this.originalSource.classList.add(...this.getClassNamesFor("source:placed"));
      this.sourceContainer.classList.add(...this.getClassNamesFor("container:placed"));
      this.sourceContainer.classList.remove(...this.getClassNamesFor("container:dragging"));
      document.body.classList.remove(...this.getClassNamesFor("body:dragging"));
      applyUserSelect(document.body, "");
      if (this.currentOver) {
        this.currentOver.classList.remove(...this.getClassNamesFor("draggable:over"));
      }
      if (this.currentOverContainer) {
        this.currentOverContainer.classList.remove(...this.getClassNamesFor("container:over"));
      }
      this.lastPlacedSource = this.originalSource;
      this.lastPlacedContainer = this.sourceContainer;
      this.placedTimeoutID = setTimeout(() => {
        if (this.lastPlacedSource) {
          this.lastPlacedSource.classList.remove(...this.getClassNamesFor("source:placed"));
        }
        if (this.lastPlacedContainer) {
          this.lastPlacedContainer.classList.remove(...this.getClassNamesFor("container:placed"));
        }
        this.lastPlacedSource = null;
        this.lastPlacedContainer = null;
      }, this.options.placedTimeout);
      const dragStoppedEvent = new DragStoppedEvent({
        source: this.source,
        originalSource: this.originalSource,
        sensorEvent: event ? event.sensorEvent : null,
        sourceContainer: this.sourceContainer
      });
      this.trigger(dragStoppedEvent);
      this.source = null;
      this.originalSource = null;
      this.currentOverContainer = null;
      this.currentOver = null;
      this.sourceContainer = null;
    }
    [onDragStop5](event) {
      this[dragStop](event);
    }
    [onDragPressure](event) {
      if (!this.dragging) {
        return;
      }
      const sensorEvent = getSensorEvent(event);
      const source = this.source || closest(sensorEvent.originalEvent.target, this.options.draggable);
      const dragPressureEvent = new DragPressureEvent({
        sensorEvent,
        source,
        pressure: sensorEvent.pressure
      });
      this.trigger(dragPressureEvent);
    }
  };
  Draggable.Plugins = {
    Announcement,
    Focusable,
    Mirror,
    Scrollable
  };
  Draggable.Sensors = {
    MouseSensor,
    TouchSensor
  };
  function getSensorEvent(event) {
    return event.detail;
  }
  function applyUserSelect(element, value) {
    element.style.webkitUserSelect = value;
    element.style.mozUserSelect = value;
    element.style.msUserSelect = value;
    element.style.oUserSelect = value;
    element.style.userSelect = value;
  }

  // node_modules/@shopify/draggable/build/esm/Droppable/DroppableEvent/DroppableEvent.mjs
  var DroppableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  DroppableEvent.type = "droppable";
  var DroppableStartEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableStartEvent.type = "droppable:start";
  DroppableStartEvent.cancelable = true;
  var DroppableDroppedEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableDroppedEvent.type = "droppable:dropped";
  DroppableDroppedEvent.cancelable = true;
  var DroppableReturnedEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableReturnedEvent.type = "droppable:returned";
  DroppableReturnedEvent.cancelable = true;
  var DroppableStopEvent = class extends DroppableEvent {
    get dropzone() {
      return this.data.dropzone;
    }
  };
  DroppableStopEvent.type = "droppable:stop";
  DroppableStopEvent.cancelable = true;

  // node_modules/@shopify/draggable/build/esm/Droppable/Droppable.mjs
  var onDragStart6 = Symbol("onDragStart");
  var onDragMove5 = Symbol("onDragMove");
  var onDragStop6 = Symbol("onDragStop");
  var dropInDropzone = Symbol("dropInDropZone");
  var returnToOriginalDropzone = Symbol("returnToOriginalDropzone");
  var closestDropzone = Symbol("closestDropzone");
  var getDropzones = Symbol("getDropzones");

  // node_modules/@shopify/draggable/build/esm/Swappable/SwappableEvent/SwappableEvent.mjs
  var SwappableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  SwappableEvent.type = "swappable";
  var SwappableStartEvent = class extends SwappableEvent {
  };
  SwappableStartEvent.type = "swappable:start";
  SwappableStartEvent.cancelable = true;
  var SwappableSwapEvent = class extends SwappableEvent {
    get over() {
      return this.data.over;
    }
    get overContainer() {
      return this.data.overContainer;
    }
  };
  SwappableSwapEvent.type = "swappable:swap";
  SwappableSwapEvent.cancelable = true;
  var SwappableSwappedEvent = class extends SwappableEvent {
    get swappedElement() {
      return this.data.swappedElement;
    }
  };
  SwappableSwappedEvent.type = "swappable:swapped";
  var SwappableStopEvent = class extends SwappableEvent {
  };
  SwappableStopEvent.type = "swappable:stop";

  // node_modules/@shopify/draggable/build/esm/Swappable/Swappable.mjs
  var onDragStart7 = Symbol("onDragStart");
  var onDragOver3 = Symbol("onDragOver");
  var onDragStop7 = Symbol("onDragStop");

  // node_modules/@shopify/draggable/build/esm/Sortable/SortableEvent/SortableEvent.mjs
  var SortableEvent = class extends AbstractEvent {
    constructor(data) {
      super(data);
      this.data = data;
    }
    get dragEvent() {
      return this.data.dragEvent;
    }
  };
  SortableEvent.type = "sortable";
  var SortableStartEvent = class extends SortableEvent {
    get startIndex() {
      return this.data.startIndex;
    }
    get startContainer() {
      return this.data.startContainer;
    }
  };
  SortableStartEvent.type = "sortable:start";
  SortableStartEvent.cancelable = true;
  var SortableSortEvent = class extends SortableEvent {
    get currentIndex() {
      return this.data.currentIndex;
    }
    get over() {
      return this.data.over;
    }
    get overContainer() {
      return this.data.dragEvent.overContainer;
    }
  };
  SortableSortEvent.type = "sortable:sort";
  SortableSortEvent.cancelable = true;
  var SortableSortedEvent = class extends SortableEvent {
    get oldIndex() {
      return this.data.oldIndex;
    }
    get newIndex() {
      return this.data.newIndex;
    }
    get oldContainer() {
      return this.data.oldContainer;
    }
    get newContainer() {
      return this.data.newContainer;
    }
  };
  SortableSortedEvent.type = "sortable:sorted";
  var SortableStopEvent = class extends SortableEvent {
    get oldIndex() {
      return this.data.oldIndex;
    }
    get newIndex() {
      return this.data.newIndex;
    }
    get oldContainer() {
      return this.data.oldContainer;
    }
    get newContainer() {
      return this.data.newContainer;
    }
  };
  SortableStopEvent.type = "sortable:stop";

  // node_modules/@shopify/draggable/build/esm/Sortable/Sortable.mjs
  var onDragStart8 = Symbol("onDragStart");
  var onDragOverContainer = Symbol("onDragOverContainer");
  var onDragOver4 = Symbol("onDragOver");
  var onDragStop8 = Symbol("onDragStop");
  function onSortableSortedDefaultAnnouncement({
    dragEvent
  }) {
    const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || "sortable element";
    if (dragEvent.over) {
      const overText = dragEvent.over.textContent.trim() || dragEvent.over.id || "sortable element";
      const isFollowing = dragEvent.source.compareDocumentPosition(dragEvent.over) & Node.DOCUMENT_POSITION_FOLLOWING;
      if (isFollowing) {
        return `Placed ${sourceText} after ${overText}`;
      } else {
        return `Placed ${sourceText} before ${overText}`;
      }
    } else {
      return `Placed ${sourceText} into a different container`;
    }
  }
  var defaultAnnouncements2 = {
    "sortable:sorted": onSortableSortedDefaultAnnouncement
  };
  var Sortable = class extends Draggable {
    constructor(containers = [], options = {}) {
      super(containers, __spreadProps(__spreadValues({}, options), {
        announcements: __spreadValues(__spreadValues({}, defaultAnnouncements2), options.announcements || {})
      }));
      this.startIndex = null;
      this.startContainer = null;
      this[onDragStart8] = this[onDragStart8].bind(this);
      this[onDragOverContainer] = this[onDragOverContainer].bind(this);
      this[onDragOver4] = this[onDragOver4].bind(this);
      this[onDragStop8] = this[onDragStop8].bind(this);
      this.on("drag:start", this[onDragStart8]).on("drag:over:container", this[onDragOverContainer]).on("drag:over", this[onDragOver4]).on("drag:stop", this[onDragStop8]);
    }
    destroy() {
      super.destroy();
      this.off("drag:start", this[onDragStart8]).off("drag:over:container", this[onDragOverContainer]).off("drag:over", this[onDragOver4]).off("drag:stop", this[onDragStop8]);
    }
    index(element) {
      return this.getSortableElementsForContainer(element.parentNode).indexOf(element);
    }
    getSortableElementsForContainer(container) {
      const allSortableElements = container.querySelectorAll(this.options.draggable);
      return [...allSortableElements].filter((childElement) => {
        return childElement !== this.originalSource && childElement !== this.mirror && childElement.parentNode === container;
      });
    }
    [onDragStart8](event) {
      this.startContainer = event.source.parentNode;
      this.startIndex = this.index(event.source);
      const sortableStartEvent = new SortableStartEvent({
        dragEvent: event,
        startIndex: this.startIndex,
        startContainer: this.startContainer
      });
      this.trigger(sortableStartEvent);
      if (sortableStartEvent.canceled()) {
        event.cancel();
      }
    }
    [onDragOverContainer](event) {
      if (event.canceled()) {
        return;
      }
      const {
        source,
        over,
        overContainer
      } = event;
      const oldIndex = this.index(source);
      const sortableSortEvent = new SortableSortEvent({
        dragEvent: event,
        currentIndex: oldIndex,
        source,
        over
      });
      this.trigger(sortableSortEvent);
      if (sortableSortEvent.canceled()) {
        return;
      }
      const children = this.getSortableElementsForContainer(overContainer);
      const moves = move({
        source,
        over,
        overContainer,
        children
      });
      if (!moves) {
        return;
      }
      const {
        oldContainer,
        newContainer
      } = moves;
      const newIndex = this.index(event.source);
      const sortableSortedEvent = new SortableSortedEvent({
        dragEvent: event,
        oldIndex,
        newIndex,
        oldContainer,
        newContainer
      });
      this.trigger(sortableSortedEvent);
    }
    [onDragOver4](event) {
      if (event.over === event.originalSource || event.over === event.source) {
        return;
      }
      const {
        source,
        over,
        overContainer
      } = event;
      const oldIndex = this.index(source);
      const sortableSortEvent = new SortableSortEvent({
        dragEvent: event,
        currentIndex: oldIndex,
        source,
        over
      });
      this.trigger(sortableSortEvent);
      if (sortableSortEvent.canceled()) {
        return;
      }
      const children = this.getDraggableElementsForContainer(overContainer);
      const moves = move({
        source,
        over,
        overContainer,
        children
      });
      if (!moves) {
        return;
      }
      const {
        oldContainer,
        newContainer
      } = moves;
      const newIndex = this.index(source);
      const sortableSortedEvent = new SortableSortedEvent({
        dragEvent: event,
        oldIndex,
        newIndex,
        oldContainer,
        newContainer
      });
      this.trigger(sortableSortedEvent);
    }
    [onDragStop8](event) {
      const sortableStopEvent = new SortableStopEvent({
        dragEvent: event,
        oldIndex: this.startIndex,
        newIndex: this.index(event.source),
        oldContainer: this.startContainer,
        newContainer: event.source.parentNode
      });
      this.trigger(sortableStopEvent);
      this.startIndex = null;
      this.startContainer = null;
    }
  };
  function index(element) {
    return Array.prototype.indexOf.call(element.parentNode.children, element);
  }
  function move({
    source,
    over,
    overContainer,
    children
  }) {
    const emptyOverContainer = !children.length;
    const differentContainer = source.parentNode !== overContainer;
    const sameContainer = over && source.parentNode === over.parentNode;
    if (emptyOverContainer) {
      return moveInsideEmptyContainer(source, overContainer);
    } else if (sameContainer) {
      return moveWithinContainer(source, over);
    } else if (differentContainer) {
      return moveOutsideContainer(source, over, overContainer);
    } else {
      return null;
    }
  }
  function moveInsideEmptyContainer(source, overContainer) {
    const oldContainer = source.parentNode;
    overContainer.appendChild(source);
    return {
      oldContainer,
      newContainer: overContainer
    };
  }
  function moveWithinContainer(source, over) {
    const oldIndex = index(source);
    const newIndex = index(over);
    if (oldIndex < newIndex) {
      source.parentNode.insertBefore(source, over.nextElementSibling);
    } else {
      source.parentNode.insertBefore(source, over);
    }
    return {
      oldContainer: source.parentNode,
      newContainer: source.parentNode
    };
  }
  function moveOutsideContainer(source, over, overContainer) {
    const oldContainer = source.parentNode;
    if (over) {
      over.parentNode.insertBefore(source, over);
    } else {
      overContainer.appendChild(source);
    }
    return {
      oldContainer,
      newContainer: source.parentNode
    };
  }

  // js/app.js
  var import_topbar = __toModule(require_topbar());

  // js/chart.js
  var import_chart = __toModule(require_chart());
  var import_chartjs_plugin_datalabels = __toModule(require_chartjs_plugin_datalabels());

  // node_modules/chart.js-plugin-labels-dv/dist/chartjs-plugin-labels.min.js
  !function(t) {
    typeof define == "function" && define.amd ? define(t) : t();
  }(function() {
    "use strict";
    !function() {
      if (typeof Chart == "undefined")
        return void console.error("Cannot find Chart object.");
      const t = Chart.helpers;
      typeof Object.assign != "function" && (Object.assign = function(t2) {
        if (!t2)
          throw new TypeError("Cannot convert undefined or null to object");
        const e2 = Object(t2);
        for (let t3 = 1; t3 < arguments.length; t3++) {
          const o2 = arguments[t3];
          if (o2)
            for (const t4 in o2)
              Object.prototype.hasOwnProperty.call(o2, t4) && (e2[t4] = o2[t4]);
        }
        return e2;
      });
      const e = {};
      function o() {
        this.renderToDataset = this.renderToDataset.bind(this);
      }
      function n(t2) {
        const e2 = t2._context.chart.config._config;
        return !(!e2.options || !e2.options.plugins) && !!e2.options.plugins.labels;
      }
      ["pie", "doughnut", "polarArea", "bar"].forEach(function(t2) {
        e[t2] = true;
      }), o.prototype.setup = function(t2, e2) {
        this.chart = t2, this.ctx = t2.ctx, this.args = {}, this.barTotal = {};
        const o2 = t2.config.options;
        this.options = Object.assign({ position: "default", precision: 0, fontSize: o2.font ? o2.font.size : 12, fontColor: o2.color || "#333333", fontStyle: o2.font ? o2.font.style : "normal", fontFamily: o2.font ? o2.font.family : "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", shadowOffsetX: 3, shadowOffsetY: 3, shadowColor: "rgba(0,0,0,0.3)", shadowBlur: 6, images: [], outsidePadding: 2, textMargin: 2, overlap: true }, e2), t2.config.type === "bar" && (this.options.position = "default", this.options.arc = false, this.options.overlap = true);
      }, o.prototype.render = function() {
        this.labelBounds = [], this.chart.data.datasets.forEach(this.renderToDataset);
      }, o.prototype.renderToDataset = function(t2, e2) {
        this.totalPercentage = 0, this.total = null;
        const o2 = this.args[e2];
        o2.meta.data.forEach(function(e3, n2) {
          this.renderToElement(t2, o2, e3, n2);
        }.bind(this));
      }, o.prototype.renderToElement = function(e2, o2, n2, i) {
        if (!this.shouldRenderToElement(o2.meta, n2))
          return;
        this.percentage = null;
        const s = this.getLabel(e2, n2, i);
        if (!s)
          return;
        const r = this.ctx;
        r.save(), r.font = t.fontString(this.options.fontSize, this.options.fontStyle, this.options.fontFamily);
        const a = this.getRenderInfo(n2, s);
        this.drawable(n2, s, a) ? (r.beginPath(), r.fillStyle = this.getFontColor(e2, n2, i), this.renderLabel(s, a), r.restore()) : r.restore();
      }, o.prototype.renderLabel = function(t2, e2) {
        return this.options.arc ? this.renderArcLabel(t2, e2) : this.renderBaseLabel(t2, e2);
      }, o.prototype.renderBaseLabel = function(t2, e2) {
        const o2 = this.ctx;
        if (typeof t2 == "object")
          o2.drawImage(t2, e2.x - t2.width / 2, e2.y - t2.height / 2, t2.width, t2.height);
        else {
          o2.save(), o2.textBaseline = "top", o2.textAlign = "center", this.options.textShadow && (o2.shadowOffsetX = this.options.shadowOffsetX, o2.shadowOffsetY = this.options.shadowOffsetY, o2.shadowColor = this.options.shadowColor, o2.shadowBlur = this.options.shadowBlur);
          const n2 = t2.split("\n");
          for (let t3 = 0; t3 < n2.length; t3++) {
            const i = e2.y - this.options.fontSize / 2 * n2.length + this.options.fontSize * t3;
            o2.fillText(n2[t3], e2.x, i);
          }
          o2.restore();
        }
      }, o.prototype.renderArcLabel = function(t2, e2) {
        const o2 = this.ctx, n2 = e2.radius, i = e2.view;
        if (o2.save(), o2.translate(i.x, i.y), typeof t2 == "string") {
          o2.rotate(e2.startAngle), o2.textBaseline = "middle", o2.textAlign = "left";
          const i2 = t2.split("\n");
          let s = 0;
          const r = [];
          let a, h = 0;
          this.options.position === "border" && (h = (i2.length - 1) * this.options.fontSize / 2);
          for (let t3 = 0; t3 < i2.length; ++t3)
            a = o2.measureText(i2[t3]), a.width > s && (s = a.width), r.push(a.width);
          for (let t3 = 0; t3 < i2.length; ++t3) {
            const e3 = i2[t3], l = (i2.length - 1 - t3) * -this.options.fontSize + h;
            o2.save();
            const c = (s - r[t3]) / 2;
            o2.rotate(c / n2);
            for (let t4 = 0; t4 < e3.length; t4++) {
              const i3 = e3.charAt(t4);
              a = o2.measureText(i3), o2.save(), o2.translate(0, -1 * n2), o2.fillText(i3, 0, l), o2.restore(), o2.rotate(a.width / n2);
            }
            o2.restore();
          }
        } else
          o2.rotate((i.startAngle + Math.PI / 2 + e2.endAngle) / 2), o2.translate(0, -1 * n2), this.renderLabel(t2, { x: 0, y: 0 });
        o2.restore();
      }, o.prototype.shouldRenderToElement = function(t2, e2) {
        return !t2.hidden && (this.options.showZero || this.chart.config.type === "polarArea" ? e2.outerRadius !== 0 : e2.circumference !== 0);
      }, o.prototype.getLabel = function(t2, e2, o2) {
        let n2;
        if (typeof this.options.render == "function")
          n2 = this.options.render({ label: this.chart.config.data.labels[o2], value: t2.data[o2], percentage: this.getPercentage(t2, e2, o2), dataset: t2, index: o2 });
        else
          switch (this.options.render) {
            case "value":
              n2 = t2.data[o2];
              break;
            case "label":
              n2 = this.chart.config.data.labels[o2];
              break;
            case "image":
              n2 = this.options.images[o2] ? this.loadImage(this.options.images[o2]) : "";
              break;
            default:
              n2 = this.getPercentage(t2, e2, o2) + "%";
          }
        return typeof n2 == "object" ? n2 = this.loadImage(n2) : n2 && (n2 = n2.toString()), n2;
      }, o.prototype.getFontColor = function(t2, e2, o2) {
        let n2 = this.options.fontColor;
        return typeof n2 == "function" ? n2 = n2({ label: this.chart.config.data.labels[o2], value: t2.data[o2], percentage: this.getPercentage(t2, e2, o2), backgroundColor: t2.backgroundColor[o2], dataset: t2, index: o2 }) : typeof n2 != "string" && (n2 = n2[o2] || this.chart.config.options.color), n2;
      }, o.prototype.getPercentage = function(t2, e2, o2) {
        if (this.percentage)
          return this.percentage;
        let n2;
        if (this.chart.config.type === "polarArea" || this.chart.config.type === "doughnut" || this.chart.config.type === "pie") {
          if (!this.total) {
            this.total = 0;
            for (let e3 = 0; e3 < t2.data.length; ++e3)
              this.total += t2.data[e3];
          }
          n2 = t2.data[o2] / this.total * 100;
        } else if (this.chart.config.type === "bar") {
          if (!this.barTotal[o2]) {
            this.barTotal[o2] = 0;
            for (let t3 = 0; t3 < this.chart.data.datasets.length; ++t3)
              this.barTotal[o2] += this.chart.data.datasets[t3].data[o2];
          }
          n2 = t2.data[o2] / this.barTotal[o2] * 100;
        } else
          n2 = e2.circumference / this.chart.config.options.circumference * 100;
        return n2 = parseFloat(n2.toFixed(this.options.precision)), this.options.showActualPercentages || (this.chart.config.type === "bar" && (this.totalPercentage = this.barTotalPercentage[o2] || 0), this.totalPercentage += n2, this.totalPercentage > 100 && (n2 -= this.totalPercentage - 100, n2 = parseFloat(n2.toFixed(this.options.precision))), this.chart.config.type === "bar" && (this.barTotalPercentage[o2] = this.totalPercentage)), this.percentage = n2, n2;
      }, o.prototype.getRenderInfo = function(t2, e2) {
        return this.chart.config.type === "bar" ? this.getBarRenderInfo(t2, e2) : this.options.arc ? this.getArcRenderInfo(t2, e2) : this.getBaseRenderInfo(t2, e2);
      }, o.prototype.getBaseRenderInfo = function(t2, e2) {
        if (this.options.position === "outside" || this.options.position === "border") {
          let o2, n2 = {};
          const i = t2, s = i.startAngle + (i.endAngle - i.startAngle) / 2, r = i.outerRadius / 2;
          if (this.options.position === "border" ? o2 = (i.outerRadius - r) / 2 + r : this.options.position === "outside" && (o2 = i.outerRadius - r + r + this.options.textMargin), n2 = { x: i.x + Math.cos(s) * o2, y: i.y + Math.sin(s) * o2 }, this.options.position === "outside") {
            const t3 = this.options.textMargin + this.measureLabel(e2).width / 2;
            n2.x += n2.x < i.x ? -t3 : t3;
          }
          return n2;
        }
        return t2.tooltipPosition();
      }, o.prototype.getArcRenderInfo = function(t2, e2) {
        let o2;
        const n2 = t2;
        o2 = this.options.position === "outside" ? n2.outerRadius + this.options.fontSize + this.options.textMargin : this.options.position === "border" ? (n2.outerRadius / 2 + n2.outerRadius) / 2 : (n2.innerRadius + n2.outerRadius) / 2;
        let i = n2.startAngle, s = n2.endAngle;
        const r = s - i;
        i += Math.PI / 2, s += Math.PI / 2;
        return i += (s - (this.measureLabel(e2).width / o2 + i)) / 2, { radius: o2, startAngle: i, endAngle: s, totalAngle: r, view: n2 };
      }, o.prototype.getBarRenderInfo = function(t2, e2) {
        const o2 = t2.tooltipPosition();
        return o2.y -= this.measureLabel(e2).height / 2 + this.options.textMargin, o2;
      }, o.prototype.drawable = function(t2, e2, o2) {
        if (this.options.overlap)
          return true;
        if (this.options.arc)
          return o2.endAngle - o2.startAngle <= o2.totalAngle;
        {
          const n2 = this.measureLabel(e2), i = o2.x - n2.width / 2, s = o2.x + n2.width / 2, r = o2.y - n2.height / 2, a = o2.y + n2.height / 2;
          return this.options.position === "outside" ? this.outsideInRange(i, s, r, a) : t2.inRange(i, r) && t2.inRange(i, a) && t2.inRange(s, r) && t2.inRange(s, a);
        }
      }, o.prototype.outsideInRange = function(t2, e2, o2, n2) {
        const i = this.labelBounds;
        for (let s = 0; s < i.length; ++s) {
          const r = i[s];
          let a = [[t2, o2], [t2, n2], [e2, o2], [e2, n2]];
          for (let t3 = 0; t3 < a.length; ++t3) {
            const e3 = a[t3][0], o3 = a[t3][1];
            if (e3 >= r.left && e3 <= r.right && o3 >= r.top && o3 <= r.bottom)
              return false;
          }
          a = [[r.left, r.top], [r.left, r.bottom], [r.right, r.top], [r.right, r.bottom]];
          for (let i2 = 0; i2 < a.length; ++i2) {
            const s2 = a[i2][0], r2 = a[i2][1];
            if (s2 >= t2 && s2 <= e2 && r2 >= o2 && r2 <= n2)
              return false;
          }
        }
        return i.push({ left: t2, right: e2, top: o2, bottom: n2 }), true;
      }, o.prototype.measureLabel = function(t2) {
        if (typeof t2 == "object")
          return { width: t2.width, height: t2.height };
        {
          let e2 = 0;
          const o2 = t2.split("\n");
          for (let t3 = 0; t3 < o2.length; ++t3) {
            const n2 = this.ctx.measureText(o2[t3]);
            n2.width > e2 && (e2 = n2.width);
          }
          return { width: e2, height: this.options.fontSize * o2.length };
        }
      }, o.prototype.loadImage = function(t2) {
        const e2 = new Image();
        return e2.src = t2.src, e2.width = t2.width, e2.height = t2.height, e2;
      }, Chart.register({ id: "labels", beforeDatasetsUpdate: function(t2, i, s) {
        if (!e[t2.config.type] || !n(s))
          return;
        s.length || (s = [s]);
        const r = s.length;
        t2._labels && r === t2._labels.length || (t2._labels = s.map(function() {
          return new o();
        }));
        let a = false, h = 0;
        for (let e2 = 0; e2 < r; ++e2) {
          const o2 = t2._labels[e2];
          if (o2.setup(t2, s[e2]), o2.options.position === "outside") {
            a = true;
            const t3 = 1.5 * o2.options.fontSize + o2.options.outsidePadding;
            t3 > h && (h = t3);
          }
        }
        a && (t2.chartArea.top += h, t2.chartArea.bottom -= h);
      }, afterDatasetUpdate: function(t2, o2, i) {
        var _a;
        e[t2.config.type] && n(i) && ((_a = t2._labels) == null ? void 0 : _a.forEach(function(t3) {
          t3.args[o2.index] = o2;
        }));
      }, beforeDraw: function(t2, o2, i) {
        var _a;
        e[t2.config.type] && n(i) && ((_a = t2._labels) == null ? void 0 : _a.forEach(function(t3) {
          t3.barTotalPercentage = {};
        }));
      }, afterDatasetsDraw: function(t2, o2, i) {
        var _a;
        e[t2.config.type] && n(i) && ((_a = t2._labels) == null ? void 0 : _a.forEach(function(t3) {
          t3.render();
        }));
      } });
    }();
  });

  // js/chart.js
  var colors = ["#36a2eb"];
  var month = [
    "Janvier",
    "F\xE9vrier",
    "Mars",
    "Avril",
    "Mai",
    "Juin",
    "Juillet",
    "Ao\xFBt",
    "Septembre",
    "Octobre",
    "Novembre",
    "D\xE9cembre"
  ];
  var SURVEY = [
    "Qualit\xE9 du travail effectu\xE9",
    "Gain de temps du client",
    "Respect du d\xE9lai de livraison",
    "Qualit\xE9 de la communication"
  ];
  var HorizontalBarChart = class {
    constructor(ctx, labels, values) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              axis: "x",
              label: "Liste des t\xE2ches",
              data: values,
              fill: false,
              borderColor: colors,
              backgroundColor: colors,
              borderWidth: 1,
              color: "#fff"
            }
          ]
        },
        options: {
          indexAxis: "x",
          responsive: true,
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "Liste des t\xE2ches par contributeurs"
            },
            datalabels: {
              color: "#fff"
            }
          }
        }
      });
    }
  };
  var StackedBarChart = class {
    constructor(ctx, todo_tasks, blocked_tasks, tasks_in_progress, tasks_in_control, achieved_tasks) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels: month,
          datasets: [
            {
              label: "T\xE2ches \xE0 faire",
              data: todo_tasks,
              backgroundColor: "#36a2eb"
            },
            {
              label: "T\xE2ches en blocage",
              data: blocked_tasks,
              backgroundColor: "#e67e22"
            },
            {
              label: "T\xE2ches en cours",
              data: tasks_in_progress,
              backgroundColor: "#27ae60"
            },
            {
              label: "T\xE2ches en contr\xF4le",
              data: tasks_in_control,
              backgroundColor: "#8e44ad"
            },
            {
              label: "T\xE2ches achev\xE9es",
              data: achieved_tasks,
              backgroundColor: "#ff6384"
            }
          ]
        },
        options: {
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "T\xE2ches par mois"
            }
          },
          responsive: true
        }
      });
    }
  };
  var SurveyChart = class {
    constructor(ctx, values) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels: SURVEY,
          datasets: [
            {
              axis: "x",
              label: "Pourcentage de satisfaction en %",
              data: values,
              fill: false,
              borderColor: colors,
              backgroundColor: colors,
              borderWidth: 2,
              color: "#fff"
            }
          ]
        },
        options: {
          maintainAspectRatio: false,
          indexAxis: "y",
          responsive: true,
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "Taux de satisfaction du client"
            },
            datalabels: {
              color: "#fff"
            }
          }
        }
      });
    }
  };

  // js/app.js
  var import_chart3 = __toModule(require_chart());
  require_();
  require_2();
  var Hooks2 = {};
  Hooks2.saisieAction = {
    mounted() {
      const tableBody = document.getElementById("record-table-body");
      const addRowLink = document.getElementById("addRowIcon");
      const dataContainer = document.getElementById("data-container");
      if (tableBody && addRowLink && dataContainer) {
        const userId = dataContainer.dataset.userId;
        const date = dataContainer.dataset.today;
        const username = dataContainer.dataset.username;
        const projects = JSON.parse(dataContainer.dataset.projects);
        addRowLink.addEventListener("click", function() {
          lineNotSaved = haveLineNotSaved(tableBody);
          console.log(lineNotSaved);
          if (!lineNotSaved) {
            addRow(tableBody, import_tom_select3.default, userId, date, username, projects);
          } else {
            var addRowIcon = document.querySelector("#addRowIcon i");
            console.log(addRowIcon);
            addRowLink.classList.add("non-cliquable");
            addRowIcon.style.cursor = "not-allowed";
          }
        });
      }
    }
  };
  Hooks2.showTask = {
    mounted() {
      desactivateAllinputs();
      const profile = this.el.dataset.profile;
      console.log(profile);
      showTask(profile);
    },
    updated() {
      desactivateAllinputs();
    }
  };
  Hooks2.tableHover = {
    mounted() {
      const table = this.el;
      table.querySelectorAll("tbody tr").forEach((row) => {
        let currentColor = "";
        row.addEventListener("mouseover", () => {
          currentColor = row.style.backgroundColor;
          row.style.backgroundColor = "#60b0f0";
        });
        row.addEventListener("mouseout", () => {
          row.style.backgroundColor = currentColor;
        });
      });
    }
  };
  Hooks2.CustomSampleSelect = {
    mounted() {
      console.log("CustomSampleSelect hook initialized");
      var selectElement = document.getElementById("mySelect");
      if (selectElement) {
        console.log("Element found:", selectElement);
        if (!selectElement.tomselect) {
          selectElement.tomselect = new import_tom_select3.default(selectElement, {
            create: false,
            sortField: {
              field: "text",
              direction: "asc"
            }
          });
          console.log("TomSelect options:", selectElement.tomselect.options);
        }
      } else {
        console.error("Select element not found");
      }
    },
    updated() {
      console.log("CustomSampleSelect hook updated");
      var selectElement = document.getElementById("mySelect");
      if (selectElement && selectElement.tomselect) {
        console.log("Element found:", selectElement);
        selectElement.tomselect.clearOptions();
        var selectOptions = selectElement.querySelectorAll("option");
        selectOptions.forEach(function(option) {
          selectElement.tomselect.addOption({
            value: option.value,
            text: option.textContent
          });
        });
        selectElement.tomselect.refreshOptions();
      } else {
        console.error("Select element or TomSelect instance not found");
      }
    }
  };
  Hooks2.CsvExportHook = {
    mounted() {
      this.handleExportClick = this.handleExportClick.bind(this);
      this.el.addEventListener("click", this.handleExportClick);
    },
    destroyed() {
      this.el.removeEventListener("click", this.handleExportClick);
    },
    handleExportClick(event) {
      let csvData = this.el.getAttribute("data-csv");
      console.log("avant :", csvData);
      csvData = csvData.replace(/\\r\\n/g, "\n");
      console.log("apres :", csvData);
      const blob = new Blob([csvData], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      link.href = window.URL.createObjectURL(blob);
      link.download = "exemple.csv";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };
  Hooks2.HorizontalBarChart = {
    mounted() {
      const { labels_tasks_by_contributors, values_tasks_by_contributors } = JSON.parse(this.el.dataset.chartData);
      this.chart = new HorizontalBarChart(this.el, labels_tasks_by_contributors, values_tasks_by_contributors);
    }
  };
  Hooks2.StackedBarChart = {
    mounted() {
      const {
        values_tasks_todo_by_month,
        values_blocking_tasks_by_month,
        values_tasks_in_progress_by_month,
        values_tasks_in_control_by_month,
        values_tasks_achieved_by_month
      } = JSON.parse(this.el.dataset.chartData);
      this.chart = new StackedBarChart(this.el, values_tasks_todo_by_month, values_blocking_tasks_by_month, values_tasks_in_progress_by_month, values_tasks_in_control_by_month, values_tasks_achieved_by_month);
    }
  };
  Hooks2.SurveyChart = {
    mounted() {
      console.log("is mounted");
      const { values } = JSON.parse(this.el.dataset.chartData);
      this.mychart = new SurveyChart(this.el, values);
    }
  };
  Hooks2.Board = {
    mounted() {
      this.initDraggables();
    },
    updated() {
      this.sortableCard.destroy();
      this.sortableStage.destroy();
      this.initDraggables();
    },
    initDraggables() {
      this.sortableCard = new Sortable(document.querySelectorAll(".stage__cards"), {
        draggable: ".card",
        mirror: {
          constrainDimensions: true
        },
        swapAnimation: {
          duration: 200,
          easingFunction: "ease-in-out"
        },
        plugins: [Plugins_exports.SwapAnimation]
      });
      this.sortableCard.on("sortable:stop", (event) => {
        const source = event.data.dragEvent.data.source;
        const cardId = parseInt(source.getAttribute("data-card-id"));
        const newStageId = parseInt(event.data.newContainer.getAttribute("data-stage-id"));
        const newIndex = parseInt(event.data.newIndex);
        const cardPayload = {
          card: {
            id: cardId,
            stage_id: newStageId,
            position: newIndex
          }
        };
        this.pushEvent("update_card", cardPayload);
      });
      this.sortableStage = new Sortable(document.querySelectorAll(".board"), {
        draggable: ".stage",
        handle: ".draggable-handle",
        mirror: {
          constrainDimensions: true,
          yAxis: false
        }
      });
      this.sortableStage.on("sortable:stop", (event) => {
        const source = event.data.dragEvent.data.source;
        const stageId = parseInt(source.getAttribute("data-stage-id"));
        const newIndex = parseInt(event.data.newIndex);
        const stagePayload = {
          stage: {
            id: stageId,
            position: newIndex
          }
        };
        this.pushEvent("update_stage", stagePayload);
      });
    }
  };
  Hooks2.AnimateAlert = {
    mounted() {
      this.handleEvent("AnimateAlert", ({}) => this.reset_opacity());
    },
    updated() {
    },
    reset_opacity() {
      var alert2 = document.querySelector("#alert_anim");
      alert2.style.opacity = 1;
      window.setTimeout(function() {
        alert2.style.display = "none";
      }, 2e3);
    },
    anim_onload() {
      var alerts2 = document.querySelectorAll(".alert");
      alerts2.forEach((item) => {
        item.style.opacity = 1;
        item.onload = window.setTimeout(function() {
          item.style.opacity = 0;
        }, 2e3);
      });
      for (var i = 0; i < alerts2.length; i++) {
        alerts2[i].style.opacity = 1;
        alerts2[i].onload = window.setTimeout(function() {
          alerts2[i].style.opacity = 0;
        }, 2e3);
      }
    }
  };
  Hooks2.blurHook = {
    mounted() {
      this.handleEvent("blurBody", ({ param1, param2 }) => this.blurBody());
    },
    blurBody() {
      var body = document.body;
      var request_form = document.querySelector("#the_request_form");
      body.style.opacity = 0.5;
      request_form.style.opacity = 1;
    }
  };
  Hooks2.MessageBody = {
    mounted() {
      var messageBody = document.querySelector("#messageBody");
      this.handleEvent("updateScroll", ({}) => messageBody.scrollTop = messageBody.scrollHeight - messageBody.clientHeight);
    }
  };
  Hooks2.urlProcess = {
    mounted() {
      let main = document.querySelector("#main");
      var url = window.location.href;
      url.includes("/logs") ? main.classList.remove("container") : main.classList.add("container");
    }
  };
  Hooks2.SpinTest = {
    mounted() {
      this.handleEvent("SpinTest", ({}) => this.spin_icon());
      this.handleEvent("SpinComment", ({}) => this.spin_comment_icon());
    },
    spin_icon() {
      var spins = document.querySelectorAll(".notif__load");
      spins.forEach((item) => {
        item.classList.add("new__rotate__icon");
      });
      spins.forEach((item) => {
        window.setTimeout(function() {
          item.classList.remove("new__rotate__icon");
        }, 500);
      });
    },
    spin_comment_icon() {
      var clock_comment = document.getElementById("clock_comment");
      clock_comment.classList.add("rotate__icon");
      window.setTimeout(function() {
        clock_comment.classList.remove("rotate__icon");
      }, 500);
    }
  };
  var navToggle = document.querySelector(".nav__toggle");
  var navWrapper = document.querySelector(".nav__wrapper");
  navToggle.addEventListener("click", function() {
    if (navWrapper.classList.contains("active")) {
      this.setAttribute("aria-expanded", "false");
      this.setAttribute("aria-label", "menu");
      navWrapper.classList.remove("active");
    } else {
      navWrapper.classList.add("active");
      this.setAttribute("aria-label", "close menu");
      this.setAttribute("aria-expanded", "true");
    }
  });
  var copyrightIcon = document.getElementById("copyright__icon");
  if (copyrightIcon) {
    copyrightIcon.innerHTML = "copyright PHIDIA / Project monitoring -2024";
  }
  var menuBtn = document.querySelector(".menu-btn");
  var menuOpen = false;
  menuBtn.addEventListener("click", () => {
    if (!menuOpen) {
      menuBtn.classList.add("open");
      menuOpen = true;
    } else {
      menuBtn.classList.remove("open");
      menuOpen = false;
    }
  });
  var alerts = document.querySelectorAll(".alert");
  alerts.forEach((item) => {
    item.style.opacity = 1;
    item.onload = window.setTimeout(function() {
      item.style.opacity = 0;
    }, 2e3);
  });
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var liveSocket = new LiveSocket("/live", Socket, {
    params: { _csrf_token: csrfToken },
    hooks: Hooks2
  });
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (info) => import_topbar.default.show());
  window.addEventListener("phx:page-loading-stop", (info) => import_topbar.default.hide());
  liveSocket.connect();
  window.liveSocket = liveSocket;
})();
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
/*!
 * chartjs-plugin-datalabels v2.2.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2022 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */
/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */
/*! sifter.js | https://github.com/orchidjs/sifter.js | Apache License (v2) */
/**
   * [chartjs-plugin-labels]{@link https://github.com/DavideViolante/chartjs-plugin-labels}
   *
   * @version 3.1.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com], Davide Violante, Yousef Altaher
   * @copyright Chen, Yi-Cyuan 2017-2018
   * @license MIT
   */
/**
 * @license MIT
 * topbar 1.0.0, 2021-01-06
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9jb250cmliL21pY3JvZXZlbnQudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9jb250cmliL21pY3JvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMvZGlzdC9lc20vcmVnZXguanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvdW5pY29kZS12YXJpYW50cy9kaXN0L2VzbS9zdHJpbmdzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMvZGlzdC9lc20vaW5kZXguanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvc2lmdGVyL2Rpc3QvZXNtL3V0aWxzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9ub2RlX21vZHVsZXMvQG9yY2hpZGpzL3NpZnRlci9kaXN0L2VzbS9zaWZ0ZXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L25vZGVfbW9kdWxlcy9Ab3JjaGlkanMvc2lmdGVyL2xpYi91dGlscy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3ZhbmlsbGEudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9jb250cmliL2hpZ2hsaWdodC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL2NvbnN0YW50cy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL2RlZmF1bHRzLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvdXRpbHMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9nZXRTZXR0aW5ncy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3RvbS1zZWxlY3QudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL2NoYW5nZV9saXN0ZW5lci9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL2NoZWNrYm94X29wdGlvbnMvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9jbGVhcl9idXR0b24vcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9kcmFnX2Ryb3AvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9kcm9wZG93bl9oZWFkZXIvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9jYXJldF9wb3NpdGlvbi9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL2Ryb3Bkb3duX2lucHV0L3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3BsdWdpbnMvaW5wdXRfYXV0b2dyb3cvcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9ub19iYWNrc3BhY2VfZGVsZXRlL3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3BsdWdpbnMvbm9fYWN0aXZlX2l0ZW1zL3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3BsdWdpbnMvb3B0Z3JvdXBfY29sdW1ucy9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL3JlbW92ZV9idXR0b24vcGx1Z2luLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvdG9tLXNlbGVjdC9zcmMvcGx1Z2lucy9yZXN0b3JlX29uX2JhY2tzcGFjZS9wbHVnaW4udHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy90b20tc2VsZWN0L3NyYy9wbHVnaW5zL3ZpcnR1YWxfc2Nyb2xsL3BsdWdpbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3RvbS1zZWxlY3Qvc3JjL3RvbS1zZWxlY3QuY29tcGxldGUudHMiLCAiLi4vLi4vLi4vYXNzZXRzL3ZlbmRvci90b3BiYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NoYXJ0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvaGVscGVycy9oZWxwZXJzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9kaXN0L2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL2pzL2FwcC5qcyIsICIuLi8uLi8uLi9hc3NldHMvanMvdG9tX3NlbGVjdF9zYWlzaWVfcGFnZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvanMvc2hvd2luZ190YXNrLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9odG1sL3ByaXYvc3RhdGljL3Bob2VuaXhfaHRtbC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvdXRpbHMuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L2NvbnN0YW50cy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvcHVzaC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvdGltZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L2NoYW5uZWwuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L2FqYXguanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L2xvbmdwb2xsLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9wcmVzZW5jZS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvc2VyaWFsaXplci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvc29ja2V0LmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2NvbnN0YW50cy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9lbnRyeV91cGxvYWRlci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy91dGlscy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9icm93c2VyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy91cGxvYWRfZW50cnkuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvbGl2ZV91cGxvYWRlci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9ob29rcy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9kb21fcG9zdF9tb3JwaF9yZXN0b3Jlci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9ub2RlX21vZHVsZXMvbW9ycGhkb20vZGlzdC9tb3JwaGRvbS1lc20uanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3BhdGNoLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3JlbmRlcmVkLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3ZpZXdfaG9vay5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9qcy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy92aWV3LmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2xpdmVfc29ja2V0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9zaGFyZWQvQWJzdHJhY3RFdmVudC9BYnN0cmFjdEV2ZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vc2hhcmVkL0Fic3RyYWN0UGx1Z2luL0Fic3RyYWN0UGx1Z2luLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1NlbnNvcnMvU2Vuc29yL1NlbnNvci5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL3NoYXJlZC91dGlscy9jbG9zZXN0L2Nsb3Nlc3QubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9zaGFyZWQvdXRpbHMvZGlzdGFuY2UvZGlzdGFuY2UubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvU2Vuc29ycy9TZW5zb3JFdmVudC9TZW5zb3JFdmVudC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9TZW5zb3JzL01vdXNlU2Vuc29yL01vdXNlU2Vuc29yLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vc2hhcmVkL3V0aWxzL3RvdWNoQ29vcmRzL3RvdWNoQ29vcmRzLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1NlbnNvcnMvVG91Y2hTZW5zb3IvVG91Y2hTZW5zb3IubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvU2Vuc29ycy9EcmFnU2Vuc29yL0RyYWdTZW5zb3IubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvU2Vuc29ycy9Gb3JjZVRvdWNoU2Vuc29yL0ZvcmNlVG91Y2hTZW5zb3IubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9QbHVnaW5zL2luZGV4Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vUGx1Z2lucy9Db2xsaWRhYmxlL0NvbGxpZGFibGVFdmVudC9Db2xsaWRhYmxlRXZlbnQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9QbHVnaW5zL0NvbGxpZGFibGUvQ29sbGlkYWJsZS5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9zaGFyZWQvdXRpbHMvZGVjb3JhdG9ycy9BdXRvQmluZC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL3NoYXJlZC91dGlscy9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lL3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvRHJhZ0V2ZW50L0RyYWdFdmVudC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL1BsdWdpbnMvUmVzaXplTWlycm9yL1Jlc2l6ZU1pcnJvci5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL1BsdWdpbnMvU25hcHBhYmxlL1NuYXBwYWJsZUV2ZW50L1NuYXBwYWJsZUV2ZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vUGx1Z2lucy9TbmFwcGFibGUvU25hcHBhYmxlLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vUGx1Z2lucy9Td2FwQW5pbWF0aW9uL1N3YXBBbmltYXRpb24ubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9QbHVnaW5zL1NvcnRBbmltYXRpb24vU29ydEFuaW1hdGlvbi5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9QbHVnaW5zL0Fubm91bmNlbWVudC9Bbm5vdW5jZW1lbnQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvUGx1Z2lucy9Gb2N1c2FibGUvRm9jdXNhYmxlLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1BsdWdpbnMvTWlycm9yL01pcnJvckV2ZW50L01pcnJvckV2ZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJhZ2dhYmxlL1BsdWdpbnMvTWlycm9yL01pcnJvci5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9QbHVnaW5zL1Njcm9sbGFibGUvU2Nyb2xsYWJsZS5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL0RyYWdnYWJsZS9FbWl0dGVyL0VtaXR0ZXIubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvRHJhZ2dhYmxlRXZlbnQvRHJhZ2dhYmxlRXZlbnQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9EcmFnZ2FibGUvRHJhZ2dhYmxlLm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJvcHBhYmxlL0Ryb3BwYWJsZUV2ZW50L0Ryb3BwYWJsZUV2ZW50Lm1qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL0BzaG9waWZ5L2RyYWdnYWJsZS9idWlsZC9lc20vRHJvcHBhYmxlL0Ryb3BwYWJsZS5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL1N3YXBwYWJsZS9Td2FwcGFibGVFdmVudC9Td2FwcGFibGVFdmVudC5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvYnVpbGQvZXNtL1N3YXBwYWJsZS9Td2FwcGFibGUubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9Tb3J0YWJsZS9Tb3J0YWJsZUV2ZW50L1NvcnRhYmxlRXZlbnQubWpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQHNob3BpZnkvZHJhZ2dhYmxlL2J1aWxkL2VzbS9Tb3J0YWJsZS9Tb3J0YWJsZS5tanMiLCAiLi4vLi4vLi4vYXNzZXRzL2pzL2NoYXJ0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMtcGx1Z2luLWxhYmVscy1kdi9kaXN0L2NoYXJ0anMtcGx1Z2luLWxhYmVscy5taW4uanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogTWljcm9FdmVudCAtIHRvIG1ha2UgYW55IGpzIG9iamVjdCBhbiBldmVudCBlbWl0dGVyXG4gKlxuICogLSBwdXJlIGphdmFzY3JpcHQgLSBzZXJ2ZXIgY29tcGF0aWJsZSwgYnJvd3NlciBjb21wYXRpYmxlXG4gKiAtIGRvbnQgcmVseSBvbiB0aGUgYnJvd3NlciBkb21zXG4gKiAtIHN1cGVyIHNpbXBsZSAtIHlvdSBnZXQgaXQgaW1tZWRpYXRseSwgbm8gbWlzdGVyeSwgbm8gbWFnaWMgaW52b2x2ZWRcbiAqXG4gKiBAYXV0aG9yIEplcm9tZSBFdGllbm5lIChodHRwczovL2dpdGh1Yi5jb20vamVyb21lZXRpZW5uZSlcbiAqL1xuXG50eXBlIFRDYWxsYmFjayA9ICguLi5hcmdzOmFueSkgPT4gYW55O1xuXG4vKipcbiAqIEV4ZWN1dGUgY2FsbGJhY2sgZm9yIGVhY2ggZXZlbnQgaW4gc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZXZlbnQgbmFtZXNcbiAqXG4gKi9cbmZ1bmN0aW9uIGZvckV2ZW50cyhldmVudHM6c3RyaW5nLGNhbGxiYWNrOihldmVudDpzdHJpbmcpPT5hbnkpe1xuXHRldmVudHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChldmVudCkgPT57XG5cdFx0Y2FsbGJhY2soZXZlbnQpO1xuXHR9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWljcm9FdmVudHtcblxuXHRwdWJsaWMgX2V2ZW50czoge1trZXk6c3RyaW5nXTpUQ2FsbGJhY2tbXX07XG5cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLl9ldmVudHMgPSB7fTtcblx0fVxuXG5cdG9uKGV2ZW50czpzdHJpbmcsIGZjdDpUQ2FsbGJhY2spe1xuXHRcdGZvckV2ZW50cyhldmVudHMsKGV2ZW50KSA9PiB7XG5cdFx0XHRjb25zdCBldmVudF9hcnJheSA9IHRoaXMuX2V2ZW50c1tldmVudF0gfHwgW107XG5cdFx0XHRldmVudF9hcnJheS5wdXNoKGZjdCk7XG5cdFx0XHR0aGlzLl9ldmVudHNbZXZlbnRdID0gZXZlbnRfYXJyYXk7XG5cdFx0fSk7XG5cdH1cblxuXHRvZmYoZXZlbnRzOnN0cmluZywgZmN0OlRDYWxsYmFjayl7XG5cdFx0dmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmKCBuID09PSAwICl7XG5cdFx0XHR0aGlzLl9ldmVudHMgPSB7fTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3JFdmVudHMoZXZlbnRzLChldmVudCkgPT4ge1xuXG5cdFx0XHRpZiAobiA9PT0gMSl7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZXZlbnRfYXJyYXkgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuXHRcdFx0aWYoIGV2ZW50X2FycmF5ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdGV2ZW50X2FycmF5LnNwbGljZShldmVudF9hcnJheS5pbmRleE9mKGZjdCksIDEpO1xuXHRcdFx0dGhpcy5fZXZlbnRzW2V2ZW50XSA9IGV2ZW50X2FycmF5O1xuXHRcdH0pO1xuXHR9XG5cblx0dHJpZ2dlcihldmVudHM6c3RyaW5nLCAuLi5hcmdzOmFueSl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0Zm9yRXZlbnRzKGV2ZW50cywoZXZlbnQpID0+IHtcblx0XHRcdGNvbnN0IGV2ZW50X2FycmF5ID0gc2VsZi5fZXZlbnRzW2V2ZW50XTtcblx0XHRcdGlmKCBldmVudF9hcnJheSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXHRcdFx0ZXZlbnRfYXJyYXkuZm9yRWFjaChmY3QgPT4ge1xuXHRcdFx0XHRmY3QuYXBwbHkoc2VsZiwgYXJncyApO1xuXHRcdFx0fSk7XG5cblx0XHR9KTtcblx0fVxufTtcbiIsICIvKipcbiAqIG1pY3JvcGx1Z2luLmpzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgQnJpYW4gUmVhdmlzICYgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBhdXRob3IgQnJpYW4gUmVhdmlzIDxicmlhbkB0aGlyZHJvdXRlLmNvbT5cbiAqL1xuXG50eXBlIFRTZXR0aW5ncyA9IHtcblx0W2tleTpzdHJpbmddOmFueVxufVxuXG50eXBlIFRQbHVnaW5zID0ge1xuXHRuYW1lczogc3RyaW5nW10sXG5cdHNldHRpbmdzOiBUU2V0dGluZ3MsXG5cdHJlcXVlc3RlZDoge1trZXk6c3RyaW5nXTpib29sZWFufSxcblx0bG9hZGVkOiB7W2tleTpzdHJpbmddOmFueX1cbn07XG5cbmV4cG9ydCB0eXBlIFRQbHVnaW5JdGVtID0ge25hbWU6c3RyaW5nLG9wdGlvbnM6e319O1xuZXhwb3J0IHR5cGUgVFBsdWdpbkhhc2ggPSB7W2tleTpzdHJpbmddOnt9fTtcblxuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWljcm9QbHVnaW4oSW50ZXJmYWNlOiBhbnkgKXtcblxuXHRJbnRlcmZhY2UucGx1Z2lucyA9IHt9O1xuXG5cdHJldHVybiBjbGFzcyBleHRlbmRzIEludGVyZmFjZXtcblxuXHRcdHB1YmxpYyBwbHVnaW5zOlRQbHVnaW5zID0ge1xuXHRcdFx0bmFtZXMgICAgIDogW10sXG5cdFx0XHRzZXR0aW5ncyAgOiB7fSxcblx0XHRcdHJlcXVlc3RlZCA6IHt9LFxuXHRcdFx0bG9hZGVkICAgIDoge31cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIGEgcGx1Z2luLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cblx0XHQgKi9cblx0XHRzdGF0aWMgZGVmaW5lKG5hbWU6c3RyaW5nLCBmbjoodGhpczphbnksc2V0dGluZ3M6VFNldHRpbmdzKT0+YW55KXtcblx0XHRcdEludGVyZmFjZS5wbHVnaW5zW25hbWVdID0ge1xuXHRcdFx0XHQnbmFtZScgOiBuYW1lLFxuXHRcdFx0XHQnZm4nICAgOiBmblxuXHRcdFx0fTtcblx0XHR9XG5cblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemVzIHRoZSBsaXN0ZWQgcGx1Z2lucyAod2l0aCBvcHRpb25zKS5cblx0XHQgKiBBY2NlcHRhYmxlIGZvcm1hdHM6XG5cdFx0ICpcblx0XHQgKiBMaXN0ICh3aXRob3V0IG9wdGlvbnMpOlxuXHRcdCAqICAgWydhJywgJ2InLCAnYyddXG5cdFx0ICpcblx0XHQgKiBMaXN0ICh3aXRoIG9wdGlvbnMpOlxuXHRcdCAqICAgW3snbmFtZSc6ICdhJywgb3B0aW9uczoge319LCB7J25hbWUnOiAnYicsIG9wdGlvbnM6IHt9fV1cblx0XHQgKlxuXHRcdCAqIEhhc2ggKHdpdGggb3B0aW9ucyk6XG5cdFx0ICogICB7J2EnOiB7IC4uLiB9LCAnYic6IHsgLi4uIH0sICdjJzogeyAuLi4gfX1cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBwbHVnaW5zXG5cdFx0ICovXG5cdFx0aW5pdGlhbGl6ZVBsdWdpbnMocGx1Z2luczpzdHJpbmdbXXxUUGx1Z2luSXRlbVtdfFRQbHVnaW5IYXNoKSB7XG5cdFx0XHR2YXIga2V5LCBuYW1lO1xuXHRcdFx0Y29uc3Qgc2VsZiAgPSB0aGlzO1xuXHRcdFx0Y29uc3QgcXVldWU6c3RyaW5nW10gPSBbXTtcblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkocGx1Z2lucykpIHtcblx0XHRcdFx0cGx1Z2lucy5mb3JFYWNoKChwbHVnaW46c3RyaW5nfFRQbHVnaW5JdGVtKT0+e1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgcGx1Z2luID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaChwbHVnaW4pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLnBsdWdpbnMuc2V0dGluZ3NbcGx1Z2luLm5hbWVdID0gcGx1Z2luLm9wdGlvbnM7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHBsdWdpbi5uYW1lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIGlmIChwbHVnaW5zKSB7XG5cdFx0XHRcdGZvciAoa2V5IGluIHBsdWdpbnMpIHtcblx0XHRcdFx0XHRpZiAocGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnBsdWdpbnMuc2V0dGluZ3Nba2V5XSA9IHBsdWdpbnNba2V5XTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0d2hpbGUoIG5hbWUgPSBxdWV1ZS5zaGlmdCgpICl7XG5cdFx0XHRcdHNlbGYucmVxdWlyZShuYW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsb2FkUGx1Z2luKG5hbWU6c3RyaW5nKSB7XG5cdFx0XHR2YXIgc2VsZiAgICA9IHRoaXM7XG5cdFx0XHR2YXIgcGx1Z2lucyA9IHNlbGYucGx1Z2lucztcblx0XHRcdHZhciBwbHVnaW4gID0gSW50ZXJmYWNlLnBsdWdpbnNbbmFtZV07XG5cblx0XHRcdGlmICghSW50ZXJmYWNlLnBsdWdpbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBcIicgKyAgbmFtZSArICdcIiBwbHVnaW4nKTtcblx0XHRcdH1cblxuXHRcdFx0cGx1Z2lucy5yZXF1ZXN0ZWRbbmFtZV0gPSB0cnVlO1xuXHRcdFx0cGx1Z2lucy5sb2FkZWRbbmFtZV0gPSBwbHVnaW4uZm4uYXBwbHkoc2VsZiwgW3NlbGYucGx1Z2lucy5zZXR0aW5nc1tuYW1lXSB8fCB7fV0pO1xuXHRcdFx0cGx1Z2lucy5uYW1lcy5wdXNoKG5hbWUpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemVzIGEgcGx1Z2luLlxuXHRcdCAqXG5cdFx0ICovXG5cdFx0cmVxdWlyZShuYW1lOnN0cmluZykge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHBsdWdpbnMgPSBzZWxmLnBsdWdpbnM7XG5cblx0XHRcdGlmICghc2VsZi5wbHVnaW5zLmxvYWRlZC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHRpZiAocGx1Z2lucy5yZXF1ZXN0ZWRbbmFtZV0pIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BsdWdpbiBoYXMgY2lyY3VsYXIgZGVwZW5kZW5jeSAoXCInICsgbmFtZSArICdcIiknKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLmxvYWRQbHVnaW4obmFtZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwbHVnaW5zLmxvYWRlZFtuYW1lXTtcblx0XHR9XG5cblx0fTtcblxufVxuIiwgIi8qISBAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyB8IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzIHwgQXBhY2hlIExpY2Vuc2UgKHYyKSAqL1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIHN0cmluZ3MgdG8gYSByZWd1bGFyIGV4cHJlc3Npb25cbiAqXHRleCBbJ2FiJywnYSddID0+ICg/OmFifGEpXG4gKiBcdGV4IFsnYScsJ2InXSA9PiBbYWJdXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBjaGFyc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCBhcnJheVRvUGF0dGVybiA9IGNoYXJzID0+IHtcbiAgY2hhcnMgPSBjaGFycy5maWx0ZXIoQm9vbGVhbik7XG5cbiAgaWYgKGNoYXJzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gY2hhcnNbMF0gfHwgJyc7XG4gIH1cblxuICByZXR1cm4gbWF4VmFsdWVMZW5ndGgoY2hhcnMpID09IDEgPyAnWycgKyBjaGFycy5qb2luKCcnKSArICddJyA6ICcoPzonICsgY2hhcnMuam9pbignfCcpICsgJyknO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gYXJyYXlcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5jb25zdCBzZXF1ZW5jZVBhdHRlcm4gPSBhcnJheSA9PiB7XG4gIGlmICghaGFzRHVwbGljYXRlcyhhcnJheSkpIHtcbiAgICByZXR1cm4gYXJyYXkuam9pbignJyk7XG4gIH1cblxuICBsZXQgcGF0dGVybiA9ICcnO1xuICBsZXQgcHJldl9jaGFyX2NvdW50ID0gMDtcblxuICBjb25zdCBwcmV2X3BhdHRlcm4gPSAoKSA9PiB7XG4gICAgaWYgKHByZXZfY2hhcl9jb3VudCA+IDEpIHtcbiAgICAgIHBhdHRlcm4gKz0gJ3snICsgcHJldl9jaGFyX2NvdW50ICsgJ30nO1xuICAgIH1cbiAgfTtcblxuICBhcnJheS5mb3JFYWNoKChjaGFyLCBpKSA9PiB7XG4gICAgaWYgKGNoYXIgPT09IGFycmF5W2kgLSAxXSkge1xuICAgICAgcHJldl9jaGFyX2NvdW50Kys7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJldl9wYXR0ZXJuKCk7XG4gICAgcGF0dGVybiArPSBjaGFyO1xuICAgIHByZXZfY2hhcl9jb3VudCA9IDE7XG4gIH0pO1xuICBwcmV2X3BhdHRlcm4oKTtcbiAgcmV0dXJuIHBhdHRlcm47XG59O1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIHN0cmluZ3MgdG8gYSByZWd1bGFyIGV4cHJlc3Npb25cbiAqXHRleCBbJ2FiJywnYSddID0+ICg/OmFifGEpXG4gKiBcdGV4IFsnYScsJ2InXSA9PiBbYWJdXG4gKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBjaGFyc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmNvbnN0IHNldFRvUGF0dGVybiA9IGNoYXJzID0+IHtcbiAgbGV0IGFycmF5ID0gdG9BcnJheShjaGFycyk7XG4gIHJldHVybiBhcnJheVRvUGF0dGVybihhcnJheSk7XG59O1xuLyoqXG4gKlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzM3NjU5OC9pbi1qYXZhc2NyaXB0LWhvdy1kby1pLWNoZWNrLWlmLWFuLWFycmF5LWhhcy1kdXBsaWNhdGUtdmFsdWVzXG4gKiBAcGFyYW0ge2FueVtdfSBhcnJheVxuICovXG5cbmNvbnN0IGhhc0R1cGxpY2F0ZXMgPSBhcnJheSA9PiB7XG4gIHJldHVybiBuZXcgU2V0KGFycmF5KS5zaXplICE9PSBhcnJheS5sZW5ndGg7XG59O1xuLyoqXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MzAwNjYwMS93aHktZG9lcy11LXRocm93LWFuLWludmFsaWQtZXNjYXBlLWVycm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuY29uc3QgZXNjYXBlX3JlZ2V4ID0gc3RyID0+IHtcbiAgcmV0dXJuIChzdHIgKyAnJykucmVwbGFjZSgvKFtcXCRcXChcXClcXCpcXCtcXC5cXD9cXFtcXF1cXF5cXHtcXHxcXH1cXFxcXSkvZ3UsICdcXFxcJDEnKTtcbn07XG4vKipcbiAqIFJldHVybiB0aGUgbWF4IGxlbmd0aCBvZiBhcnJheSB2YWx1ZXNcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFycmF5XG4gKlxuICovXG5cbmNvbnN0IG1heFZhbHVlTGVuZ3RoID0gYXJyYXkgPT4ge1xuICByZXR1cm4gYXJyYXkucmVkdWNlKChsb25nZXN0LCB2YWx1ZSkgPT4gTWF0aC5tYXgobG9uZ2VzdCwgdW5pY29kZUxlbmd0aCh2YWx1ZSkpLCAwKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuXG5jb25zdCB1bmljb2RlTGVuZ3RoID0gc3RyID0+IHtcbiAgcmV0dXJuIHRvQXJyYXkoc3RyKS5sZW5ndGg7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2FueX0gcFxuICogQHJldHVybiB7YW55W119XG4gKi9cblxuY29uc3QgdG9BcnJheSA9IHAgPT4gQXJyYXkuZnJvbShwKTtcblxuZXhwb3J0IHsgYXJyYXlUb1BhdHRlcm4sIGVzY2FwZV9yZWdleCwgaGFzRHVwbGljYXRlcywgbWF4VmFsdWVMZW5ndGgsIHNlcXVlbmNlUGF0dGVybiwgc2V0VG9QYXR0ZXJuLCB0b0FycmF5LCB1bmljb2RlTGVuZ3RoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdleC5qcy5tYXBcbiIsICIvKiEgQG9yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMgfCBodHRwczovL2dpdGh1Yi5jb20vb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyB8IEFwYWNoZSBMaWNlbnNlICh2MikgKi9cbi8qKlxuICogR2V0IGFsbCBwb3NzaWJsZSBjb21iaW5hdGlvbnMgb2Ygc3Vic3RyaW5ncyB0aGF0IGFkZCB1cCB0byB0aGUgZ2l2ZW4gc3RyaW5nXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDE2OTU4Ny9maW5kLWFsbC10aGUtY29tYmluYXRpb24tb2Ytc3Vic3RyaW5ncy10aGF0LWFkZC11cC10by10aGUtZ2l2ZW4tc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gKi9cbmNvbnN0IGFsbFN1YnN0cmluZ3MgPSBpbnB1dCA9PiB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDEpIHJldHVybiBbW2lucHV0XV07XG4gIC8qKiBAdHlwZSB7c3RyaW5nW11bXX0gKi9cblxuICBsZXQgcmVzdWx0ID0gW107XG4gIGNvbnN0IHN0YXJ0ID0gaW5wdXQuc3Vic3RyaW5nKDEpO1xuICBjb25zdCBzdWJhID0gYWxsU3Vic3RyaW5ncyhzdGFydCk7XG4gIHN1YmEuZm9yRWFjaChmdW5jdGlvbiAoc3VicmVzdWx0KSB7XG4gICAgbGV0IHRtcCA9IHN1YnJlc3VsdC5zbGljZSgwKTtcbiAgICB0bXBbMF0gPSBpbnB1dC5jaGFyQXQoMCkgKyB0bXBbMF07XG4gICAgcmVzdWx0LnB1c2godG1wKTtcbiAgICB0bXAgPSBzdWJyZXN1bHQuc2xpY2UoMCk7XG4gICAgdG1wLnVuc2hpZnQoaW5wdXQuY2hhckF0KDApKTtcbiAgICByZXN1bHQucHVzaCh0bXApO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCB7IGFsbFN1YnN0cmluZ3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwXG4iLCAiLyohIEBvcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzIHwgaHR0cHM6Ly9naXRodWIuY29tL29yY2hpZGpzL3VuaWNvZGUtdmFyaWFudHMgfCBBcGFjaGUgTGljZW5zZSAodjIpICovXG5pbXBvcnQgeyB0b0FycmF5LCBzZXRUb1BhdHRlcm4sIGVzY2FwZV9yZWdleCwgYXJyYXlUb1BhdHRlcm4sIHNlcXVlbmNlUGF0dGVybiB9IGZyb20gJy4vcmVnZXguanMnO1xuZXhwb3J0IHsgZXNjYXBlX3JlZ2V4IH0gZnJvbSAnLi9yZWdleC5qcyc7XG5pbXBvcnQgeyBhbGxTdWJzdHJpbmdzIH0gZnJvbSAnLi9zdHJpbmdzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1trZXk6c3RyaW5nXTpzdHJpbmd9fSBUVW5pY29kZU1hcFxuICogQHR5cGVkZWYge3tba2V5OnN0cmluZ106U2V0PHN0cmluZz59fSBUVW5pY29kZVNldHNcbiAqIEB0eXBlZGVmIHtbW251bWJlcixudW1iZXJdXX0gVENvZGVQb2ludHNcbiAqIEB0eXBlZGVmIHt7Zm9sZGVkOnN0cmluZyxjb21wb3NlZDpzdHJpbmcsY29kZV9wb2ludDpudW1iZXJ9fSBUQ29kZVBvaW50T2JqXG4gKiBAdHlwZWRlZiB7e3N0YXJ0Om51bWJlcixlbmQ6bnVtYmVyLGxlbmd0aDpudW1iZXIsc3Vic3RyOnN0cmluZ319IFRTZXF1ZW5jZVBhcnRcbiAqL1xuLyoqIEB0eXBlIHtUQ29kZVBvaW50c30gKi9cblxuY29uc3QgY29kZV9wb2ludHMgPSBbWzAsIDY1NTM1XV07XG5jb25zdCBhY2NlbnRfcGF0ID0gJ1tcXHUwMzAwLVxcdTAzNkZcXHV7Yjd9XFx1ezJiZX1cXHV7MmJjfV0nO1xuLyoqIEB0eXBlIHtUVW5pY29kZU1hcH0gKi9cblxubGV0IHVuaWNvZGVfbWFwO1xuLyoqIEB0eXBlIHtSZWdFeHB9ICovXG5cbmxldCBtdWx0aV9jaGFyX3JlZztcbmNvbnN0IG1heF9jaGFyX2xlbmd0aCA9IDM7XG4vKiogQHR5cGUge1RVbmljb2RlTWFwfSAqL1xuXG5jb25zdCBsYXRpbl9jb252ZXJ0ID0ge307XG4vKiogQHR5cGUge1RVbmljb2RlTWFwfSAqL1xuXG5jb25zdCBsYXRpbl9jb25kZW5zZWQgPSB7XG4gICcvJzogJ1x1MjA0NFx1MjIxNScsXG4gICcwJzogJ1x1MDdDMCcsXG4gIFwiYVwiOiBcIlx1MkM2NVx1MDI1MFx1MDI1MVwiLFxuICBcImFhXCI6IFwiXHVBNzMzXCIsXG4gIFwiYWVcIjogXCJcdTAwRTZcdTAxRkRcdTAxRTNcIixcbiAgXCJhb1wiOiBcIlx1QTczNVwiLFxuICBcImF1XCI6IFwiXHVBNzM3XCIsXG4gIFwiYXZcIjogXCJcdUE3MzlcdUE3M0JcIixcbiAgXCJheVwiOiBcIlx1QTczRFwiLFxuICBcImJcIjogXCJcdTAxODBcdTAyNTNcdTAxODNcIixcbiAgXCJjXCI6IFwiXHVBNzNGXHUwMTg4XHUwMjNDXHUyMTg0XCIsXG4gIFwiZFwiOiBcIlx1MDExMVx1MDI1N1x1MDI1Nlx1MUQwNVx1MDE4Q1x1QUJCN1x1MDUwMVx1MDI2NlwiLFxuICBcImVcIjogXCJcdTAyNUJcdTAxRERcdTFEMDdcdTAyNDdcIixcbiAgXCJmXCI6IFwiXHVBNzdDXHUwMTkyXCIsXG4gIFwiZ1wiOiBcIlx1MDFFNVx1MDI2MFx1QTdBMVx1MUQ3OVx1QTc3Rlx1MDI2MlwiLFxuICBcImhcIjogXCJcdTAxMjdcdTJDNjhcdTJDNzZcdTAyNjVcIixcbiAgXCJpXCI6IFwiXHUwMjY4XHUwMTMxXCIsXG4gIFwialwiOiBcIlx1MDI0OVx1MDIzN1wiLFxuICBcImtcIjogXCJcdTAxOTlcdTJDNkFcdUE3NDFcdUE3NDNcdUE3NDVcdUE3QTNcIixcbiAgXCJsXCI6IFwiXHUwMTQyXHUwMTlBXHUwMjZCXHUyQzYxXHVBNzQ5XHVBNzQ3XHVBNzgxXHUwMjZEXCIsXG4gIFwibVwiOiBcIlx1MDI3MVx1MDI2Rlx1MDNGQlwiLFxuICBcIm5cIjogXCJcdUE3QTVcdTAxOUVcdTAyNzJcdUE3OTFcdTFEMEVcdTA0M0JcdTA1MDlcIixcbiAgXCJvXCI6IFwiXHUwMEY4XHUwMUZGXHUwMjU0XHUwMjc1XHVBNzRCXHVBNzREXHUxRDExXCIsXG4gIFwib2VcIjogXCJcdTAxNTNcIixcbiAgXCJvaVwiOiBcIlx1MDFBM1wiLFxuICBcIm9vXCI6IFwiXHVBNzRGXCIsXG4gIFwib3VcIjogXCJcdTAyMjNcIixcbiAgXCJwXCI6IFwiXHUwMUE1XHUxRDdEXHVBNzUxXHVBNzUzXHVBNzU1XHUwM0MxXCIsXG4gIFwicVwiOiBcIlx1QTc1N1x1QTc1OVx1MDI0QlwiLFxuICBcInJcIjogXCJcdTAyNERcdTAyN0RcdUE3NUJcdUE3QTdcdUE3ODNcIixcbiAgXCJzXCI6IFwiXHUwMERGXHUwMjNGXHVBN0E5XHVBNzg1XHUwMjgyXCIsXG4gIFwidFwiOiBcIlx1MDE2N1x1MDFBRFx1MDI4OFx1MkM2Nlx1QTc4N1wiLFxuICBcInRoXCI6IFwiXHUwMEZFXCIsXG4gIFwidHpcIjogXCJcdUE3MjlcIixcbiAgXCJ1XCI6IFwiXHUwMjg5XCIsXG4gIFwidlwiOiBcIlx1MDI4Qlx1QTc1Rlx1MDI4Q1wiLFxuICBcInZ5XCI6IFwiXHVBNzYxXCIsXG4gIFwid1wiOiBcIlx1MkM3M1wiLFxuICBcInlcIjogXCJcdTAxQjRcdTAyNEZcdTFFRkZcIixcbiAgXCJ6XCI6IFwiXHUwMUI2XHUwMjI1XHUwMjQwXHUyQzZDXHVBNzYzXCIsXG4gIFwiaHZcIjogXCJcdTAxOTVcIlxufTtcblxuZm9yIChsZXQgbGF0aW4gaW4gbGF0aW5fY29uZGVuc2VkKSB7XG4gIGxldCB1bmljb2RlID0gbGF0aW5fY29uZGVuc2VkW2xhdGluXSB8fCAnJztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHVuaWNvZGUubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2hhciA9IHVuaWNvZGUuc3Vic3RyaW5nKGksIGkgKyAxKTtcbiAgICBsYXRpbl9jb252ZXJ0W2NoYXJdID0gbGF0aW47XG4gIH1cbn1cblxuY29uc3QgY29udmVydF9wYXQgPSBuZXcgUmVnRXhwKE9iamVjdC5rZXlzKGxhdGluX2NvbnZlcnQpLmpvaW4oJ3wnKSArICd8JyArIGFjY2VudF9wYXQsICdndScpO1xuLyoqXG4gKiBJbml0aWFsaXplIHRoZSB1bmljb2RlX21hcCBmcm9tIHRoZSBnaXZlIGNvZGUgcG9pbnQgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtUQ29kZVBvaW50cz19IF9jb2RlX3BvaW50c1xuICovXG5cbmNvbnN0IGluaXRpYWxpemUgPSBfY29kZV9wb2ludHMgPT4ge1xuICBpZiAodW5pY29kZV9tYXAgIT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICB1bmljb2RlX21hcCA9IGdlbmVyYXRlTWFwKF9jb2RlX3BvaW50cyB8fCBjb2RlX3BvaW50cyk7XG59O1xuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIGZvciBub3JtYWxpemUgYSBzdHJpbmdcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9ub3JtYWxpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtXG4gKi9cblxuY29uc3Qgbm9ybWFsaXplID0gKHN0ciwgZm9ybSA9ICdORktEJykgPT4gc3RyLm5vcm1hbGl6ZShmb3JtKTtcbi8qKlxuICogUmVtb3ZlIGFjY2VudHMgd2l0aG91dCByZW9yZGVyaW5nIHN0cmluZ1xuICogY2FsbGluZyBzdHIubm9ybWFsaXplKCdORktEJykgb24gXFx1ezU5NH1cXHV7NTk1fVxcdXs1OTZ9IGJlY29tZXMgXFx1ezU5Nn1cXHV7NTk0fVxcdXs1OTV9XG4gKiB2aWEgaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrL0Z1c2UvaXNzdWVzLzEzMyNpc3N1ZWNvbW1lbnQtMzE4NjkyNzAzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuY29uc3QgYXNjaWlmb2xkID0gc3RyID0+IHtcbiAgcmV0dXJuIHRvQXJyYXkoc3RyKS5yZWR1Y2UoXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG4gICAqL1xuICAocmVzdWx0LCBjaGFyKSA9PiB7XG4gICAgcmV0dXJuIHJlc3VsdCArIF9hc2NpaWZvbGQoY2hhcik7XG4gIH0sICcnKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5jb25zdCBfYXNjaWlmb2xkID0gc3RyID0+IHtcbiAgc3RyID0gbm9ybWFsaXplKHN0cikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKGNvbnZlcnRfcGF0LCAoXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBjaGFyKSA9PiB7XG4gICAgcmV0dXJuIGxhdGluX2NvbnZlcnRbY2hhcl0gfHwgJyc7XG4gIH0pOyAvL3JldHVybiBzdHI7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZShzdHIsICdORkMnKTtcbn07XG4vKipcbiAqIEdlbmVyYXRlIGEgbGlzdCBvZiB1bmljb2RlIHZhcmlhbnRzIGZyb20gdGhlIGxpc3Qgb2YgY29kZSBwb2ludHNcbiAqIEBwYXJhbSB7VENvZGVQb2ludHN9IGNvZGVfcG9pbnRzXG4gKiBAeWllbGQge1RDb2RlUG9pbnRPYmp9XG4gKi9cblxuZnVuY3Rpb24qIGdlbmVyYXRvcihjb2RlX3BvaW50cykge1xuICBmb3IgKGNvbnN0IFtjb2RlX3BvaW50X21pbiwgY29kZV9wb2ludF9tYXhdIG9mIGNvZGVfcG9pbnRzKSB7XG4gICAgZm9yIChsZXQgaSA9IGNvZGVfcG9pbnRfbWluOyBpIDw9IGNvZGVfcG9pbnRfbWF4OyBpKyspIHtcbiAgICAgIGxldCBjb21wb3NlZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICBsZXQgZm9sZGVkID0gYXNjaWlmb2xkKGNvbXBvc2VkKTtcblxuICAgICAgaWYgKGZvbGRlZCA9PSBjb21wb3NlZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBza2lwIHdoZW4gZm9sZGVkIGlzIGEgc3RyaW5nIGxvbmdlciB0aGFuIDMgY2hhcmFjdGVycyBsb25nXG4gICAgICAvLyBiYyB0aGUgcmVzdWx0aW5nIHJlZ2V4IHBhdHRlcm5zIHdpbGwgYmUgbG9uZ1xuICAgICAgLy8gZWc6XG4gICAgICAvLyBmb2xkZWQgXHUwNjM1XHUwNjQ0XHUwNjQ5IFx1MDYyN1x1MDY0NFx1MDY0NFx1MDY0NyBcdTA2MzlcdTA2NDRcdTA2NEFcdTA2NDcgXHUwNjQ4XHUwNjMzXHUwNjQ0XHUwNjQ1IGxlbmd0aCAxOCBjb2RlIHBvaW50IDY1MDE4XG4gICAgICAvLyBmb2xkZWQgXHUwNjJDXHUwNjQ0IFx1MDYyQ1x1MDY0NFx1MDYyN1x1MDY0NFx1MDY0NyBsZW5ndGggOCBjb2RlIHBvaW50IDY1MDE5XG5cblxuICAgICAgaWYgKGZvbGRlZC5sZW5ndGggPiBtYXhfY2hhcl9sZW5ndGgpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb2xkZWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHlpZWxkIHtcbiAgICAgICAgZm9sZGVkOiBmb2xkZWQsXG4gICAgICAgIGNvbXBvc2VkOiBjb21wb3NlZCxcbiAgICAgICAgY29kZV9wb2ludDogaVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2VuZXJhdGUgYSB1bmljb2RlIG1hcCBmcm9tIHRoZSBsaXN0IG9mIGNvZGUgcG9pbnRzXG4gKiBAcGFyYW0ge1RDb2RlUG9pbnRzfSBjb2RlX3BvaW50c1xuICogQHJldHVybiB7VFVuaWNvZGVTZXRzfVxuICovXG5cbmNvbnN0IGdlbmVyYXRlU2V0cyA9IGNvZGVfcG9pbnRzID0+IHtcbiAgLyoqIEB0eXBlIHt7W2tleTpzdHJpbmddOlNldDxzdHJpbmc+fX0gKi9cbiAgY29uc3QgdW5pY29kZV9zZXRzID0ge307XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b19hZGRcbiAgICovXG5cbiAgY29uc3QgYWRkTWF0Y2hpbmcgPSAoZm9sZGVkLCB0b19hZGQpID0+IHtcbiAgICAvKiogQHR5cGUge1NldDxzdHJpbmc+fSAqL1xuICAgIGNvbnN0IGZvbGRlZF9zZXQgPSB1bmljb2RlX3NldHNbZm9sZGVkXSB8fCBuZXcgU2V0KCk7XG4gICAgY29uc3QgcGF0dCA9IG5ldyBSZWdFeHAoJ14nICsgc2V0VG9QYXR0ZXJuKGZvbGRlZF9zZXQpICsgJyQnLCAnaXUnKTtcblxuICAgIGlmICh0b19hZGQubWF0Y2gocGF0dCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb2xkZWRfc2V0LmFkZChlc2NhcGVfcmVnZXgodG9fYWRkKSk7XG4gICAgdW5pY29kZV9zZXRzW2ZvbGRlZF0gPSBmb2xkZWRfc2V0O1xuICB9O1xuXG4gIGZvciAobGV0IHZhbHVlIG9mIGdlbmVyYXRvcihjb2RlX3BvaW50cykpIHtcbiAgICBhZGRNYXRjaGluZyh2YWx1ZS5mb2xkZWQsIHZhbHVlLmZvbGRlZCk7XG4gICAgYWRkTWF0Y2hpbmcodmFsdWUuZm9sZGVkLCB2YWx1ZS5jb21wb3NlZCk7XG4gIH1cblxuICByZXR1cm4gdW5pY29kZV9zZXRzO1xufTtcbi8qKlxuICogR2VuZXJhdGUgYSB1bmljb2RlIG1hcCBmcm9tIHRoZSBsaXN0IG9mIGNvZGUgcG9pbnRzXG4gKiBhZSA9PiAoPzooPzphZXxcdTAwQzZ8XHUwMUZDfFx1MDFFMil8KD86QXxcdTI0QjZ8XHVGRjIxLi4uKSg/OkV8XHUwMjVCfFx1MjRCQS4uLikpXG4gKlxuICogQHBhcmFtIHtUQ29kZVBvaW50c30gY29kZV9wb2ludHNcbiAqIEByZXR1cm4ge1RVbmljb2RlTWFwfVxuICovXG5cbmNvbnN0IGdlbmVyYXRlTWFwID0gY29kZV9wb2ludHMgPT4ge1xuICAvKiogQHR5cGUge1RVbmljb2RlU2V0c30gKi9cbiAgY29uc3QgdW5pY29kZV9zZXRzID0gZ2VuZXJhdGVTZXRzKGNvZGVfcG9pbnRzKTtcbiAgLyoqIEB0eXBlIHtUVW5pY29kZU1hcH0gKi9cblxuICBjb25zdCB1bmljb2RlX21hcCA9IHt9O1xuICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuXG4gIGxldCBtdWx0aV9jaGFyID0gW107XG5cbiAgZm9yIChsZXQgZm9sZGVkIGluIHVuaWNvZGVfc2V0cykge1xuICAgIGxldCBzZXQgPSB1bmljb2RlX3NldHNbZm9sZGVkXTtcblxuICAgIGlmIChzZXQpIHtcbiAgICAgIHVuaWNvZGVfbWFwW2ZvbGRlZF0gPSBzZXRUb1BhdHRlcm4oc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoZm9sZGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgIG11bHRpX2NoYXIucHVzaChlc2NhcGVfcmVnZXgoZm9sZGVkKSk7XG4gICAgfVxuICB9XG5cbiAgbXVsdGlfY2hhci5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcbiAgY29uc3QgbXVsdGlfY2hhcl9wYXR0ID0gYXJyYXlUb1BhdHRlcm4obXVsdGlfY2hhcik7XG4gIG11bHRpX2NoYXJfcmVnID0gbmV3IFJlZ0V4cCgnXicgKyBtdWx0aV9jaGFyX3BhdHQsICd1Jyk7XG4gIHJldHVybiB1bmljb2RlX21hcDtcbn07XG4vKipcbiAqIE1hcCBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXkgZnJvbSBpdCdzIGZvbGRlZCB2YWx1ZSB0byBhbGwgcG9zc2libGUgdW5pY29kZSBtYXRjaGVzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzdHJpbmdzXG4gKiBAcGFyYW0ge251bWJlcn0gbWluX3JlcGxhY2VtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuY29uc3QgbWFwU2VxdWVuY2UgPSAoc3RyaW5ncywgbWluX3JlcGxhY2VtZW50ID0gMSkgPT4ge1xuICBsZXQgY2hhcnNfcmVwbGFjZWQgPSAwO1xuICBzdHJpbmdzID0gc3RyaW5ncy5tYXAoc3RyID0+IHtcbiAgICBpZiAodW5pY29kZV9tYXBbc3RyXSkge1xuICAgICAgY2hhcnNfcmVwbGFjZWQgKz0gc3RyLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pY29kZV9tYXBbc3RyXSB8fCBzdHI7XG4gIH0pO1xuXG4gIGlmIChjaGFyc19yZXBsYWNlZCA+PSBtaW5fcmVwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gc2VxdWVuY2VQYXR0ZXJuKHN0cmluZ3MpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcbi8qKlxuICogQ29udmVydCBhIHNob3J0IHN0cmluZyBhbmQgc3BsaXQgaXQgaW50byBhbGwgcG9zc2libGUgcGF0dGVybnNcbiAqIEtlZXAgYSBwYXR0ZXJuIG9ubHkgaWYgbWluX3JlcGxhY2VtZW50IGlzIG1ldFxuICpcbiAqICdhYmMnXG4gKiBcdFx0PT4gW1snYWJjJ10sWydhYicsJ2MnXSxbJ2EnLCdiYyddLFsnYScsJ2InLCdjJ11dXG4gKlx0XHQ9PiBbJ2FiYy1wYXR0ZXJuJywnYWItYy1wYXR0ZXJuJy4uLl1cbiAqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtudW1iZXJ9IG1pbl9yZXBsYWNlbWVudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmNvbnN0IHN1YnN0cmluZ3NUb1BhdHRlcm4gPSAoc3RyLCBtaW5fcmVwbGFjZW1lbnQgPSAxKSA9PiB7XG4gIG1pbl9yZXBsYWNlbWVudCA9IE1hdGgubWF4KG1pbl9yZXBsYWNlbWVudCwgc3RyLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gYXJyYXlUb1BhdHRlcm4oYWxsU3Vic3RyaW5ncyhzdHIpLm1hcChzdWJfcGF0ID0+IHtcbiAgICByZXR1cm4gbWFwU2VxdWVuY2Uoc3ViX3BhdCwgbWluX3JlcGxhY2VtZW50KTtcbiAgfSkpO1xufTtcbi8qKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBzZXF1ZW5jZXMgaW50byBhIHBhdHRlcm5cbiAqIFt7c3RhcnQ6MCxlbmQ6MyxsZW5ndGg6MyxzdWJzdHI6J2lpaSd9Li4uXSA9PiAoPzppaWkuLi4pXG4gKlxuICogQHBhcmFtIHtTZXF1ZW5jZVtdfSBzZXF1ZW5jZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsXG4gKi9cblxuY29uc3Qgc2VxdWVuY2VzVG9QYXR0ZXJuID0gKHNlcXVlbmNlcywgYWxsID0gdHJ1ZSkgPT4ge1xuICBsZXQgbWluX3JlcGxhY2VtZW50ID0gc2VxdWVuY2VzLmxlbmd0aCA+IDEgPyAxIDogMDtcbiAgcmV0dXJuIGFycmF5VG9QYXR0ZXJuKHNlcXVlbmNlcy5tYXAoc2VxdWVuY2UgPT4ge1xuICAgIGxldCBzZXEgPSBbXTtcbiAgICBjb25zdCBsZW4gPSBhbGwgPyBzZXF1ZW5jZS5sZW5ndGgoKSA6IHNlcXVlbmNlLmxlbmd0aCgpIC0gMTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHNlcS5wdXNoKHN1YnN0cmluZ3NUb1BhdHRlcm4oc2VxdWVuY2Uuc3Vic3Ryc1tqXSB8fCAnJywgbWluX3JlcGxhY2VtZW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcXVlbmNlUGF0dGVybihzZXEpO1xuICB9KSk7XG59O1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgc2VxdWVuY2UgaXMgYWxyZWFkeSBpbiB0aGUgc2VxdWVuY2VzXG4gKiBAcGFyYW0ge1NlcXVlbmNlfSBuZWVkbGVfc2VxXG4gKiBAcGFyYW0ge1NlcXVlbmNlW119IHNlcXVlbmNlc1xuICovXG5cblxuY29uc3QgaW5TZXF1ZW5jZXMgPSAobmVlZGxlX3NlcSwgc2VxdWVuY2VzKSA9PiB7XG4gIGZvciAoY29uc3Qgc2VxIG9mIHNlcXVlbmNlcykge1xuICAgIGlmIChzZXEuc3RhcnQgIT0gbmVlZGxlX3NlcS5zdGFydCB8fCBzZXEuZW5kICE9IG5lZWRsZV9zZXEuZW5kKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc2VxLnN1YnN0cnMuam9pbignJykgIT09IG5lZWRsZV9zZXEuc3Vic3Rycy5qb2luKCcnKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IG5lZWRsZV9wYXJ0cyA9IG5lZWRsZV9zZXEucGFydHM7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUU2VxdWVuY2VQYXJ0fSBwYXJ0XG4gICAgICovXG5cbiAgICBjb25zdCBmaWx0ZXIgPSBwYXJ0ID0+IHtcbiAgICAgIGZvciAoY29uc3QgbmVlZGxlX3BhcnQgb2YgbmVlZGxlX3BhcnRzKSB7XG4gICAgICAgIGlmIChuZWVkbGVfcGFydC5zdGFydCA9PT0gcGFydC5zdGFydCAmJiBuZWVkbGVfcGFydC5zdWJzdHIgPT09IHBhcnQuc3Vic3RyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09IDEgfHwgbmVlZGxlX3BhcnQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBjaGVjayBmb3Igb3ZlcmxhcHBpbmcgcGFydHNcbiAgICAgICAgLy8gYSA9IFsnOjo9JywnPT0nXVxuICAgICAgICAvLyBiID0gWyc6OicsJz09PSddXG4gICAgICAgIC8vIGEgPSBbJ3InLCdzbSddXG4gICAgICAgIC8vIGIgPSBbJ3JzJywnbSddXG5cblxuICAgICAgICBpZiAocGFydC5zdGFydCA8IG5lZWRsZV9wYXJ0LnN0YXJ0ICYmIHBhcnQuZW5kID4gbmVlZGxlX3BhcnQuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWVkbGVfcGFydC5zdGFydCA8IHBhcnQuc3RhcnQgJiYgbmVlZGxlX3BhcnQuZW5kID4gcGFydC5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgbGV0IGZpbHRlcmVkID0gc2VxLnBhcnRzLmZpbHRlcihmaWx0ZXIpO1xuXG4gICAgaWYgKGZpbHRlcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY2xhc3MgU2VxdWVuY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUge1RTZXF1ZW5jZVBhcnRbXX0gKi9cbiAgICB0aGlzLnBhcnRzID0gW107XG4gICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cblxuICAgIHRoaXMuc3Vic3RycyA9IFtdO1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuZW5kID0gMDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtUU2VxdWVuY2VQYXJ0fHVuZGVmaW5lZH0gcGFydFxuICAgKi9cblxuXG4gIGFkZChwYXJ0KSB7XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIHRoaXMucGFydHMucHVzaChwYXJ0KTtcbiAgICAgIHRoaXMuc3Vic3Rycy5wdXNoKHBhcnQuc3Vic3RyKTtcbiAgICAgIHRoaXMuc3RhcnQgPSBNYXRoLm1pbihwYXJ0LnN0YXJ0LCB0aGlzLnN0YXJ0KTtcbiAgICAgIHRoaXMuZW5kID0gTWF0aC5tYXgocGFydC5lbmQsIHRoaXMuZW5kKTtcbiAgICB9XG4gIH1cblxuICBsYXN0KCkge1xuICAgIHJldHVybiB0aGlzLnBhcnRzW3RoaXMucGFydHMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydHMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICogQHBhcmFtIHtUU2VxdWVuY2VQYXJ0fSBsYXN0X3BpZWNlXG4gICAqL1xuXG5cbiAgY2xvbmUocG9zaXRpb24sIGxhc3RfcGllY2UpIHtcbiAgICBsZXQgY2xvbmUgPSBuZXcgU2VxdWVuY2UoKTtcbiAgICBsZXQgcGFydHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGFydHMpKTtcbiAgICBsZXQgbGFzdF9wYXJ0ID0gcGFydHMucG9wKCk7XG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIGNsb25lLmFkZChwYXJ0KTtcbiAgICB9XG5cbiAgICBsZXQgbGFzdF9zdWJzdHIgPSBsYXN0X3BpZWNlLnN1YnN0ci5zdWJzdHJpbmcoMCwgcG9zaXRpb24gLSBsYXN0X3BhcnQuc3RhcnQpO1xuICAgIGxldCBjbG9uZV9sYXN0X2xlbiA9IGxhc3Rfc3Vic3RyLmxlbmd0aDtcbiAgICBjbG9uZS5hZGQoe1xuICAgICAgc3RhcnQ6IGxhc3RfcGFydC5zdGFydCxcbiAgICAgIGVuZDogbGFzdF9wYXJ0LnN0YXJ0ICsgY2xvbmVfbGFzdF9sZW4sXG4gICAgICBsZW5ndGg6IGNsb25lX2xhc3RfbGVuLFxuICAgICAgc3Vic3RyOiBsYXN0X3N1YnN0clxuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG59XG4vKipcbiAqIEV4cGFuZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHRvIGluY2x1ZGUgdW5pY29kZSB2YXJpYW50c1xuICogXHRlZyAvYS8gYmVjb21lcyAvYVx1MjREMFx1RkY0MVx1MUU5QVx1MDBFMFx1MDBFMVx1MDBFMlx1MUVBN1x1MUVBNVx1MUVBQlx1MUVBOVx1MDBFM1x1MDEwMVx1MDEwM1x1MUVCMVx1MUVBRlx1MUVCNVx1MUVCM1x1MDIyN1x1MDFFMVx1MDBFNFx1MDFERlx1MUVBM1x1MDBFNVx1MDFGQlx1MDFDRVx1MDIwMVx1MDIwM1x1MUVBMVx1MUVBRFx1MUVCN1x1MUUwMVx1MDEwNVx1MkM2NVx1MDI1MFx1MDI1MUFcdTI0QjZcdUZGMjFcdTAwQzBcdTAwQzFcdTAwQzJcdTFFQTZcdTFFQTRcdTFFQUFcdTFFQThcdTAwQzNcdTAxMDBcdTAxMDJcdTFFQjBcdTFFQUVcdTFFQjRcdTFFQjJcdTAyMjZcdTAxRTBcdTAwQzRcdTAxREVcdTFFQTJcdTAwQzVcdTAxRkFcdTAxQ0RcdTAyMDBcdTAyMDJcdTFFQTBcdTFFQUNcdTFFQjZcdTFFMDBcdTAxMDRcdTAyM0FcdTJDNkYvXG4gKlxuICogSXNzdWU6XG4gKiAgXHVGRThBXHVGRThCIFsgJ1x1RkU4QSA9IFxcXFx1e2ZlOGF9JywgJ1x1RkU4QiA9IFxcXFx1e2ZlOGJ9JyBdXG4gKlx0YmVjb21lczpcdFx1MDY0QVx1MDY1NFx1MDY0QVx1MDY1NCBbICdcdTA2NEEgPSBcXFxcdXs2NGF9JywgJ1x1MDY1NCA9IFxcXFx1ezY1NH0nLCAnXHUwNjRBID0gXFxcXHV7NjRhfScsICdcdTA2NTQgPSBcXFxcdXs2NTR9JyBdXG4gKlxuICpcdFx1MDEzMFx1MDEzMiA9IElJSiA9IFx1MjE2MUpcbiAqXG4gKiBcdDEvMi80XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuXG5cbmNvbnN0IGdldFBhdHRlcm4gPSBzdHIgPT4ge1xuICBpbml0aWFsaXplKCk7XG4gIHN0ciA9IGFzY2lpZm9sZChzdHIpO1xuICBsZXQgcGF0dGVybiA9ICcnO1xuICBsZXQgc2VxdWVuY2VzID0gW25ldyBTZXF1ZW5jZSgpXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGxldCBzdWJzdHIgPSBzdHIuc3Vic3RyaW5nKGkpO1xuICAgIGxldCBtYXRjaCA9IHN1YnN0ci5tYXRjaChtdWx0aV9jaGFyX3JlZyk7XG4gICAgY29uc3QgY2hhciA9IHN0ci5zdWJzdHJpbmcoaSwgaSArIDEpO1xuICAgIGNvbnN0IG1hdGNoX3N0ciA9IG1hdGNoID8gbWF0Y2hbMF0gOiBudWxsOyAvLyBsb29wIHRocm91Z2ggc2VxdWVuY2VzXG4gICAgLy8gYWRkIGVpdGhlciB0aGUgY2hhciBvciBtdWx0aV9tYXRjaFxuXG4gICAgbGV0IG92ZXJsYXBwaW5nID0gW107XG4gICAgbGV0IGFkZGVkX3R5cGVzID0gbmV3IFNldCgpO1xuXG4gICAgZm9yIChjb25zdCBzZXF1ZW5jZSBvZiBzZXF1ZW5jZXMpIHtcbiAgICAgIGNvbnN0IGxhc3RfcGllY2UgPSBzZXF1ZW5jZS5sYXN0KCk7XG5cbiAgICAgIGlmICghbGFzdF9waWVjZSB8fCBsYXN0X3BpZWNlLmxlbmd0aCA9PSAxIHx8IGxhc3RfcGllY2UuZW5kIDw9IGkpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG11bHRpIG1hdGNoXG4gICAgICAgIGlmIChtYXRjaF9zdHIpIHtcbiAgICAgICAgICBjb25zdCBsZW4gPSBtYXRjaF9zdHIubGVuZ3RoO1xuICAgICAgICAgIHNlcXVlbmNlLmFkZCh7XG4gICAgICAgICAgICBzdGFydDogaSxcbiAgICAgICAgICAgIGVuZDogaSArIGxlbixcbiAgICAgICAgICAgIGxlbmd0aDogbGVuLFxuICAgICAgICAgICAgc3Vic3RyOiBtYXRjaF9zdHJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhZGRlZF90eXBlcy5hZGQoJzEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXF1ZW5jZS5hZGQoe1xuICAgICAgICAgICAgc3RhcnQ6IGksXG4gICAgICAgICAgICBlbmQ6IGkgKyAxLFxuICAgICAgICAgICAgbGVuZ3RoOiAxLFxuICAgICAgICAgICAgc3Vic3RyOiBjaGFyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkZWRfdHlwZXMuYWRkKCcyJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hfc3RyKSB7XG4gICAgICAgIGxldCBjbG9uZSA9IHNlcXVlbmNlLmNsb25lKGksIGxhc3RfcGllY2UpO1xuICAgICAgICBjb25zdCBsZW4gPSBtYXRjaF9zdHIubGVuZ3RoO1xuICAgICAgICBjbG9uZS5hZGQoe1xuICAgICAgICAgIHN0YXJ0OiBpLFxuICAgICAgICAgIGVuZDogaSArIGxlbixcbiAgICAgICAgICBsZW5ndGg6IGxlbixcbiAgICAgICAgICBzdWJzdHI6IG1hdGNoX3N0clxuICAgICAgICB9KTtcbiAgICAgICAgb3ZlcmxhcHBpbmcucHVzaChjbG9uZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb24ndCBhZGQgY2hhclxuICAgICAgICAvLyBhZGRpbmcgd291bGQgY3JlYXRlIGludmFsaWQgcGF0dGVybnM6IDIzNCA9PiBbMiwzNCw0XVxuICAgICAgICBhZGRlZF90eXBlcy5hZGQoJzMnKTtcbiAgICAgIH1cbiAgICB9IC8vIGlmIHdlIGhhdmUgb3ZlcmxhcHBpbmdcblxuXG4gICAgaWYgKG92ZXJsYXBwaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFsnaWknLCdpaWknXSBiZWZvcmUgWydpJywnaScsJ2lpaSddXG4gICAgICBvdmVybGFwcGluZyA9IG92ZXJsYXBwaW5nLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoKCkgLSBiLmxlbmd0aCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAobGV0IGNsb25lIG9mIG92ZXJsYXBwaW5nKSB7XG4gICAgICAgIC8vIGRvbid0IGFkZCBpZiB3ZSBhbHJlYWR5IGhhdmUgYW4gZXF1aXZhbGVudCBzZXF1ZW5jZVxuICAgICAgICBpZiAoaW5TZXF1ZW5jZXMoY2xvbmUsIHNlcXVlbmNlcykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcXVlbmNlcy5wdXNoKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfSAvLyBpZiB3ZSBoYXZlbid0IGRvbmUgYW55dGhpbmcgdW5pcXVlXG4gICAgLy8gY2xlYW4gdXAgdGhlIHBhdHRlcm5zXG4gICAgLy8gaGVscHMga2VlcCBwYXR0ZXJucyBzbWFsbGVyXG4gICAgLy8gaWYgc3RyID0gJ3JcdTIwQThcdTMzQTdhYXJzcycsIHBhdHRlcm4gd2lsbCBiZSA0NDYgaW5zdGVhZCBvZiA2NTVcblxuXG4gICAgaWYgKGkgPiAwICYmIGFkZGVkX3R5cGVzLnNpemUgPT0gMSAmJiAhYWRkZWRfdHlwZXMuaGFzKCczJykpIHtcbiAgICAgIHBhdHRlcm4gKz0gc2VxdWVuY2VzVG9QYXR0ZXJuKHNlcXVlbmNlcywgZmFsc2UpO1xuICAgICAgbGV0IG5ld19zZXEgPSBuZXcgU2VxdWVuY2UoKTtcbiAgICAgIGNvbnN0IG9sZF9zZXEgPSBzZXF1ZW5jZXNbMF07XG5cbiAgICAgIGlmIChvbGRfc2VxKSB7XG4gICAgICAgIG5ld19zZXEuYWRkKG9sZF9zZXEubGFzdCgpKTtcbiAgICAgIH1cblxuICAgICAgc2VxdWVuY2VzID0gW25ld19zZXFdO1xuICAgIH1cbiAgfVxuXG4gIHBhdHRlcm4gKz0gc2VxdWVuY2VzVG9QYXR0ZXJuKHNlcXVlbmNlcywgdHJ1ZSk7XG4gIHJldHVybiBwYXR0ZXJuO1xufTtcblxuZXhwb3J0IHsgX2FzY2lpZm9sZCwgYXNjaWlmb2xkLCBjb2RlX3BvaW50cywgZ2VuZXJhdGVNYXAsIGdlbmVyYXRlU2V0cywgZ2VuZXJhdG9yLCBnZXRQYXR0ZXJuLCBpbml0aWFsaXplLCBtYXBTZXF1ZW5jZSwgbm9ybWFsaXplLCBzdWJzdHJpbmdzVG9QYXR0ZXJuLCB1bmljb2RlX21hcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCAiLyohIHNpZnRlci5qcyB8IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmNoaWRqcy9zaWZ0ZXIuanMgfCBBcGFjaGUgTGljZW5zZSAodjIpICovXG5pbXBvcnQgeyBhc2NpaWZvbGQgfSBmcm9tICdAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyc7XG5cbi8qKlxuICogQSBwcm9wZXJ0eSBnZXR0ZXIgcmVzb2x2aW5nIGRvdC1ub3RhdGlvblxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqICAgICBUaGUgcm9vdCBvYmplY3QgdG8gZmV0Y2ggcHJvcGVydHkgb25cbiAqIEBwYXJhbSAge1N0cmluZ30gIG5hbWUgICAgVGhlIG9wdGlvbmFsbHkgZG90dGVkIHByb3BlcnR5IG5hbWUgdG8gZmV0Y2hcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgVGhlIHJlc29sdmVkIHByb3BlcnR5IHZhbHVlXG4gKi9cbmNvbnN0IGdldEF0dHIgPSAob2JqLCBuYW1lKSA9PiB7XG4gIGlmICghb2JqKSByZXR1cm47XG4gIHJldHVybiBvYmpbbmFtZV07XG59O1xuLyoqXG4gKiBBIHByb3BlcnR5IGdldHRlciByZXNvbHZpbmcgZG90LW5vdGF0aW9uXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogICAgIFRoZSByb290IG9iamVjdCB0byBmZXRjaCBwcm9wZXJ0eSBvblxuICogQHBhcmFtICB7U3RyaW5nfSAgbmFtZSAgICBUaGUgb3B0aW9uYWxseSBkb3R0ZWQgcHJvcGVydHkgbmFtZSB0byBmZXRjaFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICBUaGUgcmVzb2x2ZWQgcHJvcGVydHkgdmFsdWVcbiAqL1xuXG5jb25zdCBnZXRBdHRyTmVzdGluZyA9IChvYmosIG5hbWUpID0+IHtcbiAgaWYgKCFvYmopIHJldHVybjtcbiAgdmFyIHBhcnQsXG4gICAgICBuYW1lcyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuXG4gIHdoaWxlICgocGFydCA9IG5hbWVzLnNoaWZ0KCkpICYmIChvYmogPSBvYmpbcGFydF0pKTtcblxuICByZXR1cm4gb2JqO1xufTtcbi8qKlxuICogQ2FsY3VsYXRlcyBob3cgY2xvc2Ugb2YgYSBtYXRjaCB0aGVcbiAqIGdpdmVuIHZhbHVlIGlzIGFnYWluc3QgYSBzZWFyY2ggdG9rZW4uXG4gKlxuICovXG5cbmNvbnN0IHNjb3JlVmFsdWUgPSAodmFsdWUsIHRva2VuLCB3ZWlnaHQpID0+IHtcbiAgdmFyIHNjb3JlLCBwb3M7XG4gIGlmICghdmFsdWUpIHJldHVybiAwO1xuICB2YWx1ZSA9IHZhbHVlICsgJyc7XG4gIGlmICh0b2tlbi5yZWdleCA9PSBudWxsKSByZXR1cm4gMDtcbiAgcG9zID0gdmFsdWUuc2VhcmNoKHRva2VuLnJlZ2V4KTtcbiAgaWYgKHBvcyA9PT0gLTEpIHJldHVybiAwO1xuICBzY29yZSA9IHRva2VuLnN0cmluZy5sZW5ndGggLyB2YWx1ZS5sZW5ndGg7XG4gIGlmIChwb3MgPT09IDApIHNjb3JlICs9IDAuNTtcbiAgcmV0dXJuIHNjb3JlICogd2VpZ2h0O1xufTtcbi8qKlxuICogQ2FzdCBvYmplY3QgcHJvcGVydHkgdG8gYW4gYXJyYXkgaWYgaXQgZXhpc3RzIGFuZCBoYXMgYSB2YWx1ZVxuICpcbiAqL1xuXG5jb25zdCBwcm9wVG9BcnJheSA9IChvYmosIGtleSkgPT4ge1xuICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSByZXR1cm4gdmFsdWU7XG5cbiAgaWYgKHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIG9ialtrZXldID0gW3ZhbHVlXTtcbiAgfVxufTtcbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBhcnJheXMgYW5kIGhhc2hlcy5cbiAqXG4gKiBgYGBcbiAqIGl0ZXJhdGUodGhpcy5pdGVtcywgZnVuY3Rpb24oaXRlbSwgaWQpIHtcbiAqICAgIC8vIGludm9rZWQgZm9yIGVhY2ggaXRlbVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cblxuY29uc3QgaXRlcmF0ZSA9IChvYmplY3QsIGNhbGxiYWNrKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICBvYmplY3QuZm9yRWFjaChjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmNvbnN0IGNtcCA9IChhLCBiKSA9PiB7XG4gIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICB9XG5cbiAgYSA9IGFzY2lpZm9sZChhICsgJycpLnRvTG93ZXJDYXNlKCk7XG4gIGIgPSBhc2NpaWZvbGQoYiArICcnKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICBpZiAoYiA+IGEpIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59O1xuXG5leHBvcnQgeyBjbXAsIGdldEF0dHIsIGdldEF0dHJOZXN0aW5nLCBpdGVyYXRlLCBwcm9wVG9BcnJheSwgc2NvcmVWYWx1ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG4iLCAiLyohIHNpZnRlci5qcyB8IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmNoaWRqcy9zaWZ0ZXIuanMgfCBBcGFjaGUgTGljZW5zZSAodjIpICovXG5pbXBvcnQgeyBpdGVyYXRlLCBjbXAsIHByb3BUb0FycmF5LCBnZXRBdHRyTmVzdGluZywgZ2V0QXR0ciwgc2NvcmVWYWx1ZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0IHsgY21wLCBnZXRBdHRyLCBnZXRBdHRyTmVzdGluZywgaXRlcmF0ZSwgcHJvcFRvQXJyYXksIHNjb3JlVmFsdWUgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVzY2FwZV9yZWdleCwgZ2V0UGF0dGVybiB9IGZyb20gJ0BvcmNoaWRqcy91bmljb2RlLXZhcmlhbnRzJztcbmV4cG9ydCB7IGdldFBhdHRlcm4gfSBmcm9tICdAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyc7XG5cbi8qKlxuICogc2lmdGVyLmpzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTNcdTIwMTMyMDIwIEJyaWFuIFJlYXZpcyAmIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAYXV0aG9yIEJyaWFuIFJlYXZpcyA8YnJpYW5AdGhpcmRyb3V0ZS5jb20+XG4gKi9cblxuY2xhc3MgU2lmdGVyIHtcbiAgLy8gW118e307XG5cbiAgLyoqXG4gICAqIFRleHR1YWxseSBzZWFyY2hlcyBhcnJheXMgYW5kIGhhc2hlcyBvZiBvYmplY3RzXG4gICAqIGJ5IHByb3BlcnR5IChvciBtdWx0aXBsZSBwcm9wZXJ0aWVzKS4gRGVzaWduZWRcbiAgICogc3BlY2lmaWNhbGx5IGZvciBhdXRvY29tcGxldGUuXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpdGVtcywgc2V0dGluZ3MpIHtcbiAgICB0aGlzLml0ZW1zID0gdm9pZCAwO1xuICAgIHRoaXMuc2V0dGluZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7XG4gICAgICBkaWFjcml0aWNzOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYSBzZWFyY2ggc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgaW5kaXZpZHVhbFxuICAgKiByZWdleHBzIHRvIGJlIHVzZWQgdG8gbWF0Y2ggcmVzdWx0cy5cbiAgICpcbiAgICovXG4gIHRva2VuaXplKHF1ZXJ5LCByZXNwZWN0X3dvcmRfYm91bmRhcmllcywgd2VpZ2h0cykge1xuICAgIGlmICghcXVlcnkgfHwgIXF1ZXJ5Lmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGNvbnN0IHdvcmRzID0gcXVlcnkuc3BsaXQoL1xccysvKTtcbiAgICB2YXIgZmllbGRfcmVnZXg7XG5cbiAgICBpZiAod2VpZ2h0cykge1xuICAgICAgZmllbGRfcmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBPYmplY3Qua2V5cyh3ZWlnaHRzKS5tYXAoZXNjYXBlX3JlZ2V4KS5qb2luKCd8JykgKyAnKVxcOiguKikkJyk7XG4gICAgfVxuXG4gICAgd29yZHMuZm9yRWFjaCh3b3JkID0+IHtcbiAgICAgIGxldCBmaWVsZF9tYXRjaDtcbiAgICAgIGxldCBmaWVsZCA9IG51bGw7XG4gICAgICBsZXQgcmVnZXggPSBudWxsOyAvLyBsb29rIGZvciBcImZpZWxkOnF1ZXJ5XCIgdG9rZW5zXG5cbiAgICAgIGlmIChmaWVsZF9yZWdleCAmJiAoZmllbGRfbWF0Y2ggPSB3b3JkLm1hdGNoKGZpZWxkX3JlZ2V4KSkpIHtcbiAgICAgICAgZmllbGQgPSBmaWVsZF9tYXRjaFsxXTtcbiAgICAgICAgd29yZCA9IGZpZWxkX21hdGNoWzJdO1xuICAgICAgfVxuXG4gICAgICBpZiAod29yZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRpYWNyaXRpY3MpIHtcbiAgICAgICAgICByZWdleCA9IGdldFBhdHRlcm4od29yZCkgfHwgbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWdleCA9IGVzY2FwZV9yZWdleCh3b3JkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWdleCAmJiByZXNwZWN0X3dvcmRfYm91bmRhcmllcykgcmVnZXggPSBcIlxcXFxiXCIgKyByZWdleDtcbiAgICAgIH1cblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICBzdHJpbmc6IHdvcmQsXG4gICAgICAgIHJlZ2V4OiByZWdleCA/IG5ldyBSZWdFeHAocmVnZXgsICdpdScpIDogbnVsbCxcbiAgICAgICAgZmllbGQ6IGZpZWxkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIHRvIHNjb3JlIGluZGl2aWR1YWwgcmVzdWx0cy5cbiAgICpcbiAgICogR29vZCBtYXRjaGVzIHdpbGwgaGF2ZSBhIGhpZ2hlciBzY29yZSB0aGFuIHBvb3IgbWF0Y2hlcy5cbiAgICogSWYgYW4gaXRlbSBpcyBub3QgYSBtYXRjaCwgMCB3aWxsIGJlIHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge1QuU2NvcmVGbn1cbiAgICovXG4gIGdldFNjb3JlRnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VhcmNoID0gdGhpcy5wcmVwYXJlU2VhcmNoKHF1ZXJ5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2NvcmVGdW5jdGlvbihzZWFyY2gpO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7VC5TY29yZUZufVxuICAgKlxuICAgKi9cblxuXG4gIF9nZXRTY29yZUZ1bmN0aW9uKHNlYXJjaCkge1xuICAgIGNvbnN0IHRva2VucyA9IHNlYXJjaC50b2tlbnMsXG4gICAgICAgICAgdG9rZW5fY291bnQgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgaWYgKCF0b2tlbl9jb3VudCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkcyA9IHNlYXJjaC5vcHRpb25zLmZpZWxkcyxcbiAgICAgICAgICB3ZWlnaHRzID0gc2VhcmNoLndlaWdodHMsXG4gICAgICAgICAgZmllbGRfY291bnQgPSBmaWVsZHMubGVuZ3RoLFxuICAgICAgICAgIGdldEF0dHJGbiA9IHNlYXJjaC5nZXRBdHRyRm47XG5cbiAgICBpZiAoIWZpZWxkX2NvdW50KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNjb3JlIG9mIGFuIG9iamVjdFxuICAgICAqIGFnYWluc3QgdGhlIHNlYXJjaCBxdWVyeS5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBjb25zdCBzY29yZU9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChmaWVsZF9jb3VudCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRva2VuLCBkYXRhKSB7XG4gICAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNbMF0uZmllbGQ7XG4gICAgICAgICAgcmV0dXJuIHNjb3JlVmFsdWUoZ2V0QXR0ckZuKGRhdGEsIGZpZWxkKSwgdG9rZW4sIHdlaWdodHNbZmllbGRdIHx8IDEpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRva2VuLCBkYXRhKSB7XG4gICAgICAgIHZhciBzdW0gPSAwOyAvLyBpcyB0aGUgdG9rZW4gc3BlY2lmaWMgdG8gYSBmaWVsZD9cblxuICAgICAgICBpZiAodG9rZW4uZmllbGQpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEF0dHJGbihkYXRhLCB0b2tlbi5maWVsZCk7XG5cbiAgICAgICAgICBpZiAoIXRva2VuLnJlZ2V4ICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBzdW0gKz0gMSAvIGZpZWxkX2NvdW50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdW0gKz0gc2NvcmVWYWx1ZSh2YWx1ZSwgdG9rZW4sIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRlKHdlaWdodHMsICh3ZWlnaHQsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBzdW0gKz0gc2NvcmVWYWx1ZShnZXRBdHRyRm4oZGF0YSwgZmllbGQpLCB0b2tlbiwgd2VpZ2h0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW0gLyBmaWVsZF9jb3VudDtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgaWYgKHRva2VuX2NvdW50ID09PSAxKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHNjb3JlT2JqZWN0KHRva2Vuc1swXSwgZGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChzZWFyY2gub3B0aW9ucy5jb25qdW5jdGlvbiA9PT0gJ2FuZCcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc2NvcmUsXG4gICAgICAgICAgICBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgIHNjb3JlID0gc2NvcmVPYmplY3QodG9rZW4sIGRhdGEpO1xuICAgICAgICAgIGlmIChzY29yZSA8PSAwKSByZXR1cm4gMDtcbiAgICAgICAgICBzdW0gKz0gc2NvcmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtIC8gdG9rZW5fY291bnQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGl0ZXJhdGUodG9rZW5zLCB0b2tlbiA9PiB7XG4gICAgICAgICAgc3VtICs9IHNjb3JlT2JqZWN0KHRva2VuLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdW0gLyB0b2tlbl9jb3VudDtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXBhcmUgdHdvXG4gICAqIHJlc3VsdHMsIGZvciBzb3J0aW5nIHB1cnBvc2VzLiBJZiBubyBzb3J0aW5nIHNob3VsZFxuICAgKiBiZSBwZXJmb3JtZWQsIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIGZ1bmN0aW9uKGEsYilcbiAgICovXG4gIGdldFNvcnRGdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuICAgIHZhciBzZWFyY2ggPSB0aGlzLnByZXBhcmVTZWFyY2gocXVlcnksIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0RnVuY3Rpb24oc2VhcmNoKTtcbiAgfVxuXG4gIF9nZXRTb3J0RnVuY3Rpb24oc2VhcmNoKSB7XG4gICAgdmFyIGltcGxpY2l0X3Njb3JlLFxuICAgICAgICBzb3J0X2ZsZHMgPSBbXTtcbiAgICBjb25zdCBzZWxmID0gdGhpcyxcbiAgICAgICAgICBvcHRpb25zID0gc2VhcmNoLm9wdGlvbnMsXG4gICAgICAgICAgc29ydCA9ICFzZWFyY2gucXVlcnkgJiYgb3B0aW9ucy5zb3J0X2VtcHR5ID8gb3B0aW9ucy5zb3J0X2VtcHR5IDogb3B0aW9ucy5zb3J0O1xuXG4gICAgaWYgKHR5cGVvZiBzb3J0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBzb3J0LmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIHNwZWNpZmllZCBzb3J0IGZpZWxkIHZhbHVlXG4gICAgICogZnJvbSBhIHNlYXJjaCByZXN1bHQgaXRlbS5cbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBjb25zdCBnZXRfZmllbGQgPSBmdW5jdGlvbiBnZXRfZmllbGQobmFtZSwgcmVzdWx0KSB7XG4gICAgICBpZiAobmFtZSA9PT0gJyRzY29yZScpIHJldHVybiByZXN1bHQuc2NvcmU7XG4gICAgICByZXR1cm4gc2VhcmNoLmdldEF0dHJGbihzZWxmLml0ZW1zW3Jlc3VsdC5pZF0sIG5hbWUpO1xuICAgIH07IC8vIHBhcnNlIG9wdGlvbnNcblxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgIGZvciAobGV0IHMgb2Ygc29ydCkge1xuICAgICAgICBpZiAoc2VhcmNoLnF1ZXJ5IHx8IHMuZmllbGQgIT09ICckc2NvcmUnKSB7XG4gICAgICAgICAgc29ydF9mbGRzLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHRoZSBcIiRzY29yZVwiIGZpZWxkIGlzIGltcGxpZWQgdG8gYmUgdGhlIHByaW1hcnlcbiAgICAvLyBzb3J0IGZpZWxkLCB1bmxlc3MgaXQncyBtYW51YWxseSBzcGVjaWZpZWRcblxuXG4gICAgaWYgKHNlYXJjaC5xdWVyeSkge1xuICAgICAgaW1wbGljaXRfc2NvcmUgPSB0cnVlO1xuXG4gICAgICBmb3IgKGxldCBmbGQgb2Ygc29ydF9mbGRzKSB7XG4gICAgICAgIGlmIChmbGQuZmllbGQgPT09ICckc2NvcmUnKSB7XG4gICAgICAgICAgaW1wbGljaXRfc2NvcmUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW1wbGljaXRfc2NvcmUpIHtcbiAgICAgICAgc29ydF9mbGRzLnVuc2hpZnQoe1xuICAgICAgICAgIGZpZWxkOiAnJHNjb3JlJyxcbiAgICAgICAgICBkaXJlY3Rpb246ICdkZXNjJ1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gd2l0aG91dCBhIHNlYXJjaC5xdWVyeSwgYWxsIGl0ZW1zIHdpbGwgaGF2ZSB0aGUgc2FtZSBzY29yZVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNvcnRfZmxkcyA9IHNvcnRfZmxkcy5maWx0ZXIoZmxkID0+IGZsZC5maWVsZCAhPT0gJyRzY29yZScpO1xuICAgIH0gLy8gYnVpbGQgZnVuY3Rpb25cblxuXG4gICAgY29uc3Qgc29ydF9mbGRzX2NvdW50ID0gc29ydF9mbGRzLmxlbmd0aDtcblxuICAgIGlmICghc29ydF9mbGRzX2NvdW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciByZXN1bHQsIGZpZWxkO1xuXG4gICAgICBmb3IgKGxldCBzb3J0X2ZsZCBvZiBzb3J0X2ZsZHMpIHtcbiAgICAgICAgZmllbGQgPSBzb3J0X2ZsZC5maWVsZDtcbiAgICAgICAgbGV0IG11bHRpcGxpZXIgPSBzb3J0X2ZsZC5kaXJlY3Rpb24gPT09ICdkZXNjJyA/IC0xIDogMTtcbiAgICAgICAgcmVzdWx0ID0gbXVsdGlwbGllciAqIGNtcChnZXRfZmllbGQoZmllbGQsIGEpLCBnZXRfZmllbGQoZmllbGQsIGIpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBzZWFyY2ggcXVlcnkgYW5kIHJldHVybnMgYW4gb2JqZWN0XG4gICAqIHdpdGggdG9rZW5zIGFuZCBmaWVsZHMgcmVhZHkgdG8gYmUgcG9wdWxhdGVkXG4gICAqIHdpdGggcmVzdWx0cy5cbiAgICpcbiAgICovXG4gIHByZXBhcmVTZWFyY2gocXVlcnksIG9wdHNVc2VyKSB7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IHt9O1xuICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0c1VzZXIpO1xuICAgIHByb3BUb0FycmF5KG9wdGlvbnMsICdzb3J0Jyk7XG4gICAgcHJvcFRvQXJyYXkob3B0aW9ucywgJ3NvcnRfZW1wdHknKTsgLy8gY29udmVydCBmaWVsZHMgdG8gbmV3IGZvcm1hdFxuXG4gICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBwcm9wVG9BcnJheShvcHRpb25zLCAnZmllbGRzJyk7XG4gICAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICAgIG9wdGlvbnMuZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZmllbGQgPSB7XG4gICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICB3ZWlnaHQ6IDFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICB3ZWlnaHRzW2ZpZWxkLmZpZWxkXSA9ICd3ZWlnaHQnIGluIGZpZWxkID8gZmllbGQud2VpZ2h0IDogMTtcbiAgICAgIH0pO1xuICAgICAgb3B0aW9ucy5maWVsZHMgPSBmaWVsZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBxdWVyeTogcXVlcnkudG9Mb3dlckNhc2UoKS50cmltKCksXG4gICAgICB0b2tlbnM6IHRoaXMudG9rZW5pemUocXVlcnksIG9wdGlvbnMucmVzcGVjdF93b3JkX2JvdW5kYXJpZXMsIHdlaWdodHMpLFxuICAgICAgdG90YWw6IDAsXG4gICAgICBpdGVtczogW10sXG4gICAgICB3ZWlnaHRzOiB3ZWlnaHRzLFxuICAgICAgZ2V0QXR0ckZuOiBvcHRpb25zLm5lc3RpbmcgPyBnZXRBdHRyTmVzdGluZyA6IGdldEF0dHJcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIHRocm91Z2ggYWxsIGl0ZW1zIGFuZCByZXR1cm5zIGEgc29ydGVkIGFycmF5IG9mIG1hdGNoZXMuXG4gICAqXG4gICAqL1xuICBzZWFyY2gocXVlcnksIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHNjb3JlLFxuICAgICAgICBzZWFyY2g7XG4gICAgc2VhcmNoID0gdGhpcy5wcmVwYXJlU2VhcmNoKHF1ZXJ5LCBvcHRpb25zKTtcbiAgICBvcHRpb25zID0gc2VhcmNoLm9wdGlvbnM7XG4gICAgcXVlcnkgPSBzZWFyY2gucXVlcnk7IC8vIGdlbmVyYXRlIHJlc3VsdCBzY29yaW5nIGZ1bmN0aW9uXG5cbiAgICBjb25zdCBmbl9zY29yZSA9IG9wdGlvbnMuc2NvcmUgfHwgc2VsZi5fZ2V0U2NvcmVGdW5jdGlvbihzZWFyY2gpOyAvLyBwZXJmb3JtIHNlYXJjaCBhbmQgc29ydFxuXG5cbiAgICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgICBpdGVyYXRlKHNlbGYuaXRlbXMsIChpdGVtLCBpZCkgPT4ge1xuICAgICAgICBzY29yZSA9IGZuX3Njb3JlKGl0ZW0pO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmZpbHRlciA9PT0gZmFsc2UgfHwgc2NvcmUgPiAwKSB7XG4gICAgICAgICAgc2VhcmNoLml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgJ3Njb3JlJzogc2NvcmUsXG4gICAgICAgICAgICAnaWQnOiBpZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZShzZWxmLml0ZW1zLCAoXywgaWQpID0+IHtcbiAgICAgICAgc2VhcmNoLml0ZW1zLnB1c2goe1xuICAgICAgICAgICdzY29yZSc6IDEsXG4gICAgICAgICAgJ2lkJzogaWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBmbl9zb3J0ID0gc2VsZi5fZ2V0U29ydEZ1bmN0aW9uKHNlYXJjaCk7XG5cbiAgICBpZiAoZm5fc29ydCkgc2VhcmNoLml0ZW1zLnNvcnQoZm5fc29ydCk7IC8vIGFwcGx5IGxpbWl0c1xuXG4gICAgc2VhcmNoLnRvdGFsID0gc2VhcmNoLml0ZW1zLmxlbmd0aDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5saW1pdCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHNlYXJjaC5pdGVtcyA9IHNlYXJjaC5pdGVtcy5zbGljZSgwLCBvcHRpb25zLmxpbWl0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VhcmNoO1xuICB9XG5cbn1cblxuZXhwb3J0IHsgU2lmdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWZ0ZXIuanMubWFwXG4iLCAiXG5pbXBvcnQgeyBhc2NpaWZvbGQgfSBmcm9tICdAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyc7XG5pbXBvcnQgKiBhcyBUIGZyb20gJy4vdHlwZXMnO1xuXG5cbi8qKlxuICogQSBwcm9wZXJ0eSBnZXR0ZXIgcmVzb2x2aW5nIGRvdC1ub3RhdGlvblxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqICAgICBUaGUgcm9vdCBvYmplY3QgdG8gZmV0Y2ggcHJvcGVydHkgb25cbiAqIEBwYXJhbSAge1N0cmluZ30gIG5hbWUgICAgVGhlIG9wdGlvbmFsbHkgZG90dGVkIHByb3BlcnR5IG5hbWUgdG8gZmV0Y2hcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgVGhlIHJlc29sdmVkIHByb3BlcnR5IHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBdHRyID0gKG9iajp7W2tleTpzdHJpbmddOmFueX0sIG5hbWU6c3RyaW5nICkgPT4ge1xuICAgIGlmICghb2JqICkgcmV0dXJuO1xuICAgIHJldHVybiBvYmpbbmFtZV07XG59O1xuXG4vKipcbiAqIEEgcHJvcGVydHkgZ2V0dGVyIHJlc29sdmluZyBkb3Qtbm90YXRpb25cbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiAgICAgVGhlIHJvb3Qgb2JqZWN0IHRvIGZldGNoIHByb3BlcnR5IG9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgIFRoZSBvcHRpb25hbGx5IGRvdHRlZCBwcm9wZXJ0eSBuYW1lIHRvIGZldGNoXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIFRoZSByZXNvbHZlZCBwcm9wZXJ0eSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0QXR0ck5lc3RpbmcgPSAob2JqOntba2V5OnN0cmluZ106YW55fSwgbmFtZTpzdHJpbmcgKSA9PiB7XG4gICAgaWYgKCFvYmogKSByZXR1cm47XG4gICAgdmFyIHBhcnQsIG5hbWVzID0gbmFtZS5zcGxpdChcIi5cIik7XG5cdHdoaWxlKCAocGFydCA9IG5hbWVzLnNoaWZ0KCkpICYmIChvYmogPSBvYmpbcGFydF0pKTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGhvdyBjbG9zZSBvZiBhIG1hdGNoIHRoZVxuICogZ2l2ZW4gdmFsdWUgaXMgYWdhaW5zdCBhIHNlYXJjaCB0b2tlbi5cbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBzY29yZVZhbHVlID0gKHZhbHVlOnN0cmluZywgdG9rZW46VC5Ub2tlbiwgd2VpZ2h0Om51bWJlciApOm51bWJlciA9PiB7XG5cdHZhciBzY29yZSwgcG9zO1xuXG5cdGlmICghdmFsdWUpIHJldHVybiAwO1xuXG5cdHZhbHVlID0gdmFsdWUgKyAnJztcblx0aWYoIHRva2VuLnJlZ2V4ID09IG51bGwgKSByZXR1cm4gMDtcblx0cG9zID0gdmFsdWUuc2VhcmNoKHRva2VuLnJlZ2V4KTtcblx0aWYgKHBvcyA9PT0gLTEpIHJldHVybiAwO1xuXG5cdHNjb3JlID0gdG9rZW4uc3RyaW5nLmxlbmd0aCAvIHZhbHVlLmxlbmd0aDtcblx0aWYgKHBvcyA9PT0gMCkgc2NvcmUgKz0gMC41O1xuXG5cdHJldHVybiBzY29yZSAqIHdlaWdodDtcbn07XG5cblxuLyoqXG4gKiBDYXN0IG9iamVjdCBwcm9wZXJ0eSB0byBhbiBhcnJheSBpZiBpdCBleGlzdHMgYW5kIGhhcyBhIHZhbHVlXG4gKlxuICovXG5leHBvcnQgY29uc3QgcHJvcFRvQXJyYXkgPSAob2JqOntba2V5OnN0cmluZ106YW55fSwga2V5OnN0cmluZykgPT4ge1xuXHR2YXIgdmFsdWUgPSBvYmpba2V5XTtcblxuXHRpZiggdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgKSByZXR1cm4gdmFsdWU7XG5cblx0aWYoIHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSApe1xuXHRcdG9ialtrZXldID0gW3ZhbHVlXTtcblx0fVxufVxuXG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBhcnJheXMgYW5kIGhhc2hlcy5cbiAqXG4gKiBgYGBcbiAqIGl0ZXJhdGUodGhpcy5pdGVtcywgZnVuY3Rpb24oaXRlbSwgaWQpIHtcbiAqICAgIC8vIGludm9rZWQgZm9yIGVhY2ggaXRlbVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRlID0gKG9iamVjdDpbXXx7W2tleTpzdHJpbmddOmFueX0sIGNhbGxiYWNrOih2YWx1ZTphbnksa2V5OmFueSk9PmFueSkgPT4ge1xuXG5cdGlmICggQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdFx0b2JqZWN0LmZvckVhY2goY2FsbGJhY2spO1xuXG5cdH1lbHNle1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHRcdFx0aWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuXG5cbmV4cG9ydCBjb25zdCBjbXAgPSAoYTpudW1iZXJ8c3RyaW5nLCBiOm51bWJlcnxzdHJpbmcpID0+IHtcblx0aWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcblx0XHRyZXR1cm4gYSA+IGIgPyAxIDogKGEgPCBiID8gLTEgOiAwKTtcblx0fVxuXHRhID0gYXNjaWlmb2xkKGEgKyAnJykudG9Mb3dlckNhc2UoKTtcblx0YiA9IGFzY2lpZm9sZChiICsgJycpLnRvTG93ZXJDYXNlKCk7XG5cdGlmIChhID4gYikgcmV0dXJuIDE7XG5cdGlmIChiID4gYSkgcmV0dXJuIC0xO1xuXHRyZXR1cm4gMDtcbn07XG4iLCAiXG5pbXBvcnQgeyBpdGVyYXRlIH0gZnJvbSAnQG9yY2hpZGpzL3NpZnRlci9saWIvdXRpbHMnO1xuXG4vKipcbiAqIFJldHVybiBhIGRvbSBlbGVtZW50IGZyb20gZWl0aGVyIGEgZG9tIHF1ZXJ5IHN0cmluZywgalF1ZXJ5IG9iamVjdCwgYSBkb20gZWxlbWVudCBvciBodG1sIHN0cmluZ1xuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk0MTQzL2NyZWF0aW5nLWEtbmV3LWRvbS1lbGVtZW50LWZyb20tYW4taHRtbC1zdHJpbmctdXNpbmctYnVpbHQtaW4tZG9tLW1ldGhvZHMtb3ItcHJvLzM1Mzg1NTE4IzM1Mzg1NTE4XG4gKlxuICogcGFyYW0gcXVlcnkgc2hvdWxkIGJlIHt9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXREb20gPSAoIHF1ZXJ5OmFueSApOkhUTUxFbGVtZW50ID0+IHtcblxuXHRpZiggcXVlcnkuanF1ZXJ5ICl7XG5cdFx0cmV0dXJuIHF1ZXJ5WzBdO1xuXHR9XG5cblx0aWYoIHF1ZXJ5IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgKXtcblx0XHRyZXR1cm4gcXVlcnk7XG5cdH1cblxuXHRpZiggaXNIdG1sU3RyaW5nKHF1ZXJ5KSApe1xuXHRcdHZhciB0cGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXHRcdHRwbC5pbm5lckhUTUwgPSBxdWVyeS50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcblx0XHRyZXR1cm4gdHBsLmNvbnRlbnQuZmlyc3RDaGlsZCBhcyBIVE1MRWxlbWVudDtcblx0fVxuXG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0h0bWxTdHJpbmcgPSAoYXJnOmFueSk6IGJvb2xlYW4gPT4ge1xuXHRpZiggdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgYXJnLmluZGV4T2YoJzwnKSA+IC0xICl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgY29uc3QgZXNjYXBlUXVlcnkgPSAocXVlcnk6c3RyaW5nKTpzdHJpbmcgPT4ge1xuXHRyZXR1cm4gcXVlcnkucmVwbGFjZSgvWydcIlxcXFxdL2csICdcXFxcJCYnKTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhbiBldmVudFxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHRyaWdnZXJFdmVudCA9ICggZG9tX2VsOkhUTUxFbGVtZW50LCBldmVudF9uYW1lOnN0cmluZyApOnZvaWQgPT4ge1xuXHR2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuXHRldmVudC5pbml0RXZlbnQoZXZlbnRfbmFtZSwgdHJ1ZSwgZmFsc2UpO1xuXHRkb21fZWwuZGlzcGF0Y2hFdmVudChldmVudClcbn07XG5cbi8qKlxuICogQXBwbHkgQ1NTIHJ1bGVzIHRvIGEgZG9tIGVsZW1lbnRcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBhcHBseUNTUyA9ICggZG9tX2VsOkhUTUxFbGVtZW50LCBjc3M6eyBba2V5OiBzdHJpbmddOiBzdHJpbmd8bnVtYmVyIH0pOnZvaWQgPT4ge1xuXHRPYmplY3QuYXNzaWduKGRvbV9lbC5zdHlsZSwgY3NzKTtcbn1cblxuXG4vKipcbiAqIEFkZCBjc3MgY2xhc3Nlc1xuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZENsYXNzZXMgPSAoIGVsbXRzOkhUTUxFbGVtZW50fEhUTUxFbGVtZW50W10sIC4uLmNsYXNzZXM6c3RyaW5nW118c3RyaW5nW11bXSApID0+IHtcblxuXHR2YXIgbm9ybV9jbGFzc2VzIFx0PSBjbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG5cdGVsbXRzXHRcdFx0XHQ9IGNhc3RBc0FycmF5KGVsbXRzKTtcblxuXHRlbG10cy5tYXAoIGVsID0+IHtcblx0XHRub3JtX2NsYXNzZXMubWFwKCBjbHMgPT4ge1xuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZCggY2xzICk7XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZSBjc3MgY2xhc3Nlc1xuICpcbiAqL1xuIGV4cG9ydCBjb25zdCByZW1vdmVDbGFzc2VzID0gKCBlbG10czpIVE1MRWxlbWVudHxIVE1MRWxlbWVudFtdLCAuLi5jbGFzc2VzOnN0cmluZ1tdfHN0cmluZ1tdW10gKSA9PiB7XG5cbiBcdHZhciBub3JtX2NsYXNzZXMgXHQ9IGNsYXNzZXNBcnJheShjbGFzc2VzKTtcblx0ZWxtdHNcdFx0XHRcdD0gY2FzdEFzQXJyYXkoZWxtdHMpO1xuXG5cdGVsbXRzLm1hcCggZWwgPT4ge1xuXHRcdG5vcm1fY2xhc3Nlcy5tYXAoY2xzID0+IHtcblx0IFx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKCBjbHMgKTtcblx0XHR9KTtcbiBcdH0pO1xuIH1cblxuXG4vKipcbiAqIFJldHVybiBhcmd1bWVudHNcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBjbGFzc2VzQXJyYXkgPSAoYXJnczpzdHJpbmdbXXxzdHJpbmdbXVtdKTpzdHJpbmdbXSA9PiB7XG5cdHZhciBjbGFzc2VzOnN0cmluZ1tdID0gW107XG5cdGl0ZXJhdGUoIGFyZ3MsIChfY2xhc3NlcykgPT57XG5cdFx0aWYoIHR5cGVvZiBfY2xhc3NlcyA9PT0gJ3N0cmluZycgKXtcblx0XHRcdF9jbGFzc2VzID0gX2NsYXNzZXMudHJpbSgpLnNwbGl0KC9bXFwxMVxcMTJcXDE0XFwxNVxcNDBdLyk7XG5cdFx0fVxuXHRcdGlmKCBBcnJheS5pc0FycmF5KF9jbGFzc2VzKSApe1xuXHRcdFx0Y2xhc3NlcyA9IGNsYXNzZXMuY29uY2F0KF9jbGFzc2VzKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBjbGFzc2VzLmZpbHRlcihCb29sZWFuKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBmcm9tIGFyZyBpZiBpdCdzIG5vdCBhbHJlYWR5IGFuIGFycmF5XG4gKlxuICovXG5leHBvcnQgY29uc3QgY2FzdEFzQXJyYXkgPSAoYXJnOmFueSk6QXJyYXk8YW55PiA9PiB7XG5cdGlmKCAhQXJyYXkuaXNBcnJheShhcmcpICl7XG4gXHRcdGFyZyA9IFthcmddO1xuIFx0fVxuXHRyZXR1cm4gYXJnO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjbG9zZXN0IG5vZGUgdG8gdGhlIGV2dC50YXJnZXQgbWF0Y2hpbmcgdGhlIHNlbGVjdG9yXG4gKiBTdG9wcyBhdCB3cmFwcGVyXG4gKlxuICovXG5leHBvcnQgY29uc3QgcGFyZW50TWF0Y2ggPSAoIHRhcmdldDpudWxsfEhUTUxFbGVtZW50LCBzZWxlY3RvcjpzdHJpbmcsIHdyYXBwZXI/OkhUTUxFbGVtZW50ICk6SFRNTEVsZW1lbnR8dm9pZCA9PiB7XG5cblx0aWYoIHdyYXBwZXIgJiYgIXdyYXBwZXIuY29udGFpbnModGFyZ2V0KSApe1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHdoaWxlKCB0YXJnZXQgJiYgdGFyZ2V0Lm1hdGNoZXMgKXtcblxuXHRcdGlmKCB0YXJnZXQubWF0Y2hlcyhzZWxlY3RvcikgKXtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQ7XG5cdH1cbn1cblxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3Qgb3IgbGFzdCBpdGVtIGZyb20gYW4gYXJyYXlcbiAqXG4gKiA+IDAgLSByaWdodCAobGFzdClcbiAqIDw9IDAgLSBsZWZ0IChmaXJzdClcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUYWlsID0gKCBsaXN0OkFycmF5PGFueT58Tm9kZUxpc3QsIGRpcmVjdGlvbjpudW1iZXI9MCApOmFueSA9PiB7XG5cblx0aWYoIGRpcmVjdGlvbiA+IDAgKXtcblx0XHRyZXR1cm4gbGlzdFtsaXN0Lmxlbmd0aC0xXTtcblx0fVxuXG5cdHJldHVybiBsaXN0WzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGFuIG9iamVjdCBpcyBlbXB0eVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRW1wdHlPYmplY3QgPSAob2JqOm9iamVjdCk6Ym9vbGVhbiA9PiB7XG5cdHJldHVybiAoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDApO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IGFtb25nc3Qgc2libGluZyBub2RlcyBvZiB0aGUgc2FtZSB0eXBlXG4gKlxuICovXG5leHBvcnQgY29uc3Qgbm9kZUluZGV4ID0gKCBlbDpudWxsfEVsZW1lbnQsIGFtb25nc3Q/OnN0cmluZyApOm51bWJlciA9PiB7XG5cdGlmICghZWwpIHJldHVybiAtMTtcblxuXHRhbW9uZ3N0ID0gYW1vbmdzdCB8fCBlbC5ub2RlTmFtZTtcblxuXHR2YXIgaSA9IDA7XG5cdHdoaWxlKCBlbCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgKXtcblxuXHRcdGlmKCBlbC5tYXRjaGVzKGFtb25nc3QpICl7XG5cdFx0XHRpKys7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBpO1xufVxuXG5cbi8qKlxuICogU2V0IGF0dHJpYnV0ZXMgb2YgYW4gZWxlbWVudFxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEF0dHIgPSAoZWw6RWxlbWVudCxhdHRyczp7IFtrZXk6IHN0cmluZ106IG51bGx8c3RyaW5nfG51bWJlciB9KSA9PiB7XG5cdGl0ZXJhdGUoIGF0dHJzLCh2YWwsYXR0cikgPT4ge1xuXHRcdGlmKCB2YWwgPT0gbnVsbCApe1xuXHRcdFx0ZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIgYXMgc3RyaW5nKTtcblx0XHR9ZWxzZXtcblx0XHRcdGVsLnNldEF0dHJpYnV0ZShhdHRyIGFzIHN0cmluZywgJycrdmFsKTtcblx0XHR9XG5cdH0pO1xufVxuXG5cbi8qKlxuICogUmVwbGFjZSBhIG5vZGVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGxhY2VOb2RlID0gKCBleGlzdGluZzpOb2RlLCByZXBsYWNlbWVudDpOb2RlICkgPT4ge1xuXHRpZiggZXhpc3RpbmcucGFyZW50Tm9kZSApIGV4aXN0aW5nLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHJlcGxhY2VtZW50LCBleGlzdGluZyk7XG59XG4iLCAiLyoqXG4gKiBoaWdobGlnaHQgdjMgfCBNSVQgbGljZW5zZSB8IEpvaGFubiBCdXJrYXJkIDxqYkBlYWlvLmNvbT5cbiAqIEhpZ2hsaWdodHMgYXJiaXRyYXJ5IHRlcm1zIGluIGEgbm9kZS5cbiAqXG4gKiAtIE1vZGlmaWVkIGJ5IE1hcnNoYWwgPGJlYXRnYXRlc0BnbWFpbC5jb20+IDIwMTEtNi0yNCAoYWRkZWQgcmVnZXgpXG4gKiAtIE1vZGlmaWVkIGJ5IEJyaWFuIFJlYXZpcyA8YnJpYW5AdGhpcmRyb3V0ZS5jb20+IDIwMTItOC0yNyAoY2xlYW51cClcbiAqL1xuXG5pbXBvcnQge3JlcGxhY2VOb2RlfSBmcm9tICcuLi92YW5pbGxhJztcblxuXG5leHBvcnQgY29uc3QgaGlnaGxpZ2h0ID0gKGVsZW1lbnQ6SFRNTEVsZW1lbnQsIHJlZ2V4OnN0cmluZ3xSZWdFeHApID0+IHtcblxuXHRpZiggcmVnZXggPT09IG51bGwgKSByZXR1cm47XG5cblx0Ly8gY29udmV0IHN0cmluZyB0byByZWdleFxuXHRpZiggdHlwZW9mIHJlZ2V4ID09PSAnc3RyaW5nJyApe1xuXG5cdFx0aWYoICFyZWdleC5sZW5ndGggKSByZXR1cm47XG5cdFx0cmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4LCAnaScpO1xuXHR9XG5cblxuXHQvLyBXcmFwIG1hdGNoaW5nIHBhcnQgb2YgdGV4dCBub2RlIHdpdGggaGlnaGxpZ2h0aW5nIDxzcGFuPiwgZS5nLlxuXHQvLyBTb2NjZXIgIC0+ICA8c3BhbiBjbGFzcz1cImhpZ2hsaWdodFwiPlNvYzwvc3Bhbj5jZXIgIGZvciByZWdleCA9IC9zb2MvaVxuXHRjb25zdCBoaWdobGlnaHRUZXh0ID0gKCBub2RlOlRleHQgKTpudW1iZXIgPT4ge1xuXG5cdFx0dmFyIG1hdGNoID0gbm9kZS5kYXRhLm1hdGNoKHJlZ2V4KTtcblx0XHRpZiggbWF0Y2ggJiYgbm9kZS5kYXRhLmxlbmd0aCA+IDAgKXtcblx0XHRcdHZhciBzcGFubm9kZVx0XHQ9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblx0XHRcdHNwYW5ub2RlLmNsYXNzTmFtZVx0PSAnaGlnaGxpZ2h0Jztcblx0XHRcdHZhciBtaWRkbGViaXRcdFx0PSBub2RlLnNwbGl0VGV4dChtYXRjaC5pbmRleCBhcyBudW1iZXIpO1xuXG5cdFx0XHRtaWRkbGViaXQuc3BsaXRUZXh0KG1hdGNoWzBdIS5sZW5ndGgpO1xuXHRcdFx0dmFyIG1pZGRsZWNsb25lXHRcdD0gbWlkZGxlYml0LmNsb25lTm9kZSh0cnVlKTtcblxuXHRcdFx0c3Bhbm5vZGUuYXBwZW5kQ2hpbGQobWlkZGxlY2xvbmUpO1xuXHRcdFx0cmVwbGFjZU5vZGUobWlkZGxlYml0LCBzcGFubm9kZSk7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fTtcblxuXHQvLyBSZWN1cnNlIGVsZW1lbnQgbm9kZSwgbG9va2luZyBmb3IgY2hpbGQgdGV4dCBub2RlcyB0byBoaWdobGlnaHQsIHVubGVzcyBlbGVtZW50XG5cdC8vIGlzIGNoaWxkbGVzcywgPHNjcmlwdD4sIDxzdHlsZT4sIG9yIGFscmVhZHkgaGlnaGxpZ2h0ZWQ6IDxzcGFuIGNsYXNzPVwiaGlnaHRsaWdodFwiPlxuXHRjb25zdCBoaWdobGlnaHRDaGlsZHJlbiA9ICggbm9kZTpFbGVtZW50ICk6dm9pZCA9PiB7XG5cdFx0aWYoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS5jaGlsZE5vZGVzICYmICEvKHNjcmlwdHxzdHlsZSkvaS50ZXN0KG5vZGUudGFnTmFtZSkgJiYgKCBub2RlLmNsYXNzTmFtZSAhPT0gJ2hpZ2hsaWdodCcgfHwgbm9kZS50YWdOYW1lICE9PSAnU1BBTicgKSApe1xuXHRcdFx0QXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiB7XG5cdFx0XHRcdGhpZ2hsaWdodFJlY3Vyc2l2ZShlbGVtZW50KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXG5cdGNvbnN0IGhpZ2hsaWdodFJlY3Vyc2l2ZSA9ICggbm9kZTpOb2RlfEVsZW1lbnQgKTpudW1iZXIgPT4ge1xuXG5cdFx0aWYoIG5vZGUubm9kZVR5cGUgPT09IDMgKXtcblx0XHRcdHJldHVybiBoaWdobGlnaHRUZXh0KG5vZGUgYXMgVGV4dCk7XG5cdFx0fVxuXG5cdFx0aGlnaGxpZ2h0Q2hpbGRyZW4obm9kZSBhcyBFbGVtZW50KTtcblxuXHRcdHJldHVybiAwO1xuXHR9O1xuXG5cdGhpZ2hsaWdodFJlY3Vyc2l2ZSggZWxlbWVudCApO1xufTtcblxuLyoqXG4gKiByZW1vdmVIaWdobGlnaHQgZm4gY29waWVkIGZyb20gaGlnaGxpZ2h0IHY1IGFuZFxuICogZWRpdGVkIHRvIHJlbW92ZSB3aXRoKCksIHBhc3MganMgc3RyaWN0IG1vZGUsIGFuZCB1c2Ugd2l0aG91dCBqcXVlcnlcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUhpZ2hsaWdodCA9IChlbDpIVE1MRWxlbWVudCkgPT4ge1xuXHR2YXIgZWxlbWVudHMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKFwic3Bhbi5oaWdobGlnaHRcIik7XG5cdEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWxlbWVudHMsIGZ1bmN0aW9uKGVsOkhUTUxFbGVtZW50KXtcblx0XHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZSBhcyBOb2RlO1xuXHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoZWwuZmlyc3RDaGlsZCBhcyBOb2RlLCBlbCk7XG5cdFx0cGFyZW50Lm5vcm1hbGl6ZSgpO1xuXHR9KTtcbn07XG4iLCAiZXhwb3J0IGNvbnN0IEtFWV9BXHRcdFx0XHQ9IDY1O1xuZXhwb3J0IGNvbnN0IEtFWV9SRVRVUk5cdFx0XHQ9IDEzO1xuZXhwb3J0IGNvbnN0IEtFWV9FU0NcdFx0XHQ9IDI3O1xuZXhwb3J0IGNvbnN0IEtFWV9MRUZUXHRcdFx0PSAzNztcbmV4cG9ydCBjb25zdCBLRVlfVVBcdFx0XHRcdD0gMzg7XG5leHBvcnQgY29uc3QgS0VZX1JJR0hUXHRcdFx0PSAzOTtcbmV4cG9ydCBjb25zdCBLRVlfRE9XTlx0XHRcdD0gNDA7XG5leHBvcnQgY29uc3QgS0VZX0JBQ0tTUEFDRVx0XHQ9IDg7XG5leHBvcnQgY29uc3QgS0VZX0RFTEVURVx0XHRcdD0gNDY7XG5leHBvcnQgY29uc3QgS0VZX1RBQlx0XHRcdD0gOTtcblxuZXhwb3J0IGNvbnN0IElTX01BQyAgICAgIFx0XHQ9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiAvTWFjLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuZXhwb3J0IGNvbnN0IEtFWV9TSE9SVENVVFx0XHQ9IElTX01BQyA/ICdtZXRhS2V5JyA6ICdjdHJsS2V5JzsgLy8gY3RybCBrZXkgb3IgYXBwbGUga2V5IGZvciBtYVxuIiwgIlxuZXhwb3J0IGRlZmF1bHQge1xuXHRvcHRpb25zOiBbXSxcblx0b3B0Z3JvdXBzOiBbXSxcblxuXHRwbHVnaW5zOiBbXSxcblx0ZGVsaW1pdGVyOiAnLCcsXG5cdHNwbGl0T246IG51bGwsIC8vIHJlZ2V4cCBvciBzdHJpbmcgZm9yIHNwbGl0dGluZyB1cCB2YWx1ZXMgZnJvbSBhIHBhc3RlIGNvbW1hbmRcblx0cGVyc2lzdDogdHJ1ZSxcblx0ZGlhY3JpdGljczogdHJ1ZSxcblx0Y3JlYXRlOiBudWxsLFxuXHRjcmVhdGVPbkJsdXI6IGZhbHNlLFxuXHRjcmVhdGVGaWx0ZXI6IG51bGwsXG5cdGhpZ2hsaWdodDogdHJ1ZSxcblx0b3Blbk9uRm9jdXM6IHRydWUsXG5cdHNob3VsZE9wZW46IG51bGwsXG5cdG1heE9wdGlvbnM6IDUwLFxuXHRtYXhJdGVtczogbnVsbCxcblx0aGlkZVNlbGVjdGVkOiBudWxsLFxuXHRkdXBsaWNhdGVzOiBmYWxzZSxcblx0YWRkUHJlY2VkZW5jZTogZmFsc2UsXG5cdHNlbGVjdE9uVGFiOiBmYWxzZSxcblx0cHJlbG9hZDogbnVsbCxcblx0YWxsb3dFbXB0eU9wdGlvbjogZmFsc2UsXG5cdC8vY2xvc2VBZnRlclNlbGVjdDogZmFsc2UsXG5cdHJlZnJlc2hUaHJvdHRsZTogMzAwLFxuXG5cblx0bG9hZFRocm90dGxlOiAzMDAsXG5cdGxvYWRpbmdDbGFzczogJ2xvYWRpbmcnLFxuXG5cdGRhdGFBdHRyOiBudWxsLCAvLydkYXRhLWRhdGEnLFxuXHRvcHRncm91cEZpZWxkOiAnb3B0Z3JvdXAnLFxuXHR2YWx1ZUZpZWxkOiAndmFsdWUnLFxuXHRsYWJlbEZpZWxkOiAndGV4dCcsXG5cdGRpc2FibGVkRmllbGQ6ICdkaXNhYmxlZCcsXG5cdG9wdGdyb3VwTGFiZWxGaWVsZDogJ2xhYmVsJyxcblx0b3B0Z3JvdXBWYWx1ZUZpZWxkOiAndmFsdWUnLFxuXHRsb2NrT3B0Z3JvdXBPcmRlcjogZmFsc2UsXG5cblx0c29ydEZpZWxkOiAnJG9yZGVyJyxcblx0c2VhcmNoRmllbGQ6IFsndGV4dCddLFxuXHRzZWFyY2hDb25qdW5jdGlvbjogJ2FuZCcsXG5cblx0bW9kZTogbnVsbCxcblx0d3JhcHBlckNsYXNzOiAndHMtd3JhcHBlcicsXG5cdGNvbnRyb2xDbGFzczogJ3RzLWNvbnRyb2wnLFxuXHRkcm9wZG93bkNsYXNzOiAndHMtZHJvcGRvd24nLFxuXHRkcm9wZG93bkNvbnRlbnRDbGFzczogJ3RzLWRyb3Bkb3duLWNvbnRlbnQnLFxuXHRpdGVtQ2xhc3M6ICdpdGVtJyxcblx0b3B0aW9uQ2xhc3M6ICdvcHRpb24nLFxuXG5cdGRyb3Bkb3duUGFyZW50OiBudWxsLFxuXHRjb250cm9sSW5wdXQ6ICc8aW5wdXQgdHlwZT1cInRleHRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiBzaXplPVwiMVwiIC8+JyxcblxuXHRjb3B5Q2xhc3Nlc1RvRHJvcGRvd246IGZhbHNlLFxuXG5cdHBsYWNlaG9sZGVyOiBudWxsLFxuXHRoaWRlUGxhY2Vob2xkZXI6IG51bGwsXG5cblx0c2hvdWxkTG9hZDogZnVuY3Rpb24ocXVlcnk6c3RyaW5nKTpib29sZWFue1xuXHRcdHJldHVybiBxdWVyeS5sZW5ndGggPiAwO1xuXHR9LFxuXG5cdC8qXG5cdGxvYWQgICAgICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24ocXVlcnksIGNhbGxiYWNrKSB7IC4uLiB9XG5cdHNjb3JlICAgICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oc2VhcmNoKSB7IC4uLiB9XG5cdG9uSW5pdGlhbGl6ZSAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oKSB7IC4uLiB9XG5cdG9uQ2hhbmdlICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUpIHsgLi4uIH1cblx0b25JdGVtQWRkICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSwgJGl0ZW0pIHsgLi4uIH1cblx0b25JdGVtUmVtb3ZlICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSkgeyAuLi4gfVxuXHRvbkNsZWFyICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuXHRvbk9wdGlvbkFkZCAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlLCBkYXRhKSB7IC4uLiB9XG5cdG9uT3B0aW9uUmVtb3ZlICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUpIHsgLi4uIH1cblx0b25PcHRpb25DbGVhciAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbigpIHsgLi4uIH1cblx0b25PcHRpb25Hcm91cEFkZCAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihpZCwgZGF0YSkgeyAuLi4gfVxuXHRvbk9wdGlvbkdyb3VwUmVtb3ZlICA6IG51bGwsIC8vIGZ1bmN0aW9uKGlkKSB7IC4uLiB9XG5cdG9uT3B0aW9uR3JvdXBDbGVhciAgIDogbnVsbCwgLy8gZnVuY3Rpb24oKSB7IC4uLiB9XG5cdG9uRHJvcGRvd25PcGVuICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oZHJvcGRvd24pIHsgLi4uIH1cblx0b25Ecm9wZG93bkNsb3NlICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihkcm9wZG93bikgeyAuLi4gfVxuXHRvblR5cGUgICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHN0cikgeyAuLi4gfVxuXHRvbkRlbGV0ZSAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlcykgeyAuLi4gfVxuXHQqL1xuXG5cdHJlbmRlcjoge1xuXHRcdC8qXG5cdFx0aXRlbTogbnVsbCxcblx0XHRvcHRncm91cDogbnVsbCxcblx0XHRvcHRncm91cF9oZWFkZXI6IG51bGwsXG5cdFx0b3B0aW9uOiBudWxsLFxuXHRcdG9wdGlvbl9jcmVhdGU6IG51bGxcblx0XHQqL1xuXHR9XG59O1xuIiwgIlxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgVG9tTG9hZENhbGxiYWNrIH0gZnJvbSAnLi90eXBlcy9pbmRleCc7XG5cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNjYWxhciB0byBpdHMgYmVzdCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIGZvciBoYXNoIGtleXMgYW5kIEhUTUwgYXR0cmlidXRlIHZhbHVlcy5cbiAqXG4gKiBUcmFuc2Zvcm1hdGlvbnM6XG4gKiAgICdzdHInICAgICAtPiAnc3RyJ1xuICogICBudWxsICAgICAgLT4gJydcbiAqICAgdW5kZWZpbmVkIC0+ICcnXG4gKiAgIHRydWUgICAgICAtPiAnMSdcbiAqICAgZmFsc2UgICAgIC0+ICcwJ1xuICogICAwICAgICAgICAgLT4gJzAnXG4gKiAgIDEgICAgICAgICAtPiAnMSdcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNoX2tleSA9ICh2YWx1ZTp1bmRlZmluZWR8bnVsbHxib29sZWFufHN0cmluZ3xudW1iZXIpOnN0cmluZ3xudWxsID0+IHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiBudWxsO1xuXHRyZXR1cm4gZ2V0X2hhc2godmFsdWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldF9oYXNoID0gKHZhbHVlOmJvb2xlYW58c3RyaW5nfG51bWJlcik6c3RyaW5nID0+IHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gdmFsdWUgPyAnMScgOiAnMCc7XG5cdHJldHVybiB2YWx1ZSArICcnO1xufTtcblxuLyoqXG4gKiBFc2NhcGVzIGEgc3RyaW5nIGZvciB1c2Ugd2l0aGluIEhUTUwuXG4gKlxuICovXG5leHBvcnQgY29uc3QgZXNjYXBlX2h0bWwgPSAoc3RyOnN0cmluZyk6c3RyaW5nID0+IHtcblx0cmV0dXJuIChzdHIgKyAnJylcblx0XHQucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuXHRcdC5yZXBsYWNlKC88L2csICcmbHQ7Jylcblx0XHQucmVwbGFjZSgvPi9nLCAnJmd0OycpXG5cdFx0LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn07XG5cblxuLyoqXG4gKiB1c2Ugc2V0VGltZW91dCBpZiB0aW1lb3V0ID4gMCBcbiAqL1xuZXhwb3J0IGNvbnN0IHRpbWVvdXQgPSAoZm46KCk9PnZvaWQsdGltZW91dDpudW1iZXIpID0+IHtcblx0aWYoIHRpbWVvdXQgPiAwICl7XG5cdFx0cmV0dXJuIHNldFRpbWVvdXQoZm4sdGltZW91dCk7XG5cdH1cblxuXHRmbi5jYWxsKG51bGwpO1xuXHRyZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZWJvdW5jZSB0aGUgdXNlciBwcm92aWRlZCBsb2FkIGZ1bmN0aW9uXG4gKlxuICovXG5leHBvcnQgY29uc3QgbG9hZERlYm91bmNlID0gKGZuOih2YWx1ZTpzdHJpbmcsY2FsbGJhY2s6VG9tTG9hZENhbGxiYWNrKSA9PiB2b2lkLGRlbGF5Om51bWJlcikgPT4ge1xuXHR2YXIgdGltZW91dDogbnVsbHxSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0Pjtcblx0cmV0dXJuIGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0LCB2YWx1ZTpzdHJpbmcsY2FsbGJhY2s6VG9tTG9hZENhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYoIHRpbWVvdXQgKXtcblx0XHRcdHNlbGYubG9hZGluZyA9IE1hdGgubWF4KHNlbGYubG9hZGluZyAtIDEsIDApO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdH1cblx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdHRpbWVvdXQgPSBudWxsO1xuXHRcdFx0c2VsZi5sb2FkZWRTZWFyY2hlc1t2YWx1ZV0gPSB0cnVlO1xuXHRcdFx0Zm4uY2FsbChzZWxmLCB2YWx1ZSwgY2FsbGJhY2spO1xuXG5cdFx0fSwgZGVsYXkpO1xuXHR9O1xufTtcblxuXG4vKipcbiAqIERlYm91bmNlIGFsbCBmaXJlZCBldmVudHMgdHlwZXMgbGlzdGVkIGluIGB0eXBlc2BcbiAqIHdoaWxlIGV4ZWN1dGluZyB0aGUgcHJvdmlkZWQgYGZuYC5cbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBkZWJvdW5jZV9ldmVudHMgPSAoIHNlbGY6VG9tU2VsZWN0LCB0eXBlczpzdHJpbmdbXSwgZm46KCkgPT4gdm9pZCApID0+IHtcblx0dmFyIHR5cGU6c3RyaW5nO1xuXHR2YXIgdHJpZ2dlciA9IHNlbGYudHJpZ2dlcjtcblx0dmFyIGV2ZW50X2FyZ3M6eyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuXG5cdC8vIG92ZXJyaWRlIHRyaWdnZXIgbWV0aG9kXG5cdHNlbGYudHJpZ2dlciA9IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHR5cGUgPSBhcmd1bWVudHNbMF07XG5cdFx0aWYgKHR5cGVzLmluZGV4T2YodHlwZSkgIT09IC0xKSB7XG5cdFx0XHRldmVudF9hcmdzW3R5cGVdID0gYXJndW1lbnRzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdHJpZ2dlci5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcblxuXHQvLyBpbnZva2UgcHJvdmlkZWQgZnVuY3Rpb25cblx0Zm4uYXBwbHkoc2VsZiwgW10pO1xuXHRzZWxmLnRyaWdnZXIgPSB0cmlnZ2VyO1xuXG5cdC8vIHRyaWdnZXIgcXVldWVkIGV2ZW50c1xuXHRmb3IoIHR5cGUgb2YgdHlwZXMgKXtcblx0XHRpZiggdHlwZSBpbiBldmVudF9hcmdzICl7XG5cdFx0XHR0cmlnZ2VyLmFwcGx5KHNlbGYsIGV2ZW50X2FyZ3NbdHlwZV0pO1xuXHRcdH1cblx0fVxufTtcblxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHdpdGhpbiBhIHRleHQgaW5wdXQgY29udHJvbC5cbiAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmc6XG4gKiAgIC0gc3RhcnRcbiAqICAgLSBsZW5ndGhcbiAqXG4gKiBOb3RlOiBcInNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQgLi4uIGFwcGx5IG9ubHkgdG8gaW5wdXRzIG9mIHR5cGVzIHRleHQsIHNlYXJjaCwgVVJMLCB0ZWwgYW5kIHBhc3N3b3JkXCJcbiAqIFx0LSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTElucHV0RWxlbWVudC9zZXRTZWxlY3Rpb25SYW5nZVxuICovXG5leHBvcnQgY29uc3QgZ2V0U2VsZWN0aW9uID0gKGlucHV0OkhUTUxJbnB1dEVsZW1lbnQpOnsgc3RhcnQ6IG51bWJlcjsgbGVuZ3RoOiBudW1iZXIgfSA9PiB7XG5cdHJldHVybiB7XG5cdFx0c3RhcnRcdDogaW5wdXQuc2VsZWN0aW9uU3RhcnQgfHwgMCxcblx0XHRsZW5ndGhcdDogKGlucHV0LnNlbGVjdGlvbkVuZHx8MCkgLSAoaW5wdXQuc2VsZWN0aW9uU3RhcnR8fDApLFxuXHR9O1xufTtcblxuXG4vKipcbiAqIFByZXZlbnQgZGVmYXVsdFxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHByZXZlbnREZWZhdWx0ID0gKGV2dD86RXZlbnQsIHN0b3A6Ym9vbGVhbj1mYWxzZSk6dm9pZCA9PiB7XG5cdGlmKCBldnQgKXtcblx0XHRldnQucHJldmVudERlZmF1bHQoKTtcblx0XHRpZiggc3RvcCApe1xuXHRcdFx0ZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fVxufVxuXG5cbi8qKlxuICogQWRkIGV2ZW50IGhlbHBlclxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEV2ZW50ID0gKHRhcmdldDpFdmVudFRhcmdldCwgdHlwZTpzdHJpbmcsIGNhbGxiYWNrOkV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QsIG9wdGlvbnM/Om9iamVjdCk6dm9pZCA9PiB7XG5cdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsY2FsbGJhY2ssb3B0aW9ucyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHJlcXVlc3RlZCBrZXkgaXMgZG93blxuICogV2lsbCByZXR1cm4gZmFsc2UgaWYgbW9yZSB0aGFuIG9uZSBjb250cm9sIGNoYXJhY3RlciBpcyBwcmVzc2VkICggd2hlbiBbY3RybCtzaGlmdCthXSAhPSBbY3RybCthXSApXG4gKiBUaGUgY3VycmVudCBldnQgbWF5IG5vdCBhbHdheXMgc2V0ICggZWcgY2FsbGluZyBhZHZhbmNlU2VsZWN0aW9uKCkgKVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGlzS2V5RG93biA9ICgga2V5X25hbWU6a2V5b2YgKEtleWJvYXJkRXZlbnR8TW91c2VFdmVudCksIGV2dD86S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50ICkgPT4ge1xuXG5cdGlmKCAhZXZ0ICl7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYoICFldnRba2V5X25hbWVdICl7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGNvdW50ID0gKGV2dC5hbHRLZXk/MTowKSArIChldnQuY3RybEtleT8xOjApICsgKGV2dC5zaGlmdEtleT8xOjApICsgKGV2dC5tZXRhS2V5PzE6MCk7XG5cblx0aWYoIGNvdW50ID09PSAxICl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBpZCBvZiBhbiBlbGVtZW50XG4gKiBJZiB0aGUgaWQgYXR0cmlidXRlIGlzIG5vdCBzZXQsIHNldCB0aGUgYXR0cmlidXRlIHdpdGggdGhlIGdpdmVuIGlkXG4gKlxuICovXG5leHBvcnQgY29uc3QgZ2V0SWQgPSAoZWw6RWxlbWVudCxpZDpzdHJpbmcpID0+IHtcblx0Y29uc3QgZXhpc3RpbmdfaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cdGlmKCBleGlzdGluZ19pZCApe1xuXHRcdHJldHVybiBleGlzdGluZ19pZDtcblx0fVxuXG5cdGVsLnNldEF0dHJpYnV0ZSgnaWQnLGlkKTtcblx0cmV0dXJuIGlkO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBiYWNrc2xhc2hlcyBhZGRlZCBiZWZvcmUgY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZXNjYXBlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGFkZFNsYXNoZXMgPSAoc3RyOnN0cmluZyk6c3RyaW5nID0+IHtcblx0cmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxcXFwiJ10vZywgJ1xcXFwkJicpO1xufTtcblxuLyoqXG4gKlxuICovXG5leHBvcnQgY29uc3QgYXBwZW5kID0gKCBwYXJlbnQ6RWxlbWVudHxEb2N1bWVudEZyYWdtZW50LCBub2RlOiBzdHJpbmd8Tm9kZXxudWxsfHVuZGVmaW5lZCApOnZvaWQgPT57XG5cdGlmKCBub2RlICkgcGFyZW50LmFwcGVuZChub2RlKTtcbn07XG4iLCAiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vZGVmYXVsdHMnO1xuaW1wb3J0IHsgaGFzaF9rZXkgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IFRvbU9wdGlvbiwgVG9tU2V0dGluZ3MsIFJlY3Vyc2l2ZVBhcnRpYWwgfSBmcm9tICcuL3R5cGVzL2luZGV4JztcbmltcG9ydCB7IGl0ZXJhdGUgfSBmcm9tICdAb3JjaGlkanMvc2lmdGVyL2xpYi91dGlscyc7XG5pbXBvcnQgeyBUb21JbnB1dCB9IGZyb20gJy4vdHlwZXMvaW5kZXgnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNldHRpbmdzKCBpbnB1dDpUb21JbnB1dCwgc2V0dGluZ3NfdXNlcjpSZWN1cnNpdmVQYXJ0aWFsPFRvbVNldHRpbmdzPik6VG9tU2V0dGluZ3N7XG5cdHZhciBzZXR0aW5nczpUb21TZXR0aW5nc1x0PSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgc2V0dGluZ3NfdXNlcik7XG5cblx0dmFyIGF0dHJfZGF0YVx0XHRcdFx0PSBzZXR0aW5ncy5kYXRhQXR0cjtcblx0dmFyIGZpZWxkX2xhYmVsXHRcdFx0XHQ9IHNldHRpbmdzLmxhYmVsRmllbGQ7XG5cdHZhciBmaWVsZF92YWx1ZVx0XHRcdFx0PSBzZXR0aW5ncy52YWx1ZUZpZWxkO1xuXHR2YXIgZmllbGRfZGlzYWJsZWRcdFx0XHQ9IHNldHRpbmdzLmRpc2FibGVkRmllbGQ7XG5cdHZhciBmaWVsZF9vcHRncm91cFx0XHRcdD0gc2V0dGluZ3Mub3B0Z3JvdXBGaWVsZDtcblx0dmFyIGZpZWxkX29wdGdyb3VwX2xhYmVsXHQ9IHNldHRpbmdzLm9wdGdyb3VwTGFiZWxGaWVsZDtcblx0dmFyIGZpZWxkX29wdGdyb3VwX3ZhbHVlXHQ9IHNldHRpbmdzLm9wdGdyb3VwVmFsdWVGaWVsZDtcblxuXHR2YXIgdGFnX25hbWVcdFx0XHRcdD0gaW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR2YXIgcGxhY2Vob2xkZXJcdFx0XHRcdD0gaW5wdXQuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpIHx8IGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZWhvbGRlcicpO1xuXG5cdGlmICghcGxhY2Vob2xkZXIgJiYgIXNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24pIHtcblx0XHRsZXQgb3B0aW9uXHRcdD0gaW5wdXQucXVlcnlTZWxlY3Rvcignb3B0aW9uW3ZhbHVlPVwiXCJdJyk7XG5cdFx0aWYoIG9wdGlvbiApe1xuXHRcdFx0cGxhY2Vob2xkZXIgPSBvcHRpb24udGV4dENvbnRlbnQ7XG5cdFx0fVxuXG5cdH1cblxuXHR2YXIgc2V0dGluZ3NfZWxlbWVudDp7XG5cdFx0cGxhY2Vob2xkZXJcdDogbnVsbHxzdHJpbmcsXG5cdFx0b3B0aW9uc1x0XHQ6IFRvbU9wdGlvbltdLFxuXHRcdG9wdGdyb3Vwc1x0OiBUb21PcHRpb25bXSxcblx0XHRpdGVtc1x0XHQ6IHN0cmluZ1tdLFxuXHRcdG1heEl0ZW1zXHQ6IG51bGx8bnVtYmVyLFxuXHR9ID0ge1xuXHRcdHBsYWNlaG9sZGVyXHQ6IHBsYWNlaG9sZGVyLFxuXHRcdG9wdGlvbnNcdFx0OiBbXSxcblx0XHRvcHRncm91cHNcdDogW10sXG5cdFx0aXRlbXNcdFx0OiBbXSxcblx0XHRtYXhJdGVtc1x0OiBudWxsLFxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgZnJvbSBhIDxzZWxlY3Q+IGVsZW1lbnQuXG5cdCAqXG5cdCAqL1xuXHR2YXIgaW5pdF9zZWxlY3QgPSAoKSA9PiB7XG5cdFx0dmFyIHRhZ05hbWU7XG5cdFx0dmFyIG9wdGlvbnMgPSBzZXR0aW5nc19lbGVtZW50Lm9wdGlvbnM7XG5cdFx0dmFyIG9wdGlvbnNNYXA6e1trZXk6c3RyaW5nXTphbnl9ID0ge307XG5cdFx0dmFyIGdyb3VwX2NvdW50ID0gMTtcblx0XHRsZXQgJG9yZGVyID0gMDtcblxuXHRcdHZhciByZWFkRGF0YSA9IChlbDpIVE1MRWxlbWVudCk6VG9tT3B0aW9uID0+IHtcblxuXHRcdFx0dmFyIGRhdGFcdD0gT2JqZWN0LmFzc2lnbih7fSxlbC5kYXRhc2V0KTsgLy8gZ2V0IHBsYWluIG9iamVjdCBmcm9tIERPTVN0cmluZ01hcFxuXHRcdFx0dmFyIGpzb25cdD0gYXR0cl9kYXRhICYmIGRhdGFbYXR0cl9kYXRhXTtcblxuXHRcdFx0aWYoIHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyAmJiBqc29uLmxlbmd0aCApe1xuXHRcdFx0XHRkYXRhID0gT2JqZWN0LmFzc2lnbihkYXRhLEpTT04ucGFyc2UoanNvbikpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9O1xuXG5cdFx0dmFyIGFkZE9wdGlvbiA9IChvcHRpb246SFRNTE9wdGlvbkVsZW1lbnQsIGdyb3VwPzpzdHJpbmcpID0+IHtcblxuXHRcdFx0dmFyIHZhbHVlID0gaGFzaF9rZXkob3B0aW9uLnZhbHVlKTtcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCApIHJldHVybjtcblx0XHRcdGlmICggIXZhbHVlICYmICFzZXR0aW5ncy5hbGxvd0VtcHR5T3B0aW9uKSByZXR1cm47XG5cblx0XHRcdC8vIGlmIHRoZSBvcHRpb24gYWxyZWFkeSBleGlzdHMsIGl0J3MgcHJvYmFibHkgYmVlblxuXHRcdFx0Ly8gZHVwbGljYXRlZCBpbiBhbm90aGVyIG9wdGdyb3VwLiBpbiB0aGlzIGNhc2UsIHB1c2hcblx0XHRcdC8vIHRoZSBjdXJyZW50IGdyb3VwIHRvIHRoZSBcIm9wdGdyb3VwXCIgcHJvcGVydHkgb24gdGhlXG5cdFx0XHQvLyBleGlzdGluZyBvcHRpb24gc28gdGhhdCBpdCdzIHJlbmRlcmVkIGluIGJvdGggcGxhY2VzLlxuXHRcdFx0aWYgKG9wdGlvbnNNYXAuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XG5cdFx0XHRcdGlmIChncm91cCkge1xuXHRcdFx0XHRcdHZhciBhcnIgPSBvcHRpb25zTWFwW3ZhbHVlXVtmaWVsZF9vcHRncm91cF07XG5cdFx0XHRcdFx0aWYgKCFhcnIpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnNNYXBbdmFsdWVdW2ZpZWxkX29wdGdyb3VwXSA9IGdyb3VwO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuXHRcdFx0XHRcdFx0b3B0aW9uc01hcFt2YWx1ZV1bZmllbGRfb3B0Z3JvdXBdID0gW2FyciwgZ3JvdXBdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhcnIucHVzaChncm91cCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH1lbHNle1xuXG5cdFx0XHRcdHZhciBvcHRpb25fZGF0YSAgICAgICAgICAgICA9IHJlYWREYXRhKG9wdGlvbik7XG5cdFx0XHRcdG9wdGlvbl9kYXRhW2ZpZWxkX2xhYmVsXSAgICA9IG9wdGlvbl9kYXRhW2ZpZWxkX2xhYmVsXSB8fCBvcHRpb24udGV4dENvbnRlbnQ7XG5cdFx0XHRcdG9wdGlvbl9kYXRhW2ZpZWxkX3ZhbHVlXSAgICA9IG9wdGlvbl9kYXRhW2ZpZWxkX3ZhbHVlXSB8fCB2YWx1ZTtcblx0XHRcdFx0b3B0aW9uX2RhdGFbZmllbGRfZGlzYWJsZWRdID0gb3B0aW9uX2RhdGFbZmllbGRfZGlzYWJsZWRdIHx8IG9wdGlvbi5kaXNhYmxlZDtcblx0XHRcdFx0b3B0aW9uX2RhdGFbZmllbGRfb3B0Z3JvdXBdID0gb3B0aW9uX2RhdGFbZmllbGRfb3B0Z3JvdXBdIHx8IGdyb3VwO1xuXHRcdFx0XHRvcHRpb25fZGF0YS4kb3B0aW9uXHRcdFx0PSBvcHRpb247XG5cdFx0XHRcdG9wdGlvbl9kYXRhLiRvcmRlclx0XHRcdD0gb3B0aW9uX2RhdGEuJG9yZGVyIHx8ICsrJG9yZGVyO1xuXG5cdFx0XHRcdG9wdGlvbnNNYXBbdmFsdWVdID0gb3B0aW9uX2RhdGE7XG5cdFx0XHRcdG9wdGlvbnMucHVzaChvcHRpb25fZGF0YSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCBvcHRpb24uc2VsZWN0ZWQgKXtcblx0XHRcdFx0c2V0dGluZ3NfZWxlbWVudC5pdGVtcy5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIGFkZEdyb3VwID0gKCBvcHRncm91cDpIVE1MT3B0R3JvdXBFbGVtZW50ICkgPT4ge1xuXHRcdFx0dmFyIGlkOnN0cmluZywgb3B0Z3JvdXBfZGF0YVxuXG5cdFx0XHRvcHRncm91cF9kYXRhXHRcdFx0XHRcdFx0XHQ9IHJlYWREYXRhKG9wdGdyb3VwKTtcblx0XHRcdG9wdGdyb3VwX2RhdGFbZmllbGRfb3B0Z3JvdXBfbGFiZWxdXHRcdD0gb3B0Z3JvdXBfZGF0YVtmaWVsZF9vcHRncm91cF9sYWJlbF0gfHwgb3B0Z3JvdXAuZ2V0QXR0cmlidXRlKCdsYWJlbCcpIHx8ICcnO1xuXHRcdFx0b3B0Z3JvdXBfZGF0YVtmaWVsZF9vcHRncm91cF92YWx1ZV1cdFx0PSBvcHRncm91cF9kYXRhW2ZpZWxkX29wdGdyb3VwX3ZhbHVlXSB8fCBncm91cF9jb3VudCsrO1xuXHRcdFx0b3B0Z3JvdXBfZGF0YVtmaWVsZF9kaXNhYmxlZF1cdFx0XHQ9IG9wdGdyb3VwX2RhdGFbZmllbGRfZGlzYWJsZWRdIHx8IG9wdGdyb3VwLmRpc2FibGVkO1xuXHRcdFx0b3B0Z3JvdXBfZGF0YS4kb3JkZXJcdFx0XHRcdFx0PSBvcHRncm91cF9kYXRhLiRvcmRlciB8fCArKyRvcmRlcjtcblxuXHRcdFx0c2V0dGluZ3NfZWxlbWVudC5vcHRncm91cHMucHVzaChvcHRncm91cF9kYXRhKTtcblxuXHRcdFx0aWQgPSBvcHRncm91cF9kYXRhW2ZpZWxkX29wdGdyb3VwX3ZhbHVlXTtcblxuXHRcdFx0aXRlcmF0ZShvcHRncm91cC5jaGlsZHJlbiwgKG9wdGlvbik9Pntcblx0XHRcdFx0YWRkT3B0aW9uKG9wdGlvbiBhcyBIVE1MT3B0aW9uRWxlbWVudCwgaWQpO1xuXHRcdFx0fSk7XG5cblx0XHR9O1xuXG5cdFx0c2V0dGluZ3NfZWxlbWVudC5tYXhJdGVtcyA9IGlucHV0Lmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSA/IG51bGwgOiAxO1xuXG5cdFx0aXRlcmF0ZShpbnB1dC5jaGlsZHJlbiwoY2hpbGQpPT57XG5cdFx0XHR0YWdOYW1lID0gY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKHRhZ05hbWUgPT09ICdvcHRncm91cCcpIHtcblx0XHRcdFx0YWRkR3JvdXAoY2hpbGQgYXMgSFRNTE9wdEdyb3VwRWxlbWVudCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdvcHRpb24nKSB7XG5cdFx0XHRcdGFkZE9wdGlvbihjaGlsZCBhcyBIVE1MT3B0aW9uRWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGZyb20gYSA8aW5wdXQgdHlwZT1cInRleHRcIj4gZWxlbWVudC5cblx0ICpcblx0ICovXG5cdHZhciBpbml0X3RleHRib3ggPSAoKSA9PiB7XG5cdFx0Y29uc3QgZGF0YV9yYXcgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoYXR0cl9kYXRhKTtcblxuXHRcdGlmICghZGF0YV9yYXcpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlLnRyaW0oKSB8fCAnJztcblx0XHRcdGlmICghc2V0dGluZ3MuYWxsb3dFbXB0eU9wdGlvbiAmJiAhdmFsdWUubGVuZ3RoKSByZXR1cm47XG5cdFx0XHRjb25zdCB2YWx1ZXMgPSB2YWx1ZS5zcGxpdChzZXR0aW5ncy5kZWxpbWl0ZXIpO1xuXG5cdFx0XHRpdGVyYXRlKCB2YWx1ZXMsICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRjb25zdCBvcHRpb246VG9tT3B0aW9uID0ge307XG5cdFx0XHRcdG9wdGlvbltmaWVsZF9sYWJlbF0gPSB2YWx1ZTtcblx0XHRcdFx0b3B0aW9uW2ZpZWxkX3ZhbHVlXSA9IHZhbHVlO1xuXHRcdFx0XHRzZXR0aW5nc19lbGVtZW50Lm9wdGlvbnMucHVzaChvcHRpb24pO1xuXHRcdFx0fSk7XG5cdFx0XHRzZXR0aW5nc19lbGVtZW50Lml0ZW1zID0gdmFsdWVzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZXR0aW5nc19lbGVtZW50Lm9wdGlvbnMgPSBKU09OLnBhcnNlKGRhdGFfcmF3KTtcblx0XHRcdGl0ZXJhdGUoIHNldHRpbmdzX2VsZW1lbnQub3B0aW9ucywgKG9wdCkgPT4ge1xuXHRcdFx0XHRzZXR0aW5nc19lbGVtZW50Lml0ZW1zLnB1c2gob3B0W2ZpZWxkX3ZhbHVlXSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblxuXHRpZiAodGFnX25hbWUgPT09ICdzZWxlY3QnKSB7XG5cdFx0aW5pdF9zZWxlY3QoKTtcblx0fSBlbHNlIHtcblx0XHRpbml0X3RleHRib3goKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QuYXNzaWduKCB7fSwgZGVmYXVsdHMsIHNldHRpbmdzX2VsZW1lbnQsIHNldHRpbmdzX3VzZXIpIGFzIFRvbVNldHRpbmdzO1xufTtcbiIsICJcbmltcG9ydCBNaWNyb0V2ZW50IGZyb20gJy4vY29udHJpYi9taWNyb2V2ZW50JztcbmltcG9ydCBNaWNyb1BsdWdpbiBmcm9tICcuL2NvbnRyaWIvbWljcm9wbHVnaW4nO1xuaW1wb3J0IHsgU2lmdGVyLCBpdGVyYXRlIH0gZnJvbSAnQG9yY2hpZGpzL3NpZnRlcic7XG5pbXBvcnQgeyBlc2NhcGVfcmVnZXggfSBmcm9tICdAb3JjaGlkanMvdW5pY29kZS12YXJpYW50cyc7XG5pbXBvcnQgeyBUb21JbnB1dCwgVG9tQXJnT2JqZWN0LCBUb21PcHRpb24sIFRvbU9wdGlvbnMsIFRvbUNyZWF0ZUZpbHRlciwgVG9tQ3JlYXRlQ2FsbGJhY2ssIFRvbUl0ZW0sIFRvbVNldHRpbmdzLCBUb21UZW1wbGF0ZU5hbWVzLCBUb21DbGVhckZpbHRlciwgUmVjdXJzaXZlUGFydGlhbCB9IGZyb20gJy4vdHlwZXMvaW5kZXgnO1xuaW1wb3J0IHtoaWdobGlnaHQsIHJlbW92ZUhpZ2hsaWdodH0gZnJvbSAnLi9jb250cmliL2hpZ2hsaWdodCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IGdldFNldHRpbmdzIGZyb20gJy4vZ2V0U2V0dGluZ3MnO1xuaW1wb3J0IHtcblx0aGFzaF9rZXksXG5cdGdldF9oYXNoLFxuXHRlc2NhcGVfaHRtbCxcblx0ZGVib3VuY2VfZXZlbnRzLFxuXHRnZXRTZWxlY3Rpb24sXG5cdHByZXZlbnREZWZhdWx0LFxuXHRhZGRFdmVudCxcblx0bG9hZERlYm91bmNlLFxuXHR0aW1lb3V0LFxuXHRpc0tleURvd24sXG5cdGdldElkLFxuXHRhZGRTbGFzaGVzLFxuXHRhcHBlbmRcbn0gZnJvbSAnLi91dGlscyc7XG5cbmltcG9ydCB7XG5cdGdldERvbSxcblx0aXNIdG1sU3RyaW5nLFxuXHRlc2NhcGVRdWVyeSxcblx0dHJpZ2dlckV2ZW50LFxuXHRhcHBseUNTUyxcblx0YWRkQ2xhc3Nlcyxcblx0cmVtb3ZlQ2xhc3Nlcyxcblx0cGFyZW50TWF0Y2gsXG5cdGdldFRhaWwsXG5cdGlzRW1wdHlPYmplY3QsXG5cdG5vZGVJbmRleCxcblx0c2V0QXR0cixcblx0cmVwbGFjZU5vZGVcbn0gZnJvbSAnLi92YW5pbGxhJztcblxudmFyIGluc3RhbmNlX2kgPSAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb21TZWxlY3QgZXh0ZW5kcyBNaWNyb1BsdWdpbihNaWNyb0V2ZW50KXtcblxuXHRwdWJsaWMgY29udHJvbF9pbnB1dFx0XHRcdDogSFRNTElucHV0RWxlbWVudDtcblx0cHVibGljIHdyYXBwZXJcdFx0XHRcdFx0OiBIVE1MRWxlbWVudDtcblx0cHVibGljIGRyb3Bkb3duXHRcdFx0XHRcdDogSFRNTEVsZW1lbnQ7XG5cdHB1YmxpYyBjb250cm9sXHRcdFx0XHRcdDogSFRNTEVsZW1lbnQ7XG5cdHB1YmxpYyBkcm9wZG93bl9jb250ZW50XHRcdFx0OiBIVE1MRWxlbWVudDtcblx0cHVibGljIGZvY3VzX25vZGVcdFx0XHRcdDogSFRNTEVsZW1lbnQ7XG5cblx0cHVibGljIG9yZGVyXHRcdFx0XHRcdDogbnVtYmVyID0gMDtcblx0cHVibGljIHNldHRpbmdzXHRcdFx0XHRcdDogVG9tU2V0dGluZ3M7XG5cdHB1YmxpYyBpbnB1dFx0XHRcdFx0XHQ6IFRvbUlucHV0O1xuXHRwdWJsaWMgdGFiSW5kZXhcdFx0XHRcdFx0OiBudW1iZXI7XG5cdHB1YmxpYyBpc19zZWxlY3RfdGFnXHRcdFx0OiBib29sZWFuO1xuXHRwdWJsaWMgcnRsXHRcdFx0XHRcdFx0OiBib29sZWFuO1xuXHRwcml2YXRlIGlucHV0SWRcdFx0XHRcdFx0OiBzdHJpbmc7XG5cblx0cHJpdmF0ZSBfZGVzdHJveVx0XHRcdFx0ITogKCkgPT4gdm9pZDtcblx0cHVibGljIHNpZnRlclx0XHRcdFx0XHQ6IFNpZnRlcjtcblxuXG5cdHB1YmxpYyBpc09wZW5cdFx0XHRcdFx0OiBib29sZWFuID0gZmFsc2U7XG5cdHB1YmxpYyBpc0Rpc2FibGVkXHRcdFx0XHQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHVibGljIGlzUmVhZE9ubHlcdFx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgaXNSZXF1aXJlZFx0XHRcdFx0OiBib29sZWFuO1xuXHRwdWJsaWMgaXNJbnZhbGlkXHRcdFx0XHQ6IGJvb2xlYW4gPSBmYWxzZTsgLy8gQGRlcHJlY2F0ZWQgMS44XG5cdHB1YmxpYyBpc1ZhbGlkXHRcdFx0XHRcdDogYm9vbGVhbiA9IHRydWU7XG5cdHB1YmxpYyBpc0xvY2tlZFx0XHRcdFx0XHQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHVibGljIGlzRm9jdXNlZFx0XHRcdFx0OiBib29sZWFuID0gZmFsc2U7XG5cdHB1YmxpYyBpc0lucHV0SGlkZGVuXHRcdFx0OiBib29sZWFuID0gZmFsc2U7XG5cdHB1YmxpYyBpc1NldHVwXHRcdFx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgaWdub3JlRm9jdXNcdFx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgaWdub3JlSG92ZXJcdFx0XHRcdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRwdWJsaWMgaGFzT3B0aW9uc1x0XHRcdFx0OiBib29sZWFuID0gZmFsc2U7XG5cdHB1YmxpYyBjdXJyZW50UmVzdWx0c1x0XHRcdD86IFJldHVyblR5cGU8U2lmdGVyWydzZWFyY2gnXT47XG5cdHB1YmxpYyBsYXN0VmFsdWVcdFx0XHRcdDogc3RyaW5nID0gJyc7XG5cdHB1YmxpYyBjYXJldFBvc1x0XHRcdFx0XHQ6IG51bWJlciA9IDA7XG5cdHB1YmxpYyBsb2FkaW5nXHRcdFx0XHRcdDogbnVtYmVyID0gMDtcblx0cHVibGljIGxvYWRlZFNlYXJjaGVzXHRcdFx0OiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuXG5cdHB1YmxpYyBhY3RpdmVPcHRpb25cdFx0XHRcdDogbnVsbHxIVE1MRWxlbWVudCA9IG51bGw7XG5cdHB1YmxpYyBhY3RpdmVJdGVtc1x0XHRcdFx0OiBUb21JdGVtW10gPSBbXTtcblxuXHRwdWJsaWMgb3B0Z3JvdXBzXHRcdFx0XHQ6IFRvbU9wdGlvbnMgPSB7fTtcblx0cHVibGljIG9wdGlvbnNcdFx0XHRcdFx0OiBUb21PcHRpb25zID0ge307XG5cdHB1YmxpYyB1c2VyT3B0aW9uc1x0XHRcdFx0OiB7W2tleTpzdHJpbmddOmJvb2xlYW59ID0ge307XG5cdHB1YmxpYyBpdGVtc1x0XHRcdFx0XHQ6IHN0cmluZ1tdID0gW107XG5cblx0cHJpdmF0ZSByZWZyZXNoVGltZW91dFx0XHRcdDogbnVsbHxSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiA9IG51bGw7XG5cblxuXHRjb25zdHJ1Y3RvciggaW5wdXRfYXJnOiBzdHJpbmd8VG9tSW5wdXQsIHVzZXJfc2V0dGluZ3M6UmVjdXJzaXZlUGFydGlhbDxUb21TZXR0aW5ncz4gKXtcblx0XHRzdXBlcigpO1xuXG5cdFx0aW5zdGFuY2VfaSsrO1xuXG5cdFx0dmFyIGRpcjtcblx0XHR2YXIgaW5wdXRcdFx0XHRcdD0gZ2V0RG9tKCBpbnB1dF9hcmcgKSBhcyBUb21JbnB1dDtcblxuXHRcdGlmKCBpbnB1dC50b21zZWxlY3QgKXtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVG9tIFNlbGVjdCBhbHJlYWR5IGluaXRpYWxpemVkIG9uIHRoaXMgZWxlbWVudCcpO1xuXHRcdH1cblxuXG5cdFx0aW5wdXQudG9tc2VsZWN0XHRcdFx0PSB0aGlzO1xuXG5cblx0XHQvLyBkZXRlY3QgcnRsIGVudmlyb25tZW50XG5cdFx0dmFyIGNvbXB1dGVkU3R5bGVcdFx0PSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbnB1dCwgbnVsbCk7XG5cdFx0ZGlyXHRcdFx0XHRcdFx0PSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpO1xuXG5cdFx0Ly8gc2V0dXAgZGVmYXVsdCBzdGF0ZVxuXHRcdGNvbnN0IHNldHRpbmdzXHRcdFx0PSBnZXRTZXR0aW5ncyggaW5wdXQsIHVzZXJfc2V0dGluZ3MgKTtcblx0XHR0aGlzLnNldHRpbmdzXHRcdFx0PSBzZXR0aW5ncztcblx0XHR0aGlzLmlucHV0XHRcdFx0XHQ9IGlucHV0O1xuXHRcdHRoaXMudGFiSW5kZXhcdFx0XHQ9IGlucHV0LnRhYkluZGV4IHx8IDA7XG5cdFx0dGhpcy5pc19zZWxlY3RfdGFnXHRcdD0gaW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0Jztcblx0XHR0aGlzLnJ0bFx0XHRcdFx0PSAvcnRsL2kudGVzdChkaXIpO1xuXHRcdHRoaXMuaW5wdXRJZFx0XHRcdD0gZ2V0SWQoaW5wdXQsICd0b21zZWxlY3QtJytpbnN0YW5jZV9pKTtcblx0XHR0aGlzLmlzUmVxdWlyZWRcdFx0XHQ9IGlucHV0LnJlcXVpcmVkO1xuXG5cblx0XHQvLyBzZWFyY2ggc3lzdGVtXG5cdFx0dGhpcy5zaWZ0ZXIgPSBuZXcgU2lmdGVyKHRoaXMub3B0aW9ucywge2RpYWNyaXRpY3M6IHNldHRpbmdzLmRpYWNyaXRpY3N9KTtcblxuXHRcdC8vIG9wdGlvbi1kZXBlbmRlbnQgZGVmYXVsdHNcblx0XHRzZXR0aW5ncy5tb2RlID0gc2V0dGluZ3MubW9kZSB8fCAoc2V0dGluZ3MubWF4SXRlbXMgPT09IDEgPyAnc2luZ2xlJyA6ICdtdWx0aScpO1xuXHRcdGlmICh0eXBlb2Ygc2V0dGluZ3MuaGlkZVNlbGVjdGVkICE9PSAnYm9vbGVhbicpIHtcblx0XHRcdHNldHRpbmdzLmhpZGVTZWxlY3RlZCA9IHNldHRpbmdzLm1vZGUgPT09ICdtdWx0aSc7XG5cdFx0fVxuXG5cdFx0aWYoIHR5cGVvZiBzZXR0aW5ncy5oaWRlUGxhY2Vob2xkZXIgIT09ICdib29sZWFuJyApe1xuXHRcdFx0c2V0dGluZ3MuaGlkZVBsYWNlaG9sZGVyID0gc2V0dGluZ3MubW9kZSAhPT0gJ211bHRpJztcblx0XHR9XG5cblx0XHQvLyBzZXQgdXAgY3JlYXRlRmlsdGVyIGNhbGxiYWNrXG5cdFx0dmFyIGZpbHRlciA9IHNldHRpbmdzLmNyZWF0ZUZpbHRlcjtcblx0XHRpZiggdHlwZW9mIGZpbHRlciAhPT0gJ2Z1bmN0aW9uJyApe1xuXG5cdFx0XHRpZiggdHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycgKXtcblx0XHRcdFx0ZmlsdGVyID0gbmV3IFJlZ0V4cChmaWx0ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggZmlsdGVyIGluc3RhbmNlb2YgUmVnRXhwICl7XG5cdFx0XHRcdHNldHRpbmdzLmNyZWF0ZUZpbHRlciA9IChpbnB1dCkgPT4gKGZpbHRlciBhcyBSZWdFeHApLnRlc3QoaW5wdXQpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHNldHRpbmdzLmNyZWF0ZUZpbHRlciA9ICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnNldHRpbmdzLmR1cGxpY2F0ZXMgfHwgIXRoaXMub3B0aW9uc1t2YWx1ZV07XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHR0aGlzLmluaXRpYWxpemVQbHVnaW5zKHNldHRpbmdzLnBsdWdpbnMpO1xuXHRcdHRoaXMuc2V0dXBDYWxsYmFja3MoKTtcblx0XHR0aGlzLnNldHVwVGVtcGxhdGVzKCk7XG5cblxuXHRcdC8vIENyZWF0ZSBhbGwgZWxlbWVudHNcblx0XHRjb25zdCB3cmFwcGVyXHRcdFx0PSBnZXREb20oJzxkaXY+Jyk7XG5cdFx0Y29uc3QgY29udHJvbFx0XHRcdD0gZ2V0RG9tKCc8ZGl2PicpO1xuXHRcdGNvbnN0IGRyb3Bkb3duXHRcdFx0PSB0aGlzLl9yZW5kZXIoJ2Ryb3Bkb3duJyk7XG5cdFx0Y29uc3QgZHJvcGRvd25fY29udGVudFx0PSBnZXREb20oYDxkaXYgcm9sZT1cImxpc3Rib3hcIiB0YWJpbmRleD1cIi0xXCI+YCk7XG5cblx0XHRjb25zdCBjbGFzc2VzXHRcdFx0PSB0aGlzLmlucHV0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcblx0XHRjb25zdCBpbnB1dE1vZGVcdFx0XHQ9IHNldHRpbmdzLm1vZGU7XG5cblx0XHR2YXIgY29udHJvbF9pbnB1dDogSFRNTElucHV0RWxlbWVudDtcblxuXG5cdFx0YWRkQ2xhc3Nlcyggd3JhcHBlciwgc2V0dGluZ3Mud3JhcHBlckNsYXNzLCBjbGFzc2VzLCBpbnB1dE1vZGUpO1xuXG5cblx0XHRhZGRDbGFzc2VzKGNvbnRyb2wsc2V0dGluZ3MuY29udHJvbENsYXNzKTtcblx0XHRhcHBlbmQoIHdyYXBwZXIsIGNvbnRyb2wgKTtcblxuXG5cdFx0YWRkQ2xhc3Nlcyhkcm9wZG93biwgc2V0dGluZ3MuZHJvcGRvd25DbGFzcywgaW5wdXRNb2RlKTtcblx0XHRpZiggc2V0dGluZ3MuY29weUNsYXNzZXNUb0Ryb3Bkb3duICl7XG5cdFx0XHRhZGRDbGFzc2VzKCBkcm9wZG93biwgY2xhc3Nlcyk7XG5cdFx0fVxuXG5cblx0XHRhZGRDbGFzc2VzKGRyb3Bkb3duX2NvbnRlbnQsIHNldHRpbmdzLmRyb3Bkb3duQ29udGVudENsYXNzKTtcblx0XHRhcHBlbmQoIGRyb3Bkb3duLCBkcm9wZG93bl9jb250ZW50ICk7XG5cblx0XHRnZXREb20oIHNldHRpbmdzLmRyb3Bkb3duUGFyZW50IHx8IHdyYXBwZXIgKS5hcHBlbmRDaGlsZCggZHJvcGRvd24gKTtcblxuXG5cdFx0Ly8gZGVmYXVsdCBjb250cm9sSW5wdXRcblx0XHRpZiggaXNIdG1sU3RyaW5nKHNldHRpbmdzLmNvbnRyb2xJbnB1dCkgKXtcblx0XHRcdGNvbnRyb2xfaW5wdXRcdFx0PSBnZXREb20oc2V0dGluZ3MuY29udHJvbElucHV0ICkgYXMgSFRNTElucHV0RWxlbWVudDtcblxuXHRcdFx0Ly8gc2V0IGF0dHJpYnV0ZXNcblx0XHRcdHZhciBhdHRycyA9IFsnYXV0b2NvcnJlY3QnLCdhdXRvY2FwaXRhbGl6ZScsJ2F1dG9jb21wbGV0ZScsJ3NwZWxsY2hlY2snXTtcblx0XHRcdGl0ZXJhdGUoYXR0cnMsKGF0dHI6c3RyaW5nKSA9PiB7XG5cdFx0XHRcdGlmKCBpbnB1dC5nZXRBdHRyaWJ1dGUoYXR0cikgKXtcblx0XHRcdFx0XHRzZXRBdHRyKGNvbnRyb2xfaW5wdXQse1thdHRyXTppbnB1dC5nZXRBdHRyaWJ1dGUoYXR0cil9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGNvbnRyb2xfaW5wdXQudGFiSW5kZXggPSAtMTtcblx0XHRcdGNvbnRyb2wuYXBwZW5kQ2hpbGQoIGNvbnRyb2xfaW5wdXQgKTtcblx0XHRcdHRoaXMuZm9jdXNfbm9kZVx0XHQ9IGNvbnRyb2xfaW5wdXQ7XG5cblx0XHQvLyBkb20gZWxlbWVudFxuXHRcdH1lbHNlIGlmKCBzZXR0aW5ncy5jb250cm9sSW5wdXQgKXtcblx0XHRcdGNvbnRyb2xfaW5wdXRcdFx0PSBnZXREb20oIHNldHRpbmdzLmNvbnRyb2xJbnB1dCApIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cdFx0XHR0aGlzLmZvY3VzX25vZGVcdFx0PSBjb250cm9sX2lucHV0O1xuXG5cdFx0fWVsc2V7XG5cdFx0XHRjb250cm9sX2lucHV0XHRcdD0gZ2V0RG9tKCc8aW5wdXQvPicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cdFx0XHR0aGlzLmZvY3VzX25vZGVcdFx0PSBjb250cm9sO1xuXHRcdH1cblxuXHRcdHRoaXMud3JhcHBlclx0XHRcdD0gd3JhcHBlcjtcblx0XHR0aGlzLmRyb3Bkb3duXHRcdFx0PSBkcm9wZG93bjtcblx0XHR0aGlzLmRyb3Bkb3duX2NvbnRlbnRcdD0gZHJvcGRvd25fY29udGVudDtcblx0XHR0aGlzLmNvbnRyb2wgXHRcdFx0PSBjb250cm9sO1xuXHRcdHRoaXMuY29udHJvbF9pbnB1dFx0XHQ9IGNvbnRyb2xfaW5wdXQ7XG5cblx0XHR0aGlzLnNldHVwKCk7XG5cdH1cblxuXHQvKipcblx0ICogc2V0IHVwIGV2ZW50IGJpbmRpbmdzLlxuXHQgKlxuXHQgKi9cblx0c2V0dXAoKXtcblxuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdGNvbnN0IHNldHRpbmdzXHRcdFx0XHQ9IHNlbGYuc2V0dGluZ3M7XG5cdFx0Y29uc3QgY29udHJvbF9pbnB1dFx0XHRcdD0gc2VsZi5jb250cm9sX2lucHV0O1xuXHRcdGNvbnN0IGRyb3Bkb3duXHRcdFx0XHQ9IHNlbGYuZHJvcGRvd247XG5cdFx0Y29uc3QgZHJvcGRvd25fY29udGVudFx0XHQ9IHNlbGYuZHJvcGRvd25fY29udGVudDtcblx0XHRjb25zdCB3cmFwcGVyXHRcdFx0XHQ9IHNlbGYud3JhcHBlcjtcblx0XHRjb25zdCBjb250cm9sXHRcdFx0XHQ9IHNlbGYuY29udHJvbDtcblx0XHRjb25zdCBpbnB1dFx0XHRcdFx0XHQ9IHNlbGYuaW5wdXQ7XG5cdFx0Y29uc3QgZm9jdXNfbm9kZVx0XHRcdD0gc2VsZi5mb2N1c19ub2RlO1xuXHRcdGNvbnN0IHBhc3NpdmVfZXZlbnRcdFx0XHQ9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuXHRcdGNvbnN0IGxpc3Rib3hJZFx0XHRcdFx0PSBzZWxmLmlucHV0SWQgKyctdHMtZHJvcGRvd24nO1xuXG5cblx0XHRzZXRBdHRyKGRyb3Bkb3duX2NvbnRlbnQse1xuXHRcdFx0aWQ6IGxpc3Rib3hJZFxuXHRcdH0pO1xuXG5cdFx0c2V0QXR0cihmb2N1c19ub2RlLHtcblx0XHRcdHJvbGU6J2NvbWJvYm94Jyxcblx0XHRcdCdhcmlhLWhhc3BvcHVwJzonbGlzdGJveCcsXG5cdFx0XHQnYXJpYS1leHBhbmRlZCc6J2ZhbHNlJyxcblx0XHRcdCdhcmlhLWNvbnRyb2xzJzpsaXN0Ym94SWRcblx0XHR9KTtcblxuXHRcdGNvbnN0IGNvbnRyb2xfaWRcdD0gZ2V0SWQoZm9jdXNfbm9kZSxzZWxmLmlucHV0SWQgKyAnLXRzLWNvbnRyb2wnKTtcblx0XHRjb25zdCBxdWVyeVx0XHRcdD0gXCJsYWJlbFtmb3I9J1wiK2VzY2FwZVF1ZXJ5KHNlbGYuaW5wdXRJZCkrXCInXVwiO1xuXHRcdGNvbnN0IGxhYmVsXHRcdFx0PSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcblx0XHRjb25zdCBsYWJlbF9jbGlja1x0PSBzZWxmLmZvY3VzLmJpbmQoc2VsZik7XG5cdFx0aWYoIGxhYmVsICl7XG5cdFx0XHRhZGRFdmVudChsYWJlbCwnY2xpY2snLCBsYWJlbF9jbGljayApO1xuXHRcdFx0c2V0QXR0cihsYWJlbCx7Zm9yOmNvbnRyb2xfaWR9KTtcblx0XHRcdGNvbnN0IGxhYmVsX2lkID0gZ2V0SWQobGFiZWwsc2VsZi5pbnB1dElkKyctdHMtbGFiZWwnKTtcblx0XHRcdHNldEF0dHIoZm9jdXNfbm9kZSx7J2FyaWEtbGFiZWxsZWRieSc6bGFiZWxfaWR9KTtcblx0XHRcdHNldEF0dHIoZHJvcGRvd25fY29udGVudCx7J2FyaWEtbGFiZWxsZWRieSc6bGFiZWxfaWR9KTtcblx0XHR9XG5cblx0XHR3cmFwcGVyLnN0eWxlLndpZHRoID0gaW5wdXQuc3R5bGUud2lkdGg7XG5cblx0XHRpZiAoc2VsZi5wbHVnaW5zLm5hbWVzLmxlbmd0aCkge1xuXHRcdFx0Y29uc3QgY2xhc3Nlc19wbHVnaW5zID0gJ3BsdWdpbi0nICsgc2VsZi5wbHVnaW5zLm5hbWVzLmpvaW4oJyBwbHVnaW4tJyk7XG5cdFx0XHRhZGRDbGFzc2VzKCBbd3JhcHBlcixkcm9wZG93bl0sIGNsYXNzZXNfcGx1Z2lucyk7XG5cdFx0fVxuXG5cdFx0aWYgKChzZXR0aW5ncy5tYXhJdGVtcyA9PT0gbnVsbCB8fCBzZXR0aW5ncy5tYXhJdGVtcyA+IDEpICYmIHNlbGYuaXNfc2VsZWN0X3RhZyApe1xuXHRcdFx0c2V0QXR0cihpbnB1dCx7bXVsdGlwbGU6J211bHRpcGxlJ30pO1xuXHRcdH1cblxuXHRcdGlmIChzZXR0aW5ncy5wbGFjZWhvbGRlcikge1xuXHRcdFx0c2V0QXR0cihjb250cm9sX2lucHV0LHtwbGFjZWhvbGRlcjpzZXR0aW5ncy5wbGFjZWhvbGRlcn0pO1xuXHRcdH1cblxuXHRcdC8vIGlmIHNwbGl0T24gd2FzIG5vdCBwYXNzZWQgaW4sIGNvbnN0cnVjdCBpdCBmcm9tIHRoZSBkZWxpbWl0ZXIgdG8gYWxsb3cgcGFzdGluZyB1bml2ZXJzYWxseVxuXHRcdGlmICghc2V0dGluZ3Muc3BsaXRPbiAmJiBzZXR0aW5ncy5kZWxpbWl0ZXIpIHtcblx0XHRcdHNldHRpbmdzLnNwbGl0T24gPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlX3JlZ2V4KHNldHRpbmdzLmRlbGltaXRlcikgKyAnK1xcXFxzKicpO1xuXHRcdH1cblxuXHRcdC8vIGRlYm91bmNlIHVzZXIgZGVmaW5lZCBsb2FkKCkgaWYgbG9hZFRocm90dGxlID4gMFxuXHRcdC8vIGFmdGVyIGluaXRpYWxpemVQbHVnaW5zKCkgc28gcGx1Z2lucyBjYW4gY3JlYXRlL21vZGlmeSB1c2VyIGRlZmluZWQgbG9hZGVyc1xuXHRcdGlmKCBzZXR0aW5ncy5sb2FkICYmIHNldHRpbmdzLmxvYWRUaHJvdHRsZSApe1xuXHRcdFx0c2V0dGluZ3MubG9hZCA9IGxvYWREZWJvdW5jZShzZXR0aW5ncy5sb2FkLHNldHRpbmdzLmxvYWRUaHJvdHRsZSlcblx0XHR9XG5cblx0XHRhZGRFdmVudChkcm9wZG93biwnbW91c2Vtb3ZlJywgKCkgPT4ge1xuXHRcdFx0c2VsZi5pZ25vcmVIb3ZlciA9IGZhbHNlO1xuXHRcdH0pO1xuXG5cdFx0YWRkRXZlbnQoZHJvcGRvd24sJ21vdXNlZW50ZXInLCAoZSkgPT4ge1xuXG5cdFx0XHR2YXIgdGFyZ2V0X21hdGNoID0gcGFyZW50TWF0Y2goZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQsICdbZGF0YS1zZWxlY3RhYmxlXScsIGRyb3Bkb3duKTtcblx0XHRcdGlmKCB0YXJnZXRfbWF0Y2ggKSBzZWxmLm9uT3B0aW9uSG92ZXIoIGUgYXMgTW91c2VFdmVudCwgdGFyZ2V0X21hdGNoICk7XG5cblx0XHR9LCB7Y2FwdHVyZTp0cnVlfSk7XG5cblx0XHQvLyBjbGlja2luZyBvbiBhbiBvcHRpb24gc2hvdWxkIHNlbGVjdCBpdFxuXHRcdGFkZEV2ZW50KGRyb3Bkb3duLCdjbGljaycsKGV2dCkgPT4ge1xuXHRcdFx0Y29uc3Qgb3B0aW9uID0gcGFyZW50TWF0Y2goZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG5cdFx0XHRpZiggb3B0aW9uICl7XG5cdFx0XHRcdHNlbGYub25PcHRpb25TZWxlY3QoIGV2dCBhcyBNb3VzZUV2ZW50LCBvcHRpb24gKTtcblx0XHRcdFx0cHJldmVudERlZmF1bHQoZXZ0LHRydWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YWRkRXZlbnQoY29udHJvbCwnY2xpY2snLCAoZXZ0KSA9PiB7XG5cblx0XHRcdHZhciB0YXJnZXRfbWF0Y2ggPSBwYXJlbnRNYXRjaCggZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgJ1tkYXRhLXRzLWl0ZW1dJywgY29udHJvbCk7XG5cdFx0XHRpZiggdGFyZ2V0X21hdGNoICYmIHNlbGYub25JdGVtU2VsZWN0KGV2dCBhcyBNb3VzZUV2ZW50LCB0YXJnZXRfbWF0Y2ggYXMgVG9tSXRlbSkgKXtcblx0XHRcdFx0cHJldmVudERlZmF1bHQoZXZ0LHRydWUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJldGFpbiBmb2N1cyAoc2VlIGNvbnRyb2xfaW5wdXQgbW91c2Vkb3duKVxuXHRcdFx0aWYoIGNvbnRyb2xfaW5wdXQudmFsdWUgIT0gJycgKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxmLm9uQ2xpY2soKTtcblx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCx0cnVlKTtcblx0XHR9KTtcblxuXG5cdFx0Ly8ga2V5ZG93biBvbiBmb2N1c19ub2RlIGZvciBhcnJvd19kb3duL2Fycm93X3VwXG5cdFx0YWRkRXZlbnQoZm9jdXNfbm9kZSwna2V5ZG93bicsXHRcdChlKSA9PiBzZWxmLm9uS2V5RG93bihlIGFzIEtleWJvYXJkRXZlbnQpICk7XG5cblx0XHQvLyBrZXlwcmVzcyBhbmQgaW5wdXQva2V5dXBcblx0XHRhZGRFdmVudChjb250cm9sX2lucHV0LCdrZXlwcmVzcycsXHQoZSkgPT4gc2VsZi5vbktleVByZXNzKGUgYXMgS2V5Ym9hcmRFdmVudCkgKTtcblx0XHRhZGRFdmVudChjb250cm9sX2lucHV0LCdpbnB1dCcsXHRcdChlKSA9PiBzZWxmLm9uSW5wdXQoZSBhcyBLZXlib2FyZEV2ZW50KSApO1xuXHRcdGFkZEV2ZW50KGZvY3VzX25vZGUsJ2JsdXInLCBcdFx0KGUpID0+IHNlbGYub25CbHVyKGUgYXMgRm9jdXNFdmVudCkgKTtcblx0XHRhZGRFdmVudChmb2N1c19ub2RlLCdmb2N1cycsXHRcdChlKSA9PiBzZWxmLm9uRm9jdXMoZSBhcyBNb3VzZUV2ZW50KSApO1xuXHRcdGFkZEV2ZW50KGNvbnRyb2xfaW5wdXQsJ3Bhc3RlJyxcdFx0KGUpID0+IHNlbGYub25QYXN0ZShlIGFzIE1vdXNlRXZlbnQpICk7XG5cblxuXHRcdGNvbnN0IGRvY19tb3VzZWRvd24gPSAoZXZ0OkV2ZW50KSA9PiB7XG5cblx0XHRcdC8vIGJsdXIgaWYgdGFyZ2V0IGlzIG91dHNpZGUgb2YgdGhpcyBpbnN0YW5jZVxuXHRcdFx0Ly8gZHJvcGRvd24gaXMgbm90IGFsd2F5cyBpbnNpZGUgd3JhcHBlclxuXHRcdFx0Y29uc3QgdGFyZ2V0ID0gZXZ0LmNvbXBvc2VkUGF0aCgpWzBdO1xuXHRcdFx0aWYoICF3cmFwcGVyLmNvbnRhaW5zKHRhcmdldCBhcyBIVE1MRWxlbWVudCkgJiYgIWRyb3Bkb3duLmNvbnRhaW5zKHRhcmdldCBhcyBIVE1MRWxlbWVudCkgKXtcblx0XHRcdFx0aWYgKHNlbGYuaXNGb2N1c2VkKSB7XG5cdFx0XHRcdFx0c2VsZi5ibHVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXG5cdFx0XHQvLyByZXRhaW4gZm9jdXMgYnkgcHJldmVudGluZyBuYXRpdmUgaGFuZGxpbmcuIGlmIHRoZVxuXHRcdFx0Ly8gZXZlbnQgdGFyZ2V0IGlzIHRoZSBpbnB1dCBpdCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxuXHRcdFx0Ly8gb3RoZXJ3aXNlLCB0ZXh0IHNlbGVjdGlvbiB3aXRoaW4gdGhlIGlucHV0IHdvbid0IHdvcmsuXG5cdFx0XHQvLyBGaXhlcyBidWcgIzIxMiB3aGljaCBpcyBubyBjb3ZlcmVkIGJ5IHRlc3RzXG5cdFx0XHRpZiggdGFyZ2V0ID09IGNvbnRyb2xfaW5wdXQgJiYgc2VsZi5pc09wZW4gKXtcblx0XHRcdFx0ZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHQvLyBjbGlja2luZyBhbnl3aGVyZSBpbiB0aGUgY29udHJvbCBzaG91bGQgbm90IGJsdXIgdGhlIGNvbnRyb2xfaW5wdXQgKHdoaWNoIHdvdWxkIGNsb3NlIHRoZSBkcm9wZG93bilcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChldnQsdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0Y29uc3Qgd2luX3Njcm9sbCA9ICgpID0+IHtcblx0XHRcdGlmIChzZWxmLmlzT3Blbikge1xuXHRcdFx0XHRzZWxmLnBvc2l0aW9uRHJvcGRvd24oKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cblx0XHRhZGRFdmVudChkb2N1bWVudCwnbW91c2Vkb3duJywgZG9jX21vdXNlZG93bik7XG5cdFx0YWRkRXZlbnQod2luZG93LCdzY3JvbGwnLCB3aW5fc2Nyb2xsLCBwYXNzaXZlX2V2ZW50KTtcblx0XHRhZGRFdmVudCh3aW5kb3csJ3Jlc2l6ZScsIHdpbl9zY3JvbGwsIHBhc3NpdmVfZXZlbnQpO1xuXG5cdFx0dGhpcy5fZGVzdHJveSA9ICgpID0+IHtcblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsZG9jX21vdXNlZG93bik7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyx3aW5fc2Nyb2xsKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLHdpbl9zY3JvbGwpO1xuXHRcdFx0aWYoIGxhYmVsICkgbGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLGxhYmVsX2NsaWNrKTtcblx0XHR9O1xuXG5cdFx0Ly8gc3RvcmUgb3JpZ2luYWwgaHRtbCBhbmQgdGFiIGluZGV4IHNvIHRoYXQgdGhleSBjYW4gYmVcblx0XHQvLyByZXN0b3JlZCB3aGVuIHRoZSBkZXN0cm95KCkgbWV0aG9kIGlzIGNhbGxlZC5cblx0XHR0aGlzLnJldmVydFNldHRpbmdzID0ge1xuXHRcdFx0aW5uZXJIVE1MIDogaW5wdXQuaW5uZXJIVE1MLFxuXHRcdFx0dGFiSW5kZXggOiBpbnB1dC50YWJJbmRleFxuXHRcdH07XG5cblxuXHRcdGlucHV0LnRhYkluZGV4ID0gLTE7XG5cdFx0aW5wdXQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIHNlbGYud3JhcHBlcik7XG5cblx0XHRzZWxmLnN5bmMoZmFsc2UpO1xuXHRcdHNldHRpbmdzLml0ZW1zID0gW107XG5cdFx0ZGVsZXRlIHNldHRpbmdzLm9wdGdyb3Vwcztcblx0XHRkZWxldGUgc2V0dGluZ3Mub3B0aW9ucztcblxuXHRcdGFkZEV2ZW50KGlucHV0LCdpbnZhbGlkJywgKCkgPT4ge1xuXHRcdFx0aWYoIHNlbGYuaXNWYWxpZCApe1xuXHRcdFx0XHRzZWxmLmlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0c2VsZi5pc0ludmFsaWQgPSB0cnVlO1xuXHRcdFx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0c2VsZi51cGRhdGVPcmlnaW5hbElucHV0KCk7XG5cdFx0c2VsZi5yZWZyZXNoSXRlbXMoKTtcblx0XHRzZWxmLmNsb3NlKGZhbHNlKTtcblx0XHRzZWxmLmlucHV0U3RhdGUoKTtcblx0XHRzZWxmLmlzU2V0dXAgPSB0cnVlO1xuXG5cdFx0aWYoIGlucHV0LmRpc2FibGVkICl7XG5cdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHR9ZWxzZSBpZiggaW5wdXQucmVhZE9ubHkgKXtcblx0XHRcdHNlbGYuc2V0UmVhZE9ubHkodHJ1ZSk7XG5cdFx0fWVsc2V7XG5cdFx0XHRzZWxmLmVuYWJsZSgpOyAvL3NldHMgdGFiSW5kZXhcblx0XHR9XG5cblx0XHRzZWxmLm9uKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcblxuXHRcdGFkZENsYXNzZXMoaW5wdXQsJ3RvbXNlbGVjdGVkJywndHMtaGlkZGVuLWFjY2Vzc2libGUnKTtcblx0XHRzZWxmLnRyaWdnZXIoJ2luaXRpYWxpemUnKTtcblxuXHRcdC8vIHByZWxvYWQgb3B0aW9uc1xuXHRcdGlmIChzZXR0aW5ncy5wcmVsb2FkID09PSB0cnVlKSB7XG5cdFx0XHRzZWxmLnByZWxvYWQoKTtcblx0XHR9XG5cblx0fVxuXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIG9wdGlvbnMgYW5kIG9wdGdyb3Vwc1xuXHQgKlxuXHQgKi9cblx0c2V0dXBPcHRpb25zKG9wdGlvbnM6VG9tT3B0aW9uW10gPSBbXSwgb3B0Z3JvdXBzOlRvbU9wdGlvbltdID0gW10pe1xuXG5cdFx0Ly8gYnVpbGQgb3B0aW9ucyB0YWJsZVxuXHRcdHRoaXMuYWRkT3B0aW9ucyhvcHRpb25zKTtcblxuXG5cdFx0Ly8gYnVpbGQgb3B0Z3JvdXAgdGFibGVcblx0XHRpdGVyYXRlKCBvcHRncm91cHMsIChvcHRncm91cDpUb21PcHRpb24pID0+IHtcblx0XHRcdHRoaXMucmVnaXN0ZXJPcHRpb25Hcm91cChvcHRncm91cCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB1cCBkZWZhdWx0IHJlbmRlcmluZyBmdW5jdGlvbnMuXG5cdCAqL1xuXHRzZXR1cFRlbXBsYXRlcygpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGZpZWxkX2xhYmVsID0gc2VsZi5zZXR0aW5ncy5sYWJlbEZpZWxkO1xuXHRcdHZhciBmaWVsZF9vcHRncm91cCA9IHNlbGYuc2V0dGluZ3Mub3B0Z3JvdXBMYWJlbEZpZWxkO1xuXG5cdFx0dmFyIHRlbXBsYXRlcyA9IHtcblx0XHRcdCdvcHRncm91cCc6IChkYXRhOlRvbU9wdGlvbikgPT4ge1xuXHRcdFx0XHRsZXQgb3B0Z3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdFx0b3B0Z3JvdXAuY2xhc3NOYW1lID0gJ29wdGdyb3VwJztcblx0XHRcdFx0b3B0Z3JvdXAuYXBwZW5kQ2hpbGQoZGF0YS5vcHRpb25zKTtcblx0XHRcdFx0cmV0dXJuIG9wdGdyb3VwO1xuXG5cdFx0XHR9LFxuXHRcdFx0J29wdGdyb3VwX2hlYWRlcic6IChkYXRhOlRvbU9wdGlvbiwgZXNjYXBlOnR5cGVvZiBlc2NhcGVfaHRtbCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gJzxkaXYgY2xhc3M9XCJvcHRncm91cC1oZWFkZXJcIj4nICsgZXNjYXBlKGRhdGFbZmllbGRfb3B0Z3JvdXBdKSArICc8L2Rpdj4nO1xuXHRcdFx0fSxcblx0XHRcdCdvcHRpb24nOiAoZGF0YTpUb21PcHRpb24sIGVzY2FwZTp0eXBlb2YgZXNjYXBlX2h0bWwpID0+IHtcblx0XHRcdFx0cmV0dXJuICc8ZGl2PicgKyBlc2NhcGUoZGF0YVtmaWVsZF9sYWJlbF0pICsgJzwvZGl2Pic7XG5cdFx0XHR9LFxuXHRcdFx0J2l0ZW0nOiAoZGF0YTpUb21PcHRpb24sIGVzY2FwZTp0eXBlb2YgZXNjYXBlX2h0bWwpID0+IHtcblx0XHRcdFx0cmV0dXJuICc8ZGl2PicgKyBlc2NhcGUoZGF0YVtmaWVsZF9sYWJlbF0pICsgJzwvZGl2Pic7XG5cdFx0XHR9LFxuXHRcdFx0J29wdGlvbl9jcmVhdGUnOiAoZGF0YTpUb21PcHRpb24sIGVzY2FwZTp0eXBlb2YgZXNjYXBlX2h0bWwpID0+IHtcblx0XHRcdFx0cmV0dXJuICc8ZGl2IGNsYXNzPVwiY3JlYXRlXCI+QWRkIDxzdHJvbmc+JyArIGVzY2FwZShkYXRhLmlucHV0KSArICc8L3N0cm9uZz4maGVsbGlwOzwvZGl2Pic7XG5cdFx0XHR9LFxuXHRcdFx0J25vX3Jlc3VsdHMnOigpID0+IHtcblx0XHRcdFx0cmV0dXJuICc8ZGl2IGNsYXNzPVwibm8tcmVzdWx0c1wiPk5vIHJlc3VsdHMgZm91bmQ8L2Rpdj4nO1xuXHRcdFx0fSxcblx0XHRcdCdsb2FkaW5nJzooKSA9PiB7XG5cdFx0XHRcdHJldHVybiAnPGRpdiBjbGFzcz1cInNwaW5uZXJcIj48L2Rpdj4nO1xuXHRcdFx0fSxcblx0XHRcdCdub3RfbG9hZGluZyc6KCkgPT4ge30sXG5cdFx0XHQnZHJvcGRvd24nOigpID0+IHtcblx0XHRcdFx0cmV0dXJuICc8ZGl2PjwvZGl2Pic7XG5cdFx0XHR9XG5cdFx0fTtcblxuXG5cdFx0c2VsZi5zZXR0aW5ncy5yZW5kZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0ZW1wbGF0ZXMsIHNlbGYuc2V0dGluZ3MucmVuZGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXBzIGZpcmVkIGV2ZW50cyB0byBjYWxsYmFja3MgcHJvdmlkZWRcblx0ICogaW4gdGhlIHNldHRpbmdzIHVzZWQgd2hlbiBjcmVhdGluZyB0aGUgY29udHJvbC5cblx0ICovXG5cdHNldHVwQ2FsbGJhY2tzKCkge1xuXHRcdHZhciBrZXksIGZuO1xuXHRcdHZhciBjYWxsYmFja3M6e1trZXk6c3RyaW5nXTpzdHJpbmd9ID0ge1xuXHRcdFx0J2luaXRpYWxpemUnICAgICAgOiAnb25Jbml0aWFsaXplJyxcblx0XHRcdCdjaGFuZ2UnICAgICAgICAgIDogJ29uQ2hhbmdlJyxcblx0XHRcdCdpdGVtX2FkZCcgICAgICAgIDogJ29uSXRlbUFkZCcsXG5cdFx0XHQnaXRlbV9yZW1vdmUnICAgICA6ICdvbkl0ZW1SZW1vdmUnLFxuXHRcdFx0J2l0ZW1fc2VsZWN0JyAgICAgOiAnb25JdGVtU2VsZWN0Jyxcblx0XHRcdCdjbGVhcicgICAgICAgICAgIDogJ29uQ2xlYXInLFxuXHRcdFx0J29wdGlvbl9hZGQnICAgICAgOiAnb25PcHRpb25BZGQnLFxuXHRcdFx0J29wdGlvbl9yZW1vdmUnICAgOiAnb25PcHRpb25SZW1vdmUnLFxuXHRcdFx0J29wdGlvbl9jbGVhcicgICAgOiAnb25PcHRpb25DbGVhcicsXG5cdFx0XHQnb3B0Z3JvdXBfYWRkJyAgICA6ICdvbk9wdGlvbkdyb3VwQWRkJyxcblx0XHRcdCdvcHRncm91cF9yZW1vdmUnIDogJ29uT3B0aW9uR3JvdXBSZW1vdmUnLFxuXHRcdFx0J29wdGdyb3VwX2NsZWFyJyAgOiAnb25PcHRpb25Hcm91cENsZWFyJyxcblx0XHRcdCdkcm9wZG93bl9vcGVuJyAgIDogJ29uRHJvcGRvd25PcGVuJyxcblx0XHRcdCdkcm9wZG93bl9jbG9zZScgIDogJ29uRHJvcGRvd25DbG9zZScsXG5cdFx0XHQndHlwZScgICAgICAgICAgICA6ICdvblR5cGUnLFxuXHRcdFx0J2xvYWQnICAgICAgICAgICAgOiAnb25Mb2FkJyxcblx0XHRcdCdmb2N1cycgICAgICAgICAgIDogJ29uRm9jdXMnLFxuXHRcdFx0J2JsdXInICAgICAgICAgICAgOiAnb25CbHVyJ1xuXHRcdH07XG5cblx0XHRmb3IgKGtleSBpbiBjYWxsYmFja3MpIHtcblxuXHRcdFx0Zm4gPSB0aGlzLnNldHRpbmdzW2NhbGxiYWNrc1trZXldIGFzIChrZXlvZiBUb21TZXR0aW5ncyldO1xuXHRcdFx0aWYgKGZuKSB0aGlzLm9uKGtleSwgZm4pO1xuXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFN5bmMgdGhlIFRvbSBTZWxlY3QgaW5zdGFuY2Ugd2l0aCB0aGUgb3JpZ2luYWwgaW5wdXQgb3Igc2VsZWN0XG5cdCAqXG5cdCAqL1xuXHRzeW5jKGdldF9zZXR0aW5nczpib29sZWFuPXRydWUpOnZvaWR7XG5cdFx0Y29uc3Qgc2VsZlx0XHQ9IHRoaXM7XG5cdFx0Y29uc3Qgc2V0dGluZ3NcdD0gZ2V0X3NldHRpbmdzID8gZ2V0U2V0dGluZ3MoIHNlbGYuaW5wdXQsIHtkZWxpbWl0ZXI6c2VsZi5zZXR0aW5ncy5kZWxpbWl0ZXJ9IGFzIFJlY3Vyc2l2ZVBhcnRpYWw8VG9tU2V0dGluZ3M+ICkgOiBzZWxmLnNldHRpbmdzO1xuXG5cdFx0c2VsZi5zZXR1cE9wdGlvbnMoc2V0dGluZ3Mub3B0aW9ucyxzZXR0aW5ncy5vcHRncm91cHMpO1xuXG5cdFx0c2VsZi5zZXRWYWx1ZShzZXR0aW5ncy5pdGVtc3x8W10sdHJ1ZSk7IC8vIHNpbGVudCBwcmV2ZW50cyByZWN1cnNpb25cblxuXHRcdHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDsgLy8gc28gdXBkYXRlZCBvcHRpb25zIHdpbGwgYmUgZGlzcGxheWVkIGluIGRyb3Bkb3duXG5cdH1cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIG1haW4gY29udHJvbCBlbGVtZW50XG5cdCAqIGhhcyBhIGNsaWNrIGV2ZW50LlxuXHQgKlxuXHQgKi9cblx0b25DbGljaygpOnZvaWQge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGlmKCBzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCA+IDAgKXtcblx0XHRcdHNlbGYuY2xlYXJBY3RpdmVJdGVtcygpO1xuXHRcdFx0c2VsZi5mb2N1cygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCBzZWxmLmlzRm9jdXNlZCAmJiBzZWxmLmlzT3BlbiApe1xuXHRcdFx0c2VsZi5ibHVyKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYuZm9jdXMoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQGRlcHJlY2F0ZWQgdjEuN1xuXHQgKlxuXHQgKi9cblx0b25Nb3VzZURvd24oKTp2b2lkIHt9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCBoYXMgYmVlbiBjaGFuZ2VkLlxuXHQgKiBUaGlzIHNob3VsZCBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHRoZSBvcmlnaW5hbCBET01cblx0ICogaW5wdXQgLyBzZWxlY3QgZWxlbWVudC5cblx0ICovXG5cdG9uQ2hhbmdlKCkge1xuXHRcdHRyaWdnZXJFdmVudCh0aGlzLmlucHV0LCAnaW5wdXQnKTtcblx0XHR0cmlnZ2VyRXZlbnQodGhpcy5pbnB1dCwgJ2NoYW5nZScpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IHBhc3RlLlxuXHQgKlxuXHQgKi9cblx0b25QYXN0ZShlOk1vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudCk6dm9pZCB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYoIHNlbGYuaXNJbnB1dEhpZGRlbiB8fCBzZWxmLmlzTG9ja2VkICl7XG5cdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiBhIHJlZ2V4IG9yIHN0cmluZyBpcyBpbmNsdWRlZCwgdGhpcyB3aWxsIHNwbGl0IHRoZSBwYXN0ZWRcblx0XHQvLyBpbnB1dCBhbmQgY3JlYXRlIEl0ZW1zIGZvciBlYWNoIHNlcGFyYXRlIHZhbHVlXG5cdFx0aWYoICFzZWxmLnNldHRpbmdzLnNwbGl0T24gKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXYWl0IGZvciBwYXN0ZWQgdGV4dCB0byBiZSByZWNvZ25pemVkIGluIHZhbHVlXG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHR2YXIgcGFzdGVkVGV4dCA9IHNlbGYuaW5wdXRWYWx1ZSgpO1xuXHRcdFx0aWYoICFwYXN0ZWRUZXh0Lm1hdGNoKHNlbGYuc2V0dGluZ3Muc3BsaXRPbikpe1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNwbGl0SW5wdXQgPSBwYXN0ZWRUZXh0LnRyaW0oKS5zcGxpdChzZWxmLnNldHRpbmdzLnNwbGl0T24pO1xuXHRcdFx0aXRlcmF0ZSggc3BsaXRJbnB1dCwgKHBpZWNlOnN0cmluZykgPT4ge1xuXG5cdFx0XHRcdGNvbnN0IGhhc2ggPSBoYXNoX2tleShwaWVjZSk7XG5cdFx0XHRcdGlmKCBoYXNoICl7XG5cdFx0XHRcdFx0aWYoIHRoaXMub3B0aW9uc1twaWVjZV0gKXtcblx0XHRcdFx0XHRcdHNlbGYuYWRkSXRlbShwaWVjZSk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRzZWxmLmNyZWF0ZUl0ZW0ocGllY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSwgMCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBrZXlwcmVzcy5cblx0ICpcblx0ICovXG5cdG9uS2V5UHJlc3MoZTpLZXlib2FyZEV2ZW50KTp2b2lkIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYoc2VsZi5pc0xvY2tlZCl7XG5cdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGNoYXJhY3RlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS5rZXlDb2RlIHx8IGUud2hpY2gpO1xuXHRcdGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aScgJiYgY2hhcmFjdGVyID09PSBzZWxmLnNldHRpbmdzLmRlbGltaXRlcikge1xuXHRcdFx0c2VsZi5jcmVhdGVJdGVtKCk7XG5cdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4ga2V5ZG93bi5cblx0ICpcblx0ICovXG5cdG9uS2V5RG93bihlOktleWJvYXJkRXZlbnQpOnZvaWQge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdHNlbGYuaWdub3JlSG92ZXIgPSB0cnVlO1xuXG5cdFx0aWYgKHNlbGYuaXNMb2NrZWQpIHtcblx0XHRcdGlmIChlLmtleUNvZGUgIT09IGNvbnN0YW50cy5LRVlfVEFCKSB7XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoZS5rZXlDb2RlKSB7XG5cblx0XHRcdC8vIGN0cmwrQTogc2VsZWN0IGFsbFxuXHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX0E6XG5cdFx0XHRcdGlmKCBpc0tleURvd24oY29uc3RhbnRzLktFWV9TSE9SVENVVCxlKSApe1xuXHRcdFx0XHRcdGlmKCBzZWxmLmNvbnRyb2xfaW5wdXQudmFsdWUgPT0gJycgKXtcblx0XHRcdFx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0XHRcdFx0c2VsZi5zZWxlY3RBbGwoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIGVzYzogY2xvc2UgZHJvcGRvd25cblx0XHRcdGNhc2UgY29uc3RhbnRzLktFWV9FU0M6XG5cdFx0XHRcdGlmIChzZWxmLmlzT3Blbikge1xuXHRcdFx0XHRcdHByZXZlbnREZWZhdWx0KGUsdHJ1ZSk7XG5cdFx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuY2xlYXJBY3RpdmVJdGVtcygpO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIGRvd246IG9wZW4gZHJvcGRvd24gb3IgbW92ZSBzZWxlY3Rpb24gZG93blxuXHRcdFx0Y2FzZSBjb25zdGFudHMuS0VZX0RPV046XG5cdFx0XHRcdGlmICghc2VsZi5pc09wZW4gJiYgc2VsZi5oYXNPcHRpb25zKSB7XG5cdFx0XHRcdFx0c2VsZi5vcGVuKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2VsZi5hY3RpdmVPcHRpb24pIHtcblx0XHRcdFx0XHRsZXQgbmV4dCA9IHNlbGYuZ2V0QWRqYWNlbnQoc2VsZi5hY3RpdmVPcHRpb24sIDEpO1xuXHRcdFx0XHRcdGlmIChuZXh0KSBzZWxmLnNldEFjdGl2ZU9wdGlvbihuZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyB1cDogbW92ZSBzZWxlY3Rpb24gdXBcblx0XHRcdGNhc2UgY29uc3RhbnRzLktFWV9VUDpcblx0XHRcdFx0aWYgKHNlbGYuYWN0aXZlT3B0aW9uKSB7XG5cdFx0XHRcdFx0bGV0IHByZXYgPSBzZWxmLmdldEFkamFjZW50KHNlbGYuYWN0aXZlT3B0aW9uLCAtMSk7XG5cdFx0XHRcdFx0aWYgKHByZXYpIHNlbGYuc2V0QWN0aXZlT3B0aW9uKHByZXYpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIHJldHVybjogc2VsZWN0IGFjdGl2ZSBvcHRpb25cblx0XHRcdGNhc2UgY29uc3RhbnRzLktFWV9SRVRVUk46XG5cdFx0XHRcdGlmKCBzZWxmLmNhblNlbGVjdChzZWxmLmFjdGl2ZU9wdGlvbikgKXtcblx0XHRcdFx0XHRzZWxmLm9uT3B0aW9uU2VsZWN0KGUsc2VsZi5hY3RpdmVPcHRpb24hKTtcblx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdFx0XHQvLyBpZiB0aGUgb3B0aW9uX2NyZWF0ZT1udWxsLCB0aGUgZHJvcGRvd24gbWlnaHQgYmUgY2xvc2VkXG5cdFx0XHRcdH1lbHNlIGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLmNyZWF0ZUl0ZW0oKSkge1xuXHRcdFx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXG5cdFx0XHRcdC8vIGRvbid0IHN1Ym1pdCBmb3JtIHdoZW4gc2VhcmNoaW5nIGZvciBhIHZhbHVlXG5cdFx0XHRcdH1lbHNlIGlmKCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IHNlbGYuY29udHJvbF9pbnB1dCAmJiBzZWxmLmlzT3BlbiApe1xuXHRcdFx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyBsZWZ0OiBtb2RpZml5IGl0ZW0gc2VsZWN0aW9uIHRvIHRoZSBsZWZ0XG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfTEVGVDpcblx0XHRcdFx0c2VsZi5hZHZhbmNlU2VsZWN0aW9uKC0xLCBlKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyByaWdodDogbW9kaWZpeSBpdGVtIHNlbGVjdGlvbiB0byB0aGUgcmlnaHRcblx0XHRcdGNhc2UgY29uc3RhbnRzLktFWV9SSUdIVDpcblx0XHRcdFx0c2VsZi5hZHZhbmNlU2VsZWN0aW9uKDEsIGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIHRhYjogc2VsZWN0IGFjdGl2ZSBvcHRpb24gYW5kL29yIGNyZWF0ZSBpdGVtXG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfVEFCOlxuXG5cdFx0XHRcdGlmKCBzZWxmLnNldHRpbmdzLnNlbGVjdE9uVGFiICl7XG5cdFx0XHRcdFx0aWYoIHNlbGYuY2FuU2VsZWN0KHNlbGYuYWN0aXZlT3B0aW9uKSApe1xuXHRcdFx0XHRcdFx0c2VsZi5vbk9wdGlvblNlbGVjdChlLHNlbGYuYWN0aXZlT3B0aW9uISk7XG5cblx0XHRcdFx0XHRcdC8vIHByZXZlbnQgZGVmYXVsdCBbdGFiXSBiZWhhdmlvdXIgb2YganVtcCB0byB0aGUgbmV4dCBmaWVsZFxuXHRcdFx0XHRcdFx0Ly8gaWYgc2VsZWN0IGlzRnVsbCwgdGhlbiB0aGUgZHJvcGRvd24gd29uJ3QgYmUgb3BlbiBhbmQgW3RhYl0gd2lsbCB3b3JrIG5vcm1hbGx5XG5cdFx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MuY3JlYXRlICYmIHNlbGYuY3JlYXRlSXRlbSgpKSB7XG5cdFx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyBkZWxldGV8YmFja3NwYWNlOiBkZWxldGUgaXRlbXNcblx0XHRcdGNhc2UgY29uc3RhbnRzLktFWV9CQUNLU1BBQ0U6XG5cdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfREVMRVRFOlxuXHRcdFx0XHRzZWxmLmRlbGV0ZVNlbGVjdGlvbihlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGRvbid0IGVudGVyIHRleHQgaW4gdGhlIGNvbnRyb2xfaW5wdXQgd2hlbiBhY3RpdmUgaXRlbXMgYXJlIHNlbGVjdGVkXG5cdFx0aWYoIHNlbGYuaXNJbnB1dEhpZGRlbiAmJiAhaXNLZXlEb3duKGNvbnN0YW50cy5LRVlfU0hPUlRDVVQsZSkgKXtcblx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBrZXl1cC5cblx0ICpcblx0ICovXG5cdG9uSW5wdXQoZTpNb3VzZUV2ZW50fEtleWJvYXJkRXZlbnQpOnZvaWQge1xuXHRcdFxuXHRcdGlmKCB0aGlzLmlzTG9ja2VkICl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmlucHV0VmFsdWUoKTtcblx0XHRpZiggdGhpcy5sYXN0VmFsdWUgPT09IHZhbHVlICkgcmV0dXJuO1xuXHRcdHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG5cdFx0XG5cdFx0aWYoIHZhbHVlID09ICcnICl7XG5cdFx0XHR0aGlzLl9vbklucHV0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoIHRoaXMucmVmcmVzaFRpbWVvdXQgKXtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnJlZnJlc2hUaW1lb3V0KTtcblx0XHR9XG5cblx0XHR0aGlzLnJlZnJlc2hUaW1lb3V0ID0gdGltZW91dCgoKT0+IHtcblx0XHRcdHRoaXMucmVmcmVzaFRpbWVvdXQgPSBudWxsO1xuXHRcdFx0dGhpcy5fb25JbnB1dCgpO1xuXHRcdH0sIHRoaXMuc2V0dGluZ3MucmVmcmVzaFRocm90dGxlKTtcblx0fVxuXG5cdF9vbklucHV0KCk6dm9pZCB7XG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmxhc3RWYWx1ZTtcblxuXHRcdGlmKCB0aGlzLnNldHRpbmdzLnNob3VsZExvYWQuY2FsbCh0aGlzLHZhbHVlKSApe1xuXHRcdFx0dGhpcy5sb2FkKHZhbHVlKTtcblx0XHR9XG5cblx0XHR0aGlzLnJlZnJlc2hPcHRpb25zKCk7XG5cdFx0dGhpcy50cmlnZ2VyKCd0eXBlJywgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIHJvbGxzIG92ZXJcblx0ICogYW4gb3B0aW9uIGluIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gbWVudS5cblx0ICpcblx0ICovXG5cdG9uT3B0aW9uSG92ZXIoIGV2dDpNb3VzZUV2ZW50fEtleWJvYXJkRXZlbnQsIG9wdGlvbjpIVE1MRWxlbWVudCApOnZvaWR7XG5cdFx0aWYoIHRoaXMuaWdub3JlSG92ZXIgKSByZXR1cm47XG5cdFx0dGhpcy5zZXRBY3RpdmVPcHRpb24ob3B0aW9uLCBmYWxzZSk7XG5cdH1cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4gZm9jdXMuXG5cdCAqXG5cdCAqL1xuXHRvbkZvY3VzKGU/Ok1vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudCk6dm9pZCB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciB3YXNGb2N1c2VkID0gc2VsZi5pc0ZvY3VzZWQ7XG5cblx0XHRpZiggc2VsZi5pc0Rpc2FibGVkIHx8IHNlbGYuaXNSZWFkT25seSApe1xuXHRcdFx0c2VsZi5ibHVyKCk7XG5cdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoc2VsZi5pZ25vcmVGb2N1cykgcmV0dXJuO1xuXHRcdHNlbGYuaXNGb2N1c2VkID0gdHJ1ZTtcblx0XHRpZiggc2VsZi5zZXR0aW5ncy5wcmVsb2FkID09PSAnZm9jdXMnICkgc2VsZi5wcmVsb2FkKCk7XG5cblx0XHRpZiAoIXdhc0ZvY3VzZWQpIHNlbGYudHJpZ2dlcignZm9jdXMnKTtcblxuXHRcdGlmICghc2VsZi5hY3RpdmVJdGVtcy5sZW5ndGgpIHtcblx0XHRcdHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHRcdFx0c2VsZi5yZWZyZXNoT3B0aW9ucyghIXNlbGYuc2V0dGluZ3Mub3Blbk9uRm9jdXMpO1xuXHRcdH1cblxuXHRcdHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4gYmx1ci5cblx0ICpcblx0ICovXG5cdG9uQmx1cihlPzpGb2N1c0V2ZW50KTp2b2lkIHtcblxuXHRcdGlmKCBkb2N1bWVudC5oYXNGb2N1cygpID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZiAoIXNlbGYuaXNGb2N1c2VkKSByZXR1cm47XG5cdFx0c2VsZi5pc0ZvY3VzZWQgPSBmYWxzZTtcblx0XHRzZWxmLmlnbm9yZUZvY3VzID0gZmFsc2U7XG5cblx0XHR2YXIgZGVhY3RpdmF0ZSA9ICgpID0+IHtcblx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdHNlbGYuc2V0QWN0aXZlSXRlbSgpO1xuXHRcdFx0c2VsZi5zZXRDYXJldChzZWxmLml0ZW1zLmxlbmd0aCk7XG5cdFx0XHRzZWxmLnRyaWdnZXIoJ2JsdXInKTtcblx0XHR9O1xuXG5cdFx0aWYgKHNlbGYuc2V0dGluZ3MuY3JlYXRlICYmIHNlbGYuc2V0dGluZ3MuY3JlYXRlT25CbHVyKSB7XG5cdFx0XHRzZWxmLmNyZWF0ZUl0ZW0obnVsbCwgZGVhY3RpdmF0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlYWN0aXZhdGUoKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gb3B0aW9uXG5cdCAqIGluIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gbWVudS5cblx0ICpcblx0ICovXG5cdG9uT3B0aW9uU2VsZWN0KCBldnQ6TW91c2VFdmVudHxLZXlib2FyZEV2ZW50LCBvcHRpb246SFRNTEVsZW1lbnQgKXtcblx0XHR2YXIgdmFsdWUsIHNlbGYgPSB0aGlzO1xuXG5cblx0XHQvLyBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIHRyaWdnZXIgYSBvcHRpb24gdW5kZXIgYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdGlmKCBvcHRpb24ucGFyZW50RWxlbWVudCAmJiBvcHRpb24ucGFyZW50RWxlbWVudC5tYXRjaGVzKCdbZGF0YS1kaXNhYmxlZF0nKSApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXG5cdFx0aWYoIG9wdGlvbi5jbGFzc0xpc3QuY29udGFpbnMoJ2NyZWF0ZScpICl7XG5cdFx0XHRzZWxmLmNyZWF0ZUl0ZW0obnVsbCwgKCkgPT4ge1xuXHRcdFx0XHRpZiAoc2VsZi5zZXR0aW5ncy5jbG9zZUFmdGVyU2VsZWN0KSB7XG5cdFx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSBvcHRpb24uZGF0YXNldC52YWx1ZTtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblx0XHRcdFx0c2VsZi5hZGRJdGVtKHZhbHVlKTtcblx0XHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCkge1xuXHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCAhc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQgJiYgZXZ0LnR5cGUgJiYgL2NsaWNrLy50ZXN0KGV2dC50eXBlKSApe1xuXHRcdFx0XHRcdHNlbGYuc2V0QWN0aXZlT3B0aW9uKG9wdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIG9wdGlvbiBjYW4gYmUgc2VsZWN0ZWRcblx0ICpcblx0ICovXG5cdGNhblNlbGVjdChvcHRpb246SFRNTEVsZW1lbnR8bnVsbCk6Ym9vbGVhbntcblxuXHRcdGlmKCB0aGlzLmlzT3BlbiAmJiBvcHRpb24gJiYgdGhpcy5kcm9wZG93bl9jb250ZW50LmNvbnRhaW5zKG9wdGlvbikgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBpdGVtXG5cdCAqIHRoYXQgaGFzIGJlZW4gc2VsZWN0ZWQuXG5cdCAqXG5cdCAqL1xuXHRvbkl0ZW1TZWxlY3QoIGV2dD86TW91c2VFdmVudCwgaXRlbT86VG9tSXRlbSApOmJvb2xlYW57XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYoICFzZWxmLmlzTG9ja2VkICYmIHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ211bHRpJyApe1xuXHRcdFx0cHJldmVudERlZmF1bHQoZXZ0KTtcblx0XHRcdHNlbGYuc2V0QWN0aXZlSXRlbShpdGVtLCBldnQpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIGludm9rZVxuXHQgKiB0aGUgdXNlci1wcm92aWRlZCBvcHRpb24gcHJvdmlkZXIgLyBsb2FkZXJcblx0ICpcblx0ICogTm90ZSwgdGhlcmUgaXMgYSBzdWJ0bGUgZGlmZmVyZW5jZSBiZXR3ZWVuXG5cdCAqIHRoaXMuY2FuTG9hZCgpIGFuZCB0aGlzLnNldHRpbmdzLnNob3VsZExvYWQoKTtcblx0ICpcblx0ICpcdC0gc2V0dGluZ3Muc2hvdWxkTG9hZCgpIGlzIGEgdXNlci1pbnB1dCB2YWxpZGF0b3IuXG5cdCAqXHRXaGVuIGZhbHNlIGlzIHJldHVybmVkLCB0aGUgbm90X2xvYWRpbmcgdGVtcGxhdGVcblx0ICpcdHdpbGwgYmUgYWRkZWQgdG8gdGhlIGRyb3Bkb3duXG5cdCAqXG5cdCAqXHQtIGNhbkxvYWQoKSBpcyBsb3dlciBsZXZlbCB2YWxpZGF0b3IgdGhhdCBjaGVja3Ncblx0ICogXHR0aGUgVG9tIFNlbGVjdCBpbnN0YW5jZS4gVGhlcmUgaXMgbm8gaW5oZXJlbnQgdXNlclxuXHQgKlx0ZmVlZGJhY2sgd2hlbiBjYW5Mb2FkIHJldHVybnMgZmFsc2Vcblx0ICpcblx0ICovXG5cdGNhbkxvYWQodmFsdWU6c3RyaW5nKTpib29sZWFue1xuXG5cdFx0aWYoICF0aGlzLnNldHRpbmdzLmxvYWQgKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYoIHRoaXMubG9hZGVkU2VhcmNoZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogSW52b2tlcyB0aGUgdXNlci1wcm92aWRlZCBvcHRpb24gcHJvdmlkZXIgLyBsb2FkZXIuXG5cdCAqXG5cdCAqL1xuXHRsb2FkKHZhbHVlOnN0cmluZyk6dm9pZCB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiggIXNlbGYuY2FuTG9hZCh2YWx1ZSkgKSByZXR1cm47XG5cblx0XHRhZGRDbGFzc2VzKHNlbGYud3JhcHBlcixzZWxmLnNldHRpbmdzLmxvYWRpbmdDbGFzcyk7XG5cdFx0c2VsZi5sb2FkaW5nKys7XG5cblx0XHRjb25zdCBjYWxsYmFjayA9IHNlbGYubG9hZENhbGxiYWNrLmJpbmQoc2VsZik7XG5cdFx0c2VsZi5zZXR0aW5ncy5sb2FkLmNhbGwoc2VsZiwgdmFsdWUsIGNhbGxiYWNrKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZva2VkIGJ5IHRoZSB1c2VyLXByb3ZpZGVkIG9wdGlvbiBwcm92aWRlclxuXHQgKlxuXHQgKi9cblx0bG9hZENhbGxiYWNrKCBvcHRpb25zOlRvbU9wdGlvbltdLCBvcHRncm91cHM6VG9tT3B0aW9uW10gKTp2b2lke1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdHNlbGYubG9hZGluZyA9IE1hdGgubWF4KHNlbGYubG9hZGluZyAtIDEsIDApO1xuXHRcdHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblxuXHRcdHNlbGYuY2xlYXJBY3RpdmVPcHRpb24oKTsgLy8gd2hlbiBuZXcgcmVzdWx0cyBsb2FkLCBmb2N1cyBzaG91bGQgYmUgb24gZmlyc3Qgb3B0aW9uXG5cdFx0c2VsZi5zZXR1cE9wdGlvbnMob3B0aW9ucyxvcHRncm91cHMpO1xuXG5cdFx0c2VsZi5yZWZyZXNoT3B0aW9ucyhzZWxmLmlzRm9jdXNlZCAmJiAhc2VsZi5pc0lucHV0SGlkZGVuKTtcblxuXHRcdGlmICghc2VsZi5sb2FkaW5nKSB7XG5cdFx0XHRyZW1vdmVDbGFzc2VzKHNlbGYud3JhcHBlcixzZWxmLnNldHRpbmdzLmxvYWRpbmdDbGFzcyk7XG5cdFx0fVxuXG5cdFx0c2VsZi50cmlnZ2VyKCdsb2FkJywgb3B0aW9ucywgb3B0Z3JvdXBzKTtcblx0fVxuXG5cdHByZWxvYWQoKTp2b2lke1xuXHRcdHZhciBjbGFzc0xpc3QgPSB0aGlzLndyYXBwZXIuY2xhc3NMaXN0O1xuXHRcdGlmKCBjbGFzc0xpc3QuY29udGFpbnMoJ3ByZWxvYWRlZCcpICkgcmV0dXJuO1xuXHRcdGNsYXNzTGlzdC5hZGQoJ3ByZWxvYWRlZCcpO1xuXHRcdHRoaXMubG9hZCgnJyk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBpbnB1dCBmaWVsZCBvZiB0aGUgY29udHJvbCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuXHQgKlxuXHQgKi9cblx0c2V0VGV4dGJveFZhbHVlKHZhbHVlOnN0cmluZyA9ICcnKSB7XG5cdFx0dmFyIGlucHV0ID0gdGhpcy5jb250cm9sX2lucHV0O1xuXHRcdHZhciBjaGFuZ2VkID0gaW5wdXQudmFsdWUgIT09IHZhbHVlO1xuXHRcdGlmIChjaGFuZ2VkKSB7XG5cdFx0XHRpbnB1dC52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0dHJpZ2dlckV2ZW50KGlucHV0LCd1cGRhdGUnKTtcblx0XHRcdHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLiBJZiBtdWx0aXBsZSBpdGVtc1xuXHQgKiBjYW4gYmUgc2VsZWN0ZWQgKGUuZy4gPHNlbGVjdCBtdWx0aXBsZT4pLCB0aGlzIHJldHVybnNcblx0ICogYW4gYXJyYXkuIElmIG9ubHkgb25lIGl0ZW0gY2FuIGJlIHNlbGVjdGVkLCB0aGlzXG5cdCAqIHJldHVybnMgYSBzdHJpbmcuXG5cdCAqXG5cdCAqL1xuXHRnZXRWYWx1ZSgpOnN0cmluZ3xzdHJpbmdbXSB7XG5cblx0XHRpZiggdGhpcy5pc19zZWxlY3RfdGFnICYmIHRoaXMuaW5wdXQuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pdGVtcztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5pdGVtcy5qb2luKHRoaXMuc2V0dGluZ3MuZGVsaW1pdGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIHNlbGVjdGVkIGl0ZW1zIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0ICpcblx0ICovXG5cdHNldFZhbHVlKCB2YWx1ZTpzdHJpbmd8c3RyaW5nW10sIHNpbGVudD86Ym9vbGVhbiApOnZvaWR7XG5cdFx0dmFyIGV2ZW50cyA9IHNpbGVudCA/IFtdIDogWydjaGFuZ2UnXTtcblxuXHRcdGRlYm91bmNlX2V2ZW50cyh0aGlzLCBldmVudHMsKCkgPT4ge1xuXHRcdFx0dGhpcy5jbGVhcihzaWxlbnQpO1xuXHRcdFx0dGhpcy5hZGRJdGVtcyh2YWx1ZSwgc2lsZW50KTtcblx0XHR9KTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFJlc2V0cyB0aGUgbnVtYmVyIG9mIG1heCBpdGVtcyB0byB0aGUgZ2l2ZW4gdmFsdWVcblx0ICpcblx0ICovXG5cdHNldE1heEl0ZW1zKHZhbHVlOm51bGx8bnVtYmVyKXtcblx0XHRpZih2YWx1ZSA9PT0gMCkgdmFsdWUgPSBudWxsOyAvL3Jlc2V0IHRvIHVubGltaXRlZCBpdGVtcy5cblx0XHR0aGlzLnNldHRpbmdzLm1heEl0ZW1zID0gdmFsdWU7XG5cdFx0dGhpcy5yZWZyZXNoU3RhdGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzZWxlY3RlZCBpdGVtLlxuXHQgKlxuXHQgKi9cblx0c2V0QWN0aXZlSXRlbSggaXRlbT86VG9tSXRlbSwgZT86TW91c2VFdmVudHxLZXlib2FyZEV2ZW50ICl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBldmVudE5hbWU7XG5cdFx0dmFyIGksIGJlZ2luLCBlbmQsIHN3YXA7XG5cdFx0dmFyIGxhc3Q7XG5cblx0XHRpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJykgcmV0dXJuO1xuXG5cdFx0Ly8gY2xlYXIgdGhlIGFjdGl2ZSBzZWxlY3Rpb25cblx0XHRpZiggIWl0ZW0gKXtcblx0XHRcdHNlbGYuY2xlYXJBY3RpdmVJdGVtcygpO1xuXHRcdFx0aWYgKHNlbGYuaXNGb2N1c2VkKSB7XG5cdFx0XHRcdHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIG1vZGlmeSBzZWxlY3Rpb25cblx0XHRldmVudE5hbWUgPSBlICYmIGUudHlwZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKGV2ZW50TmFtZSA9PT0gJ2NsaWNrJyAmJiBpc0tleURvd24oJ3NoaWZ0S2V5JyxlKSAmJiBzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuXHRcdFx0bGFzdFx0PSBzZWxmLmdldExhc3RBY3RpdmUoKTtcblx0XHRcdGJlZ2luXHQ9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoc2VsZi5jb250cm9sLmNoaWxkcmVuLCBsYXN0KTtcblx0XHRcdGVuZFx0XHQ9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoc2VsZi5jb250cm9sLmNoaWxkcmVuLCBpdGVtKTtcblxuXHRcdFx0aWYgKGJlZ2luID4gZW5kKSB7XG5cdFx0XHRcdHN3YXAgID0gYmVnaW47XG5cdFx0XHRcdGJlZ2luID0gZW5kO1xuXHRcdFx0XHRlbmQgICA9IHN3YXA7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGkgPSBiZWdpbjsgaSA8PSBlbmQ7IGkrKykge1xuXHRcdFx0XHRpdGVtID0gc2VsZi5jb250cm9sLmNoaWxkcmVuW2ldIGFzIFRvbUl0ZW07XG5cdFx0XHRcdGlmIChzZWxmLmFjdGl2ZUl0ZW1zLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG5cdFx0XHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtQ2xhc3MoaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXHRcdH0gZWxzZSBpZiAoKGV2ZW50TmFtZSA9PT0gJ2NsaWNrJyAmJiBpc0tleURvd24oY29uc3RhbnRzLktFWV9TSE9SVENVVCxlKSApIHx8IChldmVudE5hbWUgPT09ICdrZXlkb3duJyAmJiBpc0tleURvd24oJ3NoaWZ0S2V5JyxlKSkpIHtcblx0XHRcdGlmKCBpdGVtLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgKXtcblx0XHRcdFx0c2VsZi5yZW1vdmVBY3RpdmVJdGVtKCBpdGVtICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhpdGVtKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c2VsZi5jbGVhckFjdGl2ZUl0ZW1zKCk7XG5cdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhpdGVtKTtcblx0XHR9XG5cblx0XHQvLyBlbnN1cmUgY29udHJvbCBoYXMgZm9jdXNcblx0XHRzZWxmLmlucHV0U3RhdGUoKTtcblx0XHRpZiAoIXNlbGYuaXNGb2N1c2VkKSB7XG5cdFx0XHRzZWxmLmZvY3VzKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgYWN0aXZlIGFuZCBsYXN0LWFjdGl2ZSBjbGFzc2VzXG5cdCAqXG5cdCAqL1xuXHRzZXRBY3RpdmVJdGVtQ2xhc3MoIGl0ZW06VG9tSXRlbSApe1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdGNvbnN0IGxhc3RfYWN0aXZlID0gc2VsZi5jb250cm9sLnF1ZXJ5U2VsZWN0b3IoJy5sYXN0LWFjdGl2ZScpO1xuXHRcdGlmKCBsYXN0X2FjdGl2ZSApIHJlbW92ZUNsYXNzZXMobGFzdF9hY3RpdmUgYXMgSFRNTEVsZW1lbnQsJ2xhc3QtYWN0aXZlJyk7XG5cblx0XHRhZGRDbGFzc2VzKGl0ZW0sJ2FjdGl2ZSBsYXN0LWFjdGl2ZScpO1xuXHRcdHNlbGYudHJpZ2dlcignaXRlbV9zZWxlY3QnLCBpdGVtKTtcblx0XHRpZiggc2VsZi5hY3RpdmVJdGVtcy5pbmRleE9mKGl0ZW0pID09IC0xICl7XG5cdFx0XHRzZWxmLmFjdGl2ZUl0ZW1zLnB1c2goIGl0ZW0gKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlIGFjdGl2ZSBpdGVtXG5cdCAqXG5cdCAqL1xuXHRyZW1vdmVBY3RpdmVJdGVtKCBpdGVtOlRvbUl0ZW0gKXtcblx0XHR2YXIgaWR4ID0gdGhpcy5hY3RpdmVJdGVtcy5pbmRleE9mKGl0ZW0pO1xuXHRcdHRoaXMuYWN0aXZlSXRlbXMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0cmVtb3ZlQ2xhc3NlcyhpdGVtLCdhY3RpdmUnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgYWxsIHRoZSBhY3RpdmUgaXRlbXNcblx0ICpcblx0ICovXG5cdGNsZWFyQWN0aXZlSXRlbXMoKXtcblx0XHRyZW1vdmVDbGFzc2VzKHRoaXMuYWN0aXZlSXRlbXMsJ2FjdGl2ZScpO1xuXHRcdHRoaXMuYWN0aXZlSXRlbXMgPSBbXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzZWxlY3RlZCBpdGVtIGluIHRoZSBkcm9wZG93biBtZW51XG5cdCAqIG9mIGF2YWlsYWJsZSBvcHRpb25zLlxuXHQgKlxuXHQgKi9cblx0c2V0QWN0aXZlT3B0aW9uKCBvcHRpb246bnVsbHxIVE1MRWxlbWVudCxzY3JvbGw6Ym9vbGVhbj10cnVlICk6dm9pZHtcblxuXHRcdGlmKCBvcHRpb24gPT09IHRoaXMuYWN0aXZlT3B0aW9uICl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5jbGVhckFjdGl2ZU9wdGlvbigpO1xuXHRcdGlmKCAhb3B0aW9uICkgcmV0dXJuO1xuXG5cdFx0dGhpcy5hY3RpdmVPcHRpb24gPSBvcHRpb247XG5cdFx0c2V0QXR0cih0aGlzLmZvY3VzX25vZGUseydhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOm9wdGlvbi5nZXRBdHRyaWJ1dGUoJ2lkJyl9KTtcblx0XHRzZXRBdHRyKG9wdGlvbix7J2FyaWEtc2VsZWN0ZWQnOid0cnVlJ30pO1xuXHRcdGFkZENsYXNzZXMob3B0aW9uLCdhY3RpdmUnKTtcblx0XHRpZiggc2Nyb2xsICkgdGhpcy5zY3JvbGxUb09wdGlvbihvcHRpb24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGRyb3Bkb3duX2NvbnRlbnQgc2Nyb2xsVG9wIHRvIGRpc3BsYXkgdGhlIG9wdGlvblxuXHQgKlxuXHQgKi9cblx0c2Nyb2xsVG9PcHRpb24oIG9wdGlvbjpudWxsfEhUTUxFbGVtZW50LCBiZWhhdmlvcj86c3RyaW5nICk6dm9pZHtcblxuXHRcdGlmKCAhb3B0aW9uICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgY29udGVudFx0XHQ9IHRoaXMuZHJvcGRvd25fY29udGVudDtcblx0XHRjb25zdCBoZWlnaHRfbWVudVx0PSBjb250ZW50LmNsaWVudEhlaWdodDtcblx0XHRjb25zdCBzY3JvbGxUb3BcdFx0PSBjb250ZW50LnNjcm9sbFRvcCB8fCAwO1xuXHRcdGNvbnN0IGhlaWdodF9pdGVtXHQ9IG9wdGlvbi5vZmZzZXRIZWlnaHQ7XG5cdFx0Y29uc3QgeVx0XHRcdFx0PSBvcHRpb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBzY3JvbGxUb3A7XG5cblx0XHRpZiAoeSArIGhlaWdodF9pdGVtID4gaGVpZ2h0X21lbnUgKyBzY3JvbGxUb3ApIHtcblx0XHRcdHRoaXMuc2Nyb2xsKHkgLSBoZWlnaHRfbWVudSArIGhlaWdodF9pdGVtLCBiZWhhdmlvcik7XG5cblx0XHR9IGVsc2UgaWYgKHkgPCBzY3JvbGxUb3ApIHtcblx0XHRcdHRoaXMuc2Nyb2xsKHksIGJlaGF2aW9yKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2Nyb2xsIHRoZSBkcm9wZG93biB0byB0aGUgZ2l2ZW4gcG9zaXRpb25cblx0ICpcblx0ICovXG5cdHNjcm9sbCggc2Nyb2xsVG9wOm51bWJlciwgYmVoYXZpb3I/OnN0cmluZyApOnZvaWR7XG5cdFx0Y29uc3QgY29udGVudCA9IHRoaXMuZHJvcGRvd25fY29udGVudDtcblx0XHRpZiggYmVoYXZpb3IgKXtcblx0XHRcdGNvbnRlbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBiZWhhdmlvcjtcblx0XHR9XG5cdFx0Y29udGVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG5cdFx0Y29udGVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9ICcnO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyB0aGUgYWN0aXZlIG9wdGlvblxuXHQgKlxuXHQgKi9cblx0Y2xlYXJBY3RpdmVPcHRpb24oKXtcblx0XHRpZiggdGhpcy5hY3RpdmVPcHRpb24gKXtcblx0XHRcdHJlbW92ZUNsYXNzZXModGhpcy5hY3RpdmVPcHRpb24sJ2FjdGl2ZScpO1xuXHRcdFx0c2V0QXR0cih0aGlzLmFjdGl2ZU9wdGlvbix7J2FyaWEtc2VsZWN0ZWQnOm51bGx9KTtcblx0XHR9XG5cdFx0dGhpcy5hY3RpdmVPcHRpb24gPSBudWxsO1xuXHRcdHNldEF0dHIodGhpcy5mb2N1c19ub2RlLHsnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzpudWxsfSk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBTZWxlY3RzIGFsbCBpdGVtcyAoQ1RSTCArIEEpLlxuXHQgKi9cblx0c2VsZWN0QWxsKCkge1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScpIHJldHVybjtcblxuXHRcdGNvbnN0IGFjdGl2ZUl0ZW1zID0gc2VsZi5jb250cm9sQ2hpbGRyZW4oKTtcblxuXHRcdGlmKCAhYWN0aXZlSXRlbXMubGVuZ3RoICkgcmV0dXJuO1xuXG5cdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0c2VsZi5jbG9zZSgpO1xuXG5cdFx0c2VsZi5hY3RpdmVJdGVtcyA9IGFjdGl2ZUl0ZW1zO1xuXHRcdGl0ZXJhdGUoIGFjdGl2ZUl0ZW1zLCAoaXRlbTpUb21JdGVtKSA9PiB7XG5cdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW1DbGFzcyhpdGVtKTtcblx0XHR9KTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGNvbnRyb2xfaW5wdXQgc2hvdWxkIGJlIGluIGEgaGlkZGVuIG9yIHZpc2libGUgc3RhdGVcblx0ICpcblx0ICovXG5cdGlucHV0U3RhdGUoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiggIXNlbGYuY29udHJvbC5jb250YWlucyhzZWxmLmNvbnRyb2xfaW5wdXQpICkgcmV0dXJuO1xuXG5cdFx0c2V0QXR0cihzZWxmLmNvbnRyb2xfaW5wdXQse3BsYWNlaG9sZGVyOnNlbGYuc2V0dGluZ3MucGxhY2Vob2xkZXJ9KTtcblxuXHRcdGlmKCBzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCA+IDAgfHwgKCFzZWxmLmlzRm9jdXNlZCAmJiBzZWxmLnNldHRpbmdzLmhpZGVQbGFjZWhvbGRlciAmJiBzZWxmLml0ZW1zLmxlbmd0aCA+IDApICl7XG5cdFx0XHRzZWxmLnNldFRleHRib3hWYWx1ZSgpO1xuXHRcdFx0c2VsZi5pc0lucHV0SGlkZGVuID0gdHJ1ZTtcblxuXHRcdH1lbHNle1xuXG5cdFx0XHRpZiggc2VsZi5zZXR0aW5ncy5oaWRlUGxhY2Vob2xkZXIgJiYgc2VsZi5pdGVtcy5sZW5ndGggPiAwICl7XG5cdFx0XHRcdHNldEF0dHIoc2VsZi5jb250cm9sX2lucHV0LHtwbGFjZWhvbGRlcjonJ30pO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5pc0lucHV0SGlkZGVuID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0c2VsZi53cmFwcGVyLmNsYXNzTGlzdC50b2dnbGUoJ2lucHV0LWhpZGRlbicsIHNlbGYuaXNJbnB1dEhpZGRlbiApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgaW5wdXQgdmFsdWVcblx0ICovXG5cdGlucHV0VmFsdWUoKXtcblx0XHRyZXR1cm4gdGhpcy5jb250cm9sX2lucHV0LnZhbHVlLnRyaW0oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHaXZlcyB0aGUgY29udHJvbCBmb2N1cy5cblx0ICovXG5cdGZvY3VzKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZiggc2VsZi5pc0Rpc2FibGVkIHx8IHNlbGYuaXNSZWFkT25seSkgcmV0dXJuO1xuXG5cdFx0c2VsZi5pZ25vcmVGb2N1cyA9IHRydWU7XG5cblx0XHRpZiggc2VsZi5jb250cm9sX2lucHV0Lm9mZnNldFdpZHRoICl7XG5cdFx0XHRzZWxmLmNvbnRyb2xfaW5wdXQuZm9jdXMoKTtcblx0XHR9ZWxzZXtcblx0XHRcdHNlbGYuZm9jdXNfbm9kZS5mb2N1cygpO1xuXHRcdH1cblxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0c2VsZi5pZ25vcmVGb2N1cyA9IGZhbHNlO1xuXHRcdFx0c2VsZi5vbkZvY3VzKCk7XG5cdFx0fSwgMCk7XG5cdH1cblxuXHQvKipcblx0ICogRm9yY2VzIHRoZSBjb250cm9sIG91dCBvZiBmb2N1cy5cblx0ICpcblx0ICovXG5cdGJsdXIoKTp2b2lkIHtcblx0XHR0aGlzLmZvY3VzX25vZGUuYmx1cigpO1xuXHRcdHRoaXMub25CbHVyKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgc2NvcmVzIGFuIG9iamVjdFxuXHQgKiB0byBzaG93IGhvdyBnb29kIG9mIGEgbWF0Y2ggaXQgaXMgdG8gdGhlXG5cdCAqIHByb3ZpZGVkIHF1ZXJ5LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtmdW5jdGlvbn1cblx0ICovXG5cdGdldFNjb3JlRnVuY3Rpb24ocXVlcnk6c3RyaW5nKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2lmdGVyLmdldFNjb3JlRnVuY3Rpb24ocXVlcnksIHRoaXMuZ2V0U2VhcmNoT3B0aW9ucygpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHNlYXJjaCBvcHRpb25zIGZvciBzaWZ0ZXIgKHRoZSBzeXN0ZW1cblx0ICogZm9yIHNjb3JpbmcgYW5kIHNvcnRpbmcgcmVzdWx0cykuXG5cdCAqXG5cdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL29yY2hpZGpzL3NpZnRlci5qc1xuXHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdCAqL1xuXHRnZXRTZWFyY2hPcHRpb25zKCkge1xuXHRcdHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG5cdFx0dmFyIHNvcnQgPSBzZXR0aW5ncy5zb3J0RmllbGQ7XG5cdFx0aWYgKHR5cGVvZiBzZXR0aW5ncy5zb3J0RmllbGQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRzb3J0ID0gW3tmaWVsZDogc2V0dGluZ3Muc29ydEZpZWxkfV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGZpZWxkcyAgICAgIDogc2V0dGluZ3Muc2VhcmNoRmllbGQsXG5cdFx0XHRjb25qdW5jdGlvbiA6IHNldHRpbmdzLnNlYXJjaENvbmp1bmN0aW9uLFxuXHRcdFx0c29ydCAgICAgICAgOiBzb3J0LFxuXHRcdFx0bmVzdGluZyAgICAgOiBzZXR0aW5ncy5uZXN0aW5nXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWFyY2hlcyB0aHJvdWdoIGF2YWlsYWJsZSBvcHRpb25zIGFuZCByZXR1cm5zXG5cdCAqIGEgc29ydGVkIGFycmF5IG9mIG1hdGNoZXMuXG5cdCAqXG5cdCAqL1xuXHRzZWFyY2gocXVlcnk6c3RyaW5nKSA6IFJldHVyblR5cGU8U2lmdGVyWydzZWFyY2gnXT57XG5cdFx0dmFyIHJlc3VsdCwgY2FsY3VsYXRlU2NvcmU7XG5cdFx0dmFyIHNlbGYgICAgID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyAgPSB0aGlzLmdldFNlYXJjaE9wdGlvbnMoKTtcblxuXHRcdC8vIHZhbGlkYXRlIHVzZXItcHJvdmlkZWQgcmVzdWx0IHNjb3JpbmcgZnVuY3Rpb25cblx0XHRpZiAoIHNlbGYuc2V0dGluZ3Muc2NvcmUgKXtcblx0XHRcdGNhbGN1bGF0ZVNjb3JlID0gc2VsZi5zZXR0aW5ncy5zY29yZS5jYWxsKHNlbGYscXVlcnkpO1xuXHRcdFx0aWYgKHR5cGVvZiBjYWxjdWxhdGVTY29yZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RvbSBTZWxlY3QgXCJzY29yZVwiIHNldHRpbmcgbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcGVyZm9ybSBzZWFyY2hcblx0XHRpZiAocXVlcnkgIT09IHNlbGYubGFzdFF1ZXJ5KSB7XG5cdFx0XHRzZWxmLmxhc3RRdWVyeVx0XHRcdD0gcXVlcnk7XG5cdFx0XHRyZXN1bHRcdFx0XHRcdFx0PSBzZWxmLnNpZnRlci5zZWFyY2gocXVlcnksIE9iamVjdC5hc3NpZ24ob3B0aW9ucywge3Njb3JlOiBjYWxjdWxhdGVTY29yZX0pKTtcblx0XHRcdHNlbGYuY3VycmVudFJlc3VsdHNcdFx0PSByZXN1bHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdFx0XHRcdFx0XHQ9IE9iamVjdC5hc3NpZ24oIHt9LCBzZWxmLmN1cnJlbnRSZXN1bHRzKTtcblx0XHR9XG5cblx0XHQvLyBmaWx0ZXIgb3V0IHNlbGVjdGVkIGl0ZW1zXG5cdFx0aWYoIHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkICl7XG5cdFx0XHRyZXN1bHQuaXRlbXMgPSByZXN1bHQuaXRlbXMuZmlsdGVyKChpdGVtKSA9PiB7XG5cdFx0XHRcdGxldCBoYXNoZWQgPSBoYXNoX2tleShpdGVtLmlkKTtcblx0XHRcdFx0cmV0dXJuICEoaGFzaGVkICYmIHNlbGYuaXRlbXMuaW5kZXhPZihoYXNoZWQpICE9PSAtMSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWZyZXNoZXMgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbnMgc2hvd25cblx0ICogaW4gdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBtZW51LlxuXHQgKlxuXHQgKi9cblx0cmVmcmVzaE9wdGlvbnMoIHRyaWdnZXJEcm9wZG93bjpib29sZWFuID0gdHJ1ZSApe1xuXHRcdHZhciBpLCBqLCBrLCBuLCBvcHRncm91cCwgb3B0Z3JvdXBzLCBodG1sOkRvY3VtZW50RnJhZ21lbnQsIGhhc19jcmVhdGVfb3B0aW9uLCBhY3RpdmVfZ3JvdXA7XG5cdFx0dmFyIGNyZWF0ZTtcblxuXHRcdHR5cGUgR3JvdXAgPSB7ZnJhZ21lbnQ6RG9jdW1lbnRGcmFnbWVudCxvcmRlcjpudW1iZXIsb3B0Z3JvdXA6c3RyaW5nfVxuXHRcdGNvbnN0IGdyb3Vwczoge1trZXk6c3RyaW5nXTpudW1iZXJ9ID0ge307XG5cdFx0Y29uc3QgZ3JvdXBzX29yZGVyOkdyb3VwW11cdD0gW107XG5cblx0XHR2YXIgc2VsZlx0XHRcdFx0XHQ9IHRoaXM7XG5cdFx0dmFyIHF1ZXJ5XHRcdFx0XHRcdD0gc2VsZi5pbnB1dFZhbHVlKCk7XG5cdFx0Y29uc3Qgc2FtZV9xdWVyeVx0XHRcdD0gcXVlcnkgPT09IHNlbGYubGFzdFF1ZXJ5IHx8IChxdWVyeSA9PSAnJyAmJiBzZWxmLmxhc3RRdWVyeSA9PSBudWxsKTtcblx0XHR2YXIgcmVzdWx0c1x0XHRcdFx0XHQ9IHNlbGYuc2VhcmNoKHF1ZXJ5KTtcblx0XHR2YXIgYWN0aXZlX29wdGlvbjpIVE1MRWxlbWVudHxudWxsID0gbnVsbDtcblx0XHR2YXIgc2hvd19kcm9wZG93blx0XHRcdD0gc2VsZi5zZXR0aW5ncy5zaG91bGRPcGVuIHx8IGZhbHNlO1xuXHRcdHZhciBkcm9wZG93bl9jb250ZW50XHRcdD0gc2VsZi5kcm9wZG93bl9jb250ZW50O1xuXG5cblx0XHRpZiggc2FtZV9xdWVyeSApe1xuXHRcdFx0YWN0aXZlX29wdGlvblx0XHRcdD0gc2VsZi5hY3RpdmVPcHRpb247XG5cblx0XHRcdGlmKCBhY3RpdmVfb3B0aW9uICl7XG5cdFx0XHRcdGFjdGl2ZV9ncm91cCA9IGFjdGl2ZV9vcHRpb24uY2xvc2VzdCgnW2RhdGEtZ3JvdXBdJykgYXMgSFRNTEVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgbWFya3VwXG5cdFx0biA9IHJlc3VsdHMuaXRlbXMubGVuZ3RoO1xuXHRcdGlmICh0eXBlb2Ygc2VsZi5zZXR0aW5ncy5tYXhPcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0biA9IE1hdGgubWluKG4sIHNlbGYuc2V0dGluZ3MubWF4T3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0aWYoIG4gPiAwICl7XG5cdFx0XHRzaG93X2Ryb3Bkb3duID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBnZXQgZnJhZ21lbnQgZm9yIGdyb3VwIGFuZCB0aGUgcG9zaXRpb24gb2YgdGhlIGdyb3VwIGluIGdyb3VwX29yZGVyXG5cdFx0Y29uc3QgZ2V0R3JvdXBGcmFnbWVudCA9IChvcHRncm91cDpzdHJpbmcsb3JkZXI6bnVtYmVyKTpbbnVtYmVyLERvY3VtZW50RnJhZ21lbnRdID0+IHtcblxuXHRcdFx0bGV0IGdyb3VwX29yZGVyX2kgPSBncm91cHNbb3B0Z3JvdXBdO1xuXG5cdFx0XHRpZiggZ3JvdXBfb3JkZXJfaSAhPT0gdW5kZWZpbmVkICl7XG5cdFx0XHRcdGxldCBvcmRlcl9ncm91cCA9IGdyb3Vwc19vcmRlcltncm91cF9vcmRlcl9pXTtcblx0XHRcdFx0aWYoIG9yZGVyX2dyb3VwICE9PSB1bmRlZmluZWQgKXtcblx0XHRcdFx0XHRyZXR1cm4gW2dyb3VwX29yZGVyX2ksb3JkZXJfZ3JvdXAuZnJhZ21lbnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGxldCBncm91cF9mcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdGdyb3VwX29yZGVyX2kgPSBncm91cHNfb3JkZXIubGVuZ3RoO1xuXHRcdFx0Z3JvdXBzX29yZGVyLnB1c2goe2ZyYWdtZW50Omdyb3VwX2ZyYWdtZW50LG9yZGVyLG9wdGdyb3VwfSk7XG5cblx0XHRcdHJldHVybiBbZ3JvdXBfb3JkZXJfaSxncm91cF9mcmFnbWVudF1cblx0XHR9XG5cblx0XHQvLyByZW5kZXIgYW5kIGdyb3VwIGF2YWlsYWJsZSBvcHRpb25zIGluZGl2aWR1YWxseVxuXHRcdGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuXHRcdFx0Ly8gZ2V0IG9wdGlvbiBkb20gZWxlbWVudFxuXHRcdFx0bGV0IGl0ZW1cdFx0XHQ9IHJlc3VsdHMuaXRlbXNbaV07XG5cdFx0XHRpZiggIWl0ZW0gKSBjb250aW51ZTtcblxuXHRcdFx0bGV0IG9wdF92YWx1ZVx0XHQ9IGl0ZW0uaWQ7XG5cdFx0XHRsZXQgb3B0aW9uXHRcdFx0PSBzZWxmLm9wdGlvbnNbb3B0X3ZhbHVlXTtcblxuXHRcdFx0aWYoIG9wdGlvbiA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cblx0XHRcdGxldCBvcHRfaGFzaFx0XHQ9IGdldF9oYXNoKG9wdF92YWx1ZSk7XG5cdFx0XHRsZXQgb3B0aW9uX2VsXHRcdD0gc2VsZi5nZXRPcHRpb24ob3B0X2hhc2gsdHJ1ZSkgYXMgSFRNTEVsZW1lbnQ7XG5cblx0XHRcdC8vIHRvZ2dsZSAnc2VsZWN0ZWQnIGNsYXNzXG5cdFx0XHRpZiggIXNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkICl7XG5cdFx0XHRcdG9wdGlvbl9lbC5jbGFzc0xpc3QudG9nZ2xlKCdzZWxlY3RlZCcsIHNlbGYuaXRlbXMuaW5jbHVkZXMob3B0X2hhc2gpICk7XG5cdFx0XHR9XG5cblx0XHRcdG9wdGdyb3VwICAgID0gb3B0aW9uW3NlbGYuc2V0dGluZ3Mub3B0Z3JvdXBGaWVsZF0gfHwgJyc7XG5cdFx0XHRvcHRncm91cHMgICA9IEFycmF5LmlzQXJyYXkob3B0Z3JvdXApID8gb3B0Z3JvdXAgOiBbb3B0Z3JvdXBdO1xuXHRcdFx0XG5cblx0XHRcdGZvciAoaiA9IDAsIGsgPSBvcHRncm91cHMgJiYgb3B0Z3JvdXBzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuXHRcdFx0XHRvcHRncm91cCA9IG9wdGdyb3Vwc1tqXTtcblxuXHRcdFx0XHRsZXQgb3JkZXIgPSBvcHRpb24uJG9yZGVyO1xuXHRcdFx0XHRsZXQgc2VsZl9vcHRncm91cCA9IHNlbGYub3B0Z3JvdXBzW29wdGdyb3VwXTtcblx0XHRcdFx0aWYoIHNlbGZfb3B0Z3JvdXAgPT09IHVuZGVmaW5lZCApe1x0XHRcdFx0XHRcblx0XHRcdFx0XHRvcHRncm91cCA9ICcnO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRvcmRlciA9IHNlbGZfb3B0Z3JvdXAuJG9yZGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgW2dyb3VwX29yZGVyX2ksZ3JvdXBfZnJhZ21lbnRdID0gZ2V0R3JvdXBGcmFnbWVudChvcHRncm91cCxvcmRlcik7XG5cblxuXHRcdFx0XHQvLyBub2RlcyBjYW4gb25seSBoYXZlIG9uZSBwYXJlbnQsIHNvIGlmIHRoZSBvcHRpb24gaXMgaW4gbXV0cGxlIGdyb3Vwcywgd2UgbmVlZCBhIGNsb25lXG5cdFx0XHRcdGlmKCBqID4gMCApe1xuXHRcdFx0XHRcdG9wdGlvbl9lbCA9IG9wdGlvbl9lbC5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnQ7XG5cdFx0XHRcdFx0c2V0QXR0cihvcHRpb25fZWwse2lkOiBvcHRpb24uJGlkKyctY2xvbmUtJytqLCdhcmlhLXNlbGVjdGVkJzpudWxsfSk7XG5cdFx0XHRcdFx0b3B0aW9uX2VsLmNsYXNzTGlzdC5hZGQoJ3RzLWNsb25lZCcpO1xuXHRcdFx0XHRcdHJlbW92ZUNsYXNzZXMob3B0aW9uX2VsLCdhY3RpdmUnKTtcblxuXG5cdFx0XHRcdFx0Ly8gbWFrZSBzdXJlIHdlIGtlZXAgdGhlIGFjdGl2ZU9wdGlvbiBpbiB0aGUgc2FtZSBncm91cFxuXHRcdFx0XHRcdGlmKCBzZWxmLmFjdGl2ZU9wdGlvbiAmJiBzZWxmLmFjdGl2ZU9wdGlvbi5kYXRhc2V0LnZhbHVlID09IG9wdF92YWx1ZSApe1xuXHRcdFx0XHRcdFx0aWYoIGFjdGl2ZV9ncm91cCAmJiBhY3RpdmVfZ3JvdXAuZGF0YXNldC5ncm91cCA9PT0gb3B0Z3JvdXAudG9TdHJpbmcoKSApe1xuXHRcdFx0XHRcdFx0XHRhY3RpdmVfb3B0aW9uID0gb3B0aW9uX2VsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVx0XG5cdFx0XHRcdFxuXHRcdFx0XHRncm91cF9mcmFnbWVudC5hcHBlbmRDaGlsZChvcHRpb25fZWwpO1xuXHRcdFx0XHRpZiggb3B0Z3JvdXAgIT0gJycgKXtcblx0XHRcdFx0XHRncm91cHNbb3B0Z3JvdXBdID0gZ3JvdXBfb3JkZXJfaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNvcnQgb3B0Z3JvdXBzXG5cdFx0aWYoIHNlbGYuc2V0dGluZ3MubG9ja09wdGdyb3VwT3JkZXIgKXtcblx0XHRcdGdyb3Vwc19vcmRlci5zb3J0KChhLCBiKSA9PiB7XG5cdFx0XHRcdHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIHJlbmRlciBvcHRncm91cCBoZWFkZXJzICYgam9pbiBncm91cHNcblx0XHRodG1sID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdGl0ZXJhdGUoIGdyb3Vwc19vcmRlciwgKGdyb3VwX29yZGVyOkdyb3VwKSA9PiB7XG5cblx0XHRcdGxldCBncm91cF9mcmFnbWVudCA9IGdyb3VwX29yZGVyLmZyYWdtZW50O1xuXHRcdFx0bGV0IG9wdGdyb3VwID0gZ3JvdXBfb3JkZXIub3B0Z3JvdXBcblxuXHRcdFx0aWYoICFncm91cF9mcmFnbWVudCB8fCAhZ3JvdXBfZnJhZ21lbnQuY2hpbGRyZW4ubGVuZ3RoICkgcmV0dXJuO1xuXG5cdFx0XHRsZXQgZ3JvdXBfaGVhZGluZyA9IHNlbGYub3B0Z3JvdXBzW29wdGdyb3VwXTtcblxuXHRcdFx0aWYoIGdyb3VwX2hlYWRpbmcgIT09IHVuZGVmaW5lZCApe1xuXG5cdFx0XHRcdGxldCBncm91cF9vcHRpb25zID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHRsZXQgaGVhZGVyID0gc2VsZi5yZW5kZXIoJ29wdGdyb3VwX2hlYWRlcicsIGdyb3VwX2hlYWRpbmcpO1xuXHRcdFx0XHRhcHBlbmQoIGdyb3VwX29wdGlvbnMsIGhlYWRlciApO1xuXHRcdFx0XHRhcHBlbmQoIGdyb3VwX29wdGlvbnMsIGdyb3VwX2ZyYWdtZW50ICk7XG5cblx0XHRcdFx0bGV0IGdyb3VwX2h0bWwgPSBzZWxmLnJlbmRlcignb3B0Z3JvdXAnLCB7Z3JvdXA6Z3JvdXBfaGVhZGluZyxvcHRpb25zOmdyb3VwX29wdGlvbnN9ICk7XG5cblx0XHRcdFx0YXBwZW5kKCBodG1sLCBncm91cF9odG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFwcGVuZCggaHRtbCwgZ3JvdXBfZnJhZ21lbnQgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGRyb3Bkb3duX2NvbnRlbnQuaW5uZXJIVE1MID0gJyc7XG5cdFx0YXBwZW5kKCBkcm9wZG93bl9jb250ZW50LCBodG1sICk7XG5cblx0XHQvLyBoaWdobGlnaHQgbWF0Y2hpbmcgdGVybXMgaW5saW5lXG5cdFx0aWYgKHNlbGYuc2V0dGluZ3MuaGlnaGxpZ2h0KSB7XG5cdFx0XHRyZW1vdmVIaWdobGlnaHQoIGRyb3Bkb3duX2NvbnRlbnQgKTtcblx0XHRcdGlmIChyZXN1bHRzLnF1ZXJ5Lmxlbmd0aCAmJiByZXN1bHRzLnRva2Vucy5sZW5ndGgpIHtcblx0XHRcdFx0aXRlcmF0ZSggcmVzdWx0cy50b2tlbnMsICh0b2spID0+IHtcblx0XHRcdFx0XHRoaWdobGlnaHQoIGRyb3Bkb3duX2NvbnRlbnQsIHRvay5yZWdleCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGhlbHBlciBtZXRob2QgZm9yIGFkZGluZyB0ZW1wbGF0ZXMgdG8gZHJvcGRvd25cblx0XHR2YXIgYWRkX3RlbXBsYXRlID0gKHRlbXBsYXRlOlRvbVRlbXBsYXRlTmFtZXMpID0+IHtcblx0XHRcdGxldCBjb250ZW50ID0gc2VsZi5yZW5kZXIodGVtcGxhdGUse2lucHV0OnF1ZXJ5fSk7XG5cdFx0XHRpZiggY29udGVudCApe1xuXHRcdFx0XHRzaG93X2Ryb3Bkb3duID0gdHJ1ZTtcblx0XHRcdFx0ZHJvcGRvd25fY29udGVudC5pbnNlcnRCZWZvcmUoY29udGVudCwgZHJvcGRvd25fY29udGVudC5maXJzdENoaWxkKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdH07XG5cblxuXHRcdC8vIGFkZCBsb2FkaW5nIG1lc3NhZ2Vcblx0XHRpZiggc2VsZi5sb2FkaW5nICl7XG5cdFx0XHRhZGRfdGVtcGxhdGUoJ2xvYWRpbmcnKTtcblxuXHRcdC8vIGludmFsaWQgcXVlcnlcblx0XHR9ZWxzZSBpZiggIXNlbGYuc2V0dGluZ3Muc2hvdWxkTG9hZC5jYWxsKHNlbGYscXVlcnkpICl7XG5cdFx0XHRhZGRfdGVtcGxhdGUoJ25vdF9sb2FkaW5nJyk7XG5cblx0XHQvLyBhZGQgbm9fcmVzdWx0cyBtZXNzYWdlXG5cdFx0fWVsc2UgaWYoIHJlc3VsdHMuaXRlbXMubGVuZ3RoID09PSAwICl7XG5cdFx0XHRhZGRfdGVtcGxhdGUoJ25vX3Jlc3VsdHMnKTtcblxuXHRcdH1cblxuXG5cblx0XHQvLyBhZGQgY3JlYXRlIG9wdGlvblxuXHRcdGhhc19jcmVhdGVfb3B0aW9uID0gc2VsZi5jYW5DcmVhdGUocXVlcnkpO1xuXHRcdGlmIChoYXNfY3JlYXRlX29wdGlvbikge1xuXHRcdFx0Y3JlYXRlID0gYWRkX3RlbXBsYXRlKCdvcHRpb25fY3JlYXRlJyk7XG5cdFx0fVxuXG5cblx0XHQvLyBhY3RpdmF0ZVxuXHRcdHNlbGYuaGFzT3B0aW9ucyA9IHJlc3VsdHMuaXRlbXMubGVuZ3RoID4gMCB8fCBoYXNfY3JlYXRlX29wdGlvbjtcblx0XHRpZiggc2hvd19kcm9wZG93biApe1xuXG5cdFx0XHRpZiAocmVzdWx0cy5pdGVtcy5sZW5ndGggPiAwKSB7XG5cblx0XHRcdFx0aWYoICFhY3RpdmVfb3B0aW9uICYmIHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScgJiYgc2VsZi5pdGVtc1swXSAhPSB1bmRlZmluZWQgKXtcblx0XHRcdFx0XHRhY3RpdmVfb3B0aW9uID0gc2VsZi5nZXRPcHRpb24oc2VsZi5pdGVtc1swXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiggIWRyb3Bkb3duX2NvbnRlbnQuY29udGFpbnMoYWN0aXZlX29wdGlvbikgICl7XG5cblx0XHRcdFx0XHRsZXQgYWN0aXZlX2luZGV4ID0gMDtcblx0XHRcdFx0XHRpZiggY3JlYXRlICYmICFzZWxmLnNldHRpbmdzLmFkZFByZWNlZGVuY2UgKXtcblx0XHRcdFx0XHRcdGFjdGl2ZV9pbmRleCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGFjdGl2ZV9vcHRpb24gPSBzZWxmLnNlbGVjdGFibGUoKVthY3RpdmVfaW5kZXhdIGFzIEhUTUxFbGVtZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdH1lbHNlIGlmKCBjcmVhdGUgKXtcblx0XHRcdFx0YWN0aXZlX29wdGlvbiA9IGNyZWF0ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIHRyaWdnZXJEcm9wZG93biAmJiAhc2VsZi5pc09wZW4gKXtcblx0XHRcdFx0c2VsZi5vcGVuKCk7XG5cdFx0XHRcdHNlbGYuc2Nyb2xsVG9PcHRpb24oYWN0aXZlX29wdGlvbiwnYXV0bycpO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5zZXRBY3RpdmVPcHRpb24oYWN0aXZlX29wdGlvbik7XG5cblx0XHR9ZWxzZXtcblx0XHRcdHNlbGYuY2xlYXJBY3RpdmVPcHRpb24oKTtcblx0XHRcdGlmKCB0cmlnZ2VyRHJvcGRvd24gJiYgc2VsZi5pc09wZW4gKXtcblx0XHRcdFx0c2VsZi5jbG9zZShmYWxzZSk7IC8vIGlmIGNyZWF0ZV9vcHRpb249bnVsbCwgd2Ugd2FudCB0aGUgZHJvcGRvd24gdG8gY2xvc2UgYnV0IG5vdCByZXNldCB0aGUgdGV4dGJveCB2YWx1ZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gbGlzdCBvZiBzZWxlY3RhYmxlIG9wdGlvbnNcblx0ICpcblx0ICovXG5cdHNlbGVjdGFibGUoKTpOb2RlTGlzdHtcblx0XHRyZXR1cm4gdGhpcy5kcm9wZG93bl9jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG5cdH1cblxuXG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYXZhaWxhYmxlIG9wdGlvbi4gSWYgaXQgYWxyZWFkeSBleGlzdHMsXG5cdCAqIG5vdGhpbmcgd2lsbCBoYXBwZW4uIE5vdGU6IHRoaXMgZG9lcyBub3QgcmVmcmVzaFxuXHQgKiB0aGUgb3B0aW9ucyBsaXN0IGRyb3Bkb3duICh1c2UgYHJlZnJlc2hPcHRpb25zYFxuXHQgKiBmb3IgdGhhdCkuXG5cdCAqXG5cdCAqIFVzYWdlOlxuXHQgKlxuXHQgKiAgIHRoaXMuYWRkT3B0aW9uKGRhdGEpXG5cdCAqXG5cdCAqL1xuXHRhZGRPcHRpb24oIGRhdGE6VG9tT3B0aW9uLCB1c2VyX2NyZWF0ZWQgPSBmYWxzZSApOmZhbHNlfHN0cmluZyB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBAZGVwcmVjYXRlZCAxLjcuN1xuXHRcdC8vIHVzZSBhZGRPcHRpb25zKCBhcnJheSwgdXNlcl9jcmVhdGVkICkgZm9yIGFkZGluZyBtdWx0aXBsZSBvcHRpb25zXG5cdFx0aWYoIEFycmF5LmlzQXJyYXkoZGF0YSkgKXtcblx0XHRcdHNlbGYuYWRkT3B0aW9ucyggZGF0YSwgdXNlcl9jcmVhdGVkKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBrZXkgPSBoYXNoX2tleShkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuXHRcdGlmKCBrZXkgPT09IG51bGwgfHwgc2VsZi5vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkgKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRkYXRhLiRvcmRlclx0XHRcdD0gZGF0YS4kb3JkZXIgfHwgKytzZWxmLm9yZGVyO1xuXHRcdGRhdGEuJGlkXHRcdFx0PSBzZWxmLmlucHV0SWQgKyAnLW9wdC0nICsgZGF0YS4kb3JkZXI7XG5cdFx0c2VsZi5vcHRpb25zW2tleV1cdD0gZGF0YTtcblx0XHRzZWxmLmxhc3RRdWVyeVx0XHQ9IG51bGw7XG5cblx0XHRpZiggdXNlcl9jcmVhdGVkICl7XG5cdFx0XHRzZWxmLnVzZXJPcHRpb25zW2tleV0gPSB1c2VyX2NyZWF0ZWQ7XG5cdFx0XHRzZWxmLnRyaWdnZXIoJ29wdGlvbl9hZGQnLCBrZXksIGRhdGEpO1xuXHRcdH1cblxuXHRcdHJldHVybiBrZXk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkIG11bHRpcGxlIG9wdGlvbnNcblx0ICpcblx0ICovXG5cdGFkZE9wdGlvbnMoIGRhdGE6VG9tT3B0aW9uW10sIHVzZXJfY3JlYXRlZCA9IGZhbHNlICk6dm9pZHtcblx0XHRpdGVyYXRlKCBkYXRhLCAoZGF0OlRvbU9wdGlvbikgPT4ge1xuXHRcdFx0dGhpcy5hZGRPcHRpb24oZGF0LCB1c2VyX2NyZWF0ZWQpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXByZWNhdGVkIDEuNy43XG5cdCAqL1xuXHRyZWdpc3Rlck9wdGlvbiggZGF0YTpUb21PcHRpb24gKTpmYWxzZXxzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLmFkZE9wdGlvbihkYXRhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gb3B0aW9uIGdyb3VwIHRvIHRoZSBwb29sIG9mIG9wdGlvbiBncm91cHMuXG5cdCAqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuXHQgKi9cblx0cmVnaXN0ZXJPcHRpb25Hcm91cChkYXRhOlRvbU9wdGlvbikge1xuXHRcdHZhciBrZXkgPSBoYXNoX2tleShkYXRhW3RoaXMuc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkXSk7XG5cblx0XHRpZiAoIGtleSA9PT0gbnVsbCApIHJldHVybiBmYWxzZTtcblxuXHRcdGRhdGEuJG9yZGVyID0gZGF0YS4kb3JkZXIgfHwgKyt0aGlzLm9yZGVyO1xuXHRcdHRoaXMub3B0Z3JvdXBzW2tleV0gPSBkYXRhO1xuXHRcdHJldHVybiBrZXk7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgbmV3IG9wdGdyb3VwIGZvciBvcHRpb25zXG5cdCAqIHRvIGJlIGJ1Y2tldGVkIGludG8uXG5cdCAqXG5cdCAqL1xuXHRhZGRPcHRpb25Hcm91cChpZDpzdHJpbmcsIGRhdGE6VG9tT3B0aW9uKSB7XG5cdFx0dmFyIGhhc2hlZF9pZDtcblx0XHRkYXRhW3RoaXMuc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkXSA9IGlkO1xuXG5cdFx0aWYoIGhhc2hlZF9pZCA9IHRoaXMucmVnaXN0ZXJPcHRpb25Hcm91cChkYXRhKSApe1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdvcHRncm91cF9hZGQnLCBoYXNoZWRfaWQsIGRhdGEpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFuIGV4aXN0aW5nIG9wdGlvbiBncm91cC5cblx0ICpcblx0ICovXG5cdHJlbW92ZU9wdGlvbkdyb3VwKGlkOnN0cmluZykge1xuXHRcdGlmICh0aGlzLm9wdGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLm9wdGdyb3Vwc1tpZF07XG5cdFx0XHR0aGlzLmNsZWFyQ2FjaGUoKTtcblx0XHRcdHRoaXMudHJpZ2dlcignb3B0Z3JvdXBfcmVtb3ZlJywgaWQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgYWxsIGV4aXN0aW5nIG9wdGlvbiBncm91cHMuXG5cdCAqL1xuXHRjbGVhck9wdGlvbkdyb3VwcygpIHtcblx0XHR0aGlzLm9wdGdyb3VwcyA9IHt9O1xuXHRcdHRoaXMuY2xlYXJDYWNoZSgpO1xuXHRcdHRoaXMudHJpZ2dlcignb3B0Z3JvdXBfY2xlYXInKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIGFuIG9wdGlvbiBhdmFpbGFibGUgZm9yIHNlbGVjdGlvbi4gSWZcblx0ICogaXQgaXMgdmlzaWJsZSBpbiB0aGUgc2VsZWN0ZWQgaXRlbXMgb3Igb3B0aW9uc1xuXHQgKiBkcm9wZG93biwgaXQgd2lsbCBiZSByZS1yZW5kZXJlZCBhdXRvbWF0aWNhbGx5LlxuXHQgKlxuXHQgKi9cblx0dXBkYXRlT3B0aW9uKHZhbHVlOnN0cmluZywgZGF0YTpUb21PcHRpb24pIHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHR2YXIgaXRlbV9uZXc7XG5cdFx0dmFyIGluZGV4X2l0ZW07XG5cblx0XHRjb25zdCB2YWx1ZV9vbGRcdFx0PSBoYXNoX2tleSh2YWx1ZSk7XG5cdFx0Y29uc3QgdmFsdWVfbmV3XHRcdD0gaGFzaF9rZXkoZGF0YVtzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdKTtcblxuXHRcdC8vIHNhbml0eSBjaGVja3Ncblx0XHRpZiggdmFsdWVfb2xkID09PSBudWxsICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgZGF0YV9vbGRcdFx0PSBzZWxmLm9wdGlvbnNbdmFsdWVfb2xkXTtcblxuXHRcdGlmKCBkYXRhX29sZCA9PSB1bmRlZmluZWQgKSByZXR1cm47XG5cdFx0aWYoIHR5cGVvZiB2YWx1ZV9uZXcgIT09ICdzdHJpbmcnICkgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBtdXN0IGJlIHNldCBpbiBvcHRpb24gZGF0YScpO1xuXG5cblx0XHRjb25zdCBvcHRpb25cdFx0PSBzZWxmLmdldE9wdGlvbih2YWx1ZV9vbGQpO1xuXHRcdGNvbnN0IGl0ZW1cdFx0XHQ9IHNlbGYuZ2V0SXRlbSh2YWx1ZV9vbGQpO1xuXG5cblx0XHRkYXRhLiRvcmRlciA9IGRhdGEuJG9yZGVyIHx8IGRhdGFfb2xkLiRvcmRlcjtcblx0XHRkZWxldGUgc2VsZi5vcHRpb25zW3ZhbHVlX29sZF07XG5cblx0XHQvLyBpbnZhbGlkYXRlIHJlbmRlciBjYWNoZVxuXHRcdC8vIGRvbid0IHJlbW92ZSBleGlzdGluZyBub2RlIHlldCwgd2UnbGwgcmVtb3ZlIGl0IGFmdGVyIHJlcGxhY2luZyBpdFxuXHRcdHNlbGYudW5jYWNoZVZhbHVlKHZhbHVlX25ldyk7XG5cblx0XHRzZWxmLm9wdGlvbnNbdmFsdWVfbmV3XSA9IGRhdGE7XG5cblx0XHQvLyB1cGRhdGUgdGhlIG9wdGlvbiBpZiBpdCdzIGluIHRoZSBkcm9wZG93blxuXHRcdGlmKCBvcHRpb24gKXtcblx0XHRcdGlmKCBzZWxmLmRyb3Bkb3duX2NvbnRlbnQuY29udGFpbnMob3B0aW9uKSApe1xuXG5cdFx0XHRcdGNvbnN0IG9wdGlvbl9uZXdcdD0gc2VsZi5fcmVuZGVyKCdvcHRpb24nLCBkYXRhKTtcblx0XHRcdFx0cmVwbGFjZU5vZGUob3B0aW9uLCBvcHRpb25fbmV3KTtcblxuXHRcdFx0XHRpZiggc2VsZi5hY3RpdmVPcHRpb24gPT09IG9wdGlvbiApe1xuXHRcdFx0XHRcdHNlbGYuc2V0QWN0aXZlT3B0aW9uKG9wdGlvbl9uZXcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcHRpb24ucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIHRoZSBpdGVtIGlmIHdlIGhhdmUgb25lXG5cdFx0aWYoIGl0ZW0gKXtcblx0XHRcdGluZGV4X2l0ZW0gPSBzZWxmLml0ZW1zLmluZGV4T2YodmFsdWVfb2xkKTtcblx0XHRcdGlmIChpbmRleF9pdGVtICE9PSAtMSkge1xuXHRcdFx0XHRzZWxmLml0ZW1zLnNwbGljZShpbmRleF9pdGVtLCAxLCB2YWx1ZV9uZXcpO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtX25ld1x0PSBzZWxmLl9yZW5kZXIoJ2l0ZW0nLCBkYXRhKTtcblxuXHRcdFx0aWYoIGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSApIGFkZENsYXNzZXMoaXRlbV9uZXcsJ2FjdGl2ZScpO1xuXG5cdFx0XHRyZXBsYWNlTm9kZSggaXRlbSwgaXRlbV9uZXcpO1xuXHRcdH1cblxuXHRcdC8vIGludmFsaWRhdGUgbGFzdCBxdWVyeSBiZWNhdXNlIHdlIG1pZ2h0IGhhdmUgdXBkYXRlZCB0aGUgc29ydEZpZWxkXG5cdFx0c2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBzaW5nbGUgb3B0aW9uLlxuXHQgKlxuXHQgKi9cblx0cmVtb3ZlT3B0aW9uKHZhbHVlOnN0cmluZywgc2lsZW50Pzpib29sZWFuKTp2b2lkIHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHR2YWx1ZSA9IGdldF9oYXNoKHZhbHVlKTtcblxuXHRcdHNlbGYudW5jYWNoZVZhbHVlKHZhbHVlKTtcblxuXHRcdGRlbGV0ZSBzZWxmLnVzZXJPcHRpb25zW3ZhbHVlXTtcblx0XHRkZWxldGUgc2VsZi5vcHRpb25zW3ZhbHVlXTtcblx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdFx0c2VsZi50cmlnZ2VyKCdvcHRpb25fcmVtb3ZlJywgdmFsdWUpO1xuXHRcdHNlbGYucmVtb3ZlSXRlbSh2YWx1ZSwgc2lsZW50KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgYWxsIG9wdGlvbnMuXG5cdCAqL1xuXHRjbGVhck9wdGlvbnMoZmlsdGVyPzpUb21DbGVhckZpbHRlciApIHtcblxuXHRcdGNvbnN0IGJvdW5kRmlsdGVyID0gKGZpbHRlciB8fCB0aGlzLmNsZWFyRmlsdGVyKS5iaW5kKHRoaXMpO1xuXG5cdFx0dGhpcy5sb2FkZWRTZWFyY2hlc1x0XHQ9IHt9O1xuXHRcdHRoaXMudXNlck9wdGlvbnNcdFx0PSB7fTtcblx0XHR0aGlzLmNsZWFyQ2FjaGUoKTtcblxuXHRcdGNvbnN0IHNlbGVjdGVkOlRvbU9wdGlvbnNcdD0ge307XG5cdFx0aXRlcmF0ZSh0aGlzLm9wdGlvbnMsKG9wdGlvbjpUb21PcHRpb24sa2V5OnN0cmluZyk9Pntcblx0XHRcdGlmKCBib3VuZEZpbHRlcihvcHRpb24sa2V5IGFzIHN0cmluZykgKXtcblx0XHRcdFx0c2VsZWN0ZWRba2V5XSA9IG9wdGlvbjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMub3B0aW9ucyA9IHRoaXMuc2lmdGVyLml0ZW1zID0gc2VsZWN0ZWQ7XG5cdFx0dGhpcy5sYXN0UXVlcnkgPSBudWxsO1xuXHRcdHRoaXMudHJpZ2dlcignb3B0aW9uX2NsZWFyJyk7XG5cdH1cblxuXHQvKipcblx0ICogVXNlZCBieSBjbGVhck9wdGlvbnMoKSB0byBkZWNpZGUgd2hldGhlciBvciBub3QgYW4gb3B0aW9uIHNob3VsZCBiZSByZW1vdmVkXG5cdCAqIFJldHVybiB0cnVlIHRvIGtlZXAgYW4gb3B0aW9uLCBmYWxzZSB0byByZW1vdmVcblx0ICpcblx0ICovXG5cdGNsZWFyRmlsdGVyKG9wdGlvbjpUb21PcHRpb24sdmFsdWU6c3RyaW5nKXtcblx0XHRpZiggdGhpcy5pdGVtcy5pbmRleE9mKHZhbHVlKSA+PSAwICl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGRvbSBlbGVtZW50IG9mIHRoZSBvcHRpb25cblx0ICogbWF0Y2hpbmcgdGhlIGdpdmVuIHZhbHVlLlxuXHQgKlxuXHQgKi9cblx0Z2V0T3B0aW9uKHZhbHVlOnVuZGVmaW5lZHxudWxsfGJvb2xlYW58c3RyaW5nfG51bWJlciwgY3JlYXRlOmJvb2xlYW49ZmFsc2UpOm51bGx8SFRNTEVsZW1lbnQge1xuXG5cdFx0Y29uc3QgaGFzaGVkID0gaGFzaF9rZXkodmFsdWUpO1xuXHRcdGlmKCBoYXNoZWQgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc1toYXNoZWRdO1xuXHRcdGlmKCBvcHRpb24gIT0gdW5kZWZpbmVkICl7XG5cblx0XHRcdGlmKCBvcHRpb24uJGRpdiApe1xuXHRcdFx0XHRyZXR1cm4gb3B0aW9uLiRkaXY7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCBjcmVhdGUgKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlbmRlcignb3B0aW9uJywgb3B0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkb20gZWxlbWVudCBvZiB0aGUgbmV4dCBvciBwcmV2aW91cyBkb20gZWxlbWVudCBvZiB0aGUgc2FtZSB0eXBlXG5cdCAqIE5vdGU6IGFkamFjZW50IG9wdGlvbnMgbWF5IG5vdCBiZSBhZGphY2VudCBET00gZWxlbWVudHMgKG9wdGdyb3Vwcylcblx0ICpcblx0ICovXG5cdGdldEFkamFjZW50KCBvcHRpb246bnVsbHxIVE1MRWxlbWVudCwgZGlyZWN0aW9uOm51bWJlciwgdHlwZTpzdHJpbmcgPSAnb3B0aW9uJyApIDogSFRNTEVsZW1lbnR8bnVsbHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIGFsbDtcblxuXHRcdGlmKCAhb3B0aW9uICl7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRpZiggdHlwZSA9PSAnaXRlbScgKXtcblx0XHRcdGFsbFx0XHRcdD0gc2VsZi5jb250cm9sQ2hpbGRyZW4oKTtcblx0XHR9ZWxzZXtcblx0XHRcdGFsbFx0XHRcdD0gc2VsZi5kcm9wZG93bl9jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG5cdFx0fVxuXG5cdFx0Zm9yKCBsZXQgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXtcblx0XHRcdGlmKCBhbGxbaV0gIT0gb3B0aW9uICl7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggZGlyZWN0aW9uID4gMCApe1xuXHRcdFx0XHRyZXR1cm4gYWxsW2krMV0gYXMgSFRNTEVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhbGxbaS0xXSBhcyBIVE1MRWxlbWVudDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkb20gZWxlbWVudCBvZiB0aGUgaXRlbVxuXHQgKiBtYXRjaGluZyB0aGUgZ2l2ZW4gdmFsdWUuXG5cdCAqXG5cdCAqL1xuXHRnZXRJdGVtKGl0ZW06c3RyaW5nfFRvbUl0ZW18bnVsbCk6bnVsbHxUb21JdGVtIHtcblxuXHRcdGlmKCB0eXBlb2YgaXRlbSA9PSAnb2JqZWN0JyApe1xuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fVxuXG5cdFx0dmFyIHZhbHVlID0gaGFzaF9rZXkoaXRlbSk7XG5cdFx0cmV0dXJuIHZhbHVlICE9PSBudWxsXG5cdFx0XHQ/IHRoaXMuY29udHJvbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS12YWx1ZT1cIiR7YWRkU2xhc2hlcyh2YWx1ZSl9XCJdYClcblx0XHRcdDogbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBcIlNlbGVjdHNcIiBtdWx0aXBsZSBpdGVtcyBhdCBvbmNlLiBBZGRzIHRoZW0gdG8gdGhlIGxpc3Rcblx0ICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG5cdCAqXG5cdCAqL1xuXHRhZGRJdGVtcyggdmFsdWVzOnN0cmluZ3xzdHJpbmdbXSwgc2lsZW50Pzpib29sZWFuICk6dm9pZHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHR2YXIgaXRlbXMgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbdmFsdWVzXTtcblx0XHRpdGVtcyA9IGl0ZW1zLmZpbHRlcih4ID0+IHNlbGYuaXRlbXMuaW5kZXhPZih4KSA9PT0gLTEpO1xuXHRcdGNvbnN0IGxhc3RfaXRlbSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuXHRcdGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG5cdFx0XHRzZWxmLmlzUGVuZGluZyA9IChpdGVtICE9PSBsYXN0X2l0ZW0pO1xuXHRcdFx0c2VsZi5hZGRJdGVtKGl0ZW0sIHNpbGVudCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogXCJTZWxlY3RzXCIgYW4gaXRlbS4gQWRkcyBpdCB0byB0aGUgbGlzdFxuXHQgKiBhdCB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbi5cblx0ICpcblx0ICovXG5cdGFkZEl0ZW0oIHZhbHVlOnN0cmluZywgc2lsZW50Pzpib29sZWFuICk6dm9pZHtcblx0XHR2YXIgZXZlbnRzID0gc2lsZW50ID8gW10gOiBbJ2NoYW5nZScsJ2Ryb3Bkb3duX2Nsb3NlJ107XG5cblx0XHRkZWJvdW5jZV9ldmVudHModGhpcywgZXZlbnRzLCAoKSA9PiB7XG5cdFx0XHR2YXIgaXRlbSwgd2FzRnVsbDtcblx0XHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdCBcdGNvbnN0IGlucHV0TW9kZSA9IHNlbGYuc2V0dGluZ3MubW9kZTtcblx0XHRcdGNvbnN0IGhhc2hlZCA9IGhhc2hfa2V5KHZhbHVlKTtcblxuXHRcdFx0aWYoIGhhc2hlZCAmJiBzZWxmLml0ZW1zLmluZGV4T2YoaGFzaGVkKSAhPT0gLTEgKXtcblxuXHRcdFx0XHRpZiggaW5wdXRNb2RlID09PSAnc2luZ2xlJyApe1xuXHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCBpbnB1dE1vZGUgPT09ICdzaW5nbGUnIHx8ICFzZWxmLnNldHRpbmdzLmR1cGxpY2F0ZXMgKXtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGhhc2hlZCA9PT0gbnVsbCB8fCAhc2VsZi5vcHRpb25zLmhhc093blByb3BlcnR5KGhhc2hlZCkpIHJldHVybjtcblx0XHRcdGlmIChpbnB1dE1vZGUgPT09ICdzaW5nbGUnKSBzZWxmLmNsZWFyKHNpbGVudCk7XG5cdFx0XHRpZiAoaW5wdXRNb2RlID09PSAnbXVsdGknICYmIHNlbGYuaXNGdWxsKCkpIHJldHVybjtcblxuXHRcdFx0aXRlbSA9IHNlbGYuX3JlbmRlcignaXRlbScsIHNlbGYub3B0aW9uc1toYXNoZWRdKTtcblxuXHRcdFx0aWYoIHNlbGYuY29udHJvbC5jb250YWlucyhpdGVtKSApeyAvLyBkdXBsaWNhdGVzXG5cdFx0XHRcdGl0ZW0gPSBpdGVtLmNsb25lTm9kZSh0cnVlKSBhcyBIVE1MRWxlbWVudDtcblx0XHRcdH1cblxuXHRcdFx0d2FzRnVsbCA9IHNlbGYuaXNGdWxsKCk7XG5cdFx0XHRzZWxmLml0ZW1zLnNwbGljZShzZWxmLmNhcmV0UG9zLCAwLCBoYXNoZWQpO1xuXHRcdFx0c2VsZi5pbnNlcnRBdENhcmV0KGl0ZW0pO1xuXG5cdFx0XHRpZiAoc2VsZi5pc1NldHVwKSB7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIG1lbnUgLyByZW1vdmUgdGhlIG9wdGlvbiAoaWYgdGhpcyBpcyBub3Qgb25lIGl0ZW0gYmVpbmcgYWRkZWQgYXMgcGFydCBvZiBzZXJpZXMpXG5cdFx0XHRcdGlmKCAhc2VsZi5pc1BlbmRpbmcgJiYgc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQgKXtcblx0XHRcdFx0XHRsZXQgb3B0aW9uID0gc2VsZi5nZXRPcHRpb24oaGFzaGVkKTtcblx0XHRcdFx0XHRsZXQgbmV4dCA9IHNlbGYuZ2V0QWRqYWNlbnQob3B0aW9uLCAxKTtcblx0XHRcdFx0XHRpZiggbmV4dCApe1xuXHRcdFx0XHRcdFx0c2VsZi5zZXRBY3RpdmVPcHRpb24obmV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVmcmVzaE9wdGlvbnMgYWZ0ZXIgc2V0QWN0aXZlT3B0aW9uKCksXG5cdFx0XHRcdC8vIG90aGVyd2lzZSBzZXRBY3RpdmVPcHRpb24oKSB3aWxsIGJlIGNhbGxlZCBieSByZWZyZXNoT3B0aW9ucygpIHdpdGggdGhlIHdyb25nIHZhbHVlXG5cdFx0XHRcdGlmKCAhc2VsZi5pc1BlbmRpbmcgJiYgIXNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCApe1xuXHRcdFx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoc2VsZi5pc0ZvY3VzZWQgJiYgaW5wdXRNb2RlICE9PSAnc2luZ2xlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBoaWRlIHRoZSBtZW51IGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyBoYXZlIGJlZW4gc2VsZWN0ZWQgb3Igbm8gb3B0aW9ucyBhcmUgbGVmdFxuXHRcdFx0XHRpZiggc2VsZi5zZXR0aW5ncy5jbG9zZUFmdGVyU2VsZWN0ICE9IGZhbHNlICYmIHNlbGYuaXNGdWxsKCkgKXtcblx0XHRcdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXNlbGYuaXNQZW5kaW5nKSB7XG5cdFx0XHRcdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZWxmLnRyaWdnZXIoJ2l0ZW1fYWRkJywgaGFzaGVkLCBpdGVtKTtcblxuXHRcdFx0XHRpZiAoIXNlbGYuaXNQZW5kaW5nKSB7XG5cdFx0XHRcdFx0c2VsZi51cGRhdGVPcmlnaW5hbElucHV0KHtzaWxlbnQ6IHNpbGVudH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICghc2VsZi5pc1BlbmRpbmcgfHwgKCF3YXNGdWxsICYmIHNlbGYuaXNGdWxsKCkpKSB7XG5cdFx0XHRcdHNlbGYuaW5wdXRTdGF0ZSgpO1xuXHRcdFx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgc2VsZWN0ZWQgaXRlbSBtYXRjaGluZ1xuXHQgKiB0aGUgcHJvdmlkZWQgdmFsdWUuXG5cdCAqXG5cdCAqL1xuXHRyZW1vdmVJdGVtKCBpdGVtOnN0cmluZ3xUb21JdGVtfG51bGw9bnVsbCwgc2lsZW50Pzpib29sZWFuICl7XG5cdFx0Y29uc3Qgc2VsZlx0XHQ9IHRoaXM7XG5cdFx0aXRlbVx0XHRcdD0gc2VsZi5nZXRJdGVtKGl0ZW0pO1xuXG5cdFx0aWYoICFpdGVtICkgcmV0dXJuO1xuXG5cdFx0dmFyIGksaWR4O1xuXHRcdGNvbnN0IHZhbHVlXHQ9IGl0ZW0uZGF0YXNldC52YWx1ZTtcblx0XHRpID0gbm9kZUluZGV4KGl0ZW0pO1xuXG5cdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRpZiggaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICl7XG5cdFx0XHRpZHggPSBzZWxmLmFjdGl2ZUl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cdFx0XHRzZWxmLmFjdGl2ZUl0ZW1zLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0cmVtb3ZlQ2xhc3NlcyhpdGVtLCdhY3RpdmUnKTtcblx0XHR9XG5cblx0XHRzZWxmLml0ZW1zLnNwbGljZShpLCAxKTtcblx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdFx0aWYgKCFzZWxmLnNldHRpbmdzLnBlcnNpc3QgJiYgc2VsZi51c2VyT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcblx0XHRcdHNlbGYucmVtb3ZlT3B0aW9uKHZhbHVlLCBzaWxlbnQpO1xuXHRcdH1cblxuXHRcdGlmIChpIDwgc2VsZi5jYXJldFBvcykge1xuXHRcdFx0c2VsZi5zZXRDYXJldChzZWxmLmNhcmV0UG9zIC0gMSk7XG5cdFx0fVxuXG5cdFx0c2VsZi51cGRhdGVPcmlnaW5hbElucHV0KHtzaWxlbnQ6IHNpbGVudH0pO1xuXHRcdHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0c2VsZi50cmlnZ2VyKCdpdGVtX3JlbW92ZScsIHZhbHVlLCBpdGVtKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEludm9rZXMgdGhlIGBjcmVhdGVgIG1ldGhvZCBwcm92aWRlZCBpbiB0aGVcblx0ICogVG9tU2VsZWN0IG9wdGlvbnMgdGhhdCBzaG91bGQgcHJvdmlkZSB0aGUgZGF0YVxuXHQgKiBmb3IgdGhlIG5ldyBpdGVtLCBnaXZlbiB0aGUgdXNlciBpbnB1dC5cblx0ICpcblx0ICogT25jZSB0aGlzIGNvbXBsZXRlcywgaXQgd2lsbCBiZSBhZGRlZFxuXHQgKiB0byB0aGUgaXRlbSBsaXN0LlxuXHQgKlxuXHQgKi9cblx0Y3JlYXRlSXRlbSggaW5wdXQ6bnVsbHxzdHJpbmc9bnVsbCwgY2FsbGJhY2s6VG9tQ3JlYXRlQ2FsbGJhY2sgPSAoKT0+e30gKTpib29sZWFue1xuXG5cdFx0Ly8gdHJpZ2dlckRyb3Bkb3duIHBhcmFtZXRlciBAZGVwcmVjYXRlZCAyLjEuMVxuXHRcdGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAzICl7XG5cdFx0XHRjYWxsYmFjayA9IGFyZ3VtZW50c1syXTtcblx0XHR9XG5cdFx0aWYoIHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nICl7XG5cdFx0XHRjYWxsYmFjayA9ICgpID0+IHt9O1xuXHRcdH1cblxuXHRcdHZhciBzZWxmICA9IHRoaXM7XG5cdFx0dmFyIGNhcmV0ID0gc2VsZi5jYXJldFBvcztcblx0XHR2YXIgb3V0cHV0O1xuXHRcdGlucHV0ID0gaW5wdXQgfHwgc2VsZi5pbnB1dFZhbHVlKCk7XG5cblx0XHRpZiAoIXNlbGYuY2FuQ3JlYXRlKGlucHV0KSkge1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRzZWxmLmxvY2soKTtcblxuXHRcdHZhciBjcmVhdGVkID0gZmFsc2U7XG5cdFx0dmFyIGNyZWF0ZSA9IChkYXRhPzpib29sZWFufFRvbU9wdGlvbikgPT4ge1xuXHRcdFx0c2VsZi51bmxvY2soKTtcblxuXHRcdFx0aWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JykgcmV0dXJuIGNhbGxiYWNrKCk7XG5cdFx0XHR2YXIgdmFsdWUgPSBoYXNoX2tleShkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuXHRcdFx0aWYoIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgKXtcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKCk7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGYuc2V0VGV4dGJveFZhbHVlKCk7XG5cdFx0XHRzZWxmLmFkZE9wdGlvbihkYXRhLHRydWUpO1xuXHRcdFx0c2VsZi5zZXRDYXJldChjYXJldCk7XG5cdFx0XHRzZWxmLmFkZEl0ZW0odmFsdWUpO1xuXHRcdFx0Y2FsbGJhY2soZGF0YSk7XG5cdFx0XHRjcmVhdGVkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0aWYoIHR5cGVvZiBzZWxmLnNldHRpbmdzLmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJyApe1xuXHRcdFx0b3V0cHV0ID0gc2VsZi5zZXR0aW5ncy5jcmVhdGUuY2FsbCh0aGlzLCBpbnB1dCwgY3JlYXRlKTtcblx0XHR9ZWxzZXtcblx0XHRcdG91dHB1dCA9IHtcblx0XHRcdFx0W3NlbGYuc2V0dGluZ3MubGFiZWxGaWVsZF06IGlucHV0LFxuXHRcdFx0XHRbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXTogaW5wdXQsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmKCAhY3JlYXRlZCApe1xuXHRcdFx0Y3JlYXRlKG91dHB1dCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogUmUtcmVuZGVycyB0aGUgc2VsZWN0ZWQgaXRlbSBsaXN0cy5cblx0ICovXG5cdHJlZnJlc2hJdGVtcygpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXG5cdFx0aWYgKHNlbGYuaXNTZXR1cCkge1xuXHRcdFx0c2VsZi5hZGRJdGVtcyhzZWxmLml0ZW1zKTtcblx0XHR9XG5cblx0XHRzZWxmLnVwZGF0ZU9yaWdpbmFsSW5wdXQoKTtcblx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgYWxsIHN0YXRlLWRlcGVuZGVudCBhdHRyaWJ1dGVzXG5cdCAqIGFuZCBDU1MgY2xhc3Nlcy5cblx0ICovXG5cdHJlZnJlc2hTdGF0ZSgpIHtcblx0XHRjb25zdCBzZWxmICAgICA9IHRoaXM7XG5cblx0XHRzZWxmLnJlZnJlc2hWYWxpZGl0eVN0YXRlKCk7XG5cblx0XHRjb25zdCBpc0Z1bGxcdD0gc2VsZi5pc0Z1bGwoKTtcblx0XHRjb25zdCBpc0xvY2tlZFx0PSBzZWxmLmlzTG9ja2VkO1xuXG5cdFx0c2VsZi53cmFwcGVyLmNsYXNzTGlzdC50b2dnbGUoJ3J0bCcsc2VsZi5ydGwpO1xuXG5cblx0XHRjb25zdCB3cmFwX2NsYXNzTGlzdCA9IHNlbGYud3JhcHBlci5jbGFzc0xpc3Q7XG5cblx0XHR3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2ZvY3VzJywgc2VsZi5pc0ZvY3VzZWQpXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdkaXNhYmxlZCcsIHNlbGYuaXNEaXNhYmxlZClcblx0XHR3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ3JlYWRvbmx5Jywgc2VsZi5pc1JlYWRPbmx5KVxuXHRcdHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgncmVxdWlyZWQnLCBzZWxmLmlzUmVxdWlyZWQpXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdpbnZhbGlkJywgIXNlbGYuaXNWYWxpZClcblx0XHR3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2xvY2tlZCcsIGlzTG9ja2VkKVxuXHRcdHdyYXBfY2xhc3NMaXN0LnRvZ2dsZSgnZnVsbCcsIGlzRnVsbClcblx0XHR3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2lucHV0LWFjdGl2ZScsIHNlbGYuaXNGb2N1c2VkICYmICFzZWxmLmlzSW5wdXRIaWRkZW4pXG5cdFx0d3JhcF9jbGFzc0xpc3QudG9nZ2xlKCdkcm9wZG93bi1hY3RpdmUnLCBzZWxmLmlzT3Blbilcblx0XHR3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2hhcy1vcHRpb25zJywgaXNFbXB0eU9iamVjdChzZWxmLm9wdGlvbnMpIClcblx0XHR3cmFwX2NsYXNzTGlzdC50b2dnbGUoJ2hhcy1pdGVtcycsIHNlbGYuaXRlbXMubGVuZ3RoID4gMCk7XG5cblx0fVxuXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUgb2YgYm90aCBpbnB1dCBhbmQgY29udHJvbCBpbnB1dC5cblx0ICpcblx0ICogVGhlIGByZXF1aXJlZGAgcHJvcGVydHkgbmVlZHMgdG8gYmUgYWN0aXZhdGVkIG9uIHRoZSBjb250cm9sIGlucHV0XG5cdCAqIGZvciB0aGUgZXJyb3IgdG8gYmUgZGlzcGxheWVkIGF0IHRoZSByaWdodCBwbGFjZS4gYHJlcXVpcmVkYCBhbHNvXG5cdCAqIG5lZWRzIHRvIGJlIHRlbXBvcmFyaWx5IGRlYWN0aXZhdGVkIG9uIHRoZSBpbnB1dCBzaW5jZSB0aGUgaW5wdXQgaXNcblx0ICogaGlkZGVuIGFuZCBjYW4ndCBzaG93IGVycm9ycy5cblx0ICovXG5cdHJlZnJlc2hWYWxpZGl0eVN0YXRlKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGlmKCAhc2VsZi5pbnB1dC52YWxpZGl0eSApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHNlbGYuaXNWYWxpZCA9IHNlbGYuaW5wdXQudmFsaWRpdHkudmFsaWQ7XG5cdFx0c2VsZi5pc0ludmFsaWQgPSAhc2VsZi5pc1ZhbGlkO1xuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgbW9yZSBpdGVtcyBjYW4gYmUgYWRkZWRcblx0ICogdG8gdGhlIGNvbnRyb2wgd2l0aG91dCBleGNlZWRpbmcgdGhlIHVzZXItZGVmaW5lZCBtYXhpbXVtLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzRnVsbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncy5tYXhJdGVtcyAhPT0gbnVsbCAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+PSB0aGlzLnNldHRpbmdzLm1heEl0ZW1zO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZnJlc2hlcyB0aGUgb3JpZ2luYWwgPHNlbGVjdD4gb3IgPGlucHV0PlxuXHQgKiBlbGVtZW50IHRvIHJlZmxlY3QgdGhlIGN1cnJlbnQgc3RhdGUuXG5cdCAqXG5cdCAqL1xuXHR1cGRhdGVPcmlnaW5hbElucHV0KCBvcHRzOlRvbUFyZ09iamVjdCA9IHt9ICl7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbiwgbGFiZWw7XG5cblx0XHRjb25zdCBlbXB0eV9vcHRpb24gPSBzZWxmLmlucHV0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvblt2YWx1ZT1cIlwiXScpIGFzIEhUTUxPcHRpb25FbGVtZW50O1xuXG5cdFx0aWYoIHNlbGYuaXNfc2VsZWN0X3RhZyApe1xuXG5cdFx0XHRjb25zdCBzZWxlY3RlZDpIVE1MT3B0aW9uRWxlbWVudFtdXHRcdD0gW107XG5cdFx0XHRjb25zdCBoYXNfc2VsZWN0ZWQ6bnVtYmVyXHRcdFx0XHQ9IHNlbGYuaW5wdXQucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uOmNoZWNrZWQnKS5sZW5ndGg7XG5cblx0XHRcdGZ1bmN0aW9uIEFkZFNlbGVjdGVkKG9wdGlvbl9lbDpIVE1MT3B0aW9uRWxlbWVudHxudWxsLCB2YWx1ZTpzdHJpbmcsIGxhYmVsOnN0cmluZyk6SFRNTE9wdGlvbkVsZW1lbnR7XG5cblx0XHRcdFx0aWYoICFvcHRpb25fZWwgKXtcblx0XHRcdFx0XHRvcHRpb25fZWwgPSBnZXREb20oJzxvcHRpb24gdmFsdWU9XCInICsgZXNjYXBlX2h0bWwodmFsdWUpICsgJ1wiPicgKyBlc2NhcGVfaHRtbChsYWJlbCkgKyAnPC9vcHRpb24+JykgYXMgSFRNTE9wdGlvbkVsZW1lbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBkb24ndCBtb3ZlIGVtcHR5IG9wdGlvbiBmcm9tIHRvcCBvZiBsaXN0XG5cdFx0XHRcdC8vIGZpeGVzIGJ1ZyBpbiBmaXJlZm94IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE3MjUyOTNcblx0XHRcdFx0aWYoIG9wdGlvbl9lbCAhPSBlbXB0eV9vcHRpb24gKXtcblx0XHRcdFx0XHRzZWxmLmlucHV0LmFwcGVuZChvcHRpb25fZWwpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2VsZWN0ZWQucHVzaChvcHRpb25fZWwpO1xuXG5cdFx0XHRcdC8vIG1hcmtpbmcgZW1wdHkgb3B0aW9uIGFzIHNlbGVjdGVkIGNhbiBicmVhayB2YWxpZGF0aW9uXG5cdFx0XHRcdC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmNoaWRqcy90b20tc2VsZWN0L2lzc3Vlcy8zMDNcblx0XHRcdFx0aWYoIG9wdGlvbl9lbCAhPSBlbXB0eV9vcHRpb24gfHwgaGFzX3NlbGVjdGVkID4gMCApe1xuXHRcdFx0XHRcdG9wdGlvbl9lbC5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gb3B0aW9uX2VsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB1bnNlbGVjdCBhbGwgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0c2VsZi5pbnB1dC5xdWVyeVNlbGVjdG9yQWxsKCdvcHRpb246Y2hlY2tlZCcpLmZvckVhY2goKG9wdGlvbl9lbDpFbGVtZW50KSA9PiB7XG5cdFx0XHRcdCg8SFRNTE9wdGlvbkVsZW1lbnQ+b3B0aW9uX2VsKS5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0fSk7XG5cblxuXHRcdFx0Ly8gbm90aGluZyBzZWxlY3RlZD9cblx0XHRcdGlmKCBzZWxmLml0ZW1zLmxlbmd0aCA9PSAwICYmIHNlbGYuc2V0dGluZ3MubW9kZSA9PSAnc2luZ2xlJyApe1xuXG5cdFx0XHRcdEFkZFNlbGVjdGVkKGVtcHR5X29wdGlvbiwgXCJcIiwgXCJcIik7XG5cblx0XHRcdC8vIG9yZGVyIHNlbGVjdGVkIDxvcHRpb24+IHRhZ3MgZm9yIHZhbHVlcyBpbiBzZWxmLml0ZW1zXG5cdFx0XHR9ZWxzZXtcblxuXHRcdFx0XHRzZWxmLml0ZW1zLmZvckVhY2goKHZhbHVlKT0+e1xuXHRcdFx0XHRcdG9wdGlvblx0XHRcdD0gc2VsZi5vcHRpb25zW3ZhbHVlXSE7XG5cdFx0XHRcdFx0bGFiZWxcdFx0XHQ9IG9wdGlvbltzZWxmLnNldHRpbmdzLmxhYmVsRmllbGRdIHx8ICcnO1xuXG5cdFx0XHRcdFx0aWYoIHNlbGVjdGVkLmluY2x1ZGVzKG9wdGlvbi4kb3B0aW9uKSApe1xuXHRcdFx0XHRcdFx0Y29uc3QgcmV1c2Vfb3B0ID0gc2VsZi5pbnB1dC5xdWVyeVNlbGVjdG9yKGBvcHRpb25bdmFsdWU9XCIke2FkZFNsYXNoZXModmFsdWUpfVwiXTpub3QoOmNoZWNrZWQpYCkgYXMgSFRNTE9wdGlvbkVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRBZGRTZWxlY3RlZChyZXVzZV9vcHQsIHZhbHVlLCBsYWJlbCk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRvcHRpb24uJG9wdGlvblx0PSBBZGRTZWxlY3RlZChvcHRpb24uJG9wdGlvbiwgdmFsdWUsIGxhYmVsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0c2VsZi5pbnB1dC52YWx1ZSA9IHNlbGYuZ2V0VmFsdWUoKSBhcyBzdHJpbmc7XG5cdFx0fVxuXG5cdFx0aWYgKHNlbGYuaXNTZXR1cCkge1xuXHRcdFx0aWYgKCFvcHRzLnNpbGVudCkge1xuXHRcdFx0XHRzZWxmLnRyaWdnZXIoJ2NoYW5nZScsIHNlbGYuZ2V0VmFsdWUoKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTaG93cyB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIGNvbnRhaW5pbmdcblx0ICogdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuXHQgKi9cblx0b3BlbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoc2VsZi5pc0xvY2tlZCB8fCBzZWxmLmlzT3BlbiB8fCAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnbXVsdGknICYmIHNlbGYuaXNGdWxsKCkpKSByZXR1cm47XG5cdFx0c2VsZi5pc09wZW4gPSB0cnVlO1xuXHRcdHNldEF0dHIoc2VsZi5mb2N1c19ub2RlLHsnYXJpYS1leHBhbmRlZCc6ICd0cnVlJ30pO1xuXHRcdHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cdFx0YXBwbHlDU1Moc2VsZi5kcm9wZG93bix7dmlzaWJpbGl0eTogJ2hpZGRlbicsIGRpc3BsYXk6ICdibG9jayd9KTtcblx0XHRzZWxmLnBvc2l0aW9uRHJvcGRvd24oKTtcblx0XHRhcHBseUNTUyhzZWxmLmRyb3Bkb3duLHt2aXNpYmlsaXR5OiAndmlzaWJsZScsIGRpc3BsYXk6ICdibG9jayd9KTtcblx0XHRzZWxmLmZvY3VzKCk7XG5cdFx0c2VsZi50cmlnZ2VyKCdkcm9wZG93bl9vcGVuJywgc2VsZi5kcm9wZG93bik7XG5cdH1cblxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gbWVudS5cblx0ICovXG5cdGNsb3NlKHNldFRleHRib3hWYWx1ZT10cnVlKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciB0cmlnZ2VyID0gc2VsZi5pc09wZW47XG5cblx0XHRpZiggc2V0VGV4dGJveFZhbHVlICl7XG5cblx0XHRcdC8vIGJlZm9yZSBibHVyKCkgdG8gcHJldmVudCBmb3JtIG9uY2hhbmdlIGV2ZW50XG5cdFx0XHRzZWxmLnNldFRleHRib3hWYWx1ZSgpO1xuXG5cdFx0XHRpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJyAmJiBzZWxmLml0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRzZWxmLmlucHV0U3RhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZWxmLmlzT3BlbiA9IGZhbHNlO1xuXHRcdHNldEF0dHIoc2VsZi5mb2N1c19ub2RlLHsnYXJpYS1leHBhbmRlZCc6ICdmYWxzZSd9KTtcblx0XHRhcHBseUNTUyhzZWxmLmRyb3Bkb3duLHtkaXNwbGF5OiAnbm9uZSd9KTtcblx0XHRpZiggc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQgKXtcblx0XHRcdHNlbGYuY2xlYXJBY3RpdmVPcHRpb24oKTtcblx0XHR9XG5cdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblxuXHRcdGlmICh0cmlnZ2VyKSBzZWxmLnRyaWdnZXIoJ2Ryb3Bkb3duX2Nsb3NlJywgc2VsZi5kcm9wZG93bik7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyBhbmQgYXBwbGllcyB0aGUgYXBwcm9wcmlhdGVcblx0ICogcG9zaXRpb24gb2YgdGhlIGRyb3Bkb3duIGlmIGRyb3Bkb3duUGFyZW50ID0gJ2JvZHknLlxuXHQgKiBPdGhlcndpc2UsIHBvc2l0aW9uIGlzIGRldGVybWluZWQgYnkgY3NzXG5cdCAqL1xuXHRwb3NpdGlvbkRyb3Bkb3duKCl7XG5cblx0XHRpZiggdGhpcy5zZXR0aW5ncy5kcm9wZG93blBhcmVudCAhPT0gJ2JvZHknICl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRleHRcdFx0XHQ9IHRoaXMuY29udHJvbDtcblx0XHR2YXIgcmVjdFx0XHRcdD0gY29udGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR2YXIgdG9wXHRcdFx0XHQ9IGNvbnRleHQub2Zmc2V0SGVpZ2h0ICsgcmVjdC50b3AgICsgd2luZG93LnNjcm9sbFk7XG5cdFx0dmFyIGxlZnRcdFx0XHQ9IHJlY3QubGVmdCArIHdpbmRvdy5zY3JvbGxYO1xuXG5cblx0XHRhcHBseUNTUyh0aGlzLmRyb3Bkb3duLHtcblx0XHRcdHdpZHRoIDogcmVjdC53aWR0aCArICdweCcsXG5cdFx0XHR0b3AgICA6IHRvcCArICdweCcsXG5cdFx0XHRsZWZ0ICA6IGxlZnQgKyAncHgnXG5cdFx0fSk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldHMgLyBjbGVhcnMgYWxsIHNlbGVjdGVkIGl0ZW1zXG5cdCAqIGZyb20gdGhlIGNvbnRyb2wuXG5cdCAqXG5cdCAqL1xuXHRjbGVhcihzaWxlbnQ/OmJvb2xlYW4pIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIXNlbGYuaXRlbXMubGVuZ3RoKSByZXR1cm47XG5cblx0XHR2YXIgaXRlbXMgPSBzZWxmLmNvbnRyb2xDaGlsZHJlbigpO1xuXHRcdGl0ZXJhdGUoaXRlbXMsKGl0ZW06VG9tSXRlbSk9Pntcblx0XHRcdHNlbGYucmVtb3ZlSXRlbShpdGVtLHRydWUpO1xuXHRcdH0pO1xuXG5cdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0aWYoICFzaWxlbnQgKSBzZWxmLnVwZGF0ZU9yaWdpbmFsSW5wdXQoKTtcblx0XHRzZWxmLnRyaWdnZXIoJ2NsZWFyJyk7XG5cdH1cblxuXHQvKipcblx0ICogQSBoZWxwZXIgbWV0aG9kIGZvciBpbnNlcnRpbmcgYW4gZWxlbWVudFxuXHQgKiBhdCB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbi5cblx0ICpcblx0ICovXG5cdGluc2VydEF0Q2FyZXQoZWw6SFRNTEVsZW1lbnQpIHtcblx0XHRjb25zdCBzZWxmXHRcdD0gdGhpcztcblx0XHRjb25zdCBjYXJldFx0XHQ9IHNlbGYuY2FyZXRQb3M7XG5cdFx0Y29uc3QgdGFyZ2V0XHQ9IHNlbGYuY29udHJvbDtcblxuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldC5jaGlsZHJlbltjYXJldF0gfHwgbnVsbCk7XG5cdFx0c2VsZi5zZXRDYXJldChjYXJldCArIDEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgaXRlbShzKS5cblx0ICpcblx0ICovXG5cdGRlbGV0ZVNlbGVjdGlvbihlOktleWJvYXJkRXZlbnQpOmJvb2xlYW4ge1xuXHRcdHZhciBkaXJlY3Rpb24sIHNlbGVjdGlvbiwgY2FyZXQsIHRhaWw7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0ZGlyZWN0aW9uID0gKGUgJiYgZS5rZXlDb2RlID09PSBjb25zdGFudHMuS0VZX0JBQ0tTUEFDRSkgPyAtMSA6IDE7XG5cdFx0c2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHNlbGYuY29udHJvbF9pbnB1dCk7XG5cblxuXHRcdC8vIGRldGVybWluZSBpdGVtcyB0aGF0IHdpbGwgYmUgcmVtb3ZlZFxuXHRcdGNvbnN0IHJtX2l0ZW1zOlRvbUl0ZW1bXVx0PSBbXTtcblxuXHRcdGlmIChzZWxmLmFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuXG5cdFx0XHR0YWlsID0gZ2V0VGFpbChzZWxmLmFjdGl2ZUl0ZW1zLCBkaXJlY3Rpb24pO1xuXHRcdFx0Y2FyZXQgPSBub2RlSW5kZXgodGFpbCk7XG5cblx0XHRcdGlmIChkaXJlY3Rpb24gPiAwKSB7IGNhcmV0Kys7IH1cblxuXHRcdFx0aXRlcmF0ZShzZWxmLmFjdGl2ZUl0ZW1zLCAoaXRlbTpUb21JdGVtKSA9PiBybV9pdGVtcy5wdXNoKGl0ZW0pICk7XG5cblx0XHR9IGVsc2UgaWYgKChzZWxmLmlzRm9jdXNlZCB8fCBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnKSAmJiBzZWxmLml0ZW1zLmxlbmd0aCkge1xuXHRcdFx0Y29uc3QgaXRlbXMgPSBzZWxmLmNvbnRyb2xDaGlsZHJlbigpO1xuXHRcdFx0bGV0IHJtX2l0ZW07XG5cdFx0XHRpZiggZGlyZWN0aW9uIDwgMCAmJiBzZWxlY3Rpb24uc3RhcnQgPT09IDAgJiYgc2VsZWN0aW9uLmxlbmd0aCA9PT0gMCApe1xuXHRcdFx0XHRybV9pdGVtID0gaXRlbXNbc2VsZi5jYXJldFBvcyAtIDFdO1xuXG5cdFx0XHR9ZWxzZSBpZiggZGlyZWN0aW9uID4gMCAmJiBzZWxlY3Rpb24uc3RhcnQgPT09IHNlbGYuaW5wdXRWYWx1ZSgpLmxlbmd0aCApe1xuXHRcdFx0XHRybV9pdGVtID0gaXRlbXNbc2VsZi5jYXJldFBvc107XG5cdFx0XHR9XG5cblx0XHRcdGlmKCBybV9pdGVtICE9PSB1bmRlZmluZWQgKXtcblx0XHRcdFx0cm1faXRlbXMucHVzaCggcm1faXRlbSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKCAhc2VsZi5zaG91bGREZWxldGUocm1faXRlbXMsZSkgKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcmV2ZW50RGVmYXVsdChlLHRydWUpO1xuXG5cdFx0Ly8gcGVyZm9ybSByZW1vdmFsXG5cdFx0aWYgKHR5cGVvZiBjYXJldCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHNlbGYuc2V0Q2FyZXQoY2FyZXQpO1xuXHRcdH1cblxuXHRcdHdoaWxlKCBybV9pdGVtcy5sZW5ndGggKXtcblx0XHRcdHNlbGYucmVtb3ZlSXRlbShybV9pdGVtcy5wb3AoKSk7XG5cdFx0fVxuXG5cdFx0c2VsZi5pbnB1dFN0YXRlKCk7XG5cdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0c2VsZi5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgaXRlbXMgc2hvdWxkIGJlIGRlbGV0ZWRcblx0ICovXG5cdHNob3VsZERlbGV0ZShpdGVtczpUb21JdGVtW10sZXZ0Ok1vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudCl7XG5cblx0XHRjb25zdCB2YWx1ZXMgPSBpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLmRhdGFzZXQudmFsdWUpO1xuXG5cdFx0Ly8gYWxsb3cgdGhlIGNhbGxiYWNrIHRvIGFib3J0XG5cdFx0aWYoICF2YWx1ZXMubGVuZ3RoIHx8ICh0eXBlb2YgdGhpcy5zZXR0aW5ncy5vbkRlbGV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnNldHRpbmdzLm9uRGVsZXRlKHZhbHVlcyxldnQpID09PSBmYWxzZSkgKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWxlY3RzIHRoZSBwcmV2aW91cyAvIG5leHQgaXRlbSAoZGVwZW5kaW5nIG9uIHRoZSBgZGlyZWN0aW9uYCBhcmd1bWVudCkuXG5cdCAqXG5cdCAqID4gMCAtIHJpZ2h0XG5cdCAqIDwgMCAtIGxlZnRcblx0ICpcblx0ICovXG5cdGFkdmFuY2VTZWxlY3Rpb24oZGlyZWN0aW9uOm51bWJlciwgZT86TW91c2VFdmVudHxLZXlib2FyZEV2ZW50KSB7XG5cdFx0dmFyIGxhc3RfYWN0aXZlLCBhZGphY2VudCwgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoc2VsZi5ydGwpIGRpcmVjdGlvbiAqPSAtMTtcblx0XHRpZiggc2VsZi5pbnB1dFZhbHVlKCkubGVuZ3RoICkgcmV0dXJuO1xuXG5cblx0XHQvLyBhZGQgb3IgcmVtb3ZlIHRvIGFjdGl2ZSBpdGVtc1xuXHRcdGlmKCBpc0tleURvd24oY29uc3RhbnRzLktFWV9TSE9SVENVVCxlKSB8fCBpc0tleURvd24oJ3NoaWZ0S2V5JyxlKSApe1xuXG5cdFx0XHRsYXN0X2FjdGl2ZVx0XHRcdD0gc2VsZi5nZXRMYXN0QWN0aXZlKGRpcmVjdGlvbik7XG5cdFx0XHRpZiggbGFzdF9hY3RpdmUgKXtcblxuXHRcdFx0XHRpZiggIWxhc3RfYWN0aXZlLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgKXtcblx0XHRcdFx0XHRhZGphY2VudFx0XHRcdD0gbGFzdF9hY3RpdmU7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGFkamFjZW50XHRcdFx0PSBzZWxmLmdldEFkamFjZW50KGxhc3RfYWN0aXZlLGRpcmVjdGlvbiwnaXRlbScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIGlmIG5vIGFjdGl2ZSBpdGVtLCBnZXQgaXRlbXMgYWRqYWNlbnQgdG8gdGhlIGNvbnRyb2wgaW5wdXRcblx0XHRcdH1lbHNlIGlmKCBkaXJlY3Rpb24gPiAwICl7XG5cdFx0XHRcdGFkamFjZW50XHRcdFx0PSBzZWxmLmNvbnRyb2xfaW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGFkamFjZW50XHRcdFx0PSBzZWxmLmNvbnRyb2xfaW5wdXQucHJldmlvdXNFbGVtZW50U2libGluZztcblx0XHRcdH1cblxuXG5cdFx0XHRpZiggYWRqYWNlbnQgKXtcblx0XHRcdFx0aWYoIGFkamFjZW50LmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgKXtcblx0XHRcdFx0XHRzZWxmLnJlbW92ZUFjdGl2ZUl0ZW0obGFzdF9hY3RpdmUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuc2V0QWN0aXZlSXRlbUNsYXNzKGFkamFjZW50KTsgLy8gbWFyayBhcyBsYXN0X2FjdGl2ZSAhISBhZnRlciByZW1vdmVBY3RpdmVJdGVtKCkgb24gbGFzdF9hY3RpdmVcblx0XHRcdH1cblxuXHRcdC8vIG1vdmUgY2FyZXQgdG8gdGhlIGxlZnQgb3IgcmlnaHRcblx0XHR9ZWxzZXtcblx0XHRcdHNlbGYubW92ZUNhcmV0KGRpcmVjdGlvbik7XG5cdFx0fVxuXHR9XG5cblx0bW92ZUNhcmV0KGRpcmVjdGlvbjpudW1iZXIpe31cblxuXHQvKipcblx0ICogR2V0IHRoZSBsYXN0IGFjdGl2ZSBpdGVtXG5cdCAqXG5cdCAqL1xuXHRnZXRMYXN0QWN0aXZlKGRpcmVjdGlvbj86bnVtYmVyKXtcblxuXHRcdGxldCBsYXN0X2FjdGl2ZSA9IHRoaXMuY29udHJvbC5xdWVyeVNlbGVjdG9yKCcubGFzdC1hY3RpdmUnKTtcblx0XHRpZiggbGFzdF9hY3RpdmUgKXtcblx0XHRcdHJldHVybiBsYXN0X2FjdGl2ZTtcblx0XHR9XG5cblxuXHRcdHZhciByZXN1bHQgPSB0aGlzLmNvbnRyb2wucXVlcnlTZWxlY3RvckFsbCgnLmFjdGl2ZScpO1xuXHRcdGlmKCByZXN1bHQgKXtcblx0XHRcdHJldHVybiBnZXRUYWlsKHJlc3VsdCxkaXJlY3Rpb24pO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIE1vdmVzIHRoZSBjYXJldCB0byB0aGUgc3BlY2lmaWVkIGluZGV4LlxuXHQgKlxuXHQgKiBUaGUgaW5wdXQgbXVzdCBiZSBtb3ZlZCBieSBsZWF2aW5nIGl0IGluIHBsYWNlIGFuZCBtb3ZpbmcgdGhlXG5cdCAqIHNpYmxpbmdzLCBkdWUgdG8gdGhlIGZhY3QgdGhhdCBmb2N1cyBjYW5ub3QgYmUgcmVzdG9yZWQgb25jZSBsb3N0XG5cdCAqIG9uIG1vYmlsZSB3ZWJraXQgZGV2aWNlc1xuXHQgKlxuXHQgKi9cblx0c2V0Q2FyZXQobmV3X3BvczpudW1iZXIpIHtcblx0XHR0aGlzLmNhcmV0UG9zID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGxpc3Qgb2YgaXRlbSBkb20gZWxlbWVudHNcblx0ICpcblx0ICovXG5cdGNvbnRyb2xDaGlsZHJlbigpOlRvbUl0ZW1bXXtcblx0XHRyZXR1cm4gQXJyYXkuZnJvbSggdGhpcy5jb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRzLWl0ZW1dJykgKSBhcyBUb21JdGVtW107XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZXMgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbC4gVXNlZCB3aGlsZVxuXHQgKiBpdGVtcyBhcmUgYmVpbmcgYXN5bmNocm9ub3VzbHkgY3JlYXRlZC5cblx0ICovXG5cdGxvY2soKSB7XG5cdFx0dGhpcy5zZXRMb2NrZWQodHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmUtZW5hYmxlcyB1c2VyIGlucHV0IG9uIHRoZSBjb250cm9sLlxuXHQgKi9cblx0dW5sb2NrKCkge1xuXHRcdHRoaXMuc2V0TG9ja2VkKGZhbHNlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlIG9yIGVuYWJsZSB1c2VyIGlucHV0IG9uIHRoZSBjb250cm9sXG5cdCAqL1xuXHRzZXRMb2NrZWQoIGxvY2s6Ym9vbGVhbiA9IHRoaXMuaXNSZWFkT25seSB8fCB0aGlzLmlzRGlzYWJsZWQgKXtcblx0XHR0aGlzLmlzTG9ja2VkID0gbG9jaztcblx0XHR0aGlzLnJlZnJlc2hTdGF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc2FibGVzIHVzZXIgaW5wdXQgb24gdGhlIGNvbnRyb2wgY29tcGxldGVseS5cblx0ICogV2hpbGUgZGlzYWJsZWQsIGl0IGNhbm5vdCByZWNlaXZlIGZvY3VzLlxuXHQgKi9cblx0ZGlzYWJsZSgpIHtcblx0XHR0aGlzLnNldERpc2FibGVkKHRydWUpO1xuXHRcdHRoaXMuY2xvc2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIHRoZSBjb250cm9sIHNvIHRoYXQgaXQgY2FuIHJlc3BvbmRcblx0ICogdG8gZm9jdXMgYW5kIHVzZXIgaW5wdXQuXG5cdCAqL1xuXHRlbmFibGUoKSB7XG5cdFx0dGhpcy5zZXREaXNhYmxlZChmYWxzZSk7XG5cdH1cblxuXHRzZXREaXNhYmxlZChkaXNhYmxlZDpib29sZWFuKXtcblx0XHR0aGlzLmZvY3VzX25vZGUudGFiSW5kZXhcdFx0PSBkaXNhYmxlZCA/IC0xIDogdGhpcy50YWJJbmRleDtcblx0XHR0aGlzLmlzRGlzYWJsZWRcdFx0XHRcdFx0PSBkaXNhYmxlZDtcblx0XHR0aGlzLmlucHV0LmRpc2FibGVkXHRcdFx0XHQ9IGRpc2FibGVkO1xuXHRcdHRoaXMuY29udHJvbF9pbnB1dC5kaXNhYmxlZFx0XHQ9IGRpc2FibGVkO1xuXHRcdHRoaXMuc2V0TG9ja2VkKCk7XG5cdH1cblxuXHRzZXRSZWFkT25seShpc1JlYWRPbmx5OmJvb2xlYW4pe1xuXHRcdHRoaXMuaXNSZWFkT25seVx0XHRcdFx0XHQ9IGlzUmVhZE9ubHk7XG5cdFx0dGhpcy5pbnB1dC5yZWFkT25seVx0XHRcdFx0PSBpc1JlYWRPbmx5O1xuXHRcdHRoaXMuY29udHJvbF9pbnB1dC5yZWFkT25seVx0XHQ9IGlzUmVhZE9ubHk7XG5cdFx0dGhpcy5zZXRMb2NrZWQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wbGV0ZWx5IGRlc3Ryb3lzIHRoZSBjb250cm9sIGFuZFxuXHQgKiB1bmJpbmRzIGFsbCBldmVudCBsaXN0ZW5lcnMgc28gdGhhdCBpdCBjYW5cblx0ICogYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgcmV2ZXJ0U2V0dGluZ3MgPSBzZWxmLnJldmVydFNldHRpbmdzO1xuXG5cdFx0c2VsZi50cmlnZ2VyKCdkZXN0cm95Jyk7XG5cdFx0c2VsZi5vZmYoKTtcblx0XHRzZWxmLndyYXBwZXIucmVtb3ZlKCk7XG5cdFx0c2VsZi5kcm9wZG93bi5yZW1vdmUoKTtcblxuXHRcdHNlbGYuaW5wdXQuaW5uZXJIVE1MID0gcmV2ZXJ0U2V0dGluZ3MuaW5uZXJIVE1MO1xuXHRcdHNlbGYuaW5wdXQudGFiSW5kZXggPSByZXZlcnRTZXR0aW5ncy50YWJJbmRleDtcblxuXHRcdHJlbW92ZUNsYXNzZXMoc2VsZi5pbnB1dCwndG9tc2VsZWN0ZWQnLCd0cy1oaWRkZW4tYWNjZXNzaWJsZScpO1xuXG5cdFx0c2VsZi5fZGVzdHJveSgpO1xuXG5cdFx0ZGVsZXRlIHNlbGYuaW5wdXQudG9tc2VsZWN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgaGVscGVyIG1ldGhvZCBmb3IgcmVuZGVyaW5nIFwiaXRlbVwiIGFuZFxuXHQgKiBcIm9wdGlvblwiIHRlbXBsYXRlcywgZ2l2ZW4gdGhlIGRhdGEuXG5cdCAqXG5cdCAqL1xuXHRyZW5kZXIoIHRlbXBsYXRlTmFtZTpUb21UZW1wbGF0ZU5hbWVzLCBkYXRhPzphbnkgKTpudWxsfEhUTUxFbGVtZW50e1xuXHRcdHZhciBpZCwgaHRtbDtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRcdGlmKCB0eXBlb2YgdGhpcy5zZXR0aW5ncy5yZW5kZXJbdGVtcGxhdGVOYW1lXSAhPT0gJ2Z1bmN0aW9uJyApe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gcmVuZGVyIG1hcmt1cFxuXHRcdGh0bWwgPSBzZWxmLnNldHRpbmdzLnJlbmRlclt0ZW1wbGF0ZU5hbWVdLmNhbGwodGhpcywgZGF0YSwgZXNjYXBlX2h0bWwpO1xuXG5cdFx0aWYoICFodG1sICl7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRodG1sID0gZ2V0RG9tKCBodG1sICk7XG5cblx0XHQvLyBhZGQgbWFuZGF0b3J5IGF0dHJpYnV0ZXNcblx0XHRpZiAodGVtcGxhdGVOYW1lID09PSAnb3B0aW9uJyB8fCB0ZW1wbGF0ZU5hbWUgPT09ICdvcHRpb25fY3JlYXRlJykge1xuXG5cdFx0XHRpZiggZGF0YVtzZWxmLnNldHRpbmdzLmRpc2FibGVkRmllbGRdICl7XG5cdFx0XHRcdHNldEF0dHIoaHRtbCx7J2FyaWEtZGlzYWJsZWQnOid0cnVlJ30pO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHNldEF0dHIoaHRtbCx7J2RhdGEtc2VsZWN0YWJsZSc6ICcnfSk7XG5cdFx0XHR9XG5cblx0XHR9ZWxzZSBpZiAodGVtcGxhdGVOYW1lID09PSAnb3B0Z3JvdXAnKSB7XG5cdFx0XHRpZCA9IGRhdGEuZ3JvdXBbc2VsZi5zZXR0aW5ncy5vcHRncm91cFZhbHVlRmllbGRdO1xuXHRcdFx0c2V0QXR0cihodG1sLHsnZGF0YS1ncm91cCc6IGlkfSk7XG5cdFx0XHRpZihkYXRhLmdyb3VwW3NlbGYuc2V0dGluZ3MuZGlzYWJsZWRGaWVsZF0pIHtcblx0XHRcdFx0c2V0QXR0cihodG1sLHsnZGF0YS1kaXNhYmxlZCc6ICcnfSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRlbXBsYXRlTmFtZSA9PT0gJ29wdGlvbicgfHwgdGVtcGxhdGVOYW1lID09PSAnaXRlbScpIHtcblx0XHRcdGNvbnN0IHZhbHVlXHQ9IGdldF9oYXNoKGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG5cdFx0XHRzZXRBdHRyKGh0bWwseydkYXRhLXZhbHVlJzogdmFsdWUgfSk7XG5cblxuXHRcdFx0Ly8gbWFrZSBzdXJlIHdlIGhhdmUgc29tZSBjbGFzc2VzIGlmIGEgdGVtcGxhdGUgaXMgb3ZlcndyaXR0ZW5cblx0XHRcdGlmKCB0ZW1wbGF0ZU5hbWUgPT09ICdpdGVtJyApe1xuXHRcdFx0XHRhZGRDbGFzc2VzKGh0bWwsc2VsZi5zZXR0aW5ncy5pdGVtQ2xhc3MpO1xuXHRcdFx0XHRzZXRBdHRyKGh0bWwseydkYXRhLXRzLWl0ZW0nOicnfSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0YWRkQ2xhc3NlcyhodG1sLHNlbGYuc2V0dGluZ3Mub3B0aW9uQ2xhc3MpO1xuXHRcdFx0XHRzZXRBdHRyKGh0bWwse1xuXHRcdFx0XHRcdHJvbGU6J29wdGlvbicsXG5cdFx0XHRcdFx0aWQ6ZGF0YS4kaWRcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIGNhY2hlXG5cdFx0XHRcdGRhdGEuJGRpdiA9IGh0bWw7XG5cdFx0XHRcdHNlbGYub3B0aW9uc1t2YWx1ZV0gPSBkYXRhO1xuXHRcdFx0fVxuXG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaHRtbDtcblxuXHR9XG5cblxuXHQvKipcblx0ICogVHlwZSBndWFyZGVkIHJlbmRlcmluZ1xuXHQgKlxuXHQgKi9cblx0X3JlbmRlciggdGVtcGxhdGVOYW1lOlRvbVRlbXBsYXRlTmFtZXMsIGRhdGE/OmFueSApOkhUTUxFbGVtZW50e1xuXHRcdGNvbnN0IGh0bWwgPSB0aGlzLnJlbmRlcih0ZW1wbGF0ZU5hbWUsIGRhdGEpO1xuXG5cdFx0aWYoIGh0bWwgPT0gbnVsbCApe1xuXHRcdFx0dGhyb3cgJ0hUTUxFbGVtZW50IGV4cGVjdGVkJztcblx0XHR9XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIHJlbmRlciBjYWNoZSBmb3IgYSB0ZW1wbGF0ZS4gSWZcblx0ICogbm8gdGVtcGxhdGUgaXMgZ2l2ZW4sIGNsZWFycyBhbGwgcmVuZGVyXG5cdCAqIGNhY2hlcy5cblx0ICpcblx0ICovXG5cdGNsZWFyQ2FjaGUoKTp2b2lke1xuXG5cdFx0aXRlcmF0ZSh0aGlzLm9wdGlvbnMsIChvcHRpb246VG9tT3B0aW9uKT0+e1xuXHRcdFx0aWYoIG9wdGlvbi4kZGl2ICl7XG5cdFx0XHRcdG9wdGlvbi4kZGl2LnJlbW92ZSgpO1xuXHRcdFx0XHRkZWxldGUgb3B0aW9uLiRkaXY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSBpdGVtIGFuZCBvcHRpb24gY2FjaGVzXG5cdCAqXG5cdCAqL1xuXHR1bmNhY2hlVmFsdWUodmFsdWU6c3RyaW5nKXtcblxuXHRcdGNvbnN0IG9wdGlvbl9lbFx0XHRcdD0gdGhpcy5nZXRPcHRpb24odmFsdWUpO1xuXHRcdGlmKCBvcHRpb25fZWwgKSBvcHRpb25fZWwucmVtb3ZlKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIGRpc3BsYXkgdGhlXG5cdCAqIGNyZWF0ZSBpdGVtIHByb21wdCwgZ2l2ZW4gYSB1c2VyIGlucHV0LlxuXHQgKlxuXHQgKi9cblx0Y2FuQ3JlYXRlKCBpbnB1dDpzdHJpbmcgKTpib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncy5jcmVhdGUgJiYgKGlucHV0Lmxlbmd0aCA+IDApICYmICh0aGlzLnNldHRpbmdzLmNyZWF0ZUZpbHRlciBhcyBUb21DcmVhdGVGaWx0ZXIgKS5jYWxsKHRoaXMsIGlucHV0KTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFdyYXBzIHRoaXMuYG1ldGhvZGAgc28gdGhhdCBgbmV3X2ZuYCBjYW4gYmUgaW52b2tlZCAnYmVmb3JlJywgJ2FmdGVyJywgb3IgJ2luc3RlYWQnIG9mIHRoZSBvcmlnaW5hbCBtZXRob2Rcblx0ICpcblx0ICogdGhpcy5ob29rKCdpbnN0ZWFkJywnb25LZXlEb3duJyxmdW5jdGlvbiggYXJnMSwgYXJnMiAuLi4pe1xuXHQgKlxuXHQgKiB9KTtcblx0ICovXG5cdGhvb2soIHdoZW46c3RyaW5nLCBtZXRob2Q6c3RyaW5nLCBuZXdfZm46YW55ICl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBvcmlnX21ldGhvZCA9IHNlbGZbbWV0aG9kXTtcblxuXG5cdFx0c2VsZlttZXRob2RdID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciByZXN1bHQsIHJlc3VsdF9uZXc7XG5cblx0XHRcdGlmKCB3aGVuID09PSAnYWZ0ZXInICl7XG5cdFx0XHRcdHJlc3VsdCA9IG9yaWdfbWV0aG9kLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdF9uZXcgPSBuZXdfZm4uYXBwbHkoc2VsZiwgYXJndW1lbnRzICk7XG5cblx0XHRcdGlmKCB3aGVuID09PSAnaW5zdGVhZCcgKXtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdF9uZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCB3aGVuID09PSAnYmVmb3JlJyApe1xuXHRcdFx0XHRyZXN1bHQgPSBvcmlnX21ldGhvZC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0fVxuXG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcImNoYW5nZV9saXN0ZW5lclwiIChUb20gU2VsZWN0KVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgeyBhZGRFdmVudCB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QpIHtcblx0YWRkRXZlbnQodGhpcy5pbnB1dCwnY2hhbmdlJywoKT0+e1xuXHRcdHRoaXMuc3luYygpO1xuXHR9KTtcbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwiY2hlY2tib3hfb3B0aW9uc1wiIChUb20gU2VsZWN0KVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgeyBwcmV2ZW50RGVmYXVsdCwgaGFzaF9rZXkgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBnZXREb20gfSBmcm9tICcuLi8uLi92YW5pbGxhJztcbmltcG9ydCB7IENCT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0LCB1c2VyT3B0aW9uczpDQk9wdGlvbnMpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR2YXIgb3JpZ19vbk9wdGlvblNlbGVjdCA9IHNlbGYub25PcHRpb25TZWxlY3Q7XG5cblx0c2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRjb25zdCBjYk9wdGlvbnMgOiBDQk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHQvLyBzbyB0aGF0IHRoZSB1c2VyIG1heSBhZGQgZGlmZmVyZW50IG9uZXMgYXMgd2VsbFxuXHRcdGNsYXNzTmFtZSAgICAgICAgICAgICA6IFwidG9tc2VsZWN0LWNoZWNrYm94XCIsXG5cblx0XHQvLyB0aGUgZm9sbG93aW5nIGRlZmF1bHQgdG8gdGhlIGhpc3RvcmljIHBsdWdpbidzIHZhbHVlc1xuXHRcdGNoZWNrZWRDbGFzc05hbWVzICAgICA6IHVuZGVmaW5lZCxcblx0XHR1bmNoZWNrZWRDbGFzc05hbWVzICAgOiB1bmRlZmluZWQsXG5cdH0sIHVzZXJPcHRpb25zKTtcblxuXG5cdHZhciBVcGRhdGVDaGVja2VkID0gZnVuY3Rpb24oY2hlY2tib3g6SFRNTElucHV0RWxlbWVudCwgdG9DaGVjayA6IGJvb2xlYW4pIHtcblx0XHRpZiggdG9DaGVjayApe1xuXHRcdFx0Y2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG5cdFx0XHRpZiAoY2JPcHRpb25zLnVuY2hlY2tlZENsYXNzTmFtZXMpIHtcblx0XHRcdFx0Y2hlY2tib3guY2xhc3NMaXN0LnJlbW92ZSguLi5jYk9wdGlvbnMudW5jaGVja2VkQ2xhc3NOYW1lcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2JPcHRpb25zLmNoZWNrZWRDbGFzc05hbWVzKSB7XG5cdFx0XHRcdGNoZWNrYm94LmNsYXNzTGlzdC5hZGQoLi4uY2JPcHRpb25zLmNoZWNrZWRDbGFzc05hbWVzKTtcblx0XHRcdH1cblx0XHR9ZWxzZXtcblx0XHRcdGNoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcblx0XHRcdGlmIChjYk9wdGlvbnMuY2hlY2tlZENsYXNzTmFtZXMpIHtcblx0XHRcdFx0Y2hlY2tib3guY2xhc3NMaXN0LnJlbW92ZSguLi5jYk9wdGlvbnMuY2hlY2tlZENsYXNzTmFtZXMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNiT3B0aW9ucy51bmNoZWNrZWRDbGFzc05hbWVzKSB7XG5cdFx0XHRcdGNoZWNrYm94LmNsYXNzTGlzdC5hZGQoLi4uY2JPcHRpb25zLnVuY2hlY2tlZENsYXNzTmFtZXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIHVwZGF0ZSB0aGUgY2hlY2tib3ggZm9yIGFuIG9wdGlvblxuXHR2YXIgVXBkYXRlQ2hlY2tib3ggPSBmdW5jdGlvbihvcHRpb246SFRNTEVsZW1lbnQpe1xuXHRcdHNldFRpbWVvdXQoKCk9Pntcblx0XHRcdHZhciBjaGVja2JveCA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCdpbnB1dC4nICsgY2JPcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0XHRpZiggY2hlY2tib3ggaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICl7XG5cdFx0XHRcdFVwZGF0ZUNoZWNrZWQoY2hlY2tib3gsIG9wdGlvbi5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykpO1xuXHRcdFx0fVxuXHRcdH0sMSk7XG5cdH07XG5cblx0Ly8gYWRkIGNoZWNrYm94IHRvIG9wdGlvbiB0ZW1wbGF0ZVxuXHRzZWxmLmhvb2soJ2FmdGVyJywnc2V0dXBUZW1wbGF0ZXMnLCgpID0+IHtcblxuXHRcdHZhciBvcmlnX3JlbmRlcl9vcHRpb24gPSBzZWxmLnNldHRpbmdzLnJlbmRlci5vcHRpb247XG5cblx0XHRzZWxmLnNldHRpbmdzLnJlbmRlci5vcHRpb24gPSAoZGF0YSwgZXNjYXBlX2h0bWwpID0+IHtcblx0XHRcdHZhciByZW5kZXJlZCA9IGdldERvbShvcmlnX3JlbmRlcl9vcHRpb24uY2FsbChzZWxmLCBkYXRhLCBlc2NhcGVfaHRtbCkpO1xuXHRcdFx0dmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcblx0XHRcdGlmIChjYk9wdGlvbnMuY2xhc3NOYW1lKSB7XG5cdFx0XHRcdGNoZWNrYm94LmNsYXNzTGlzdC5hZGQoY2JPcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0cHJldmVudERlZmF1bHQoZXZ0KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRjaGVja2JveC50eXBlID0gJ2NoZWNrYm94Jztcblx0XHRcdGNvbnN0IGhhc2hlZCA9IGhhc2hfa2V5KGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG5cblx0XHRcdFVwZGF0ZUNoZWNrZWQoY2hlY2tib3gsICEhKGhhc2hlZCAmJiBzZWxmLml0ZW1zLmluZGV4T2YoaGFzaGVkKSA+IC0xKSApO1xuXG5cdFx0XHRyZW5kZXJlZC5wcmVwZW5kKGNoZWNrYm94KTtcblx0XHRcdHJldHVybiByZW5kZXJlZDtcblx0XHR9O1xuXHR9KTtcblxuXHQvLyB1bmNoZWNrIHdoZW4gaXRlbSByZW1vdmVkXG5cdHNlbGYub24oJ2l0ZW1fcmVtb3ZlJywodmFsdWU6c3RyaW5nKSA9PiB7XG5cdFx0dmFyIG9wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKHZhbHVlKTtcblxuXHRcdGlmKCBvcHRpb24gKXsgLy8gaWYgZHJvcGRvd24gaGFzbid0IGJlZW4gb3BlbmVkIHlldCwgdGhlIG9wdGlvbiB3b24ndCBleGlzdFxuXHRcdFx0b3B0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7IC8vIHNlbGVjdGVkIGNsYXNzIHdvbid0IGJlIHJlbW92ZWQgeWV0XG5cdFx0XHRVcGRhdGVDaGVja2JveChvcHRpb24pO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gY2hlY2sgd2hlbiBpdGVtIGFkZGVkXG5cdHNlbGYub24oJ2l0ZW1fYWRkJywodmFsdWU6c3RyaW5nKSA9PiB7XG5cdFx0dmFyIG9wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKHZhbHVlKTtcblxuXHRcdGlmKCBvcHRpb24gKXsgLy8gaWYgZHJvcGRvd24gaGFzbid0IGJlZW4gb3BlbmVkIHlldCwgdGhlIG9wdGlvbiB3b24ndCBleGlzdFxuXHRcdFx0VXBkYXRlQ2hlY2tib3gob3B0aW9uKTtcblx0XHR9XG5cdH0pO1xuXG5cblx0Ly8gcmVtb3ZlIGl0ZW1zIHdoZW4gc2VsZWN0ZWQgb3B0aW9uIGlzIGNsaWNrZWRcblx0c2VsZi5ob29rKCdpbnN0ZWFkJywnb25PcHRpb25TZWxlY3QnLCggZXZ0OktleWJvYXJkRXZlbnQsIG9wdGlvbjpIVE1MRWxlbWVudCApPT57XG5cblx0XHRpZiggb3B0aW9uLmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0ZWQnKSApe1xuXHRcdFx0b3B0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJylcblx0XHRcdHNlbGYucmVtb3ZlSXRlbShvcHRpb24uZGF0YXNldC52YWx1ZSk7XG5cdFx0XHRzZWxmLnJlZnJlc2hPcHRpb25zKCk7XG5cdFx0XHRwcmV2ZW50RGVmYXVsdChldnQsdHJ1ZSk7XG5cdFx0XHRyZXR1cm47XG4gICAgICAgIH1cblxuXHRcdG9yaWdfb25PcHRpb25TZWxlY3QuY2FsbChzZWxmLCBldnQsIG9wdGlvbik7XG5cblx0XHRVcGRhdGVDaGVja2JveChvcHRpb24pO1xuXHR9KTtcblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJkcm9wZG93bl9oZWFkZXJcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgZ2V0RG9tIH0gZnJvbSAnLi4vLi4vdmFuaWxsYSc7XG5pbXBvcnQgeyBDQk9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QsIHVzZXJPcHRpb25zOkNCT3B0aW9ucykge1xuXHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Y2xhc3NOYW1lOiAnY2xlYXItYnV0dG9uJyxcblx0XHR0aXRsZTogJ0NsZWFyIEFsbCcsXG5cdFx0aHRtbDogKGRhdGE6Q0JPcHRpb25zKSA9PiB7XG5cdFx0XHRyZXR1cm4gYDxkaXYgY2xhc3M9XCIke2RhdGEuY2xhc3NOYW1lfVwiIHRpdGxlPVwiJHtkYXRhLnRpdGxlfVwiPiYjMTA3OTk7PC9kaXY+YDtcblx0XHR9XG5cdH0sIHVzZXJPcHRpb25zKTtcblxuXHRzZWxmLm9uKCdpbml0aWFsaXplJywoKT0+e1xuXHRcdHZhciBidXR0b24gPSBnZXREb20ob3B0aW9ucy5odG1sKG9wdGlvbnMpKTtcblx0XHRidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLChldnQpPT57XG5cblx0XHRcdGlmKCBzZWxmLmlzTG9ja2VkICkgcmV0dXJuO1xuXG5cdFx0XHRzZWxmLmNsZWFyKCk7XG5cblx0XHRcdGlmKCBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnICYmIHNlbGYuc2V0dGluZ3MuYWxsb3dFbXB0eU9wdGlvbiApe1xuXHRcdFx0XHRzZWxmLmFkZEl0ZW0oJycpO1xuXHRcdFx0fVxuXG5cdFx0XHRldnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9KTtcblx0XHRzZWxmLmNvbnRyb2wuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwiZHJhZ19kcm9wXCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCB7IFRvbU9wdGlvbiwgVG9tSXRlbSB9IGZyb20gJy4uLy4uL3R5cGVzL2luZGV4JztcbmltcG9ydCB7IGVzY2FwZV9odG1sLCBwcmV2ZW50RGVmYXVsdCwgYWRkRXZlbnQgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBnZXREb20sIHNldEF0dHIgfSBmcm9tICcuLi8uLi92YW5pbGxhJztcblxuXG5jb25zdCBpbnNlcnRBZnRlciA9IChyZWZlcmVuY2VOb2RlOkVsZW1lbnQsIG5ld05vZGU6RWxlbWVudCkgPT4ge1xuXHRyZWZlcmVuY2VOb2RlLnBhcmVudE5vZGU/Lmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nKTtcbn1cblxuY29uc3QgaW5zZXJ0QmVmb3JlID0gKHJlZmVyZW5jZU5vZGU6RWxlbWVudCwgbmV3Tm9kZTpFbGVtZW50KSA9PiB7XG5cdHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZT8uaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5jb25zdCBpc0JlZm9yZSA9IChyZWZlcmVuY2VOb2RlOkVsZW1lbnR8dW5kZWZpbmVkfG51bGwsIG5ld05vZGU6RWxlbWVudHx1bmRlZmluZWR8bnVsbCkgPT57XG5cdFxuXHRkb3tcblx0XHRuZXdOb2RlID0gbmV3Tm9kZT8ucHJldmlvdXNFbGVtZW50U2libGluZztcblxuXHRcdGlmKCByZWZlcmVuY2VOb2RlID09IG5ld05vZGUgKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHR9d2hpbGUoIG5ld05vZGUgJiYgbmV3Tm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICk7XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdGlmIChzZWxmLnNldHRpbmdzLm1vZGUgIT09ICdtdWx0aScpIHJldHVybjtcblxuXHR2YXIgb3JpZ19sb2NrXHRcdD0gc2VsZi5sb2NrO1xuXHR2YXIgb3JpZ191bmxvY2tcdFx0PSBzZWxmLnVubG9jaztcblx0bGV0IHNvcnRhYmxlID0gdHJ1ZTtcblx0XHRsZXQgZHJhZ19pdGVtOlRvbUl0ZW18dW5kZWZpbmVkO1xuXG5cblx0LyoqXG5cdCAqIEFkZCBkcmFnZ2FibGUgYXR0cmlidXRlIHRvIGl0ZW1cblx0ICovXG5cdHNlbGYuaG9vaygnYWZ0ZXInLCdzZXR1cFRlbXBsYXRlcycsKCkgPT4ge1xuXG5cdFx0dmFyIG9yaWdfcmVuZGVyX2l0ZW0gPSBzZWxmLnNldHRpbmdzLnJlbmRlci5pdGVtO1xuXG5cdFx0c2VsZi5zZXR0aW5ncy5yZW5kZXIuaXRlbSA9IChkYXRhOlRvbU9wdGlvbiwgZXNjYXBlOnR5cGVvZiBlc2NhcGVfaHRtbCkgPT4ge1xuXHRcdFx0Y29uc3QgaXRlbSA9IGdldERvbShvcmlnX3JlbmRlcl9pdGVtLmNhbGwoc2VsZiwgZGF0YSwgZXNjYXBlKSkgYXMgVG9tSXRlbTtcblx0XHRcdHNldEF0dHIoaXRlbSx7J2RyYWdnYWJsZSc6J3RydWUnfSk7XG5cblxuXHRcdFx0Ly8gcHJldmVudCBkb2NfbW91c2Vkb3duIChzZWUgdG9tLXNlbGVjdC50cylcblx0XHRcdGNvbnN0IG1vdXNlZG93biA9IChldnQ6RXZlbnQpID0+IHtcblx0XHRcdFx0aWYoICFzb3J0YWJsZSApIHByZXZlbnREZWZhdWx0KGV2dCk7XG5cdFx0XHRcdGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZHJhZ1N0YXJ0ID0gKGV2dDpFdmVudCkgPT4ge1xuXHRcdFx0XHRkcmFnX2l0ZW0gPSBpdGVtO1xuXHRcdFx0XHRcblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0aXRlbS5jbGFzc0xpc3QuYWRkKCd0cy1kcmFnZ2luZycpO1xuXHRcdFx0XHR9LCAwKTtcblx0XHRcdFx0XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRyYWdPdmVyID0gKGV2dDpFdmVudCkgPT57XG5cdFx0XHRcdGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRpdGVtLmNsYXNzTGlzdC5hZGQoJ3RzLWRyYWctb3ZlcicpO1xuXHRcdFx0XHRtb3ZlaXRlbShpdGVtLGRyYWdfaXRlbSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRyYWdMZWF2ZSA9ICgpID0+IHtcblx0XHRcdFx0aXRlbS5jbGFzc0xpc3QucmVtb3ZlKCd0cy1kcmFnLW92ZXInKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbW92ZWl0ZW0gPSAodGFyZ2V0aXRlbTpUb21JdGVtLCBkcmFnaXRlbTpUb21JdGVtfHVuZGVmaW5lZCkgPT4ge1xuXHRcdFx0XHRpZiggZHJhZ2l0ZW0gPT09IHVuZGVmaW5lZCApIHJldHVybjtcblx0XHRcdFx0XG5cdFx0XHRcdGlmKCBpc0JlZm9yZShkcmFnaXRlbSxpdGVtKSApe1xuXHRcdFx0XHRcdGluc2VydEFmdGVyKHRhcmdldGl0ZW0sZHJhZ2l0ZW0pO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRpbnNlcnRCZWZvcmUodGFyZ2V0aXRlbSxkcmFnaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZHJhZ2VuZCA9ICgpID0+IHtcblx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRzLWRyYWctb3ZlcicpLmZvckVhY2goZWw9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKCd0cy1kcmFnLW92ZXInKSk7XG5cdFx0XHRcdGRyYWdfaXRlbT8uY2xhc3NMaXN0LnJlbW92ZSgndHMtZHJhZ2dpbmcnKTtcblx0XHRcdFx0ZHJhZ19pdGVtID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdHZhciB2YWx1ZXM6c3RyaW5nW10gPSBbXTtcblx0XHRcdFx0c2VsZi5jb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXZhbHVlXWApLmZvckVhY2goKGVsOkVsZW1lbnQpPT4ge1xuXHRcdFx0XHRcdGlmKCAoPEhUTUxPcHRpb25FbGVtZW50PmVsKS5kYXRhc2V0LnZhbHVlICl7XG5cdFx0XHRcdFx0XHRsZXQgdmFsdWUgPSAoPEhUTUxPcHRpb25FbGVtZW50PmVsKS5kYXRhc2V0LnZhbHVlO1xuXHRcdFx0XHRcdFx0aWYoIHZhbHVlICl7XG5cdFx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHNlbGYuc2V0VmFsdWUodmFsdWVzKTtcblx0XHRcdH1cdFxuXG5cblx0XHRcdGFkZEV2ZW50KGl0ZW0sJ21vdXNlZG93bicsIG1vdXNlZG93bik7XG5cdFx0XHRhZGRFdmVudChpdGVtLCdkcmFnc3RhcnQnLCBkcmFnU3RhcnQpO1xuXHRcdFx0YWRkRXZlbnQoaXRlbSwnZHJhZ2VudGVyJywgZHJhZ092ZXIpXG5cdFx0XHRhZGRFdmVudChpdGVtLCdkcmFnb3ZlcicsIGRyYWdPdmVyKTtcblx0XHRcdGFkZEV2ZW50KGl0ZW0sJ2RyYWdsZWF2ZScsIGRyYWdMZWF2ZSk7XG5cdFx0XHRhZGRFdmVudChpdGVtLCdkcmFnZW5kJywgZHJhZ2VuZCk7XG5cdFx0XHRcdFxuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fVx0XG5cdH0pO1xuXG5cblxuXHRzZWxmLmhvb2soJ2luc3RlYWQnLCdsb2NrJywoKT0+e1xuXHRcdHNvcnRhYmxlID0gZmFsc2U7XG5cdFx0cmV0dXJuIG9yaWdfbG9jay5jYWxsKHNlbGYpO1xuXHR9KTtcblxuXHRzZWxmLmhvb2soJ2luc3RlYWQnLCd1bmxvY2snLCgpPT57XG5cdFx0c29ydGFibGUgPSB0cnVlO1xuXHRcdHJldHVybiBvcmlnX3VubG9jay5jYWxsKHNlbGYpO1xuXHR9KTtcblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJkcm9wZG93bl9oZWFkZXJcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgZ2V0RG9tIH0gZnJvbSAnLi4vLi4vdmFuaWxsYSc7XG5pbXBvcnQgeyBwcmV2ZW50RGVmYXVsdCB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IERIT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCwgdXNlck9wdGlvbnM6REhPcHRpb25zKSB7XG5cdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHR0aXRsZSAgICAgICAgIDogJ1VudGl0bGVkJyxcblx0XHRoZWFkZXJDbGFzcyAgIDogJ2Ryb3Bkb3duLWhlYWRlcicsXG5cdFx0dGl0bGVSb3dDbGFzcyA6ICdkcm9wZG93bi1oZWFkZXItdGl0bGUnLFxuXHRcdGxhYmVsQ2xhc3MgICAgOiAnZHJvcGRvd24taGVhZGVyLWxhYmVsJyxcblx0XHRjbG9zZUNsYXNzICAgIDogJ2Ryb3Bkb3duLWhlYWRlci1jbG9zZScsXG5cblx0XHRodG1sOiAoZGF0YTpESE9wdGlvbnMpID0+IHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdCc8ZGl2IGNsYXNzPVwiJyArIGRhdGEuaGVhZGVyQ2xhc3MgKyAnXCI+JyArXG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCInICsgZGF0YS50aXRsZVJvd0NsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiJyArIGRhdGEubGFiZWxDbGFzcyArICdcIj4nICsgZGF0YS50aXRsZSArICc8L3NwYW4+JyArXG5cdFx0XHRcdFx0XHQnPGEgY2xhc3M9XCInICsgZGF0YS5jbG9zZUNsYXNzICsgJ1wiPiZ0aW1lczs8L2E+JyArXG5cdFx0XHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0XHQnPC9kaXY+J1xuXHRcdFx0KTtcblx0XHR9XG5cdH0sIHVzZXJPcHRpb25zKTtcblxuXHRzZWxmLm9uKCdpbml0aWFsaXplJywoKT0+e1xuXHRcdHZhciBoZWFkZXIgPSBnZXREb20ob3B0aW9ucy5odG1sKG9wdGlvbnMpKTtcblxuXHRcdHZhciBjbG9zZV9saW5rID0gaGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJy4nK29wdGlvbnMuY2xvc2VDbGFzcyk7XG5cdFx0aWYoIGNsb3NlX2xpbmsgKXtcblx0XHRcdGNsb3NlX2xpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLChldnQpPT57XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCx0cnVlKTtcblx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0c2VsZi5kcm9wZG93bi5pbnNlcnRCZWZvcmUoaGVhZGVyLCBzZWxmLmRyb3Bkb3duLmZpcnN0Q2hpbGQpO1xuXHR9KTtcblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJkcm9wZG93bl9pbnB1dFwiIChUb20gU2VsZWN0KVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgeyBub2RlSW5kZXgsIHJlbW92ZUNsYXNzZXMgfSBmcm9tICcuLi8uLi92YW5pbGxhJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0LyoqXG5cdCAqIE1vdmVzIHRoZSBjYXJldCB0byB0aGUgc3BlY2lmaWVkIGluZGV4LlxuXHQgKlxuXHQgKiBUaGUgaW5wdXQgbXVzdCBiZSBtb3ZlZCBieSBsZWF2aW5nIGl0IGluIHBsYWNlIGFuZCBtb3ZpbmcgdGhlXG5cdCAqIHNpYmxpbmdzLCBkdWUgdG8gdGhlIGZhY3QgdGhhdCBmb2N1cyBjYW5ub3QgYmUgcmVzdG9yZWQgb25jZSBsb3N0XG5cdCAqIG9uIG1vYmlsZSB3ZWJraXQgZGV2aWNlc1xuXHQgKlxuXHQgKi9cblx0c2VsZi5ob29rKCdpbnN0ZWFkJywnc2V0Q2FyZXQnLChuZXdfcG9zOm51bWJlcikgPT4ge1xuXG5cdFx0aWYoIHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScgfHwgIXNlbGYuY29udHJvbC5jb250YWlucyhzZWxmLmNvbnRyb2xfaW5wdXQpICkge1xuXHRcdFx0bmV3X3BvcyA9IHNlbGYuaXRlbXMubGVuZ3RoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdfcG9zID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VsZi5pdGVtcy5sZW5ndGgsIG5ld19wb3MpKTtcblxuXHRcdFx0aWYoIG5ld19wb3MgIT0gc2VsZi5jYXJldFBvcyAmJiAhc2VsZi5pc1BlbmRpbmcgKXtcblxuXHRcdFx0XHRzZWxmLmNvbnRyb2xDaGlsZHJlbigpLmZvckVhY2goKGNoaWxkLGopID0+IHtcblx0XHRcdFx0XHRpZiggaiA8IG5ld19wb3MgKXtcblx0XHRcdFx0XHRcdHNlbGYuY29udHJvbF9pbnB1dC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2JlZm9yZWJlZ2luJywgY2hpbGQgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5jb250cm9sLmFwcGVuZENoaWxkKCBjaGlsZCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VsZi5jYXJldFBvcyA9IG5ld19wb3M7XG5cdH0pO1xuXG5cdHNlbGYuaG9vaygnaW5zdGVhZCcsJ21vdmVDYXJldCcsKGRpcmVjdGlvbjpudW1iZXIpID0+IHtcblxuXHRcdGlmKCAhc2VsZi5pc0ZvY3VzZWQgKSByZXR1cm47XG5cblx0XHQvLyBtb3ZlIGNhcmV0IGJlZm9yZSBvciBhZnRlciBzZWxlY3RlZCBpdGVtc1xuXHRcdGNvbnN0IGxhc3RfYWN0aXZlXHRcdD0gc2VsZi5nZXRMYXN0QWN0aXZlKGRpcmVjdGlvbik7XG5cdFx0aWYoIGxhc3RfYWN0aXZlICl7XG5cdFx0XHRjb25zdCBpZHggPSBub2RlSW5kZXgobGFzdF9hY3RpdmUpO1xuXHRcdFx0c2VsZi5zZXRDYXJldChkaXJlY3Rpb24gPiAwID8gaWR4ICsgMTogaWR4KTtcblx0XHRcdHNlbGYuc2V0QWN0aXZlSXRlbSgpO1xuXHRcdFx0cmVtb3ZlQ2xhc3NlcyhsYXN0X2FjdGl2ZSBhcyBIVE1MRWxlbWVudCwnbGFzdC1hY3RpdmUnKTtcblxuXHRcdC8vIG1vdmUgY2FyZXQgbGVmdCBvciByaWdodCBvZiBjdXJyZW50IHBvc2l0aW9uXG5cdFx0fWVsc2V7XG5cdFx0XHRzZWxmLnNldENhcmV0KHNlbGYuY2FyZXRQb3MgKyBkaXJlY3Rpb24pO1xuXG5cdFx0fVxuXG5cdH0pO1xuXG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcImRyb3Bkb3duX2lucHV0XCIgKFRvbSBTZWxlY3QpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0RG9tLCBhZGRDbGFzc2VzIH0gZnJvbSAnLi4vLi4vdmFuaWxsYSc7XG5pbXBvcnQgeyBhZGRFdmVudCwgcHJldmVudERlZmF1bHQgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QpIHtcblx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0c2VsZi5zZXR0aW5ncy5zaG91bGRPcGVuID0gdHJ1ZTsgLy8gbWFrZSBzdXJlIHRoZSBpbnB1dCBpcyBzaG93biBldmVuIGlmIHRoZXJlIGFyZSBubyBvcHRpb25zIHRvIGRpc3BsYXkgaW4gdGhlIGRyb3Bkb3duXG5cblx0c2VsZi5ob29rKCdiZWZvcmUnLCdzZXR1cCcsKCk9Pntcblx0XHRzZWxmLmZvY3VzX25vZGVcdFx0PSBzZWxmLmNvbnRyb2w7XG5cblx0XHRhZGRDbGFzc2VzKCBzZWxmLmNvbnRyb2xfaW5wdXQsICdkcm9wZG93bi1pbnB1dCcpO1xuXG5cdCBcdGNvbnN0IGRpdiA9IGdldERvbSgnPGRpdiBjbGFzcz1cImRyb3Bkb3duLWlucHV0LXdyYXBcIj4nKTtcblx0XHRkaXYuYXBwZW5kKHNlbGYuY29udHJvbF9pbnB1dCk7XG5cdFx0c2VsZi5kcm9wZG93bi5pbnNlcnRCZWZvcmUoZGl2LCBzZWxmLmRyb3Bkb3duLmZpcnN0Q2hpbGQpO1xuXG5cdFx0Ly8gc2V0IGEgcGxhY2Vob2xkZXIgaW4gdGhlIHNlbGVjdCBjb250cm9sXG5cdFx0Y29uc3QgcGxhY2Vob2xkZXIgPSBnZXREb20oJzxpbnB1dCBjbGFzcz1cIml0ZW1zLXBsYWNlaG9sZGVyXCIgdGFiaW5kZXg9XCItMVwiIC8+JykgYXMgSFRNTElucHV0RWxlbWVudDtcblx0XHRwbGFjZWhvbGRlci5wbGFjZWhvbGRlciA9IHNlbGYuc2V0dGluZ3MucGxhY2Vob2xkZXIgfHwnJztcblx0XHRzZWxmLmNvbnRyb2wuYXBwZW5kKHBsYWNlaG9sZGVyKTtcblxuXHR9KTtcblxuXG5cdHNlbGYub24oJ2luaXRpYWxpemUnLCgpPT57XG5cblx0XHQvLyBzZXQgdGFiSW5kZXggb24gY29udHJvbCB0byAtMSwgb3RoZXJ3aXNlIFtzaGlmdCt0YWJdIHdpbGwgcHV0IGZvY3VzIHJpZ2h0IGJhY2sgb24gY29udHJvbF9pbnB1dFxuXHRcdHNlbGYuY29udHJvbF9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywoZXZ0OktleWJvYXJkRXZlbnQpID0+e1xuXHRcdC8vYWRkRXZlbnQoc2VsZi5jb250cm9sX2lucHV0LCdrZXlkb3duJyBhcyBjb25zdCwoZXZ0OktleWJvYXJkRXZlbnQpID0+e1xuXHRcdFx0c3dpdGNoKCBldnQua2V5Q29kZSApe1xuXHRcdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfRVNDOlxuXHRcdFx0XHRcdGlmIChzZWxmLmlzT3Blbikge1xuXHRcdFx0XHRcdFx0cHJldmVudERlZmF1bHQoZXZ0LHRydWUpO1xuXHRcdFx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxmLmNsZWFyQWN0aXZlSXRlbXMoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRjYXNlIGNvbnN0YW50cy5LRVlfVEFCOlxuXHRcdFx0XHRcdHNlbGYuZm9jdXNfbm9kZS50YWJJbmRleCA9IC0xO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiBzZWxmLm9uS2V5RG93bi5jYWxsKHNlbGYsZXZ0KTtcblx0XHR9KTtcblxuXHRcdHNlbGYub24oJ2JsdXInLCgpPT57XG5cdFx0XHRzZWxmLmZvY3VzX25vZGUudGFiSW5kZXggPSBzZWxmLmlzRGlzYWJsZWQgPyAtMSA6IHNlbGYudGFiSW5kZXg7XG5cdFx0fSk7XG5cblxuXHRcdC8vIGdpdmUgdGhlIGNvbnRyb2xfaW5wdXQgZm9jdXMgd2hlbiB0aGUgZHJvcGRvd24gaXMgb3BlblxuXHRcdHNlbGYub24oJ2Ryb3Bkb3duX29wZW4nLCgpID0+e1xuXHRcdFx0c2VsZi5jb250cm9sX2lucHV0LmZvY3VzKCk7XG5cdFx0fSk7XG5cblx0XHQvLyBwcmV2ZW50IG9uQmx1ciBmcm9tIGNsb3Npbmcgd2hlbiBmb2N1cyBpcyBvbiB0aGUgY29udHJvbF9pbnB1dFxuXHRcdGNvbnN0IG9yaWdfb25CbHVyID0gc2VsZi5vbkJsdXI7XG5cdFx0c2VsZi5ob29rKCdpbnN0ZWFkJywnb25CbHVyJywoZXZ0PzpGb2N1c0V2ZW50KT0+e1xuXHRcdFx0aWYoIGV2dCAmJiBldnQucmVsYXRlZFRhcmdldCA9PSBzZWxmLmNvbnRyb2xfaW5wdXQgKSByZXR1cm47XG5cdFx0XHRyZXR1cm4gb3JpZ19vbkJsdXIuY2FsbChzZWxmKTtcblx0XHR9KTtcblxuXHRcdGFkZEV2ZW50KHNlbGYuY29udHJvbF9pbnB1dCwnYmx1cicsICgpID0+IHNlbGYub25CbHVyKCkgKTtcblxuXHRcdC8vIHJldHVybiBmb2N1cyB0byBjb250cm9sIHRvIGFsbG93IGZ1cnRoZXIga2V5Ym9hcmQgaW5wdXRcblx0XHRzZWxmLmhvb2soJ2JlZm9yZScsJ2Nsb3NlJywoKSA9PntcblxuXHRcdFx0aWYoICFzZWxmLmlzT3BlbiApIHJldHVybjtcblx0XHRcdHNlbGYuZm9jdXNfbm9kZS5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pO1xuXHRcdH0pO1xuXG5cdH0pO1xuXG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcImlucHV0X2F1dG9ncm93XCIgKFRvbSBTZWxlY3QpXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgYWRkRXZlbnQgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0KSB7XG5cdHZhciBzZWxmXHRcdFx0XHRcdD0gdGhpcztcblxuXHRzZWxmLm9uKCdpbml0aWFsaXplJywoKT0+e1xuXG5cblx0XHR2YXIgdGVzdF9pbnB1dFx0XHRcdFx0PSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdFx0dmFyIGNvbnRyb2xcdFx0XHRcdFx0PSBzZWxmLmNvbnRyb2xfaW5wdXQ7XG5cdFx0dGVzdF9pbnB1dC5zdHlsZS5jc3NUZXh0XHQ9ICdwb3NpdGlvbjphYnNvbHV0ZTsgdG9wOi05OTk5OXB4OyBsZWZ0Oi05OTk5OXB4OyB3aWR0aDphdXRvOyBwYWRkaW5nOjA7IHdoaXRlLXNwYWNlOnByZTsgJztcblxuXHRcdHNlbGYud3JhcHBlci5hcHBlbmRDaGlsZCh0ZXN0X2lucHV0KTtcblxuXG5cdFx0dmFyIHRyYW5zZmVyX3N0eWxlc1x0XHRcdD0gWyAnbGV0dGVyU3BhY2luZycsICdmb250U2l6ZScsICdmb250RmFtaWx5JywgJ2ZvbnRXZWlnaHQnLCAndGV4dFRyYW5zZm9ybScgXTtcblxuXHRcdGZvciggY29uc3Qgc3R5bGVfbmFtZSBvZiB0cmFuc2Zlcl9zdHlsZXMgKXtcblx0XHRcdC8vIEB0cy1pZ25vcmUgVFM3MDE1IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81MDUwNjE1NC82OTc1NzZcblx0XHRcdHRlc3RfaW5wdXQuc3R5bGVbc3R5bGVfbmFtZV0gPSBjb250cm9sLnN0eWxlW3N0eWxlX25hbWVdO1xuXHRcdH1cblxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBjb250cm9sIHdpZHRoXG5cdFx0ICpcblx0XHQgKi9cblx0XHR2YXIgcmVzaXplID0gKCk9Pntcblx0XHRcdHRlc3RfaW5wdXQudGV4dENvbnRlbnRcdD0gY29udHJvbC52YWx1ZTtcblx0XHRcdGNvbnRyb2wuc3R5bGUud2lkdGhcdFx0PSB0ZXN0X2lucHV0LmNsaWVudFdpZHRoKydweCc7XG5cdFx0fTtcblxuXHRcdHJlc2l6ZSgpO1xuXHRcdHNlbGYub24oJ3VwZGF0ZSBpdGVtX2FkZCBpdGVtX3JlbW92ZScscmVzaXplKTtcblx0XHRhZGRFdmVudChjb250cm9sLCdpbnB1dCcsIHJlc2l6ZSApO1xuXHRcdGFkZEV2ZW50KGNvbnRyb2wsJ2tleXVwJywgcmVzaXplICk7XG5cdFx0YWRkRXZlbnQoY29udHJvbCwnYmx1cicsIHJlc2l6ZSApO1xuXHRcdGFkZEV2ZW50KGNvbnRyb2wsJ3VwZGF0ZScsIHJlc2l6ZSApO1xuXHR9KTtcblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJpbnB1dF9hdXRvZ3Jvd1wiIChUb20gU2VsZWN0KVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odGhpczpUb21TZWxlY3QpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR2YXIgb3JpZ19kZWxldGVTZWxlY3Rpb24gPSBzZWxmLmRlbGV0ZVNlbGVjdGlvbjtcblxuXHR0aGlzLmhvb2soJ2luc3RlYWQnLCdkZWxldGVTZWxlY3Rpb24nLChldnQ6S2V5Ym9hcmRFdmVudCkgPT4ge1xuXG5cdFx0aWYoIHNlbGYuYWN0aXZlSXRlbXMubGVuZ3RoICl7XG5cdFx0XHRyZXR1cm4gb3JpZ19kZWxldGVTZWxlY3Rpb24uY2FsbChzZWxmLCBldnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSk7XG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwibm9fYWN0aXZlX2l0ZW1zXCIgKFRvbSBTZWxlY3QpXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCkge1xuXHR0aGlzLmhvb2soJ2luc3RlYWQnLCdzZXRBY3RpdmVJdGVtJywoKSA9PiB7fSk7XG5cdHRoaXMuaG9vaygnaW5zdGVhZCcsJ3NlbGVjdEFsbCcsKCkgPT4ge30pO1xufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJvcHRncm91cF9jb2x1bW5zXCIgKFRvbSBTZWxlY3QuanMpXG4gKiBDb3B5cmlnaHQgKGMpIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgcGFyZW50TWF0Y2gsIG5vZGVJbmRleCB9IGZyb20gJy4uLy4uL3ZhbmlsbGEnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0dmFyIG9yaWdfa2V5ZG93biA9IHNlbGYub25LZXlEb3duO1xuXG5cdHNlbGYuaG9vaygnaW5zdGVhZCcsJ29uS2V5RG93bicsKGV2dDpLZXlib2FyZEV2ZW50KT0+e1xuXHRcdHZhciBpbmRleCwgb3B0aW9uLCBvcHRpb25zLCBvcHRncm91cDtcblxuXHRcdGlmKCAhc2VsZi5pc09wZW4gfHwgIShldnQua2V5Q29kZSA9PT0gY29uc3RhbnRzLktFWV9MRUZUIHx8IGV2dC5rZXlDb2RlID09PSBjb25zdGFudHMuS0VZX1JJR0hUKSkge1xuXHRcdFx0cmV0dXJuIG9yaWdfa2V5ZG93bi5jYWxsKHNlbGYsZXZ0KTtcblx0XHR9XG5cblx0XHRzZWxmLmlnbm9yZUhvdmVyXHQ9IHRydWU7XG5cdFx0b3B0Z3JvdXBcdFx0XHQ9IHBhcmVudE1hdGNoKHNlbGYuYWN0aXZlT3B0aW9uLCdbZGF0YS1ncm91cF0nKTtcblx0XHRpbmRleFx0XHRcdFx0PSBub2RlSW5kZXgoc2VsZi5hY3RpdmVPcHRpb24sJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG5cblx0XHRpZiggIW9wdGdyb3VwICl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoIGV2dC5rZXlDb2RlID09PSBjb25zdGFudHMuS0VZX0xFRlQgKXtcblx0XHRcdG9wdGdyb3VwID0gb3B0Z3JvdXAucHJldmlvdXNTaWJsaW5nO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvcHRncm91cCA9IG9wdGdyb3VwLm5leHRTaWJsaW5nO1xuXHRcdH1cblxuXHRcdGlmKCAhb3B0Z3JvdXAgKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRvcHRpb25zXHRcdFx0XHQ9ICg8SFRNTE9wdEdyb3VwRWxlbWVudD5vcHRncm91cCkucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2VsZWN0YWJsZV0nKTtcblx0XHRvcHRpb25cdFx0XHRcdD0gb3B0aW9uc1sgTWF0aC5taW4ob3B0aW9ucy5sZW5ndGggLSAxLCBpbmRleCkgXSBhcyBIVE1MRWxlbWVudDtcblxuXHRcdGlmKCBvcHRpb24gKXtcblx0XHRcdHNlbGYuc2V0QWN0aXZlT3B0aW9uKG9wdGlvbik7XG5cdFx0fVxuXG5cdH0pO1xuXG59O1xuIiwgIi8qKlxuICogUGx1Z2luOiBcInJlbW92ZV9idXR0b25cIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4uLy4uL3RvbS1zZWxlY3QnO1xuaW1wb3J0IHsgZ2V0RG9tIH0gZnJvbSAnLi4vLi4vdmFuaWxsYSc7XG5pbXBvcnQgeyBlc2NhcGVfaHRtbCwgcHJldmVudERlZmF1bHQsIGFkZEV2ZW50IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgVG9tT3B0aW9uLCBUb21JdGVtIH0gZnJvbSAnLi4vLi4vdHlwZXMvaW5kZXgnO1xuaW1wb3J0IHsgUkJPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0LCB1c2VyT3B0aW9uczpSQk9wdGlvbnMpIHtcblxuXHRjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRsYWJlbCAgICAgOiAnJnRpbWVzOycsXG5cdFx0XHR0aXRsZSAgICAgOiAnUmVtb3ZlJyxcblx0XHRcdGNsYXNzTmFtZSA6ICdyZW1vdmUnLFxuXHRcdFx0YXBwZW5kICAgIDogdHJ1ZVxuXHRcdH0sIHVzZXJPcHRpb25zKTtcblxuXG5cdC8vb3B0aW9ucy5jbGFzc05hbWUgPSAncmVtb3ZlLXNpbmdsZSc7XG5cdHZhciBzZWxmXHRcdFx0PSB0aGlzO1xuXG5cdC8vIG92ZXJyaWRlIHRoZSByZW5kZXIgbWV0aG9kIHRvIGFkZCByZW1vdmUgYnV0dG9uIHRvIGVhY2ggaXRlbVxuXHRpZiggIW9wdGlvbnMuYXBwZW5kICl7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGh0bWwgPSAnPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGNsYXNzPVwiJyArIG9wdGlvbnMuY2xhc3NOYW1lICsgJ1wiIHRhYmluZGV4PVwiLTFcIiB0aXRsZT1cIicgKyBlc2NhcGVfaHRtbChvcHRpb25zLnRpdGxlKSArICdcIj4nICsgb3B0aW9ucy5sYWJlbCArICc8L2E+JztcblxuXHRzZWxmLmhvb2soJ2FmdGVyJywnc2V0dXBUZW1wbGF0ZXMnLCgpID0+IHtcblxuXHRcdHZhciBvcmlnX3JlbmRlcl9pdGVtID0gc2VsZi5zZXR0aW5ncy5yZW5kZXIuaXRlbTtcblxuXHRcdHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW0gPSAoZGF0YTpUb21PcHRpb24sIGVzY2FwZTp0eXBlb2YgZXNjYXBlX2h0bWwpID0+IHtcblxuXHRcdFx0dmFyIGl0ZW0gPSBnZXREb20ob3JpZ19yZW5kZXJfaXRlbS5jYWxsKHNlbGYsIGRhdGEsIGVzY2FwZSkpIGFzIFRvbUl0ZW07XG5cblx0XHRcdHZhciBjbG9zZV9idXR0b24gPSBnZXREb20oaHRtbCk7XG5cdFx0XHRpdGVtLmFwcGVuZENoaWxkKGNsb3NlX2J1dHRvbik7XG5cblx0XHRcdGFkZEV2ZW50KGNsb3NlX2J1dHRvbiwnbW91c2Vkb3duJywoZXZ0KSA9PiB7XG5cdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2dCx0cnVlKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRhZGRFdmVudChjbG9zZV9idXR0b24sJ2NsaWNrJywoZXZ0KSA9PiB7XG5cblx0XHRcdFx0aWYoIHNlbGYuaXNMb2NrZWQgKSByZXR1cm47XG5cblx0XHRcdFx0Ly8gcHJvcGFnYXRpbmcgd2lsbCB0cmlnZ2VyIHRoZSBkcm9wZG93biB0byBzaG93IGZvciBzaW5nbGUgbW9kZVxuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChldnQsdHJ1ZSk7XG5cblx0XHRcdFx0aWYoIHNlbGYuaXNMb2NrZWQgKSByZXR1cm47XG5cdFx0XHRcdGlmKCAhc2VsZi5zaG91bGREZWxldGUoW2l0ZW1dLGV2dCBhcyBNb3VzZUV2ZW50KSApIHJldHVybjtcblxuXHRcdFx0XHRzZWxmLnJlbW92ZUl0ZW0oaXRlbSk7XG5cdFx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXHRcdFx0XHRzZWxmLmlucHV0U3RhdGUoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9O1xuXG5cdH0pO1xuXG5cbn07XG4iLCAiLyoqXG4gKiBQbHVnaW46IFwicmVzdG9yZV9vbl9iYWNrc3BhY2VcIiAoVG9tIFNlbGVjdClcbiAqIENvcHlyaWdodCAoYykgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IFRvbVNlbGVjdCBmcm9tICcuLi8uLi90b20tc2VsZWN0JztcbmltcG9ydCB7IFRvbU9wdGlvbiB9IGZyb20gJy4uLy4uL3R5cGVzL2luZGV4JztcblxudHlwZSBUUGx1Z2luT3B0aW9ucyA9IHtcblx0dGV4dD86KG9wdGlvbjpUb21PcHRpb24pPT5zdHJpbmcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0aGlzOlRvbVNlbGVjdCwgdXNlck9wdGlvbnM6VFBsdWdpbk9wdGlvbnMpIHtcblx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0Y29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdHRleHQ6IChvcHRpb246VG9tT3B0aW9uKSA9PiB7XG5cdFx0XHRyZXR1cm4gb3B0aW9uW3NlbGYuc2V0dGluZ3MubGFiZWxGaWVsZF07XG5cdFx0fVxuXHR9LHVzZXJPcHRpb25zKTtcblxuXHRzZWxmLm9uKCdpdGVtX3JlbW92ZScsZnVuY3Rpb24odmFsdWU6c3RyaW5nKXtcblx0XHRpZiggIXNlbGYuaXNGb2N1c2VkICl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoIHNlbGYuY29udHJvbF9pbnB1dC52YWx1ZS50cmltKCkgPT09ICcnICl7XG5cdFx0XHR2YXIgb3B0aW9uID0gc2VsZi5vcHRpb25zW3ZhbHVlXTtcblx0XHRcdGlmKCBvcHRpb24gKXtcblx0XHRcdFx0c2VsZi5zZXRUZXh0Ym94VmFsdWUob3B0aW9ucy50ZXh0LmNhbGwoc2VsZiwgb3B0aW9uKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxufTtcbiIsICIvKipcbiAqIFBsdWdpbjogXCJyZXN0b3JlX29uX2JhY2tzcGFjZVwiIChUb20gU2VsZWN0KVxuICogQ29weXJpZ2h0IChjKSBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnLi4vLi4vdG9tLXNlbGVjdCc7XG5pbXBvcnQgeyBUb21PcHRpb24gfSBmcm9tICcuLi8uLi90eXBlcy9pbmRleCc7XG5pbXBvcnQgeyBhZGRDbGFzc2VzIH0gZnJvbSAnLi4vLi4vdmFuaWxsYSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRoaXM6VG9tU2VsZWN0KSB7XG5cdGNvbnN0IHNlbGZcdFx0XHRcdFx0XHRcdD0gdGhpcztcblx0Y29uc3Qgb3JpZ19jYW5Mb2FkXHRcdFx0XHRcdD0gc2VsZi5jYW5Mb2FkO1xuXHRjb25zdCBvcmlnX2NsZWFyQWN0aXZlT3B0aW9uXHRcdD0gc2VsZi5jbGVhckFjdGl2ZU9wdGlvbjtcblx0Y29uc3Qgb3JpZ19sb2FkQ2FsbGJhY2tcdFx0XHRcdD0gc2VsZi5sb2FkQ2FsbGJhY2s7XG5cblx0dmFyIHBhZ2luYXRpb246e1trZXk6c3RyaW5nXTphbnl9XHQ9IHt9O1xuXHR2YXIgZHJvcGRvd25fY29udGVudDpIVE1MRWxlbWVudDtcblx0dmFyIGxvYWRpbmdfbW9yZVx0XHRcdFx0XHQ9IGZhbHNlO1xuXHR2YXIgbG9hZF9tb3JlX29wdDpIVE1MRWxlbWVudDtcblx0dmFyIGRlZmF1bHRfdmFsdWVzOiBzdHJpbmdbXVx0XHQ9IFtdO1xuXG5cdGlmKCAhc2VsZi5zZXR0aW5ncy5zaG91bGRMb2FkTW9yZSApe1xuXG5cdFx0Ly8gcmV0dXJuIHRydWUgaWYgYWRkaXRpb25hbCByZXN1bHRzIHNob3VsZCBiZSBsb2FkZWRcblx0XHRzZWxmLnNldHRpbmdzLnNob3VsZExvYWRNb3JlID0gKCk6Ym9vbGVhbj0+e1xuXG5cdFx0XHRjb25zdCBzY3JvbGxfcGVyY2VudCA9IGRyb3Bkb3duX2NvbnRlbnQuY2xpZW50SGVpZ2h0IC8gKGRyb3Bkb3duX2NvbnRlbnQuc2Nyb2xsSGVpZ2h0IC0gZHJvcGRvd25fY29udGVudC5zY3JvbGxUb3ApO1xuXHRcdFx0aWYoIHNjcm9sbF9wZXJjZW50ID4gMC45ICl7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggc2VsZi5hY3RpdmVPcHRpb24gKXtcblx0XHRcdFx0dmFyIHNlbGVjdGFibGVcdD0gc2VsZi5zZWxlY3RhYmxlKCk7XG5cdFx0XHRcdHZhciBpbmRleFx0XHQ9IEFycmF5LmZyb20oc2VsZWN0YWJsZSkuaW5kZXhPZihzZWxmLmFjdGl2ZU9wdGlvbik7XG5cdFx0XHRcdGlmKCBpbmRleCA+PSAoc2VsZWN0YWJsZS5sZW5ndGgtMikgKXtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblxuXHRpZiggIXNlbGYuc2V0dGluZ3MuZmlyc3RVcmwgKXtcblx0XHR0aHJvdyAndmlydHVhbF9zY3JvbGwgcGx1Z2luIHJlcXVpcmVzIGEgZmlyc3RVcmwoKSBtZXRob2QnO1xuXHR9XG5cblxuXHQvLyBpbiBvcmRlciBmb3IgdmlydHVhbCBzY3JvbGxpbmcgdG8gd29yayxcblx0Ly8gb3B0aW9ucyBuZWVkIHRvIGJlIG9yZGVyZWQgdGhlIHNhbWUgd2F5IHRoZXkncmUgcmV0dXJuZWQgZnJvbSB0aGUgcmVtb3RlIGRhdGEgc291cmNlXG5cdHNlbGYuc2V0dGluZ3Muc29ydEZpZWxkXHRcdFx0PSBbe2ZpZWxkOickb3JkZXInfSx7ZmllbGQ6JyRzY29yZSd9XTtcblxuXG5cdC8vIGNhbiB3ZSBsb2FkIG1vcmUgcmVzdWx0cyBmb3IgZ2l2ZW4gcXVlcnk/XG5cdGNvbnN0IGNhbkxvYWRNb3JlID0gKHF1ZXJ5OnN0cmluZyk6Ym9vbGVhbiA9PiB7XG5cblx0XHRpZiggdHlwZW9mIHNlbGYuc2V0dGluZ3MubWF4T3B0aW9ucyA9PT0gJ251bWJlcicgJiYgZHJvcGRvd25fY29udGVudC5jaGlsZHJlbi5sZW5ndGggPj0gc2VsZi5zZXR0aW5ncy5tYXhPcHRpb25zICl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYoIChxdWVyeSBpbiBwYWdpbmF0aW9uKSAmJiBwYWdpbmF0aW9uW3F1ZXJ5XSApe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdGNvbnN0IGNsZWFyRmlsdGVyID0gKG9wdGlvbjpUb21PcHRpb24sIHZhbHVlOnN0cmluZyk6Ym9vbGVhbiA9PiB7XG5cdFx0aWYoIHNlbGYuaXRlbXMuaW5kZXhPZih2YWx1ZSkgPj0gMCB8fCBkZWZhdWx0X3ZhbHVlcy5pbmRleE9mKHZhbHVlKSA+PSAwICl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0Ly8gc2V0IHRoZSBuZXh0IHVybCB0aGF0IHdpbGwgYmVcblx0c2VsZi5zZXROZXh0VXJsID0gKHZhbHVlOnN0cmluZyxuZXh0X3VybDphbnkpOnZvaWQgPT4ge1xuXHRcdHBhZ2luYXRpb25bdmFsdWVdID0gbmV4dF91cmw7XG5cdH07XG5cblx0Ly8gZ2V0VXJsKCkgdG8gYmUgdXNlZCBpbiBzZXR0aW5ncy5sb2FkKClcblx0c2VsZi5nZXRVcmwgPSAocXVlcnk6c3RyaW5nKTphbnkgPT57XG5cblx0XHRpZiggcXVlcnkgaW4gcGFnaW5hdGlvbiApe1xuXHRcdFx0Y29uc3QgbmV4dF91cmwgPSBwYWdpbmF0aW9uW3F1ZXJ5XTtcblx0XHRcdHBhZ2luYXRpb25bcXVlcnldID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gbmV4dF91cmw7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIHVzZXIgZ29lcyBiYWNrIHRvIGEgcHJldmlvdXMgcXVlcnlcblx0XHQvLyB3ZSBuZWVkIHRvIGxvYWQgdGhlIGZpcnN0IHBhZ2UgYWdhaW5cblx0XHRzZWxmLmNsZWFyUGFnaW5hdGlvbigpO1xuXG5cdFx0cmV0dXJuIHNlbGYuc2V0dGluZ3MuZmlyc3RVcmwuY2FsbChzZWxmLHF1ZXJ5KTtcblx0fTtcblxuXHQvLyBjbGVhciBwYWdpbmF0aW9uXG5cdHNlbGYuY2xlYXJQYWdpbmF0aW9uID0gKCk6dm9pZCA9Pntcblx0XHRwYWdpbmF0aW9uID0ge307XG5cdH07XG5cblx0Ly8gZG9uJ3QgY2xlYXIgdGhlIGFjdGl2ZSBvcHRpb24gKGFuZCBjYXVzZSB1bndhbnRlZCBkcm9wZG93biBzY3JvbGwpXG5cdC8vIHdoaWxlIGxvYWRpbmcgbW9yZSByZXN1bHRzXG5cdHNlbGYuaG9vaygnaW5zdGVhZCcsJ2NsZWFyQWN0aXZlT3B0aW9uJywoKT0+e1xuXG5cdFx0aWYoIGxvYWRpbmdfbW9yZSApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHJldHVybiBvcmlnX2NsZWFyQWN0aXZlT3B0aW9uLmNhbGwoc2VsZik7XG5cdH0pO1xuXG5cdC8vIG92ZXJyaWRlIHRoZSBjYW5Mb2FkIG1ldGhvZFxuXHRzZWxmLmhvb2soJ2luc3RlYWQnLCdjYW5Mb2FkJywocXVlcnk6c3RyaW5nKT0+e1xuXG5cdFx0Ly8gZmlyc3QgdGltZSB0aGUgcXVlcnkgaGFzIGJlZW4gc2VlblxuXHRcdGlmKCAhKHF1ZXJ5IGluIHBhZ2luYXRpb24pICl7XG5cdFx0XHRyZXR1cm4gb3JpZ19jYW5Mb2FkLmNhbGwoc2VsZixxdWVyeSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNhbkxvYWRNb3JlKHF1ZXJ5KTtcblx0fSk7XG5cblxuXHQvLyB3cmFwIHRoZSBsb2FkXG5cdHNlbGYuaG9vaygnaW5zdGVhZCcsJ2xvYWRDYWxsYmFjaycsKCBvcHRpb25zOlRvbU9wdGlvbltdLCBvcHRncm91cHM6VG9tT3B0aW9uW10pPT57XG5cblx0XHRpZiggIWxvYWRpbmdfbW9yZSApe1xuXHRcdFx0c2VsZi5jbGVhck9wdGlvbnMoY2xlYXJGaWx0ZXIpO1xuXHRcdH1lbHNlIGlmKCBsb2FkX21vcmVfb3B0ICl7XG5cdFx0XHRjb25zdCBmaXJzdF9vcHRpb24gPSBvcHRpb25zWzBdO1xuXHRcdFx0aWYoIGZpcnN0X29wdGlvbiAhPT0gdW5kZWZpbmVkICl7XG5cdFx0XHRcdGxvYWRfbW9yZV9vcHQuZGF0YXNldC52YWx1ZVx0XHQ9IGZpcnN0X29wdGlvbltzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG9yaWdfbG9hZENhbGxiYWNrLmNhbGwoIHNlbGYsIG9wdGlvbnMsIG9wdGdyb3Vwcyk7XG5cblx0XHRsb2FkaW5nX21vcmUgPSBmYWxzZTtcblx0fSk7XG5cblxuXHQvLyBhZGQgdGVtcGxhdGVzIHRvIGRyb3Bkb3duXG5cdC8vXHRsb2FkaW5nX21vcmUgaWYgd2UgaGF2ZSBhbm90aGVyIHVybCBpbiB0aGUgcXVldWVcblx0Ly9cdG5vX21vcmVfcmVzdWx0cyBpZiB3ZSBkb24ndCBoYXZlIGFub3RoZXIgdXJsIGluIHRoZSBxdWV1ZVxuXHRzZWxmLmhvb2soJ2FmdGVyJywncmVmcmVzaE9wdGlvbnMnLCgpPT57XG5cblx0XHRjb25zdCBxdWVyeVx0XHQ9IHNlbGYubGFzdFZhbHVlO1xuXHRcdHZhciBvcHRpb247XG5cblx0XHRpZiggY2FuTG9hZE1vcmUocXVlcnkpICl7XG5cblx0XHRcdG9wdGlvbiA9IHNlbGYucmVuZGVyKCdsb2FkaW5nX21vcmUnLHtxdWVyeTpxdWVyeX0pO1xuXHRcdFx0aWYoIG9wdGlvbiApe1xuXHRcdFx0XHRvcHRpb24uc2V0QXR0cmlidXRlKCdkYXRhLXNlbGVjdGFibGUnLCcnKTsgLy8gc28gdGhhdCBuYXZpZ2F0aW5nIGRyb3Bkb3duIHdpdGggW2Rvd25dIGtleXByZXNzZXMgY2FuIG5hdmlnYXRlIHRvIHRoaXMgbm9kZVxuXHRcdFx0XHRsb2FkX21vcmVfb3B0ID0gb3B0aW9uO1xuXHRcdFx0fVxuXG5cdFx0fWVsc2UgaWYoIChxdWVyeSBpbiBwYWdpbmF0aW9uKSAmJiAhZHJvcGRvd25fY29udGVudC5xdWVyeVNlbGVjdG9yKCcubm8tcmVzdWx0cycpICl7XG5cdFx0XHRvcHRpb24gPSBzZWxmLnJlbmRlcignbm9fbW9yZV9yZXN1bHRzJyx7cXVlcnk6cXVlcnl9KTtcblx0XHR9XG5cblx0XHRpZiggb3B0aW9uICl7XG5cdFx0XHRhZGRDbGFzc2VzKG9wdGlvbixzZWxmLnNldHRpbmdzLm9wdGlvbkNsYXNzKTtcblx0XHRcdGRyb3Bkb3duX2NvbnRlbnQuYXBwZW5kKCBvcHRpb24gKTtcblx0XHR9XG5cblx0fSk7XG5cblxuXHQvLyBhZGQgc2Nyb2xsIGxpc3RlbmVyIGFuZCBkZWZhdWx0IHRlbXBsYXRlc1xuXHRzZWxmLm9uKCdpbml0aWFsaXplJywoKT0+e1xuXHRcdGRlZmF1bHRfdmFsdWVzID0gT2JqZWN0LmtleXMoc2VsZi5vcHRpb25zKTtcblx0XHRkcm9wZG93bl9jb250ZW50ID0gc2VsZi5kcm9wZG93bl9jb250ZW50O1xuXG5cdFx0Ly8gZGVmYXVsdCB0ZW1wbGF0ZXNcblx0XHRzZWxmLnNldHRpbmdzLnJlbmRlciA9IE9iamVjdC5hc3NpZ24oe30sIHtcblx0XHRcdGxvYWRpbmdfbW9yZTooKSA9PiB7XG5cdFx0XHRcdHJldHVybiBgPGRpdiBjbGFzcz1cImxvYWRpbmctbW9yZS1yZXN1bHRzXCI+TG9hZGluZyBtb3JlIHJlc3VsdHMgLi4uIDwvZGl2PmA7XG5cdFx0XHR9LFxuXHRcdFx0bm9fbW9yZV9yZXN1bHRzOigpID0+e1xuXHRcdFx0XHRyZXR1cm4gYDxkaXYgY2xhc3M9XCJuby1tb3JlLXJlc3VsdHNcIj5ObyBtb3JlIHJlc3VsdHM8L2Rpdj5gO1xuXHRcdFx0fVxuXHRcdH0sc2VsZi5zZXR0aW5ncy5yZW5kZXIpO1xuXG5cblx0XHQvLyB3YXRjaCBkcm9wZG93biBjb250ZW50IHNjcm9sbCBwb3NpdGlvblxuXHRcdGRyb3Bkb3duX2NvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywoKT0+e1xuXG5cdFx0XHRpZiggIXNlbGYuc2V0dGluZ3Muc2hvdWxkTG9hZE1vcmUuY2FsbChzZWxmKSApe1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vICFpbXBvcnRhbnQ6IHRoaXMgd2lsbCBnZXQgY2hlY2tlZCBhZ2FpbiBpbiBsb2FkKCkgYnV0IHdlIHN0aWxsIG5lZWQgdG8gY2hlY2sgaGVyZSBvdGhlcndpc2UgbG9hZGluZ19tb3JlIHdpbGwgYmUgc2V0IHRvIHRydWVcblx0XHRcdGlmKCAhY2FuTG9hZE1vcmUoc2VsZi5sYXN0VmFsdWUpICl7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZG9uJ3QgY2FsbCBsb2FkKCkgdG9vIG11Y2hcblx0XHRcdGlmKCBsb2FkaW5nX21vcmUgKSByZXR1cm47XG5cblxuXHRcdFx0bG9hZGluZ19tb3JlID0gdHJ1ZTtcblx0XHRcdHNlbGYubG9hZC5jYWxsKHNlbGYsc2VsZi5sYXN0VmFsdWUpO1xuXHRcdH0pO1xuXHR9KTtcblxufTtcbiIsICJpbXBvcnQgVG9tU2VsZWN0IGZyb20gJy4vdG9tLXNlbGVjdCc7XG5cbmltcG9ydCBjaGFuZ2VfbGlzdGVuZXIgZnJvbSAnLi9wbHVnaW5zL2NoYW5nZV9saXN0ZW5lci9wbHVnaW4nO1xuaW1wb3J0IGNoZWNrYm94X29wdGlvbnMgZnJvbSAnLi9wbHVnaW5zL2NoZWNrYm94X29wdGlvbnMvcGx1Z2luJztcbmltcG9ydCBjbGVhcl9idXR0b24gZnJvbSAnLi9wbHVnaW5zL2NsZWFyX2J1dHRvbi9wbHVnaW4nO1xuaW1wb3J0IGRyYWdfZHJvcCBmcm9tICcuL3BsdWdpbnMvZHJhZ19kcm9wL3BsdWdpbic7XG5pbXBvcnQgZHJvcGRvd25faGVhZGVyIGZyb20gJy4vcGx1Z2lucy9kcm9wZG93bl9oZWFkZXIvcGx1Z2luJztcbmltcG9ydCBjYXJldF9wb3NpdGlvbiBmcm9tICcuL3BsdWdpbnMvY2FyZXRfcG9zaXRpb24vcGx1Z2luJztcbmltcG9ydCBkcm9wZG93bl9pbnB1dCBmcm9tICcuL3BsdWdpbnMvZHJvcGRvd25faW5wdXQvcGx1Z2luJztcbmltcG9ydCBpbnB1dF9hdXRvZ3JvdyBmcm9tICcuL3BsdWdpbnMvaW5wdXRfYXV0b2dyb3cvcGx1Z2luJztcbmltcG9ydCBub19iYWNrc3BhY2VfZGVsZXRlIGZyb20gJy4vcGx1Z2lucy9ub19iYWNrc3BhY2VfZGVsZXRlL3BsdWdpbic7XG5pbXBvcnQgbm9fYWN0aXZlX2l0ZW1zIGZyb20gJy4vcGx1Z2lucy9ub19hY3RpdmVfaXRlbXMvcGx1Z2luJztcbmltcG9ydCBvcHRncm91cF9jb2x1bW5zIGZyb20gJy4vcGx1Z2lucy9vcHRncm91cF9jb2x1bW5zL3BsdWdpbic7XG5pbXBvcnQgcmVtb3ZlX2J1dHRvbiBmcm9tICcuL3BsdWdpbnMvcmVtb3ZlX2J1dHRvbi9wbHVnaW4nO1xuaW1wb3J0IHJlc3RvcmVfb25fYmFja3NwYWNlIGZyb20gJy4vcGx1Z2lucy9yZXN0b3JlX29uX2JhY2tzcGFjZS9wbHVnaW4nO1xuaW1wb3J0IHZpcnR1YWxfc2Nyb2xsIGZyb20gJy4vcGx1Z2lucy92aXJ0dWFsX3Njcm9sbC9wbHVnaW4nO1xuXG5Ub21TZWxlY3QuZGVmaW5lKCdjaGFuZ2VfbGlzdGVuZXInLCBjaGFuZ2VfbGlzdGVuZXIpO1xuVG9tU2VsZWN0LmRlZmluZSgnY2hlY2tib3hfb3B0aW9ucycsIGNoZWNrYm94X29wdGlvbnMpO1xuVG9tU2VsZWN0LmRlZmluZSgnY2xlYXJfYnV0dG9uJywgY2xlYXJfYnV0dG9uKTtcblRvbVNlbGVjdC5kZWZpbmUoJ2RyYWdfZHJvcCcsIGRyYWdfZHJvcCk7XG5Ub21TZWxlY3QuZGVmaW5lKCdkcm9wZG93bl9oZWFkZXInLCBkcm9wZG93bl9oZWFkZXIpO1xuVG9tU2VsZWN0LmRlZmluZSgnY2FyZXRfcG9zaXRpb24nLCBjYXJldF9wb3NpdGlvbik7XG5Ub21TZWxlY3QuZGVmaW5lKCdkcm9wZG93bl9pbnB1dCcsIGRyb3Bkb3duX2lucHV0KTtcblRvbVNlbGVjdC5kZWZpbmUoJ2lucHV0X2F1dG9ncm93JywgaW5wdXRfYXV0b2dyb3cpO1xuVG9tU2VsZWN0LmRlZmluZSgnbm9fYmFja3NwYWNlX2RlbGV0ZScsIG5vX2JhY2tzcGFjZV9kZWxldGUpO1xuVG9tU2VsZWN0LmRlZmluZSgnbm9fYWN0aXZlX2l0ZW1zJywgbm9fYWN0aXZlX2l0ZW1zKTtcblRvbVNlbGVjdC5kZWZpbmUoJ29wdGdyb3VwX2NvbHVtbnMnLCBvcHRncm91cF9jb2x1bW5zKTtcblRvbVNlbGVjdC5kZWZpbmUoJ3JlbW92ZV9idXR0b24nLCByZW1vdmVfYnV0dG9uKTtcblRvbVNlbGVjdC5kZWZpbmUoJ3Jlc3RvcmVfb25fYmFja3NwYWNlJywgcmVzdG9yZV9vbl9iYWNrc3BhY2UpO1xuVG9tU2VsZWN0LmRlZmluZSgndmlydHVhbF9zY3JvbGwnLCB2aXJ0dWFsX3Njcm9sbCk7XG5cbmV4cG9ydCBkZWZhdWx0IFRvbVNlbGVjdDtcbiIsICIvKipcclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqIHRvcGJhciAxLjAuMCwgMjAyMS0wMS0wNlxyXG4gKiBodHRwczovL2J1dW5ndXllbi5naXRodWIuaW8vdG9wYmFyXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMSBCdXUgTmd1eWVuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQpIHtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzFcclxuICAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGxhc3RUaW1lID0gMDtcclxuICAgIHZhciB2ZW5kb3JzID0gW1wibXNcIiwgXCJtb3pcIiwgXCJ3ZWJraXRcIiwgXCJvXCJdO1xyXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XHJcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxyXG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XHJcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9XHJcbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdIHx8XHJcbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcclxuICAgIH1cclxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSlcclxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xyXG4gICAgICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XHJcbiAgICAgICAgfSwgdGltZVRvQ2FsbCk7XHJcbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgICB9O1xyXG4gICAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpXHJcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XHJcbiAgICAgIH07XHJcbiAgfSkoKTtcclxuXHJcbiAgdmFyIGNhbnZhcyxcclxuICAgIHByb2dyZXNzVGltZXJJZCxcclxuICAgIGZhZGVUaW1lcklkLFxyXG4gICAgY3VycmVudFByb2dyZXNzLFxyXG4gICAgc2hvd2luZyxcclxuICAgIGFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgICAgZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkgZWxlbS5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBoYW5kbGVyKTtcclxuICAgICAgZWxzZSBlbGVtW1wib25cIiArIHR5cGVdID0gaGFuZGxlcjtcclxuICAgIH0sXHJcbiAgICBvcHRpb25zID0ge1xyXG4gICAgICBhdXRvUnVuOiB0cnVlLFxyXG4gICAgICBiYXJUaGlja25lc3M6IDMsXHJcbiAgICAgIGJhckNvbG9yczoge1xyXG4gICAgICAgIDA6IFwicmdiYSgyNiwgIDE4OCwgMTU2LCAuOSlcIixcclxuICAgICAgICBcIi4yNVwiOiBcInJnYmEoNTIsICAxNTIsIDIxOSwgLjkpXCIsXHJcbiAgICAgICAgXCIuNTBcIjogXCJyZ2JhKDI0MSwgMTk2LCAxNSwgIC45KVwiLFxyXG4gICAgICAgIFwiLjc1XCI6IFwicmdiYSgyMzAsIDEyNiwgMzQsICAuOSlcIixcclxuICAgICAgICBcIjEuMFwiOiBcInJnYmEoMjExLCA4NCwgIDAsICAgLjkpXCIsXHJcbiAgICAgIH0sXHJcbiAgICAgIHNoYWRvd0JsdXI6IDEwLFxyXG4gICAgICBzaGFkb3dDb2xvcjogXCJyZ2JhKDAsICAgMCwgICAwLCAgIC42KVwiLFxyXG4gICAgICBjbGFzc05hbWU6IG51bGwsXHJcbiAgICB9LFxyXG4gICAgcmVwYWludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmJhclRoaWNrbmVzcyAqIDU7IC8vIG5lZWQgc3BhY2UgZm9yIHNoYWRvd1xyXG5cclxuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gb3B0aW9ucy5zaGFkb3dCbHVyO1xyXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBvcHRpb25zLnNoYWRvd0NvbG9yO1xyXG5cclxuICAgICAgdmFyIGxpbmVHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBjYW52YXMud2lkdGgsIDApO1xyXG4gICAgICBmb3IgKHZhciBzdG9wIGluIG9wdGlvbnMuYmFyQ29sb3JzKVxyXG4gICAgICAgIGxpbmVHcmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgb3B0aW9ucy5iYXJDb2xvcnNbc3RvcF0pO1xyXG4gICAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4Lm1vdmVUbygwLCBvcHRpb25zLmJhclRoaWNrbmVzcyAvIDIpO1xyXG4gICAgICBjdHgubGluZVRvKFxyXG4gICAgICAgIE1hdGguY2VpbChjdXJyZW50UHJvZ3Jlc3MgKiBjYW52YXMud2lkdGgpLFxyXG4gICAgICAgIG9wdGlvbnMuYmFyVGhpY2tuZXNzIC8gMlxyXG4gICAgICApO1xyXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsaW5lR3JhZGllbnQ7XHJcbiAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgIHZhciBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcclxuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XHJcbiAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmxlZnQgPSBzdHlsZS5yaWdodCA9IHN0eWxlLm1hcmdpbiA9IHN0eWxlLnBhZGRpbmcgPSAwO1xyXG4gICAgICBzdHlsZS56SW5kZXggPSAxMDAwMDE7XHJcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgaWYgKG9wdGlvbnMuY2xhc3NOYW1lKSBjYW52YXMuY2xhc3NMaXN0LmFkZChvcHRpb25zLmNsYXNzTmFtZSk7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcclxuICAgICAgYWRkRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCByZXBhaW50KTtcclxuICAgIH0sXHJcbiAgICB0b3BiYXIgPSB7XHJcbiAgICAgIGNvbmZpZzogZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0cylcclxuICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIG9wdGlvbnNba2V5XSA9IG9wdHNba2V5XTtcclxuICAgICAgfSxcclxuICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChzaG93aW5nKSByZXR1cm47XHJcbiAgICAgICAgc2hvd2luZyA9IHRydWU7XHJcbiAgICAgICAgaWYgKGZhZGVUaW1lcklkICE9PSBudWxsKSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoZmFkZVRpbWVySWQpO1xyXG4gICAgICAgIGlmICghY2FudmFzKSBjcmVhdGVDYW52YXMoKTtcclxuICAgICAgICBjYW52YXMuc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgdG9wYmFyLnByb2dyZXNzKDApO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9SdW4pIHtcclxuICAgICAgICAgIChmdW5jdGlvbiBsb29wKCkge1xyXG4gICAgICAgICAgICBwcm9ncmVzc1RpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xyXG4gICAgICAgICAgICB0b3BiYXIucHJvZ3Jlc3MoXHJcbiAgICAgICAgICAgICAgXCIrXCIgKyAwLjA1ICogTWF0aC5wb3coMSAtIE1hdGguc3FydChjdXJyZW50UHJvZ3Jlc3MpLCAyKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHByb2dyZXNzOiBmdW5jdGlvbiAodG8pIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gY3VycmVudFByb2dyZXNzO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgIHRvID1cclxuICAgICAgICAgICAgKHRvLmluZGV4T2YoXCIrXCIpID49IDAgfHwgdG8uaW5kZXhPZihcIi1cIikgPj0gMFxyXG4gICAgICAgICAgICAgID8gY3VycmVudFByb2dyZXNzXHJcbiAgICAgICAgICAgICAgOiAwKSArIHBhcnNlRmxvYXQodG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3MgPSB0byA+IDEgPyAxIDogdG87XHJcbiAgICAgICAgcmVwYWludCgpO1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50UHJvZ3Jlc3M7XHJcbiAgICAgIH0sXHJcbiAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXNob3dpbmcpIHJldHVybjtcclxuICAgICAgICBzaG93aW5nID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHByb2dyZXNzVGltZXJJZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocHJvZ3Jlc3NUaW1lcklkKTtcclxuICAgICAgICAgIHByb2dyZXNzVGltZXJJZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIChmdW5jdGlvbiBsb29wKCkge1xyXG4gICAgICAgICAgaWYgKHRvcGJhci5wcm9ncmVzcyhcIisuMVwiKSA+PSAxKSB7XHJcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5vcGFjaXR5IC09IDAuMDU7XHJcbiAgICAgICAgICAgIGlmIChjYW52YXMuc3R5bGUub3BhY2l0eSA8PSAwLjA1KSB7XHJcbiAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgICBmYWRlVGltZXJJZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmYWRlVGltZXJJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XHJcbiAgICAgICAgfSkoKTtcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b3BiYXI7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRvcGJhcjtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnRvcGJhciA9IHRvcGJhcjtcclxuICB9XHJcbn0uY2FsbCh0aGlzLCB3aW5kb3csIGRvY3VtZW50KSk7XHJcbiIsICIvKiFcbiAqIENoYXJ0LmpzIHYzLjkuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIyIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkNoYXJ0ID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5jb25zdCB1aWQgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpZCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWQrKztcbiAgfTtcbn0oKSk7XG5mdW5jdGlvbiBpc051bGxPclVuZGVmKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodHlwZS5zbGljZSgwLCA3KSA9PT0gJ1tvYmplY3QnICYmIHR5cGUuc2xpY2UoLTYpID09PSAnQXJyYXldJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmNvbnN0IGlzTnVtYmVyRmluaXRlID0gKHZhbHVlKSA9PiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUoK3ZhbHVlKTtcbmZ1bmN0aW9uIGZpbml0ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn1cbmNvbnN0IHRvUGVyY2VudGFnZSA9ICh2YWx1ZSwgZGltZW5zaW9uKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiB2YWx1ZSAvIGRpbWVuc2lvbjtcbmNvbnN0IHRvRGltZW5zaW9uID0gKHZhbHVlLCBkaW1lbnNpb24pID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBkaW1lbnNpb25cbiAgICA6ICt2YWx1ZTtcbmZ1bmN0aW9uIGNhbGxiYWNrKGZuLCBhcmdzLCB0aGlzQXJnKSB7XG4gIGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZWFjaChsb29wYWJsZSwgZm4sIHRoaXNBcmcsIHJldmVyc2UpIHtcbiAgbGV0IGksIGxlbiwga2V5cztcbiAgaWYgKGlzQXJyYXkobG9vcGFibGUpKSB7XG4gICAgbGVuID0gbG9vcGFibGUubGVuZ3RoO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChsb29wYWJsZSkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfZWxlbWVudHNFcXVhbChhMCwgYTEpIHtcbiAgbGV0IGksIGlsZW4sIHYwLCB2MTtcbiAgaWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcbiAgICBpZiAodjAuZGF0YXNldEluZGV4ICE9PSB2MS5kYXRhc2V0SW5kZXggfHwgdjAuaW5kZXggIT09IHYxLmluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2xvbmUkMShzb3VyY2UpIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lJDEpO1xuICB9XG4gIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBjb25zdCBrbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGsgPSAwO1xuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZSQxKHNvdXJjZVtrZXlzW2tdXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuZnVuY3Rpb24gX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lJDEoc3ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBpc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcbiAgY29uc3QgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChsZXQgayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuICAgICAgbWVyZ2VyKGtleXNba10sIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG1lcmdlSWYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG1lcmdlKHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBfbWVyZ2VySWZ9KTtcbn1cbmZ1bmN0aW9uIF9tZXJnZXJJZihrZXksIHRhcmdldCwgc291cmNlKSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZUlmKHR2YWwsIHN2YWwpO1xuICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZSQxKHN2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBfZGVwcmVjYXRlZChzY29wZSwgdmFsdWUsIHByZXZpb3VzLCBjdXJyZW50KSB7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgK1xuXHRcdFx0J1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCInICsgY3VycmVudCArICdcIiBpbnN0ZWFkJyk7XG4gIH1cbn1cbmNvbnN0IGtleVJlc29sdmVycyA9IHtcbiAgJyc6IHYgPT4gdixcbiAgeDogbyA9PiBvLngsXG4gIHk6IG8gPT4gby55XG59O1xuZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSkge1xuICBjb25zdCByZXNvbHZlciA9IGtleVJlc29sdmVyc1trZXldIHx8IChrZXlSZXNvbHZlcnNba2V5XSA9IF9nZXRLZXlSZXNvbHZlcihrZXkpKTtcbiAgcmV0dXJuIHJlc29sdmVyKG9iaik7XG59XG5mdW5jdGlvbiBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSB7XG4gIGNvbnN0IGtleXMgPSBfc3BsaXRLZXkoa2V5KTtcbiAgcmV0dXJuIG9iaiA9PiB7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgIGlmIChrID09PSAnJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9iaiAmJiBvYmpba107XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG59XG5mdW5jdGlvbiBfc3BsaXRLZXkoa2V5KSB7XG4gIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgbGV0IHRtcCA9ICcnO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICB0bXAgKz0gcGFydDtcbiAgICBpZiAodG1wLmVuZHNXaXRoKCdcXFxcJykpIHtcbiAgICAgIHRtcCA9IHRtcC5zbGljZSgwLCAtMSkgKyAnLic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaCh0bXApO1xuICAgICAgdG1wID0gJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5jb25zdCBkZWZpbmVkID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuY29uc3Qgc2V0c0VxdWFsID0gKGEsIGIpID0+IHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBfaXNDbGlja0V2ZW50KGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdjb250ZXh0bWVudSc7XG59XG5cbmNvbnN0IFBJID0gTWF0aC5QSTtcbmNvbnN0IFRBVSA9IDIgKiBQSTtcbmNvbnN0IFBJVEFVID0gVEFVICsgUEk7XG5jb25zdCBJTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbmNvbnN0IFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG5jb25zdCBIQUxGX1BJID0gUEkgLyAyO1xuY29uc3QgUVVBUlRFUl9QSSA9IFBJIC8gNDtcbmNvbnN0IFRXT19USElSRFNfUEkgPSBQSSAqIDIgLyAzO1xuY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwO1xuY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcbmZ1bmN0aW9uIG5pY2VOdW0ocmFuZ2UpIHtcbiAgY29uc3Qgcm91bmRlZFJhbmdlID0gTWF0aC5yb3VuZChyYW5nZSk7XG4gIHJhbmdlID0gYWxtb3N0RXF1YWxzKHJhbmdlLCByb3VuZGVkUmFuZ2UsIHJhbmdlIC8gMTAwMCkgPyByb3VuZGVkUmFuZ2UgOiByYW5nZTtcbiAgY29uc3QgbmljZVJhbmdlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAocmFuZ2UpKSk7XG4gIGNvbnN0IGZyYWN0aW9uID0gcmFuZ2UgLyBuaWNlUmFuZ2U7XG4gIGNvbnN0IG5pY2VGcmFjdGlvbiA9IGZyYWN0aW9uIDw9IDEgPyAxIDogZnJhY3Rpb24gPD0gMiA/IDIgOiBmcmFjdGlvbiA8PSA1ID8gNSA6IDEwO1xuICByZXR1cm4gbmljZUZyYWN0aW9uICogbmljZVJhbmdlO1xufVxuZnVuY3Rpb24gX2ZhY3Rvcml6ZSh2YWx1ZSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc3FydCA9IE1hdGguc3FydCh2YWx1ZSk7XG4gIGxldCBpO1xuICBmb3IgKGkgPSAxOyBpIDwgc3FydDsgaSsrKSB7XG4gICAgaWYgKHZhbHVlICUgaSA9PT0gMCkge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSAvIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoc3FydCA9PT0gKHNxcnQgfCAwKSkge1xuICAgIHJlc3VsdC5wdXNoKHNxcnQpO1xuICB9XG4gIHJlc3VsdC5zb3J0KChhLCBiKSA9PiBhIC0gYikucG9wKCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc051bWJlcihuKSB7XG4gIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5mdW5jdGlvbiBhbG1vc3RFcXVhbHMoeCwgeSwgZXBzaWxvbikge1xuICByZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgZXBzaWxvbjtcbn1cbmZ1bmN0aW9uIGFsbW9zdFdob2xlKHgsIGVwc2lsb24pIHtcbiAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG4gIHJldHVybiAoKHJvdW5kZWQgLSBlcHNpbG9uKSA8PSB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+PSB4KTtcbn1cbmZ1bmN0aW9uIF9zZXRNaW5BbmRNYXhCeUtleShhcnJheSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycmF5W2ldW3Byb3BlcnR5XTtcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdGFyZ2V0Lm1pbiA9IE1hdGgubWluKHRhcmdldC5taW4sIHZhbHVlKTtcbiAgICAgIHRhcmdldC5tYXggPSBNYXRoLm1heCh0YXJnZXQubWF4LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xuICByZXR1cm4gZGVncmVlcyAqIChQSSAvIDE4MCk7XG59XG5mdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xuICByZXR1cm4gcmFkaWFucyAqICgxODAgLyBQSSk7XG59XG5mdW5jdGlvbiBfZGVjaW1hbFBsYWNlcyh4KSB7XG4gIGlmICghaXNOdW1iZXJGaW5pdGUoeCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGUgPSAxO1xuICBsZXQgcCA9IDA7XG4gIHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcbiAgICBlICo9IDEwO1xuICAgIHArKztcbiAgfVxuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGdldEFuZ2xlRnJvbVBvaW50KGNlbnRyZVBvaW50LCBhbmdsZVBvaW50KSB7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVhDZW50ZXIgPSBhbmdsZVBvaW50LnggLSBjZW50cmVQb2ludC54O1xuICBjb25zdCBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcbiAgY29uc3QgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKGRpc3RhbmNlRnJvbVlDZW50ZXIsIGRpc3RhbmNlRnJvbVhDZW50ZXIpO1xuICBpZiAoYW5nbGUgPCAoLTAuNSAqIFBJKSkge1xuICAgIGFuZ2xlICs9IFRBVTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFuZ2xlLFxuICAgIGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlblBvaW50cyhwdDEsIHB0Mikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHB0Mi54IC0gcHQxLngsIDIpICsgTWF0aC5wb3cocHQyLnkgLSBwdDEueSwgMikpO1xufVxuZnVuY3Rpb24gX2FuZ2xlRGlmZihhLCBiKSB7XG4gIHJldHVybiAoYSAtIGIgKyBQSVRBVSkgJSBUQVUgLSBQSTtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVBbmdsZShhKSB7XG4gIHJldHVybiAoYSAlIFRBVSArIFRBVSkgJSBUQVU7XG59XG5mdW5jdGlvbiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydCwgZW5kLCBzYW1lQW5nbGVJc0Z1bGxDaXJjbGUpIHtcbiAgY29uc3QgYSA9IF9ub3JtYWxpemVBbmdsZShhbmdsZSk7XG4gIGNvbnN0IHMgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICBjb25zdCBlID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIGNvbnN0IGFuZ2xlVG9TdGFydCA9IF9ub3JtYWxpemVBbmdsZShzIC0gYSk7XG4gIGNvbnN0IGFuZ2xlVG9FbmQgPSBfbm9ybWFsaXplQW5nbGUoZSAtIGEpO1xuICBjb25zdCBzdGFydFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIHMpO1xuICBjb25zdCBlbmRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBlKTtcbiAgcmV0dXJuIGEgPT09IHMgfHwgYSA9PT0gZSB8fCAoc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlICYmIHMgPT09IGUpXG4gICAgfHwgKGFuZ2xlVG9TdGFydCA+IGFuZ2xlVG9FbmQgJiYgc3RhcnRUb0FuZ2xlIDwgZW5kVG9BbmdsZSk7XG59XG5mdW5jdGlvbiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gX2ludDE2UmFuZ2UodmFsdWUpIHtcbiAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbn1cbmZ1bmN0aW9uIF9pc0JldHdlZW4odmFsdWUsIHN0YXJ0LCBlbmQsIGVwc2lsb24gPSAxZS02KSB7XG4gIHJldHVybiB2YWx1ZSA+PSBNYXRoLm1pbihzdGFydCwgZW5kKSAtIGVwc2lsb24gJiYgdmFsdWUgPD0gTWF0aC5tYXgoc3RhcnQsIGVuZCkgKyBlcHNpbG9uO1xufVxuXG5mdW5jdGlvbiBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgY21wKSB7XG4gIGNtcCA9IGNtcCB8fCAoKGluZGV4KSA9PiB0YWJsZVtpbmRleF0gPCB2YWx1ZSk7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBtaWQ7XG4gIHdoaWxlIChoaSAtIGxvID4gMSkge1xuICAgIG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgIGlmIChjbXAobWlkKSkge1xuICAgICAgbG8gPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2xvLCBoaX07XG59XG5jb25zdCBfbG9va3VwQnlLZXkgPSAodGFibGUsIGtleSwgdmFsdWUsIGxhc3QpID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBsYXN0XG4gICAgPyBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8PSB2YWx1ZVxuICAgIDogaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPCB2YWx1ZSk7XG5jb25zdCBfcmxvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlKSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPj0gdmFsdWUpO1xuZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzLCBtaW4sIG1heCkge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gdmFsdWVzLmxlbmd0aDtcbiAgd2hpbGUgKHN0YXJ0IDwgZW5kICYmIHZhbHVlc1tzdGFydF0gPCBtaW4pIHtcbiAgICBzdGFydCsrO1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiB2YWx1ZXNbZW5kIC0gMV0gPiBtYXgpIHtcbiAgICBlbmQtLTtcbiAgfVxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuY29uc3QgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J107XG5mdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgaWYgKGFycmF5Ll9jaGFydGpzKSB7XG4gICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHtcbiAgICAgIGxpc3RlbmVyczogW2xpc3RlbmVyXVxuICAgIH1cbiAgfSk7XG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMuZm9yRWFjaCgob2JqZWN0KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqZWN0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBjb25zdCBzdHViID0gYXJyYXkuX2NoYXJ0anM7XG4gIGlmICghc3R1Yikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgZGVsZXRlIGFycmF5W2tleV07XG4gIH0pO1xuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5mdW5jdGlvbiBfYXJyYXlVbmlxdWUoaXRlbXMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHNldC5hZGQoaXRlbXNbaV0pO1xuICB9XG4gIGlmIChzZXQuc2l6ZSA9PT0gaWxlbikge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuXG5mdW5jdGlvbiBmb250U3RyaW5nKHBpeGVsU2l6ZSwgZm9udFN0eWxlLCBmb250RmFtaWx5KSB7XG4gIHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG59XG5jb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCkpO1xuZnVuY3Rpb24gdGhyb3R0bGVkKGZuLCB0aGlzQXJnLCB1cGRhdGVGbikge1xuICBjb25zdCB1cGRhdGVBcmdzID0gdXBkYXRlRm4gfHwgKChhcmdzKSA9PiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKSk7XG4gIGxldCB0aWNraW5nID0gZmFsc2U7XG4gIGxldCBhcmdzID0gW107XG4gIHJldHVybiBmdW5jdGlvbiguLi5yZXN0KSB7XG4gICAgYXJncyA9IHVwZGF0ZUFyZ3MocmVzdCk7XG4gICAgaWYgKCF0aWNraW5nKSB7XG4gICAgICB0aWNraW5nID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgICAgdGlja2luZyA9IGZhbHNlO1xuICAgICAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBkZWxheSkge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG4gIH07XG59XG5jb25zdCBfdG9MZWZ0UmlnaHRDZW50ZXIgPSAoYWxpZ24pID0+IGFsaWduID09PSAnc3RhcnQnID8gJ2xlZnQnIDogYWxpZ24gPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuY29uc3QgX2FsaWduU3RhcnRFbmQgPSAoYWxpZ24sIHN0YXJ0LCBlbmQpID0+IGFsaWduID09PSAnc3RhcnQnID8gc3RhcnQgOiBhbGlnbiA9PT0gJ2VuZCcgPyBlbmQgOiAoc3RhcnQgKyBlbmQpIC8gMjtcbmNvbnN0IF90ZXh0WCA9IChhbGlnbiwgbGVmdCwgcmlnaHQsIHJ0bCkgPT4ge1xuICBjb25zdCBjaGVjayA9IHJ0bCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHJldHVybiBhbGlnbiA9PT0gY2hlY2sgPyByaWdodCA6IGFsaWduID09PSAnY2VudGVyJyA/IChsZWZ0ICsgcmlnaHQpIC8gMiA6IGxlZnQ7XG59O1xuZnVuY3Rpb24gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudCA9IHBvaW50Q291bnQ7XG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCBfcGFyc2VkfSA9IG1ldGE7XG4gICAgY29uc3QgYXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICAgIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgICBzdGFydCA9IF9saW1pdFZhbHVlKE1hdGgubWluKFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1pbikubG8sXG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyksXG4gICAgICAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICBjb3VudCA9IF9saW1pdFZhbHVlKE1hdGgubWF4KFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1heCwgdHJ1ZSkuaGkgKyAxLFxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyAwIDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWF4KSwgdHJ1ZSkuaGkgKyAxKSxcbiAgICAgIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuZnVuY3Rpb24gX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZSwgX3NjYWxlUmFuZ2VzfSA9IG1ldGE7XG4gIGNvbnN0IG5ld1JhbmdlcyA9IHtcbiAgICB4bWluOiB4U2NhbGUubWluLFxuICAgIHhtYXg6IHhTY2FsZS5tYXgsXG4gICAgeW1pbjogeVNjYWxlLm1pbixcbiAgICB5bWF4OiB5U2NhbGUubWF4XG4gIH07XG4gIGlmICghX3NjYWxlUmFuZ2VzKSB7XG4gICAgbWV0YS5fc2NhbGVSYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgY2hhbmdlZCA9IF9zY2FsZVJhbmdlcy54bWluICE9PSB4U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnhtYXggIT09IHhTY2FsZS5tYXhcblx0XHR8fCBfc2NhbGVSYW5nZXMueW1pbiAhPT0geVNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWF4ICE9PSB5U2NhbGUubWF4O1xuICBPYmplY3QuYXNzaWduKF9zY2FsZVJhbmdlcywgbmV3UmFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbmNsYXNzIEFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5fY2hhcnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBfbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgdHlwZSkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGFuaW1zLmxpc3RlbmVyc1t0eXBlXTtcbiAgICBjb25zdCBudW1TdGVwcyA9IGFuaW1zLmR1cmF0aW9uO1xuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZuID0+IGZuKHtcbiAgICAgIGNoYXJ0LFxuICAgICAgaW5pdGlhbDogYW5pbXMuaW5pdGlhbCxcbiAgICAgIG51bVN0ZXBzLFxuICAgICAgY3VycmVudFN0ZXA6IE1hdGgubWluKGRhdGUgLSBhbmltcy5zdGFydCwgbnVtU3RlcHMpXG4gICAgfSkpO1xuICB9XG4gIF9yZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF91cGRhdGUoZGF0ZSA9IERhdGUubm93KCkpIHtcbiAgICBsZXQgcmVtYWluaW5nID0gMDtcbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XG4gICAgICBpZiAoIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgIGxldCBpdGVtO1xuICAgICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0uX2FjdGl2ZSkge1xuICAgICAgICAgIGlmIChpdGVtLl90b3RhbCA+IGFuaW1zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGl0ZW0uX3RvdGFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnRpY2soZGF0ZSk7XG4gICAgICAgICAgZHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbXNbaV0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgY2hhcnQuZHJhdygpO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAncHJvZ3Jlc3MnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFuaW1zLmluaXRpYWwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJlbWFpbmluZyArPSBpdGVtcy5sZW5ndGg7XG4gICAgfSk7XG4gICAgdGhpcy5fbGFzdERhdGUgPSBkYXRlO1xuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX2dldEFuaW1zKGNoYXJ0KSB7XG4gICAgY29uc3QgY2hhcnRzID0gdGhpcy5fY2hhcnRzO1xuICAgIGxldCBhbmltcyA9IGNoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIGFuaW1zID0ge1xuICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICBjb21wbGV0ZTogW10sXG4gICAgICAgICAgcHJvZ3Jlc3M6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFydHMuc2V0KGNoYXJ0LCBhbmltcyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltcztcbiAgfVxuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2IpO1xuICB9XG4gIGFkZChjaGFydCwgaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICB9XG4gIGhhcyhjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMubGVuZ3RoID4gMDtcbiAgfVxuICBzdGFydChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBhbmltcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgYW5pbXMuZHVyYXRpb24gPSBhbmltcy5pdGVtcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiBNYXRoLm1heChhY2MsIGN1ci5fZHVyYXRpb24pLCAwKTtcbiAgICB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgcnVubmluZyhjaGFydCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpdGVtc1tpXS5jYW5jZWwoKTtcbiAgICB9XG4gICAgYW5pbXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBEYXRlLm5vdygpLCAnY29tcGxldGUnKTtcbiAgfVxuICByZW1vdmUoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIH1cbn1cbnZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcigpO1xuXG4vKiFcbiAqIEBrdXJrbGUvY29sb3IgdjAuMi4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20va3Vya2xlL2NvbG9yI3JlYWRtZVxuICogKGMpIDIwMjIgSnVra2EgS3Vya2VsYVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHJvdW5kKHYpIHtcbiAgcmV0dXJuIHYgKyAwLjUgfCAwO1xufVxuY29uc3QgbGltID0gKHYsIGwsIGgpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIGgpLCBsKTtcbmZ1bmN0aW9uIHAyYih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDIuNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5jb25zdCBtYXAkMSA9IHswOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LCBBOiAxMCwgQjogMTEsIEM6IDEyLCBEOiAxMywgRTogMTQsIEY6IDE1LCBhOiAxMCwgYjogMTEsIGM6IDEyLCBkOiAxMywgZTogMTQsIGY6IDE1fTtcbmNvbnN0IGhleCA9IFsuLi4nMDEyMzQ1Njc4OUFCQ0RFRiddO1xuY29uc3QgaDEgPSBiID0+IGhleFtiICYgMHhGXTtcbmNvbnN0IGgyID0gYiA9PiBoZXhbKGIgJiAweEYwKSA+PiA0XSArIGhleFtiICYgMHhGXTtcbmNvbnN0IGVxID0gYiA9PiAoKGIgJiAweEYwKSA+PiA0KSA9PT0gKGIgJiAweEYpO1xuY29uc3QgaXNTaG9ydCA9IHYgPT4gZXEodi5yKSAmJiBlcSh2LmcpICYmIGVxKHYuYikgJiYgZXEodi5hKTtcbmZ1bmN0aW9uIGhleFBhcnNlKHN0cikge1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKGxlbiA9PT0gNCB8fCBsZW4gPT09IDUpIHtcbiAgICAgIHJldCA9IHtcbiAgICAgICAgcjogMjU1ICYgbWFwJDFbc3RyWzFdXSAqIDE3LFxuICAgICAgICBnOiAyNTUgJiBtYXAkMVtzdHJbMl1dICogMTcsXG4gICAgICAgIGI6IDI1NSAmIG1hcCQxW3N0clszXV0gKiAxNyxcbiAgICAgICAgYTogbGVuID09PSA1ID8gbWFwJDFbc3RyWzRdXSAqIDE3IDogMjU1XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGVuID09PSA3IHx8IGxlbiA9PT0gOSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiBtYXAkMVtzdHJbMV1dIDw8IDQgfCBtYXAkMVtzdHJbMl1dLFxuICAgICAgICBnOiBtYXAkMVtzdHJbM11dIDw8IDQgfCBtYXAkMVtzdHJbNF1dLFxuICAgICAgICBiOiBtYXAkMVtzdHJbNV1dIDw8IDQgfCBtYXAkMVtzdHJbNl1dLFxuICAgICAgICBhOiBsZW4gPT09IDkgPyAobWFwJDFbc3RyWzddXSA8PCA0IHwgbWFwJDFbc3RyWzhdXSkgOiAyNTVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5jb25zdCBhbHBoYSA9IChhLCBmKSA9PiBhIDwgMjU1ID8gZihhKSA6ICcnO1xuZnVuY3Rpb24gaGV4U3RyaW5nKHYpIHtcbiAgdmFyIGYgPSBpc1Nob3J0KHYpID8gaDEgOiBoMjtcbiAgcmV0dXJuIHZcbiAgICA/ICcjJyArIGYodi5yKSArIGYodi5nKSArIGYodi5iKSArIGFscGhhKHYuYSwgZilcbiAgICA6IHVuZGVmaW5lZDtcbn1cbmNvbnN0IEhVRV9SRSA9IC9eKGhzbGE/fGh3Ynxoc3YpXFwoXFxzKihbLSsuZVxcZF0rKSg/OmRlZyk/W1xccyxdKyhbLSsuZVxcZF0rKSVbXFxzLF0rKFstKy5lXFxkXSspJSg/OltcXHMsXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiBoc2wycmdibihoLCBzLCBsKSB7XG4gIGNvbnN0IGEgPSBzICogTWF0aC5taW4obCwgMSAtIGwpO1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyAzMCkgJSAxMikgPT4gbCAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XG4gIHJldHVybiBbZigwKSwgZig4KSwgZig0KV07XG59XG5mdW5jdGlvbiBoc3YycmdibihoLCBzLCB2KSB7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDYwKSAlIDYpID0+IHYgLSB2ICogcyAqIE1hdGgubWF4KE1hdGgubWluKGssIDQgLSBrLCAxKSwgMCk7XG4gIHJldHVybiBbZig1KSwgZigzKSwgZigxKV07XG59XG5mdW5jdGlvbiBod2IycmdibihoLCB3LCBiKSB7XG4gIGNvbnN0IHJnYiA9IGhzbDJyZ2JuKGgsIDEsIDAuNSk7XG4gIGxldCBpO1xuICBpZiAodyArIGIgPiAxKSB7XG4gICAgaSA9IDEgLyAodyArIGIpO1xuICAgIHcgKj0gaTtcbiAgICBiICo9IGk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHJnYltpXSAqPSAxIC0gdyAtIGI7XG4gICAgcmdiW2ldICs9IHc7XG4gIH1cbiAgcmV0dXJuIHJnYjtcbn1cbmZ1bmN0aW9uIGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCkge1xuICBpZiAociA9PT0gbWF4KSB7XG4gICAgcmV0dXJuICgoZyAtIGIpIC8gZCkgKyAoZyA8IGIgPyA2IDogMCk7XG4gIH1cbiAgaWYgKGcgPT09IG1heCkge1xuICAgIHJldHVybiAoYiAtIHIpIC8gZCArIDI7XG4gIH1cbiAgcmV0dXJuIChyIC0gZykgLyBkICsgNDtcbn1cbmZ1bmN0aW9uIHJnYjJoc2wodikge1xuICBjb25zdCByYW5nZSA9IDI1NTtcbiAgY29uc3QgciA9IHYuciAvIHJhbmdlO1xuICBjb25zdCBnID0gdi5nIC8gcmFuZ2U7XG4gIGNvbnN0IGIgPSB2LmIgLyByYW5nZTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuICBsZXQgaCwgcywgZDtcbiAgaWYgKG1heCAhPT0gbWluKSB7XG4gICAgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgaCA9IGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCk7XG4gICAgaCA9IGggKiA2MCArIDAuNTtcbiAgfVxuICByZXR1cm4gW2ggfCAwLCBzIHx8IDAsIGxdO1xufVxuZnVuY3Rpb24gY2FsbG4oZiwgYSwgYiwgYykge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkoYSlcbiAgICAgID8gZihhWzBdLCBhWzFdLCBhWzJdKVxuICAgICAgOiBmKGEsIGIsIGMpXG4gICkubWFwKG4yYik7XG59XG5mdW5jdGlvbiBoc2wycmdiKGgsIHMsIGwpIHtcbiAgcmV0dXJuIGNhbGxuKGhzbDJyZ2JuLCBoLCBzLCBsKTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2IoaCwgdywgYikge1xuICByZXR1cm4gY2FsbG4oaHdiMnJnYm4sIGgsIHcsIGIpO1xufVxuZnVuY3Rpb24gaHN2MnJnYihoLCBzLCB2KSB7XG4gIHJldHVybiBjYWxsbihoc3YycmdibiwgaCwgcywgdik7XG59XG5mdW5jdGlvbiBodWUoaCkge1xuICByZXR1cm4gKGggJSAzNjAgKyAzNjApICUgMzYwO1xufVxuZnVuY3Rpb24gaHVlUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBIVUVfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHY7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs1XSAhPT0gdikge1xuICAgIGEgPSBtWzZdID8gcDJiKCttWzVdKSA6IG4yYigrbVs1XSk7XG4gIH1cbiAgY29uc3QgaCA9IGh1ZSgrbVsyXSk7XG4gIGNvbnN0IHAxID0gK21bM10gLyAxMDA7XG4gIGNvbnN0IHAyID0gK21bNF0gLyAxMDA7XG4gIGlmIChtWzFdID09PSAnaHdiJykge1xuICAgIHYgPSBod2IycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSBpZiAobVsxXSA9PT0gJ2hzdicpIHtcbiAgICB2ID0gaHN2MnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2Uge1xuICAgIHYgPSBoc2wycmdiKGgsIHAxLCBwMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByOiB2WzBdLFxuICAgIGc6IHZbMV0sXG4gICAgYjogdlsyXSxcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByb3RhdGUodiwgZGVnKSB7XG4gIHZhciBoID0gcmdiMmhzbCh2KTtcbiAgaFswXSA9IGh1ZShoWzBdICsgZGVnKTtcbiAgaCA9IGhzbDJyZ2IoaCk7XG4gIHYuciA9IGhbMF07XG4gIHYuZyA9IGhbMV07XG4gIHYuYiA9IGhbMl07XG59XG5mdW5jdGlvbiBoc2xTdHJpbmcodikge1xuICBpZiAoIXYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYSA9IHJnYjJoc2wodik7XG4gIGNvbnN0IGggPSBhWzBdO1xuICBjb25zdCBzID0gbjJwKGFbMV0pO1xuICBjb25zdCBsID0gbjJwKGFbMl0pO1xuICByZXR1cm4gdi5hIDwgMjU1XG4gICAgPyBgaHNsYSgke2h9LCAke3N9JSwgJHtsfSUsICR7YjJuKHYuYSl9KWBcbiAgICA6IGBoc2woJHtofSwgJHtzfSUsICR7bH0lKWA7XG59XG5jb25zdCBtYXAkMiA9IHtcbiAgeDogJ2RhcmsnLFxuICBaOiAnbGlnaHQnLFxuICBZOiAncmUnLFxuICBYOiAnYmx1JyxcbiAgVzogJ2dyJyxcbiAgVjogJ21lZGl1bScsXG4gIFU6ICdzbGF0ZScsXG4gIEE6ICdlZScsXG4gIFQ6ICdvbCcsXG4gIFM6ICdvcicsXG4gIEI6ICdyYScsXG4gIEM6ICdsYXRlZycsXG4gIEQ6ICdpZ2h0cycsXG4gIFI6ICdpbicsXG4gIFE6ICd0dXJxdW9pcycsXG4gIEU6ICdoaScsXG4gIFA6ICdybycsXG4gIE86ICdhbCcsXG4gIE46ICdsZScsXG4gIE06ICdkZScsXG4gIEw6ICd5ZWxsbycsXG4gIEY6ICdlbicsXG4gIEs6ICdjaCcsXG4gIEc6ICdhcmtzJyxcbiAgSDogJ2VhJyxcbiAgSTogJ2lnaHRnJyxcbiAgSjogJ3doJ1xufTtcbmNvbnN0IG5hbWVzJDEgPSB7XG4gIE9pY2VYZTogJ2YwZjhmZicsXG4gIGFudGlxdWV3RXRlOiAnZmFlYmQ3JyxcbiAgYXF1YTogJ2ZmZmYnLFxuICBhcXVhbWFyUmU6ICc3ZmZmZDQnLFxuICBhenVZOiAnZjBmZmZmJyxcbiAgYmVpZ2U6ICdmNWY1ZGMnLFxuICBiaXNxdWU6ICdmZmU0YzQnLFxuICBibGFjazogJzAnLFxuICBibGFuS2VkT21vbmQ6ICdmZmViY2QnLFxuICBYZTogJ2ZmJyxcbiAgWGV2aVRldDogJzhhMmJlMicsXG4gIGJQd246ICdhNTJhMmEnLFxuICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICBjYU10WGU6ICc1ZjllYTAnLFxuICBLYXJ0WXVzZTogJzdmZmYwMCcsXG4gIEtvY1RhdGU6ICdkMjY5MWUnLFxuICBjU086ICdmZjdmNTAnLFxuICBjU25mbG93ZXJYZTogJzY0OTVlZCcsXG4gIGNTbnNpbGs6ICdmZmY4ZGMnLFxuICBjcmltc29uOiAnZGMxNDNjJyxcbiAgY3lhbjogJ2ZmZmYnLFxuICB4WGU6ICc4YicsXG4gIHhjeWFuOiAnOGI4YicsXG4gIHhnVE1uUGQ6ICdiODg2MGInLFxuICB4V2F5OiAnYTlhOWE5JyxcbiAgeGdZRjogJzY0MDAnLFxuICB4Z1l5OiAnYTlhOWE5JyxcbiAgeGtoYWtpOiAnYmRiNzZiJyxcbiAgeG1hZ0Z0YTogJzhiMDA4YicsXG4gIHhUaXZlZ1lGOiAnNTU2YjJmJyxcbiAgeFNhbmdlOiAnZmY4YzAwJyxcbiAgeFNjRWQ6ICc5OTMyY2MnLFxuICB4WWQ6ICc4YjAwMDAnLFxuICB4c09tb246ICdlOTk2N2EnLFxuICB4c0hnWUY6ICc4ZmJjOGYnLFxuICB4VVhlOiAnNDgzZDhiJyxcbiAgeFVXYXk6ICcyZjRmNGYnLFxuICB4VWdZeTogJzJmNGY0ZicsXG4gIHhRZTogJ2NlZDEnLFxuICB4dmlUZXQ6ICc5NDAwZDMnLFxuICBkQXBwUms6ICdmZjE0OTMnLFxuICBkQXBza3lYZTogJ2JmZmYnLFxuICBkaW1XYXk6ICc2OTY5NjknLFxuICBkaW1nWXk6ICc2OTY5NjknLFxuICBkb2RnZXJYZTogJzFlOTBmZicsXG4gIGZpWWJyaWNrOiAnYjIyMjIyJyxcbiAgZmxTT3dFdGU6ICdmZmZhZjAnLFxuICBmb1lzdFdBbjogJzIyOGIyMicsXG4gIGZ1S3NpYTogJ2ZmMDBmZicsXG4gIGdhUnNiU286ICdkY2RjZGMnLFxuICBnaG9zdHdFdGU6ICdmOGY4ZmYnLFxuICBnVGQ6ICdmZmQ3MDAnLFxuICBnVE1uUGQ6ICdkYWE1MjAnLFxuICBXYXk6ICc4MDgwODAnLFxuICBnWUY6ICc4MDAwJyxcbiAgZ1lGTHc6ICdhZGZmMmYnLFxuICBnWXk6ICc4MDgwODAnLFxuICBob25leU13OiAnZjBmZmYwJyxcbiAgaG90cFJrOiAnZmY2OWI0JyxcbiAgUmRpYW5ZZDogJ2NkNWM1YycsXG4gIFJkaWdvOiAnNGIwMDgyJyxcbiAgaXZTeTogJ2ZmZmZmMCcsXG4gIGtoYWtpOiAnZjBlNjhjJyxcbiAgbGF2Rk1yOiAnZTZlNmZhJyxcbiAgbGF2Rk1yWHNoOiAnZmZmMGY1JyxcbiAgbGF3bmdZRjogJzdjZmMwMCcsXG4gIE5tb25jRWZmb246ICdmZmZhY2QnLFxuICBaWGU6ICdhZGQ4ZTYnLFxuICBaY1NPOiAnZjA4MDgwJyxcbiAgWmN5YW46ICdlMGZmZmYnLFxuICBaZ1RNblBkTHc6ICdmYWZhZDInLFxuICBaV2F5OiAnZDNkM2QzJyxcbiAgWmdZRjogJzkwZWU5MCcsXG4gIFpnWXk6ICdkM2QzZDMnLFxuICBacFJrOiAnZmZiNmMxJyxcbiAgWnNPbW9uOiAnZmZhMDdhJyxcbiAgWnNIZ1lGOiAnMjBiMmFhJyxcbiAgWnNreVhlOiAnODdjZWZhJyxcbiAgWlVXYXk6ICc3Nzg4OTknLFxuICBaVWdZeTogJzc3ODg5OScsXG4gIFpzdEFsWGU6ICdiMGM0ZGUnLFxuICBaTHc6ICdmZmZmZTAnLFxuICBsaW1lOiAnZmYwMCcsXG4gIGxpbWVnWUY6ICczMmNkMzInLFxuICBsUkY6ICdmYWYwZTYnLFxuICBtYWdGdGE6ICdmZjAwZmYnLFxuICBtYVBvbjogJzgwMDAwMCcsXG4gIFZhcXVhbWFyUmU6ICc2NmNkYWEnLFxuICBWWGU6ICdjZCcsXG4gIFZTY0VkOiAnYmE1NWQzJyxcbiAgVnB1cnBOOiAnOTM3MGRiJyxcbiAgVnNIZ1lGOiAnM2NiMzcxJyxcbiAgVlVYZTogJzdiNjhlZScsXG4gIFZzcHJSZ2dZRjogJ2ZhOWEnLFxuICBWUWU6ICc0OGQxY2MnLFxuICBWdmlUZXRZZDogJ2M3MTU4NScsXG4gIG1pZG5pZ2h0WGU6ICcxOTE5NzAnLFxuICBtUnRjWWFtOiAnZjVmZmZhJyxcbiAgbWlzdHlQc2U6ICdmZmU0ZTEnLFxuICBtb2NjYXNSOiAnZmZlNGI1JyxcbiAgbmF2YWpvd0V0ZTogJ2ZmZGVhZCcsXG4gIG5hdnk6ICc4MCcsXG4gIFRkbGFjZTogJ2ZkZjVlNicsXG4gIFRpdmU6ICc4MDgwMDAnLFxuICBUaXZlZEJiOiAnNmI4ZTIzJyxcbiAgU2FuZ2U6ICdmZmE1MDAnLFxuICBTYW5nZVlkOiAnZmY0NTAwJyxcbiAgU2NFZDogJ2RhNzBkNicsXG4gIHBPZWdUTW5QZDogJ2VlZThhYScsXG4gIHBPZWdZRjogJzk4ZmI5OCcsXG4gIHBPZVFlOiAnYWZlZWVlJyxcbiAgcE9ldmlUZXRZZDogJ2RiNzA5MycsXG4gIHBhcGF5YXdFcDogJ2ZmZWZkNScsXG4gIHBIS3B1ZmY6ICdmZmRhYjknLFxuICBwZXJ1OiAnY2Q4NTNmJyxcbiAgcFJrOiAnZmZjMGNiJyxcbiAgcGx1bTogJ2RkYTBkZCcsXG4gIHBvd01yWGU6ICdiMGUwZTYnLFxuICBwdXJwTjogJzgwMDA4MCcsXG4gIFliZWNjYXB1cnBOOiAnNjYzMzk5JyxcbiAgWWQ6ICdmZjAwMDAnLFxuICBQc3licm93bjogJ2JjOGY4ZicsXG4gIFB5T1hlOiAnNDE2OWUxJyxcbiAgc2FkZE5iUHduOiAnOGI0NTEzJyxcbiAgc09tb246ICdmYTgwNzInLFxuICBzYW5keWJQd246ICdmNGE0NjAnLFxuICBzSGdZRjogJzJlOGI1NycsXG4gIHNIc2hlbGw6ICdmZmY1ZWUnLFxuICBzaUZuYTogJ2EwNTIyZCcsXG4gIHNpbHZlcjogJ2MwYzBjMCcsXG4gIHNreVhlOiAnODdjZWViJyxcbiAgVVhlOiAnNmE1YWNkJyxcbiAgVVdheTogJzcwODA5MCcsXG4gIFVnWXk6ICc3MDgwOTAnLFxuICBzbm93OiAnZmZmYWZhJyxcbiAgc3ByUmdnWUY6ICdmZjdmJyxcbiAgc3RBbFhlOiAnNDY4MmI0JyxcbiAgdGFuOiAnZDJiNDhjJyxcbiAgdGVPOiAnODA4MCcsXG4gIHRFc3ROOiAnZDhiZmQ4JyxcbiAgdG9tYXRvOiAnZmY2MzQ3JyxcbiAgUWU6ICc0MGUwZDAnLFxuICB2aVRldDogJ2VlODJlZScsXG4gIEpIdDogJ2Y1ZGViMycsXG4gIHdFdGU6ICdmZmZmZmYnLFxuICB3RXRlc21va2U6ICdmNWY1ZjUnLFxuICBMdzogJ2ZmZmYwMCcsXG4gIEx3Z1lGOiAnOWFjZDMyJ1xufTtcbmZ1bmN0aW9uIHVucGFjaygpIHtcbiAgY29uc3QgdW5wYWNrZWQgPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG5hbWVzJDEpO1xuICBjb25zdCB0a2V5cyA9IE9iamVjdC5rZXlzKG1hcCQyKTtcbiAgbGV0IGksIGosIGssIG9rLCBuaztcbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBvayA9IG5rID0ga2V5c1tpXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgdGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGsgPSB0a2V5c1tqXTtcbiAgICAgIG5rID0gbmsucmVwbGFjZShrLCBtYXAkMltrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cbmxldCBuYW1lcztcbmZ1bmN0aW9uIG5hbWVQYXJzZShzdHIpIHtcbiAgaWYgKCFuYW1lcykge1xuICAgIG5hbWVzID0gdW5wYWNrKCk7XG4gICAgbmFtZXMudHJhbnNwYXJlbnQgPSBbMCwgMCwgMCwgMF07XG4gIH1cbiAgY29uc3QgYSA9IG5hbWVzW3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIGEgJiYge1xuICAgIHI6IGFbMF0sXG4gICAgZzogYVsxXSxcbiAgICBiOiBhWzJdLFxuICAgIGE6IGEubGVuZ3RoID09PSA0ID8gYVszXSA6IDI1NVxuICB9O1xufVxuY29uc3QgUkdCX1JFID0gL15yZ2JhP1xcKFxccyooWy0rLlxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/KD86W1xccywvXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiByZ2JQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IFJHQl9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgciwgZywgYjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzddICE9PSByKSB7XG4gICAgY29uc3QgdiA9ICttWzddO1xuICAgIGEgPSBtWzhdID8gcDJiKHYpIDogbGltKHYgKiAyNTUsIDAsIDI1NSk7XG4gIH1cbiAgciA9ICttWzFdO1xuICBnID0gK21bM107XG4gIGIgPSArbVs1XTtcbiAgciA9IDI1NSAmIChtWzJdID8gcDJiKHIpIDogbGltKHIsIDAsIDI1NSkpO1xuICBnID0gMjU1ICYgKG1bNF0gPyBwMmIoZykgOiBsaW0oZywgMCwgMjU1KSk7XG4gIGIgPSAyNTUgJiAobVs2XSA/IHAyYihiKSA6IGxpbShiLCAwLCAyNTUpKTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByZ2JTdHJpbmcodikge1xuICByZXR1cm4gdiAmJiAoXG4gICAgdi5hIDwgMjU1XG4gICAgICA/IGByZ2JhKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0sICR7YjJuKHYuYSl9KWBcbiAgICAgIDogYHJnYigke3Yucn0sICR7di5nfSwgJHt2LmJ9KWBcbiAgKTtcbn1cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlJDEocmdiMSwgcmdiMiwgdCkge1xuICBjb25zdCByID0gZnJvbShiMm4ocmdiMS5yKSk7XG4gIGNvbnN0IGcgPSBmcm9tKGIybihyZ2IxLmcpKTtcbiAgY29uc3QgYiA9IGZyb20oYjJuKHJnYjEuYikpO1xuICByZXR1cm4ge1xuICAgIHI6IG4yYih0byhyICsgdCAqIChmcm9tKGIybihyZ2IyLnIpKSAtIHIpKSksXG4gICAgZzogbjJiKHRvKGcgKyB0ICogKGZyb20oYjJuKHJnYjIuZykpIC0gZykpKSxcbiAgICBiOiBuMmIodG8oYiArIHQgKiAoZnJvbShiMm4ocmdiMi5iKSkgLSBiKSkpLFxuICAgIGE6IHJnYjEuYSArIHQgKiAocmdiMi5hIC0gcmdiMS5hKVxuICB9O1xufVxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG4gIGlmICh2KSB7XG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XG4gICAgdG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG4gICAgdG1wID0gaHNsMnJnYih0bXApO1xuICAgIHYuciA9IHRtcFswXTtcbiAgICB2LmcgPSB0bXBbMV07XG4gICAgdi5iID0gdG1wWzJdO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuICByZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcbiAgdmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICB2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG4gICAgdi5hID0gbjJiKHYuYSk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XG4gIH1cbiAgcmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICBsZXQgdjtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRoaXMuX3JnYiA9IHY7XG4gICAgdGhpcy5fdmFsaWQgPSAhIXY7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcbiAgICBpZiAodikge1xuICAgICAgdi5hID0gYjJuKHYuYSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHNldCByZ2Iob2JqKSB7XG4gICAgdGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuICB9XG4gIHJnYlN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCBjMSA9IHRoaXMucmdiO1xuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XG4gICAgICBsZXQgdzI7XG4gICAgICBjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XG4gICAgICBjb25zdCBhID0gYzEuYSAtIGMyLmE7XG4gICAgICBjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgIHcyID0gMSAtIHcxO1xuICAgICAgYzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG4gICAgICBjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuICAgICAgYzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG4gICAgICB0aGlzLnJnYiA9IGMxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5fcmdiID0gaW50ZXJwb2xhdGUkMSh0aGlzLl9yZ2IsIGNvbG9yLl9yZ2IsIHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMucmdiKTtcbiAgfVxuICBhbHBoYShhKSB7XG4gICAgdGhpcy5fcmdiLmEgPSBuMmIoYSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXJlcihyYXRpbykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZ2IuYSAqPSAxIC0gcmF0aW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ3JleXNjYWxlKCkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICBjb25zdCB2YWwgPSByb3VuZChyZ2IuciAqIDAuMyArIHJnYi5nICogMC41OSArIHJnYi5iICogMC4xMSk7XG4gICAgcmdiLnIgPSByZ2IuZyA9IHJnYi5iID0gdmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9wYXF1ZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSArIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5lZ2F0ZSgpIHtcbiAgICBjb25zdCB2ID0gdGhpcy5fcmdiO1xuICAgIHYuciA9IDI1NSAtIHYucjtcbiAgICB2LmcgPSAyNTUgLSB2Lmc7XG4gICAgdi5iID0gMjU1IC0gdi5iO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpZ2h0ZW4ocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAyLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGFya2VuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgLXJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIHJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXNhdHVyYXRlKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMSwgLXJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByb3RhdGUoZGVnKSB7XG4gICAgcm90YXRlKHRoaXMuX3JnYiwgZGVnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XG4gIHJldHVybiBuZXcgQ29sb3IoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgdHlwZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJyB8fCB0eXBlID09PSAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSA/IHZhbHVlIDogaW5kZXhfZXNtKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpXG4gICAgPyB2YWx1ZVxuICAgIDogaW5kZXhfZXNtKHZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLmhleFN0cmluZygpO1xufVxuXG5jb25zdCBvdmVycmlkZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gZ2V0U2NvcGUkMShub2RlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gc2V0KHJvb3QsIHNjb3BlLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCBzY29wZSksIHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlKGdldFNjb3BlJDEocm9vdCwgJycpLCBzY29wZSk7XG59XG5jbGFzcyBEZWZhdWx0cyB7XG4gIGNvbnN0cnVjdG9yKF9kZXNjcmlwdG9ycykge1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuY29sb3IgPSAnIzY2Nic7XG4gICAgdGhpcy5kYXRhc2V0cyA9IHt9O1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KSA9PiBjb250ZXh0LmNoYXJ0LnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICdtb3VzZW91dCcsXG4gICAgICAnY2xpY2snLFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgJ3RvdWNobW92ZSdcbiAgICBdO1xuICAgIHRoaXMuZm9udCA9IHtcbiAgICAgIGZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuICAgICAgc2l6ZTogMTIsXG4gICAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICB3ZWlnaHQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaG92ZXIgPSB7fTtcbiAgICB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKTtcbiAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuY29sb3IpO1xuICAgIHRoaXMuaW5kZXhBeGlzID0gJ3gnO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdHJ1ZTtcbiAgICB0aGlzLmRlc2NyaWJlKF9kZXNjcmlwdG9ycyk7XG4gIH1cbiAgc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KHRoaXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcbiAgfVxuICBkZXNjcmliZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChkZXNjcmlwdG9ycywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQob3ZlcnJpZGVzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUkMSh0aGlzLCB0YXJnZXRTY29wZSk7XG4gICAgY29uc3QgcHJpdmF0ZU5hbWUgPSAnXycgKyBuYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxudmFyIGRlZmF1bHRzID0gbmV3IERlZmF1bHRzKHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2V2ZW50cycsXG4gIGhvdmVyOiB7XG4gICAgX2ZhbGxiYWNrOiAnaW50ZXJhY3Rpb24nXG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9XG59KTtcblxuZnVuY3Rpb24gX2lzRG9tU3VwcG9ydGVkKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIF9nZXRQYXJlbnROb2RlKGRvbU5vZGUpIHtcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudDtcbn1cbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcbiAgbGV0IHZhbHVlSW5QaXhlbHM7XG4gIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xuICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIHZhbHVlSW5QaXhlbHMgPSB2YWx1ZUluUGl4ZWxzIC8gMTAwICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQpID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHByb3BlcnR5KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cbmNvbnN0IHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5mdW5jdGlvbiBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGVzLCBzdHlsZSwgc3VmZml4KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gIH1cbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHVzZU9mZnNldFBvcyA9ICh4LCB5LCB0YXJnZXQpID0+ICh4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgIXRhcmdldC5zaGFkb3dSb290KTtcbmZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKGUsIGNhbnZhcykge1xuICBjb25zdCB0b3VjaGVzID0gZS50b3VjaGVzO1xuICBjb25zdCBzb3VyY2UgPSB0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoID8gdG91Y2hlc1swXSA6IGU7XG4gIGNvbnN0IHtvZmZzZXRYLCBvZmZzZXRZfSA9IHNvdXJjZTtcbiAgbGV0IGJveCA9IGZhbHNlO1xuICBsZXQgeCwgeTtcbiAgaWYgKHVzZU9mZnNldFBvcyhvZmZzZXRYLCBvZmZzZXRZLCBlLnRhcmdldCkpIHtcbiAgICB4ID0gb2Zmc2V0WDtcbiAgICB5ID0gb2Zmc2V0WTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHggPSBzb3VyY2UuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICB5ID0gc291cmNlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICBib3ggPSB0cnVlO1xuICB9XG4gIHJldHVybiB7eCwgeSwgYm94fTtcbn1cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oZXZ0LCBjaGFydCkge1xuICBpZiAoJ25hdGl2ZScgaW4gZXZ0KSB7XG4gICAgcmV0dXJuIGV2dDtcbiAgfVxuICBjb25zdCB7Y2FudmFzLCBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpb30gPSBjaGFydDtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IGJvcmRlckJveCA9IHN0eWxlLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnO1xuICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICBjb25zdCB7eCwgeSwgYm94fSA9IGdldENhbnZhc1Bvc2l0aW9uKGV2dCwgY2FudmFzKTtcbiAgY29uc3QgeE9mZnNldCA9IHBhZGRpbmdzLmxlZnQgKyAoYm94ICYmIGJvcmRlcnMubGVmdCk7XG4gIGNvbnN0IHlPZmZzZXQgPSBwYWRkaW5ncy50b3AgKyAoYm94ICYmIGJvcmRlcnMudG9wKTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNoYXJ0O1xuICBpZiAoYm9yZGVyQm94KSB7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoKHggLSB4T2Zmc2V0KSAvIHdpZHRoICogY2FudmFzLndpZHRoIC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pLFxuICAgIHk6IE1hdGgucm91bmQoKHkgLSB5T2Zmc2V0KSAvIGhlaWdodCAqIGNhbnZhcy5oZWlnaHQgLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbylcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5lclNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGxldCBtYXhXaWR0aCwgbWF4SGVpZ2h0O1xuICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgY29uc3QgY29udGFpbmVyQm9yZGVyID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgICBjb25zdCBjb250YWluZXJQYWRkaW5nID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAncGFkZGluZycpO1xuICAgICAgd2lkdGggPSByZWN0LndpZHRoIC0gY29udGFpbmVyUGFkZGluZy53aWR0aCAtIGNvbnRhaW5lckJvcmRlci53aWR0aDtcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gY29udGFpbmVyUGFkZGluZy5oZWlnaHQgLSBjb250YWluZXJCb3JkZXIuaGVpZ2h0O1xuICAgICAgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heFdpZHRoLCBjb250YWluZXIsICdjbGllbnRXaWR0aCcpO1xuICAgICAgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhIZWlnaHQsIGNvbnRhaW5lciwgJ2NsaWVudEhlaWdodCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBtYXhXaWR0aDogbWF4V2lkdGggfHwgSU5GSU5JVFksXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfHwgSU5GSU5JVFlcbiAgfTtcbn1cbmNvbnN0IHJvdW5kMSA9IHYgPT4gTWF0aC5yb3VuZCh2ICogMTApIC8gMTA7XG5mdW5jdGlvbiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgbWFyZ2lucyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ21hcmdpbicpO1xuICBjb25zdCBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4V2lkdGgsIGNhbnZhcywgJ2NsaWVudFdpZHRoJykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4SGVpZ2h0LCBjYW52YXMsICdjbGllbnRIZWlnaHQnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGdldENvbnRhaW5lclNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjb250YWluZXJTaXplO1xuICBpZiAoc3R5bGUuYm94U2l6aW5nID09PSAnY29udGVudC1ib3gnKSB7XG4gICAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCAtIG1hcmdpbnMud2lkdGgpO1xuICBoZWlnaHQgPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQgLSBtYXJnaW5zLmhlaWdodCk7XG4gIHdpZHRoID0gcm91bmQxKE1hdGgubWluKHdpZHRoLCBtYXhXaWR0aCwgY29udGFpbmVyU2l6ZS5tYXhXaWR0aCkpO1xuICBoZWlnaHQgPSByb3VuZDEoTWF0aC5taW4oaGVpZ2h0LCBtYXhIZWlnaHQsIGNvbnRhaW5lclNpemUubWF4SGVpZ2h0KSk7XG4gIGlmICh3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgaGVpZ2h0ID0gcm91bmQxKHdpZHRoIC8gMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIHJldGluYVNjYWxlKGNoYXJ0LCBmb3JjZVJhdGlvLCBmb3JjZVN0eWxlKSB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8IDE7XG4gIGNvbnN0IGRldmljZUhlaWdodCA9IE1hdGguZmxvb3IoY2hhcnQuaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVdpZHRoID0gTWF0aC5mbG9vcihjaGFydC53aWR0aCAqIHBpeGVsUmF0aW8pO1xuICBjaGFydC5oZWlnaHQgPSBkZXZpY2VIZWlnaHQgLyBwaXhlbFJhdGlvO1xuICBjaGFydC53aWR0aCA9IGRldmljZVdpZHRoIC8gcGl4ZWxSYXRpbztcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBpZiAoY2FudmFzLnN0eWxlICYmIChmb3JjZVN0eWxlIHx8ICghY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSkpIHtcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7Y2hhcnQuaGVpZ2h0fXB4YDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjaGFydC53aWR0aH1weGA7XG4gIH1cbiAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBwaXhlbFJhdGlvXG4gICAgICB8fCBjYW52YXMuaGVpZ2h0ICE9PSBkZXZpY2VIZWlnaHRcbiAgICAgIHx8IGNhbnZhcy53aWR0aCAhPT0gZGV2aWNlV2lkdGgpIHtcbiAgICBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGRldmljZUhlaWdodDtcbiAgICBjYW52YXMud2lkdGggPSBkZXZpY2VXaWR0aDtcbiAgICBjaGFydC5jdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59KCkpO1xuZnVuY3Rpb24gcmVhZFVzZWRTaXplKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuICBjb25zdCBtYXRjaGVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG4gIHJldHVybiBtYXRjaGVzID8gK21hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XG4gIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gKGZvbnQuc3R5bGUgPyBmb250LnN0eWxlICsgJyAnIDogJycpXG5cdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcblx0XHQrIGZvbnQuZmFtaWx5O1xufVxuZnVuY3Rpb24gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuICBsZXQgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddO1xuICBpZiAoIXRleHRXaWR0aCkge1xuICAgIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuICAgIGdjLnB1c2goc3RyaW5nKTtcbiAgfVxuICBpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuICAgIGxvbmdlc3QgPSB0ZXh0V2lkdGg7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5mdW5jdGlvbiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LCBhcnJheU9mVGhpbmdzLCBjYWNoZSkge1xuICBjYWNoZSA9IGNhY2hlIHx8IHt9O1xuICBsZXQgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuICBsZXQgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0IHx8IFtdO1xuICBpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuICAgIGRhdGEgPSBjYWNoZS5kYXRhID0ge307XG4gICAgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuICAgIGNhY2hlLmZvbnQgPSBmb250O1xuICB9XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udDtcbiAgbGV0IGxvbmdlc3QgPSAwO1xuICBjb25zdCBpbGVuID0gYXJyYXlPZlRoaW5ncy5sZW5ndGg7XG4gIGxldCBpLCBqLCBqbGVuLCB0aGluZywgbmVzdGVkVGhpbmc7XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XG4gICAgaWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaXNBcnJheSh0aGluZykgIT09IHRydWUpIHtcbiAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgaWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG4gICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbiAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICBpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgaSsrKSB7XG4gICAgICBkZWxldGUgZGF0YVtnY1tpXV07XG4gICAgfVxuICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5mdW5jdGlvbiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIHdpZHRoKSB7XG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAvIDIsIDAuNSkgOiAwO1xuICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xufVxuZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpIHtcbiAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHguc2F2ZSgpO1xuICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgeCwgeSkge1xuICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCBudWxsKTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludExlZ2VuZChjdHgsIG9wdGlvbnMsIHgsIHksIHcpIHtcbiAgbGV0IHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIGNvcm5lclJhZGl1cywgd2lkdGg7XG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5wb2ludFN0eWxlO1xuICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG4gIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5yb3RhdGUocmFkKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgc3dpdGNoIChzdHlsZSkge1xuICBkZWZhdWx0OlxuICAgIGlmICh3KSB7XG4gICAgICBjdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgcmFkaXVzLCAwLCAwLCBUQVUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgVEFVKTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0cmlhbmdsZSc6XG4gICAgY3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZWN0Um91bmRlZCc6XG4gICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG4gICAgc2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgY3R4LmFyYyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuICAgIGN0eC5hcmMoeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG4gICAgY3R4LmFyYyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcbiAgICBjdHguYXJjKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZWN0JzpcbiAgICBpZiAoIXJvdGF0aW9uKSB7XG4gICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuICAgICAgd2lkdGggPSB3ID8gdyAvIDIgOiBzaXplO1xuICAgICAgY3R4LnJlY3QoeCAtIHdpZHRoLCB5IC0gc2l6ZSwgMiAqIHdpZHRoLCAyICogc2l6ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gIGNhc2UgJ3JlY3RSb3QnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Nyb3NzUm90JzpcbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgY2FzZSAnY3Jvc3MnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnc3Rhcic6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnbGluZSc6XG4gICAgeE9mZnNldCA9IHcgPyB3IC8gMiA6IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnZGFzaCc6XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgYnJlYWs7XG4gIH1cbiAgY3R4LmZpbGwoKTtcbiAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBfaXNQb2ludEluQXJlYShwb2ludCwgYXJlYSwgbWFyZ2luKSB7XG4gIG1hcmdpbiA9IG1hcmdpbiB8fCAwLjU7XG4gIHJldHVybiAhYXJlYSB8fCAocG9pbnQgJiYgcG9pbnQueCA+IGFyZWEubGVmdCAtIG1hcmdpbiAmJiBwb2ludC54IDwgYXJlYS5yaWdodCArIG1hcmdpbiAmJlxuXHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIG1hcmdpbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBtYXJnaW4pO1xufVxuZnVuY3Rpb24gY2xpcEFyZWEoY3R4LCBhcmVhKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB1bmNsaXBBcmVhKGN0eCkge1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRMaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwLCBtb2RlKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGlmIChtb2RlID09PSAnbWlkZGxlJykge1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgcHJldmlvdXMueSk7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgdGFyZ2V0LnkpO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhZnRlcicgIT09ICEhZmxpcCkge1xuICAgIGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJDdXJ2ZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeCA6IHByZXZpb3VzLmNwMngsXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXkgOiBwcmV2aW91cy5jcDJ5LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeCA6IHRhcmdldC5jcDF4LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeSA6IHRhcmdldC5jcDF5LFxuICAgIHRhcmdldC54LFxuICAgIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIHJlbmRlclRleHQoY3R4LCB0ZXh0LCB4LCB5LCBmb250LCBvcHRzID0ge30pIHtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KHRleHQpID8gdGV4dCA6IFt0ZXh0XTtcbiAgY29uc3Qgc3Ryb2tlID0gb3B0cy5zdHJva2VXaWR0aCA+IDAgJiYgb3B0cy5zdHJva2VDb2xvciAhPT0gJyc7XG4gIGxldCBpLCBsaW5lO1xuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuICBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cyk7XG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgfVxuICAgIGN0eC5maWxsVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKTtcbiAgICB5ICs9IGZvbnQubGluZUhlaWdodDtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpIHtcbiAgaWYgKG9wdHMudHJhbnNsYXRpb24pIHtcbiAgICBjdHgudHJhbnNsYXRlKG9wdHMudHJhbnNsYXRpb25bMF0sIG9wdHMudHJhbnNsYXRpb25bMV0pO1xuICB9XG4gIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xuICAgIGN0eC5yb3RhdGUob3B0cy5yb3RhdGlvbik7XG4gIH1cbiAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgfVxuICBpZiAob3B0cy50ZXh0QWxpZ24pIHtcbiAgICBjdHgudGV4dEFsaWduID0gb3B0cy50ZXh0QWxpZ247XG4gIH1cbiAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdHMudGV4dEJhc2VsaW5lO1xuICB9XG59XG5mdW5jdGlvbiBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKSB7XG4gIGlmIChvcHRzLnN0cmlrZXRocm91Z2ggfHwgb3B0cy51bmRlcmxpbmUpIHtcbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIGNvbnN0IGxlZnQgPSB4IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xuICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICBjb25zdCB5RGVjb3JhdGlvbiA9IG9wdHMuc3RyaWtldGhyb3VnaCA/ICh0b3AgKyBib3R0b20pIC8gMiA6IGJvdHRvbTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0cy5kZWNvcmF0aW9uV2lkdGggfHwgMjtcbiAgICBjdHgubW92ZVRvKGxlZnQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHgubGluZVRvKHJpZ2h0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGNvbnN0IHt4LCB5LCB3LCBoLCByYWRpdXN9ID0gcmVjdDtcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLnRvcExlZnQsIHkgKyByYWRpdXMudG9wTGVmdCwgcmFkaXVzLnRvcExlZnQsIC1IQUxGX1BJLCBQSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCk7XG4gIGN0eC5hcmMoeCArIHJhZGl1cy5ib3R0b21MZWZ0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0LCByYWRpdXMuYm90dG9tTGVmdCwgUEksIEhBTEZfUEksIHRydWUpO1xuICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCk7XG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCByYWRpdXMuYm90dG9tUmlnaHQsIEhBTEZfUEksIDAsIHRydWUpO1xuICBjdHgubGluZVRvKHggKyB3LCB5ICsgcmFkaXVzLnRvcFJpZ2h0KTtcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy50b3BSaWdodCwgeSArIHJhZGl1cy50b3BSaWdodCwgcmFkaXVzLnRvcFJpZ2h0LCAwLCAtSEFMRl9QSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cy50b3BMZWZ0LCB5KTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMgPSBbJyddLCByb290U2NvcGVzID0gc2NvcGVzLCBmYWxsYmFjaywgZ2V0VGFyZ2V0ID0gKCkgPT4gc2NvcGVzWzBdKSB7XG4gIGlmICghZGVmaW5lZChmYWxsYmFjaykpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3Blczogcm9vdFNjb3BlcyxcbiAgICBfZmFsbGJhY2s6IGZhbGxiYWNrLFxuICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfY3JlYXRlUmVzb2x2ZXIoW3Njb3BlLCAuLi5zY29wZXNdLCBwcmVmaXhlcywgcm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcbiAgICAgIGRlbGV0ZSBzY29wZXNbMF1bcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0Ll9zY29wZXNbMF0sIHByb3ApO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkuaW5jbHVkZXMocHJvcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc3RvcmFnZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBfYXR0YWNoQ29udGV4dChwcm94eSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICBjb25zdCBjYWNoZSA9IHtcbiAgICBfY2FjaGVhYmxlOiBmYWxzZSxcbiAgICBfcHJveHk6IHByb3h5LFxuICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgIF9zdWJQcm94eTogc3ViUHJveHksXG4gICAgX3N0YWNrOiBuZXcgU2V0KCksXG4gICAgX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMocHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgc2V0Q29udGV4dDogKGN0eCkgPT4gX2F0dGFjaENvbnRleHQocHJveHksIGN0eCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgb3ZlcnJpZGU6IChzY29wZSkgPT4gX2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgZGVsZXRlIHByb3h5W3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0YXJnZXQuX2Rlc2NyaXB0b3JzLmFsbEtleXNcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxuICAgICAgICA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YocHJveHkpO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuICAgIG93bktleXMoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHByb3h5KTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm94eVtwcm9wXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBfZGVzY3JpcHRvcnMocHJveHksIGRlZmF1bHRzID0ge3NjcmlwdGFibGU6IHRydWUsIGluZGV4YWJsZTogdHJ1ZX0pIHtcbiAgY29uc3Qge19zY3JpcHRhYmxlID0gZGVmYXVsdHMuc2NyaXB0YWJsZSwgX2luZGV4YWJsZSA9IGRlZmF1bHRzLmluZGV4YWJsZSwgX2FsbEtleXMgPSBkZWZhdWx0cy5hbGxLZXlzfSA9IHByb3h5O1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcbiAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKSA9PiBfc2NyaXB0YWJsZSxcbiAgICBpc0luZGV4YWJsZTogaXNGdW5jdGlvbihfaW5kZXhhYmxlKSA/IF9pbmRleGFibGUgOiAoKSA9PiBfaW5kZXhhYmxlXG4gIH07XG59XG5jb25zdCByZWFkS2V5ID0gKHByZWZpeCwgbmFtZSkgPT4gcHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wLCB2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIHByb3AgIT09ICdhZGFwdGVycycgJiZcbiAgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG5mdW5jdGlvbiBfY2FjaGVkKHRhcmdldCwgcHJvcCwgcmVzb2x2ZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgdmFsdWUgPSBfYXR0YWNoQ29udGV4dCh2YWx1ZSwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIHZhbHVlID0gdmFsdWUoX2NvbnRleHQsIF9zdWJQcm94eSB8fCByZWNlaXZlcik7XG4gIF9zdGFjay5kZWxldGUocHJvcCk7XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgaXNJbmRleGFibGUpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9yc30gPSB0YXJnZXQ7XG4gIGlmIChkZWZpbmVkKF9jb250ZXh0LmluZGV4KSAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xuICAgIHZhbHVlID0gdmFsdWVbX2NvbnRleHQuaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlWzBdKSkge1xuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgIGNvbnN0IHNjb3BlcyA9IF9wcm94eS5fc2NvcGVzLmZpbHRlcihzID0+IHMgIT09IGFycik7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgX3Byb3h5LCBwcm9wLCBpdGVtKTtcbiAgICAgIHZhbHVlLnB1c2goX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZXNvbHZlRmFsbGJhY2soZmFsbGJhY2ssIHByb3AsIHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKGZhbGxiYWNrKSA/IGZhbGxiYWNrKHByb3AsIHZhbHVlKSA6IGZhbGxiYWNrO1xufVxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5LCBwYXJlbnQpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBhZGRTY29wZXMoc2V0LCBwYXJlbnRTY29wZXMsIGtleSwgcGFyZW50RmFsbGJhY2ssIHZhbHVlKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjb3BlID09PSBmYWxzZSAmJiBkZWZpbmVkKHBhcmVudEZhbGxiYWNrKSAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIocGFyZW50U2NvcGVzLCByZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3Qgcm9vdFNjb3BlcyA9IHJlc29sdmVyLl9yb290U2NvcGVzO1xuICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIGxldCBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBwcm9wLCBmYWxsYmFjayB8fCBwcm9wLCB2YWx1ZSk7XG4gIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pIHtcbiAgd2hpbGUgKGtleSkge1xuICAgIGtleSA9IGFkZFNjb3BlcyhzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaywgaXRlbSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuX2dldFRhcmdldCgpO1xuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcbiAgICBwYXJlbnRbcHJvcF0gPSB7fTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCBwcm94eSkge1xuICBsZXQgdmFsdWU7XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSlcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9yZXNvbHZlKGtleSwgc2NvcGVzKSB7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gc2NvcGVba2V5XTtcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkge1xuICBsZXQga2V5cyA9IHRhcmdldC5fa2V5cztcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IHRhcmdldC5fa2V5cyA9IHJlc29sdmVLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQuX3Njb3Blcyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiByZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMoc2NvcGVzKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY29wZSkuZmlsdGVyKGsgPT4gIWsuc3RhcnRzV2l0aCgnXycpKSkge1xuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuZnVuY3Rpb24gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHtrZXkgPSAncid9ID0gdGhpcy5fcGFyc2luZztcbiAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgcGFyc2VkW2ldID0ge1xuICAgICAgcjogaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwga2V5KSwgaW5kZXgpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuXG5jb25zdCBFUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XG5jb25zdCBnZXRQb2ludCA9IChwb2ludHMsIGkpID0+IGkgPCBwb2ludHMubGVuZ3RoICYmICFwb2ludHNbaV0uc2tpcCAmJiBwb2ludHNbaV07XG5jb25zdCBnZXRWYWx1ZUF4aXMgPSAoaW5kZXhBeGlzKSA9PiBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbmZ1bmN0aW9uIHNwbGluZUN1cnZlKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG4gIGNvbnN0IHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xuICBjb25zdCBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG4gIGNvbnN0IG5leHQgPSBhZnRlclBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGFmdGVyUG9pbnQ7XG4gIGNvbnN0IGQwMSA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhjdXJyZW50LCBwcmV2aW91cyk7XG4gIGNvbnN0IGQxMiA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhuZXh0LCBjdXJyZW50KTtcbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG4gIHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xuICBzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcbiAgY29uc3QgZmEgPSB0ICogczAxO1xuICBjb25zdCBmYiA9IHQgKiBzMTI7XG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspIHtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGFscGhhSywgYmV0YUssIHRhdUssIHNxdWFyZWRNYWduaXR1ZGUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYWxwaGFLID0gbUtbaV0gLyBkZWx0YUtbaV07XG4gICAgYmV0YUsgPSBtS1tpICsgMV0gLyBkZWx0YUtbaV07XG4gICAgc3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XG4gICAgaWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBkZWx0YSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpUGl4ZWwgPSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICBjb25zdCB2UGl4ZWwgPSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXTtcbiAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgZGVsdGEgPSAocG9pbnRBZnRlcltpbmRleEF4aXNdIC0gaVBpeGVsKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7aW5kZXhBeGlzfWBdID0gaVBpeGVsICsgZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7dmFsdWVBeGlzfWBdID0gdlBpeGVsICsgZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IGRlbHRhSyA9IEFycmF5KHBvaW50c0xlbikuZmlsbCgwKTtcbiAgY29uc3QgbUsgPSBBcnJheShwb2ludHNMZW4pO1xuICBsZXQgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBjb25zdCBzbG9wZURlbHRhID0gcG9pbnRBZnRlcltpbmRleEF4aXNdIC0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgIH1cbiAgICBtS1tpXSA9ICFwb2ludEJlZm9yZSA/IGRlbHRhS1tpXVxuICAgICAgOiAhcG9pbnRBZnRlciA/IGRlbHRhS1tpIC0gMV1cbiAgICAgIDogKHNpZ24oZGVsdGFLW2kgLSAxXSkgIT09IHNpZ24oZGVsdGFLW2ldKSkgPyAwXG4gICAgICA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gIH1cbiAgbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKTtcbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcbn1cbmZ1bmN0aW9uIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhwb2ludHMsIG9wdGlvbnMsIGFyZWEsIGxvb3AsIGluZGV4QXhpcykge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGNvbnRyb2xQb2ludHM7XG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuICBpZiAob3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByZXYgPSBsb29wID8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA6IHBvaW50c1swXTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb250cm9sUG9pbnRzID0gc3BsaW5lQ3VydmUoXG4gICAgICAgIHByZXYsXG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSxcbiAgICAgICAgb3B0aW9ucy50ZW5zaW9uXG4gICAgICApO1xuICAgICAgcG9pbnQuY3AxeCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcbiAgICAgIHBvaW50LmNwMXkgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG4gICAgICBwb2ludC5jcDJ4ID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG4gICAgICBwb2ludC5jcDJ5ID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG4gICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmNhcEJlemllclBvaW50cykge1xuICAgIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpO1xuICB9XG59XG5cbmNvbnN0IGF0RWRnZSA9ICh0KSA9PiB0ID09PSAwIHx8IHQgPT09IDE7XG5jb25zdCBlbGFzdGljSW4gPSAodCwgcywgcCkgPT4gLShNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSk7XG5jb25zdCBlbGFzdGljT3V0ID0gKHQsIHMsIHApID0+IE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApICsgMTtcbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogdCA9PiB0LFxuICBlYXNlSW5RdWFkOiB0ID0+IHQgKiB0LFxuICBlYXNlT3V0UXVhZDogdCA9PiAtdCAqICh0IC0gMiksXG4gIGVhc2VJbk91dFF1YWQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSksXG4gIGVhc2VJbkN1YmljOiB0ID0+IHQgKiB0ICogdCxcbiAgZWFzZU91dEN1YmljOiB0ID0+ICh0IC09IDEpICogdCAqIHQgKyAxLFxuICBlYXNlSW5PdXRDdWJpYzogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMiksXG4gIGVhc2VJblF1YXJ0OiB0ID0+IHQgKiB0ICogdCAqIHQsXG4gIGVhc2VPdXRRdWFydDogdCA9PiAtKCh0IC09IDEpICogdCAqIHQgKiB0IC0gMSksXG4gIGVhc2VJbk91dFF1YXJ0OiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSxcbiAgZWFzZUluUXVpbnQ6IHQgPT4gdCAqIHQgKiB0ICogdCAqIHQsXG4gIGVhc2VPdXRRdWludDogdCA9PiAodCAtPSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxLFxuICBlYXNlSW5PdXRRdWludDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpLFxuICBlYXNlSW5TaW5lOiB0ID0+IC1NYXRoLmNvcyh0ICogSEFMRl9QSSkgKyAxLFxuICBlYXNlT3V0U2luZTogdCA9PiBNYXRoLnNpbih0ICogSEFMRl9QSSksXG4gIGVhc2VJbk91dFNpbmU6IHQgPT4gLTAuNSAqIChNYXRoLmNvcyhQSSAqIHQpIC0gMSksXG4gIGVhc2VJbkV4cG86IHQgPT4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSksXG4gIGVhc2VPdXRFeHBvOiB0ID0+ICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxLFxuICBlYXNlSW5PdXRFeHBvOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiB0IDwgMC41XG4gICAgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0ICogMiAtIDEpKVxuICAgIDogMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAodCAqIDIgLSAxKSkgKyAyKSxcbiAgZWFzZUluQ2lyYzogdCA9PiAodCA+PSAxKSA/IHQgOiAtKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSksXG4gIGVhc2VPdXRDaXJjOiB0ID0+IE1hdGguc3FydCgxIC0gKHQgLT0gMSkgKiB0KSxcbiAgZWFzZUluT3V0Q2lyYzogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSlcbiAgICA6IDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSxcbiAgZWFzZUluRWxhc3RpYzogdCA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY0luKHQsIDAuMDc1LCAwLjMpLFxuICBlYXNlT3V0RWxhc3RpYzogdCA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY091dCh0LCAwLjA3NSwgMC4zKSxcbiAgZWFzZUluT3V0RWxhc3RpYyh0KSB7XG4gICAgY29uc3QgcyA9IDAuMTEyNTtcbiAgICBjb25zdCBwID0gMC40NTtcbiAgICByZXR1cm4gYXRFZGdlKHQpID8gdCA6XG4gICAgICB0IDwgMC41XG4gICAgICAgID8gMC41ICogZWxhc3RpY0luKHQgKiAyLCBzLCBwKVxuICAgICAgICA6IDAuNSArIDAuNSAqIGVsYXN0aWNPdXQodCAqIDIgLSAxLCBzLCBwKTtcbiAgfSxcbiAgZWFzZUluQmFjayh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG4gIGVhc2VPdXRCYWNrKHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gKHQgLT0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuICB9LFxuICBlYXNlSW5PdXRCYWNrKHQpIHtcbiAgICBsZXQgcyA9IDEuNzAxNTg7XG4gICAgaWYgKCh0IC89IDAuNSkgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcbiAgfSxcbiAgZWFzZUluQm91bmNlOiB0ID0+IDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpLFxuICBlYXNlT3V0Qm91bmNlKHQpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcbiAgZWFzZUluT3V0Qm91bmNlOiB0ID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn07XG5cbmZ1bmN0aW9uIF9wb2ludEluTGluZShwMSwgcDIsIHQsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogcDEueSArIHQgKiAocDIueSAtIHAxLnkpXG4gIH07XG59XG5mdW5jdGlvbiBfc3RlcHBlZEludGVycG9sYXRpb24ocDEsIHAyLCB0LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IG1vZGUgPT09ICdtaWRkbGUnID8gdCA8IDAuNSA/IHAxLnkgOiBwMi55XG4gICAgOiBtb2RlID09PSAnYWZ0ZXInID8gdCA8IDEgPyBwMS55IDogcDIueVxuICAgIDogdCA+IDAgPyBwMi55IDogcDEueVxuICB9O1xufVxuZnVuY3Rpb24gX2JlemllckludGVycG9sYXRpb24ocDEsIHAyLCB0LCBtb2RlKSB7XG4gIGNvbnN0IGNwMSA9IHt4OiBwMS5jcDJ4LCB5OiBwMS5jcDJ5fTtcbiAgY29uc3QgY3AyID0ge3g6IHAyLmNwMXgsIHk6IHAyLmNwMXl9O1xuICBjb25zdCBhID0gX3BvaW50SW5MaW5lKHAxLCBjcDEsIHQpO1xuICBjb25zdCBiID0gX3BvaW50SW5MaW5lKGNwMSwgY3AyLCB0KTtcbiAgY29uc3QgYyA9IF9wb2ludEluTGluZShjcDIsIHAyLCB0KTtcbiAgY29uc3QgZCA9IF9wb2ludEluTGluZShhLCBiLCB0KTtcbiAgY29uc3QgZSA9IF9wb2ludEluTGluZShiLCBjLCB0KTtcbiAgcmV0dXJuIF9wb2ludEluTGluZShkLCBlLCB0KTtcbn1cblxuY29uc3QgaW50bENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgY2FjaGVLZXkgPSBsb2NhbGUgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgbGV0IGZvcm1hdHRlciA9IGludGxDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWZvcm1hdHRlcikge1xuICAgIGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpO1xuICAgIGludGxDYWNoZS5zZXQoY2FjaGVLZXksIGZvcm1hdHRlcik7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdHRlcjtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW0sIGxvY2FsZSwgb3B0aW9ucykge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG51bSk7XG59XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLyk7XG5jb25zdCBGT05UX1NUWUxFID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLyk7XG5mdW5jdGlvbiB0b0xpbmVIZWlnaHQodmFsdWUsIHNpemUpIHtcbiAgY29uc3QgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaChMSU5FX0hFSUdIVCk7XG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiBzaXplICogMS4yO1xuICB9XG4gIHZhbHVlID0gK21hdGNoZXNbMl07XG4gIHN3aXRjaCAobWF0Y2hlc1szXSkge1xuICBjYXNlICdweCc6XG4gICAgcmV0dXJuIHZhbHVlO1xuICBjYXNlICclJzpcbiAgICB2YWx1ZSAvPSAxMDA7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cbmNvbnN0IG51bWJlck9yWmVybyA9IHYgPT4gK3YgfHwgMDtcbmZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBwcm9wcykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY29uc3Qgb2JqUHJvcHMgPSBpc09iamVjdChwcm9wcyk7XG4gIGNvbnN0IGtleXMgPSBvYmpQcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzO1xuICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpXG4gICAgPyBvYmpQcm9wc1xuICAgICAgPyBwcm9wID0+IHZhbHVlT3JEZWZhdWx0KHZhbHVlW3Byb3BdLCB2YWx1ZVtwcm9wc1twcm9wXV0pXG4gICAgICA6IHByb3AgPT4gdmFsdWVbcHJvcF1cbiAgICA6ICgpID0+IHZhbHVlO1xuICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xuICAgIHJldFtwcm9wXSA9IG51bWJlck9yWmVybyhyZWFkKHByb3ApKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdG9UUkJMKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwge3RvcDogJ3knLCByaWdodDogJ3gnLCBib3R0b206ICd5JywgbGVmdDogJ3gnfSk7XG59XG5mdW5jdGlvbiB0b1RSQkxDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWyd0b3BMZWZ0JywgJ3RvcFJpZ2h0JywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnXSk7XG59XG5mdW5jdGlvbiB0b1BhZGRpbmcodmFsdWUpIHtcbiAgY29uc3Qgb2JqID0gdG9UUkJMKHZhbHVlKTtcbiAgb2JqLndpZHRoID0gb2JqLmxlZnQgKyBvYmoucmlnaHQ7XG4gIG9iai5oZWlnaHQgPSBvYmoudG9wICsgb2JqLmJvdHRvbTtcbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHRvRm9udChvcHRpb25zLCBmYWxsYmFjaykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCBkZWZhdWx0cy5mb250O1xuICBsZXQgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc2l6ZSwgZmFsbGJhY2suc2l6ZSk7XG4gIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICB9XG4gIGxldCBzdHlsZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc3R5bGUsIGZhbGxiYWNrLnN0eWxlKTtcbiAgaWYgKHN0eWxlICYmICEoJycgKyBzdHlsZSkubWF0Y2goRk9OVF9TVFlMRSkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHN0eWxlICsgJ1wiJyk7XG4gICAgc3R5bGUgPSAnJztcbiAgfVxuICBjb25zdCBmb250ID0ge1xuICAgIGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mYW1pbHksIGZhbGxiYWNrLmZhbWlseSksXG4gICAgbGluZUhlaWdodDogdG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZmFsbGJhY2subGluZUhlaWdodCksIHNpemUpLFxuICAgIHNpemUsXG4gICAgc3R5bGUsXG4gICAgd2VpZ2h0OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLndlaWdodCwgZmFsbGJhY2sud2VpZ2h0KSxcbiAgICBzdHJpbmc6ICcnXG4gIH07XG4gIGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuICByZXR1cm4gZm9udDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoaW5wdXRzLCBjb250ZXh0LCBpbmRleCwgaW5mbykge1xuICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gaW5wdXRzW2ldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5mbyAmJiAhY2FjaGVhYmxlKSB7XG4gICAgICAgIGluZm8uY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfYWRkR3JhY2UobWlubWF4LCBncmFjZSwgYmVnaW5BdFplcm8pIHtcbiAgY29uc3Qge21pbiwgbWF4fSA9IG1pbm1heDtcbiAgY29uc3QgY2hhbmdlID0gdG9EaW1lbnNpb24oZ3JhY2UsIChtYXggLSBtaW4pIC8gMik7XG4gIGNvbnN0IGtlZXBaZXJvID0gKHZhbHVlLCBhZGQpID0+IGJlZ2luQXRaZXJvICYmIHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgYWRkO1xuICByZXR1cm4ge1xuICAgIG1pbjoga2VlcFplcm8obWluLCAtTWF0aC5hYnMoY2hhbmdlKSksXG4gICAgbWF4OiBrZWVwWmVybyhtYXgsIGNoYW5nZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocGFyZW50Q29udGV4dCwgY29udGV4dCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudENvbnRleHQpLCBjb250ZXh0KTtcbn1cblxuY29uc3QgZ2V0UmlnaHRUb0xlZnRBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFgsIHdpZHRoKSB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4gcmVjdFggKyByZWN0WCArIHdpZHRoIC0geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHtcbiAgICAgIHdpZHRoID0gdztcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4IC0gdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIGl0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHggLSBpdGVtV2lkdGg7XG4gICAgfSxcbiAgfTtcbn07XG5jb25zdCBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICByZXR1cm4gYWxpZ247XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggKyB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgX2l0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRSdGxBZGFwdGVyKHJ0bCwgcmVjdFgsIHdpZHRoKSB7XG4gIHJldHVybiBydGwgPyBnZXRSaWdodFRvTGVmdEFkYXB0ZXIocmVjdFgsIHdpZHRoKSA6IGdldExlZnRUb1JpZ2h0QWRhcHRlcigpO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgZGlyZWN0aW9uKSB7XG4gIGxldCBzdHlsZSwgb3JpZ2luYWw7XG4gIGlmIChkaXJlY3Rpb24gPT09ICdsdHInIHx8IGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICBzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XG4gICAgb3JpZ2luYWwgPSBbXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSxcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpLFxuICAgIF07XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIGRpcmVjdGlvbiwgJ2ltcG9ydGFudCcpO1xuICAgIGN0eC5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9yaWdpbmFsKSB7XG4gIGlmIChvcmlnaW5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIGN0eC5wcmV2VGV4dERpcmVjdGlvbjtcbiAgICBjdHguY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBvcmlnaW5hbFswXSwgb3JpZ2luYWxbMV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Rm4ocHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJldHdlZW46IF9hbmdsZUJldHdlZW4sXG4gICAgICBjb21wYXJlOiBfYW5nbGVEaWZmLFxuICAgICAgbm9ybWFsaXplOiBfbm9ybWFsaXplQW5nbGUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJldHdlZW46IF9pc0JldHdlZW4sXG4gICAgY29tcGFyZTogKGEsIGIpID0+IGEgLSBiLFxuICAgIG5vcm1hbGl6ZTogeCA9PiB4XG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVTZWdtZW50KHtzdGFydCwgZW5kLCBjb3VudCwgbG9vcCwgc3R5bGV9KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0ICUgY291bnQsXG4gICAgZW5kOiBlbmQgJSBjb3VudCxcbiAgICBsb29wOiBsb29wICYmIChlbmQgLSBzdGFydCArIDEpICUgY291bnQgPT09IDAsXG4gICAgc3R5bGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IHtiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IHtzdGFydCwgZW5kLCBsb29wfSA9IHNlZ21lbnQ7XG4gIGxldCBpLCBpbGVuO1xuICBpZiAobG9vcCkge1xuICAgIHN0YXJ0ICs9IGNvdW50O1xuICAgIGVuZCArPSBjb3VudDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICghYmV0d2Vlbihub3JtYWxpemUocG9pbnRzW3N0YXJ0ICUgY291bnRdW3Byb3BlcnR5XSksIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXJ0LS07XG4gICAgICBlbmQtLTtcbiAgICB9XG4gICAgc3RhcnQgJT0gY291bnQ7XG4gICAgZW5kICU9IGNvdW50O1xuICB9XG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGVuZCArPSBjb3VudDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlOiBzZWdtZW50LnN0eWxlfTtcbn1cbmZ1bmN0aW9uIF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgaWYgKCFib3VuZHMpIHtcbiAgICByZXR1cm4gW3NlZ21lbnRdO1xuICB9XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtjb21wYXJlLCBiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZX0gPSBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgbGV0IHN1YlN0YXJ0ID0gbnVsbDtcbiAgbGV0IHZhbHVlLCBwb2ludCwgcHJldlZhbHVlO1xuICBjb25zdCBzdGFydElzQmVmb3JlID0gKCkgPT4gYmV0d2VlbihzdGFydEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKSAmJiBjb21wYXJlKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSkgIT09IDA7XG4gIGNvbnN0IGVuZElzQmVmb3JlID0gKCkgPT4gY29tcGFyZShlbmRCb3VuZCwgdmFsdWUpID09PSAwIHx8IGJldHdlZW4oZW5kQm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpO1xuICBjb25zdCBzaG91bGRTdGFydCA9ICgpID0+IGluc2lkZSB8fCBzdGFydElzQmVmb3JlKCk7XG4gIGNvbnN0IHNob3VsZFN0b3AgPSAoKSA9PiAhaW5zaWRlIHx8IGVuZElzQmVmb3JlKCk7XG4gIGZvciAobGV0IGkgPSBzdGFydCwgcHJldiA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhbHVlID0gbm9ybWFsaXplKHBvaW50W3Byb3BlcnR5XSk7XG4gICAgaWYgKHZhbHVlID09PSBwcmV2VmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbnNpZGUgPSBiZXR3ZWVuKHZhbHVlLCBzdGFydEJvdW5kLCBlbmRCb3VuZCk7XG4gICAgaWYgKHN1YlN0YXJ0ID09PSBudWxsICYmIHNob3VsZFN0YXJ0KCkpIHtcbiAgICAgIHN1YlN0YXJ0ID0gY29tcGFyZSh2YWx1ZSwgc3RhcnRCb3VuZCkgPT09IDAgPyBpIDogcHJldjtcbiAgICB9XG4gICAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsICYmIHNob3VsZFN0b3AoKSkge1xuICAgICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQ6IGksIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgICAgIHN1YlN0YXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgcHJldiA9IGk7XG4gICAgcHJldlZhbHVlID0gdmFsdWU7XG4gIH1cbiAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQsIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdWIgPSBfYm91bmRTZWdtZW50KHNlZ21lbnRzW2ldLCBsaW5lLnBvaW50cywgYm91bmRzKTtcbiAgICBpZiAoc3ViLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goLi4uc3ViKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcykge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gY291bnQgLSAxO1xuICBpZiAobG9vcCAmJiAhc3BhbkdhcHMpIHtcbiAgICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiBwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICBzdGFydCsrO1xuICB9XG4gIHN0YXJ0ICU9IGNvdW50O1xuICBpZiAobG9vcCkge1xuICAgIGVuZCArPSBzdGFydDtcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgcG9pbnRzW2VuZCAlIGNvdW50XS5za2lwKSB7XG4gICAgZW5kLS07XG4gIH1cbiAgZW5kICU9IGNvdW50O1xuICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xufVxuZnVuY3Rpb24gc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGxvb3ApIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGxhc3QgPSBzdGFydDtcbiAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnRdO1xuICBsZXQgZW5kO1xuICBmb3IgKGVuZCA9IHN0YXJ0ICsgMTsgZW5kIDw9IG1heDsgKytlbmQpIHtcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbZW5kICUgY291bnRdO1xuICAgIGlmIChjdXIuc2tpcCB8fCBjdXIuc3RvcCkge1xuICAgICAgaWYgKCFwcmV2LnNraXApIHtcbiAgICAgICAgbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogKGVuZCAtIDEpICUgY291bnQsIGxvb3B9KTtcbiAgICAgICAgc3RhcnQgPSBsYXN0ID0gY3VyLnN0b3AgPyBlbmQgOiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gZW5kO1xuICAgICAgaWYgKHByZXYuc2tpcCkge1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldiA9IGN1cjtcbiAgfVxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiBsYXN0ICUgY291bnQsIGxvb3B9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2NvbXB1dGVTZWdtZW50cyhsaW5lLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qgc3BhbkdhcHMgPSBsaW5lLm9wdGlvbnMuc3BhbkdhcHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBsb29wID0gISFsaW5lLl9sb29wO1xuICBjb25zdCB7c3RhcnQsIGVuZH0gPSBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpO1xuICBpZiAoc3BhbkdhcHMgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBbe3N0YXJ0LCBlbmQsIGxvb3B9XSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgbWF4ID0gZW5kIDwgc3RhcnQgPyBlbmQgKyBjb3VudCA6IGVuZDtcbiAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcbiAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGNvbXBsZXRlTG9vcCksIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBpZiAoIXNlZ21lbnRPcHRpb25zIHx8ICFzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0IHx8ICFwb2ludHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cbiAgcmV0dXJuIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnRDb250ZXh0ID0gbGluZS5fY2hhcnQuZ2V0Q29udGV4dCgpO1xuICBjb25zdCBiYXNlU3R5bGUgPSByZWFkU3R5bGUobGluZS5vcHRpb25zKTtcbiAgY29uc3Qge19kYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCwgb3B0aW9uczoge3NwYW5HYXBzfX0gPSBsaW5lO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgcHJldlN0eWxlID0gYmFzZVN0eWxlO1xuICBsZXQgc3RhcnQgPSBzZWdtZW50c1swXS5zdGFydDtcbiAgbGV0IGkgPSBzdGFydDtcbiAgZnVuY3Rpb24gYWRkU3R5bGUocywgZSwgbCwgc3QpIHtcbiAgICBjb25zdCBkaXIgPSBzcGFuR2FwcyA/IC0xIDogMTtcbiAgICBpZiAocyA9PT0gZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzICs9IGNvdW50O1xuICAgIHdoaWxlIChwb2ludHNbcyAlIGNvdW50XS5za2lwKSB7XG4gICAgICBzIC09IGRpcjtcbiAgICB9XG4gICAgd2hpbGUgKHBvaW50c1tlICUgY291bnRdLnNraXApIHtcbiAgICAgIGUgKz0gZGlyO1xuICAgIH1cbiAgICBpZiAocyAlIGNvdW50ICE9PSBlICUgY291bnQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogcyAlIGNvdW50LCBlbmQ6IGUgJSBjb3VudCwgbG9vcDogbCwgc3R5bGU6IHN0fSk7XG4gICAgICBwcmV2U3R5bGUgPSBzdDtcbiAgICAgIHN0YXJ0ID0gZSAlIGNvdW50O1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzdGFydCA9IHNwYW5HYXBzID8gc3RhcnQgOiBzZWdtZW50LnN0YXJ0O1xuICAgIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0ICUgY291bnRdO1xuICAgIGxldCBzdHlsZTtcbiAgICBmb3IgKGkgPSBzdGFydCArIDE7IGkgPD0gc2VnbWVudC5lbmQ7IGkrKykge1xuICAgICAgY29uc3QgcHQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICAgIHN0eWxlID0gcmVhZFN0eWxlKHNlZ21lbnRPcHRpb25zLnNldENvbnRleHQoY3JlYXRlQ29udGV4dChjaGFydENvbnRleHQsIHtcbiAgICAgICAgdHlwZTogJ3NlZ21lbnQnLFxuICAgICAgICBwMDogcHJldixcbiAgICAgICAgcDE6IHB0LFxuICAgICAgICBwMERhdGFJbmRleDogKGkgLSAxKSAlIGNvdW50LFxuICAgICAgICBwMURhdGFJbmRleDogaSAlIGNvdW50LFxuICAgICAgICBkYXRhc2V0SW5kZXhcbiAgICAgIH0pKSk7XG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpKSB7XG4gICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJldiA9IHB0O1xuICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGkgLSAxKSB7XG4gICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlYWRTdHlsZShvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICBib3JkZXJDYXBTdHlsZTogb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSxcbiAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgIGJvcmRlckpvaW5TdHlsZTogb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUsXG4gICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3JcbiAgfTtcbn1cbmZ1bmN0aW9uIHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSB7XG4gIHJldHVybiBwcmV2U3R5bGUgJiYgSlNPTi5zdHJpbmdpZnkoc3R5bGUpICE9PSBKU09OLnN0cmluZ2lmeShwcmV2U3R5bGUpO1xufVxuXG52YXIgaGVscGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbmVhc2luZ0VmZmVjdHM6IGVmZmVjdHMsXG5pc1BhdHRlcm5PckdyYWRpZW50OiBpc1BhdHRlcm5PckdyYWRpZW50LFxuY29sb3I6IGNvbG9yLFxuZ2V0SG92ZXJDb2xvcjogZ2V0SG92ZXJDb2xvcixcbm5vb3A6IG5vb3AsXG51aWQ6IHVpZCxcbmlzTnVsbE9yVW5kZWY6IGlzTnVsbE9yVW5kZWYsXG5pc0FycmF5OiBpc0FycmF5LFxuaXNPYmplY3Q6IGlzT2JqZWN0LFxuaXNGaW5pdGU6IGlzTnVtYmVyRmluaXRlLFxuZmluaXRlT3JEZWZhdWx0OiBmaW5pdGVPckRlZmF1bHQsXG52YWx1ZU9yRGVmYXVsdDogdmFsdWVPckRlZmF1bHQsXG50b1BlcmNlbnRhZ2U6IHRvUGVyY2VudGFnZSxcbnRvRGltZW5zaW9uOiB0b0RpbWVuc2lvbixcbmNhbGxiYWNrOiBjYWxsYmFjayxcbmVhY2g6IGVhY2gsXG5fZWxlbWVudHNFcXVhbDogX2VsZW1lbnRzRXF1YWwsXG5jbG9uZTogY2xvbmUkMSxcbl9tZXJnZXI6IF9tZXJnZXIsXG5tZXJnZTogbWVyZ2UsXG5tZXJnZUlmOiBtZXJnZUlmLFxuX21lcmdlcklmOiBfbWVyZ2VySWYsXG5fZGVwcmVjYXRlZDogX2RlcHJlY2F0ZWQsXG5yZXNvbHZlT2JqZWN0S2V5OiByZXNvbHZlT2JqZWN0S2V5LFxuX3NwbGl0S2V5OiBfc3BsaXRLZXksXG5fY2FwaXRhbGl6ZTogX2NhcGl0YWxpemUsXG5kZWZpbmVkOiBkZWZpbmVkLFxuaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbnNldHNFcXVhbDogc2V0c0VxdWFsLFxuX2lzQ2xpY2tFdmVudDogX2lzQ2xpY2tFdmVudCxcbnRvRm9udFN0cmluZzogdG9Gb250U3RyaW5nLFxuX21lYXN1cmVUZXh0OiBfbWVhc3VyZVRleHQsXG5fbG9uZ2VzdFRleHQ6IF9sb25nZXN0VGV4dCxcbl9hbGlnblBpeGVsOiBfYWxpZ25QaXhlbCxcbmNsZWFyQ2FudmFzOiBjbGVhckNhbnZhcyxcbmRyYXdQb2ludDogZHJhd1BvaW50LFxuZHJhd1BvaW50TGVnZW5kOiBkcmF3UG9pbnRMZWdlbmQsXG5faXNQb2ludEluQXJlYTogX2lzUG9pbnRJbkFyZWEsXG5jbGlwQXJlYTogY2xpcEFyZWEsXG51bmNsaXBBcmVhOiB1bmNsaXBBcmVhLFxuX3N0ZXBwZWRMaW5lVG86IF9zdGVwcGVkTGluZVRvLFxuX2JlemllckN1cnZlVG86IF9iZXppZXJDdXJ2ZVRvLFxucmVuZGVyVGV4dDogcmVuZGVyVGV4dCxcbmFkZFJvdW5kZWRSZWN0UGF0aDogYWRkUm91bmRlZFJlY3RQYXRoLFxuX2xvb2t1cDogX2xvb2t1cCxcbl9sb29rdXBCeUtleTogX2xvb2t1cEJ5S2V5LFxuX3Jsb29rdXBCeUtleTogX3Jsb29rdXBCeUtleSxcbl9maWx0ZXJCZXR3ZWVuOiBfZmlsdGVyQmV0d2Vlbixcbmxpc3RlbkFycmF5RXZlbnRzOiBsaXN0ZW5BcnJheUV2ZW50cyxcbnVubGlzdGVuQXJyYXlFdmVudHM6IHVubGlzdGVuQXJyYXlFdmVudHMsXG5fYXJyYXlVbmlxdWU6IF9hcnJheVVuaXF1ZSxcbl9jcmVhdGVSZXNvbHZlcjogX2NyZWF0ZVJlc29sdmVyLFxuX2F0dGFjaENvbnRleHQ6IF9hdHRhY2hDb250ZXh0LFxuX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMsXG5fcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGU6IF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSxcbnNwbGluZUN1cnZlOiBzcGxpbmVDdXJ2ZSxcbnNwbGluZUN1cnZlTW9ub3RvbmU6IHNwbGluZUN1cnZlTW9ub3RvbmUsXG5fdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMsXG5faXNEb21TdXBwb3J0ZWQ6IF9pc0RvbVN1cHBvcnRlZCxcbl9nZXRQYXJlbnROb2RlOiBfZ2V0UGFyZW50Tm9kZSxcbmdldFN0eWxlOiBnZXRTdHlsZSxcbmdldFJlbGF0aXZlUG9zaXRpb246IGdldFJlbGF0aXZlUG9zaXRpb24sXG5nZXRNYXhpbXVtU2l6ZTogZ2V0TWF4aW11bVNpemUsXG5yZXRpbmFTY2FsZTogcmV0aW5hU2NhbGUsXG5zdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zOiBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zLFxucmVhZFVzZWRTaXplOiByZWFkVXNlZFNpemUsXG5mb250U3RyaW5nOiBmb250U3RyaW5nLFxucmVxdWVzdEFuaW1GcmFtZTogcmVxdWVzdEFuaW1GcmFtZSxcbnRocm90dGxlZDogdGhyb3R0bGVkLFxuZGVib3VuY2U6IGRlYm91bmNlLFxuX3RvTGVmdFJpZ2h0Q2VudGVyOiBfdG9MZWZ0UmlnaHRDZW50ZXIsXG5fYWxpZ25TdGFydEVuZDogX2FsaWduU3RhcnRFbmQsXG5fdGV4dFg6IF90ZXh0WCxcbl9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzOiBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyxcbl9zY2FsZVJhbmdlc0NoYW5nZWQ6IF9zY2FsZVJhbmdlc0NoYW5nZWQsXG5fcG9pbnRJbkxpbmU6IF9wb2ludEluTGluZSxcbl9zdGVwcGVkSW50ZXJwb2xhdGlvbjogX3N0ZXBwZWRJbnRlcnBvbGF0aW9uLFxuX2JlemllckludGVycG9sYXRpb246IF9iZXppZXJJbnRlcnBvbGF0aW9uLFxuZm9ybWF0TnVtYmVyOiBmb3JtYXROdW1iZXIsXG50b0xpbmVIZWlnaHQ6IHRvTGluZUhlaWdodCxcbl9yZWFkVmFsdWVUb1Byb3BzOiBfcmVhZFZhbHVlVG9Qcm9wcyxcbnRvVFJCTDogdG9UUkJMLFxudG9UUkJMQ29ybmVyczogdG9UUkJMQ29ybmVycyxcbnRvUGFkZGluZzogdG9QYWRkaW5nLFxudG9Gb250OiB0b0ZvbnQsXG5yZXNvbHZlOiByZXNvbHZlLFxuX2FkZEdyYWNlOiBfYWRkR3JhY2UsXG5jcmVhdGVDb250ZXh0OiBjcmVhdGVDb250ZXh0LFxuUEk6IFBJLFxuVEFVOiBUQVUsXG5QSVRBVTogUElUQVUsXG5JTkZJTklUWTogSU5GSU5JVFksXG5SQURfUEVSX0RFRzogUkFEX1BFUl9ERUcsXG5IQUxGX1BJOiBIQUxGX1BJLFxuUVVBUlRFUl9QSTogUVVBUlRFUl9QSSxcblRXT19USElSRFNfUEk6IFRXT19USElSRFNfUEksXG5sb2cxMDogbG9nMTAsXG5zaWduOiBzaWduLFxubmljZU51bTogbmljZU51bSxcbl9mYWN0b3JpemU6IF9mYWN0b3JpemUsXG5pc051bWJlcjogaXNOdW1iZXIsXG5hbG1vc3RFcXVhbHM6IGFsbW9zdEVxdWFscyxcbmFsbW9zdFdob2xlOiBhbG1vc3RXaG9sZSxcbl9zZXRNaW5BbmRNYXhCeUtleTogX3NldE1pbkFuZE1heEJ5S2V5LFxudG9SYWRpYW5zOiB0b1JhZGlhbnMsXG50b0RlZ3JlZXM6IHRvRGVncmVlcyxcbl9kZWNpbWFsUGxhY2VzOiBfZGVjaW1hbFBsYWNlcyxcbmdldEFuZ2xlRnJvbVBvaW50OiBnZXRBbmdsZUZyb21Qb2ludCxcbmRpc3RhbmNlQmV0d2VlblBvaW50czogZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLFxuX2FuZ2xlRGlmZjogX2FuZ2xlRGlmZixcbl9ub3JtYWxpemVBbmdsZTogX25vcm1hbGl6ZUFuZ2xlLFxuX2FuZ2xlQmV0d2VlbjogX2FuZ2xlQmV0d2Vlbixcbl9saW1pdFZhbHVlOiBfbGltaXRWYWx1ZSxcbl9pbnQxNlJhbmdlOiBfaW50MTZSYW5nZSxcbl9pc0JldHdlZW46IF9pc0JldHdlZW4sXG5nZXRSdGxBZGFwdGVyOiBnZXRSdGxBZGFwdGVyLFxub3ZlcnJpZGVUZXh0RGlyZWN0aW9uOiBvdmVycmlkZVRleHREaXJlY3Rpb24sXG5yZXN0b3JlVGV4dERpcmVjdGlvbjogcmVzdG9yZVRleHREaXJlY3Rpb24sXG5fYm91bmRTZWdtZW50OiBfYm91bmRTZWdtZW50LFxuX2JvdW5kU2VnbWVudHM6IF9ib3VuZFNlZ21lbnRzLFxuX2NvbXB1dGVTZWdtZW50czogX2NvbXB1dGVTZWdtZW50c1xufSk7XG5cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChtZXRhc2V0LCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IHtjb250cm9sbGVyLCBkYXRhLCBfc29ydGVkfSA9IG1ldGFzZXQ7XG4gIGNvbnN0IGlTY2FsZSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGEuaVNjYWxlO1xuICBpZiAoaVNjYWxlICYmIGF4aXMgPT09IGlTY2FsZS5heGlzICYmIGF4aXMgIT09ICdyJyAmJiBfc29ydGVkICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgbG9va3VwTWV0aG9kID0gaVNjYWxlLl9yZXZlcnNlUGl4ZWxzID8gX3Jsb29rdXBCeUtleSA6IF9sb29rdXBCeUtleTtcbiAgICBpZiAoIWludGVyc2VjdCkge1xuICAgICAgcmV0dXJuIGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICBjb25zdCBlbCA9IGRhdGFbMF07XG4gICAgICBjb25zdCByYW5nZSA9IHR5cGVvZiBlbC5nZXRSYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiBlbC5nZXRSYW5nZShheGlzKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSAtIHJhbmdlKTtcbiAgICAgICAgY29uc3QgZW5kID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlICsgcmFuZ2UpO1xuICAgICAgICByZXR1cm4ge2xvOiBzdGFydC5sbywgaGk6IGVuZC5oaX07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7bG86IDAsIGhpOiBkYXRhLmxlbmd0aCAtIDF9O1xufVxuZnVuY3Rpb24gZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgaGFuZGxlciwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW2F4aXNdO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IHtpbmRleCwgZGF0YX0gPSBtZXRhc2V0c1tpXTtcbiAgICBjb25zdCB7bG8sIGhpfSA9IGJpbmFyeVNlYXJjaChtZXRhc2V0c1tpXSwgYXhpcywgdmFsdWUsIGludGVyc2VjdCk7XG4gICAgZm9yIChsZXQgaiA9IGxvOyBqIDw9IGhpOyArK2opIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhW2pdO1xuICAgICAgaWYgKCFlbGVtZW50LnNraXApIHtcbiAgICAgICAgaGFuZGxlcihlbGVtZW50LCBpbmRleCwgaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuICBjb25zdCB1c2VYID0gYXhpcy5pbmRleE9mKCd4JykgIT09IC0xO1xuICBjb25zdCB1c2VZID0gYXhpcy5pbmRleE9mKCd5JykgIT09IC0xO1xuICByZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcbiAgICBjb25zdCBkZWx0YVggPSB1c2VYID8gTWF0aC5hYnMocHQxLnggLSBwdDIueCkgOiAwO1xuICAgIGNvbnN0IGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBjb25zdCBldmFsdWF0aW9uRnVuYyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIV9pc1BvaW50SW5BcmVhKGVsZW1lbnQsIGNoYXJ0LmNoYXJ0QXJlYSwgMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfTtcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlfSA9IGVsZW1lbnQuZ2V0UHJvcHMoWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZX0gPSBnZXRBbmdsZUZyb21Qb2ludChlbGVtZW50LCB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX0pO1xuICAgIGlmIChfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGNvbnN0IGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpO1xuICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCBpblJhbmdlID0gZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGlmIChpbnRlcnNlY3QgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBwb2ludEluQXJlYSA9ICEhaW5jbHVkZUludmlzaWJsZSB8fCBjaGFydC5pc1BvaW50SW5BcmVhKGNlbnRlcik7XG4gICAgaWYgKCFwb2ludEluQXJlYSAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcyA9IFt7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH1dO1xuICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBheGlzID09PSAncicgJiYgIWludGVyc2VjdFxuICAgID8gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbilcbiAgICA6IGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG59XG5mdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIChlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSA9PiB7XG4gICAgaWYgKGVsZW1lbnRbcmFuZ2VNZXRob2RdKHBvc2l0aW9uW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSBpbnRlcnNlY3RzSXRlbSB8fCBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9KTtcbiAgaWYgKGludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxudmFyIEludGVyYWN0aW9uID0ge1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMsXG4gIG1vZGVzOiB7XG4gICAgaW5kZXgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBjb25zdCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKVxuICAgICAgICA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwgaW5kZXh9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICBkYXRhc2V0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGxldCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSA6XG4gICAgICAgIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRJbmRleCA9IGl0ZW1zWzBdLmRhdGFzZXRJbmRleDtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuZGF0YTtcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudDogZGF0YVtpXSwgZGF0YXNldEluZGV4LCBpbmRleDogaX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcbiAgICBwb2ludChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuICAgIG5lYXJlc3QoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3gnLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcbiAgICB5KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd5Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgU1RBVElDX1BPU0lUSU9OUyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG5mdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gdi5wb3MgPT09IHBvc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gU1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcbiAgcmV0dXJuIGFycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB2MCA9IHJldmVyc2UgPyBiIDogYTtcbiAgICBjb25zdCB2MSA9IHJldmVyc2UgPyBhIDogYjtcbiAgICByZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgP1xuICAgICAgdjAuaW5kZXggLSB2MS5pbmRleCA6XG4gICAgICB2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gd3JhcEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBib3gsIHBvcywgc3RhY2ssIHN0YWNrV2VpZ2h0O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBib3ggPSBib3hlc1tpXTtcbiAgICAoe3Bvc2l0aW9uOiBwb3MsIG9wdGlvbnM6IHtzdGFjaywgc3RhY2tXZWlnaHQgPSAxfX0gPSBib3gpO1xuICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBib3gsXG4gICAgICBwb3MsXG4gICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcbiAgICAgIHN0YWNrV2VpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuZnVuY3Rpb24gYnVpbGRTdGFja3MobGF5b3V0cykge1xuICBjb25zdCBzdGFja3MgPSB7fTtcbiAgZm9yIChjb25zdCB3cmFwIG9mIGxheW91dHMpIHtcbiAgICBjb25zdCB7c3RhY2ssIHBvcywgc3RhY2tXZWlnaHR9ID0gd3JhcDtcbiAgICBpZiAoIXN0YWNrIHx8ICFTVEFUSUNfUE9TSVRJT05TLmluY2x1ZGVzKHBvcykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBfc3RhY2sgPSBzdGFja3Nbc3RhY2tdIHx8IChzdGFja3Nbc3RhY2tdID0ge2NvdW50OiAwLCBwbGFjZWQ6IDAsIHdlaWdodDogMCwgc2l6ZTogMH0pO1xuICAgIF9zdGFjay5jb3VudCsrO1xuICAgIF9zdGFjay53ZWlnaHQgKz0gc3RhY2tXZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcbiAgbGV0IGksIGlsZW4sIGxheW91dDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICBjb25zdCB7ZnVsbFNpemV9ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdO1xuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQud2lkdGggPSB2Qm94TWF4V2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBidWlsZExheW91dEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gd3JhcEJveGVzKGJveGVzKTtcbiAgY29uc3QgZnVsbFNpemUgPSBzb3J0QnlXZWlnaHQobGF5b3V0Qm94ZXMuZmlsdGVyKHdyYXAgPT4gd3JhcC5ib3guZnVsbFNpemUpLCB0cnVlKTtcbiAgY29uc3QgbGVmdCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnbGVmdCcpLCB0cnVlKTtcbiAgY29uc3QgcmlnaHQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3JpZ2h0JykpO1xuICBjb25zdCB0b3AgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3RvcCcpLCB0cnVlKTtcbiAgY29uc3QgYm90dG9tID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdib3R0b20nKSk7XG4gIGNvbnN0IGNlbnRlckhvcml6b250YWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd4Jyk7XG4gIGNvbnN0IGNlbnRlclZlcnRpY2FsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneScpO1xuICByZXR1cm4ge1xuICAgIGZ1bGxTaXplLFxuICAgIGxlZnRBbmRUb3A6IGxlZnQuY29uY2F0KHRvcCksXG4gICAgcmlnaHRBbmRCb3R0b206IHJpZ2h0LmNvbmNhdChjZW50ZXJWZXJ0aWNhbCkuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpLFxuICAgIGNoYXJ0QXJlYTogZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2NoYXJ0QXJlYScpLFxuICAgIHZlcnRpY2FsOiBsZWZ0LmNvbmNhdChyaWdodCkuY29uY2F0KGNlbnRlclZlcnRpY2FsKSxcbiAgICBob3Jpem9udGFsOiB0b3AuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuZnVuY3Rpb24gdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3hQYWRkaW5nKSB7XG4gIG1heFBhZGRpbmcudG9wID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AsIGJveFBhZGRpbmcudG9wKTtcbiAgbWF4UGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5sZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuICBtYXhQYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XG4gIG1heFBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKSB7XG4gIGNvbnN0IHtwb3MsIGJveH0gPSBsYXlvdXQ7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgaWYgKCFpc09iamVjdChwb3MpKSB7XG4gICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICBjaGFydEFyZWFbcG9zXSAtPSBsYXlvdXQuc2l6ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7c2l6ZTogMCwgY291bnQ6IDF9O1xuICAgIHN0YWNrLnNpemUgPSBNYXRoLm1heChzdGFjay5zaXplLCBsYXlvdXQuaG9yaXpvbnRhbCA/IGJveC5oZWlnaHQgOiBib3gud2lkdGgpO1xuICAgIGxheW91dC5zaXplID0gc3RhY2suc2l6ZSAvIHN0YWNrLmNvdW50O1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGxheW91dC5zaXplO1xuICB9XG4gIGlmIChib3guZ2V0UGFkZGluZykge1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94LmdldFBhZGRpbmcoKSk7XG4gIH1cbiAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XG4gIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XG4gIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuICByZXR1cm4gbGF5b3V0Lmhvcml6b250YWxcbiAgICA/IHtzYW1lOiB3aWR0aENoYW5nZWQsIG90aGVyOiBoZWlnaHRDaGFuZ2VkfVxuICAgIDoge3NhbWU6IGhlaWdodENoYW5nZWQsIG90aGVyOiB3aWR0aENoYW5nZWR9O1xufVxuZnVuY3Rpb24gaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBmdW5jdGlvbiB1cGRhdGVQb3MocG9zKSB7XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gIGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIG1hcmdpbkZvclBvc2l0aW9ucyhwb3NpdGlvbnMpIHtcbiAgICBjb25zdCBtYXJnaW4gPSB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfTtcbiAgICBwb3NpdGlvbnMuZm9yRWFjaCgocG9zKSA9PiB7XG4gICAgICBtYXJnaW5bcG9zXSA9IE1hdGgubWF4KGNoYXJ0QXJlYVtwb3NdLCBtYXhQYWRkaW5nW3Bvc10pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXJnaW47XG4gIH1cbiAgcmV0dXJuIGhvcml6b250YWxcbiAgICA/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICA6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5mdW5jdGlvbiBmaXRCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCByZWZpdEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBib3hlcy5sZW5ndGgsIHJlZml0ID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGJveGVzW2ldO1xuICAgIGJveCA9IGxheW91dC5ib3g7XG4gICAgYm94LnVwZGF0ZShcbiAgICAgIGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG4gICAgICBnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG4gICAgKTtcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuICAgIHJlZml0IHw9IHNhbWUgJiYgcmVmaXRCb3hlcy5sZW5ndGg7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgb3RoZXI7XG4gICAgaWYgKCFib3guZnVsbFNpemUpIHtcbiAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmaXQgJiYgZml0Qm94ZXMocmVmaXRCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykgfHwgY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHNldEJveERpbXMoYm94LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgYm94LnRvcCA9IHRvcDtcbiAgYm94LmxlZnQgPSBsZWZ0O1xuICBib3gucmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gIGJveC5ib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gIGJveC53aWR0aCA9IHdpZHRoO1xuICBib3guaGVpZ2h0ID0gaGVpZ2h0O1xufVxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICBsZXQge3gsIHl9ID0gY2hhcnRBcmVhO1xuICBmb3IgKGNvbnN0IGxheW91dCBvZiBib3hlcykge1xuICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7Y291bnQ6IDEsIHBsYWNlZDogMCwgd2VpZ2h0OiAxfTtcbiAgICBjb25zdCB3ZWlnaHQgPSAobGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0KSB8fCAxO1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBjaGFydEFyZWEudyAqIHdlaWdodDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHN0YWNrLnNpemUgfHwgYm94LmhlaWdodDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB5ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB1c2VyUGFkZGluZy5sZWZ0LCB5LCBwYXJhbXMub3V0ZXJXaWR0aCAtIHVzZXJQYWRkaW5nLnJpZ2h0IC0gdXNlclBhZGRpbmcubGVmdCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCBjaGFydEFyZWEubGVmdCArIHN0YWNrLnBsYWNlZCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHk7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gd2lkdGg7XG4gICAgICB5ID0gYm94LmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhcnRBcmVhLmggKiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IHN0YWNrLnNpemUgfHwgYm94LndpZHRoO1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHggPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIHVzZXJQYWRkaW5nLnRvcCwgd2lkdGgsIHBhcmFtcy5vdXRlckhlaWdodCAtIHVzZXJQYWRkaW5nLmJvdHRvbSAtIHVzZXJQYWRkaW5nLnRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgY2hhcnRBcmVhLnRvcCArIHN0YWNrLnBsYWNlZCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHg7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gaGVpZ2h0O1xuICAgICAgeCA9IGJveC5yaWdodDtcbiAgICB9XG4gIH1cbiAgY2hhcnRBcmVhLnggPSB4O1xuICBjaGFydEFyZWEueSA9IHk7XG59XG5kZWZhdWx0cy5zZXQoJ2xheW91dCcsIHtcbiAgYXV0b1BhZGRpbmc6IHRydWUsXG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfVxufSk7XG52YXIgbGF5b3V0cyA9IHtcbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG4gICAgaXRlbS5mdWxsU2l6ZSA9IGl0ZW0uZnVsbFNpemUgfHwgZmFsc2U7XG4gICAgaXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG4gICAgaXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuICAgIGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiAwLFxuICAgICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICAgIGl0ZW0uZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9O1xuICAgIGNoYXJ0LmJveGVzLnB1c2goaXRlbSk7XG4gIH0sXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG4gIGNvbmZpZ3VyZShjaGFydCwgaXRlbSwgb3B0aW9ucykge1xuICAgIGl0ZW0uZnVsbFNpemUgPSBvcHRpb25zLmZ1bGxTaXplO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgIGl0ZW0ud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XG4gIH0sXG4gIHVwZGF0ZShjaGFydCwgd2lkdGgsIGhlaWdodCwgbWluUGFkZGluZykge1xuICAgIGlmICghY2hhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG4gICAgZWFjaChjaGFydC5ib3hlcywgYm94ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYm94LmJlZm9yZUxheW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBib3guYmVmb3JlTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIG91dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgb3V0ZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHZCb3hNYXhXaWR0aDogYXZhaWxhYmxlV2lkdGggLyAyIC8gdmlzaWJsZVZlcnRpY2FsQm94Q291bnQsXG4gICAgICBoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXG4gICAgfSk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIHBhZGRpbmcpO1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgdG9QYWRkaW5nKG1pblBhZGRpbmcpKTtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBhZGRpbmcsXG4gICAgICB3OiBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGg6IGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHg6IHBhZGRpbmcubGVmdCxcbiAgICAgIHk6IHBhZGRpbmcudG9wXG4gICAgfSwgcGFkZGluZyk7XG4gICAgY29uc3Qgc3RhY2tzID0gc2V0TGF5b3V0RGltcyh2ZXJ0aWNhbEJveGVzLmNvbmNhdChob3Jpem9udGFsQm94ZXMpLCBwYXJhbXMpO1xuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBpZiAoZml0Qm94ZXMoaG9yaXpvbnRhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSkge1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuICAgIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKTtcbiAgICBwbGFjZUJveGVzKGJveGVzLmxlZnRBbmRUb3AsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGNoYXJ0QXJlYS54ICs9IGNoYXJ0QXJlYS53O1xuICAgIGNoYXJ0QXJlYS55ICs9IGNoYXJ0QXJlYS5oO1xuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGNoYXJ0LmNoYXJ0QXJlYSA9IHtcbiAgICAgIGxlZnQ6IGNoYXJ0QXJlYS5sZWZ0LFxuICAgICAgdG9wOiBjaGFydEFyZWEudG9wLFxuICAgICAgcmlnaHQ6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLncsXG4gICAgICBib3R0b206IGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuaCxcbiAgICAgIGhlaWdodDogY2hhcnRBcmVhLmgsXG4gICAgICB3aWR0aDogY2hhcnRBcmVhLncsXG4gICAgfTtcbiAgICBlYWNoKGJveGVzLmNoYXJ0QXJlYSwgKGxheW91dCkgPT4ge1xuICAgICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICAgIE9iamVjdC5hc3NpZ24oYm94LCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgYm94LnVwZGF0ZShjaGFydEFyZWEudywgY2hhcnRBcmVhLmgsIHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9KTtcbiAgICB9KTtcbiAgfVxufTtcblxuY2xhc3MgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge31cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodClcbiAgICB9O1xuICB9XG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICB9XG59XG5cbmNsYXNzIEJhc2ljUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcub3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcbiAgfVxufVxuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gIHRvdWNoZW5kOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuICBwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG4gIHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgcG9pbnRlcnVwOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0JyxcbiAgcG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcbmNvbnN0IGlzTnVsbE9yRW1wdHkgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJyc7XG5mdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG4gIGNvbnN0IHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gIGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG4gICAgaW5pdGlhbDoge1xuICAgICAgaGVpZ2h0OiByZW5kZXJIZWlnaHQsXG4gICAgICB3aWR0aDogcmVuZGVyV2lkdGgsXG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHN0eWxlLndpZHRoXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuICBzdHlsZS5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgfHwgJ2JvcmRlci1ib3gnO1xuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJXaWR0aCkpIHtcbiAgICBjb25zdCBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcbiAgICBpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChhc3BlY3RSYXRpbyB8fCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcbiAgICAgIGlmIChkaXNwbGF5SGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW52YXM7XG59XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICBjb25zdCB7eCwgeX0gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBjaGFydCxcbiAgICBuYXRpdmU6IGV2ZW50LFxuICAgIHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuICAgIHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuICB9O1xufVxuZnVuY3Rpb24gbm9kZUxpc3RDb250YWlucyhub2RlTGlzdCwgY2FudmFzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xuICAgIGlmIChub2RlID09PSBjYW52YXMgfHwgbm9kZS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUF0dGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7XG4gIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICBpZiAoZHByID09PSBvbGREZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9sZERldmljZVBpeGVsUmF0aW8gPSBkcHI7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5mb3JFYWNoKChyZXNpemUsIGNoYXJ0KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBkcHIpIHtcbiAgICAgIHJlc2l6ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKSB7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5zZXQoY2hhcnQsIHJlc2l6ZSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUmVzaXplT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc2l6ZSA9IHRocm90dGxlZCgod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHcgPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgbGlzdGVuZXIod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHcgPCBjb250YWluZXIuY2xpZW50V2lkdGgpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9LCB3aW5kb3cpO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgY29uc3Qgd2lkdGggPSBlbnRyeS5jb250ZW50UmVjdC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcik7XG4gIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgcHJveHkgPSB0aHJvdHRsZWQoKGV2ZW50KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuICAgIH1cbiAgfSwgY2hhcnQsIChhcmdzKSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIHJldHVybiBbZXZlbnQsIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFldO1xuICB9KTtcbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG4gIHJldHVybiBwcm94eTtcbn1cbmNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jYW52YXMgPT09IGNhbnZhcykge1xuICAgICAgaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgaWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjYW52YXMuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfSk7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKTtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiBjcmVhdGVBdHRhY2hPYnNlcnZlcixcbiAgICAgIGRldGFjaDogY3JlYXRlRGV0YWNoT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IGNyZWF0ZVJlc2l6ZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgY3JlYXRlUHJveHlBbmRMaXN0ZW47XG4gICAgcHJveGllc1t0eXBlXSA9IGhhbmRsZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKSB7XG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBwcm94eSA9IHByb3hpZXNbdHlwZV07XG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgZGV0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IHJlbGVhc2VPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xuICAgIGhhbmRsZXIoY2hhcnQsIHR5cGUsIHByb3h5KTtcbiAgICBwcm94aWVzW3R5cGVdID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG4gIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICByZXR1cm4gZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gIH1cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGV0ZWN0UGxhdGZvcm0oY2FudmFzKSB7XG4gIGlmICghX2lzRG9tU3VwcG9ydGVkKCkgfHwgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykpIHtcbiAgICByZXR1cm4gQmFzaWNQbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gRG9tUGxhdGZvcm07XG59XG5cbnZhciBwbGF0Zm9ybXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5fZGV0ZWN0UGxhdGZvcm06IF9kZXRlY3RQbGF0Zm9ybSxcbkJhc2VQbGF0Zm9ybTogQmFzZVBsYXRmb3JtLFxuQmFzaWNQbGF0Zm9ybTogQmFzaWNQbGF0Zm9ybSxcbkRvbVBsYXRmb3JtOiBEb21QbGF0Zm9ybVxufSk7XG5cbmNvbnN0IHRyYW5zcGFyZW50ID0gJ3RyYW5zcGFyZW50JztcbmNvbnN0IGludGVycG9sYXRvcnMgPSB7XG4gIGJvb2xlYW4oZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmYWN0b3IgPiAwLjUgPyB0byA6IGZyb207XG4gIH0sXG4gIGNvbG9yKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICBjb25zdCBjMCA9IGNvbG9yKGZyb20gfHwgdHJhbnNwYXJlbnQpO1xuICAgIGNvbnN0IGMxID0gYzAudmFsaWQgJiYgY29sb3IodG8gfHwgdHJhbnNwYXJlbnQpO1xuICAgIHJldHVybiBjMSAmJiBjMS52YWxpZFxuICAgICAgPyBjMS5taXgoYzAsIGZhY3RvcikuaGV4U3RyaW5nKClcbiAgICAgIDogdG87XG4gIH0sXG4gIG51bWJlcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIGZhY3RvcjtcbiAgfVxufTtcbmNsYXNzIEFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNmZywgdGFyZ2V0LCBwcm9wLCB0bykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXTtcbiAgICB0byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICBjb25zdCBmcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2ZuID0gY2ZnLmZuIHx8IGludGVycG9sYXRvcnNbY2ZnLnR5cGUgfHwgdHlwZW9mIGZyb21dO1xuICAgIHRoaXMuX2Vhc2luZyA9IGVmZmVjdHNbY2ZnLmVhc2luZ10gfHwgZWZmZWN0cy5saW5lYXI7XG4gICAgdGhpcy5fc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgKyAoY2ZnLmRlbGF5IHx8IDApKTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsID0gTWF0aC5mbG9vcihjZmcuZHVyYXRpb24pO1xuICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9wcm9wID0gcHJvcDtcbiAgICB0aGlzLl9mcm9tID0gZnJvbTtcbiAgICB0aGlzLl90byA9IHRvO1xuICAgIHRoaXMuX3Byb21pc2VzID0gdW5kZWZpbmVkO1xuICB9XG4gIGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG4gIHVwZGF0ZShjZmcsIHRvLCBkYXRlKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wXTtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgICBjb25zdCByZW1haW4gPSB0aGlzLl9kdXJhdGlvbiAtIGVsYXBzZWQ7XG4gICAgICB0aGlzLl9zdGFydCA9IGRhdGU7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5tYXgocmVtYWluLCBjZmcuZHVyYXRpb24pKTtcbiAgICAgIHRoaXMuX3RvdGFsICs9IGVsYXBzZWQ7XG4gICAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICAgIHRoaXMuX3RvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgICAgdGhpcy5fZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgfVxuICB9XG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLnRpY2soRGF0ZS5ub3coKSk7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgfVxuICB9XG4gIHRpY2soZGF0ZSkge1xuICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICBjb25zdCBwcm9wID0gdGhpcy5fcHJvcDtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5fZnJvbTtcbiAgICBjb25zdCBsb29wID0gdGhpcy5fbG9vcDtcbiAgICBjb25zdCB0byA9IHRoaXMuX3RvO1xuICAgIGxldCBmYWN0b3I7XG4gICAgdGhpcy5fYWN0aXZlID0gZnJvbSAhPT0gdG8gJiYgKGxvb3AgfHwgKGVsYXBzZWQgPCBkdXJhdGlvbikpO1xuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0bztcbiAgICAgIHRoaXMuX25vdGlmeSh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsYXBzZWQgPCAwKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSBmcm9tO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmYWN0b3IgPSAoZWxhcHNlZCAvIGR1cmF0aW9uKSAlIDI7XG4gICAgZmFjdG9yID0gbG9vcCAmJiBmYWN0b3IgPiAxID8gMiAtIGZhY3RvciA6IGZhY3RvcjtcbiAgICBmYWN0b3IgPSB0aGlzLl9lYXNpbmcoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZmFjdG9yKSkpO1xuICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRoaXMuX2ZuKGZyb20sIHRvLCBmYWN0b3IpO1xuICB9XG4gIHdhaXQoKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCAodGhpcy5fcHJvbWlzZXMgPSBbXSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgcHJvbWlzZXMucHVzaCh7cmVzLCByZWp9KTtcbiAgICB9KTtcbiAgfVxuICBfbm90aWZ5KHJlc29sdmVkKSB7XG4gICAgY29uc3QgbWV0aG9kID0gcmVzb2x2ZWQgPyAncmVzJyA6ICdyZWonO1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZXNbaV1bbWV0aG9kXSgpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBudW1iZXJzID0gWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJywgJ3RlbnNpb24nXTtcbmNvbnN0IGNvbG9ycyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InLCAnYmFja2dyb3VuZENvbG9yJ107XG5kZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbicsIHtcbiAgZGVsYXk6IHVuZGVmaW5lZCxcbiAgZHVyYXRpb246IDEwMDAsXG4gIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gIGZuOiB1bmRlZmluZWQsXG4gIGZyb206IHVuZGVmaW5lZCxcbiAgbG9vcDogdW5kZWZpbmVkLFxuICB0bzogdW5kZWZpbmVkLFxuICB0eXBlOiB1bmRlZmluZWQsXG59KTtcbmNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5hbmltYXRpb24pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbicsIHtcbiAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgX2luZGV4YWJsZTogZmFsc2UsXG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ29uUHJvZ3Jlc3MnICYmIG5hbWUgIT09ICdvbkNvbXBsZXRlJyAmJiBuYW1lICE9PSAnZm4nLFxufSk7XG5kZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbnMnLCB7XG4gIGNvbG9yczoge1xuICAgIHR5cGU6ICdjb2xvcicsXG4gICAgcHJvcGVydGllczogY29sb3JzXG4gIH0sXG4gIG51bWJlcnM6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBwcm9wZXJ0aWVzOiBudW1iZXJzXG4gIH0sXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb25zJywge1xuICBfZmFsbGJhY2s6ICdhbmltYXRpb24nLFxufSk7XG5kZWZhdWx0cy5zZXQoJ3RyYW5zaXRpb25zJywge1xuICBhY3RpdmU6IHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDBcbiAgICB9XG4gIH0sXG4gIHJlc2l6ZToge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDBcbiAgICB9XG4gIH0sXG4gIHNob3c6IHtcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG4gIGhpZGU6IHtcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgdG86ICd0cmFuc3BhcmVudCdcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZm46IHYgPT4gdiB8IDBcbiAgICAgIH0sXG4gICAgfVxuICB9XG59KTtcbmNsYXNzIEFuaW1hdGlvbnMge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgY29uZmlnKSB7XG4gICAgdGhpcy5fY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29uZmlndXJlKGNvbmZpZyk7XG4gIH1cbiAgY29uZmlndXJlKGNvbmZpZykge1xuICAgIGlmICghaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGNmZyA9IGNvbmZpZ1trZXldO1xuICAgICAgaWYgKCFpc09iamVjdChjZmcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmVkID0ge307XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBhbmltYXRpb25PcHRpb25zKSB7XG4gICAgICAgIHJlc29sdmVkW29wdGlvbl0gPSBjZmdbb3B0aW9uXTtcbiAgICAgIH1cbiAgICAgIChpc0FycmF5KGNmZy5wcm9wZXJ0aWVzKSAmJiBjZmcucHJvcGVydGllcyB8fCBba2V5XSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAocHJvcCA9PT0ga2V5IHx8ICFhbmltYXRlZFByb3BzLmhhcyhwcm9wKSkge1xuICAgICAgICAgIGFuaW1hdGVkUHJvcHMuc2V0KHByb3AsIHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IHZhbHVlcy5vcHRpb25zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyhvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICBpZiAobmV3T3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICBhd2FpdEFsbCh0YXJnZXQub3B0aW9ucy4kYW5pbWF0aW9ucywgbmV3T3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgIH0sICgpID0+IHtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBfY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBydW5uaW5nID0gdGFyZ2V0LiRhbmltYXRpb25zIHx8ICh0YXJnZXQuJGFuaW1hdGlvbnMgPSB7fSk7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xuICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHByb3BzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAocHJvcC5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKC4uLnRoaXMuX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbcHJvcF07XG4gICAgICBsZXQgYW5pbWF0aW9uID0gcnVubmluZ1twcm9wXTtcbiAgICAgIGNvbnN0IGNmZyA9IGFuaW1hdGVkUHJvcHMuZ2V0KHByb3ApO1xuICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICBpZiAoY2ZnICYmIGFuaW1hdGlvbi5hY3RpdmUoKSkge1xuICAgICAgICAgIGFuaW1hdGlvbi51cGRhdGUoY2ZnLCB2YWx1ZSwgZGF0ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNmZyB8fCAhY2ZnLmR1cmF0aW9uKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJ1bm5pbmdbcHJvcF0gPSBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGNmZywgdGFyZ2V0LCBwcm9wLCB2YWx1ZSk7XG4gICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgdXBkYXRlKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuX3Byb3BlcnRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHZhbHVlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKTtcbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGFuaW1hdG9yLmFkZCh0aGlzLl9jaGFydCwgYW5pbWF0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGF3YWl0QWxsKGFuaW1hdGlvbnMsIHByb3BlcnRpZXMpIHtcbiAgY29uc3QgcnVubmluZyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFuaW0gPSBhbmltYXRpb25zW2tleXNbaV1dO1xuICAgIGlmIChhbmltICYmIGFuaW0uYWN0aXZlKCkpIHtcbiAgICAgIHJ1bm5pbmcucHVzaChhbmltLndhaXQoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChydW5uaW5nKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucykge1xuICBpZiAoIW5ld09wdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9wdGlvbnMgPSB0YXJnZXQub3B0aW9ucztcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyRzaGFyZWQ6IGZhbHNlLCAkYW5pbWF0aW9uczoge319KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gc2NhbGVDbGlwKHNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJldmVyc2UgPSBvcHRzLnJldmVyc2U7XG4gIGNvbnN0IG1pbiA9IG9wdHMubWluID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICBjb25zdCBtYXggPSBvcHRzLm1heCA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcmV2ZXJzZSA/IG1heCA6IG1pbixcbiAgICBlbmQ6IHJldmVyc2UgPyBtaW4gOiBtYXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGlwKHhTY2FsZSwgeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgaWYgKGFsbG93ZWRPdmVyZmxvdyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeCA9IHNjYWxlQ2xpcCh4U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIGNvbnN0IHkgPSBzY2FsZUNsaXAoeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICByZXR1cm4ge1xuICAgIHRvcDogeS5lbmQsXG4gICAgcmlnaHQ6IHguZW5kLFxuICAgIGJvdHRvbTogeS5zdGFydCxcbiAgICBsZWZ0OiB4LnN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiB0b0NsaXAodmFsdWUpIHtcbiAgbGV0IHQsIHIsIGIsIGw7XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB0ID0gdmFsdWUudG9wO1xuICAgIHIgPSB2YWx1ZS5yaWdodDtcbiAgICBiID0gdmFsdWUuYm90dG9tO1xuICAgIGwgPSB2YWx1ZS5sZWZ0O1xuICB9IGVsc2Uge1xuICAgIHQgPSByID0gYiA9IGwgPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcDogdCxcbiAgICByaWdodDogcixcbiAgICBib3R0b206IGIsXG4gICAgbGVmdDogbCxcbiAgICBkaXNhYmxlZDogdmFsdWUgPT09IGZhbHNlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgZmlsdGVyVmlzaWJsZSkge1xuICBjb25zdCBrZXlzID0gW107XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXlzLnB1c2gobWV0YXNldHNbaV0uaW5kZXgpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIGRzSW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBrZXlzID0gc3RhY2sua2V5cztcbiAgY29uc3Qgc2luZ2xlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZSc7XG4gIGxldCBpLCBpbGVuLCBkYXRhc2V0SW5kZXgsIG90aGVyVmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICBpZiAoZGF0YXNldEluZGV4ID09PSBkc0luZGV4KSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChpc051bWJlckZpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCAodmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSkge1xuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICBjb25zdCBhZGF0YSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gIGxldCBpLCBpbGVuLCBrZXk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgYWRhdGFbaV0gPSB7XG4gICAgICB4OiBrZXksXG4gICAgICB5OiBkYXRhW2tleV1cbiAgICB9O1xuICB9XG4gIHJldHVybiBhZGF0YTtcbn1cbmZ1bmN0aW9uIGlzU3RhY2tlZChzY2FsZSwgbWV0YSkge1xuICBjb25zdCBzdGFja2VkID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICByZXR1cm4gc3RhY2tlZCB8fCAoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBnZXRTdGFja0tleShpbmRleFNjYWxlLCB2YWx1ZVNjYWxlLCBtZXRhKSB7XG4gIHJldHVybiBgJHtpbmRleFNjYWxlLmlkfS4ke3ZhbHVlU2NhbGUuaWR9LiR7bWV0YS5zdGFjayB8fCBtZXRhLnR5cGV9YDtcbn1cbmZ1bmN0aW9uIGdldFVzZXJCb3VuZHMoc2NhbGUpIHtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbkRlZmluZWQgPyBtaW4gOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgbWF4OiBtYXhEZWZpbmVkID8gbWF4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywgc3RhY2tLZXksIGluZGV4VmFsdWUpIHtcbiAgY29uc3Qgc3ViU3RhY2sgPSBzdGFja3Nbc3RhY2tLZXldIHx8IChzdGFja3Nbc3RhY2tLZXldID0ge30pO1xuICByZXR1cm4gc3ViU3RhY2tbaW5kZXhWYWx1ZV0gfHwgKHN1YlN0YWNrW2luZGV4VmFsdWVdID0ge30pO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBwb3NpdGl2ZSwgdHlwZSkge1xuICBmb3IgKGNvbnN0IG1ldGEgb2YgdlNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpLnJldmVyc2UoKSkge1xuICAgIGNvbnN0IHZhbHVlID0gc3RhY2tbbWV0YS5pbmRleF07XG4gICAgaWYgKChwb3NpdGl2ZSAmJiB2YWx1ZSA+IDApIHx8ICghcG9zaXRpdmUgJiYgdmFsdWUgPCAwKSkge1xuICAgICAgcmV0dXJuIG1ldGEuaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlU3RhY2tzKGNvbnRyb2xsZXIsIHBhcnNlZCkge1xuICBjb25zdCB7Y2hhcnQsIF9jYWNoZWRNZXRhOiBtZXRhfSA9IGNvbnRyb2xsZXI7XG4gIGNvbnN0IHN0YWNrcyA9IGNoYXJ0Ll9zdGFja3MgfHwgKGNoYXJ0Ll9zdGFja3MgPSB7fSk7XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgaW5kZXg6IGRhdGFzZXRJbmRleH0gPSBtZXRhO1xuICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICBjb25zdCBrZXkgPSBnZXRTdGFja0tleShpU2NhbGUsIHZTY2FsZSwgbWV0YSk7XG4gIGNvbnN0IGlsZW4gPSBwYXJzZWQubGVuZ3RoO1xuICBsZXQgc3RhY2s7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IHBhcnNlZFtpXTtcbiAgICBjb25zdCB7W2lBeGlzXTogaW5kZXgsIFt2QXhpc106IHZhbHVlfSA9IGl0ZW07XG4gICAgY29uc3QgaXRlbVN0YWNrcyA9IGl0ZW0uX3N0YWNrcyB8fCAoaXRlbS5fc3RhY2tzID0ge30pO1xuICAgIHN0YWNrID0gaXRlbVN0YWNrc1t2QXhpc10gPSBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywga2V5LCBpbmRleCk7XG4gICAgc3RhY2tbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUsIG1ldGEudHlwZSk7XG4gICAgc3RhY2suX2JvdHRvbSA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgZmFsc2UsIG1ldGEudHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZpcnN0U2NhbGVJZChjaGFydCwgYXhpcykge1xuICBjb25zdCBzY2FsZXMgPSBjaGFydC5zY2FsZXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzY2FsZXMpLmZpbHRlcihrZXkgPT4gc2NhbGVzW2tleV0uYXhpcyA9PT0gYXhpcykuc2hpZnQoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFzZXRDb250ZXh0KHBhcmVudCwgaW5kZXgpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LFxuICAgIHtcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBkYXRhc2V0OiB1bmRlZmluZWQsXG4gICAgICBkYXRhc2V0SW5kZXg6IGluZGV4LFxuICAgICAgaW5kZXgsXG4gICAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgICB0eXBlOiAnZGF0YXNldCdcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhQ29udGV4dChwYXJlbnQsIGluZGV4LCBlbGVtZW50KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBwYXJzZWQ6IHVuZGVmaW5lZCxcbiAgICByYXc6IHVuZGVmaW5lZCxcbiAgICBlbGVtZW50LFxuICAgIGluZGV4LFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICB0eXBlOiAnZGF0YSdcbiAgfSk7XG59XG5mdW5jdGlvbiBjbGVhclN0YWNrcyhtZXRhLCBpdGVtcykge1xuICBjb25zdCBkYXRhc2V0SW5kZXggPSBtZXRhLmNvbnRyb2xsZXIuaW5kZXg7XG4gIGNvbnN0IGF4aXMgPSBtZXRhLnZTY2FsZSAmJiBtZXRhLnZTY2FsZS5heGlzO1xuICBpZiAoIWF4aXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaXRlbXMgPSBpdGVtcyB8fCBtZXRhLl9wYXJzZWQ7XG4gIGZvciAoY29uc3QgcGFyc2VkIG9mIGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gcGFyc2VkLl9zdGFja3M7XG4gICAgaWYgKCFzdGFja3MgfHwgc3RhY2tzW2F4aXNdID09PSB1bmRlZmluZWQgfHwgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF07XG4gIH1cbn1cbmNvbnN0IGlzRGlyZWN0VXBkYXRlTW9kZSA9IChtb2RlKSA9PiBtb2RlID09PSAncmVzZXQnIHx8IG1vZGUgPT09ICdub25lJztcbmNvbnN0IGNsb25lSWZOb3RTaGFyZWQgPSAoY2FjaGVkLCBzaGFyZWQpID0+IHNoYXJlZCA/IGNhY2hlZCA6IE9iamVjdC5hc3NpZ24oe30sIGNhY2hlZCk7XG5jb25zdCBjcmVhdGVTdGFjayA9IChjYW5TdGFjaywgbWV0YSwgY2hhcnQpID0+IGNhblN0YWNrICYmICFtZXRhLmhpZGRlbiAmJiBtZXRhLl9zdGFja2VkXG4gICYmIHtrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksIHZhbHVlczogbnVsbH07XG5jbGFzcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fY3R4ID0gY2hhcnQuY3R4O1xuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgICB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCk7XG4gICAgdGhpcy5fdHlwZSA9IHRoaXMuX2NhY2hlZE1ldGEudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGFyc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2JqZWN0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaGFyZWRPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMubGlua1NjYWxlcygpO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgfVxuICB1cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgY2hvb3NlSWQgPSAoYXhpcywgeCwgeSwgcikgPT4gYXhpcyA9PT0gJ3gnID8geCA6IGF4aXMgPT09ICdyJyA/IHIgOiB5O1xuICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICBjb25zdCB5aWQgPSBtZXRhLnlBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnlBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3knKSk7XG4gICAgY29uc3QgcmlkID0gbWV0YS5yQXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC5yQXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICdyJykpO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgIGNvbnN0IGlpZCA9IG1ldGEuaUF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeGlkLCB5aWQsIHJpZCk7XG4gICAgY29uc3QgdmlkID0gbWV0YS52QXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB5aWQsIHhpZCwgcmlkKTtcbiAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xuICAgIG1ldGEueVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHlpZCk7XG4gICAgbWV0YS5yU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQocmlkKTtcbiAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xuICAgIG1ldGEudlNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHZpZCk7XG4gIH1cbiAgZ2V0RGF0YXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICB9XG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cbiAgZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuICB9XG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHNjYWxlID09PSBtZXRhLmlTY2FsZVxuICAgICAgPyBtZXRhLnZTY2FsZVxuICAgICAgOiBtZXRhLmlTY2FsZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoJ3Jlc2V0Jyk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICB9XG4gIH1cbiAgX2RhdGFDaGVjaygpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuZGF0YSB8fCAoZGF0YXNldC5kYXRhID0gW10pO1xuICAgIGNvbnN0IF9kYXRhID0gdGhpcy5fZGF0YTtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChfZGF0YSAhPT0gZGF0YSkge1xuICAgICAgaWYgKF9kYXRhKSB7XG4gICAgICAgIHVubGlzdGVuQXJyYXlFdmVudHMoX2RhdGEsIHRoaXMpO1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuICAgIGNvbnN0IG9sZFN0YWNrZWQgPSBtZXRhLl9zdGFja2VkO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICB9XG4gICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0U2NvcGVLZXlzKHRoaXMuX3R5cGUpO1xuICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cywgdHJ1ZSk7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMuX3BhcnNpbmcgPSB0aGlzLm9wdGlvbnMucGFyc2luZztcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICB9XG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YTogbWV0YSwgX2RhdGE6IGRhdGF9ID0gdGhpcztcbiAgICBjb25zdCB7aVNjYWxlLCBfc3RhY2tlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgbGV0IHNvcnRlZCA9IHN0YXJ0ID09PSAwICYmIGNvdW50ID09PSBkYXRhLmxlbmd0aCA/IHRydWUgOiBtZXRhLl9zb3J0ZWQ7XG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiA9ICgpID0+IGN1cltpQXhpc10gPT09IG51bGwgfHwgKHByZXYgJiYgY3VyW2lBeGlzXSA8IHByZXZbaUF4aXNdKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpICsgc3RhcnRdID0gY3VyID0gcGFyc2VkW2ldO1xuICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgaWYgKGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2KCkpIHtcbiAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZXRhLl9zb3J0ZWQgPSBzb3J0ZWQ7XG4gICAgfVxuICAgIGlmIChfc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIHBhcnNlZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgW2lBeGlzXTogc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpbmRleF0sIGluZGV4KSxcbiAgICAgICAgW3ZBeGlzXTogdlNjYWxlLnBhcnNlKGRhdGFbaW5kZXhdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKGl0ZW1bMF0sIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKGl0ZW1bMV0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHhBeGlzS2V5KSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB5QXhpc0tleSksIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRQYXJzZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkW2luZGV4XTtcbiAgfVxuICBnZXREYXRhRWxlbWVudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICB9XG4gIGFwcGx5U3RhY2soc2NhbGUsIHBhcnNlZCwgbW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBjb25zdCBzdGFjayA9IHtcbiAgICAgIGtleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSxcbiAgICAgIHZhbHVlczogcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc11cbiAgICB9O1xuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkVmFsdWUgPT09IG51bGwgPyBOYU4gOiBwYXJzZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KTtcbiAgICB9XG4gICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCB2YWx1ZSk7XG4gICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gIH1cbiAgZ2V0TWluTWF4KHNjYWxlLCBjYW5TdGFjaykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gbWV0YS5fc29ydGVkICYmIHNjYWxlID09PSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xuICAgIGNvbnN0IHN0YWNrID0gY3JlYXRlU3RhY2soY2FuU3RhY2ssIG1ldGEsIHRoaXMuY2hhcnQpO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgY29uc3Qge21pbjogb3RoZXJNaW4sIG1heDogb3RoZXJNYXh9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcbiAgICBsZXQgaSwgcGFyc2VkO1xuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNOdW1iZXJGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIGdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VkW2ldW3NjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBpU2NhbGUgPyAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pIDogJycsXG4gICAgICB2YWx1ZTogdlNjYWxlID8gJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKSA6ICcnXG4gICAgfTtcbiAgfVxuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHt9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IGFjdGl2ZSA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fZHJhd1N0YXJ0IHx8IDA7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9kcmF3Q291bnQgfHwgKGVsZW1lbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBjb25zdCBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCA9IHRoaXMub3B0aW9ucy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcDtcbiAgICBsZXQgaTtcbiAgICBpZiAobWV0YS5kYXRhc2V0KSB7XG4gICAgICBtZXRhLmRhdGFzZXQuZHJhdyhjdHgsIGFyZWEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7ICsraSkge1xuICAgICAgYWN0aXZlW2ldLmRyYXcoY3R4LCBhcmVhKTtcbiAgICB9XG4gIH1cbiAgZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xuICAgIGNvbnN0IG1vZGUgPSBhY3RpdmUgPyAnYWN0aXZlJyA6ICdkZWZhdWx0JztcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXRcbiAgICAgID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpXG4gICAgICA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCB8fCAwLCBtb2RlKTtcbiAgfVxuICBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8XG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICBjb250ZXh0LnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgIGNvbnRleHQucmF3ID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gdGhpcy4kY29udGV4dCB8fFxuICAgICAgICAodGhpcy4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSk7XG4gICAgICBjb250ZXh0LmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB9XG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIHJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhc2V0RWxlbWVudFR5cGUuaWQsIG1vZGUpO1xuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YUVsZW1lbnRUeXBlLmlkLCBtb2RlLCBpbmRleCk7XG4gIH1cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb25maWcucmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyk7XG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMuJHNoYXJlZCA9IHNoYXJpbmc7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGNsb25lSWZOb3RTaGFyZWQodmFsdWVzLCBzaGFyaW5nKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgIHJldHVybiAhc2hhcmVkT3B0aW9ucyB8fCBpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG4gIF9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKSB7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyA9IHRoaXMuX3NoYXJlZE9wdGlvbnM7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB8fCAoc2hhcmVkT3B0aW9ucyAhPT0gcHJldmlvdXNseVNoYXJlZE9wdGlvbnMpO1xuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgIHJldHVybiB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9O1xuICB9XG4gIHVwZGF0ZUVsZW1lbnQoZWxlbWVudCwgaW5kZXgsIHByb3BlcnRpZXMsIG1vZGUpIHtcbiAgICBpZiAoaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSkudXBkYXRlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAoc2hhcmVkT3B0aW9ucyAmJiAhaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCBtb2RlLCBhY3RpdmUpIHtcbiAgICBlbGVtZW50LmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRTdHlsZShpbmRleCwgYWN0aXZlKTtcbiAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSwgYWN0aXZlKS51cGRhdGUoZWxlbWVudCwge1xuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlSG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCBmYWxzZSk7XG4gIH1cbiAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgfVxuICBfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBfc2V0RGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgZm9yIChjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSBvZiB0aGlzLl9zeW5jTGlzdCkge1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obnVtRGF0YSwgbnVtTWV0YSk7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG4gICAgaWYgKG51bURhdGEgPiBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9pbnNlcnRFbGVtZW50cyhudW1NZXRhLCBudW1EYXRhIC0gbnVtTWV0YSwgcmVzZXROZXdFbGVtZW50cyk7XG4gICAgfSBlbHNlIGlmIChudW1EYXRhIDwgbnVtTWV0YSkge1xuICAgICAgdGhpcy5fcmVtb3ZlRWxlbWVudHMobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgfVxuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBtb3ZlID0gKGFycikgPT4ge1xuICAgICAgYXJyLmxlbmd0aCArPSBjb3VudDtcbiAgICAgIGZvciAoaSA9IGFyci5sZW5ndGggLSAxOyBpID49IGVuZDsgaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGFycltpIC0gY291bnRdO1xuICAgICAgfVxuICAgIH07XG4gICAgbW92ZShkYXRhKTtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcbiAgICBpZiAocmVzZXROZXdFbGVtZW50cykge1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhkYXRhLCBzdGFydCwgY291bnQsICdyZXNldCcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9XG4gIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IG1ldGEuX3BhcnNlZC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgX3N5bmMoYXJncykge1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICB0aGlzLl9zeW5jTGlzdC5wdXNoKGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSA9IGFyZ3M7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuY2hhcnQuX2RhdGFDaGFuZ2VzLnB1c2goW3RoaXMuaW5kZXgsIC4uLmFyZ3NdKTtcbiAgfVxuICBfb25EYXRhUHVzaCgpIHtcbiAgICBjb25zdCBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50XSk7XG4gIH1cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuICBfb25EYXRhU2hpZnQoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIDAsIDFdKTtcbiAgfVxuICBfb25EYXRhU3BsaWNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChuZXdDb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHN0YXJ0LCBuZXdDb3VudF0pO1xuICAgIH1cbiAgfVxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG5EYXRhc2V0Q29udHJvbGxlci5kZWZhdWx0cyA9IHt9O1xuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuZGF0YUVsZW1lbnRUeXBlID0gbnVsbDtcblxuY2xhc3MgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuICBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodGhpcy54KSAmJiBpc051bWJlcih0aGlzLnkpO1xuICB9XG4gIGdldFByb3BzKHByb3BzLCBmaW5hbCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBpZiAoIWZpbmFsIHx8ICFhbmltcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuRWxlbWVudC5kZWZhdWx0cyA9IHt9O1xuRWxlbWVudC5kZWZhdWx0Um91dGVzID0gdW5kZWZpbmVkO1xuXG5jb25zdCBmb3JtYXR0ZXJzID0ge1xuICB2YWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6ICcnICsgdmFsdWU7XG4gIH0sXG4gIG51bWVyaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlO1xuICAgIGxldCBub3RhdGlvbjtcbiAgICBsZXQgZGVsdGEgPSB0aWNrVmFsdWU7XG4gICAgaWYgKHRpY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXS52YWx1ZSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlKSk7XG4gICAgICBpZiAobWF4VGljayA8IDFlLTQgfHwgbWF4VGljayA+IDFlKzE1KSB7XG4gICAgICAgIG5vdGF0aW9uID0gJ3NjaWVudGlmaWMnO1xuICAgICAgfVxuICAgICAgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKTtcbiAgICB9XG4gICAgY29uc3QgbG9nRGVsdGEgPSBsb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuICAgIGNvbnN0IG51bURlY2ltYWwgPSBNYXRoLm1heChNYXRoLm1pbigtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpLCAyMCksIDApO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7bm90YXRpb24sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodGlja1ZhbHVlLCBsb2NhbGUsIG9wdGlvbnMpO1xuICB9LFxuICBsb2dhcml0aG1pYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSkpO1xuICAgIGlmIChyZW1haW4gPT09IDEgfHwgcmVtYWluID09PSAyIHx8IHJlbWFpbiA9PT0gNSkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcykge1xuICBsZXQgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0udmFsdWUgLSB0aWNrc1sxXS52YWx1ZSA6IHRpY2tzWzFdLnZhbHVlIC0gdGlja3NbMF0udmFsdWU7XG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgIGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cbnZhciBUaWNrcyA9IHtmb3JtYXR0ZXJzfTtcblxuZGVmYXVsdHMuc2V0KCdzY2FsZScsIHtcbiAgZGlzcGxheTogdHJ1ZSxcbiAgb2Zmc2V0OiBmYWxzZSxcbiAgcmV2ZXJzZTogZmFsc2UsXG4gIGJlZ2luQXRaZXJvOiBmYWxzZSxcbiAgYm91bmRzOiAndGlja3MnLFxuICBncmFjZTogMCxcbiAgZ3JpZDoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGRyYXdCb3JkZXI6IHRydWUsXG4gICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgIGRyYXdUaWNrczogdHJ1ZSxcbiAgICB0aWNrTGVuZ3RoOiA4LFxuICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgIHRpY2tDb2xvcjogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMuY29sb3IsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjAsXG4gICAgYm9yZGVyV2lkdGg6IDFcbiAgfSxcbiAgdGl0bGU6IHtcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICB0ZXh0OiAnJyxcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0b3A6IDQsXG4gICAgICBib3R0b206IDRcbiAgICB9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgbWluUm90YXRpb246IDAsXG4gICAgbWF4Um90YXRpb246IDUwLFxuICAgIG1pcnJvcjogZmFsc2UsXG4gICAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICAgIHRleHRTdHJva2VDb2xvcjogJycsXG4gICAgcGFkZGluZzogMyxcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGF1dG9Ta2lwOiB0cnVlLFxuICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICBsYWJlbE9mZnNldDogMCxcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgbWlub3I6IHt9LFxuICAgIG1ham9yOiB7fSxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgY3Jvc3NBbGlnbjogJ25lYXInLFxuICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICBiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KScsXG4gICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICB9XG59KTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2NvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnYm9yZGVyQ29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGl0bGUnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gIF9mYWxsYmFjazogZmFsc2UsXG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnYmVmb3JlJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYWZ0ZXInKSAmJiBuYW1lICE9PSAnY2FsbGJhY2snICYmIG5hbWUgIT09ICdwYXJzZXInLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcsXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZXMnLCB7XG4gIF9mYWxsYmFjazogJ3NjYWxlJyxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnICYmIG5hbWUgIT09ICdjYWxsYmFjaycsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyxcbn0pO1xuXG5mdW5jdGlvbiBhdXRvU2tpcChzY2FsZSwgdGlja3MpIHtcbiAgY29uc3QgdGlja09wdHMgPSBzY2FsZS5vcHRpb25zLnRpY2tzO1xuICBjb25zdCB0aWNrc0xpbWl0ID0gdGlja09wdHMubWF4VGlja3NMaW1pdCB8fCBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSk7XG4gIGNvbnN0IG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XG4gIGNvbnN0IG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBjb25zdCBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xuICBjb25zdCBuZXdUaWNrcyA9IFtdO1xuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xuICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBjb25zdCBzcGFjaW5nID0gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KTtcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbnVtTWFqb3JJbmRpY2VzIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG4gICAgfVxuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBsYXN0LCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyB0aWNrcy5sZW5ndGggOiBsYXN0ICsgYXZnTWFqb3JTcGFjaW5nKTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcpO1xuICByZXR1cm4gbmV3VGlja3M7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSkge1xuICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcbiAgY29uc3QgdGlja0xlbmd0aCA9IHNjYWxlLl90aWNrU2l6ZSgpO1xuICBjb25zdCBtYXhTY2FsZSA9IHNjYWxlLl9sZW5ndGggLyB0aWNrTGVuZ3RoICsgKG9mZnNldCA/IDAgOiAxKTtcbiAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4obWF4U2NhbGUsIG1heENoYXJ0KSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpIHtcbiAgY29uc3QgZXZlbk1ham9yU3BhY2luZyA9IGdldEV2ZW5TcGFjaW5nKG1ham9ySW5kaWNlcyk7XG4gIGNvbnN0IHNwYWNpbmcgPSB0aWNrcy5sZW5ndGggLyB0aWNrc0xpbWl0O1xuICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG4gIH1cbiAgY29uc3QgZmFjdG9ycyA9IF9mYWN0b3JpemUoZXZlbk1ham9yU3BhY2luZyk7XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gZmFjdG9ycy5sZW5ndGggLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgY29uc3QgZmFjdG9yID0gZmFjdG9yc1tpXTtcbiAgICBpZiAoZmFjdG9yID4gc3BhY2luZykge1xuICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xufVxuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIGlmICh0aWNrc1tpXS5tYWpvcikge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBzcGFjaW5nKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBuZXh0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBsZXQgaTtcbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xuICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbih2YWx1ZU9yRGVmYXVsdChtYWpvckVuZCwgdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgaWYgKG1ham9yRW5kKSB7XG4gICAgbGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xuICAgIHNwYWNpbmcgPSBsZW5ndGggLyBNYXRoLmZsb29yKGxlbmd0aCAvIHNwYWNpbmcpO1xuICB9XG4gIG5leHQgPSBzdGFydDtcbiAgd2hpbGUgKG5leHQgPCAwKSB7XG4gICAgY291bnQrKztcbiAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gIH1cbiAgZm9yIChpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpLCBkaWZmO1xuICBpZiAobGVuIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGRpZmYgPSBhcnJbMF0sIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldIC0gYXJyW2kgLSAxXSAhPT0gZGlmZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn1cblxuY29uc3QgcmV2ZXJzZUFsaWduID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6IGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogYWxpZ247XG5jb25zdCBvZmZzZXRGcm9tRWRnZSA9IChzY2FsZSwgZWRnZSwgb2Zmc2V0KSA9PiBlZGdlID09PSAndG9wJyB8fCBlZGdlID09PSAnbGVmdCcgPyBzY2FsZVtlZGdlXSArIG9mZnNldCA6IHNjYWxlW2VkZ2VdIC0gb2Zmc2V0O1xuZnVuY3Rpb24gc2FtcGxlKGFyciwgbnVtSXRlbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGxlbjsgaSArPSBpbmNyZW1lbnQpIHtcbiAgICByZXN1bHQucHVzaChhcnJbTWF0aC5mbG9vcihpKV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgY29uc3QgdmFsaWRJbmRleCA9IE1hdGgubWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgY29uc3Qgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcbiAgY29uc3QgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xuICBjb25zdCBlcHNpbG9uID0gMWUtNjtcbiAgbGV0IGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKG9mZnNldEdyaWRMaW5lcykge1xuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIG9mZnNldCA9IE1hdGgubWF4KGxpbmVWYWx1ZSAtIHN0YXJ0LCBlbmQgLSBsaW5lVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIG9mZnNldCA9IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gKGxpbmVWYWx1ZSAtIHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4IC0gMSkpIC8gMjtcbiAgICB9XG4gICAgbGluZVZhbHVlICs9IHZhbGlkSW5kZXggPCBpbmRleCA/IG9mZnNldCA6IC1vZmZzZXQ7XG4gICAgaWYgKGxpbmVWYWx1ZSA8IHN0YXJ0IC0gZXBzaWxvbiB8fCBsaW5lVmFsdWUgPiBlbmQgKyBlcHNpbG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5lVmFsdWU7XG59XG5mdW5jdGlvbiBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCkge1xuICBlYWNoKGNhY2hlcywgKGNhY2hlKSA9PiB7XG4gICAgY29uc3QgZ2MgPSBjYWNoZS5nYztcbiAgICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gICAgbGV0IGk7XG4gICAgaWYgKGdjTGVuID4gbGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47ICsraSkge1xuICAgICAgICBkZWxldGUgY2FjaGUuZGF0YVtnY1tpXV07XG4gICAgICB9XG4gICAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRyYXdUaWNrcyA/IG9wdGlvbnMudGlja0xlbmd0aCA6IDA7XG59XG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb250LCBmYWxsYmFjayk7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KG9wdGlvbnMudGV4dCkgPyBvcHRpb25zLnRleHQubGVuZ3RoIDogMTtcbiAgcmV0dXJuIChsaW5lcyAqIGZvbnQubGluZUhlaWdodCkgKyBwYWRkaW5nLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUaWNrQ29udGV4dChwYXJlbnQsIGluZGV4LCB0aWNrKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRpY2ssXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3RpY2snXG4gIH0pO1xufVxuZnVuY3Rpb24gdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpIHtcbiAgbGV0IHJldCA9IF90b0xlZnRSaWdodENlbnRlcihhbGlnbik7XG4gIGlmICgocmV2ZXJzZSAmJiBwb3NpdGlvbiAhPT0gJ3JpZ2h0JykgfHwgKCFyZXZlcnNlICYmIHBvc2l0aW9uID09PSAncmlnaHQnKSkge1xuICAgIHJldCA9IHJldmVyc2VBbGlnbihyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0aXRsZUFyZ3Moc2NhbGUsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKSB7XG4gIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGNoYXJ0fSA9IHNjYWxlO1xuICBjb25zdCB7Y2hhcnRBcmVhLCBzY2FsZXN9ID0gY2hhcnQ7XG4gIGxldCByb3RhdGlvbiA9IDA7XG4gIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWSA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWSA9IChjaGFydEFyZWEuYm90dG9tICsgY2hhcnRBcmVhLnRvcCkgLyAyICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVkgPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB9IGVsc2Uge1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVggPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWCA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICByb3RhdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAtSEFMRl9QSSA6IEhBTEZfUEk7XG4gIH1cbiAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbn1cbmNsYXNzIFNjYWxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIHRoaXMuY2hhcnQgPSBjZmcuY2hhcnQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JhbmdlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGlja3MgPSBbXTtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICByZXR1cm4gcmF3O1xuICB9XG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc051bWJlckZpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc051bWJlckZpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG4gIGdldE1pbk1heChjYW5TdGFjaykge1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQpIHtcbiAgICAgIHJldHVybiB7bWluLCBtYXh9O1xuICAgIH1cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcmFuZ2UgPSBtZXRhc1tpXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCBjYW5TdGFjayk7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByYW5nZS5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcmFuZ2UubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWluID0gbWF4RGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtYXggOiBtaW47XG4gICAgbWF4ID0gbWluRGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtaW4gOiBtYXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KG1pbiwgZmluaXRlT3JEZWZhdWx0KG1heCwgbWluKSksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChtYXgsIGZpbml0ZU9yRGVmYXVsdChtaW4sIG1heCkpXG4gICAgfTtcbiAgfVxuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnBhZGRpbmdMZWZ0IHx8IDAsXG4gICAgICB0b3A6IHRoaXMucGFkZGluZ1RvcCB8fCAwLFxuICAgICAgcmlnaHQ6IHRoaXMucGFkZGluZ1JpZ2h0IHx8IDAsXG4gICAgICBib3R0b206IHRoaXMucGFkZGluZ0JvdHRvbSB8fCAwXG4gICAgfTtcbiAgfVxuICBnZXRUaWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrcztcbiAgfVxuICBnZXRMYWJlbHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICB9XG4gIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvLCBncmFjZSwgdGlja3M6IHRpY2tPcHRzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzYW1wbGVTaXplID0gdGlja09wdHMuc2FtcGxlU2l6ZTtcbiAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG4gICAgdGhpcy50aWNrcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5hZnRlclNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IHRoaXMud2lkdGggKyBtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0XG4gICAgICA6IHRoaXMuaGVpZ2h0ICsgbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbTtcbiAgICBpZiAoIXRoaXMuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5fcmFuZ2UgPSBfYWRkR3JhY2UodGhpcywgZ3JhY2UsIGJlZ2luQXRaZXJvKTtcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmJlZm9yZUJ1aWxkVGlja3MoKTtcbiAgICB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW107XG4gICAgdGhpcy5hZnRlckJ1aWxkVGlja3MoKTtcbiAgICBjb25zdCBzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHMoc2FtcGxpbmdFbmFibGVkID8gc2FtcGxlKHRoaXMudGlja3MsIHNhbXBsZVNpemUpIDogdGhpcy50aWNrcyk7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgICAgdGhpcy5hZnRlckF1dG9Ta2lwKCk7XG4gICAgfVxuICAgIGlmIChzYW1wbGluZ0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRoaXMudGlja3MpO1xuICAgIH1cbiAgICB0aGlzLmJlZm9yZUZpdCgpO1xuICAgIHRoaXMuZml0KCk7XG4gICAgdGhpcy5hZnRlckZpdCgpO1xuICAgIHRoaXMuYWZ0ZXJVcGRhdGUoKTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgbGV0IHJldmVyc2VQaXhlbHMgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZTtcbiAgICBsZXQgc3RhcnRQaXhlbCwgZW5kUGl4ZWw7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLmxlZnQ7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLnRvcDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5ib3R0b207XG4gICAgICByZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gZW5kUGl4ZWw7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IHJldmVyc2VQaXhlbHM7XG4gICAgdGhpcy5fbGVuZ3RoID0gZW5kUGl4ZWwgLSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2FsaWduVG9QaXhlbHMgPSB0aGlzLm9wdGlvbnMuYWxpZ25Ub1BpeGVscztcbiAgfVxuICBhZnRlclVwZGF0ZSgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHRoaXMudG9wID0gMDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMucGFkZGluZ0xlZnQgPSAwO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSAwO1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gIH1cbiAgYWZ0ZXJTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgX2NhbGxIb29rcyhuYW1lKSB7XG4gICAgdGhpcy5jaGFydC5ub3RpZnlQbHVnaW5zKG5hbWUsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnNbbmFtZV0sIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZURhdGFMaW1pdHMnKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJEYXRhTGltaXRzJyk7XG4gIH1cbiAgYmVmb3JlQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZUJ1aWxkVGlja3MnKTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckJ1aWxkVGlja3MnKTtcbiAgfVxuICBiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gY2FsbGJhY2sodGlja09wdHMuY2FsbGJhY2ssIFt0aWNrLnZhbHVlLCBpLCB0aWNrc10sIHRoaXMpO1xuICAgIH1cbiAgfVxuICBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IG51bVRpY2tzID0gdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuICAgIGNvbnN0IG1heFJvdGF0aW9uID0gdGlja09wdHMubWF4Um90YXRpb247XG4gICAgbGV0IGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICBsZXQgdGlja1dpZHRoLCBtYXhIZWlnaHQsIG1heExhYmVsRGlhZ29uYWw7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhdGlja09wdHMuZGlzcGxheSB8fCBtaW5Sb3RhdGlvbiA+PSBtYXhSb3RhdGlvbiB8fCBudW1UaWNrcyA8PSAxIHx8ICF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBtYXhMYWJlbFdpZHRoID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgY29uc3QgbWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0O1xuICAgIGNvbnN0IG1heFdpZHRoID0gX2xpbWl0VmFsdWUodGhpcy5jaGFydC53aWR0aCAtIG1heExhYmVsV2lkdGgsIDAsIHRoaXMubWF4V2lkdGgpO1xuICAgIHRpY2tXaWR0aCA9IG9wdGlvbnMub2Zmc2V0ID8gdGhpcy5tYXhXaWR0aCAvIG51bVRpY2tzIDogbWF4V2lkdGggLyAobnVtVGlja3MgLSAxKTtcbiAgICBpZiAobWF4TGFiZWxXaWR0aCArIDYgPiB0aWNrV2lkdGgpIHtcbiAgICAgIHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xuICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpXG5cdFx0XHRcdC0gdGlja09wdHMucGFkZGluZyAtIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMudGl0bGUsIHRoaXMuY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSB0b0RlZ3JlZXMoTWF0aC5taW4oXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZSgobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAtMSwgMSkpLFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSAtIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSlcbiAgICAgICkpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IE1hdGgubWF4KG1pblJvdGF0aW9uLCBNYXRoLm1pbihtYXhSb3RhdGlvbiwgbGFiZWxSb3RhdGlvbikpO1xuICAgIH1cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuICB9XG4gIGFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7fVxuICBiZWZvcmVGaXQoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICBjb25zdCB7Y2hhcnQsIG9wdGlvbnM6IHt0aWNrczogdGlja09wdHMsIHRpdGxlOiB0aXRsZU9wdHMsIGdyaWQ6IGdyaWRPcHRzfX0gPSB0aGlzO1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9pc1Zpc2libGUoKTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICBjb25zdCB0aXRsZUhlaWdodCA9IGdldFRpdGxlSGVpZ2h0KHRpdGxlT3B0cywgY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdH0gPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IHRpY2tQYWRkaW5nID0gdGlja09wdHMucGFkZGluZyAqIDI7XG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogc2luICogd2lkZXN0LndpZHRoICsgY29zICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUud2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFiZWxXaWR0aCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZU1hcmdpbnMoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG4gIF9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcykge1xuICAgIGNvbnN0IHt0aWNrczoge2FsaWduLCBwYWRkaW5nfSwgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGlzUm90YXRlZCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMDtcbiAgICBjb25zdCBsYWJlbHNCZWxvd1RpY2tzID0gcG9zaXRpb24gIT09ICd0b3AnICYmIHRoaXMuYXhpcyA9PT0gJ3gnO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQ7XG4gICAgICBjb25zdCBvZmZzZXRSaWdodCA9IHRoaXMucmlnaHQgLSB0aGlzLmdldFBpeGVsRm9yVGljayh0aGlzLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aCAvIDI7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGggLyAyO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldExlZnQpLCAwKTtcbiAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRSaWdodCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nVG9wID0gMDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wICsgcGFkZGluZztcbiAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlTWFyZ2lucygpIHtcbiAgICBpZiAodGhpcy5fbWFyZ2lucykge1xuICAgICAgdGhpcy5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nTGVmdCwgdGhpcy5fbWFyZ2lucy5sZWZ0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nUmlnaHQsIHRoaXMuX21hcmdpbnMucmlnaHQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdCb3R0b20sIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJGaXQoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCB7YXhpcywgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IGF4aXMgPT09ICd4JztcbiAgfVxuICBpc0Z1bGxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnVsbFNpemU7XG4gIH1cbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XG4gICAgdGhpcy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgICB0aGlzLmdlbmVyYXRlVGlja0xhYmVscyh0aWNrcyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodGlja3NbaV0ubGFiZWwpKSB7XG4gICAgICAgIHRpY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaWxlbi0tO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgfVxuICBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICBsZXQgbGFiZWxTaXplcyA9IHRoaXMuX2xhYmVsU2l6ZXM7XG4gICAgaWYgKCFsYWJlbFNpemVzKSB7XG4gICAgICBjb25zdCBzYW1wbGVTaXplID0gdGhpcy5vcHRpb25zLnRpY2tzLnNhbXBsZVNpemU7XG4gICAgICBsZXQgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgaWYgKHNhbXBsZVNpemUgPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgdGlja3MgPSBzYW1wbGUodGlja3MsIHNhbXBsZVNpemUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IGxhYmVsU2l6ZXMgPSB0aGlzLl9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgdGlja3MubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsU2l6ZXM7XG4gIH1cbiAgX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCBsZW5ndGgpIHtcbiAgICBjb25zdCB7Y3R4LCBfbG9uZ2VzdFRleHRDYWNoZTogY2FjaGVzfSA9IHRoaXM7XG4gICAgY29uc3Qgd2lkdGhzID0gW107XG4gICAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuICAgIGxldCB3aWRlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBoaWdoZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaSwgaiwgamxlbiwgbGFiZWwsIHRpY2tGb250LCBmb250U3RyaW5nLCBjYWNoZSwgbGluZUhlaWdodCwgd2lkdGgsIGhlaWdodCwgbmVzdGVkTGFiZWw7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xuICAgICAgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xuICAgICAgICBoZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbmVzdGVkTGFiZWwgPSBsYWJlbFtqXTtcbiAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xuICAgICAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIG5lc3RlZExhYmVsKTtcbiAgICAgICAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2lkdGhzLnB1c2god2lkdGgpO1xuICAgICAgaGVpZ2h0cy5wdXNoKGhlaWdodCk7XG4gICAgICB3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcbiAgICAgIGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIH1cbiAgICBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XG4gICAgY29uc3Qgd2lkZXN0ID0gd2lkdGhzLmluZGV4T2Yod2lkZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCBoaWdoZXN0ID0gaGVpZ2h0cy5pbmRleE9mKGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IHZhbHVlQXQgPSAoaWR4KSA9PiAoe3dpZHRoOiB3aWR0aHNbaWR4XSB8fCAwLCBoZWlnaHQ6IGhlaWdodHNbaWR4XSB8fCAwfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0OiB2YWx1ZUF0KDApLFxuICAgICAgbGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcbiAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxuICAgICAgaGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KSxcbiAgICAgIHdpZHRocyxcbiAgICAgIGhlaWdodHMsXG4gICAgfTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUsIGluZGV4KSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fVxuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JEZWNpbWFsKGRlY2ltYWwpIHtcbiAgICBpZiAodGhpcy5fcmV2ZXJzZVBpeGVscykge1xuICAgICAgZGVjaW1hbCA9IDEgLSBkZWNpbWFsO1xuICAgIH1cbiAgICBjb25zdCBwaXhlbCA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiBfaW50MTZSYW5nZSh0aGlzLl9hbGlnblRvUGl4ZWxzID8gX2FsaWduUGl4ZWwodGhpcy5jaGFydCwgcGl4ZWwsIDApIDogcGl4ZWwpO1xuICB9XG4gIGdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSAocGl4ZWwgLSB0aGlzLl9zdGFydFBpeGVsKSAvIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZVBpeGVscyA/IDEgLSBkZWNpbWFsIDogZGVjaW1hbDtcbiAgfVxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuICBnZXRCYXNlVmFsdWUoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgcmV0dXJuIG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG4gICAgICBtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuICAgICAgMDtcbiAgfVxuICBnZXRDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzIHx8IFtdO1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgICAgcmV0dXJuIHRpY2suJGNvbnRleHQgfHxcblx0XHRcdFx0KHRpY2suJGNvbnRleHQgPSBjcmVhdGVUaWNrQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHRpY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlU2NhbGVDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzKSk7XG4gIH1cbiAgX3RpY2tTaXplKCkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHJvdCA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKHJvdCkpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKHJvdCkpO1xuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuICAgIGNvbnN0IHcgPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy53aWRlc3Qud2lkdGggKyBwYWRkaW5nIDogMDtcbiAgICBjb25zdCBoID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBwYWRkaW5nIDogMDtcbiAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG4gICAgICA6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG4gIH1cbiAgX2lzVmlzaWJsZSgpIHtcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5vcHRpb25zLmRpc3BsYXk7XG4gICAgaWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuICEhZGlzcGxheTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICB9XG4gIF9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtncmlkLCBwb3NpdGlvbn0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9mZnNldCA9IGdyaWQub2Zmc2V0O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWQpO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyT3B0cy5kcmF3Qm9yZGVyID8gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aCA6IDA7XG4gICAgY29uc3QgYXhpc0hhbGZXaWR0aCA9IGF4aXNXaWR0aCAvIDI7XG4gICAgY29uc3QgYWxpZ25Cb3JkZXJWYWx1ZSA9IGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICByZXR1cm4gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCBheGlzV2lkdGgpO1xuICAgIH07XG4gICAgbGV0IGJvcmRlclZhbHVlLCBpLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XG4gICAgbGV0IHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTI7XG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuYm90dG9tKTtcbiAgICAgIHR5MSA9IHRoaXMuYm90dG9tIC0gdGw7XG4gICAgICB0eTIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy50b3ApO1xuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHRoaXMudG9wICsgdGw7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5yaWdodCk7XG4gICAgICB0eDEgPSB0aGlzLnJpZ2h0IC0gdGw7XG4gICAgICB0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmxlZnQpICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmxlZnQpO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEucmlnaHQpIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHRoaXMubGVmdCArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdHkxICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0eDEgLSB0bDtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQsIHRpY2tzTGVuZ3RoKTtcbiAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRpY2tzTGVuZ3RoIC8gbGltaXQpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IG9wdHNBdEluZGV4LmxpbmVXaWR0aDtcbiAgICAgIGNvbnN0IGxpbmVDb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCBib3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IG9wdHNBdEluZGV4LnRpY2tXaWR0aDtcbiAgICAgIGNvbnN0IHRpY2tDb2xvciA9IG9wdHNBdEluZGV4LnRpY2tDb2xvcjtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZSh0aGlzLCBpLCBvZmZzZXQpO1xuICAgICAgaWYgKGxpbmVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYWxpZ25lZExpbmVWYWx1ZSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgdHgxLFxuICAgICAgICB0eTEsXG4gICAgICAgIHR4MixcbiAgICAgICAgdHkyLFxuICAgICAgICB4MSxcbiAgICAgICAgeTEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MixcbiAgICAgICAgd2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcbiAgICAgICAgYm9yZGVyRGFzaCxcbiAgICAgICAgYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgdGlja1dpZHRoLFxuICAgICAgICB0aWNrQ29sb3IsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IHRpY2tzTGVuZ3RoO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIF9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczogb3B0aW9uVGlja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB7YWxpZ24sIGNyb3NzQWxpZ24sIHBhZGRpbmcsIG1pcnJvcn0gPSBvcHRpb25UaWNrcztcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3QgaFRpY2tBbmRQYWRkaW5nID0gbWlycm9yID8gLXBhZGRpbmcgOiB0aWNrQW5kUGFkZGluZztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gdGhpcy5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSAoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIGxhYmVsID0gdGljay5sYWJlbDtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gb3B0aW9uVGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuICAgICAgY29uc3QgaGFsZkNvdW50ID0gbGluZUNvdW50IC8gMjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgbGV0IHRpY2tUZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHggPSBwaXhlbDtcbiAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC0gbGluZUNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICAgIHRleHRPZmZzZXQgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBwaXhlbDtcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgbGV0IGJhY2tkcm9wO1xuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBsYWJlbFNpemVzLmhlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplcy53aWR0aHNbaV07XG4gICAgICAgIGxldCB0b3AgPSB5ICsgdGV4dE9mZnNldCAtIGxhYmVsUGFkZGluZy50b3A7XG4gICAgICAgIGxldCBsZWZ0ID0geCAtIGxhYmVsUGFkZGluZy5sZWZ0O1xuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYmFja2Ryb3AgPSB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgbGFiZWxQYWRkaW5nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbGFiZWxQYWRkaW5nLmhlaWdodCxcbiAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvbnQsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgIHRleHRBbGlnbjogdGlja1RleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICB0cmFuc2xhdGlvbjogW3gsIHldLFxuICAgICAgICBiYWNrZHJvcCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrc30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG4gICAgbGV0IGFsaWduID0gJ2NlbnRlcic7XG4gICAgaWYgKHRpY2tzLmFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnZW5kJykge1xuICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgIGFsaWduID0gJ2lubmVyJztcbiAgICB9XG4gICAgcmV0dXJuIGFsaWduO1xuICB9XG4gIF9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczoge2Nyb3NzQWxpZ24sIG1pcnJvciwgcGFkZGluZ319ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3Qgd2lkZXN0ID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgbGV0IHRleHRBbGlnbjtcbiAgICBsZXQgeDtcbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggKz0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4ID0gdGhpcy5sZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gd2lkZXN0IC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggPSB0aGlzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiB7dGV4dEFsaWduLCB4fTtcbiAgfVxuICBfY29tcHV0ZUxhYmVsQXJlYSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpY2tzLm1pcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiB0aGlzLmxlZnQsIGJvdHRvbTogY2hhcnQuaGVpZ2h0LCByaWdodDogdGhpcy5yaWdodH07XG4gICAgfSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIHt0b3A6IHRoaXMudG9wLCBsZWZ0OiAwLCBib3R0b206IHRoaXMuYm90dG9tLCByaWdodDogY2hhcnQud2lkdGh9O1xuICAgIH1cbiAgfVxuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7YmFja2dyb3VuZENvbG9yfSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGdldExpbmVXaWR0aEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIWdyaWQuZGlzcGxheSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCBpbmRleCA9IHRpY2tzLmZpbmRJbmRleCh0ID0+IHQudmFsdWUgPT09IHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgY29uc3Qgb3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIHJldHVybiBvcHRzLmxpbmVXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZHJhd0dyaWQoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ3JpZExpbmVJdGVtcyB8fCAodGhpcy5fZ3JpZExpbmVJdGVtcyA9IHRoaXMuX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGNvbnN0IGRyYXdMaW5lID0gKHAxLCBwMiwgc3R5bGUpID0+IHtcbiAgICAgIGlmICghc3R5bGUud2lkdGggfHwgIXN0eWxlLmNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZS5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGdyaWQuZHJhd09uQ2hhcnRBcmVhKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS54MSwgeTogaXRlbS55MX0sXG4gICAgICAgICAgICB7eDogaXRlbS54MiwgeTogaXRlbS55Mn0sXG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZC5kcmF3VGlja3MpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MSwgeTogaXRlbS50eTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0udHgyLCB5OiBpdGVtLnR5Mn0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbG9yOiBpdGVtLnRpY2tDb2xvcixcbiAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0udGlja1dpZHRoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBpdGVtLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3Qm9yZGVyKCkge1xuICAgIGNvbnN0IHtjaGFydCwgY3R4LCBvcHRpb25zOiB7Z3JpZH19ID0gdGhpcztcbiAgICBjb25zdCBib3JkZXJPcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBncmlkLmRyYXdCb3JkZXIgPyBib3JkZXJPcHRzLmJvcmRlcldpZHRoIDogMDtcbiAgICBpZiAoIWF4aXNXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGluZVdpZHRoID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgwKSkubGluZVdpZHRoO1xuICAgIGNvbnN0IGJvcmRlclZhbHVlID0gdGhpcy5fYm9yZGVyVmFsdWU7XG4gICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB4MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmxlZnQsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeDIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHkxID0geTIgPSBib3JkZXJWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgeTEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy50b3AsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeTIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5ib3R0b20sIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB4MSA9IHgyID0gYm9yZGVyVmFsdWU7XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlck9wdHMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyT3B0cy5ib3JkZXJDb2xvcjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBkcmF3TGFiZWxzKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGlmICghb3B0aW9uVGlja3MuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgIGlmIChhcmVhKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xhYmVsSXRlbXMgfHwgKHRoaXMuX2xhYmVsSXRlbXMgPSB0aGlzLl9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCB0aWNrRm9udCA9IGl0ZW0uZm9udDtcbiAgICAgIGNvbnN0IGxhYmVsID0gaXRlbS5sYWJlbDtcbiAgICAgIGlmIChpdGVtLmJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBpdGVtLmJhY2tkcm9wLmNvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaXRlbS5iYWNrZHJvcC5sZWZ0LCBpdGVtLmJhY2tkcm9wLnRvcCwgaXRlbS5iYWNrZHJvcC53aWR0aCwgaXRlbS5iYWNrZHJvcC5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgbGV0IHkgPSBpdGVtLnRleHRPZmZzZXQ7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGFiZWwsIDAsIHksIHRpY2tGb250LCBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb3NpdGlvbiwgdGl0bGUsIHJldmVyc2V9fSA9IHRoaXM7XG4gICAgaWYgKCF0aXRsZS5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSB0b0ZvbnQodGl0bGUuZm9udCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICBjb25zdCBhbGlnbiA9IHRpdGxlLmFsaWduO1xuICAgIGxldCBvZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLyAyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgcG9zaXRpb24gPT09ICdjZW50ZXInIHx8IGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcuYm90dG9tO1xuICAgICAgaWYgKGlzQXJyYXkodGl0bGUudGV4dCkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IGZvbnQubGluZUhlaWdodCAqICh0aXRsZS50ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy50b3A7XG4gICAgfVxuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRpdGxlQXJncyh0aGlzLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbik7XG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxuICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICB9XG4gIF9sYXllcnMoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgY29uc3QgZ3ogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmdyaWQgJiYgb3B0cy5ncmlkLnosIC0xKTtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8IHRoaXMuZHJhdyAhPT0gU2NhbGUucHJvdG90eXBlLmRyYXcpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiB0eixcbiAgICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICAgIHRoaXMuZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICB6OiBneixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogZ3ogKyAxLFxuICAgICAgZHJhdzogKCkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiB0eixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfV07XG4gIH1cbiAgZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkge1xuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5jaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXhpc0lEID0gdGhpcy5heGlzICsgJ0F4aXNJRCc7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gdGhpcy5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpbmRleCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnMudGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICByZXR1cm4gdG9Gb250KG9wdHMuZm9udCk7XG4gIH1cbiAgX21heERpZ2l0cygpIHtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICByZXR1cm4gKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQpIC8gZm9udFNpemU7XG4gIH1cbn1cblxuY2xhc3MgVHlwZWRSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNjb3BlLCBvdmVycmlkZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICB0aGlzLml0ZW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBpc0ZvclR5cGUodHlwZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbCh0aGlzLnR5cGUucHJvdG90eXBlLCB0eXBlLnByb3RvdHlwZSk7XG4gIH1cbiAgcmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGl0ZW0pO1xuICAgIGxldCBwYXJlbnRTY29wZTtcbiAgICBpZiAoaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pKSB7XG4gICAgICBwYXJlbnRTY29wZSA9IHRoaXMucmVnaXN0ZXIocHJvdG8pO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZSArICcuJyArIGlkO1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgZG9lcyBub3QgaGF2ZSBpZDogJyArIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG4gICAgaXRlbXNbaWRdID0gaXRlbTtcbiAgICByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgIGRlZmF1bHRzLm92ZXJyaWRlKGl0ZW0uaWQsIGl0ZW0ub3ZlcnJpZGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG4gIGdldChpZCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zW2lkXTtcbiAgfVxuICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIGRlbGV0ZSBpdGVtc1tpZF07XG4gICAgfVxuICAgIGlmIChzY29wZSAmJiBpZCBpbiBkZWZhdWx0c1tzY29wZV0pIHtcbiAgICAgIGRlbGV0ZSBkZWZhdWx0c1tzY29wZV1baWRdO1xuICAgICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlc1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICBjb25zdCBpdGVtRGVmYXVsdHMgPSBtZXJnZShPYmplY3QuY3JlYXRlKG51bGwpLCBbXG4gICAgcGFyZW50U2NvcGUgPyBkZWZhdWx0cy5nZXQocGFyZW50U2NvcGUpIDoge30sXG4gICAgZGVmYXVsdHMuZ2V0KHNjb3BlKSxcbiAgICBpdGVtLmRlZmF1bHRzXG4gIF0pO1xuICBkZWZhdWx0cy5zZXQoc2NvcGUsIGl0ZW1EZWZhdWx0cyk7XG4gIGlmIChpdGVtLmRlZmF1bHRSb3V0ZXMpIHtcbiAgICByb3V0ZURlZmF1bHRzKHNjb3BlLCBpdGVtLmRlZmF1bHRSb3V0ZXMpO1xuICB9XG4gIGlmIChpdGVtLmRlc2NyaXB0b3JzKSB7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoc2NvcGUsIGl0ZW0uZGVzY3JpcHRvcnMpO1xuICB9XG59XG5mdW5jdGlvbiByb3V0ZURlZmF1bHRzKHNjb3BlLCByb3V0ZXMpIHtcbiAgT2JqZWN0LmtleXMocm91dGVzKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eVBhcnRzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzb3VyY2VOYW1lID0gcHJvcGVydHlQYXJ0cy5wb3AoKTtcbiAgICBjb25zdCBzb3VyY2VTY29wZSA9IFtzY29wZV0uY29uY2F0KHByb3BlcnR5UGFydHMpLmpvaW4oJy4nKTtcbiAgICBjb25zdCBwYXJ0cyA9IHJvdXRlc1twcm9wZXJ0eV0uc3BsaXQoJy4nKTtcbiAgICBjb25zdCB0YXJnZXROYW1lID0gcGFydHMucG9wKCk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGUgPSBwYXJ0cy5qb2luKCcuJyk7XG4gICAgZGVmYXVsdHMucm91dGUoc291cmNlU2NvcGUsIHNvdXJjZU5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc0lDaGFydENvbXBvbmVudChwcm90bykge1xuICByZXR1cm4gJ2lkJyBpbiBwcm90byAmJiAnZGVmYXVsdHMnIGluIHByb3RvO1xufVxuXG5jbGFzcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KEVsZW1lbnQsICdlbGVtZW50cycpO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KE9iamVjdCwgJ3BsdWdpbnMnKTtcbiAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcbiAgfVxuICBhZGQoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncyk7XG4gIH1cbiAgcmVtb3ZlKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncyk7XG4gIH1cbiAgYWRkQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cbiAgYWRkRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cbiAgYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG4gIGFkZFNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cbiAgZ2V0Q29udHJvbGxlcihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuY29udHJvbGxlcnMsICdjb250cm9sbGVyJyk7XG4gIH1cbiAgZ2V0RWxlbWVudChpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuZWxlbWVudHMsICdlbGVtZW50Jyk7XG4gIH1cbiAgZ2V0UGx1Z2luKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5wbHVnaW5zLCAncGx1Z2luJyk7XG4gIH1cbiAgZ2V0U2NhbGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnNjYWxlcywgJ3NjYWxlJyk7XG4gIH1cbiAgcmVtb3ZlQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuICByZW1vdmVFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG4gIHJlbW92ZVBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG4gIHJlbW92ZVNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuICBfZWFjaChtZXRob2QsIGFyZ3MsIHR5cGVkUmVnaXN0cnkpIHtcbiAgICBbLi4uYXJnc10uZm9yRWFjaChhcmcgPT4ge1xuICAgICAgY29uc3QgcmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoYXJnKTtcbiAgICAgIGlmICh0eXBlZFJlZ2lzdHJ5IHx8IHJlZy5pc0ZvclR5cGUoYXJnKSB8fCAocmVnID09PSB0aGlzLnBsdWdpbnMgJiYgYXJnLmlkKSkge1xuICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgcmVnLCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFjaChhcmcsIGl0ZW0gPT4ge1xuICAgICAgICAgIGNvbnN0IGl0ZW1SZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShpdGVtKTtcbiAgICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgaXRlbVJlZywgaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9leGVjKG1ldGhvZCwgcmVnaXN0cnksIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICBjYWxsYmFjayhjb21wb25lbnRbJ2JlZm9yZScgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpO1xuICAgIHJlZ2lzdHJ5W21ldGhvZF0oY29tcG9uZW50KTtcbiAgICBjYWxsYmFjayhjb21wb25lbnRbJ2FmdGVyJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7XG4gIH1cbiAgX2dldFJlZ2lzdHJ5Rm9yVHlwZSh0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90eXBlZFJlZ2lzdHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZyA9IHRoaXMuX3R5cGVkUmVnaXN0cmllc1tpXTtcbiAgICAgIGlmIChyZWcuaXNGb3JUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiByZWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBsdWdpbnM7XG4gIH1cbiAgX2dldChpZCwgdHlwZWRSZWdpc3RyeSwgdHlwZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0eXBlZFJlZ2lzdHJ5LmdldChpZCk7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBpZCArICdcIiBpcyBub3QgYSByZWdpc3RlcmVkICcgKyB0eXBlICsgJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbn1cbnZhciByZWdpc3RyeSA9IG5ldyBSZWdpc3RyeSgpO1xuXG5jbGFzcyBQbHVnaW5TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5pdCA9IFtdO1xuICB9XG4gIG5vdGlmeShjaGFydCwgaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgaWYgKGhvb2sgPT09ICdiZWZvcmVJbml0Jykge1xuICAgICAgdGhpcy5faW5pdCA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB0cnVlKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ2luc3RhbGwnKTtcbiAgICB9XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWx0ZXIgPyB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCkuZmlsdGVyKGZpbHRlcikgOiB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncyk7XG4gICAgaWYgKGhvb2sgPT09ICdhZnRlckRlc3Ryb3knKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAndW5pbnN0YWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpIHtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgZGVzY3JpcHRvcnMpIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuICAgICAgY29uc3QgbWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuICAgICAgY29uc3QgcGFyYW1zID0gW2NoYXJ0LCBhcmdzLCBkZXNjcmlwdG9yLm9wdGlvbnNdO1xuICAgICAgaWYgKGNhbGxiYWNrKG1ldGhvZCwgcGFyYW1zLCBwbHVnaW4pID09PSBmYWxzZSAmJiBhcmdzLmNhbmNlbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLl9jYWNoZSkpIHtcbiAgICAgIHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgX2Rlc2NyaXB0b3JzKGNoYXJ0KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGUgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgdGhpcy5fbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH1cbiAgX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBhbGwpIHtcbiAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZhbHVlT3JEZWZhdWx0KGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgICBjb25zdCBwbHVnaW5zID0gYWxsUGx1Z2lucyhjb25maWcpO1xuICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcbiAgfVxuICBfbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KSB7XG4gICAgY29uc3QgcHJldmlvdXNEZXNjcmlwdG9ycyA9IHRoaXMuX29sZENhY2hlIHx8IFtdO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGU7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LnBsdWdpbi5pZCA9PT0geS5wbHVnaW4uaWQpKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihwcmV2aW91c0Rlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RvcCcpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKGRlc2NyaXB0b3JzLCBwcmV2aW91c0Rlc2NyaXB0b3JzKSwgY2hhcnQsICdzdGFydCcpO1xuICB9XG59XG5mdW5jdGlvbiBhbGxQbHVnaW5zKGNvbmZpZykge1xuICBjb25zdCBsb2NhbElkcyA9IHt9O1xuICBjb25zdCBwbHVnaW5zID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbHVnaW5zLml0ZW1zKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGx1Z2lucy5wdXNoKHJlZ2lzdHJ5LmdldFBsdWdpbihrZXlzW2ldKSk7XG4gIH1cbiAgY29uc3QgbG9jYWwgPSBjb25maWcucGx1Z2lucyB8fCBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBsdWdpbiA9IGxvY2FsW2ldO1xuICAgIGlmIChwbHVnaW5zLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgbG9jYWxJZHNbcGx1Z2luLmlkXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB7cGx1Z2lucywgbG9jYWxJZHN9O1xufVxuZnVuY3Rpb24gZ2V0T3B0cyhvcHRpb25zLCBhbGwpIHtcbiAgaWYgKCFhbGwgJiYgb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB7cGx1Z2lucywgbG9jYWxJZHN9LCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG4gIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCBvcHRzID0gZ2V0T3B0cyhvcHRpb25zW2lkXSwgYWxsKTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHBsdWdpbixcbiAgICAgIG9wdGlvbnM6IHBsdWdpbk9wdHMoY2hhcnQuY29uZmlnLCB7cGx1Z2luLCBsb2NhbDogbG9jYWxJZHNbaWRdfSwgb3B0cywgY29udGV4dClcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGx1Z2luT3B0cyhjb25maWcsIHtwbHVnaW4sIGxvY2FsfSwgb3B0cywgY29udGV4dCkge1xuICBjb25zdCBrZXlzID0gY29uZmlnLnBsdWdpblNjb3BlS2V5cyhwbHVnaW4pO1xuICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG9wdHMsIGtleXMpO1xuICBpZiAobG9jYWwgJiYgcGx1Z2luLmRlZmF1bHRzKSB7XG4gICAgc2NvcGVzLnB1c2gocGx1Z2luLmRlZmF1bHRzKTtcbiAgfVxuICByZXR1cm4gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgWycnXSwge1xuICAgIHNjcmlwdGFibGU6IGZhbHNlLFxuICAgIGluZGV4YWJsZTogZmFsc2UsXG4gICAgYWxsS2V5czogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XG4gIGNvbnN0IGRhdGFzZXRPcHRpb25zID0gKG9wdGlvbnMuZGF0YXNldHMgfHwge30pW3R5cGVdIHx8IHt9O1xuICByZXR1cm4gZGF0YXNldE9wdGlvbnMuaW5kZXhBeGlzIHx8IG9wdGlvbnMuaW5kZXhBeGlzIHx8IGRhdGFzZXREZWZhdWx0cy5pbmRleEF4aXMgfHwgJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChpZCwgaW5kZXhBeGlzKSB7XG4gIGxldCBheGlzID0gaWQ7XG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcztcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ192YWx1ZV8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBpbmRleEF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cbmZ1bmN0aW9uIGF4aXNGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gJ3gnO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgcmV0dXJuICd5JztcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKSB7XG4gIGlmIChpZCA9PT0gJ3gnIHx8IGlkID09PSAneScpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgcmV0dXJuIHNjYWxlT3B0aW9ucy5heGlzIHx8IGF4aXNGcm9tUG9zaXRpb24oc2NhbGVPcHRpb25zLnBvc2l0aW9uKSB8fCBpZC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0RGVmYXVsdHMgPSBvdmVycmlkZXNbY29uZmlnLnR5cGVdIHx8IHtzY2FsZXM6IHt9fTtcbiAgY29uc3QgY29uZmlnU2NhbGVzID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gIGNvbnN0IGNoYXJ0SW5kZXhBeGlzID0gZ2V0SW5kZXhBeGlzKGNvbmZpZy50eXBlLCBvcHRpb25zKTtcbiAgY29uc3QgZmlyc3RJRHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBzY2FsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IHNjYWxlQ29uZiA9IGNvbmZpZ1NjYWxlc1tpZF07XG4gICAgaWYgKCFpc09iamVjdChzY2FsZUNvbmYpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBzY2FsZSBjb25maWd1cmF0aW9uIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgaWYgKHNjYWxlQ29uZi5fcHJveHkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYElnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZik7XG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGNoYXJ0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIGZpcnN0SURzW2F4aXNdID0gZmlyc3RJRHNbYXhpc10gfHwgaWQ7XG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcbiAgfSk7XG4gIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goZGF0YXNldCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTY2FsZU9wdGlvbnMpLmZvckVhY2goZGVmYXVsdElEID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGRlZmF1bHRJRCwgaW5kZXhBeGlzKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGZpcnN0SURzW2F4aXNdIHx8IGF4aXM7XG4gICAgICBzY2FsZXNbaWRdID0gc2NhbGVzW2lkXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbWVyZ2VJZihzY2FsZXNbaWRdLCBbe2F4aXN9LCBjb25maWdTY2FsZXNbaWRdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJRF1dKTtcbiAgICB9KTtcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHNjYWxlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XG4gICAgbWVyZ2VJZihzY2FsZSwgW2RlZmF1bHRzLnNjYWxlc1tzY2FsZS50eXBlXSwgZGVmYXVsdHMuc2NhbGVdKTtcbiAgfSk7XG4gIHJldHVybiBzY2FsZXM7XG59XG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcbiAgb3B0aW9ucy5wbHVnaW5zID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gIG9wdGlvbnMuc2NhbGVzID0gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG4gIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcbiAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgcmV0dXJuIGNvbmZpZztcbn1cbmNvbnN0IGtleUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qga2V5c0NhY2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGNhY2hlZEtleXMoY2FjaGVLZXksIGdlbmVyYXRlKSB7XG4gIGxldCBrZXlzID0ga2V5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IGdlbmVyYXRlKCk7XG4gICAga2V5Q2FjaGUuc2V0KGNhY2hlS2V5LCBrZXlzKTtcbiAgICBrZXlzQ2FjaGVkLmFkZChrZXlzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xuICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQuYWRkKG9wdHMpO1xuICB9XG59O1xuY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbGF0Zm9ybTtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cbiAgc2V0IHR5cGUodHlwZSkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gaW5pdERhdGEoZGF0YSk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlLmNsZWFyKCk7XG4gIH1cbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGRhdGFzZXRUeXBlLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKGRhdGFzZXRUeXBlLCB0cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb24uJHt0cmFuc2l0aW9ufWAsXG4gICAgICAoKSA9PiBbXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgICAgYHRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgICAnJ1xuICAgICAgICBdXG4gICAgICBdKTtcbiAgfVxuICBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgZWxlbWVudFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0tJHtlbGVtZW50VHlwZX1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LmVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgYGVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBwbHVnaW5TY29wZUtleXMocGx1Z2luKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZTtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHt0eXBlfS1wbHVnaW4tJHtpZH1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYHBsdWdpbnMuJHtpZH1gLFxuICAgICAgICAuLi5wbHVnaW4uYWRkaXRpb25hbE9wdGlvblNjb3BlcyB8fCBbXSxcbiAgICAgIF1dKTtcbiAgfVxuICBfY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgY2FjaGUgPSBfc2NvcGVDYWNoZS5nZXQobWFpblNjb3BlKTtcbiAgICBpZiAoIWNhY2hlIHx8IHJlc2V0Q2FjaGUpIHtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgX3Njb3BlQ2FjaGUuc2V0KG1haW5TY29wZSwgY2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cbiAgZ2V0T3B0aW9uU2NvcGVzKG1haW5TY29wZSwga2V5TGlzdHMsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XG4gICAga2V5TGlzdHMuZm9yRWFjaChrZXlzID0+IHtcbiAgICAgIGlmIChtYWluU2NvcGUpIHtcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBtYWluU2NvcGUsIGtleSkpO1xuICAgICAgfVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvdmVycmlkZXNbdHlwZV0gfHwge30sIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVmYXVsdHMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzY29wZXMpO1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGFycmF5LnB1c2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcbiAgICAgIGNhY2hlLnNldChrZXlMaXN0cywgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgY2hhcnRPcHRpb25TY29wZXMoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICByZXR1cm4gW1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcbiAgICAgIGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9LFxuICAgICAge3R5cGV9LFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBkZXNjcmlwdG9yc1xuICAgIF07XG4gIH1cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7JHNoYXJlZDogdHJ1ZX07XG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICBsZXQgb3B0aW9ucyA9IHJlc29sdmVyO1xuICAgIGlmIChuZWVkQ29udGV4dChyZXNvbHZlciwgbmFtZXMpKSB7XG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dCA9IGlzRnVuY3Rpb24oY29udGV4dCkgPyBjb250ZXh0KCkgOiBjb250ZXh0O1xuICAgICAgY29uc3Qgc3ViUmVzb2x2ZXIgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgc3ViUHJlZml4ZXMpO1xuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gICAgY29uc3Qge3Jlc29sdmVyfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxuICAgICAgPyBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgdW5kZWZpbmVkLCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gICAgICA6IHJlc29sdmVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcihyZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKSB7XG4gIGxldCBjYWNoZSA9IHJlc29sdmVyQ2FjaGUuZ2V0KHNjb3Blcyk7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcbiAgfVxuICBjb25zdCBjYWNoZUtleSA9IHByZWZpeGVzLmpvaW4oKTtcbiAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghY2FjaGVkKSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgY2FjaGVkID0ge1xuICAgICAgcmVzb2x2ZXIsXG4gICAgICBzdWJQcmVmaXhlczogcHJlZml4ZXMuZmlsdGVyKHAgPT4gIXAudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaG92ZXInKSlcbiAgICB9O1xuICAgIGNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gY2FjaGVkO1xufVxuY29uc3QgaGFzRnVuY3Rpb24gPSB2YWx1ZSA9PiBpc09iamVjdCh2YWx1ZSlcbiAgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjYyB8fCBpc0Z1bmN0aW9uKHZhbHVlW2tleV0pLCBmYWxzZSk7XG5mdW5jdGlvbiBuZWVkQ29udGV4dChwcm94eSwgbmFtZXMpIHtcbiAgY29uc3Qge2lzU2NyaXB0YWJsZSwgaXNJbmRleGFibGV9ID0gX2Rlc2NyaXB0b3JzKHByb3h5KTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgY29uc3Qgc2NyaXB0YWJsZSA9IGlzU2NyaXB0YWJsZShwcm9wKTtcbiAgICBjb25zdCBpbmRleGFibGUgPSBpc0luZGV4YWJsZShwcm9wKTtcbiAgICBjb25zdCB2YWx1ZSA9IChpbmRleGFibGUgfHwgc2NyaXB0YWJsZSkgJiYgcHJveHlbcHJvcF07XG4gICAgaWYgKChzY3JpcHRhYmxlICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBoYXNGdW5jdGlvbih2YWx1ZSkpKVxuICAgICAgfHwgKGluZGV4YWJsZSAmJiBpc0FycmF5KHZhbHVlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciB2ZXJzaW9uID0gXCIzLjkuMVwiO1xuXG5jb25zdCBLTk9XTl9QT1NJVElPTlMgPSBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICdjaGFydEFyZWEnXTtcbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uLCBheGlzKSB7XG4gIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IChLTk9XTl9QT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPT09IC0xICYmIGF4aXMgPT09ICd4Jyk7XG59XG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhW2wxXSA9PT0gYltsMV1cbiAgICAgID8gYVtsMl0gLSBiW2wyXVxuICAgICAgOiBhW2wxXSAtIGJbbDFdO1xuICB9O1xufVxuZnVuY3Rpb24gb25BbmltYXRpb25zQ29tcGxldGUoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJSZW5kZXInKTtcbiAgY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuZnVuY3Rpb24gb25BbmltYXRpb25Qcm9ncmVzcyhjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcywgW2NvbnRleHRdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBnZXRDYW52YXMoaXRlbSkge1xuICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICBpdGVtID0gaXRlbVswXTtcbiAgfVxuICBpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmNvbnN0IGluc3RhbmNlcyA9IHt9O1xuY29uc3QgZ2V0Q2hhcnQgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcyhrZXkpO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZpbHRlcigoYykgPT4gYy5jYW52YXMgPT09IGNhbnZhcykucG9wKCk7XG59O1xuZnVuY3Rpb24gbW92ZU51bWVyaWNLZXlzKG9iaiwgc3RhcnQsIG1vdmUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBpbnRLZXkgPSAra2V5O1xuICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgb2JqW2ludEtleSArIG1vdmVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljaykge1xuICBpZiAoIWluQ2hhcnRBcmVhIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0NsaWNrKSB7XG4gICAgcmV0dXJuIGxhc3RFdmVudDtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmNsYXNzIENoYXJ0IHtcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyh1c2VyQ29uZmlnKTtcbiAgICBjb25zdCBpbml0aWFsQ2FudmFzID0gZ2V0Q2FudmFzKGl0ZW0pO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcbiAgICBpZiAoZXhpc3RpbmdDaGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgK1xuXHRcdFx0XHQnIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuY2FudmFzLmlkICsgJ1xcJyBjYW4gYmUgcmV1c2VkLidcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLnBsYXRmb3JtID0gbmV3IChjb25maWcucGxhdGZvcm0gfHwgX2RldGVjdFBsYXRmb3JtKGluaXRpYWxDYW52YXMpKSgpO1xuICAgIHRoaXMucGxhdGZvcm0udXBkYXRlQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG4gICAgdGhpcy5pZCA9IHVpZCgpO1xuICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIHRoaXMuX21ldGFzZXRzID0gW107XG4gICAgdGhpcy5fc3RhY2tzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm94ZXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnRBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gW107XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLl9wbHVnaW5zID0gbmV3IFBsdWdpblNlcnZpY2UoKTtcbiAgICB0aGlzLiRwcm94aWVzID0ge307XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9O1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kb1Jlc2l6ZSA9IGRlYm91bmNlKG1vZGUgPT4gdGhpcy51cGRhdGUobW9kZSksIG9wdGlvbnMucmVzaXplRGVsYXkgfHwgMCk7XG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSB0aGlzO1xuICAgIGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAnY29tcGxldGUnLCBvbkFuaW1hdGlvbnNDb21wbGV0ZSk7XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdwcm9ncmVzcycsIG9uQW5pbWF0aW9uUHJvZ3Jlc3MpO1xuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFzcGVjdFJhdGlvKCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiB7YXNwZWN0UmF0aW8sIG1haW50YWluQXNwZWN0UmF0aW99LCB3aWR0aCwgaGVpZ2h0LCBfYXNwZWN0UmF0aW99ID0gdGhpcztcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYXNwZWN0UmF0aW8pKSB7XG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIGlmIChtYWludGFpbkFzcGVjdFJhdGlvICYmIF9hc3BlY3RSYXRpbykge1xuICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YTtcbiAgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5jb25maWcuZGF0YSA9IGRhdGE7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlSW5pdCcpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVySW5pdCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGNsZWFyQ2FudmFzKHRoaXMuY2FudmFzLCB0aGlzLmN0eCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBhbmltYXRvci5zdG9wKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSB7d2lkdGgsIGhlaWdodH07XG4gICAgfVxuICB9XG4gIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbztcbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy53aWR0aCA/ICdyZXNpemUnIDogJ2F0dGFjaCc7XG4gICAgdGhpcy53aWR0aCA9IG5ld1NpemUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdTaXplLmhlaWdodDtcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgaWYgKCFyZXRpbmFTY2FsZSh0aGlzLCBuZXdSYXRpbywgdHJ1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNpemUnLCB7c2l6ZTogbmV3U2l6ZX0pO1xuICAgIGNhbGxiYWNrKG9wdGlvbnMub25SZXNpemUsIFt0aGlzLCBuZXdTaXplXSwgdGhpcyk7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICh0aGlzLl9kb1Jlc2l6ZShtb2RlKSkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICAgIGVhY2goc2NhbGVzT3B0aW9ucywgKGF4aXNPcHRpb25zLCBheGlzSUQpID0+IHtcbiAgICAgIGF4aXNPcHRpb25zLmlkID0gYXhpc0lEO1xuICAgIH0pO1xuICB9XG4gIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcbiAgICBjb25zdCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoKG9iaiwgaWQpID0+IHtcbiAgICAgIG9ialtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGxldCBpdGVtcyA9IFtdO1xuICAgIGlmIChzY2FsZU9wdHMpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KFxuICAgICAgICBPYmplY3Qua2V5cyhzY2FsZU9wdHMpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBzY2FsZU9wdHNbaWRdO1xuICAgICAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgICAgIGNvbnN0IGlzUmFkaWFsID0gYXhpcyA9PT0gJ3InO1xuICAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGF4aXMgPT09ICd4JztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczogc2NhbGVPcHRpb25zLFxuICAgICAgICAgICAgZHBvc2l0aW9uOiBpc1JhZGlhbCA/ICdjaGFydEFyZWEnIDogaXNIb3Jpem9udGFsID8gJ2JvdHRvbScgOiAnbGVmdCcsXG4gICAgICAgICAgICBkdHlwZTogaXNSYWRpYWwgPyAncmFkaWFsTGluZWFyJyA6IGlzSG9yaXpvbnRhbCA/ICdjYXRlZ29yeScgOiAnbGluZWFyJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBlYWNoKGl0ZW1zLCAoaXRlbSkgPT4ge1xuICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG4gICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNjYWxlVHlwZSA9IHZhbHVlT3JEZWZhdWx0KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcbiAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcbiAgICAgICAgc2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG4gICAgICB9XG4gICAgICB1cGRhdGVkW2lkXSA9IHRydWU7XG4gICAgICBsZXQgc2NhbGUgPSBudWxsO1xuICAgICAgaWYgKGlkIGluIHNjYWxlcyAmJiBzY2FsZXNbaWRdLnR5cGUgPT09IHNjYWxlVHlwZSkge1xuICAgICAgICBzY2FsZSA9IHNjYWxlc1tpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzY2FsZUNsYXNzID0gcmVnaXN0cnkuZ2V0U2NhbGUoc2NhbGVUeXBlKTtcbiAgICAgICAgc2NhbGUgPSBuZXcgc2NhbGVDbGFzcyh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdHlwZTogc2NhbGVUeXBlLFxuICAgICAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICAgICAgY2hhcnQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcbiAgICAgIH1cbiAgICAgIHNjYWxlLmluaXQoc2NhbGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBlYWNoKHVwZGF0ZWQsIChoYXNVcGRhdGVkLCBpZCkgPT4ge1xuICAgICAgaWYgKCFoYXNVcGRhdGVkKSB7XG4gICAgICAgIGRlbGV0ZSBzY2FsZXNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVhY2goc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMuY29uZmlndXJlKHRoaXMsIHNjYWxlLCBzY2FsZS5vcHRpb25zKTtcbiAgICAgIGxheW91dHMuYWRkQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlTWV0YXNldHMoKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBjb25zdCBudW1EYXRhID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1NZXRhID0gbWV0YXNldHMubGVuZ3RoO1xuICAgIG1ldGFzZXRzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KTtcbiAgICBpZiAobnVtTWV0YSA+IG51bURhdGEpIHtcbiAgICAgIGZvciAobGV0IGkgPSBudW1EYXRhOyBpIDwgbnVtTWV0YTsgKytpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGFzZXRzLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gbWV0YXNldHMuc2xpY2UoMCkuc29ydChjb21wYXJlMkxldmVsKCdvcmRlcicsICdpbmRleCcpKTtcbiAgfVxuICBfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSB7XG4gICAgY29uc3Qge19tZXRhc2V0czogbWV0YXNldHMsIGRhdGE6IHtkYXRhc2V0c319ID0gdGhpcztcbiAgICBpZiAobWV0YXNldHMubGVuZ3RoID4gZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RhY2tzO1xuICAgIH1cbiAgICBtZXRhc2V0cy5mb3JFYWNoKChtZXRhLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGRhdGFzZXRzLmZpbHRlcih4ID0+IHggPT09IG1ldGEuX2RhdGFzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpIHtcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRzID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzW2ldO1xuICAgICAgbGV0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCB0aGlzLmNvbmZpZy50eXBlO1xuICAgICAgaWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGEudHlwZSA9IHR5cGU7XG4gICAgICBtZXRhLmluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgbWV0YS5vcmRlciA9IGRhdGFzZXQub3JkZXIgfHwgMDtcbiAgICAgIG1ldGEuaW5kZXggPSBpO1xuICAgICAgbWV0YS5sYWJlbCA9ICcnICsgZGF0YXNldC5sYWJlbDtcbiAgICAgIG1ldGEudmlzaWJsZSA9IHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKTtcbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQ29udHJvbGxlckNsYXNzID0gcmVnaXN0cnkuZ2V0Q29udHJvbGxlcih0eXBlKTtcbiAgICAgICAgY29uc3Qge2RhdGFzZXRFbGVtZW50VHlwZSwgZGF0YUVsZW1lbnRUeXBlfSA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdO1xuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICBkYXRhRWxlbWVudFR5cGU6IHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YUVsZW1lbnRUeXBlKSxcbiAgICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGRhdGFzZXRFbGVtZW50VHlwZSAmJiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFzZXRFbGVtZW50VHlwZSlcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyQ2xhc3ModGhpcywgaSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXJzLnB1c2gobWV0YS5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlTWV0YXNldHMoKTtcbiAgICByZXR1cm4gbmV3Q29udHJvbGxlcnM7XG4gIH1cbiAgX3Jlc2V0RWxlbWVudHMoKSB7XG4gICAgZWFjaCh0aGlzLmRhdGEuZGF0YXNldHMsIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzZXQnKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbmZpZy51cGRhdGUoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFuaW1zRGlzYWJsZWQgPSB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSAhb3B0aW9ucy5hbmltYXRpb247XG4gICAgdGhpcy5fdXBkYXRlU2NhbGVzKCk7XG4gICAgdGhpcy5fY2hlY2tFdmVudEJpbmRpbmdzKCk7XG4gICAgdGhpcy5fdXBkYXRlSGlkZGVuSW5kaWNlcygpO1xuICAgIHRoaXMuX3BsdWdpbnMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gdGhpcy5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XG4gICAgbGV0IG1pblBhZGRpbmcgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3Qge2NvbnRyb2xsZXJ9ID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gIWFuaW1zRGlzYWJsZWQgJiYgbmV3Q29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSA9PT0gLTE7XG4gICAgICBjb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldCk7XG4gICAgICBtaW5QYWRkaW5nID0gTWF0aC5tYXgoK2NvbnRyb2xsZXIuZ2V0TWF4T3ZlcmZsb3coKSwgbWluUGFkZGluZyk7XG4gICAgfVxuICAgIG1pblBhZGRpbmcgPSB0aGlzLl9taW5QYWRkaW5nID0gb3B0aW9ucy5sYXlvdXQuYXV0b1BhZGRpbmcgPyBtaW5QYWRkaW5nIDogMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XG4gICAgaWYgKCFhbmltc0Rpc2FibGVkKSB7XG4gICAgICBlYWNoKG5ld0NvbnRyb2xsZXJzLCAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlRGF0YXNldHMobW9kZSk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlclVwZGF0ZScsIHttb2RlfSk7XG4gICAgdGhpcy5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuICAgIGNvbnN0IHtfYWN0aXZlLCBfbGFzdEV2ZW50fSA9IHRoaXM7XG4gICAgaWYgKF9sYXN0RXZlbnQpIHtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihfbGFzdEV2ZW50LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKF9hY3RpdmUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhfYWN0aXZlLCBfYWN0aXZlLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuICBfdXBkYXRlU2NhbGVzKCkge1xuICAgIGVhY2godGhpcy5zY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5yZW1vdmVCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuICAgIHRoaXMuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuICAgIHRoaXMuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuICB9XG4gIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gbmV3IFNldChvcHRpb25zLmV2ZW50cyk7XG4gICAgaWYgKCFzZXRzRXF1YWwoZXhpc3RpbmdFdmVudHMsIG5ld0V2ZW50cykgfHwgISF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzICE9PSBvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUhpZGRlbkluZGljZXMoKSB7XG4gICAgY29uc3Qge19oaWRkZW5JbmRpY2VzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHx8IFtdO1xuICAgIGZvciAoY29uc3Qge21ldGhvZCwgc3RhcnQsIGNvdW50fSBvZiBjaGFuZ2VzKSB7XG4gICAgICBjb25zdCBtb3ZlID0gbWV0aG9kID09PSAnX3JlbW92ZUVsZW1lbnRzJyA/IC1jb3VudCA6IGNvdW50O1xuICAgICAgbW92ZU51bWVyaWNLZXlzKF9oaWRkZW5JbmRpY2VzLCBzdGFydCwgbW92ZSk7XG4gICAgfVxuICB9XG4gIF9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB7XG4gICAgY29uc3QgX2RhdGFDaGFuZ2VzID0gdGhpcy5fZGF0YUNoYW5nZXM7XG4gICAgaWYgKCFfZGF0YUNoYW5nZXMgfHwgIV9kYXRhQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0Q291bnQgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG1ha2VTZXQgPSAoaWR4KSA9PiBuZXcgU2V0KFxuICAgICAgX2RhdGFDaGFuZ2VzXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjWzBdID09PSBpZHgpXG4gICAgICAgIC5tYXAoKGMsIGkpID0+IGkgKyAnLCcgKyBjLnNwbGljZSgxKS5qb2luKCcsJykpXG4gICAgKTtcbiAgICBjb25zdCBjaGFuZ2VTZXQgPSBtYWtlU2V0KDApO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YXNldENvdW50OyBpKyspIHtcbiAgICAgIGlmICghc2V0c0VxdWFsKGNoYW5nZVNldCwgbWFrZVNldChpKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShjaGFuZ2VTZXQpXG4gICAgICAubWFwKGMgPT4gYy5zcGxpdCgnLCcpKVxuICAgICAgLm1hcChhID0+ICh7bWV0aG9kOiBhWzFdLCBzdGFydDogK2FbMl0sIGNvdW50OiArYVszXX0pKTtcbiAgfVxuICBfdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVMYXlvdXQnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbWluUGFkZGluZyk7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG5vQXJlYSA9IGFyZWEud2lkdGggPD0gMCB8fCBhcmVhLmhlaWdodCA8PSAwO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIGVhY2godGhpcy5ib3hlcywgKGJveCkgPT4ge1xuICAgICAgaWYgKG5vQXJlYSAmJiBib3gucG9zaXRpb24gPT09ICdjaGFydEFyZWEnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChib3guY29uZmlndXJlKSB7XG4gICAgICAgIGJveC5jb25maWd1cmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgaXRlbS5faWR4ID0gaW5kZXg7XG4gICAgfSk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckxheW91dCcpO1xuICB9XG4gIF91cGRhdGVEYXRhc2V0cyhtb2RlKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci5jb25maWd1cmUoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEYXRhc2V0KGksIGlzRnVuY3Rpb24obW9kZSkgPyBtb2RlKHtkYXRhc2V0SW5kZXg6IGl9KSA6IG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNVcGRhdGUnLCB7bW9kZX0pO1xuICB9XG4gIF91cGRhdGVEYXRhc2V0KGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgIGNvbnN0IGFyZ3MgPSB7bWV0YSwgaW5kZXgsIG1vZGUsIGNhbmNlbGFibGU6IHRydWV9O1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWV0YS5jb250cm9sbGVyLl91cGRhdGUobW9kZSk7XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRVcGRhdGUnLCBhcmdzKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlUmVuZGVyJywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFuaW1hdG9yLmhhcyh0aGlzKSkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgICAgYW5pbWF0b3Iuc3RhcnQodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgb25BbmltYXRpb25zQ29tcGxldGUoe2NoYXJ0OiB0aGlzfSk7XG4gICAgfVxuICB9XG4gIGRyYXcoKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcpIHtcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXc7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoICYmIGxheWVyc1tpXS56IDw9IDA7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cbiAgICB0aGlzLl9kcmF3RGF0YXNldHMoKTtcbiAgICBmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRHJhdycpO1xuICB9XG4gIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fc29ydGVkTWV0YXNldHM7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzZXRzW2ldO1xuICAgICAgaWYgKCFmaWx0ZXJWaXNpYmxlIHx8IG1ldGEudmlzaWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModHJ1ZSk7XG4gIH1cbiAgX2RyYXdEYXRhc2V0cygpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c0RyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGhpcy5fZHJhd0RhdGFzZXQobWV0YXNldHNbaV0pO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNEcmF3Jyk7XG4gIH1cbiAgX2RyYXdEYXRhc2V0KG1ldGEpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgICBjb25zdCB1c2VDbGlwID0gIWNsaXAuZGlzYWJsZWQ7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuY2hhcnRBcmVhO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBtZXRhLFxuICAgICAgaW5kZXg6IG1ldGEuaW5kZXgsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0RHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgY2xpcEFyZWEoY3R4LCB7XG4gICAgICAgIGxlZnQ6IGNsaXAubGVmdCA9PT0gZmFsc2UgPyAwIDogYXJlYS5sZWZ0IC0gY2xpcC5sZWZ0LFxuICAgICAgICByaWdodDogY2xpcC5yaWdodCA9PT0gZmFsc2UgPyB0aGlzLndpZHRoIDogYXJlYS5yaWdodCArIGNsaXAucmlnaHQsXG4gICAgICAgIHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gY2xpcC50b3AsXG4gICAgICAgIGJvdHRvbTogY2xpcC5ib3R0b20gPT09IGZhbHNlID8gdGhpcy5oZWlnaHQgOiBhcmVhLmJvdHRvbSArIGNsaXAuYm90dG9tXG4gICAgICB9KTtcbiAgICB9XG4gICAgbWV0YS5jb250cm9sbGVyLmRyYXcoKTtcbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldERyYXcnLCBhcmdzKTtcbiAgfVxuICBpc1BvaW50SW5BcmVhKHBvaW50KSB7XG4gICAgcmV0dXJuIF9pc1BvaW50SW5BcmVhKHBvaW50LCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZyk7XG4gIH1cbiAgZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBtb2RlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbWV0aG9kID0gSW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBsZXQgbWV0YSA9IG1ldGFzZXRzLmZpbHRlcih4ID0+IHggJiYgeC5fZGF0YXNldCA9PT0gZGF0YXNldCkucG9wKCk7XG4gICAgaWYgKCFtZXRhKSB7XG4gICAgICBtZXRhID0ge1xuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZGF0YXNldDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbCxcbiAgICAgICAgaGlkZGVuOiBudWxsLFxuICAgICAgICB4QXhpc0lEOiBudWxsLFxuICAgICAgICB5QXhpc0lEOiBudWxsLFxuICAgICAgICBvcmRlcjogZGF0YXNldCAmJiBkYXRhc2V0Lm9yZGVyIHx8IDAsXG4gICAgICAgIGluZGV4OiBkYXRhc2V0SW5kZXgsXG4gICAgICAgIF9kYXRhc2V0OiBkYXRhc2V0LFxuICAgICAgICBfcGFyc2VkOiBbXSxcbiAgICAgICAgX3NvcnRlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBtZXRhc2V0cy5wdXNoKG1ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsLCB7Y2hhcnQ6IHRoaXMsIHR5cGU6ICdjaGFydCd9KSk7XG4gIH1cbiAgZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkubGVuZ3RoO1xuICB9XG4gIGlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICFkYXRhc2V0LmhpZGRlbjtcbiAgfVxuICBzZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIG1ldGEuaGlkZGVuID0gIXZpc2libGU7XG4gIH1cbiAgdG9nZ2xlRGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XSA9ICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuICBnZXREYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cbiAgX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtb2RlID0gdmlzaWJsZSA/ICdzaG93JyA6ICdoaWRlJztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IGFuaW1zID0gbWV0YS5jb250cm9sbGVyLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpO1xuICAgIGlmIChkZWZpbmVkKGRhdGFJbmRleCkpIHtcbiAgICAgIG1ldGEuZGF0YVtkYXRhSW5kZXhdLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpO1xuICAgICAgYW5pbXMudXBkYXRlKG1ldGEsIHt2aXNpYmxlfSk7XG4gICAgICB0aGlzLnVwZGF0ZSgoY3R4KSA9PiBjdHguZGF0YXNldEluZGV4ID09PSBkYXRhc2V0SW5kZXggPyBtb2RlIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cbiAgaGlkZShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIGZhbHNlKTtcbiAgfVxuICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdHJ1ZSk7XG4gIH1cbiAgX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAobWV0YSAmJiBtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgIG1ldGEuY29udHJvbGxlci5fZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgfVxuICBfc3RvcCgpIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBhbmltYXRvci5yZW1vdmUodGhpcyk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURlc3Ryb3knKTtcbiAgICBjb25zdCB7Y2FudmFzLCBjdHh9ID0gdGhpcztcbiAgICB0aGlzLl9zdG9wKCk7XG4gICAgdGhpcy5jb25maWcuY2xlYXJDYWNoZSgpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCk7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnZGVzdHJveScpO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRlc3Ryb3knKTtcbiAgfVxuICB0b0Jhc2U2NEltYWdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMKC4uLmFyZ3MpO1xuICB9XG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5iaW5kVXNlckV2ZW50cygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5iaW5kUmVzcG9uc2l2ZUV2ZW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgYmluZFVzZXJFdmVudHMoKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZSwgeCwgeSkgPT4ge1xuICAgICAgZS5vZmZzZXRYID0geDtcbiAgICAgIGUub2Zmc2V0WSA9IHk7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoZSk7XG4gICAgfTtcbiAgICBlYWNoKHRoaXMub3B0aW9ucy5ldmVudHMsICh0eXBlKSA9PiBfYWRkKHR5cGUsIGxpc3RlbmVyKSk7XG4gIH1cbiAgYmluZFJlc3BvbnNpdmVFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGlzdGVuZXIgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGRldGFjaGVkO1xuICAgIGNvbnN0IGF0dGFjaGVkID0gKCkgPT4ge1xuICAgICAgX3JlbW92ZSgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgX2FkZCgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgX2FkZCgnZGV0YWNoJywgZGV0YWNoZWQpO1xuICAgIH07XG4gICAgZGV0YWNoZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgICBfcmVtb3ZlKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICB0aGlzLl9zdG9wKCk7XG4gICAgICB0aGlzLl9yZXNpemUoMCwgMCk7XG4gICAgICBfYWRkKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgfTtcbiAgICBpZiAocGxhdGZvcm0uaXNBdHRhY2hlZCh0aGlzLmNhbnZhcykpIHtcbiAgICAgIGF0dGFjaGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFjaGVkKCk7XG4gICAgfVxuICB9XG4gIHVuYmluZEV2ZW50cygpIHtcbiAgICBlYWNoKHRoaXMuX2xpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIGVhY2godGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlSG92ZXJTdHlsZShpdGVtcywgbW9kZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IHByZWZpeCA9IGVuYWJsZWQgPyAnc2V0JyA6ICdyZW1vdmUnO1xuICAgIGxldCBtZXRhLCBpdGVtLCBpLCBpbGVuO1xuICAgIGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLmRhdGFzZXRJbmRleCk7XG4gICAgICBtZXRhLmNvbnRyb2xsZXJbJ18nICsgcHJlZml4ICsgJ0RhdGFzZXRIb3ZlclN0eWxlJ10oKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGl0ZW0gJiYgdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShpdGVtLmVsZW1lbnQsIGl0ZW0uZGF0YXNldEluZGV4LCBpdGVtLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cykge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICB9XG4gIH1cbiAgbm90aWZ5UGx1Z2lucyhob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcbiAgfVxuICBfdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpIHtcbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LmRhdGFzZXRJbmRleCA9PT0geS5kYXRhc2V0SW5kZXggJiYgeC5pbmRleCA9PT0geS5pbmRleCkpO1xuICAgIGNvbnN0IGRlYWN0aXZhdGVkID0gZGlmZihsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IGFjdGl2YXRlZCA9IHJlcGxheSA/IGFjdGl2ZSA6IGRpZmYoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoZGVhY3RpdmF0ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoZGVhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhY3RpdmF0ZWQubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9ldmVudEhhbmRsZXIoZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgcmVwbGF5LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGluQ2hhcnRBcmVhOiB0aGlzLmlzUG9pbnRJbkFyZWEoZSlcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50RmlsdGVyID0gKHBsdWdpbikgPT4gKHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLm5hdGl2ZS50eXBlKTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgYXJncy5pbkNoYXJ0QXJlYSk7XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpO1xuICAgIGlmIChjaGFuZ2VkIHx8IGFyZ3MuY2hhbmdlZCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCB7X2FjdGl2ZTogbGFzdEFjdGl2ZSA9IFtdLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgaXNDbGljayA9IF9pc0NsaWNrRXZlbnQoZSk7XG4gICAgY29uc3QgbGFzdEV2ZW50ID0gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIHRoaXMuX2xhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spO1xuICAgIGlmIChpbkNoYXJ0QXJlYSkge1xuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciwgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgY2FsbGJhY2sob3B0aW9ucy5vbkNsaWNrLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgcmV0dXJuIGxhc3RBY3RpdmU7XG4gICAgfVxuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG59XG5jb25zdCBpbnZhbGlkYXRlUGx1Z2lucyA9ICgpID0+IGVhY2goQ2hhcnQuaW5zdGFuY2VzLCAoY2hhcnQpID0+IGNoYXJ0Ll9wbHVnaW5zLmludmFsaWRhdGUoKSk7XG5jb25zdCBlbnVtZXJhYmxlID0gdHJ1ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYXJ0LCB7XG4gIGRlZmF1bHRzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZGVmYXVsdHNcbiAgfSxcbiAgaW5zdGFuY2VzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogaW5zdGFuY2VzXG4gIH0sXG4gIG92ZXJyaWRlczoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IG92ZXJyaWRlc1xuICB9LFxuICByZWdpc3RyeToge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IHJlZ2lzdHJ5XG4gIH0sXG4gIHZlcnNpb246IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiB2ZXJzaW9uXG4gIH0sXG4gIGdldENoYXJ0OiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZ2V0Q2hhcnRcbiAgfSxcbiAgcmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJlZ2lzdHJ5LmFkZCguLi5pdGVtcyk7XG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3Rlcjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6ICguLi5pdGVtcykgPT4ge1xuICAgICAgcmVnaXN0cnkucmVtb3ZlKC4uLml0ZW1zKTtcbiAgICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLicpO1xufVxuY2xhc3MgRGF0ZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuICBpbml0KGNoYXJ0T3B0aW9ucykge31cbiAgZm9ybWF0cygpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBwYXJzZSh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZm9ybWF0KHRpbWVzdGFtcCwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgYWRkKHRpbWVzdGFtcCwgYW1vdW50LCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZGlmZihhLCBiLCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgc3RhcnRPZih0aW1lc3RhbXAsIHVuaXQsIHdlZWtkYXkpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBlbmRPZih0aW1lc3RhbXAsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuRGF0ZUFkYXB0ZXIub3ZlcnJpZGUgPSBmdW5jdGlvbihtZW1iZXJzKSB7XG4gIE9iamVjdC5hc3NpZ24oRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCBtZW1iZXJzKTtcbn07XG52YXIgX2FkYXB0ZXJzID0ge1xuICBfZGF0ZTogRGF0ZUFkYXB0ZXJcbn07XG5cbmZ1bmN0aW9uIGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCB0eXBlKSB7XG4gIGlmICghc2NhbGUuX2NhY2hlLiRiYXIpIHtcbiAgICBjb25zdCB2aXNpYmxlTWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKTtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB2aXNpYmxlTWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHZpc2libGVNZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xuICAgIH1cbiAgICBzY2FsZS5fY2FjaGUuJGJhciA9IF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcbiAgfVxuICByZXR1cm4gc2NhbGUuX2NhY2hlLiRiYXI7XG59XG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKSB7XG4gIGNvbnN0IHNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZhbHVlcyA9IGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCBtZXRhLnR5cGUpO1xuICBsZXQgbWluID0gc2NhbGUuX2xlbmd0aDtcbiAgbGV0IGksIGlsZW4sIGN1cnIsIHByZXY7XG4gIGNvbnN0IHVwZGF0ZU1pbkFuZFByZXYgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnIgPT09IDMyNzY3IHx8IGN1cnIgPT09IC0zMjc2OCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChwcmV2KSkge1xuICAgICAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmFicyhjdXJyIC0gcHJldikgfHwgbWluKTtcbiAgICB9XG4gICAgcHJldiA9IGN1cnI7XG4gIH07XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWVzW2ldKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cbiAgcHJldiA9IHVuZGVmaW5lZDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHNjYWxlLnRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG4gIHJldHVybiBtaW47XG59XG5mdW5jdGlvbiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHRoaWNrbmVzcyA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xuICBsZXQgc2l6ZSwgcmF0aW87XG4gIGlmIChpc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcbiAgICBzaXplID0gcnVsZXIubWluICogb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gICAgcmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XG4gIH0gZWxzZSB7XG4gICAgc2l6ZSA9IHRoaWNrbmVzcyAqIHN0YWNrQ291bnQ7XG4gICAgcmF0aW8gPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvLFxuICAgIHN0YXJ0OiBydWxlci5waXhlbHNbaW5kZXhdIC0gKHNpemUgLyAyKVxuICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuICBjb25zdCBjdXJyID0gcGl4ZWxzW2luZGV4XTtcbiAgbGV0IHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XG4gIGxldCBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcbiAgY29uc3QgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgIHByZXYgPSBjdXJyIC0gKG5leHQgPT09IG51bGwgPyBydWxlci5lbmQgLSBydWxlci5zdGFydCA6IG5leHQgLSBjdXJyKTtcbiAgfVxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG4gIH1cbiAgY29uc3Qgc3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcbiAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxuICAgIHN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgY29uc3Qgc3RhcnRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVswXSwgaSk7XG4gIGNvbnN0IGVuZFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzFdLCBpKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGxldCBiYXJTdGFydCA9IG1pbjtcbiAgbGV0IGJhckVuZCA9IG1heDtcbiAgaWYgKE1hdGguYWJzKG1pbikgPiBNYXRoLmFicyhtYXgpKSB7XG4gICAgYmFyU3RhcnQgPSBtYXg7XG4gICAgYmFyRW5kID0gbWluO1xuICB9XG4gIGl0ZW1bdlNjYWxlLmF4aXNdID0gYmFyRW5kO1xuICBpdGVtLl9jdXN0b20gPSB7XG4gICAgYmFyU3RhcnQsXG4gICAgYmFyRW5kLFxuICAgIHN0YXJ0OiBzdGFydFZhbHVlLFxuICAgIGVuZDogZW5kVmFsdWUsXG4gICAgbWluLFxuICAgIG1heFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGlmIChpc0FycmF5KGVudHJ5KSkge1xuICAgIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbVt2U2NhbGUuYXhpc10gPSB2U2NhbGUucGFyc2UoZW50cnksIGkpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuZnVuY3Rpb24gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgY29uc3QgcGFyc2VkID0gW107XG4gIGxldCBpLCBpbGVuLCBpdGVtLCBlbnRyeTtcbiAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZW50cnkgPSBkYXRhW2ldO1xuICAgIGl0ZW0gPSB7fTtcbiAgICBpdGVtW2lTY2FsZS5heGlzXSA9IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaV0sIGkpO1xuICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5mdW5jdGlvbiBpc0Zsb2F0QmFyKGN1c3RvbSkge1xuICByZXR1cm4gY3VzdG9tICYmIGN1c3RvbS5iYXJTdGFydCAhPT0gdW5kZWZpbmVkICYmIGN1c3RvbS5iYXJFbmQgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSB7XG4gIGlmIChzaXplICE9PSAwKSB7XG4gICAgcmV0dXJuIHNpZ24oc2l6ZSk7XG4gIH1cbiAgcmV0dXJuICh2U2NhbGUuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHZTY2FsZS5taW4gPj0gYWN0dWFsQmFzZSA/IDEgOiAtMSk7XG59XG5mdW5jdGlvbiBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKSB7XG4gIGxldCByZXZlcnNlLCBzdGFydCwgZW5kLCB0b3AsIGJvdHRvbTtcbiAgaWYgKHByb3BlcnRpZXMuaG9yaXpvbnRhbCkge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPiBwcm9wZXJ0aWVzLng7XG4gICAgc3RhcnQgPSAnbGVmdCc7XG4gICAgZW5kID0gJ3JpZ2h0JztcbiAgfSBlbHNlIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlIDwgcHJvcGVydGllcy55O1xuICAgIHN0YXJ0ID0gJ2JvdHRvbSc7XG4gICAgZW5kID0gJ3RvcCc7XG4gIH1cbiAgaWYgKHJldmVyc2UpIHtcbiAgICB0b3AgPSAnZW5kJztcbiAgICBib3R0b20gPSAnc3RhcnQnO1xuICB9IGVsc2Uge1xuICAgIHRvcCA9ICdzdGFydCc7XG4gICAgYm90dG9tID0gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX07XG59XG5mdW5jdGlvbiBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCkge1xuICBsZXQgZWRnZSA9IG9wdGlvbnMuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgcmVzID0ge307XG4gIGlmICghZWRnZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVkZ2UgPT09IHRydWUpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSB7dG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlLCBsZWZ0OiB0cnVlfTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfSA9IGJvcmRlclByb3BzKHByb3BlcnRpZXMpO1xuICBpZiAoZWRnZSA9PT0gJ21pZGRsZScgJiYgc3RhY2spIHtcbiAgICBwcm9wZXJ0aWVzLmVuYWJsZUJvcmRlclJhZGl1cyA9IHRydWU7XG4gICAgaWYgKChzdGFjay5fdG9wIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9IGVsc2UgaWYgKChzdGFjay5fYm90dG9tIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IGJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW3BhcnNlRWRnZShib3R0b20sIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH1cbiAgfVxuICByZXNbcGFyc2VFZGdlKGVkZ2UsIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbn1cbmZ1bmN0aW9uIHBhcnNlRWRnZShlZGdlLCBhLCBiLCByZXZlcnNlKSB7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgZWRnZSA9IHN3YXAoZWRnZSwgYSwgYik7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGIsIGEpO1xuICB9IGVsc2Uge1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBhLCBiKTtcbiAgfVxuICByZXR1cm4gZWRnZTtcbn1cbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XG4gIHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5mdW5jdGlvbiBzdGFydEVuZCh2LCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB2ID09PSAnc3RhcnQnID8gc3RhcnQgOiB2ID09PSAnZW5kJyA/IGVuZCA6IHY7XG59XG5mdW5jdGlvbiBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIHtpbmZsYXRlQW1vdW50fSwgcmF0aW8pIHtcbiAgcHJvcGVydGllcy5pbmZsYXRlQW1vdW50ID0gaW5mbGF0ZUFtb3VudCA9PT0gJ2F1dG8nXG4gICAgPyByYXRpbyA9PT0gMSA/IDAuMzMgOiAwXG4gICAgOiBpbmZsYXRlQW1vdW50O1xufVxuY2xhc3MgQmFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgbGV0IGksIGlsZW4sIGl0ZW0sIG9iajtcbiAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9iaiA9IGRhdGFbaV07XG4gICAgICBpdGVtID0ge307XG4gICAgICBpdGVtW2lTY2FsZS5heGlzXSA9IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgaUF4aXNLZXkpLCBpKTtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUocmVzb2x2ZU9iamVjdEtleShvYmosIHZBeGlzS2V5KSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIHN1cGVyLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGlmIChjdXN0b20gJiYgc2NhbGUgPT09IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlKSB7XG4gICAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIGN1c3RvbS5taW4pO1xuICAgICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCBjdXN0b20ubWF4KTtcbiAgICB9XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzRmxvYXRCYXIoY3VzdG9tKVxuICAgICAgPyAnWycgKyBjdXN0b20uc3RhcnQgKyAnLCAnICsgY3VzdG9tLmVuZCArICddJ1xuICAgICAgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuc3RhY2sgPSB0aGlzLmdldERhdGFzZXQoKS5zdGFjaztcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMobWV0YS5kYXRhLCAwLCBtZXRhLmRhdGEubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhiYXJzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2luZGV4LCBfY2FjaGVkTWV0YToge3ZTY2FsZX19ID0gdGhpcztcbiAgICBjb25zdCBiYXNlID0gdlNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB2U2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgcnVsZXIgPSB0aGlzLl9nZXRSdWxlcigpO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgdnBpeGVscyA9IHJlc2V0IHx8IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZTY2FsZS5heGlzXSkgPyB7YmFzZSwgaGVhZDogYmFzZX0gOiB0aGlzLl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpKTtcbiAgICAgIGNvbnN0IGlwaXhlbHMgPSB0aGlzLl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpLCBydWxlcik7XG4gICAgICBjb25zdCBzdGFjayA9IChwYXJzZWQuX3N0YWNrcyB8fCB7fSlbdlNjYWxlLmF4aXNdO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgYmFzZTogdnBpeGVscy5iYXNlLFxuICAgICAgICBlbmFibGVCb3JkZXJSYWRpdXM6ICFzdGFjayB8fCBpc0Zsb2F0QmFyKHBhcnNlZC5fY3VzdG9tKSB8fCAoaW5kZXggPT09IHN0YWNrLl90b3AgfHwgaW5kZXggPT09IHN0YWNrLl9ib3R0b20pLFxuICAgICAgICB4OiBob3Jpem9udGFsID8gdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXIsXG4gICAgICAgIHk6IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHZwaXhlbHMuaGVhZCxcbiAgICAgICAgaGVpZ2h0OiBob3Jpem9udGFsID8gaXBpeGVscy5zaXplIDogTWF0aC5hYnModnBpeGVscy5zaXplKSxcbiAgICAgICAgd2lkdGg6IGhvcml6b250YWwgPyBNYXRoLmFicyh2cGl4ZWxzLnNpemUpIDogaXBpeGVscy5zaXplXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGJhcnNbaV0uYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnMgfHwgYmFyc1tpXS5vcHRpb25zO1xuICAgICAgc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpO1xuICAgICAgc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCBvcHRpb25zLCBydWxlci5yYXRpbyk7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYmFyc1tpXSwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIF9nZXRTdGFja3MobGFzdCwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qge2lTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gaVNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHRoaXMuX3R5cGUpXG4gICAgICAuZmlsdGVyKG1ldGEgPT4gbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuZ3JvdXBlZCk7XG4gICAgY29uc3Qgc3RhY2tlZCA9IGlTY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gICAgY29uc3Qgc3RhY2tzID0gW107XG4gICAgY29uc3Qgc2tpcE51bGwgPSAobWV0YSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gbWV0YS5jb250cm9sbGVyLmdldFBhcnNlZChkYXRhSW5kZXgpO1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VkICYmIHBhcnNlZFttZXRhLnZTY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbCkgfHwgaXNOYU4odmFsKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgbWV0YSBvZiBtZXRhc2V0cykge1xuICAgICAgaWYgKGRhdGFJbmRleCAhPT0gdW5kZWZpbmVkICYmIHNraXBOdWxsKG1ldGEpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWNrZWQgPT09IGZhbHNlIHx8IHN0YWNrcy5pbmRleE9mKG1ldGEuc3RhY2spID09PSAtMSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc3RhY2tzLnB1c2gobWV0YS5zdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAobWV0YS5pbmRleCA9PT0gbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzdGFja3MubGVuZ3RoKSB7XG4gICAgICBzdGFja3MucHVzaCh1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG4gIF9nZXRTdGFja0NvdW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh1bmRlZmluZWQsIGluZGV4KS5sZW5ndGg7XG4gIH1cbiAgX2dldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBuYW1lLCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCBzdGFja3MgPSB0aGlzLl9nZXRTdGFja3MoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpO1xuICAgIGNvbnN0IGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgID8gc3RhY2tzLmluZGV4T2YobmFtZSlcbiAgICAgIDogLTE7XG4gICAgcmV0dXJuIChpbmRleCA9PT0gLTEpXG4gICAgICA/IHN0YWNrcy5sZW5ndGggLSAxXG4gICAgICA6IGluZGV4O1xuICB9XG4gIF9nZXRSdWxlcigpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHBpeGVscyA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwaXhlbHMucHVzaChpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKVtpU2NhbGUuYXhpc10sIGkpKTtcbiAgICB9XG4gICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW4sXG4gICAgICBwaXhlbHMsXG4gICAgICBzdGFydDogaVNjYWxlLl9zdGFydFBpeGVsLFxuICAgICAgZW5kOiBpU2NhbGUuX2VuZFBpeGVsLFxuICAgICAgc3RhY2tDb3VudDogdGhpcy5fZ2V0U3RhY2tDb3VudCgpLFxuICAgICAgc2NhbGU6IGlTY2FsZSxcbiAgICAgIGdyb3VwZWQ6IG9wdHMuZ3JvdXBlZCxcbiAgICAgIHJhdGlvOiBiYXJUaGlja25lc3MgPyAxIDogb3B0cy5jYXRlZ29yeVBlcmNlbnRhZ2UgKiBvcHRzLmJhclBlcmNlbnRhZ2VcbiAgICB9O1xuICB9XG4gIF9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpbmRleCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YToge3ZTY2FsZSwgX3N0YWNrZWR9LCBvcHRpb25zOiB7YmFzZTogYmFzZVZhbHVlLCBtaW5CYXJMZW5ndGh9fSA9IHRoaXM7XG4gICAgY29uc3QgYWN0dWFsQmFzZSA9IGJhc2VWYWx1ZSB8fCAwO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCBmbG9hdGluZyA9IGlzRmxvYXRCYXIoY3VzdG9tKTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRbdlNjYWxlLmF4aXNdO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGxlbmd0aCA9IF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiB2YWx1ZTtcbiAgICBsZXQgaGVhZCwgc2l6ZTtcbiAgICBpZiAobGVuZ3RoICE9PSB2YWx1ZSkge1xuICAgICAgc3RhcnQgPSBsZW5ndGggLSB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiBzaWduKHZhbHVlKSAhPT0gc2lnbihjdXN0b20uYmFyRW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCArPSB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9ICFpc051bGxPclVuZGVmKGJhc2VWYWx1ZSkgJiYgIWZsb2F0aW5nID8gYmFzZVZhbHVlIDogc3RhcnQ7XG4gICAgbGV0IGJhc2UgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydFZhbHVlKTtcbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQgPSBiYXNlO1xuICAgIH1cbiAgICBzaXplID0gaGVhZCAtIGJhc2U7XG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwKTtcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuICAgIH1cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemUsXG4gICAgICBiYXNlLFxuICAgICAgaGVhZCxcbiAgICAgIGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG4gICAgfTtcbiAgfVxuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpO1xuICAgICAgY29uc3Qgc3RhY2tJbmRleCA9IHRoaXMuX2dldFN0YWNrSW5kZXgodGhpcy5pbmRleCwgdGhpcy5fY2FjaGVkTWV0YS5zdGFjaywgc2tpcE51bGwgPyBpbmRleCA6IHVuZGVmaW5lZCk7XG4gICAgICBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCByYW5nZS5jaHVuayAqIHJhbmdlLnJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VudGVyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpbmRleClbc2NhbGUuYXhpc10sIGluZGV4KTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJ1bGVyLm1pbiAqIHJ1bGVyLnJhdGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IGNlbnRlciAtIHNpemUgLyAyLFxuICAgICAgaGVhZDogY2VudGVyICsgc2l6ZSAvIDIsXG4gICAgICBjZW50ZXIsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAodGhpcy5nZXRQYXJzZWQoaSlbdlNjYWxlLmF4aXNdICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3RzW2ldLmRyYXcodGhpcy5fY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbkJhckNvbnRyb2xsZXIuaWQgPSAnYmFyJztcbkJhckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ2JhcicsXG4gIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuICBiYXJQZXJjZW50YWdlOiAwLjksXG4gIGdyb3VwZWQ6IHRydWUsXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J11cbiAgICB9XG4gIH1cbn07XG5CYXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgX2luZGV4Xzoge1xuICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgIG9mZnNldDogdHJ1ZSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgb2Zmc2V0OiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBfdmFsdWVfOiB7XG4gICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgQnViYmxlQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW1bMl0sIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtICYmIGl0ZW0uciAmJiAraXRlbS5yLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgIGNvbnN0IHIgPSBwYXJzZWQuX2N1c3RvbTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IG1ldGEubGFiZWwsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgKHIgPyAnLCAnICsgciA6ICcnKSArICcpJ1xuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICFyZXNldCAmJiB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gcmVzZXQgPyBpU2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbdkF4aXNdKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMucmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBsZXQgdmFsdWVzID0gc3VwZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSk7XG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZXMsIHskc2hhcmVkOiBmYWxzZX0pO1xuICAgIH1cbiAgICBjb25zdCByYWRpdXMgPSB2YWx1ZXMucmFkaXVzO1xuICAgIGlmIChtb2RlICE9PSAnYWN0aXZlJykge1xuICAgICAgdmFsdWVzLnJhZGl1cyA9IDA7XG4gICAgfVxuICAgIHZhbHVlcy5yYWRpdXMgKz0gdmFsdWVPckRlZmF1bHQocGFyc2VkICYmIHBhcnNlZC5fY3VzdG9tLCByYWRpdXMpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbn1cbkJ1YmJsZUNvbnRyb2xsZXIuaWQgPSAnYnViYmxlJztcbkJ1YmJsZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJ11cbiAgICB9XG4gIH1cbn07XG5CdWJibGVDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgeDoge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfVxuICB9LFxuICBwbHVnaW5zOiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCkge1xuICBsZXQgcmF0aW9YID0gMTtcbiAgbGV0IHJhdGlvWSA9IDE7XG4gIGxldCBvZmZzZXRYID0gMDtcbiAgbGV0IG9mZnNldFkgPSAwO1xuICBpZiAoY2lyY3VtZmVyZW5jZSA8IFRBVSkge1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlO1xuICAgIGNvbnN0IHN0YXJ0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGVuZFggPSBNYXRoLmNvcyhlbmRBbmdsZSk7XG4gICAgY29uc3QgZW5kWSA9IE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBjYWxjTWF4ID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAxIDogTWF0aC5tYXgoYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgY2FsY01pbiA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gLTEgOiBNYXRoLm1pbihhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBtYXhYID0gY2FsY01heCgwLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1heFkgPSBjYWxjTWF4KEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgY29uc3QgbWluWCA9IGNhbGNNaW4oUEksIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWluWSA9IGNhbGNNaW4oUEkgKyBIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIHJhdGlvWCA9IChtYXhYIC0gbWluWCkgLyAyO1xuICAgIHJhdGlvWSA9IChtYXhZIC0gbWluWSkgLyAyO1xuICAgIG9mZnNldFggPSAtKG1heFggKyBtaW5YKSAvIDI7XG4gICAgb2Zmc2V0WSA9IC0obWF4WSArIG1pblkpIC8gMjtcbiAgfVxuICByZXR1cm4ge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfTtcbn1cbmNsYXNzIERvdWdobnV0Q29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgbGlua1NjYWxlcygpIHt9XG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFzZXQoKS5kYXRhO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGdldHRlciA9IChpKSA9PiArZGF0YVtpXTtcbiAgICAgIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgY29uc3Qge2tleSA9ICd2YWx1ZSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICAgICAgZ2V0dGVyID0gKGkpID0+ICtyZXNvbHZlT2JqZWN0S2V5KGRhdGFbaV0sIGtleSk7XG4gICAgICB9XG4gICAgICBsZXQgaSwgaWxlbjtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaV0gPSBnZXR0ZXIoaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9nZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5yb3RhdGlvbiAtIDkwKTtcbiAgfVxuICBfZ2V0Q2lyY3VtZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5jaXJjdW1mZXJlbmNlKTtcbiAgfVxuICBfZ2V0Um90YXRpb25FeHRlbnRzKCkge1xuICAgIGxldCBtaW4gPSBUQVU7XG4gICAgbGV0IG1heCA9IC1UQVU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBjb250cm9sbGVyLl9nZXRSb3RhdGlvbigpO1xuICAgICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gY29udHJvbGxlci5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJvdGF0aW9uKTtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByb3RhdGlvbiArIGNpcmN1bWZlcmVuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IG1pbixcbiAgICAgIGNpcmN1bWZlcmVuY2U6IG1heCAtIG1pbixcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHtjaGFydEFyZWF9ID0gY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXRNYXhCb3JkZXJXaWR0aCgpICsgdGhpcy5nZXRNYXhPZmZzZXQoYXJjcykgKyB0aGlzLm9wdGlvbnMuc3BhY2luZztcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoKE1hdGgubWluKGNoYXJ0QXJlYS53aWR0aCwgY2hhcnRBcmVhLmhlaWdodCkgLSBzcGFjaW5nKSAvIDIsIDApO1xuICAgIGNvbnN0IGN1dG91dCA9IE1hdGgubWluKHRvUGVyY2VudGFnZSh0aGlzLm9wdGlvbnMuY3V0b3V0LCBtYXhTaXplKSwgMSk7XG4gICAgY29uc3QgY2hhcnRXZWlnaHQgPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHRoaXMuaW5kZXgpO1xuICAgIGNvbnN0IHtjaXJjdW1mZXJlbmNlLCByb3RhdGlvbn0gPSB0aGlzLl9nZXRSb3RhdGlvbkV4dGVudHMoKTtcbiAgICBjb25zdCB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9ID0gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCk7XG4gICAgY29uc3QgbWF4V2lkdGggPSAoY2hhcnRBcmVhLndpZHRoIC0gc3BhY2luZykgLyByYXRpb1g7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gKGNoYXJ0QXJlYS5oZWlnaHQgLSBzcGFjaW5nKSAvIHJhdGlvWTtcbiAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1heChNYXRoLm1pbihtYXhXaWR0aCwgbWF4SGVpZ2h0KSAvIDIsIDApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gdG9EaW1lbnNpb24odGhpcy5vcHRpb25zLnJhZGl1cywgbWF4UmFkaXVzKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG91dGVyUmFkaXVzICogY3V0b3V0LCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyB0aGlzLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCk7XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WCAqIG91dGVyUmFkaXVzO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFkgKiBvdXRlclJhZGl1cztcbiAgICBtZXRhLnRvdGFsID0gdGhpcy5jYWxjdWxhdGVUb3RhbCgpO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IE1hdGgubWF4KHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgaWYgKChyZXNldCAmJiBvcHRzLmFuaW1hdGlvbi5hbmltYXRlUm90YXRlKSB8fCAhdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSB8fCBtZXRhLl9wYXJzZWRbaV0gPT09IG51bGwgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UobWV0YS5fcGFyc2VkW2ldICogY2lyY3VtZmVyZW5jZSAvIFRBVSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG4gICAgY29uc3QgYW5pbWF0ZVNjYWxlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGU7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5pbm5lclJhZGl1cztcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLm91dGVyUmFkaXVzO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBsZXQgc3RhcnRBbmdsZSA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIHN0YXJ0QW5nbGUgKz0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCArIHRoaXMub2Zmc2V0WCxcbiAgICAgICAgeTogY2VudGVyWSArIHRoaXMub2Zmc2V0WSxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgaW5uZXJSYWRpdXNcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBzdGFydEFuZ2xlICs9IGNpcmN1bWZlcmVuY2U7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlVG90YWwoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbWV0YS5fcGFyc2VkW2ldO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSAmJiAhbWV0YURhdGFbaV0uaGlkZGVuKSB7XG4gICAgICAgIHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG4gIGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UodmFsdWUpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuX2NhY2hlZE1ldGEudG90YWw7XG4gICAgaWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gVEFVICogKE1hdGguYWJzKHZhbHVlKSAvIHRvdGFsKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuICBnZXRNYXhCb3JkZXJXaWR0aChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxldCBpLCBpbGVuLCBtZXRhLCBjb250cm9sbGVyLCBvcHRpb25zO1xuICAgIGlmICghYXJjcykge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgIGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgICAgICAgY29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9wdGlvbnMgPSBjb250cm9sbGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3JkZXJBbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCwgb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIGdldE1heE9mZnNldChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5vZmZzZXQgfHwgMCwgb3B0aW9ucy5ob3Zlck9mZnNldCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBfZ2V0UmluZ1dlaWdodE9mZnNldChkYXRhc2V0SW5kZXgpIHtcbiAgICBsZXQgcmluZ1dlaWdodE9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICByaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xuICB9XG4gIF9nZXRSaW5nV2VpZ2h0KGRhdGFzZXRJbmRleCkge1xuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcbiAgfVxuICBfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICB9XG59XG5Eb3VnaG51dENvbnRyb2xsZXIuaWQgPSAnZG91Z2hudXQnO1xuRG91Z2hudXRDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICBhbmltYXRpb246IHtcbiAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgIGFuaW1hdGVTY2FsZTogZmFsc2VcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWydjaXJjdW1mZXJlbmNlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAneCcsICd5JywgJ29mZnNldCcsICdib3JkZXJXaWR0aCcsICdzcGFjaW5nJ11cbiAgICB9LFxuICB9LFxuICBjdXRvdXQ6ICc1MCUnLFxuICByb3RhdGlvbjogMCxcbiAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICByYWRpdXM6ICcxMDAlJyxcbiAgc3BhY2luZzogMCxcbiAgaW5kZXhBeGlzOiAncicsXG59O1xuRG91Z2hudXRDb250cm9sbGVyLmRlc2NyaXB0b3JzID0ge1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbn07XG5Eb3VnaG51dENvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGV9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgICAgICAgIGxldCBkYXRhTGFiZWwgPSB0b29sdGlwSXRlbS5sYWJlbDtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9ICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICBpZiAoaXNBcnJheShkYXRhTGFiZWwpKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWwgPSBkYXRhTGFiZWwuc2xpY2UoKTtcbiAgICAgICAgICAgIGRhdGFMYWJlbFswXSArPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUxhYmVsICs9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0YUxhYmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBMaW5lQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgZGF0YTogcG9pbnRzID0gW10sIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cbiAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgfVxuICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgb3B0aW9uc1xuICAgIH0sIG1vZGUpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICBzdXBlci5kcmF3KCk7XG4gIH1cbn1cbkxpbmVDb250cm9sbGVyLmlkID0gJ2xpbmUnO1xuTGluZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIHNob3dMaW5lOiB0cnVlLFxuICBzcGFuR2FwczogZmFsc2UsXG59O1xuTGluZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgfSxcbiAgfVxufTtcblxuY2xhc3MgUG9sYXJBcmVhQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgYXJjcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICB0aGlzLl91cGRhdGVSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICBnZXRNaW5NYXgoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yO1xuICAgICAgaWYgKCFpc05hTihwYXJzZWQpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGlmIChwYXJzZWQgPCByYW5nZS5taW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZCA+IHJhbmdlLm1heCkge1xuICAgICAgICAgIHJhbmdlLm1heCA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICBfdXBkYXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gKHJhZGl1c0xlbmd0aCAqIHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG4gICAgY29uc3QgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG4gICAgY29uc3QgZGF0YXNldFN0YXJ0QW5nbGUgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKDApIC0gMC41ICogUEk7XG4gICAgbGV0IGFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgZGVmYXVsdEFuZ2xlID0gMzYwIC8gdGhpcy5jb3VudFZpc2libGVFbGVtZW50cygpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBhbmdsZSArPSB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgbGV0IGVuZEFuZ2xlID0gYW5nbGUgKyB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICAgIGxldCBvdXRlclJhZGl1cyA9IGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpID8gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSkucikgOiAwO1xuICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgIGlmIChyZXNldCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUpIHtcbiAgICAgICAgICBvdXRlclJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICBvcHRpb25zOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSlcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgY291bnRWaXNpYmxlRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNOYU4odGhpcy5nZXRQYXJzZWQoaW5kZXgpLnIpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIF9jb21wdXRlQW5nbGUoaW5kZXgsIG1vZGUsIGRlZmF1bHRBbmdsZSkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KVxuICAgICAgPyB0b1JhZGlhbnModGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKS5hbmdsZSB8fCBkZWZhdWx0QW5nbGUpXG4gICAgICA6IDA7XG4gIH1cbn1cblBvbGFyQXJlYUNvbnRyb2xsZXIuaWQgPSAncG9sYXJBcmVhJztcblBvbGFyQXJlYUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgYW5pbWF0ZVNjYWxlOiB0cnVlXG4gIH0sXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXVxuICAgIH0sXG4gIH0sXG4gIGluZGV4QXhpczogJ3InLFxuICBzdGFydEFuZ2xlOiAwLFxufTtcblBvbGFyQXJlYUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGV9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY2hhcnQuZGF0YS5sYWJlbHNbY29udGV4dC5kYXRhSW5kZXhdICsgJzogJyArIGNvbnRleHQuZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjYWxlczoge1xuICAgIHI6IHtcbiAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgZ3JpZDoge1xuICAgICAgICBjaXJjdWxhcjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc3RhcnRBbmdsZTogMFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgUGllQ29udHJvbGxlciBleHRlbmRzIERvdWdobnV0Q29udHJvbGxlciB7XG59XG5QaWVDb250cm9sbGVyLmlkID0gJ3BpZSc7XG5QaWVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBjdXRvdXQ6IDAsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogJzEwMCUnXG59O1xuXG5jbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCB2U2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiB2U2NhbGUuZ2V0TGFiZWxzKClbaW5kZXhdLFxuICAgICAgdmFsdWU6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSlcbiAgICB9O1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGxhYmVscyA9IG1ldGEuaVNjYWxlLmdldExhYmVscygpO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIGlmIChtb2RlICE9PSAncmVzaXplJykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgX2xvb3A6IHRydWUsXG4gICAgICAgIF9mdWxsTG9vcDogbGFiZWxzLmxlbmd0aCA9PT0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB0aGlzLmdldFBhcnNlZChpKS5yKTtcbiAgICAgIGNvbnN0IHggPSByZXNldCA/IHNjYWxlLnhDZW50ZXIgOiBwb2ludFBvc2l0aW9uLng7XG4gICAgICBjb25zdCB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgYW5nbGU6IHBvaW50UG9zaXRpb24uYW5nbGUsXG4gICAgICAgIHNraXA6IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbn1cblJhZGFyQ29udHJvbGxlci5pZCA9ICdyYWRhcic7XG5SYWRhckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIGluZGV4QXhpczogJ3InLFxuICBzaG93TGluZTogdHJ1ZSxcbiAgZWxlbWVudHM6IHtcbiAgICBsaW5lOiB7XG4gICAgICBmaWxsOiAnc3RhcnQnXG4gICAgfVxuICB9LFxufTtcblJhZGFyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBzY2FsZXM6IHtcbiAgICByOiB7XG4gICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIFNjYXR0ZXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhOiBwb2ludHMgPSBbXX0gPSBtZXRhO1xuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBtb2RlKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3Qge3Nob3dMaW5lfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmIHNob3dMaW5lKSB7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IHJlZ2lzdHJ5LmdldEVsZW1lbnQoJ2xpbmUnKTtcbiAgICB9XG4gICAgc3VwZXIuYWRkRWxlbWVudHMoKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBsZXQgbWF4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgICB9XG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxufVxuU2NhdHRlckNvbnRyb2xsZXIuaWQgPSAnc2NhdHRlcic7XG5TY2F0dGVyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBzaG93TGluZTogZmFsc2UsXG4gIGZpbGw6IGZhbHNlXG59O1xuU2NhdHRlckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBpbnRlcmFjdGlvbjoge1xuICAgIG1vZGU6ICdwb2ludCdcbiAgfSxcbiAgcGx1Z2luczoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gJygnICsgaXRlbS5sYWJlbCArICcsICcgKyBpdGVtLmZvcm1hdHRlZFZhbHVlICsgJyknO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb250cm9sbGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkJhckNvbnRyb2xsZXI6IEJhckNvbnRyb2xsZXIsXG5CdWJibGVDb250cm9sbGVyOiBCdWJibGVDb250cm9sbGVyLFxuRG91Z2hudXRDb250cm9sbGVyOiBEb3VnaG51dENvbnRyb2xsZXIsXG5MaW5lQ29udHJvbGxlcjogTGluZUNvbnRyb2xsZXIsXG5Qb2xhckFyZWFDb250cm9sbGVyOiBQb2xhckFyZWFDb250cm9sbGVyLFxuUGllQ29udHJvbGxlcjogUGllQ29udHJvbGxlcixcblJhZGFyQ29udHJvbGxlcjogUmFkYXJDb250cm9sbGVyLFxuU2NhdHRlckNvbnRyb2xsZXI6IFNjYXR0ZXJDb250cm9sbGVyXG59KTtcblxuZnVuY3Rpb24gY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKSB7XG4gIGNvbnN0IHtzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzfSA9IGVsZW1lbnQ7XG4gIGxldCBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gb3V0ZXJSYWRpdXM7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB0b1JhZGl1c0Nvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ291dGVyU3RhcnQnLCAnb3V0ZXJFbmQnLCAnaW5uZXJTdGFydCcsICdpbm5lckVuZCddKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzJDEoYXJjLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGFuZ2xlRGVsdGEpIHtcbiAgY29uc3QgbyA9IHRvUmFkaXVzQ29ybmVycyhhcmMub3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuICBjb25zdCBoYWxmVGhpY2tuZXNzID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gMjtcbiAgY29uc3QgaW5uZXJMaW1pdCA9IE1hdGgubWluKGhhbGZUaGlja25lc3MsIGFuZ2xlRGVsdGEgKiBpbm5lclJhZGl1cyAvIDIpO1xuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgb3V0ZXJTdGFydDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlclN0YXJ0KSxcbiAgICBvdXRlckVuZDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlckVuZCksXG4gICAgaW5uZXJTdGFydDogX2xpbWl0VmFsdWUoby5pbm5lclN0YXJ0LCAwLCBpbm5lckxpbWl0KSxcbiAgICBpbm5lckVuZDogX2xpbWl0VmFsdWUoby5pbm5lckVuZCwgMCwgaW5uZXJMaW1pdCksXG4gIH07XG59XG5mdW5jdGlvbiByVGhldGFUb1hZKHIsIHRoZXRhLCB4LCB5KSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5mdW5jdGlvbiBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmQsIGNpcmN1bGFyKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlOiBzdGFydCwgcGl4ZWxNYXJnaW4sIGlubmVyUmFkaXVzOiBpbm5lclJ9ID0gZWxlbWVudDtcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCAtIHBpeGVsTWFyZ2luLCAwKTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSICsgc3BhY2luZyArIG9mZnNldCArIHBpeGVsTWFyZ2luIDogMDtcbiAgbGV0IHNwYWNpbmdPZmZzZXQgPSAwO1xuICBjb25zdCBhbHBoYSA9IGVuZCAtIHN0YXJ0O1xuICBpZiAoc3BhY2luZykge1xuICAgIGNvbnN0IG5vU3BhY2luZ0lubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IG5vU3BhY2luZ091dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgPiAwID8gb3V0ZXJSYWRpdXMgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBhdk5vZ1NwYWNpbmdSYWRpdXMgPSAobm9TcGFjaW5nSW5uZXJSYWRpdXMgKyBub1NwYWNpbmdPdXRlclJhZGl1cykgLyAyO1xuICAgIGNvbnN0IGFkanVzdGVkQW5nbGUgPSBhdk5vZ1NwYWNpbmdSYWRpdXMgIT09IDAgPyAoYWxwaGEgKiBhdk5vZ1NwYWNpbmdSYWRpdXMpIC8gKGF2Tm9nU3BhY2luZ1JhZGl1cyArIHNwYWNpbmcpIDogYWxwaGE7XG4gICAgc3BhY2luZ09mZnNldCA9IChhbHBoYSAtIGFkanVzdGVkQW5nbGUpIC8gMjtcbiAgfVxuICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMkMShlbGVtZW50LCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyU3RhcnQ7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyRW5kO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBpbm5lclN0YXJ0IC8gaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIGlubmVyRW5kIC8gaW5uZXJFbmRBZGp1c3RlZFJhZGl1cztcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKTtcbiAgICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlckVuZEFkanVzdGVkUmFkaXVzLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJFbmQsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgZW5kQW5nbGUgKyBIQUxGX1BJKTtcbiAgICB9XG4gICAgY29uc3QgcDQgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGVuZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA0LngsIHA0LnkpO1xuICAgIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgICB9XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cyksIHN0YXJ0QW5nbGUgKyAoaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSwgdHJ1ZSk7XG4gICAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyU3RhcnQsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICAgIH1cbiAgICBjb25zdCBwOCA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBzdGFydEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA4LngsIHA4LnkpO1xuICAgIGlmIChvdXRlclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlclN0YXJ0LCBzdGFydEFuZ2xlIC0gSEFMRl9QSSwgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIGNvbnN0IG91dGVyU3RhcnRYID0gTWF0aC5jb3Mob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyU3RhcnRZID0gTWF0aC5zaW4ob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJTdGFydFgsIG91dGVyU3RhcnRZKTtcbiAgICBjb25zdCBvdXRlckVuZFggPSBNYXRoLmNvcyhvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyRW5kWSA9IE1hdGguc2luKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlckVuZFgsIG91dGVyRW5kWSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuZnVuY3Rpb24gZHJhd0FyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlfSA9IGVsZW1lbnQ7XG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIHN0YXJ0QW5nbGUgKyBUQVUsIGNpcmN1bGFyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UgJSBUQVU7XG4gICAgICBpZiAoY2lyY3VtZmVyZW5jZSAlIFRBVSA9PT0gMCkge1xuICAgICAgICBlbmRBbmdsZSArPSBUQVU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gIGN0eC5maWxsKCk7XG4gIHJldHVybiBlbmRBbmdsZTtcbn1cbmZ1bmN0aW9uIGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIGVsZW1lbnQsIGlubmVyKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgZnVsbENpcmNsZXN9ID0gZWxlbWVudDtcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzIC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGVsZW1lbnQuaW5uZXJSYWRpdXMgKyBwaXhlbE1hcmdpbjtcbiAgbGV0IGk7XG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBzdGFydEFuZ2xlICsgVEFVKTtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIHN0YXJ0QW5nbGUgKyBUQVUsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICBmb3IgKGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIHN0YXJ0QW5nbGUgKyBUQVUpO1xuICBmb3IgKGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gZHJhd0JvcmRlcihjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKSB7XG4gIGNvbnN0IHtvcHRpb25zfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IHtib3JkZXJXaWR0aCwgYm9yZGVySm9pblN0eWxlfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlubmVyID0gb3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJztcbiAgaWYgKCFib3JkZXJXaWR0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5uZXIpIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGggKiAyO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAncm91bmQnO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ2JldmVsJztcbiAgfVxuICBpZiAoZWxlbWVudC5mdWxsQ2lyY2xlcykge1xuICAgIGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIGVsZW1lbnQsIGlubmVyKTtcbiAgfVxuICBpZiAoaW5uZXIpIHtcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpO1xuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gIGN0eC5zdHJva2UoKTtcbn1cbmNsYXNzIEFyY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaXJjdW1mZXJlbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gMDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGluUmFuZ2UoY2hhcnRYLCBjaGFydFksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlLCBkaXN0YW5jZX0gPSBnZXRBbmdsZUZyb21Qb2ludChwb2ludCwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAnY2lyY3VtZmVyZW5jZSdcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCByQWRqdXN0ID0gdGhpcy5vcHRpb25zLnNwYWNpbmcgLyAyO1xuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gX2NpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb25zdCB3aXRoaW5SYWRpdXMgPSBfaXNCZXR3ZWVuKGRpc3RhbmNlLCBpbm5lclJhZGl1cyArIHJBZGp1c3QsIG91dGVyUmFkaXVzICsgckFkanVzdCk7XG4gICAgcmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3gnLFxuICAgICAgJ3knLFxuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnLFxuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHtvZmZzZXQsIHNwYWNpbmd9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGhhbGZBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgICBjb25zdCBoYWxmUmFkaXVzID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0KSAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuICAgIH07XG4gIH1cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMub2Zmc2V0IHx8IDApIC8gMjtcbiAgICBjb25zdCBzcGFjaW5nID0gKG9wdGlvbnMuc3BhY2luZyB8fCAwKSAvIDI7XG4gICAgY29uc3QgY2lyY3VsYXIgPSBvcHRpb25zLmNpcmN1bGFyO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAob3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuICAgIGlmIChjaXJjdW1mZXJlbmNlID09PSAwIHx8IHRoaXMuaW5uZXJSYWRpdXMgPCAwIHx8IHRoaXMub3V0ZXJSYWRpdXMgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgbGV0IHJhZGl1c09mZnNldCA9IDA7XG4gICAgaWYgKG9mZnNldCkge1xuICAgICAgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0IC8gMjtcbiAgICAgIGNvbnN0IGhhbGZBbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQpO1xuICAgICAgaWYgKHRoaXMuY2lyY3VtZmVyZW5jZSA+PSBQSSkge1xuICAgICAgICByYWRpdXNPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gZHJhd0FyYyhjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuICAgIGRyYXdCb3JkZXIoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuQXJjRWxlbWVudC5pZCA9ICdhcmMnO1xuQXJjRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyQWxpZ246ICdjZW50ZXInLFxuICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICBib3JkZXJKb2luU3R5bGU6IHVuZGVmaW5lZCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJXaWR0aDogMixcbiAgb2Zmc2V0OiAwLFxuICBzcGFjaW5nOiAwLFxuICBhbmdsZTogdW5kZWZpbmVkLFxuICBjaXJjdWxhcjogdHJ1ZSxcbn07XG5BcmNFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcidcbn07XG5cbmZ1bmN0aW9uIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc3R5bGUgPSBvcHRpb25zKSB7XG4gIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ2FwU3R5bGUsIG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpO1xuICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaCwgb3B0aW9ucy5ib3JkZXJEYXNoKSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsIG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCk7XG4gIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckpvaW5TdHlsZSwgb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUpO1xuICBjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDb2xvciwgb3B0aW9ucy5ib3JkZXJDb2xvcik7XG59XG5mdW5jdGlvbiBsaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0KSB7XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIGdldExpbmVNZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkTGluZVRvO1xuICB9XG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJDdXJ2ZVRvO1xuICB9XG4gIHJldHVybiBsaW5lVG87XG59XG5mdW5jdGlvbiBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyA9IHt9KSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge3N0YXJ0OiBwYXJhbXNTdGFydCA9IDAsIGVuZDogcGFyYW1zRW5kID0gY291bnQgLSAxfSA9IHBhcmFtcztcbiAgY29uc3Qge3N0YXJ0OiBzZWdtZW50U3RhcnQsIGVuZDogc2VnbWVudEVuZH0gPSBzZWdtZW50O1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHBhcmFtc1N0YXJ0LCBzZWdtZW50U3RhcnQpO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihwYXJhbXNFbmQsIHNlZ21lbnRFbmQpO1xuICBjb25zdCBvdXRzaWRlID0gcGFyYW1zU3RhcnQgPCBzZWdtZW50U3RhcnQgJiYgcGFyYW1zRW5kIDwgc2VnbWVudFN0YXJ0IHx8IHBhcmFtc1N0YXJ0ID4gc2VnbWVudEVuZCAmJiBwYXJhbXNFbmQgPiBzZWdtZW50RW5kO1xuICByZXR1cm4ge1xuICAgIGNvdW50LFxuICAgIHN0YXJ0LFxuICAgIGxvb3A6IHNlZ21lbnQubG9vcCxcbiAgICBpbGVuOiBlbmQgPCBzdGFydCAmJiAhb3V0c2lkZSA/IGNvdW50ICsgZW5kIC0gc3RhcnQgOiBlbmQgLSBzdGFydFxuICB9O1xufVxuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3Qge3BvaW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBsb29wLCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gIGxldCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgaSwgcG9pbnQsIHByZXY7XG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaSA6IGkpKSAlIGNvdW50XTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgfVxuICAgIHByZXYgPSBwb2ludDtcbiAgfVxuICBpZiAobG9vcCkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiA6IDApKSAlIGNvdW50XTtcbiAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gIH1cbiAgcmV0dXJuICEhbG9vcDtcbn1cbmZ1bmN0aW9uIGZhc3RQYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgcHJldlgsIG1pblksIG1heFksIGxhc3RZO1xuICBjb25zdCBwb2ludEluZGV4ID0gKGluZGV4KSA9PiAoc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpbmRleCA6IGluZGV4KSkgJSBjb3VudDtcbiAgY29uc3QgZHJhd1ggPSAoKSA9PiB7XG4gICAgaWYgKG1pblkgIT09IG1heFkpIHtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWF4WSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1pblkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBsYXN0WSk7XG4gICAgfVxuICB9O1xuICBpZiAobW92ZSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KGkpXTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgfVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgeCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd1goKTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgfVxuICAgIGxhc3RZID0geTtcbiAgfVxuICBkcmF3WCgpO1xufVxuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xuICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xuICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cbmZ1bmN0aW9uIF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZEludGVycG9sYXRpb247XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gIH1cbiAgcmV0dXJuIF9wb2ludEluTGluZTtcbn1cbmZ1bmN0aW9uIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgbGV0IHBhdGggPSBsaW5lLl9wYXRoO1xuICBpZiAoIXBhdGgpIHtcbiAgICBwYXRoID0gbGluZS5fcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBpZiAobGluZS5wYXRoKHBhdGgsIHN0YXJ0LCBjb3VudCkpIHtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG4gIHNldFN0eWxlKGN0eCwgbGluZS5vcHRpb25zKTtcbiAgY3R4LnN0cm9rZShwYXRoKTtcbn1cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzZWdtZW50LnN0eWxlKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKHNlZ21lbnRNZXRob2QoY3R4LCBsaW5lLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KSkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmNvbnN0IHVzZVBhdGgyRCA9IHR5cGVvZiBQYXRoMkQgPT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGlmICh1c2VQYXRoMkQgJiYgIWxpbmUub3B0aW9ucy5zZWdtZW50KSB7XG4gICAgc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbn1cbmNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoYXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnVsbExvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2VnbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVjaW1hdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFzZXRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUNvbnRyb2xQb2ludHMoY2hhcnRBcmVhLCBpbmRleEF4aXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICgob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykgJiYgIW9wdGlvbnMuc3RlcHBlZCAmJiAhdGhpcy5fcG9pbnRzVXBkYXRlZCkge1xuICAgICAgY29uc3QgbG9vcCA9IG9wdGlvbnMuc3BhbkdhcHMgPyB0aGlzLl9sb29wIDogdGhpcy5fZnVsbExvb3A7XG4gICAgICBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyh0aGlzLl9wb2ludHMsIG9wdGlvbnMsIGNoYXJ0QXJlYSwgbG9vcCwgaW5kZXhBeGlzKTtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBzZXQgcG9pbnRzKHBvaW50cykge1xuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICBkZWxldGUgdGhpcy5fc2VnbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuX3BhdGg7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBwb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgfVxuICBnZXQgc2VnbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzIHx8ICh0aGlzLl9zZWdtZW50cyA9IF9jb21wdXRlU2VnbWVudHModGhpcywgdGhpcy5vcHRpb25zLnNlZ21lbnQpKTtcbiAgfVxuICBmaXJzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCAmJiBwb2ludHNbc2VnbWVudHNbMF0uc3RhcnRdO1xuICB9XG4gIGxhc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IGNvdW50ID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBjb3VudCAmJiBwb2ludHNbc2VnbWVudHNbY291bnQgLSAxXS5lbmRdO1xuICB9XG4gIGludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0aGlzLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xuICAgIGlmICghc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IF9pbnRlcnBvbGF0ZSA9IF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnRzW2ldO1xuICAgICAgY29uc3QgcDEgPSBwb2ludHNbc3RhcnRdO1xuICAgICAgY29uc3QgcDIgPSBwb2ludHNbZW5kXTtcbiAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygodmFsdWUgLSBwMVtwcm9wZXJ0eV0pIC8gKHAyW3Byb3BlcnR5XSAtIHAxW3Byb3BlcnR5XSkpO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkID0gX2ludGVycG9sYXRlKHAxLCBwMiwgdCwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICAgIGludGVycG9sYXRlZFtwcm9wZXJ0eV0gPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgfVxuICBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIH1cbiAgcGF0aChjdHgsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgbGV0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBjb3VudCA9IGNvdW50IHx8ICh0aGlzLnBvaW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbiAgfVxuICBkcmF3KGN0eCwgY2hhcnRBcmVhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzIHx8IFtdO1xuICAgIGlmIChwb2ludHMubGVuZ3RoICYmIG9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBkcmF3KGN0eCwgdGhpcywgc3RhcnQsIGNvdW50KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuTGluZUVsZW1lbnQuaWQgPSAnbGluZSc7XG5MaW5lRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgYm9yZGVyRGFzaDogW10sXG4gIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgYm9yZGVyV2lkdGg6IDMsXG4gIGNhcEJlemllclBvaW50czogdHJ1ZSxcbiAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICBmaWxsOiBmYWxzZSxcbiAgc3BhbkdhcHM6IGZhbHNlLFxuICBzdGVwcGVkOiBmYWxzZSxcbiAgdGVuc2lvbjogMCxcbn07XG5MaW5lRWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcbkxpbmVFbGVtZW50LmRlc2NyaXB0b3JzID0ge1xuICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZmlsbCcsXG59O1xuXG5mdW5jdGlvbiBpblJhbmdlJDEoZWwsIHBvcywgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBvcHRpb25zID0gZWwub3B0aW9ucztcbiAgY29uc3Qge1theGlzXTogdmFsdWV9ID0gZWwuZ2V0UHJvcHMoW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgcmV0dXJuIChNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzKTtcbn1cbmNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNraXAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdG9wID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4gKChNYXRoLnBvdyhtb3VzZVggLSB4LCAyKSArIE1hdGgucG93KG1vdXNlWSAtIHksIDIpKSA8IE1hdGgucG93KG9wdGlvbnMuaGl0UmFkaXVzICsgb3B0aW9ucy5yYWRpdXMsIDIpKTtcbiAgfVxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWCwgJ3gnLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWSwgJ3knLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG4gIHNpemUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcbiAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIHJhZGl1cyAmJiBvcHRpb25zLmhvdmVyUmFkaXVzIHx8IDApO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcmFkaXVzICYmIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICByZXR1cm4gKHJhZGl1cyArIGJvcmRlcldpZHRoKSAqIDI7XG4gIH1cbiAgZHJhdyhjdHgsIGFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLnNraXAgfHwgb3B0aW9ucy5yYWRpdXMgPCAwLjEgfHwgIV9pc1BvaW50SW5BcmVhKHRoaXMsIGFyZWEsIHRoaXMuc2l6ZShvcHRpb25zKSAvIDIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xuICB9XG59XG5Qb2ludEVsZW1lbnQuaWQgPSAncG9pbnQnO1xuUG9pbnRFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJXaWR0aDogMSxcbiAgaGl0UmFkaXVzOiAxLFxuICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICBob3ZlclJhZGl1czogNCxcbiAgcG9pbnRTdHlsZTogJ2NpcmNsZScsXG4gIHJhZGl1czogMyxcbiAgcm90YXRpb246IDBcbn07XG5Qb2ludEVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qge3gsIHksIGJhc2UsIHdpZHRoLCBoZWlnaHR9ID0gYmFyLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICBsZXQgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBoYWxmO1xuICBpZiAoYmFyLmhvcml6b250YWwpIHtcbiAgICBoYWxmID0gaGVpZ2h0IC8gMjtcbiAgICBsZWZ0ID0gTWF0aC5taW4oeCwgYmFzZSk7XG4gICAgcmlnaHQgPSBNYXRoLm1heCh4LCBiYXNlKTtcbiAgICB0b3AgPSB5IC0gaGFsZjtcbiAgICBib3R0b20gPSB5ICsgaGFsZjtcbiAgfSBlbHNlIHtcbiAgICBoYWxmID0gd2lkdGggLyAyO1xuICAgIGxlZnQgPSB4IC0gaGFsZjtcbiAgICByaWdodCA9IHggKyBoYWxmO1xuICAgIHRvcCA9IE1hdGgubWluKHksIGJhc2UpO1xuICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJhc2UpO1xuICB9XG4gIHJldHVybiB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfTtcbn1cbmZ1bmN0aW9uIHNraXBPckxpbWl0KHNraXAsIHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gc2tpcCA/IDAgOiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpO1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aChiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBvID0gdG9UUkJMKHZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICB0OiBza2lwT3JMaW1pdChza2lwLnRvcCwgby50b3AsIDAsIG1heEgpLFxuICAgIHI6IHNraXBPckxpbWl0KHNraXAucmlnaHQsIG8ucmlnaHQsIDAsIG1heFcpLFxuICAgIGI6IHNraXBPckxpbWl0KHNraXAuYm90dG9tLCBvLmJvdHRvbSwgMCwgbWF4SCksXG4gICAgbDogc2tpcE9yTGltaXQoc2tpcC5sZWZ0LCBvLmxlZnQsIDAsIG1heFcpXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3Qge2VuYWJsZUJvcmRlclJhZGl1c30gPSBiYXIuZ2V0UHJvcHMoWydlbmFibGVCb3JkZXJSYWRpdXMnXSk7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyUmFkaXVzO1xuICBjb25zdCBvID0gdG9UUkJMQ29ybmVycyh2YWx1ZSk7XG4gIGNvbnN0IG1heFIgPSBNYXRoLm1pbihtYXhXLCBtYXhIKTtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBlbmFibGVCb3JkZXIgPSBlbmFibGVCb3JkZXJSYWRpdXMgfHwgaXNPYmplY3QodmFsdWUpO1xuICByZXR1cm4ge1xuICAgIHRvcExlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5sZWZ0LCBvLnRvcExlZnQsIDAsIG1heFIpLFxuICAgIHRvcFJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAucmlnaHQsIG8udG9wUmlnaHQsIDAsIG1heFIpLFxuICAgIGJvdHRvbUxlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5sZWZ0LCBvLmJvdHRvbUxlZnQsIDAsIG1heFIpLFxuICAgIGJvdHRvbVJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAucmlnaHQsIG8uYm90dG9tUmlnaHQsIDAsIG1heFIpXG4gIH07XG59XG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKGJhcikge1xuICBjb25zdCBib3VuZHMgPSBnZXRCYXJCb3VuZHMoYmFyKTtcbiAgY29uc3Qgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG4gIGNvbnN0IGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICBjb25zdCByYWRpdXMgPSBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0LFxuICAgICAgeTogYm91bmRzLnRvcCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0LFxuICAgICAgcmFkaXVzXG4gICAgfSxcbiAgICBpbm5lcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcbiAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcbiAgICAgIHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcbiAgICAgIGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcExlZnQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BSaWdodCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5yKSksXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaW5SYW5nZShiYXIsIHgsIHksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgc2tpcFggPSB4ID09PSBudWxsO1xuICBjb25zdCBza2lwWSA9IHkgPT09IG51bGw7XG4gIGNvbnN0IHNraXBCb3RoID0gc2tpcFggJiYgc2tpcFk7XG4gIGNvbnN0IGJvdW5kcyA9IGJhciAmJiAhc2tpcEJvdGggJiYgZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbik7XG4gIHJldHVybiBib3VuZHNcblx0XHQmJiAoc2tpcFggfHwgX2lzQmV0d2Vlbih4LCBib3VuZHMubGVmdCwgYm91bmRzLnJpZ2h0KSlcblx0XHQmJiAoc2tpcFkgfHwgX2lzQmV0d2Vlbih5LCBib3VuZHMudG9wLCBib3VuZHMuYm90dG9tKSk7XG59XG5mdW5jdGlvbiBoYXNSYWRpdXMocmFkaXVzKSB7XG4gIHJldHVybiByYWRpdXMudG9wTGVmdCB8fCByYWRpdXMudG9wUmlnaHQgfHwgcmFkaXVzLmJvdHRvbUxlZnQgfHwgcmFkaXVzLmJvdHRvbVJpZ2h0O1xufVxuZnVuY3Rpb24gYWRkTm9ybWFsUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG59XG5mdW5jdGlvbiBpbmZsYXRlUmVjdChyZWN0LCBhbW91bnQsIHJlZlJlY3QgPSB7fSkge1xuICBjb25zdCB4ID0gcmVjdC54ICE9PSByZWZSZWN0LnggPyAtYW1vdW50IDogMDtcbiAgY29uc3QgeSA9IHJlY3QueSAhPT0gcmVmUmVjdC55ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHcgPSAocmVjdC54ICsgcmVjdC53ICE9PSByZWZSZWN0LnggKyByZWZSZWN0LncgPyBhbW91bnQgOiAwKSAtIHg7XG4gIGNvbnN0IGggPSAocmVjdC55ICsgcmVjdC5oICE9PSByZWZSZWN0LnkgKyByZWZSZWN0LmggPyBhbW91bnQgOiAwKSAtIHk7XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC54ICsgeCxcbiAgICB5OiByZWN0LnkgKyB5LFxuICAgIHc6IHJlY3QudyArIHcsXG4gICAgaDogcmVjdC5oICsgaCxcbiAgICByYWRpdXM6IHJlY3QucmFkaXVzXG4gIH07XG59XG5jbGFzcyBCYXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluZmxhdGVBbW91bnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtpbmZsYXRlQW1vdW50LCBvcHRpb25zOiB7Ym9yZGVyQ29sb3IsIGJhY2tncm91bmRDb2xvcn19ID0gdGhpcztcbiAgICBjb25zdCB7aW5uZXIsIG91dGVyfSA9IGJvdW5kaW5nUmVjdHModGhpcyk7XG4gICAgY29uc3QgYWRkUmVjdFBhdGggPSBoYXNSYWRpdXMob3V0ZXIucmFkaXVzKSA/IGFkZFJvdW5kZWRSZWN0UGF0aCA6IGFkZE5vcm1hbFJlY3RQYXRoO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKG91dGVyLncgIT09IGlubmVyLncgfHwgb3V0ZXIuaCAhPT0gaW5uZXIuaCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChvdXRlciwgaW5mbGF0ZUFtb3VudCwgaW5uZXIpKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCAtaW5mbGF0ZUFtb3VudCwgb3V0ZXIpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgfVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCBpbmZsYXRlQW1vdW50KSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG51bGwsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG51bGwsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBiYXNlLCBob3Jpem9udGFsfSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICdob3Jpem9udGFsJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gKHggKyBiYXNlKSAvIDIgOiB4LFxuICAgICAgeTogaG9yaXpvbnRhbCA/IHkgOiAoeSArIGJhc2UpIC8gMlxuICAgIH07XG4gIH1cbiAgZ2V0UmFuZ2UoYXhpcykge1xuICAgIHJldHVybiBheGlzID09PSAneCcgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgfVxufVxuQmFyRWxlbWVudC5pZCA9ICdiYXInO1xuQmFyRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyU2tpcHBlZDogJ3N0YXJ0JyxcbiAgYm9yZGVyV2lkdGg6IDAsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgaW5mbGF0ZUFtb3VudDogJ2F1dG8nLFxuICBwb2ludFN0eWxlOiB1bmRlZmluZWRcbn07XG5CYXJFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuXG52YXIgZWxlbWVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5BcmNFbGVtZW50OiBBcmNFbGVtZW50LFxuTGluZUVsZW1lbnQ6IExpbmVFbGVtZW50LFxuUG9pbnRFbGVtZW50OiBQb2ludEVsZW1lbnQsXG5CYXJFbGVtZW50OiBCYXJFbGVtZW50XG59KTtcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICBpZiAoc2FtcGxlcyA+PSBjb3VudCkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgfVxuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICBsZXQgYSA9IHN0YXJ0O1xuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbYV07XG4gIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzIC0gMjsgaSsrKSB7XG4gICAgbGV0IGF2Z1ggPSAwO1xuICAgIGxldCBhdmdZID0gMDtcbiAgICBsZXQgajtcbiAgICBjb25zdCBhdmdSYW5nZVN0YXJ0ID0gTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlRW5kID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDIpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VMZW5ndGggPSBhdmdSYW5nZUVuZCAtIGF2Z1JhbmdlU3RhcnQ7XG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcbiAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgfVxuICAgIGF2Z1ggLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgYXZnWSAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgcmFuZ2VUbyA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IHt4OiBwb2ludEF4LCB5OiBwb2ludEF5fSA9IGRhdGFbYV07XG4gICAgbWF4QXJlYSA9IGFyZWEgPSAtMTtcbiAgICBmb3IgKGogPSByYW5nZU9mZnM7IGogPCByYW5nZVRvOyBqKyspIHtcbiAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXG4gICAgICAgIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSlcbiAgICAgICk7XG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICAgIG1heEFyZWFQb2ludCA9IGRhdGFbal07XG4gICAgICAgIG5leHRBID0gajtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IG1heEFyZWFQb2ludDtcbiAgICBhID0gbmV4dEE7XG4gIH1cbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbZW5kSW5kZXhdO1xuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xuICBjb25zdCB4TWF4ID0gZGF0YVtlbmRJbmRleF0ueDtcbiAgY29uc3QgZHggPSB4TWF4IC0geE1pbjtcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICBwb2ludCA9IGRhdGFbaV07XG4gICAgeCA9IChwb2ludC54IC0geE1pbikgLyBkeCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgIHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHBvaW50LngpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGkgLSAxO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MSAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDEgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgxXSxcbiAgICAgICAgICAgIHg6IGF2Z1gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MiAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDIgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcbiAgICAgICAgICAgIHg6IGF2Z1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPiAwICYmIGxhc3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xuICAgICAgfVxuICAgICAgZGVjaW1hdGVkLnB1c2gocG9pbnQpO1xuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgICAgbWluSW5kZXggPSBtYXhJbmRleCA9IHN0YXJ0SW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0Ll9kYXRhO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge3ZhbHVlOiBkYXRhfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCkge1xuICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQpID0+IHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQ7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWluKS5sbywgMCwgcG9pbnRDb3VudCAtIDEpO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cbnZhciBwbHVnaW5fZGVjaW1hdGlvbiA9IHtcbiAgaWQ6ICdkZWNpbWF0aW9uJyxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGdvcml0aG06ICdtaW4tbWF4JyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSxcbiAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChjaGFydCwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xuICAgIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7X2RhdGEsIGluZGV4QXhpc30gPSBkYXRhc2V0O1xuICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBjb25zdCBkYXRhID0gX2RhdGEgfHwgZGF0YXNldC5kYXRhO1xuICAgICAgaWYgKHJlc29sdmUoW2luZGV4QXhpcywgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gJ3knKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghbWV0YS5jb250cm9sbGVyLnN1cHBvcnRzRGVjaW1hdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB4QXhpcyA9IGNoYXJ0LnNjYWxlc1ttZXRhLnhBeGlzSURdO1xuICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2hhcnQub3B0aW9ucy5wYXJzaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIGRhdGEpO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQgfHwgNCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGNvdW50IDw9IHRocmVzaG9sZCkge1xuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bGxPclVuZGVmKF9kYXRhKSkge1xuICAgICAgICBkYXRhc2V0Ll9kYXRhID0gZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGV0IGRlY2ltYXRlZDtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2x0dGInOlxuICAgICAgICBkZWNpbWF0ZWQgPSBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaW4tbWF4JzpcbiAgICAgICAgZGVjaW1hdGVkID0gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke29wdGlvbnMuYWxnb3JpdGhtfSdgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFzZXQuX2RlY2ltYXRlZCA9IGRlY2ltYXRlZDtcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveShjaGFydCkge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBsZXQge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKTtcbiAgICBjb25zdCBib3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCBwb2ludHNbc3RhcnRdLCBwb2ludHNbZW5kXSwgc2VnbWVudC5sb29wKTtcbiAgICBpZiAoIXRhcmdldC5zZWdtZW50cykge1xuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHNvdXJjZTogc2VnbWVudCxcbiAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgIHN0YXJ0OiBwb2ludHNbc3RhcnRdLFxuICAgICAgICBlbmQ6IHBvaW50c1tlbmRdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcbiAgICBmb3IgKGNvbnN0IHRndCBvZiB0YXJnZXRTZWdtZW50cykge1xuICAgICAgY29uc3Qgc3ViQm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgdHBvaW50c1t0Z3Quc3RhcnRdLCB0cG9pbnRzW3RndC5lbmRdLCB0Z3QubG9vcCk7XG4gICAgICBjb25zdCBmaWxsU291cmNlcyA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBzdWJCb3VuZHMpO1xuICAgICAgZm9yIChjb25zdCBmaWxsU291cmNlIG9mIGZpbGxTb3VyY2VzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZTogZmlsbFNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IHRndCxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdzdGFydCcsIE1hdGgubWF4KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ2VuZCcsIE1hdGgubWluKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIF9nZXRCb3VuZHMocHJvcGVydHksIGZpcnN0LCBsYXN0LCBsb29wKSB7XG4gIGlmIChsb29wKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydCA9IGZpcnN0W3Byb3BlcnR5XTtcbiAgbGV0IGVuZCA9IGxhc3RbcHJvcGVydHldO1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICBzdGFydCA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gICAgZW5kID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIH1cbiAgcmV0dXJuIHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIGxpbmVQb2ludHMpO1xuICAgIGNvbnN0IGZpcnN0ID0gbGluZVBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVQb2ludHNbZW5kXTtcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGZpcnN0LngsIHl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBsYXN0LngsIHl9KTtcbiAgICB9IGVsc2UgaWYgKHggIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBmaXJzdC55fSk7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogbGFzdC55fSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBvaW50cztcbn1cbmZ1bmN0aW9uIF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpIHtcbiAgZm9yICg7ZW5kID4gc3RhcnQ7IGVuZC0tKSB7XG4gICAgY29uc3QgcG9pbnQgPSBwb2ludHNbZW5kXTtcbiAgICBpZiAoIWlzTmFOKHBvaW50LngpICYmICFpc05hTihwb2ludC55KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBfZ2V0RWRnZShhLCBiLCBwcm9wLCBmbikge1xuICBpZiAoYSAmJiBiKSB7XG4gICAgcmV0dXJuIGZuKGFbcHJvcF0sIGJbcHJvcF0pO1xuICB9XG4gIHJldHVybiBhID8gYVtwcm9wXSA6IGIgPyBiW3Byb3BdIDogMDtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSkge1xuICBsZXQgcG9pbnRzID0gW107XG4gIGxldCBfbG9vcCA9IGZhbHNlO1xuICBpZiAoaXNBcnJheShib3VuZGFyeSkpIHtcbiAgICBfbG9vcCA9IHRydWU7XG4gICAgcG9pbnRzID0gYm91bmRhcnk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSk7XG4gIH1cbiAgcmV0dXJuIHBvaW50cy5sZW5ndGggPyBuZXcgTGluZUVsZW1lbnQoe1xuICAgIHBvaW50cyxcbiAgICBvcHRpb25zOiB7dGVuc2lvbjogMH0sXG4gICAgX2xvb3AsXG4gICAgX2Z1bGxMb29wOiBfbG9vcFxuICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkge1xuICByZXR1cm4gc291cmNlICYmIHNvdXJjZS5maWxsICE9PSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcbiAgY29uc3QgdmlzaXRlZCA9IFtpbmRleF07XG4gIGxldCB0YXJnZXQ7XG4gIGlmICghcHJvcGFnYXRlKSB7XG4gICAgcmV0dXJuIGZpbGw7XG4gIH1cbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcbiAgICBpZiAoIWlzTnVtYmVyRmluaXRlKGZpbGwpKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG4gICAgdGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnZpc2libGUpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cbiAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIF9kZWNvZGVGaWxsKGxpbmUsIGluZGV4LCBjb3VudCkge1xuICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuICBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICByZXR1cm4gaXNOYU4oZmlsbC52YWx1ZSkgPyBmYWxzZSA6IGZpbGw7XG4gIH1cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG4gIGlmIChpc051bWJlckZpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGRlY29kZVRhcmdldEluZGV4KGZpbGxbMF0sIGluZGV4LCB0YXJnZXQsIGNvdW50KTtcbiAgfVxuICByZXR1cm4gWydvcmlnaW4nLCAnc3RhcnQnLCAnZW5kJywgJ3N0YWNrJywgJ3NoYXBlJ10uaW5kZXhPZihmaWxsKSA+PSAwICYmIGZpbGw7XG59XG5mdW5jdGlvbiBkZWNvZGVUYXJnZXRJbmRleChmaXJzdENoLCBpbmRleCwgdGFyZ2V0LCBjb3VudCkge1xuICBpZiAoZmlyc3RDaCA9PT0gJy0nIHx8IGZpcnN0Q2ggPT09ICcrJykge1xuICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICB9XG4gIGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpIHtcbiAgbGV0IHBpeGVsID0gbnVsbDtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmJvdHRvbTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHBpeGVsID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKGZpbGwudmFsdWUpO1xuICB9IGVsc2UgaWYgKHNjYWxlLmdldEJhc2VQaXhlbCkge1xuICAgIHBpeGVsID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gIH1cbiAgcmV0dXJuIHBpeGVsO1xufVxuZnVuY3Rpb24gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydFZhbHVlKSB7XG4gIGxldCB2YWx1ZTtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICB2YWx1ZSA9IHN0YXJ0VmFsdWU7XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZSA9IHNjYWxlLm9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmlsbE9wdGlvbihsaW5lKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBvcHRpb25zLmZpbGw7XG4gIGxldCBmaWxsID0gdmFsdWVPckRlZmF1bHQoZmlsbE9wdGlvbiAmJiBmaWxsT3B0aW9uLnRhcmdldCwgZmlsbE9wdGlvbik7XG4gIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBmaWxsID0gISFvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgfVxuICBpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnb3JpZ2luJztcbiAgfVxuICByZXR1cm4gZmlsbDtcbn1cblxuZnVuY3Rpb24gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGluZGV4LCBsaW5lfSA9IHNvdXJjZTtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3Qgc291cmNlUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IGxpbmVzQmVsb3cgPSBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCk7XG4gIGxpbmVzQmVsb3cucHVzaChfY3JlYXRlQm91bmRhcnlMaW5lKHt4OiBudWxsLCB5OiBzY2FsZS5ib3R0b219LCBsaW5lKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgZm9yIChsZXQgaiA9IHNlZ21lbnQuc3RhcnQ7IGogPD0gc2VnbWVudC5lbmQ7IGorKykge1xuICAgICAgYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludHNbal0sIGxpbmVzQmVsb3cpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IExpbmVFbGVtZW50KHtwb2ludHMsIG9wdGlvbnM6IHt9fSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCkge1xuICBjb25zdCBiZWxvdyA9IFtdO1xuICBjb25zdCBtZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCdsaW5lJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgaWYgKG1ldGEuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFtZXRhLmhpZGRlbikge1xuICAgICAgYmVsb3cudW5zaGlmdChtZXRhLmRhdGFzZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmVsb3c7XG59XG5mdW5jdGlvbiBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50LCBsaW5lc0JlbG93KSB7XG4gIGNvbnN0IHBvc3Rwb25lZCA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmVzQmVsb3cubGVuZ3RoOyBqKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNCZWxvd1tqXTtcbiAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHBvaW50fSA9IGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgJ3gnKTtcbiAgICBpZiAoIXBvaW50IHx8IChmaXJzdCAmJiBsYXN0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmaXJzdCkge1xuICAgICAgcG9zdHBvbmVkLnVuc2hpZnQocG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBvaW50cy5wdXNoKC4uLnBvc3Rwb25lZCk7XG59XG5mdW5jdGlvbiBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHBvaW50ID0gbGluZS5pbnRlcnBvbGF0ZShzb3VyY2VQb2ludCwgcHJvcGVydHkpO1xuICBpZiAoIXBvaW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHBvaW50VmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgbGV0IGxhc3QgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LnN0YXJ0XVtwcm9wZXJ0eV07XG4gICAgY29uc3QgbGFzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LmVuZF1bcHJvcGVydHldO1xuICAgIGlmIChfaXNCZXR3ZWVuKHBvaW50VmFsdWUsIGZpcnN0VmFsdWUsIGxhc3RWYWx1ZSkpIHtcbiAgICAgIGZpcnN0ID0gcG9pbnRWYWx1ZSA9PT0gZmlyc3RWYWx1ZTtcbiAgICAgIGxhc3QgPSBwb2ludFZhbHVlID09PSBsYXN0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtmaXJzdCwgbGFzdCwgcG9pbnR9O1xufVxuXG5jbGFzcyBzaW1wbGVBcmMge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy54ID0gb3B0cy54O1xuICAgIHRoaXMueSA9IG9wdHMueTtcbiAgICB0aGlzLnJhZGl1cyA9IG9wdHMucmFkaXVzO1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG4gIGludGVycG9sYXRlKHBvaW50KSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGNvbnN0IGFuZ2xlID0gcG9pbnQuYW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRUYXJnZXQoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgZmlsbCwgbGluZX0gPSBzb3VyY2U7XG4gIGlmIChpc051bWJlckZpbml0ZShmaWxsKSkge1xuICAgIHJldHVybiBnZXRMaW5lQnlJbmRleChjaGFydCwgZmlsbCk7XG4gIH1cbiAgaWYgKGZpbGwgPT09ICdzdGFjaycpIHtcbiAgICByZXR1cm4gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSk7XG4gIH1cbiAgaWYgKGZpbGwgPT09ICdzaGFwZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuICBpZiAoYm91bmRhcnkgaW5zdGFuY2VvZiBzaW1wbGVBcmMpIHtcbiAgICByZXR1cm4gYm91bmRhcnk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpO1xufVxuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHNjYWxlID0gc291cmNlLnNjYWxlIHx8IHt9O1xuICBpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUgPSB7fSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IHBpeGVsID0gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKTtcbiAgaWYgKGlzTnVtYmVyRmluaXRlKHBpeGVsKSkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHBpeGVsIDogbnVsbCxcbiAgICAgIHk6IGhvcml6b250YWwgPyBudWxsIDogcGl4ZWxcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xuICBjb25zdCB2YWx1ZSA9IF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnQpO1xuICBjb25zdCB0YXJnZXQgPSBbXTtcbiAgaWYgKG9wdGlvbnMuZ3JpZC5jaXJjdWxhcikge1xuICAgIGNvbnN0IGNlbnRlciA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLCBzdGFydCk7XG4gICAgcmV0dXJuIG5ldyBzaW1wbGVBcmMoe1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueSxcbiAgICAgIHJhZGl1czogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpXG4gICAgfSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRhcmdldC5wdXNoKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9kcmF3ZmlsbChjdHgsIHNvdXJjZSwgYXJlYSkge1xuICBjb25zdCB0YXJnZXQgPSBfZ2V0VGFyZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IHtsaW5lLCBzY2FsZSwgYXhpc30gPSBzb3VyY2U7XG4gIGNvbnN0IGxpbmVPcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gbGluZU9wdHMuZmlsbDtcbiAgY29uc3QgY29sb3IgPSBsaW5lT3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGNvbnN0IHthYm92ZSA9IGNvbG9yLCBiZWxvdyA9IGNvbG9yfSA9IGZpbGxPcHRpb24gfHwge307XG4gIGlmICh0YXJnZXQgJiYgbGluZS5wb2ludHMubGVuZ3RoKSB7XG4gICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICBkb0ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlLCBheGlzfSk7XG4gICAgdW5jbGlwQXJlYShjdHgpO1xuICB9XG59XG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcbiAgY3R4LnNhdmUoKTtcbiAgaWYgKHByb3BlcnR5ID09PSAneCcgJiYgYmVsb3cgIT09IGFib3ZlKSB7XG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLnRvcCk7XG4gICAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBhYm92ZSwgc2NhbGUsIHByb3BlcnR5fSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS5ib3R0b20pO1xuICB9XG4gIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYmVsb3csIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xuICBjb25zdCB7c2VnbWVudHMsIHBvaW50c30gPSB0YXJnZXQ7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdFBvaW50ID0gcG9pbnRzW19maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpXTtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGNsaXBZKTtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgIH1cbiAgICBsaW5lTG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwge21vdmU6IGxpbmVMb29wfSk7XG4gICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8obGFzdFBvaW50LngsIGNsaXBZKTtcbiAgICB9XG4gIH1cbiAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIGZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgcHJvcGVydHksIGNvbG9yLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHNlZ21lbnRzID0gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpO1xuICBmb3IgKGNvbnN0IHtzb3VyY2U6IHNyYywgdGFyZ2V0OiB0Z3QsIHN0YXJ0LCBlbmR9IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0eWxlOiB7YmFja2dyb3VuZENvbG9yID0gY29sb3J9ID0ge319ID0gc3JjO1xuICAgIGNvbnN0IG5vdFNoYXBlID0gdGFyZ2V0ICE9PSB0cnVlO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIG5vdFNoYXBlICYmIF9nZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgbGluZUxvb3AgPSAhIWxpbmUucGF0aFNlZ21lbnQoY3R4LCBzcmMpO1xuICAgIGxldCBsb29wO1xuICAgIGlmIChub3RTaGFwZSkge1xuICAgICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgZW5kLCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCB0Z3QsIHttb3ZlOiBsaW5lTG9vcCwgcmV2ZXJzZTogdHJ1ZX0pO1xuICAgICAgbG9vcCA9IGxpbmVMb29wICYmIHRhcmdldExvb3A7XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBzdGFydCwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwobG9vcCA/ICdldmVub2RkJyA6ICdub256ZXJvJyk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBib3VuZHMpIHtcbiAgY29uc3Qge3RvcCwgYm90dG9tfSA9IHNjYWxlLmNoYXJ0LmNoYXJ0QXJlYTtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydCwgZW5kfSA9IGJvdW5kcyB8fCB7fTtcbiAgaWYgKHByb3BlcnR5ID09PSAneCcpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnJlY3Qoc3RhcnQsIHRvcCwgZW5kIC0gc3RhcnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBwb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKGludGVycG9sYXRlZFBvaW50KSB7XG4gICAgY3R4LmxpbmVUbyhpbnRlcnBvbGF0ZWRQb2ludC54LCBpbnRlcnBvbGF0ZWRQb2ludC55KTtcbiAgfVxufVxuXG52YXIgaW5kZXggPSB7XG4gIGlkOiAnZmlsbGVyJyxcbiAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG4gICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgIGxldCBtZXRhLCBpLCBsaW5lLCBzb3VyY2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICBzb3VyY2UgPSBudWxsO1xuICAgICAgaWYgKGxpbmUgJiYgbGluZS5vcHRpb25zICYmIGxpbmUgaW5zdGFuY2VvZiBMaW5lRWxlbWVudCkge1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBmaWxsOiBfZGVjb2RlRmlsbChsaW5lLCBpLCBjb3VudCksXG4gICAgICAgICAgY2hhcnQsXG4gICAgICAgICAgYXhpczogbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuaW5kZXhBeGlzLFxuICAgICAgICAgIHNjYWxlOiBtZXRhLnZTY2FsZSxcbiAgICAgICAgICBsaW5lLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbWV0YS4kZmlsbGVyID0gc291cmNlO1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc291cmNlLmZpbGwgPSBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBvcHRpb25zLnByb3BhZ2F0ZSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGRyYXcgPSBvcHRpb25zLmRyYXdUaW1lID09PSAnYmVmb3JlRHJhdyc7XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgaWYgKGRyYXcgJiYgc291cmNlLmZpbGwpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXRzRHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKF9zaG91bGRBcHBseUZpbGwoc291cmNlKSkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiZWZvcmVEYXRhc2V0RHJhdyhjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuICAgIGlmICghX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHx8IG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0RHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICBkcmF3VGltZTogJ2JlZm9yZURhdGFzZXREcmF3J1xuICB9XG59O1xuXG5jb25zdCBnZXRCb3hTaXplID0gKGxhYmVsT3B0cywgZm9udFNpemUpID0+IHtcbiAgbGV0IHtib3hIZWlnaHQgPSBmb250U2l6ZSwgYm94V2lkdGggPSBmb250U2l6ZX0gPSBsYWJlbE9wdHM7XG4gIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgIGJveEhlaWdodCA9IE1hdGgubWluKGJveEhlaWdodCwgZm9udFNpemUpO1xuICAgIGJveFdpZHRoID0gbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCB8fCBNYXRoLm1pbihib3hXaWR0aCwgZm9udFNpemUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYm94V2lkdGgsXG4gICAgYm94SGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KGZvbnRTaXplLCBib3hIZWlnaHQpXG4gIH07XG59O1xuY29uc3QgaXRlbXNFcXVhbCA9IChhLCBiKSA9PiBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5kYXRhc2V0SW5kZXggPT09IGIuZGF0YXNldEluZGV4ICYmIGEuaW5kZXggPT09IGIuaW5kZXg7XG5jbGFzcyBMZWdlbmQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG4gICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sdW1uU2l6ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucztcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XG4gICAgdGhpcy5maXQoKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSB0aGlzLl9tYXJnaW5zLnRvcDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICB9XG4gIGJ1aWxkTGFiZWxzKCkge1xuICAgIGNvbnN0IGxhYmVsT3B0cyA9IHRoaXMub3B0aW9ucy5sYWJlbHMgfHwge307XG4gICAgbGV0IGxlZ2VuZEl0ZW1zID0gY2FsbGJhY2sobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbdGhpcy5jaGFydF0sIHRoaXMpIHx8IFtdO1xuICAgIGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxhYmVsT3B0cy5zb3J0KSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLnNvcnQoKGEsIGIpID0+IGxhYmVsT3B0cy5zb3J0KGEsIGIsIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcbiAgICB9XG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY3R4fSA9IHRoaXM7XG4gICAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsT3B0cyA9IG9wdGlvbnMubGFiZWxzO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtib3hXaWR0aCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgd2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5fZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHdpZHRoID0gdGhpcy5fZml0Q29scyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gTWF0aC5taW4od2lkdGgsIG9wdGlvbnMubWF4V2lkdGggfHwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIG9wdGlvbnMubWF4SGVpZ2h0IHx8IHRoaXMubWF4SGVpZ2h0KTtcbiAgfVxuICBfZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4V2lkdGgsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gdGhpcy5saW5lV2lkdGhzID0gWzBdO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICBsZXQgdG90YWxIZWlnaHQgPSB0aXRsZUhlaWdodDtcbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBsZXQgcm93ID0gLTE7XG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XG4gICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICByb3crKztcbiAgICAgIH1cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQ6IDAsIHRvcCwgcm93LCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICB9XG4gIF9maXRDb2xzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhIZWlnaHQsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBjb2x1bW5TaXplcyA9IHRoaXMuY29sdW1uU2l6ZXMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xuICAgIGxldCB0b3RhbFdpZHRoID0gcGFkZGluZztcbiAgICBsZXQgY3VycmVudENvbFdpZHRoID0gMDtcbiAgICBsZXQgY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgbGV0IGxlZnQgPSAwO1xuICAgIGxldCBjb2wgPSAwO1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgaWYgKGkgPiAwICYmIGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ICsgMiAqIHBhZGRpbmcgPiBoZWlnaHRMaW1pdCkge1xuICAgICAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pO1xuICAgICAgICBsZWZ0ICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbCsrO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQsIHRvcDogY3VycmVudENvbEhlaWdodCwgY29sLCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB9KTtcbiAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcbiAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTtcbiAgICByZXR1cm4gdG90YWxXaWR0aDtcbiAgfVxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZ2VuZEhpdEJveGVzOiBoaXRib3hlcywgb3B0aW9uczoge2FsaWduLCBsYWJlbHM6IHtwYWRkaW5nfSwgcnRsfX0gPSB0aGlzO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIocnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgcm93ID0gMDtcbiAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgcm93ID0gaGl0Ym94LnJvdztcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCArPSB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgbGVmdCArPSBoaXRib3gud2lkdGggKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sID0gMDtcbiAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgY29sID0gaGl0Ym94LmNvbDtcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChoaXRib3gubGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIHRvcCArPSBoaXRib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gIH1cbiAgZHJhdygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY2xpcEFyZWEoY3R4LCB0aGlzKTtcbiAgICAgIHRoaXMuX2RyYXcoKTtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cbiAgX2RyYXcoKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IG9wdHMsIGNvbHVtblNpemVzLCBsaW5lV2lkdGhzLCBjdHh9ID0gdGhpcztcbiAgICBjb25zdCB7YWxpZ24sIGxhYmVsczogbGFiZWxPcHRzfSA9IG9wdHM7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHtjb2xvcjogZm9udENvbG9yLCBwYWRkaW5nfSA9IGxhYmVsT3B0cztcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcbiAgICBsZXQgY3Vyc29yO1xuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oJ2xlZnQnKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG4gICAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHQsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lV2lkdGgsIDEpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsICdidXR0Jyk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCAwKTtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sICdtaXRlcicpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaCwgW10pKTtcbiAgICAgIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICByYWRpdXM6IGJveEhlaWdodCAqIE1hdGguU1FSVDIgLyAyLFxuICAgICAgICAgIHBvaW50U3R5bGU6IGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogbGVnZW5kSXRlbS5yb3RhdGlvbixcbiAgICAgICAgICBib3JkZXJXaWR0aDogbGluZVdpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyBoYWxmRm9udFNpemU7XG4gICAgICAgIGRyYXdQb2ludExlZ2VuZChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZLCBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoICYmIGJveFdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHlCb3hUb3AgPSB5ICsgTWF0aC5tYXgoKGZvbnRTaXplIC0gYm94SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICBjb25zdCB4Qm94TGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHgsIGJveFdpZHRoKTtcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsZWdlbmRJdGVtLmJvcmRlclJhZGl1cyk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICB4OiB4Qm94TGVmdCxcbiAgICAgICAgICAgIHk6IHlCb3hUb3AsXG4gICAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5yZWN0KHhCb3hMZWZ0LCB5Qm94VG9wLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZiAobGluZVdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgY29uc3QgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGVnZW5kSXRlbS50ZXh0LCB4LCB5ICsgKGl0ZW1IZWlnaHQgLyAyKSwgbGFiZWxGb250LCB7XG4gICAgICAgIHN0cmlrZXRocm91Z2g6IGxlZ2VuZEl0ZW0uaGlkZGVuLFxuICAgICAgICB0ZXh0QWxpZ246IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24pXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1swXSksXG4gICAgICAgIHk6IHRoaXMudG9wICsgcGFkZGluZyArIHRpdGxlSGVpZ2h0LFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IHRoaXMubGVmdCArIHBhZGRpbmcsXG4gICAgICAgIHk6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1swXS5oZWlnaHQpLFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBvdmVycmlkZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3IgfHwgZm9udENvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yIHx8IGZvbnRDb2xvcjtcbiAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbiB8fCAobGVnZW5kSXRlbS50ZXh0QWxpZ24gPSBsYWJlbE9wdHMudGV4dEFsaWduKSk7XG4gICAgICBjb25zdCB3aWR0aCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgdGV4dFdpZHRoO1xuICAgICAgbGV0IHggPSBjdXJzb3IueDtcbiAgICAgIGxldCB5ID0gY3Vyc29yLnk7XG4gICAgICBydGxIZWxwZXIuc2V0V2lkdGgodGhpcy53aWR0aCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChpID4gMCAmJiB4ICsgd2lkdGggKyBwYWRkaW5nID4gdGhpcy5yaWdodCkge1xuICAgICAgICAgIHkgPSBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgICAgeCA9IGN1cnNvci54ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSBsaW5lV2lkdGhzW2N1cnNvci5saW5lXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaSA+IDAgJiYgeSArIGxpbmVIZWlnaHQgPiB0aGlzLmJvdHRvbSkge1xuICAgICAgICB4ID0gY3Vyc29yLnggPSB4ICsgY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLndpZHRoICsgcGFkZGluZztcbiAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgeSA9IGN1cnNvci55ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcbiAgICAgIGRyYXdMZWdlbmRCb3gocmVhbFgsIHksIGxlZ2VuZEl0ZW0pO1xuICAgICAgeCA9IF90ZXh0WCh0ZXh0QWxpZ24sIHggKyBib3hXaWR0aCArIGhhbGZGb250U2l6ZSwgaXNIb3Jpem9udGFsID8geCArIHdpZHRoIDogdGhpcy5yaWdodCwgb3B0cy5ydGwpO1xuICAgICAgZmlsbFRleHQocnRsSGVscGVyLngoeCksIHksIGxlZ2VuZEl0ZW0pO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBjdXJzb3IueCArPSB3aWR0aCArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICB9XG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IG9wdHMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIGlmICghdGl0bGVPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRpdGxlT3B0cy5wb3NpdGlvbjtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSB0aXRsZUZvbnQuc2l6ZSAvIDI7XG4gICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xuICAgIGxldCB5O1xuICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0O1xuICAgIGxldCBtYXhXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgoLi4udGhpcy5saW5lV2lkdGhzKTtcbiAgICAgIHkgPSB0aGlzLnRvcCArIHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplO1xuICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIGxlZnQsIHRoaXMucmlnaHQgLSBtYXhXaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcbiAgICAgIHkgPSB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSArIF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIG1heEhlaWdodCAtIG9wdHMubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgfVxuICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihfdG9MZWZ0UmlnaHRDZW50ZXIocG9zaXRpb24pKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZU9wdHMudGV4dCwgeCwgeSwgdGl0bGVGb250KTtcbiAgfVxuICBfY29tcHV0ZVRpdGxlSGVpZ2h0KCkge1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IHRoaXMub3B0aW9ucy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgcmV0dXJuIHRpdGxlT3B0cy5kaXNwbGF5ID8gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVBhZGRpbmcuaGVpZ2h0IDogMDtcbiAgfVxuICBfZ2V0TGVnZW5kSXRlbUF0KHgsIHkpIHtcbiAgICBsZXQgaSwgaGl0Qm94LCBsaDtcbiAgICBpZiAoX2lzQmV0d2Vlbih4LCB0aGlzLmxlZnQsIHRoaXMucmlnaHQpXG4gICAgICAmJiBfaXNCZXR3ZWVuKHksIHRoaXMudG9wLCB0aGlzLmJvdHRvbSkpIHtcbiAgICAgIGxoID0gdGhpcy5sZWdlbmRIaXRCb3hlcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBoaXRCb3ggPSBsaFtpXTtcbiAgICAgICAgaWYgKF9pc0JldHdlZW4oeCwgaGl0Qm94LmxlZnQsIGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoKVxuICAgICAgICAgICYmIF9pc0JldHdlZW4oeSwgaGl0Qm94LnRvcCwgaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFpc0xpc3RlbmVkKGUudHlwZSwgb3B0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaG92ZXJlZEl0ZW0gPSB0aGlzLl9nZXRMZWdlbmRJdGVtQXQoZS54LCBlLnkpO1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsYmFjayhvcHRzLm9uTGVhdmUsIFtlLCBwcmV2aW91cywgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbGJhY2sob3B0cy5vbkhvdmVyLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICBjYWxsYmFjayhvcHRzLm9uQ2xpY2ssIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICgodHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgdHlwZSA9PT0gJ21vdXNlb3V0JykgJiYgKG9wdHMub25Ib3ZlciB8fCBvcHRzLm9uTGVhdmUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIHBsdWdpbl9sZWdlbmQgPSB7XG4gIGlkOiAnbGVnZW5kJyxcbiAgX2VsZW1lbnQ6IExlZ2VuZCxcbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kID0gbmV3IExlZ2VuZCh7Y3R4OiBjaGFydC5jdHgsIG9wdGlvbnMsIGNoYXJ0fSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIGxlZ2VuZCk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgY2hhcnQubGVnZW5kKTtcbiAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxlZ2VuZC5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgYWZ0ZXJVcGRhdGUoY2hhcnQpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGVnZW5kLmJ1aWxkTGFiZWxzKCk7XG4gICAgbGVnZW5kLmFkanVzdEhpdEJveGVzKCk7XG4gIH0sXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MucmVwbGF5KSB7XG4gICAgICBjaGFydC5sZWdlbmQuaGFuZGxlRXZlbnQoYXJncy5ldmVudCk7XG4gICAgfVxuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICB3ZWlnaHQ6IDEwMDAsXG4gICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG4gICAgICBjb25zdCBjaSA9IGxlZ2VuZC5jaGFydDtcbiAgICAgIGlmIChjaS5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KSkge1xuICAgICAgICBjaS5oaWRlKGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2kuc2hvdyhpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkhvdmVyOiBudWxsLFxuICAgIG9uTGVhdmU6IG51bGwsXG4gICAgbGFiZWxzOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBib3hXaWR0aDogNDAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcbiAgICAgICAgY29uc3Qge2xhYmVsczoge3VzZVBvaW50U3R5bGUsIHBvaW50U3R5bGUsIHRleHRBbGlnbiwgY29sb3J9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICByZXR1cm4gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcygpLm1hcCgobWV0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHVzZVBvaW50U3R5bGUgPyAwIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHRvUGFkZGluZyhzdHlsZS5ib3JkZXJXaWR0aCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogKGJvcmRlcldpZHRoLndpZHRoICsgYm9yZGVyV2lkdGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlIHx8IHN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgIHRleHQ6ICcnLFxuICAgIH1cbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gICAgbGFiZWxzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFbJ2dlbmVyYXRlTGFiZWxzJywgJ2ZpbHRlcicsICdzb3J0J10uaW5jbHVkZXMobmFtZSksXG4gICAgfVxuICB9LFxufTtcblxuY2xhc3MgVGl0bGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLl9wYWRkaW5nID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLmxlZnQgPSAwO1xuICAgIHRoaXMudG9wID0gMDtcbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5yaWdodCA9IHRoaXMuYm90dG9tID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgPSBtYXhXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm90dG9tID0gbWF4SGVpZ2h0O1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IGlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuICAgIHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5wYWRkaW5nKTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplO1xuICAgIH1cbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG4gIH1cbiAgX2RyYXdBcmdzKG9mZnNldCkge1xuICAgIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBhbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgdGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuICAgICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgdGl0bGVYID0gbGVmdCArIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIC0wLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZVggPSByaWdodCAtIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRvcCwgYm90dG9tKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIDAuNTtcbiAgICAgIH1cbiAgICAgIG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuICAgIH1cbiAgICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250T3B0cyA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBmb250T3B0cy5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgdGhpcy5fcGFkZGluZy50b3A7XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGhpcy5fZHJhd0FyZ3Mob2Zmc2V0KTtcbiAgICByZW5kZXJUZXh0KGN0eCwgb3B0cy50ZXh0LCAwLCAwLCBmb250T3B0cywge1xuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiBfdG9MZWZ0UmlnaHRDZW50ZXIob3B0cy5hbGlnbiksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKGNoYXJ0LCB0aXRsZU9wdHMpIHtcbiAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgIGN0eDogY2hhcnQuY3R4LFxuICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcbiAgICBjaGFydFxuICB9KTtcbiAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICBjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG52YXIgcGx1Z2luX3RpdGxlID0ge1xuICBpZDogJ3RpdGxlJyxcbiAgX2VsZW1lbnQ6IFRpdGxlLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjcmVhdGVUaXRsZShjaGFydCwgb3B0aW9ucyk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG4gICAgZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAyMDAwXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcblxuY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBwbHVnaW5fc3VidGl0bGUgPSB7XG4gIGlkOiAnc3VidGl0bGUnLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjaGFydFxuICAgIH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgICBtYXAuc2V0KGNoYXJ0LCB0aXRsZSk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBtYXAuZ2V0KGNoYXJ0KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAxNTAwXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcblxuY29uc3QgcG9zaXRpb25lcnMgPSB7XG4gIGF2ZXJhZ2UoaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaSwgbGVuO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICAgIHggKz0gcG9zLng7XG4gICAgICAgIHkgKz0gcG9zLnk7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiB4IC8gY291bnQsXG4gICAgICB5OiB5IC8gY291bnRcbiAgICB9O1xuICB9LFxuICBuZWFyZXN0KGl0ZW1zLCBldmVudFBvc2l0aW9uKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHggPSBldmVudFBvc2l0aW9uLng7XG4gICAgbGV0IHkgPSBldmVudFBvc2l0aW9uLnk7XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBpLCBsZW4sIG5lYXJlc3RFbGVtZW50O1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjb25zdCBkID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG4gICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgbmVhcmVzdEVsZW1lbnQgPSBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVhcmVzdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICB4ID0gdHAueDtcbiAgICAgIHkgPSB0cC55O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuICBpZiAodG9QdXNoKSB7XG4gICAgaWYgKGlzQXJyYXkodG9QdXNoKSkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZS5wdXNoKHRvUHVzaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlO1xufVxuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcbiAgaWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gIGNvbnN0IHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSA9IGl0ZW07XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcbiAgcmV0dXJuIHtcbiAgICBjaGFydCxcbiAgICBsYWJlbCxcbiAgICBwYXJzZWQ6IGNvbnRyb2xsZXIuZ2V0UGFyc2VkKGluZGV4KSxcbiAgICByYXc6IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSxcbiAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXG4gICAgZGF0YXNldDogY29udHJvbGxlci5nZXREYXRhc2V0KCksXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBkYXRhc2V0SW5kZXgsXG4gICAgZWxlbWVudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgb3B0aW9ucykge1xuICBjb25zdCBjdHggPSB0b29sdGlwLmNoYXJ0LmN0eDtcbiAgY29uc3Qge2JvZHksIGZvb3RlciwgdGl0bGV9ID0gdG9vbHRpcDtcbiAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHR9ID0gb3B0aW9ucztcbiAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gIGNvbnN0IGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgY29uc3QgdGl0bGVMaW5lQ291bnQgPSB0aXRsZS5sZW5ndGg7XG4gIGNvbnN0IGZvb3RlckxpbmVDb3VudCA9IGZvb3Rlci5sZW5ndGg7XG4gIGNvbnN0IGJvZHlMaW5lSXRlbUNvdW50ID0gYm9keS5sZW5ndGg7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG4gIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcblx0XHRcdCsgb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbTtcbiAgfVxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBoZWlnaHQgKz0gYm9keUxpbmVJdGVtQ291bnQgKiBib2R5TGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICB9XG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3Bcblx0XHRcdCsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgfVxuICBsZXQgd2lkdGhQYWRkaW5nID0gMDtcbiAgY29uc3QgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XG4gIH07XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMiArIG9wdGlvbnMuYm94UGFkZGluZykgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG4gIHdpZHRoUGFkZGluZyA9IDA7XG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG4gIGN0eC5yZXN0b3JlKCk7XG4gIHdpZHRoICs9IHBhZGRpbmcud2lkdGg7XG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgY29uc3Qge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeSA8IGhlaWdodCAvIDIpIHtcbiAgICByZXR1cm4gJ3RvcCc7XG4gIH0gZWxzZSBpZiAoeSA+IChjaGFydC5oZWlnaHQgLSBoZWlnaHQgLyAyKSkge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfVxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbikge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3Qge3dpZHRoOiBjaGFydFdpZHRoLCBjaGFydEFyZWE6IHtsZWZ0LCByaWdodH19ID0gY2hhcnQ7XG4gIGxldCB4QWxpZ24gPSAnY2VudGVyJztcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICB9XG4gIHJldHVybiB4QWxpZ247XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3QgeUFsaWduID0gc2l6ZS55QWxpZ24gfHwgb3B0aW9ucy55QWxpZ24gfHwgZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKTtcbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IHNpemUueEFsaWduIHx8IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgbGV0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKSB7XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBzaXplLCBhbGlnbm1lbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHtjYXJldFNpemUsIGNhcmV0UGFkZGluZywgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSBhbGlnbm1lbnQ7XG4gIGNvbnN0IHBhZGRpbmdBbmRTaXplID0gY2FyZXRTaXplICsgY2FyZXRQYWRkaW5nO1xuICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHggKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCAtPSBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIGNhcmV0U2l6ZTtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBfbGltaXRWYWx1ZSh4LCAwLCBjaGFydC53aWR0aCAtIHNpemUud2lkdGgpLFxuICAgIHk6IF9saW1pdFZhbHVlKHksIDAsIGNoYXJ0LmhlaWdodCAtIHNpemUuaGVpZ2h0KVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXG4gICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC8gMlxuICAgIDogYWxpZ24gPT09ICdyaWdodCdcbiAgICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAtIHBhZGRpbmcucmlnaHRcbiAgICAgIDogdG9vbHRpcC54ICsgcGFkZGluZy5sZWZ0O1xufVxuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcENvbnRleHQocGFyZW50LCB0b29sdGlwLCB0b29sdGlwSXRlbXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdG9vbHRpcCxcbiAgICB0b29sdGlwSXRlbXMsXG4gICAgdHlwZTogJ3Rvb2x0aXAnXG4gIH0pO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3BhY2l0eSA9IDA7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gW107XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQgfHwgY29uZmlnLl9jaGFydDtcbiAgICB0aGlzLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iZWZvcmVCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFmdGVyQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvb3RlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnhBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdGlhbGl6ZShvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlZEFuaW1hdGlvbnM7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY2hhcnQsIG9wdHMpO1xuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVRvb2x0aXBDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLCB0aGlzLl90b29sdGlwSXRlbXMpKTtcbiAgfVxuICBnZXRUaXRsZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gY2FsbGJhY2tzLmJlZm9yZVRpdGxlLmFwcGx5KHRoaXMsIFtjb250ZXh0XSk7XG4gICAgY29uc3QgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBjb25zdCBhZnRlclRpdGxlID0gY2FsbGJhY2tzLmFmdGVyVGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhvcHRpb25zLmNhbGxiYWNrcy5iZWZvcmVCb2R5LmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKSk7XG4gIH1cbiAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUl0ZW1zID0gW107XG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBib2R5SXRlbSA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBhZnRlcjogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhzY29wZWQuYmVmb3JlTGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmxpbmVzLCBzY29wZWQubGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoc2NvcGVkLmFmdGVyTGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSkpO1xuICAgICAgYm9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBib2R5SXRlbXM7XG4gIH1cbiAgZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhvcHRpb25zLmNhbGxiYWNrcy5hZnRlckJvZHkuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pKTtcbiAgfVxuICBnZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJlZm9yZUZvb3RlciA9IGNhbGxiYWNrcy5iZWZvcmVGb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGNvbnN0IGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGNvbnN0IGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKTtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5jaGFydCwgYWN0aXZlW2ldKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBvcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaXRlbVNvcnQpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KChhLCBiKSA9PiBvcHRpb25zLml0ZW1Tb3J0KGEsIGIsIGRhdGEpKTtcbiAgICB9XG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBsYWJlbENvbG9ycy5wdXNoKHNjb3BlZC5sYWJlbENvbG9yLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxQb2ludFN0eWxlcy5wdXNoKHNjb3BlZC5sYWJlbFBvaW50U3R5bGUuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFRleHRDb2xvcnMucHVzaChzY29wZWQubGFiZWxUZXh0Q29sb3IuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgfSk7XG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuICAgIHJldHVybiB0b29sdGlwSXRlbXM7XG4gIH1cbiAgdXBkYXRlKGNoYW5nZWQsIHJlcGxheSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGxldCBwcm9wZXJ0aWVzO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XG4gICAgICB0aGlzLnRpdGxlID0gdGhpcy5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5iZWZvcmVCb2R5ID0gdGhpcy5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJvZHkgPSB0aGlzLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdGhpcy5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZm9vdGVyID0gdGhpcy5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQodGhpcy5jaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgdGhpcy5jaGFydCk7XG4gICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB4OiBiYWNrZ3JvdW5kUG9pbnQueCxcbiAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXG4gICAgICAgIGNhcmV0WTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwodGhpcywge2NoYXJ0OiB0aGlzLmNoYXJ0LCB0b29sdGlwOiB0aGlzLCByZXBsYXl9KTtcbiAgICB9XG4gIH1cbiAgZHJhd0NhcmV0KHRvb2x0aXBQb2ludCwgY3R4LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICB9XG4gIGdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge2NhcmV0U2l6ZSwgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gICAgY29uc3Qge3g6IHB0WCwgeTogcHRZfSA9IHRvb2x0aXBQb2ludDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xuICAgIGxldCB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICB5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTEgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gcHRYICsgd2lkdGg7XG4gICAgICAgIHgyID0geDEgKyBjYXJldFNpemU7XG4gICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgKyBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB4MyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIChjYXJldFNpemUpO1xuICAgICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyB3aWR0aCAtIE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHRoaXMuY2FyZXRYO1xuICAgICAgfVxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgIHkyID0geTEgLSBjYXJldFNpemU7XG4gICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgKyBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHB0WSArIGhlaWdodDtcbiAgICAgICAgeTIgPSB5MSArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDEgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHkzID0geTE7XG4gICAgfVxuICAgIHJldHVybiB7eDEsIHgyLCB4MywgeTEsIHkyLCB5M307XG4gIH1cbiAgZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMudGl0bGU7XG4gICAgY29uc3QgbGVuZ3RoID0gdGl0bGUubGVuZ3RoO1xuICAgIGxldCB0aXRsZUZvbnQsIHRpdGxlU3BhY2luZywgaTtcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMudGl0bGVBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLnRpdGxlQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICAgIHRpdGxlU3BhY2luZyA9IG9wdGlvbnMudGl0bGVTcGFjaW5nO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMudGl0bGVDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQodGl0bGVbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgdGl0bGVGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlU3BhY2luZztcbiAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IHRoaXMubGFiZWxDb2xvcnNbaV07XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgIGNvbnN0IHtib3hIZWlnaHQsIGJveFdpZHRoLCBib3hQYWRkaW5nfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xuICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG4gICAgaWYgKG9wdGlvbnMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLFxuICAgICAgICBwb2ludFN0eWxlOiBsYWJlbFBvaW50U3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgcm90YXRpb246IGxhYmVsUG9pbnRTdHlsZS5yb3RhdGlvbixcbiAgICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICAgIH07XG4gICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gaXNPYmplY3QobGFiZWxDb2xvcnMuYm9yZGVyV2lkdGgpID8gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhsYWJlbENvbG9ycy5ib3JkZXJXaWR0aCkpIDogKGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoIHx8IDEpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2gobGFiZWxDb2xvcnMuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsYWJlbENvbG9ycy5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBvdXRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoIC0gYm94UGFkZGluZyk7XG4gICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSBib3hQYWRkaW5nIC0gMik7XG4gICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxhYmVsQ29sb3JzLmJvcmRlclJhZGl1cyk7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IG91dGVyWCxcbiAgICAgICAgICB5OiBjb2xvclksXG4gICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBpbm5lclgsXG4gICAgICAgICAgeTogY29sb3JZICsgMSxcbiAgICAgICAgICB3OiBib3hXaWR0aCAtIDIsXG4gICAgICAgICAgaDogYm94SGVpZ2h0IC0gMixcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5maWxsUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGlubmVyWCwgY29sb3JZICsgMSwgYm94V2lkdGggLSAyLCBib3hIZWlnaHQgLSAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICB9XG4gIGRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Ym9keX0gPSB0aGlzO1xuICAgIGNvbnN0IHtib2R5U3BhY2luZywgYm9keUFsaWduLCBkaXNwbGF5Q29sb3JzLCBib3hIZWlnaHQsIGJveFdpZHRoLCBib3hQYWRkaW5nfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgbGV0IGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBsZXQgeExpbmVQYWRkaW5nID0gMDtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUxpbmVIZWlnaHQgLyAyKTtcbiAgICAgIHB0LnkgKz0gYm9keUxpbmVIZWlnaHQgKyBib2R5U3BhY2luZztcbiAgICB9O1xuICAgIGNvbnN0IGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uID0gcnRsSGVscGVyLnRleHRBbGlnbihib2R5QWxpZ24pO1xuICAgIGxldCBib2R5SXRlbSwgdGV4dENvbG9yLCBsaW5lcywgaSwgaiwgaWxlbiwgamxlbjtcbiAgICBjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24sIG9wdGlvbnMpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcbiAgICBlYWNoKHRoaXMuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHhMaW5lUGFkZGluZyA9IGRpc3BsYXlDb2xvcnMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCdcbiAgICAgID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib3hXaWR0aCAvIDIgKyBib3hQYWRkaW5nKSA6IChib3hXaWR0aCArIDIgKyBib3hQYWRkaW5nKVxuICAgICAgOiAwO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xuICAgICAgdGV4dENvbG9yID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuICAgICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICBpZiAoZGlzcGxheUNvbG9ycyAmJiBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucyk7XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gTWF0aC5tYXgoYm9keUZvbnQubGluZUhlaWdodCwgYm94SGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgfVxuICAgIHhMaW5lUGFkZGluZyA9IDA7XG4gICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGVhY2godGhpcy5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICBwdC55IC09IGJvZHlTcGFjaW5nO1xuICB9XG4gIGRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZvb3RlciA9IHRoaXMuZm9vdGVyO1xuICAgIGNvbnN0IGxlbmd0aCA9IGZvb3Rlci5sZW5ndGg7XG4gICAgbGV0IGZvb3RlckZvbnQsIGk7XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLmZvb3RlckFsaWduLCBvcHRpb25zKTtcbiAgICAgIHB0LnkgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3A7XG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLmZvb3RlckFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZvb3RlckNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQoZm9vdGVyW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIGZvb3RlckZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IGZvb3RlckZvbnQubGluZUhlaWdodCArIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeX0gPSBwdDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0b29sdGlwU2l6ZTtcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMob3B0aW9ucy5jb3JuZXJSYWRpdXMpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHggKyB0b3BMZWZ0LCB5KTtcbiAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHRvcFJpZ2h0LCB5KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHRvcFJpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSBib3R0b21SaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBib3R0b21SaWdodCwgeSArIGhlaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgYm90dG9tTGVmdCwgeSArIGhlaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIGJvdHRvbUxlZnQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCwgeSArIHRvcExlZnQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyB0b3BMZWZ0LCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfd2lsbFJlbmRlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGxldCBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgIGlmICghb3BhY2l0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucyk7XG4gICAgY29uc3QgdG9vbHRpcFNpemUgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHB0ID0ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55XG4gICAgfTtcbiAgICBvcGFjaXR5ID0gTWF0aC5hYnMob3BhY2l0eSkgPCAxZS0zID8gMCA6IG9wYWNpdHk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICAgIGNvbnN0IGhhc1Rvb2x0aXBDb250ZW50ID0gdGhpcy50aXRsZS5sZW5ndGggfHwgdGhpcy5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB0aGlzLmJvZHkubGVuZ3RoIHx8IHRoaXMuYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB0aGlzLmZvb3Rlci5sZW5ndGg7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG4gICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xuICAgICAgdGhpcy5kcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cywgZXZlbnRQb3NpdGlvbikge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG4gICAgaWYgKGNoYW5nZWQgfHwgcG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gZXZlbnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSA9IHRydWUpIHtcbiAgICBpZiAocmVwbGF5ICYmIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSBmYWxzZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSk7XG4gICAgY29uc3QgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICB5OiBlLnlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSwgcmVwbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgcmV0dXJuIGxhc3RBY3RpdmU7XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMsIHJlcGxheSk7XG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZTtcbiAgfVxuICBfcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSkge1xuICAgIGNvbnN0IHtjYXJldFgsIGNhcmV0WSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIGUpO1xuICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xuICB9XG59XG5Ub29sdGlwLnBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnM7XG52YXIgcGx1Z2luX3Rvb2x0aXAgPSB7XG4gIGlkOiAndG9vbHRpcCcsXG4gIF9lbGVtZW50OiBUb29sdGlwLFxuICBwb3NpdGlvbmVycyxcbiAgYWZ0ZXJJbml0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe2NoYXJ0LCBvcHRpb25zfSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG4gIHJlc2V0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuICBhZnRlckRyYXcoY2hhcnQpIHtcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcbiAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwLl93aWxsUmVuZGVyKCkpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIHRvb2x0aXBcbiAgICAgIH07XG4gICAgICBpZiAoY2hhcnQubm90aWZ5UGx1Z2lucygnYmVmb3JlVG9vbHRpcERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdG9vbHRpcC5kcmF3KGNoYXJ0LmN0eCk7XG4gICAgICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclRvb2x0aXBEcmF3JywgYXJncyk7XG4gICAgfVxuICB9LFxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSBhcmdzLnJlcGxheTtcbiAgICAgIGlmIChjaGFydC50b29sdGlwLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQsIHVzZUZpbmFsUG9zaXRpb24sIGFyZ3MuaW5DaGFydEFyZWEpKSB7XG4gICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZXh0ZXJuYWw6IG51bGwsXG4gICAgcG9zaXRpb246ICdhdmVyYWdlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgIHRpdGxlQ29sb3I6ICcjZmZmJyxcbiAgICB0aXRsZUZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICBib2R5Q29sb3I6ICcjZmZmJyxcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge1xuICAgIH0sXG4gICAgYm9keUFsaWduOiAnbGVmdCcsXG4gICAgZm9vdGVyQ29sb3I6ICcjZmZmJyxcbiAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICBmb290ZXJGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZvb3RlckFsaWduOiAnbGVmdCcsXG4gICAgcGFkZGluZzogNixcbiAgICBjYXJldFBhZGRpbmc6IDIsXG4gICAgY2FyZXRTaXplOiA1LFxuICAgIGNvcm5lclJhZGl1czogNixcbiAgICBib3hIZWlnaHQ6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBib3hXaWR0aDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXG4gICAgYm94UGFkZGluZzogMCxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnY2FyZXRYJywgJ2NhcmV0WSddLFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBiZWZvcmVUaXRsZTogbm9vcCxcbiAgICAgIHRpdGxlKHRvb2x0aXBJdGVtcykge1xuICAgICAgICBpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gdG9vbHRpcEl0ZW1zWzBdO1xuICAgICAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICAgICAgY29uc3QgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuICAgICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5sYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmRhdGFJbmRleCA8IGxhYmVsQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHNbaXRlbS5kYXRhSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9LFxuICAgICAgYWZ0ZXJUaXRsZTogbm9vcCxcbiAgICAgIGJlZm9yZUJvZHk6IG5vb3AsXG4gICAgICBiZWZvcmVMYWJlbDogbm9vcCxcbiAgICAgIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgcmV0dXJuIHRvb2x0aXBJdGVtLmxhYmVsICsgJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlIHx8IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYWJlbCA9IHRvb2x0aXBJdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgIGxhYmVsICs9ICc6ICc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0sXG4gICAgICBsYWJlbENvbG9yKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgICAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBsYWJlbFRleHRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgICB9LFxuICAgICAgbGFiZWxQb2ludFN0eWxlKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFmdGVyTGFiZWw6IG5vb3AsXG4gICAgICBhZnRlckJvZHk6IG5vb3AsXG4gICAgICBiZWZvcmVGb290ZXI6IG5vb3AsXG4gICAgICBmb290ZXI6IG5vb3AsXG4gICAgICBhZnRlckZvb3Rlcjogbm9vcFxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGJvZHlGb250OiAnZm9udCcsXG4gICAgZm9vdGVyRm9udDogJ2ZvbnQnLFxuICAgIHRpdGxlRm9udDogJ2ZvbnQnXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lICE9PSAnaXRlbVNvcnQnICYmIG5hbWUgIT09ICdleHRlcm5hbCcsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgX2ZhbGxiYWNrOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJ1xuICAgIH1cbiAgfSxcbiAgYWRkaXRpb25hbE9wdGlvblNjb3BlczogWydpbnRlcmFjdGlvbiddXG59O1xuXG52YXIgcGx1Z2lucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkRlY2ltYXRpb246IHBsdWdpbl9kZWNpbWF0aW9uLFxuRmlsbGVyOiBpbmRleCxcbkxlZ2VuZDogcGx1Z2luX2xlZ2VuZCxcblN1YlRpdGxlOiBwbHVnaW5fc3VidGl0bGUsXG5UaXRsZTogcGx1Z2luX3RpdGxlLFxuVG9vbHRpcDogcGx1Z2luX3Rvb2x0aXBcbn0pO1xuXG5jb25zdCBhZGRJZlN0cmluZyA9IChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSA9PiB7XG4gIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIGluZGV4ID0gbGFiZWxzLnB1c2gocmF3KSAtIDE7XG4gICAgYWRkZWRMYWJlbHMudW5zaGlmdCh7aW5kZXgsIGxhYmVsOiByYXd9KTtcbiAgfSBlbHNlIGlmIChpc05hTihyYXcpKSB7XG4gICAgaW5kZXggPSBudWxsO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG5mdW5jdGlvbiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSB7XG4gIGNvbnN0IGZpcnN0ID0gbGFiZWxzLmluZGV4T2YocmF3KTtcbiAgaWYgKGZpcnN0ID09PSAtMSkge1xuICAgIHJldHVybiBhZGRJZlN0cmluZyhsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKTtcbiAgfVxuICBjb25zdCBsYXN0ID0gbGFiZWxzLmxhc3RJbmRleE9mKHJhdyk7XG4gIHJldHVybiBmaXJzdCAhPT0gbGFzdCA/IGluZGV4IDogZmlyc3Q7XG59XG5jb25zdCB2YWxpZEluZGV4ID0gKGluZGV4LCBtYXgpID0+IGluZGV4ID09PSBudWxsID8gbnVsbCA6IF9saW1pdFZhbHVlKE1hdGgucm91bmQoaW5kZXgpLCAwLCBtYXgpO1xuY2xhc3MgQ2F0ZWdvcnlTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gIH1cbiAgaW5pdChzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBhZGRlZCA9IHRoaXMuX2FkZGVkTGFiZWxzO1xuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICBmb3IgKGNvbnN0IHtpbmRleCwgbGFiZWx9IG9mIGFkZGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNbaW5kZXhdID09PSBsYWJlbCkge1xuICAgICAgICAgIGxhYmVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICAgIH1cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0aW9ucyk7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGluZGV4ID0gaXNGaW5pdGUoaW5kZXgpICYmIGxhYmVsc1tpbmRleF0gPT09IHJhdyA/IGluZGV4XG4gICAgICA6IGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCB2YWx1ZU9yRGVmYXVsdChpbmRleCwgcmF3KSwgdGhpcy5fYWRkZWRMYWJlbHMpO1xuICAgIHJldHVybiB2YWxpZEluZGV4KGluZGV4LCBsYWJlbHMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vcHRpb25zLm9mZnNldDtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGxldCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGxhYmVscyA9IChtaW4gPT09IDAgJiYgbWF4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluLCBtYXggKyAxKTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgobGFiZWxzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLm1pbiAtIChvZmZzZXQgPyAwLjUgOiAwKTtcbiAgICBmb3IgKGxldCB2YWx1ZSA9IG1pbjsgdmFsdWUgPD0gbWF4OyB2YWx1ZSsrKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZX0pO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPCBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbGFiZWxzW3ZhbHVlXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSAhdGhpcy5fcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gIH1cbn1cbkNhdGVnb3J5U2NhbGUuaWQgPSAnY2F0ZWdvcnknO1xuQ2F0ZWdvcnlTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogQ2F0ZWdvcnlTY2FsZS5wcm90b3R5cGUuZ2V0TGFiZWxGb3JWYWx1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzJDEoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBjb25zdCBNSU5fU1BBQ0lORyA9IDFlLTE0O1xuICBjb25zdCB7Ym91bmRzLCBzdGVwLCBtaW4sIG1heCwgcHJlY2lzaW9uLCBjb3VudCwgbWF4VGlja3MsIG1heERpZ2l0cywgaW5jbHVkZUJvdW5kc30gPSBnZW5lcmF0aW9uT3B0aW9ucztcbiAgY29uc3QgdW5pdCA9IHN0ZXAgfHwgMTtcbiAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xuICBjb25zdCB7bWluOiBybWluLCBtYXg6IHJtYXh9ID0gZGF0YVJhbmdlO1xuICBjb25zdCBtaW5EZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWluKTtcbiAgY29uc3QgbWF4RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1heCk7XG4gIGNvbnN0IGNvdW50RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKGNvdW50KTtcbiAgY29uc3QgbWluU3BhY2luZyA9IChybWF4IC0gcm1pbikgLyAobWF4RGlnaXRzICsgMSk7XG4gIGxldCBzcGFjaW5nID0gbmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICBsZXQgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG4gIGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgIW1pbkRlZmluZWQgJiYgIW1heERlZmluZWQpIHtcbiAgICByZXR1cm4gW3t2YWx1ZTogcm1pbn0sIHt2YWx1ZTogcm1heH1dO1xuICB9XG4gIG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcbiAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xuICAgIHNwYWNpbmcgPSBuaWNlTnVtKG51bVNwYWNlcyAqIHNwYWNpbmcgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIH1cbiAgaWYgKCFpc051bGxPclVuZGVmKHByZWNpc2lvbikpIHtcbiAgICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICB9XG4gIGlmIChib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICBuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICAgIG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgfSBlbHNlIHtcbiAgICBuaWNlTWluID0gcm1pbjtcbiAgICBuaWNlTWF4ID0gcm1heDtcbiAgfVxuICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkICYmIHN0ZXAgJiYgYWxtb3N0V2hvbGUoKG1heCAtIG1pbikgLyBzdGVwLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKE1hdGgubWluKChtYXggLSBtaW4pIC8gc3BhY2luZywgbWF4VGlja3MpKTtcbiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBudW1TcGFjZXM7XG4gICAgbmljZU1pbiA9IG1pbjtcbiAgICBuaWNlTWF4ID0gbWF4O1xuICB9IGVsc2UgaWYgKGNvdW50RGVmaW5lZCkge1xuICAgIG5pY2VNaW4gPSBtaW5EZWZpbmVkID8gbWluIDogbmljZU1pbjtcbiAgICBuaWNlTWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IG5pY2VNYXg7XG4gICAgbnVtU3BhY2VzID0gY291bnQgLSAxO1xuICAgIHNwYWNpbmcgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gbnVtU3BhY2VzO1xuICB9IGVsc2Uge1xuICAgIG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xuICAgIGlmIChhbG1vc3RFcXVhbHMobnVtU3BhY2VzLCBNYXRoLnJvdW5kKG51bVNwYWNlcyksIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLmNlaWwobnVtU3BhY2VzKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KFxuICAgIF9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpLFxuICAgIF9kZWNpbWFsUGxhY2VzKG5pY2VNaW4pXG4gICk7XG4gIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcbiAgbmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBsZXQgaiA9IDA7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgaWYgKGluY2x1ZGVCb3VuZHMgJiYgbmljZU1pbiAhPT0gbWluKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWlufSk7XG4gICAgICBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgICBpZiAoYWxtb3N0RXF1YWxzKE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yLCBtaW4sIHJlbGF0aXZlTGFiZWxTaXplKG1pbiwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICBqKys7XG4gICAgfVxuICB9XG4gIGZvciAoOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3J9KTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCAmJiBpbmNsdWRlQm91bmRzICYmIG5pY2VNYXggIT09IG1heCkge1xuICAgIGlmICh0aWNrcy5sZW5ndGggJiYgYWxtb3N0RXF1YWxzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlLCBtYXgsIHJlbGF0aXZlTGFiZWxTaXplKG1heCwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtYXh9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIW1heERlZmluZWQgfHwgbmljZU1heCA9PT0gbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IG5pY2VNYXh9KTtcbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiByZWxhdGl2ZUxhYmVsU2l6ZSh2YWx1ZSwgbWluU3BhY2luZywge2hvcml6b250YWwsIG1pblJvdGF0aW9ufSkge1xuICBjb25zdCByYWQgPSB0b1JhZGlhbnMobWluUm90YXRpb24pO1xuICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4ocmFkKSA6IE1hdGguY29zKHJhZCkpIHx8IDAuMDAxO1xuICBjb25zdCBsZW5ndGggPSAwLjc1ICogbWluU3BhY2luZyAqICgnJyArIHZhbHVlKS5sZW5ndGg7XG4gIHJldHVybiBNYXRoLm1pbihtaW5TcGFjaW5nIC8gcmF0aW8sIGxlbmd0aCk7XG59XG5jbGFzcyBMaW5lYXJTY2FsZUJhc2UgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VuZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgcmF3ID09PSAnbnVtYmVyJyB8fCByYXcgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrcmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiArcmF3O1xuICB9XG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcbiAgICBpZiAoYmVnaW5BdFplcm8pIHtcbiAgICAgIGNvbnN0IG1pblNpZ24gPSBzaWduKG1pbik7XG4gICAgICBjb25zdCBtYXhTaWduID0gc2lnbihtYXgpO1xuICAgICAgaWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG4gICAgICAgIHNldE1heCgwKTtcbiAgICAgIH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcbiAgICAgICAgc2V0TWluKDApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGxldCBvZmZzZXQgPSAxO1xuICAgICAgaWYgKG1heCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBtaW4gPD0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5hYnMobWF4ICogMC4wNSk7XG4gICAgICB9XG4gICAgICBzZXRNYXgobWF4ICsgb2Zmc2V0KTtcbiAgICAgIGlmICghYmVnaW5BdFplcm8pIHtcbiAgICAgICAgc2V0TWluKG1pbiAtIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBsZXQge21heFRpY2tzTGltaXQsIHN0ZXBTaXplfSA9IHRpY2tPcHRzO1xuICAgIGxldCBtYXhUaWNrcztcbiAgICBpZiAoc3RlcFNpemUpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5jZWlsKHRoaXMubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHN0ZXBTaXplKSArIDE7XG4gICAgICBpZiAobWF4VGlja3MgPiAxMDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xuICAgICAgICBtYXhUaWNrcyA9IDEwMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFRpY2tzID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICB9XG4gICAgaWYgKG1heFRpY2tzTGltaXQpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4VGlja3M7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgbGV0IG1heFRpY2tzID0gdGhpcy5nZXRUaWNrTGltaXQoKTtcbiAgICBtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcbiAgICBjb25zdCBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgIG1heFRpY2tzLFxuICAgICAgYm91bmRzOiBvcHRzLmJvdW5kcyxcbiAgICAgIG1pbjogb3B0cy5taW4sXG4gICAgICBtYXg6IG9wdHMubWF4LFxuICAgICAgcHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG4gICAgICBzdGVwOiB0aWNrT3B0cy5zdGVwU2l6ZSxcbiAgICAgIGNvdW50OiB0aWNrT3B0cy5jb3VudCxcbiAgICAgIG1heERpZ2l0czogdGhpcy5fbWF4RGlnaXRzKCksXG4gICAgICBob3Jpem9udGFsOiB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgbWluUm90YXRpb246IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDAsXG4gICAgICBpbmNsdWRlQm91bmRzOiB0aWNrT3B0cy5pbmNsdWRlQm91bmRzICE9PSBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgZGF0YVJhbmdlID0gdGhpcy5fcmFuZ2UgfHwgdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MkMShudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgZGF0YVJhbmdlKTtcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGxldCBzdGFydCA9IHRoaXMubWluO1xuICAgIGxldCBlbmQgPSB0aGlzLm1heDtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChlbmQgLSBzdGFydCkgLyBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAxLCAxKSAvIDI7XG4gICAgICBzdGFydCAtPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gc3RhcnQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSBlbmQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGVuZCAtIHN0YXJ0O1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxufVxuXG5jbGFzcyBMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpID8gbWF4IDogMTtcbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhvcml6b250YWwgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4obWluUm90YXRpb24pIDogTWF0aC5jb3MobWluUm90YXRpb24pKSB8fCAwLjAwMTtcbiAgICBjb25zdCB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGggLyBNYXRoLm1pbig0MCwgdGlja0ZvbnQubGluZUhlaWdodCAvIHJhdGlvKSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgfVxufVxuTGluZWFyU2NhbGUuaWQgPSAnbGluZWFyJztcbkxpbmVhclNjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNNYWpvcih0aWNrVmFsKSB7XG4gIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWwgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbCkpKSk7XG4gIHJldHVybiByZW1haW4gPT09IDE7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgZW5kRXhwID0gTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWF4KSk7XG4gIGNvbnN0IGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGxldCB0aWNrVmFsID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1pbikpKSk7XG4gIGxldCBleHAgPSBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKTtcbiAgbGV0IHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcih0aWNrVmFsIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuICBsZXQgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG4gIGRvIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogdGlja1ZhbCwgbWFqb3I6IGlzTWFqb3IodGlja1ZhbCl9KTtcbiAgICArK3NpZ25pZmljYW5kO1xuICAgIGlmIChzaWduaWZpY2FuZCA9PT0gMTApIHtcbiAgICAgIHNpZ25pZmljYW5kID0gMTtcbiAgICAgICsrZXhwO1xuICAgICAgcHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xuICAgIH1cbiAgICB0aWNrVmFsID0gTWF0aC5yb3VuZChzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgfSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XG4gIGNvbnN0IGxhc3RUaWNrID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1heCwgdGlja1ZhbCk7XG4gIHRpY2tzLnB1c2goe3ZhbHVlOiBsYXN0VGljaywgbWFqb3I6IGlzTWFqb3IodGlja1ZhbCl9KTtcbiAgcmV0dXJuIHRpY2tzO1xufVxuY2xhc3MgTG9nYXJpdGhtaWNTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGNvbnN0IHZhbHVlID0gTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBbcmF3LCBpbmRleF0pO1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpICYmIHZhbHVlID4gMCA/IHZhbHVlIDogbnVsbDtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgPyBNYXRoLm1heCgwLCBtaW4pIDogbnVsbDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJlZ2luQXRaZXJvKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgbWluID0gdGhpcy5taW47XG4gICAgbGV0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG4gICAgY29uc3QgZXhwID0gKHYsIG0pID0+IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHYpKSArIG0pO1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICAgIHNldE1pbigxKTtcbiAgICAgICAgc2V0TWF4KDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1pbihleHAobWluLCAtMSkpO1xuICAgICAgICBzZXRNYXgoZXhwKG1heCwgKzEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICBzZXRNaW4oZXhwKG1heCwgLTEpKTtcbiAgICB9XG4gICAgaWYgKG1heCA8PSAwKSB7XG4gICAgICBzZXRNYXgoZXhwKG1pbiwgKzEpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3plcm8gJiYgdGhpcy5taW4gIT09IHRoaXMuX3N1Z2dlc3RlZE1pbiAmJiBtaW4gPT09IGV4cCh0aGlzLm1pbiwgMCkpIHtcbiAgICAgIHNldE1pbihleHAobWluLCAtMSkpO1xuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBtaW46IHRoaXMuX3VzZXJNaW4sXG4gICAgICBtYXg6IHRoaXMuX3VzZXJNYXhcbiAgICB9O1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgdGhpcyk7XG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICcwJ1xuICAgICAgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMubWluO1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGxvZzEwKHRoaXMubWF4KSAtIGxvZzEwKHN0YXJ0KTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHZhbHVlID0gdGhpcy5taW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCh2YWx1ZSA9PT0gdGhpcy5taW5cbiAgICAgID8gMFxuICAgICAgOiAobG9nMTAodmFsdWUpIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKTtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXJ0VmFsdWUgKyBkZWNpbWFsICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbn1cbkxvZ2FyaXRobWljU2NhbGUuaWQgPSAnbG9nYXJpdGhtaWMnO1xuTG9nYXJpdGhtaWNTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcbiAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnQgJiYgdGlja09wdHMuZm9udC5zaXplLCBkZWZhdWx0cy5mb250LnNpemUpICsgcGFkZGluZy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgZm9udCwgbGFiZWwpIHtcbiAgbGFiZWwgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsIDogW2xhYmVsXTtcbiAgcmV0dXJuIHtcbiAgICB3OiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LnN0cmluZywgbGFiZWwpLFxuICAgIGg6IGxhYmVsLmxlbmd0aCAqIGZvbnQubGluZUhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG4gIGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG4gICAgICBlbmQ6IHBvcyArIChzaXplIC8gMilcbiAgICB9O1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSBzaXplLFxuICAgICAgZW5kOiBwb3NcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHBvcyxcbiAgICBlbmQ6IHBvcyArIHNpemVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuICBjb25zdCBvcmlnID0ge1xuICAgIGw6IHNjYWxlLmxlZnQgKyBzY2FsZS5fcGFkZGluZy5sZWZ0LFxuICAgIHI6IHNjYWxlLnJpZ2h0IC0gc2NhbGUuX3BhZGRpbmcucmlnaHQsXG4gICAgdDogc2NhbGUudG9wICsgc2NhbGUuX3BhZGRpbmcudG9wLFxuICAgIGI6IHNjYWxlLmJvdHRvbSAtIHNjYWxlLl9wYWRkaW5nLmJvdHRvbVxuICB9O1xuICBjb25zdCBsaW1pdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnKTtcbiAgY29uc3QgbGFiZWxTaXplcyA9IFtdO1xuICBjb25zdCBwYWRkaW5nID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBwb2ludExhYmVsT3B0cyA9IHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IHBvaW50TGFiZWxPcHRzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBvcHRzID0gcG9pbnRMYWJlbE9wdHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgcGFkZGluZ1tpXSA9IG9wdHMucGFkZGluZztcbiAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBzY2FsZS5kcmF3aW5nQXJlYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LCBzY2FsZS5fcG9pbnRMYWJlbHNbaV0pO1xuICAgIGxhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcbiAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBfbm9ybWFsaXplQW5nbGUoc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSArIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhhbmdsZVJhZGlhbnMpKTtcbiAgICBjb25zdCBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG4gICAgY29uc3QgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcbiAgICB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZVJhZGlhbnMsIGhMaW1pdHMsIHZMaW1pdHMpO1xuICB9XG4gIHNjYWxlLnNldENlbnRlclBvaW50KFxuICAgIG9yaWcubCAtIGxpbWl0cy5sLFxuICAgIGxpbWl0cy5yIC0gb3JpZy5yLFxuICAgIG9yaWcudCAtIGxpbWl0cy50LFxuICAgIGxpbWl0cy5iIC0gb3JpZy5iXG4gICk7XG4gIHNjYWxlLl9wb2ludExhYmVsSXRlbXMgPSBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZyk7XG59XG5mdW5jdGlvbiB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZSwgaExpbWl0cywgdkxpbWl0cykge1xuICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpO1xuICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKGhMaW1pdHMuc3RhcnQgPCBvcmlnLmwpIHtcbiAgICB4ID0gKG9yaWcubCAtIGhMaW1pdHMuc3RhcnQpIC8gc2luO1xuICAgIGxpbWl0cy5sID0gTWF0aC5taW4obGltaXRzLmwsIG9yaWcubCAtIHgpO1xuICB9IGVsc2UgaWYgKGhMaW1pdHMuZW5kID4gb3JpZy5yKSB7XG4gICAgeCA9IChoTGltaXRzLmVuZCAtIG9yaWcucikgLyBzaW47XG4gICAgbGltaXRzLnIgPSBNYXRoLm1heChsaW1pdHMuciwgb3JpZy5yICsgeCk7XG4gIH1cbiAgaWYgKHZMaW1pdHMuc3RhcnQgPCBvcmlnLnQpIHtcbiAgICB5ID0gKG9yaWcudCAtIHZMaW1pdHMuc3RhcnQpIC8gY29zO1xuICAgIGxpbWl0cy50ID0gTWF0aC5taW4obGltaXRzLnQsIG9yaWcudCAtIHkpO1xuICB9IGVsc2UgaWYgKHZMaW1pdHMuZW5kID4gb3JpZy5iKSB7XG4gICAgeSA9ICh2TGltaXRzLmVuZCAtIG9yaWcuYikgLyBjb3M7XG4gICAgbGltaXRzLmIgPSBNYXRoLm1heChsaW1pdHMuYiwgb3JpZy5iICsgeSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgZXh0cmEgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykgLyAyO1xuICBjb25zdCBvdXRlckRpc3RhbmNlID0gc2NhbGUuZHJhd2luZ0FyZWE7XG4gIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IG9wdHMucG9pbnRMYWJlbHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKF9ub3JtYWxpemVBbmdsZShwb2ludExhYmVsUG9zaXRpb24uYW5nbGUgKyBIQUxGX1BJKSkpO1xuICAgIGNvbnN0IHNpemUgPSBsYWJlbFNpemVzW2ldO1xuICAgIGNvbnN0IHkgPSB5Rm9yQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLnksIHNpemUuaCwgYW5nbGUpO1xuICAgIGNvbnN0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcbiAgICBjb25zdCBsZWZ0ID0gbGVmdEZvclRleHRBbGlnbihwb2ludExhYmVsUG9zaXRpb24ueCwgc2l6ZS53LCB0ZXh0QWxpZ24pO1xuICAgIGl0ZW1zLnB1c2goe1xuICAgICAgeDogcG9pbnRMYWJlbFBvc2l0aW9uLngsXG4gICAgICB5LFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgbGVmdCxcbiAgICAgIHRvcDogeSxcbiAgICAgIHJpZ2h0OiBsZWZ0ICsgc2l6ZS53LFxuICAgICAgYm90dG9tOiB5ICsgc2l6ZS5oXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcbiAgICByZXR1cm4gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9XG4gIHJldHVybiAncmlnaHQnO1xufVxuZnVuY3Rpb24gbGVmdEZvclRleHRBbGlnbih4LCB3LCBhbGlnbikge1xuICBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHc7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAodyAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24geUZvckFuZ2xlKHksIGgsIGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuICAgIHkgLT0gKGggLyAyKTtcbiAgfSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG4gICAgeSAtPSBoO1xuICB9XG4gIHJldHVybiB5O1xufVxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxzKHNjYWxlLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb2ludExhYmVsc319ID0gc2NhbGU7XG4gIGZvciAobGV0IGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBvcHRzQXRJbmRleCA9IHBvaW50TGFiZWxzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICBjb25zdCB7eCwgeSwgdGV4dEFsaWduLCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gc2NhbGUuX3BvaW50TGFiZWxJdGVtc1tpXTtcbiAgICBjb25zdCB7YmFja2Ryb3BDb2xvcn0gPSBvcHRzQXRJbmRleDtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYmFja2Ryb3BDb2xvcikpIHtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMob3B0c0F0SW5kZXguYm9yZGVyUmFkaXVzKTtcbiAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcENvbG9yO1xuICAgICAgY29uc3QgYmFja2Ryb3BMZWZ0ID0gbGVmdCAtIHBhZGRpbmcubGVmdDtcbiAgICAgIGNvbnN0IGJhY2tkcm9wVG9wID0gdG9wIC0gcGFkZGluZy50b3A7XG4gICAgICBjb25zdCBiYWNrZHJvcFdpZHRoID0gcmlnaHQgLSBsZWZ0ICsgcGFkZGluZy53aWR0aDtcbiAgICAgIGNvbnN0IGJhY2tkcm9wSGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQ7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBiYWNrZHJvcExlZnQsXG4gICAgICAgICAgeTogYmFja2Ryb3BUb3AsXG4gICAgICAgICAgdzogYmFja2Ryb3BXaWR0aCxcbiAgICAgICAgICBoOiBiYWNrZHJvcEhlaWdodCxcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbFJlY3QoYmFja2Ryb3BMZWZ0LCBiYWNrZHJvcFRvcCwgYmFja2Ryb3BXaWR0aCwgYmFja2Ryb3BIZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHh9ID0gc2NhbGU7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcbiAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gZ3JpZExpbmVPcHRzO1xuICBpZiAoKCFjaXJjdWxhciAmJiAhbGFiZWxDb3VudCkgfHwgIWNvbG9yIHx8ICFsaW5lV2lkdGggfHwgcmFkaXVzIDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQ7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zdHJva2UoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGxhYmVsLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICdwb2ludExhYmVsJ1xuICB9KTtcbn1cbmNsYXNzIFJhZGlhbExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnhDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpIC8gMik7XG4gICAgY29uc3QgdyA9IHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoIC0gcGFkZGluZy53aWR0aDtcbiAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0O1xuICAgIHRoaXMueENlbnRlciA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgdyAvIDIgKyBwYWRkaW5nLmxlZnQpO1xuICAgIHRoaXMueUNlbnRlciA9IE1hdGguZmxvb3IodGhpcy50b3AgKyBoIC8gMiArIHBhZGRpbmcudG9wKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gTWF0aC5mbG9vcihNYXRoLm1pbih3LCBoKSAvIDIpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KGZhbHNlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6IDA7XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbCh0aGlzLCB0aWNrcyk7XG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSB0aGlzLmdldExhYmVscygpXG4gICAgICAubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjYWxsYmFjayh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFt2YWx1ZSwgaW5kZXhdLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKCh2LCBpKSA9PiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZml0V2l0aFBvaW50TGFiZWxzKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuICAgIH1cbiAgfVxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKChsZWZ0TW92ZW1lbnQgLSByaWdodE1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMueUNlbnRlciArPSBNYXRoLmZsb29yKCh0b3BNb3ZlbWVudCAtIGJvdHRvbU1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XG4gIH1cbiAgZ2V0SW5kZXhBbmdsZShpbmRleCkge1xuICAgIGNvbnN0IGFuZ2xlTXVsdGlwbGllciA9IFRBVSAvICh0aGlzLl9wb2ludExhYmVscy5sZW5ndGggfHwgMSk7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG4gICAgcmV0dXJuIF9ub3JtYWxpemVBbmdsZShpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHRvUmFkaWFucyhzdGFydEFuZ2xlKSk7XG4gIH1cbiAgZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSB0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuICB9XG4gIGdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyKGRpc3RhbmNlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYoZGlzdGFuY2UpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZWREaXN0YW5jZSA9IGRpc3RhbmNlIC8gKHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IHRoaXMubWF4IC0gc2NhbGVkRGlzdGFuY2UgOiB0aGlzLm1pbiArIHNjYWxlZERpc3RhbmNlO1xuICB9XG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbHMgPSB0aGlzLl9wb2ludExhYmVscyB8fCBbXTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHBvaW50TGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcG9pbnRMYWJlbCA9IHBvaW50TGFiZWxzW2luZGV4XTtcbiAgICAgIHJldHVybiBjcmVhdGVQb2ludExhYmVsQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHBvaW50TGFiZWwpO1xuICAgIH1cbiAgfVxuICBnZXRQb2ludFBvc2l0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIsIGFkZGl0aW9uYWxBbmdsZSA9IDApIHtcbiAgICBjb25zdCBhbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSBIQUxGX1BJICsgYWRkaXRpb25hbEFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnhDZW50ZXIsXG4gICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnlDZW50ZXIsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbiAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcbiAgfVxuICBnZXRCYXNlUG9zaXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXggfHwgMCwgdGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0UG9pbnRMYWJlbFBvc2l0aW9uKGluZGV4KSB7XG4gICAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSB0aGlzLl9wb2ludExhYmVsSXRlbXNbaW5kZXhdO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgfTtcbiAgfVxuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7YmFja2dyb3VuZENvbG9yLCBncmlkOiB7Y2lyY3VsYXJ9fSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBwYXRoUmFkaXVzTGluZSh0aGlzLCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuX2VuZFZhbHVlKSwgY2lyY3VsYXIsIHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGRyYXdHcmlkKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2FuZ2xlTGluZXMsIGdyaWR9ID0gb3B0cztcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICAgIGxldCBpLCBvZmZzZXQsIHBvc2l0aW9uO1xuICAgIGlmIChvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGRyYXdQb2ludExhYmVscyh0aGlzLCBsYWJlbENvdW50KTtcbiAgICB9XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCAtIDEpKTtcbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBmb3IgKGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBhbmdsZUxpbmVzLnNldENvbnRleHQodGhpcy5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgICAgIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IG9wdHNBdEluZGV4O1xuICAgICAgICBpZiAoIWxpbmVXaWR0aCB8fCAhY29sb3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKG9wdHNBdEluZGV4LmJvcmRlckRhc2gpO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMudGlja3MucmV2ZXJzZSA/IHRoaXMubWluIDogdGhpcy5tYXgpO1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpLCBvZmZzZXQpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3Qm9yZGVyKCkge31cbiAgZHJhd0xhYmVscygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICBpZiAoIXRpY2tPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcbiAgICBsZXQgb2Zmc2V0LCB3aWR0aDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgIGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPT09IDAgJiYgIW9wdHMucmV2ZXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IHRpY2tPcHRzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICBjb25zdCB0aWNrRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy50aWNrc1tpbmRleF0udmFsdWUpO1xuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aWNrLmxhYmVsKS53aWR0aDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3I7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgLW9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gcGFkZGluZy50b3AsXG4gICAgICAgICAgd2lkdGggKyBwYWRkaW5nLndpZHRoLFxuICAgICAgICAgIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVuZGVyVGV4dChjdHgsIHRpY2subGFiZWwsIDAsIC1vZmZzZXQsIHRpY2tGb250LCB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd1RpdGxlKCkge31cbn1cblJhZGlhbExpbmVhclNjYWxlLmlkID0gJ3JhZGlhbExpbmVhcic7XG5SYWRpYWxMaW5lYXJTY2FsZS5kZWZhdWx0cyA9IHtcbiAgZGlzcGxheTogdHJ1ZSxcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgcG9zaXRpb246ICdjaGFydEFyZWEnLFxuICBhbmdsZUxpbmVzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBsaW5lV2lkdGg6IDEsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMC4wXG4gIH0sXG4gIGdyaWQ6IHtcbiAgICBjaXJjdWxhcjogZmFsc2VcbiAgfSxcbiAgc3RhcnRBbmdsZTogMCxcbiAgdGlja3M6IHtcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gIH0sXG4gIHBvaW50TGFiZWxzOiB7XG4gICAgYmFja2Ryb3BDb2xvcjogdW5kZWZpbmVkLFxuICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHNpemU6IDEwXG4gICAgfSxcbiAgICBjYWxsYmFjayhsYWJlbCkge1xuICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH0sXG4gICAgcGFkZGluZzogNSxcbiAgICBjZW50ZXJQb2ludExhYmVsczogZmFsc2VcbiAgfVxufTtcblJhZGlhbExpbmVhclNjYWxlLmRlZmF1bHRSb3V0ZXMgPSB7XG4gICdhbmdsZUxpbmVzLmNvbG9yJzogJ2JvcmRlckNvbG9yJyxcbiAgJ3BvaW50TGFiZWxzLmNvbG9yJzogJ2NvbG9yJyxcbiAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xufTtcblJhZGlhbExpbmVhclNjYWxlLmRlc2NyaXB0b3JzID0ge1xuICBhbmdsZUxpbmVzOiB7XG4gICAgX2ZhbGxiYWNrOiAnZ3JpZCdcbiAgfVxufTtcblxuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcbmNvbnN0IFVOSVRTID0gKE9iamVjdC5rZXlzKElOVEVSVkFMUykpO1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3Qge3BhcnNlciwgcm91bmQsIGlzb1dlZWtkYXl9ID0gc2NhbGUuX3BhcnNlT3B0cztcbiAgbGV0IHZhbHVlID0gaW5wdXQ7XG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG4gIGlmICghaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCBwYXJzZXIpXG4gICAgICA6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyb3VuZCkge1xuICAgIHZhbHVlID0gcm91bmQgPT09ICd3ZWVrJyAmJiAoaXNOdW1iZXIoaXNvV2Vla2RheSkgfHwgaXNvV2Vla2RheSA9PT0gdHJ1ZSlcbiAgICAgID8gYWRhcHRlci5zdGFydE9mKHZhbHVlLCAnaXNvV2VlaycsIGlzb1dlZWtkYXkpXG4gICAgICA6IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgcm91bmQpO1xuICB9XG4gIHJldHVybiArdmFsdWU7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICBjb25zdCBpbGVuID0gVU5JVFMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcbiAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgaWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgY29uc3Qge2xvLCBoaX0gPSBfbG9va3VwKHRpbWVzdGFtcHMsIHRpbWUpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbbG9dID49IHRpbWUgPyB0aW1lc3RhbXBzW2xvXSA6IHRpbWVzdGFtcHNbaGldO1xuICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XG4gIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgbGV0IG1ham9yLCBpbmRleDtcbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgbWFwID0ge307XG4gIGNvbnN0IGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICBsZXQgaSwgdmFsdWU7XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBtYXBbdmFsdWVdID0gaTtcbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIChpbGVuID09PSAwIHx8ICFtYWpvclVuaXQpID8gdGlja3MgOiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpO1xufVxuY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICAgIHRoaXMuX3VuaXQgPSAnZGF5JztcbiAgICB0aGlzLl9tYWpvclVuaXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHt9O1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMpIHtcbiAgICBjb25zdCB0aW1lID0gc2NhbGVPcHRzLnRpbWUgfHwgKHNjYWxlT3B0cy50aW1lID0ge30pO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyID0gbmV3IF9hZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG4gICAgYWRhcHRlci5pbml0KG9wdHMpO1xuICAgIG1lcmdlSWYodGltZS5kaXNwbGF5Rm9ybWF0cywgYWRhcHRlci5mb3JtYXRzKCkpO1xuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgIHBhcnNlcjogdGltZS5wYXJzZXIsXG4gICAgICByb3VuZDogdGltZS5yb3VuZCxcbiAgICAgIGlzb1dlZWtkYXk6IHRpbWUuaXNvV2Vla2RheVxuICAgIH07XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdHMpO1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBvcHRzLm5vcm1hbGl6ZWQ7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChyYXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZSh0aGlzLCByYXcpO1xuICB9XG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICBzdXBlci5iZWZvcmVMYXlvdXQoKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB1bml0ID0gb3B0aW9ucy50aW1lLnVuaXQgfHwgJ2RheSc7XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBmdW5jdGlvbiBfYXBwbHlCb3VuZHMoYm91bmRzKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5taW4pKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgYm91bmRzLm1heCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWluRGVmaW5lZCB8fCAhbWF4RGVmaW5lZCkge1xuICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuX2dldExhYmVsQm91bmRzKCkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm91bmRzICE9PSAndGlja3MnIHx8IG9wdGlvbnMudGlja3Muc291cmNlICE9PSAnbGFiZWxzJykge1xuICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWluID0gaXNOdW1iZXJGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6ICthZGFwdGVyLnN0YXJ0T2YoRGF0ZS5ub3coKSwgdW5pdCk7XG4gICAgbWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6ICthZGFwdGVyLmVuZE9mKERhdGUubm93KCksIHVuaXQpICsgMTtcbiAgICB0aGlzLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4IC0gMSk7XG4gICAgdGhpcy5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuICB9XG4gIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBpZiAoYXJyLmxlbmd0aCkge1xuICAgICAgbWluID0gYXJyWzBdO1xuICAgICAgbWF4ID0gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHttaW4sIG1heH07XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGlja09wdHMuc291cmNlID09PSAnbGFiZWxzJyA/IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiB0aGlzLl9nZW5lcmF0ZSgpO1xuICAgIGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IHRpbWVzdGFtcHNbMF07XG4gICAgICB0aGlzLm1heCA9IHRoaXMuX3VzZXJNYXggfHwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCB0aWNrcyA9IF9maWx0ZXJCZXR3ZWVuKHRpbWVzdGFtcHMsIG1pbiwgbWF4KTtcbiAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcbiAgICAgID8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSlcbiAgICAgIDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcodGhpcywgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgpKTtcbiAgICB0aGlzLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCB0aGlzLl91bml0ID09PSAneWVhcicgPyB1bmRlZmluZWRcbiAgICAgIDogZGV0ZXJtaW5lTWFqb3JVbml0KHRoaXMuX3VuaXQpO1xuICAgIHRoaXMuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCB0aWNrcywgdGhpcy5fbWFqb3JVbml0KTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCkge1xuICAgICAgdGhpcy5pbml0T2Zmc2V0cyh0aGlzLnRpY2tzLm1hcCh0aWNrID0+ICt0aWNrLnZhbHVlKSk7XG4gICAgfVxuICB9XG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMpIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGxldCBmaXJzdCwgbGFzdDtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IDEgLSBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gKHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMV0pIC0gZmlyc3QpIC8gMjtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSAobGFzdCAtIHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB0aW1lc3RhbXBzLmxlbmd0aCA8IDMgPyAwLjUgOiAwLjI1O1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIGxpbWl0KTtcbiAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcbiAgICB0aGlzLl9vZmZzZXRzID0ge3N0YXJ0LCBlbmQsIGZhY3RvcjogMSAvIChzdGFydCArIDEgKyBlbmQpfTtcbiAgfVxuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKTtcbiAgICBjb25zdCBzdGVwU2l6ZSA9IHZhbHVlT3JEZWZhdWx0KHRpbWVPcHRzLnN0ZXBTaXplLCAxKTtcbiAgICBjb25zdCB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcbiAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcbiAgICBjb25zdCB0aWNrcyA9IHt9O1xuICAgIGxldCBmaXJzdCA9IG1pbjtcbiAgICBsZXQgdGltZSwgY291bnQ7XG4gICAgaWYgKGhhc1dlZWtkYXkpIHtcbiAgICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcbiAgICB9XG4gICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCBoYXNXZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG4gICAgaWYgKGFkYXB0ZXIuZGlmZihtYXgsIG1pbiwgbWlub3IpID4gMTAwMDAwICogc3RlcFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtaW4gKyAnIGFuZCAnICsgbWF4ICsgJyBhcmUgdG9vIGZhciBhcGFydCB3aXRoIHN0ZXBTaXplIG9mICcgKyBzdGVwU2l6ZSArICcgJyArIG1pbm9yKTtcbiAgICB9XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IG9wdGlvbnMudGlja3Muc291cmNlID09PSAnZGF0YScgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGZvciAodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKykge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoKGEsIGIpID0+IGEgLSBiKS5tYXAoeCA9PiAreCk7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgbWFqb3JVbml0ID0gdGhpcy5fbWFqb3JVbml0O1xuICAgIGNvbnN0IG1pbm9yRm9ybWF0ID0gdW5pdCAmJiBmb3JtYXRzW3VuaXRdO1xuICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgIGNvbnN0IG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCB8fCAobWFqb3IgPyBtYWpvckZvcm1hdCA6IG1pbm9yRm9ybWF0KSk7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gb3B0aW9ucy50aWNrcy5jYWxsYmFjaztcbiAgICByZXR1cm4gZm9ybWF0dGVyID8gY2FsbGJhY2soZm9ybWF0dGVyLCBbbGFiZWwsIGluZGV4LCB0aWNrc10sIHRoaXMpIDogbGFiZWw7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XG4gICAgfVxuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgob2Zmc2V0cy5zdGFydCArIHBvcykgKiBvZmZzZXRzLmZhY3Rvcik7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIHRoaXMubWluICsgcG9zICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG4gIF9nZXRMYWJlbFNpemUobGFiZWwpIHtcbiAgICBjb25zdCB0aWNrc09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGlja0xhYmVsV2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgY29uc3QgYW5nbGUgPSB0b1JhZGlhbnModGhpcy5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgdGlja0ZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxuICAgICAgaDogKHRpY2tMYWJlbFdpZHRoICogc2luUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uKVxuICAgIH07XG4gIH1cbiAgX2dldExhYmVsQ2FwYWNpdHkoZXhhbXBsZVRpbWUpIHtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIFtleGFtcGxlVGltZV0sIHRoaXMuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIGNvbnN0IGNhcGFjaXR5ID0gTWF0aC5mbG9vcih0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCAvIHNpemUudyA6IHRoaXMuaGVpZ2h0IC8gc2l6ZS5oKSAtIDE7XG4gICAgcmV0dXJuIGNhcGFjaXR5ID4gMCA/IGNhcGFjaXR5IDogMTtcbiAgfVxuICBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmRhdGEgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbWV0YXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSBtZXRhc1swXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuICBnZXRMYWJlbFRpbWVzdGFtcHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fY2FjaGUubGFiZWxzID0gdGhpcy5fbm9ybWFsaXplZCA/IHRpbWVzdGFtcHMgOiB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cbiAgbm9ybWFsaXplKHZhbHVlcykge1xuICAgIHJldHVybiBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoc29ydGVyKSk7XG4gIH1cbn1cblRpbWVTY2FsZS5pZCA9ICd0aW1lJztcblRpbWVTY2FsZS5kZWZhdWx0cyA9IHtcbiAgYm91bmRzOiAnZGF0YScsXG4gIGFkYXB0ZXJzOiB7fSxcbiAgdGltZToge1xuICAgIHBhcnNlcjogZmFsc2UsXG4gICAgdW5pdDogZmFsc2UsXG4gICAgcm91bmQ6IGZhbHNlLFxuICAgIGlzb1dlZWtkYXk6IGZhbHNlLFxuICAgIG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG4gICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgc291cmNlOiAnYXV0bycsXG4gICAgbWFqb3I6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0YWJsZSwgdmFsLCByZXZlcnNlKSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2U291cmNlLCBuZXh0U291cmNlLCBwcmV2VGFyZ2V0LCBuZXh0VGFyZ2V0O1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnBvcyAmJiB2YWwgPD0gdGFibGVbaGldLnBvcykge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgfVxuICAgICh7cG9zOiBwcmV2U291cmNlLCB0aW1lOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHtwb3M6IG5leHRTb3VyY2UsIHRpbWU6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS50aW1lICYmIHZhbCA8PSB0YWJsZVtoaV0udGltZSkge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgIH1cbiAgICAoe3RpbWU6IHByZXZTb3VyY2UsIHBvczogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7dGltZTogbmV4dFNvdXJjZSwgcG9zOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH1cbiAgY29uc3Qgc3BhbiA9IG5leHRTb3VyY2UgLSBwcmV2U291cmNlO1xuICByZXR1cm4gc3BhbiA/IHByZXZUYXJnZXQgKyAobmV4dFRhcmdldCAtIHByZXZUYXJnZXQpICogKHZhbCAtIHByZXZTb3VyY2UpIC8gc3BhbiA6IHByZXZUYXJnZXQ7XG59XG5jbGFzcyBUaW1lU2VyaWVzU2NhbGUgZXh0ZW5kcyBUaW1lU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl90YWJsZSA9IFtdO1xuICAgIHRoaXMuX21pblBvcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRPZmZzZXRzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKTtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xuICAgIHRoaXMuX21pblBvcyA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1pbik7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1heCkgLSB0aGlzLl9taW5Qb3M7XG4gICAgc3VwZXIuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gIH1cbiAgYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCB0YWJsZSA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY3VyciA9IHRpbWVzdGFtcHNbaV07XG4gICAgICBpZiAoY3VyciA+PSBtaW4gJiYgY3VyciA8PSBtYXgpIHtcbiAgICAgICAgaXRlbXMucHVzaChjdXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt0aW1lOiBtaW4sIHBvczogMH0sXG4gICAgICAgIHt0aW1lOiBtYXgsIHBvczogMX1cbiAgICAgIF07XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgIHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG4gIF9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICYmIGxhYmVsLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wcyA9IHRoaXMubm9ybWFsaXplKGRhdGEuY29uY2F0KGxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICB9XG4gICAgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCA9IHRpbWVzdGFtcHM7XG4gICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgdmFsdWUpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgZGVjaW1hbCAqIHRoaXMuX3RhYmxlUmFuZ2UgKyB0aGlzLl9taW5Qb3MsIHRydWUpO1xuICB9XG59XG5UaW1lU2VyaWVzU2NhbGUuaWQgPSAndGltZXNlcmllcyc7XG5UaW1lU2VyaWVzU2NhbGUuZGVmYXVsdHMgPSBUaW1lU2NhbGUuZGVmYXVsdHM7XG5cbnZhciBzY2FsZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5DYXRlZ29yeVNjYWxlOiBDYXRlZ29yeVNjYWxlLFxuTGluZWFyU2NhbGU6IExpbmVhclNjYWxlLFxuTG9nYXJpdGhtaWNTY2FsZTogTG9nYXJpdGhtaWNTY2FsZSxcblJhZGlhbExpbmVhclNjYWxlOiBSYWRpYWxMaW5lYXJTY2FsZSxcblRpbWVTY2FsZTogVGltZVNjYWxlLFxuVGltZVNlcmllc1NjYWxlOiBUaW1lU2VyaWVzU2NhbGVcbn0pO1xuXG5DaGFydC5yZWdpc3Rlcihjb250cm9sbGVycywgc2NhbGVzLCBlbGVtZW50cywgcGx1Z2lucyk7XG5DaGFydC5oZWxwZXJzID0gey4uLmhlbHBlcnN9O1xuQ2hhcnQuX2FkYXB0ZXJzID0gX2FkYXB0ZXJzO1xuQ2hhcnQuQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xuQ2hhcnQuQW5pbWF0aW9ucyA9IEFuaW1hdGlvbnM7XG5DaGFydC5hbmltYXRvciA9IGFuaW1hdG9yO1xuQ2hhcnQuY29udHJvbGxlcnMgPSByZWdpc3RyeS5jb250cm9sbGVycy5pdGVtcztcbkNoYXJ0LkRhdGFzZXRDb250cm9sbGVyID0gRGF0YXNldENvbnRyb2xsZXI7XG5DaGFydC5FbGVtZW50ID0gRWxlbWVudDtcbkNoYXJ0LmVsZW1lbnRzID0gZWxlbWVudHM7XG5DaGFydC5JbnRlcmFjdGlvbiA9IEludGVyYWN0aW9uO1xuQ2hhcnQubGF5b3V0cyA9IGxheW91dHM7XG5DaGFydC5wbGF0Zm9ybXMgPSBwbGF0Zm9ybXM7XG5DaGFydC5TY2FsZSA9IFNjYWxlO1xuQ2hhcnQuVGlja3MgPSBUaWNrcztcbk9iamVjdC5hc3NpZ24oQ2hhcnQsIGNvbnRyb2xsZXJzLCBzY2FsZXMsIGVsZW1lbnRzLCBwbHVnaW5zLCBwbGF0Zm9ybXMpO1xuQ2hhcnQuQ2hhcnQgPSBDaGFydDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuQ2hhcnQgPSBDaGFydDtcbn1cblxucmV0dXJuIENoYXJ0O1xuXG59KSk7XG4iLCAibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLicpLmhlbHBlcnM7XG4iLCAiLyohXG4gKiBjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzIHYyLjIuMFxuICogaHR0cHM6Ly9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzLm5ldGxpZnkuYXBwXG4gKiAoYykgMjAxNy0yMDIyIGNoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdjaGFydC5qcy9oZWxwZXJzJyksIHJlcXVpcmUoJ2NoYXJ0LmpzJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2NoYXJ0LmpzL2hlbHBlcnMnLCAnY2hhcnQuanMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkNoYXJ0RGF0YUxhYmVscyA9IGZhY3RvcnkoZ2xvYmFsLkNoYXJ0LmhlbHBlcnMsIGdsb2JhbC5DaGFydCkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChoZWxwZXJzLCBjaGFydF9qcykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBkZXZpY2VQaXhlbFJhdGlvID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICAvLyBkZXZpY2VQaXhlbFJhdGlvIGlzIHVuZGVmaW5lZCBvbiBJRTEwXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMjA0MTgwLzg4Mzc4ODdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy84NVxuICAgIHZhciBzY3JlZW4gPSB3aW5kb3cuc2NyZWVuO1xuICAgIGlmIChzY3JlZW4pIHtcbiAgICAgIHJldHVybiAoc2NyZWVuLmRldmljZVhEUEkgfHwgMSkgLyAoc2NyZWVuLmxvZ2ljYWxYRFBJIHx8IDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAxO1xufSgpKTtcblxudmFyIHV0aWxzID0ge1xuICAvLyBAdG9kbyBtb3ZlIHRoaXMgaW4gQ2hhcnQuaGVscGVycy50b1RleHRMaW5lc1xuICB0b1RleHRMaW5lczogZnVuY3Rpb24oaW5wdXRzKSB7XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgdmFyIGlucHV0O1xuXG4gICAgaW5wdXRzID0gW10uY29uY2F0KGlucHV0cyk7XG4gICAgd2hpbGUgKGlucHV0cy5sZW5ndGgpIHtcbiAgICAgIGlucHV0ID0gaW5wdXRzLnBvcCgpO1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGluZXMudW5zaGlmdC5hcHBseShsaW5lcywgaW5wdXQuc3BsaXQoJ1xcbicpKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgaW5wdXRzLnB1c2guYXBwbHkoaW5wdXRzLCBpbnB1dCk7XG4gICAgICB9IGVsc2UgaWYgKCFoZWxwZXJzLmlzTnVsbE9yVW5kZWYoaW5wdXRzKSkge1xuICAgICAgICBsaW5lcy51bnNoaWZ0KCcnICsgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaW5lcztcbiAgfSxcblxuICAvLyBAdG9kbyBtb3ZlIHRoaXMgaW4gQ2hhcnQuaGVscGVycy5jYW52YXMudGV4dFNpemVcbiAgLy8gQHRvZG8gY2FjaGUgY2FsbHMgb2YgbWVhc3VyZVRleHQgaWYgZm9udCBkb2Vzbid0IGNoYW5nZT8hXG4gIHRleHRTaXplOiBmdW5jdGlvbihjdHgsIGxpbmVzLCBmb250KSB7XG4gICAgdmFyIGl0ZW1zID0gW10uY29uY2F0KGxpbmVzKTtcbiAgICB2YXIgaWxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgcHJldiA9IGN0eC5mb250O1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgdmFyIGk7XG5cbiAgICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgd2lkdGggPSBNYXRoLm1heChjdHgubWVhc3VyZVRleHQoaXRlbXNbaV0pLndpZHRoLCB3aWR0aCk7XG4gICAgfVxuXG4gICAgY3R4LmZvbnQgPSBwcmV2O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhlaWdodDogaWxlbiAqIGZvbnQubGluZUhlaWdodCxcbiAgICAgIHdpZHRoOiB3aWR0aFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdmFsdWUgYm91bmRlZCBieSBtaW4gYW5kIG1heC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIG1heChtaW4sIG1pbih2YWx1ZSwgbWF4KSkuXG4gICAqIEB0b2RvIG1vdmUgdGhpcyBtZXRob2QgaW4gQ2hhcnQuaGVscGVycy5ib3VuZFxuICAgKiBodHRwczovL2RvYy5xdC5pby9xdC01L3F0Z2xvYmFsLmh0bWwjcUJvdW5kXG4gICAqL1xuICBib3VuZDogZnVuY3Rpb24obWluLCB2YWx1ZSwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHBhaXIgW3ZhbHVlLCBzdGF0ZV0gd2hlcmUgc3RhdGUgaXM6XG4gICAqICogLTE6IHZhbHVlIGlzIG9ubHkgaW4gYTAgKHJlbW92ZWQpXG4gICAqICogIDE6IHZhbHVlIGlzIG9ubHkgaW4gYTEgKGFkZGVkKVxuICAgKi9cbiAgYXJyYXlEaWZmOiBmdW5jdGlvbihhMCwgYTEpIHtcbiAgICB2YXIgcHJldiA9IGEwLnNsaWNlKCk7XG4gICAgdmFyIHVwZGF0ZXMgPSBbXTtcbiAgICB2YXIgaSwgaiwgaWxlbiwgdjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhMS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHYgPSBhMVtpXTtcbiAgICAgIGogPSBwcmV2LmluZGV4T2Yodik7XG5cbiAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICB1cGRhdGVzLnB1c2goW3YsIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYuc3BsaWNlKGosIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwcmV2Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdXBkYXRlcy5wdXNoKFtwcmV2W2ldLCAtMV0pO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy83MFxuICAgKi9cbiAgcmFzdGVyaXplOiBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodiAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxufTtcblxuZnVuY3Rpb24gb3JpZW50KHBvaW50LCBvcmlnaW4pIHtcbiAgdmFyIHgwID0gb3JpZ2luLng7XG4gIHZhciB5MCA9IG9yaWdpbi55O1xuXG4gIGlmICh4MCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7eDogMCwgeTogLTF9O1xuICB9XG4gIGlmICh5MCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7eDogMSwgeTogMH07XG4gIH1cblxuICB2YXIgZHggPSBwb2ludC54IC0geDA7XG4gIHZhciBkeSA9IHBvaW50LnkgLSB5MDtcbiAgdmFyIGxuID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICByZXR1cm4ge1xuICAgIHg6IGxuID8gZHggLyBsbiA6IDAsXG4gICAgeTogbG4gPyBkeSAvIGxuIDogLTFcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxpZ25lZCh4LCB5LCB2eCwgdnksIGFsaWduKSB7XG4gIHN3aXRjaCAoYWxpZ24pIHtcbiAgY2FzZSAnY2VudGVyJzpcbiAgICB2eCA9IHZ5ID0gMDtcbiAgICBicmVhaztcbiAgY2FzZSAnYm90dG9tJzpcbiAgICB2eCA9IDA7XG4gICAgdnkgPSAxO1xuICAgIGJyZWFrO1xuICBjYXNlICdyaWdodCc6XG4gICAgdnggPSAxO1xuICAgIHZ5ID0gMDtcbiAgICBicmVhaztcbiAgY2FzZSAnbGVmdCc6XG4gICAgdnggPSAtMTtcbiAgICB2eSA9IDA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3RvcCc6XG4gICAgdnggPSAwO1xuICAgIHZ5ID0gLTE7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3N0YXJ0JzpcbiAgICB2eCA9IC12eDtcbiAgICB2eSA9IC12eTtcbiAgICBicmVhaztcbiAgY2FzZSAnZW5kJzpcbiAgICAvLyBrZWVwIG5hdHVyYWwgb3JpZW50YXRpb25cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICAvLyBjbG9ja3dpc2Ugcm90YXRpb24gKGluIGRlZ3JlZSlcbiAgICBhbGlnbiAqPSAoTWF0aC5QSSAvIDE4MCk7XG4gICAgdnggPSBNYXRoLmNvcyhhbGlnbik7XG4gICAgdnkgPSBNYXRoLnNpbihhbGlnbik7XG4gICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB2eDogdngsXG4gICAgdnk6IHZ5XG4gIH07XG59XG5cbi8vIExpbmUgY2xpcHBpbmcgKENvaGVuXHUyMDEzU3V0aGVybGFuZCBhbGdvcml0aG0pXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlblx1MjAxM1N1dGhlcmxhbmRfYWxnb3JpdGhtXG5cbnZhciBSX0lOU0lERSA9IDA7XG52YXIgUl9MRUZUID0gMTtcbnZhciBSX1JJR0hUID0gMjtcbnZhciBSX0JPVFRPTSA9IDQ7XG52YXIgUl9UT1AgPSA4O1xuXG5mdW5jdGlvbiByZWdpb24oeCwgeSwgcmVjdCkge1xuICB2YXIgcmVzID0gUl9JTlNJREU7XG5cbiAgaWYgKHggPCByZWN0LmxlZnQpIHtcbiAgICByZXMgfD0gUl9MRUZUO1xuICB9IGVsc2UgaWYgKHggPiByZWN0LnJpZ2h0KSB7XG4gICAgcmVzIHw9IFJfUklHSFQ7XG4gIH1cbiAgaWYgKHkgPCByZWN0LnRvcCkge1xuICAgIHJlcyB8PSBSX1RPUDtcbiAgfSBlbHNlIGlmICh5ID4gcmVjdC5ib3R0b20pIHtcbiAgICByZXMgfD0gUl9CT1RUT007XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjbGlwcGVkKHNlZ21lbnQsIGFyZWEpIHtcbiAgdmFyIHgwID0gc2VnbWVudC54MDtcbiAgdmFyIHkwID0gc2VnbWVudC55MDtcbiAgdmFyIHgxID0gc2VnbWVudC54MTtcbiAgdmFyIHkxID0gc2VnbWVudC55MTtcbiAgdmFyIHIwID0gcmVnaW9uKHgwLCB5MCwgYXJlYSk7XG4gIHZhciByMSA9IHJlZ2lvbih4MSwgeTEsIGFyZWEpO1xuICB2YXIgciwgeCwgeTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCEocjAgfCByMSkgfHwgKHIwICYgcjEpKSB7XG4gICAgICAvLyBib3RoIHBvaW50cyBpbnNpZGUgb3Igb24gdGhlIHNhbWUgc2lkZTogbm8gY2xpcHBpbmdcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGF0IGxlYXN0IG9uZSBwb2ludCBpcyBvdXRzaWRlXG4gICAgciA9IHIwIHx8IHIxO1xuXG4gICAgaWYgKHIgJiBSX1RPUCkge1xuICAgICAgeCA9IHgwICsgKHgxIC0geDApICogKGFyZWEudG9wIC0geTApIC8gKHkxIC0geTApO1xuICAgICAgeSA9IGFyZWEudG9wO1xuICAgIH0gZWxzZSBpZiAociAmIFJfQk9UVE9NKSB7XG4gICAgICB4ID0geDAgKyAoeDEgLSB4MCkgKiAoYXJlYS5ib3R0b20gLSB5MCkgLyAoeTEgLSB5MCk7XG4gICAgICB5ID0gYXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChyICYgUl9SSUdIVCkge1xuICAgICAgeSA9IHkwICsgKHkxIC0geTApICogKGFyZWEucmlnaHQgLSB4MCkgLyAoeDEgLSB4MCk7XG4gICAgICB4ID0gYXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHIgJiBSX0xFRlQpIHtcbiAgICAgIHkgPSB5MCArICh5MSAtIHkwKSAqIChhcmVhLmxlZnQgLSB4MCkgLyAoeDEgLSB4MCk7XG4gICAgICB4ID0gYXJlYS5sZWZ0O1xuICAgIH1cblxuICAgIGlmIChyID09PSByMCkge1xuICAgICAgeDAgPSB4O1xuICAgICAgeTAgPSB5O1xuICAgICAgcjAgPSByZWdpb24oeDAsIHkwLCBhcmVhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDEgPSB4O1xuICAgICAgeTEgPSB5O1xuICAgICAgcjEgPSByZWdpb24oeDEsIHkxLCBhcmVhKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHgwOiB4MCxcbiAgICB4MTogeDEsXG4gICAgeTA6IHkwLFxuICAgIHkxOiB5MVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlJDEocmFuZ2UsIGNvbmZpZykge1xuICB2YXIgYW5jaG9yID0gY29uZmlnLmFuY2hvcjtcbiAgdmFyIHNlZ21lbnQgPSByYW5nZTtcbiAgdmFyIHgsIHk7XG5cbiAgaWYgKGNvbmZpZy5jbGFtcCkge1xuICAgIHNlZ21lbnQgPSBjbGlwcGVkKHNlZ21lbnQsIGNvbmZpZy5hcmVhKTtcbiAgfVxuXG4gIGlmIChhbmNob3IgPT09ICdzdGFydCcpIHtcbiAgICB4ID0gc2VnbWVudC54MDtcbiAgICB5ID0gc2VnbWVudC55MDtcbiAgfSBlbHNlIGlmIChhbmNob3IgPT09ICdlbmQnKSB7XG4gICAgeCA9IHNlZ21lbnQueDE7XG4gICAgeSA9IHNlZ21lbnQueTE7XG4gIH0gZWxzZSB7XG4gICAgeCA9IChzZWdtZW50LngwICsgc2VnbWVudC54MSkgLyAyO1xuICAgIHkgPSAoc2VnbWVudC55MCArIHNlZ21lbnQueTEpIC8gMjtcbiAgfVxuXG4gIHJldHVybiBhbGlnbmVkKHgsIHksIHJhbmdlLnZ4LCByYW5nZS52eSwgY29uZmlnLmFsaWduKTtcbn1cblxudmFyIHBvc2l0aW9uZXJzID0ge1xuICBhcmM6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcbiAgICB2YXIgYW5nbGUgPSAoZWwuc3RhcnRBbmdsZSArIGVsLmVuZEFuZ2xlKSAvIDI7XG4gICAgdmFyIHZ4ID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciB2eSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgcjAgPSBlbC5pbm5lclJhZGl1cztcbiAgICB2YXIgcjEgPSBlbC5vdXRlclJhZGl1cztcblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IGVsLnggKyB2eCAqIHIwLFxuICAgICAgeTA6IGVsLnkgKyB2eSAqIHIwLFxuICAgICAgeDE6IGVsLnggKyB2eCAqIHIxLFxuICAgICAgeTE6IGVsLnkgKyB2eSAqIHIxLFxuICAgICAgdng6IHZ4LFxuICAgICAgdnk6IHZ5XG4gICAgfSwgY29uZmlnKTtcbiAgfSxcblxuICBwb2ludDogZnVuY3Rpb24oZWwsIGNvbmZpZykge1xuICAgIHZhciB2ID0gb3JpZW50KGVsLCBjb25maWcub3JpZ2luKTtcbiAgICB2YXIgcnggPSB2LnggKiBlbC5vcHRpb25zLnJhZGl1cztcbiAgICB2YXIgcnkgPSB2LnkgKiBlbC5vcHRpb25zLnJhZGl1cztcblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IGVsLnggLSByeCxcbiAgICAgIHkwOiBlbC55IC0gcnksXG4gICAgICB4MTogZWwueCArIHJ4LFxuICAgICAgeTE6IGVsLnkgKyByeSxcbiAgICAgIHZ4OiB2LngsXG4gICAgICB2eTogdi55XG4gICAgfSwgY29uZmlnKTtcbiAgfSxcblxuICBiYXI6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcbiAgICB2YXIgdiA9IG9yaWVudChlbCwgY29uZmlnLm9yaWdpbik7XG4gICAgdmFyIHggPSBlbC54O1xuICAgIHZhciB5ID0gZWwueTtcbiAgICB2YXIgc3ggPSAwO1xuICAgIHZhciBzeSA9IDA7XG5cbiAgICBpZiAoZWwuaG9yaXpvbnRhbCkge1xuICAgICAgeCA9IE1hdGgubWluKGVsLngsIGVsLmJhc2UpO1xuICAgICAgc3ggPSBNYXRoLmFicyhlbC5iYXNlIC0gZWwueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBNYXRoLm1pbihlbC55LCBlbC5iYXNlKTtcbiAgICAgIHN5ID0gTWF0aC5hYnMoZWwuYmFzZSAtIGVsLnkpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IHgsXG4gICAgICB5MDogeSArIHN5LFxuICAgICAgeDE6IHggKyBzeCxcbiAgICAgIHkxOiB5LFxuICAgICAgdng6IHYueCxcbiAgICAgIHZ5OiB2LnlcbiAgICB9LCBjb25maWcpO1xuICB9LFxuXG4gIGZhbGxiYWNrOiBmdW5jdGlvbihlbCwgY29uZmlnKSB7XG4gICAgdmFyIHYgPSBvcmllbnQoZWwsIGNvbmZpZy5vcmlnaW4pO1xuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogZWwueCxcbiAgICAgIHkwOiBlbC55LFxuICAgICAgeDE6IGVsLnggKyAoZWwud2lkdGggfHwgMCksXG4gICAgICB5MTogZWwueSArIChlbC5oZWlnaHQgfHwgMCksXG4gICAgICB2eDogdi54LFxuICAgICAgdnk6IHYueVxuICAgIH0sIGNvbmZpZyk7XG4gIH1cbn07XG5cbnZhciByYXN0ZXJpemUgPSB1dGlscy5yYXN0ZXJpemU7XG5cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMobW9kZWwpIHtcbiAgdmFyIGJvcmRlcldpZHRoID0gbW9kZWwuYm9yZGVyV2lkdGggfHwgMDtcbiAgdmFyIHBhZGRpbmcgPSBtb2RlbC5wYWRkaW5nO1xuICB2YXIgdGggPSBtb2RlbC5zaXplLmhlaWdodDtcbiAgdmFyIHR3ID0gbW9kZWwuc2l6ZS53aWR0aDtcbiAgdmFyIHR4ID0gLXR3IC8gMjtcbiAgdmFyIHR5ID0gLXRoIC8gMjtcblxuICByZXR1cm4ge1xuICAgIGZyYW1lOiB7XG4gICAgICB4OiB0eCAtIHBhZGRpbmcubGVmdCAtIGJvcmRlcldpZHRoLFxuICAgICAgeTogdHkgLSBwYWRkaW5nLnRvcCAtIGJvcmRlcldpZHRoLFxuICAgICAgdzogdHcgKyBwYWRkaW5nLndpZHRoICsgYm9yZGVyV2lkdGggKiAyLFxuICAgICAgaDogdGggKyBwYWRkaW5nLmhlaWdodCArIGJvcmRlcldpZHRoICogMlxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgeDogdHgsXG4gICAgICB5OiB0eSxcbiAgICAgIHc6IHR3LFxuICAgICAgaDogdGhcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlT3JpZ2luKGVsLCBjb250ZXh0KSB7XG4gIHZhciBzY2FsZSA9IGNvbnRleHQuY2hhcnQuZ2V0RGF0YXNldE1ldGEoY29udGV4dC5kYXRhc2V0SW5kZXgpLnZTY2FsZTtcblxuICBpZiAoIXNjYWxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc2NhbGUueENlbnRlciAhPT0gdW5kZWZpbmVkICYmIHNjYWxlLnlDZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7eDogc2NhbGUueENlbnRlciwgeTogc2NhbGUueUNlbnRlcn07XG4gIH1cblxuICB2YXIgcGl4ZWwgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgcmV0dXJuIGVsLmhvcml6b250YWwgP1xuICAgIHt4OiBwaXhlbCwgeTogbnVsbH0gOlxuICAgIHt4OiBudWxsLCB5OiBwaXhlbH07XG59XG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uZXIoZWwpIHtcbiAgaWYgKGVsIGluc3RhbmNlb2YgY2hhcnRfanMuQXJjRWxlbWVudCkge1xuICAgIHJldHVybiBwb3NpdGlvbmVycy5hcmM7XG4gIH1cbiAgaWYgKGVsIGluc3RhbmNlb2YgY2hhcnRfanMuUG9pbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uZXJzLnBvaW50O1xuICB9XG4gIGlmIChlbCBpbnN0YW5jZW9mIGNoYXJ0X2pzLkJhckVsZW1lbnQpIHtcbiAgICByZXR1cm4gcG9zaXRpb25lcnMuYmFyO1xuICB9XG4gIHJldHVybiBwb3NpdGlvbmVycy5mYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gZHJhd1JvdW5kZWRSZWN0KGN0eCwgeCwgeSwgdywgaCwgcmFkaXVzKSB7XG4gIHZhciBIQUxGX1BJID0gTWF0aC5QSSAvIDI7XG5cbiAgaWYgKHJhZGl1cykge1xuICAgIHZhciByID0gTWF0aC5taW4ocmFkaXVzLCBoIC8gMiwgdyAvIDIpO1xuICAgIHZhciBsZWZ0ID0geCArIHI7XG4gICAgdmFyIHRvcCA9IHkgKyByO1xuICAgIHZhciByaWdodCA9IHggKyB3IC0gcjtcbiAgICB2YXIgYm90dG9tID0geSArIGggLSByO1xuXG4gICAgY3R4Lm1vdmVUbyh4LCB0b3ApO1xuICAgIGlmIChsZWZ0IDwgcmlnaHQgJiYgdG9wIDwgYm90dG9tKSB7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgLU1hdGguUEksIC1IQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIDApO1xuICAgICAgY3R4LmFyYyhyaWdodCwgYm90dG9tLCByLCAwLCBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCBIQUxGX1BJLCBNYXRoLlBJKTtcbiAgICB9IGVsc2UgaWYgKGxlZnQgPCByaWdodCkge1xuICAgICAgY3R4Lm1vdmVUbyhsZWZ0LCB5KTtcbiAgICAgIGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIEhBTEZfUEksIE1hdGguUEkgKyBIQUxGX1BJKTtcbiAgICB9IGVsc2UgaWYgKHRvcCA8IGJvdHRvbSkge1xuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1NYXRoLlBJLCAwKTtcbiAgICAgIGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCAwLCBNYXRoLlBJKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1NYXRoLlBJLCBNYXRoLlBJKTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0ZyYW1lKGN0eCwgcmVjdCwgbW9kZWwpIHtcbiAgdmFyIGJnQ29sb3IgPSBtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XG4gIHZhciBib3JkZXJDb2xvciA9IG1vZGVsLmJvcmRlckNvbG9yO1xuICB2YXIgYm9yZGVyV2lkdGggPSBtb2RlbC5ib3JkZXJXaWR0aDtcblxuICBpZiAoIWJnQ29sb3IgJiYgKCFib3JkZXJDb2xvciB8fCAhYm9yZGVyV2lkdGgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIGRyYXdSb3VuZGVkUmVjdChcbiAgICBjdHgsXG4gICAgcmFzdGVyaXplKHJlY3QueCkgKyBib3JkZXJXaWR0aCAvIDIsXG4gICAgcmFzdGVyaXplKHJlY3QueSkgKyBib3JkZXJXaWR0aCAvIDIsXG4gICAgcmFzdGVyaXplKHJlY3QudykgLSBib3JkZXJXaWR0aCxcbiAgICByYXN0ZXJpemUocmVjdC5oKSAtIGJvcmRlcldpZHRoLFxuICAgIG1vZGVsLmJvcmRlclJhZGl1cyk7XG5cbiAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gIGlmIChiZ0NvbG9yKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxuXG4gIGlmIChib3JkZXJDb2xvciAmJiBib3JkZXJXaWR0aCkge1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICBjdHgubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXh0R2VvbWV0cnkocmVjdCwgYWxpZ24sIGZvbnQpIHtcbiAgdmFyIGggPSBmb250LmxpbmVIZWlnaHQ7XG4gIHZhciB3ID0gcmVjdC53O1xuICB2YXIgeCA9IHJlY3QueDtcbiAgdmFyIHkgPSByZWN0LnkgKyBoIC8gMjtcblxuICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCArPSB3IC8gMjtcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcgfHwgYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IHc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGg6IGgsXG4gICAgdzogdyxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHJhd1RleHRMaW5lKGN0eCwgdGV4dCwgY2ZnKSB7XG4gIHZhciBzaGFkb3cgPSBjdHguc2hhZG93Qmx1cjtcbiAgdmFyIHN0cm9rZWQgPSBjZmcuc3Ryb2tlZDtcbiAgdmFyIHggPSByYXN0ZXJpemUoY2ZnLngpO1xuICB2YXIgeSA9IHJhc3Rlcml6ZShjZmcueSk7XG4gIHZhciB3ID0gcmFzdGVyaXplKGNmZy53KTtcblxuICBpZiAoc3Ryb2tlZCkge1xuICAgIGN0eC5zdHJva2VUZXh0KHRleHQsIHgsIHksIHcpO1xuICB9XG5cbiAgaWYgKGNmZy5maWxsZWQpIHtcbiAgICBpZiAoc2hhZG93ICYmIHN0cm9rZWQpIHtcbiAgICAgIC8vIFByZXZlbnQgZHJhd2luZyBzaGFkb3cgb24gYm90aCB0aGUgdGV4dCBzdHJva2UgYW5kIGZpbGwsIHNvXG4gICAgICAvLyBpZiB0aGUgdGV4dCBpcyBzdHJva2VkLCByZW1vdmUgdGhlIHNoYWRvdyBmb3IgdGhlIHRleHQgZmlsbC5cbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICB9XG5cbiAgICBjdHguZmlsbFRleHQodGV4dCwgeCwgeSwgdyk7XG5cbiAgICBpZiAoc2hhZG93ICYmIHN0cm9rZWQpIHtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gc2hhZG93O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3VGV4dChjdHgsIGxpbmVzLCByZWN0LCBtb2RlbCkge1xuICB2YXIgYWxpZ24gPSBtb2RlbC50ZXh0QWxpZ247XG4gIHZhciBjb2xvciA9IG1vZGVsLmNvbG9yO1xuICB2YXIgZmlsbGVkID0gISFjb2xvcjtcbiAgdmFyIGZvbnQgPSBtb2RlbC5mb250O1xuICB2YXIgaWxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgdmFyIHN0cm9rZUNvbG9yID0gbW9kZWwudGV4dFN0cm9rZUNvbG9yO1xuICB2YXIgc3Ryb2tlV2lkdGggPSBtb2RlbC50ZXh0U3Ryb2tlV2lkdGg7XG4gIHZhciBzdHJva2VkID0gc3Ryb2tlQ29sb3IgJiYgc3Ryb2tlV2lkdGg7XG4gIHZhciBpO1xuXG4gIGlmICghaWxlbiB8fCAoIWZpbGxlZCAmJiAhc3Ryb2tlZCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBBZGp1c3QgY29vcmRpbmF0ZXMgYmFzZWQgb24gdGV4dCBhbGlnbm1lbnQgYW5kIGxpbmUgaGVpZ2h0XG4gIHJlY3QgPSB0ZXh0R2VvbWV0cnkocmVjdCwgYWxpZ24sIGZvbnQpO1xuXG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIGN0eC50ZXh0QWxpZ24gPSBhbGlnbjtcbiAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICBjdHguc2hhZG93Qmx1ciA9IG1vZGVsLnRleHRTaGFkb3dCbHVyO1xuICBjdHguc2hhZG93Q29sb3IgPSBtb2RlbC50ZXh0U2hhZG93Q29sb3I7XG5cbiAgaWYgKGZpbGxlZCkge1xuICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgfVxuICBpZiAoc3Ryb2tlZCkge1xuICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRyYXdUZXh0TGluZShjdHgsIGxpbmVzW2ldLCB7XG4gICAgICBzdHJva2VkOiBzdHJva2VkLFxuICAgICAgZmlsbGVkOiBmaWxsZWQsXG4gICAgICB3OiByZWN0LncsXG4gICAgICB4OiByZWN0LngsXG4gICAgICB5OiByZWN0LnkgKyByZWN0LmggKiBpXG4gICAgfSk7XG4gIH1cbn1cblxudmFyIExhYmVsID0gZnVuY3Rpb24oY29uZmlnLCBjdHgsIGVsLCBpbmRleCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIG1lLl9jb25maWcgPSBjb25maWc7XG4gIG1lLl9pbmRleCA9IGluZGV4O1xuICBtZS5fbW9kZWwgPSBudWxsO1xuICBtZS5fcmVjdHMgPSBudWxsO1xuICBtZS5fY3R4ID0gY3R4O1xuICBtZS5fZWwgPSBlbDtcbn07XG5cbmhlbHBlcnMubWVyZ2UoTGFiZWwucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vZGVsaXplOiBmdW5jdGlvbihkaXNwbGF5LCBsaW5lcywgY29uZmlnLCBjb250ZXh0KSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgaW5kZXggPSBtZS5faW5kZXg7XG4gICAgdmFyIGZvbnQgPSBoZWxwZXJzLnRvRm9udChoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5mb250LCB7fV0sIGNvbnRleHQsIGluZGV4KSk7XG4gICAgdmFyIGNvbG9yID0gaGVscGVycy5yZXNvbHZlKFtjb25maWcuY29sb3IsIGNoYXJ0X2pzLmRlZmF1bHRzLmNvbG9yXSwgY29udGV4dCwgaW5kZXgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFsaWduOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5hbGlnbiwgJ2NlbnRlciddLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBhbmNob3I6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmFuY2hvciwgJ2NlbnRlciddLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBhcmVhOiBjb250ZXh0LmNoYXJ0LmNoYXJ0QXJlYSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogaGVscGVycy5yZXNvbHZlKFtjb25maWcuYmFja2dyb3VuZENvbG9yLCBudWxsXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYm9yZGVyQ29sb3I6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmJvcmRlckNvbG9yLCBudWxsXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYm9yZGVyUmFkaXVzOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5ib3JkZXJSYWRpdXMsIDBdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBib3JkZXJXaWR0aDogaGVscGVycy5yZXNvbHZlKFtjb25maWcuYm9yZGVyV2lkdGgsIDBdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBjbGFtcDogaGVscGVycy5yZXNvbHZlKFtjb25maWcuY2xhbXAsIGZhbHNlXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgY2xpcDogaGVscGVycy5yZXNvbHZlKFtjb25maWcuY2xpcCwgZmFsc2VdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBjb2xvcjogY29sb3IsXG4gICAgICBkaXNwbGF5OiBkaXNwbGF5LFxuICAgICAgZm9udDogZm9udCxcbiAgICAgIGxpbmVzOiBsaW5lcyxcbiAgICAgIG9mZnNldDogaGVscGVycy5yZXNvbHZlKFtjb25maWcub2Zmc2V0LCA0XSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgb3BhY2l0eTogaGVscGVycy5yZXNvbHZlKFtjb25maWcub3BhY2l0eSwgMV0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIG9yaWdpbjogZ2V0U2NhbGVPcmlnaW4obWUuX2VsLCBjb250ZXh0KSxcbiAgICAgIHBhZGRpbmc6IGhlbHBlcnMudG9QYWRkaW5nKGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLnBhZGRpbmcsIDRdLCBjb250ZXh0LCBpbmRleCkpLFxuICAgICAgcG9zaXRpb25lcjogZ2V0UG9zaXRpb25lcihtZS5fZWwpLFxuICAgICAgcm90YXRpb246IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLnJvdGF0aW9uLCAwXSwgY29udGV4dCwgaW5kZXgpICogKE1hdGguUEkgLyAxODApLFxuICAgICAgc2l6ZTogdXRpbHMudGV4dFNpemUobWUuX2N0eCwgbGluZXMsIGZvbnQpLFxuICAgICAgdGV4dEFsaWduOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy50ZXh0QWxpZ24sICdzdGFydCddLCBjb250ZXh0LCBpbmRleCksXG4gICAgICB0ZXh0U2hhZG93Qmx1cjogaGVscGVycy5yZXNvbHZlKFtjb25maWcudGV4dFNoYWRvd0JsdXIsIDBdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICB0ZXh0U2hhZG93Q29sb3I6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLnRleHRTaGFkb3dDb2xvciwgY29sb3JdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLnRleHRTdHJva2VDb2xvciwgY29sb3JdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLnRleHRTdHJva2VXaWR0aCwgMF0sIGNvbnRleHQsIGluZGV4KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbW9kZWwgPSBudWxsO1xuICAgIHZhciByZWN0cyA9IG51bGw7XG4gICAgdmFyIGluZGV4ID0gbWUuX2luZGV4O1xuICAgIHZhciBjb25maWcgPSBtZS5fY29uZmlnO1xuICAgIHZhciB2YWx1ZSwgbGFiZWwsIGxpbmVzO1xuXG4gICAgLy8gV2UgZmlyc3QgcmVzb2x2ZSB0aGUgZGlzcGxheSBvcHRpb24gKHNlcGFyYXRlbHkpIHRvIGF2b2lkIGNvbXB1dGluZ1xuICAgIC8vIG90aGVyIG9wdGlvbnMgaW4gY2FzZSB0aGUgbGFiZWwgaXMgaGlkZGVuIChpLmUuIGRpc3BsYXk6IGZhbHNlKS5cbiAgICB2YXIgZGlzcGxheSA9IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmRpc3BsYXksIHRydWVdLCBjb250ZXh0LCBpbmRleCk7XG5cbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgdmFsdWUgPSBjb250ZXh0LmRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBsYWJlbCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQoaGVscGVycy5jYWxsYmFjayhjb25maWcuZm9ybWF0dGVyLCBbdmFsdWUsIGNvbnRleHRdKSwgdmFsdWUpO1xuICAgICAgbGluZXMgPSBoZWxwZXJzLmlzTnVsbE9yVW5kZWYobGFiZWwpID8gW10gOiB1dGlscy50b1RleHRMaW5lcyhsYWJlbCk7XG5cbiAgICAgIGlmIChsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgbW9kZWwgPSBtZS5fbW9kZWxpemUoZGlzcGxheSwgbGluZXMsIGNvbmZpZywgY29udGV4dCk7XG4gICAgICAgIHJlY3RzID0gYm91bmRpbmdSZWN0cyhtb2RlbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWUuX21vZGVsID0gbW9kZWw7XG4gICAgbWUuX3JlY3RzID0gcmVjdHM7XG4gIH0sXG5cbiAgZ2VvbWV0cnk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWN0cyA/IHRoaXMuX3JlY3RzLmZyYW1lIDoge307XG4gIH0sXG5cbiAgcm90YXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbCA/IHRoaXMuX21vZGVsLnJvdGF0aW9uIDogMDtcbiAgfSxcblxuICB2aXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwub3BhY2l0eTtcbiAgfSxcblxuICBtb2RlbDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB9LFxuXG4gIGRyYXc6IGZ1bmN0aW9uKGNoYXJ0LCBjZW50ZXIpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjdHggPSBjaGFydC5jdHg7XG4gICAgdmFyIG1vZGVsID0gbWUuX21vZGVsO1xuICAgIHZhciByZWN0cyA9IG1lLl9yZWN0cztcbiAgICB2YXIgYXJlYTtcblxuICAgIGlmICghdGhpcy52aXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgaWYgKG1vZGVsLmNsaXApIHtcbiAgICAgIGFyZWEgPSBtb2RlbC5hcmVhO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnJlY3QoXG4gICAgICAgIGFyZWEubGVmdCxcbiAgICAgICAgYXJlYS50b3AsXG4gICAgICAgIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsXG4gICAgICAgIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICB9XG5cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB1dGlscy5ib3VuZCgwLCBtb2RlbC5vcGFjaXR5LCAxKTtcbiAgICBjdHgudHJhbnNsYXRlKHJhc3Rlcml6ZShjZW50ZXIueCksIHJhc3Rlcml6ZShjZW50ZXIueSkpO1xuICAgIGN0eC5yb3RhdGUobW9kZWwucm90YXRpb24pO1xuXG4gICAgZHJhd0ZyYW1lKGN0eCwgcmVjdHMuZnJhbWUsIG1vZGVsKTtcbiAgICBkcmF3VGV4dChjdHgsIG1vZGVsLmxpbmVzLCByZWN0cy50ZXh0LCBtb2RlbCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59KTtcblxudmFyIE1JTl9JTlRFR0VSID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfHwgLTkwMDcxOTkyNTQ3NDA5OTE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXMvbm8tbnVtYmVyLW1pbnNhZmVpbnRlZ2VyXG52YXIgTUFYX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcy9uby1udW1iZXItbWF4c2FmZWludGVnZXJcblxuZnVuY3Rpb24gcm90YXRlZChwb2ludCwgY2VudGVyLCBhbmdsZSkge1xuICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICB2YXIgY3ggPSBjZW50ZXIueDtcbiAgdmFyIGN5ID0gY2VudGVyLnk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBjeCArIGNvcyAqIChwb2ludC54IC0gY3gpIC0gc2luICogKHBvaW50LnkgLSBjeSksXG4gICAgeTogY3kgKyBzaW4gKiAocG9pbnQueCAtIGN4KSArIGNvcyAqIChwb2ludC55IC0gY3kpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2plY3RlZChwb2ludHMsIGF4aXMpIHtcbiAgdmFyIG1pbiA9IE1BWF9JTlRFR0VSO1xuICB2YXIgbWF4ID0gTUlOX0lOVEVHRVI7XG4gIHZhciBvcmlnaW4gPSBheGlzLm9yaWdpbjtcbiAgdmFyIGksIHB0LCB2eCwgdnksIGRwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICBwdCA9IHBvaW50c1tpXTtcbiAgICB2eCA9IHB0LnggLSBvcmlnaW4ueDtcbiAgICB2eSA9IHB0LnkgLSBvcmlnaW4ueTtcbiAgICBkcCA9IGF4aXMudnggKiB2eCArIGF4aXMudnkgKiB2eTtcbiAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGRwKTtcbiAgICBtYXggPSBNYXRoLm1heChtYXgsIGRwKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9BeGlzKHAwLCBwMSkge1xuICB2YXIgdnggPSBwMS54IC0gcDAueDtcbiAgdmFyIHZ5ID0gcDEueSAtIHAwLnk7XG4gIHZhciBsbiA9IE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG5cbiAgcmV0dXJuIHtcbiAgICB2eDogKHAxLnggLSBwMC54KSAvIGxuLFxuICAgIHZ5OiAocDEueSAtIHAwLnkpIC8gbG4sXG4gICAgb3JpZ2luOiBwMCxcbiAgICBsbjogbG5cbiAgfTtcbn1cblxudmFyIEhpdEJveCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yb3RhdGlvbiA9IDA7XG4gIHRoaXMuX3JlY3QgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHc6IDAsXG4gICAgaDogMFxuICB9O1xufTtcblxuaGVscGVycy5tZXJnZShIaXRCb3gucHJvdG90eXBlLCB7XG4gIGNlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSB0aGlzLl9yZWN0O1xuICAgIHJldHVybiB7XG4gICAgICB4OiByLnggKyByLncgLyAyLFxuICAgICAgeTogci55ICsgci5oIC8gMlxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbihjZW50ZXIsIHJlY3QsIHJvdGF0aW9uKSB7XG4gICAgdGhpcy5fcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLl9yZWN0ID0ge1xuICAgICAgeDogcmVjdC54ICsgY2VudGVyLngsXG4gICAgICB5OiByZWN0LnkgKyBjZW50ZXIueSxcbiAgICAgIHc6IHJlY3QudyxcbiAgICAgIGg6IHJlY3QuaFxuICAgIH07XG4gIH0sXG5cbiAgY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbWFyZ2luID0gMTtcbiAgICB2YXIgcmVjdCA9IG1lLl9yZWN0O1xuXG4gICAgcG9pbnQgPSByb3RhdGVkKHBvaW50LCBtZS5jZW50ZXIoKSwgLW1lLl9yb3RhdGlvbik7XG5cbiAgICByZXR1cm4gIShwb2ludC54IDwgcmVjdC54IC0gbWFyZ2luXG4gICAgICB8fCBwb2ludC55IDwgcmVjdC55IC0gbWFyZ2luXG4gICAgICB8fCBwb2ludC54ID4gcmVjdC54ICsgcmVjdC53ICsgbWFyZ2luICogMlxuICAgICAgfHwgcG9pbnQueSA+IHJlY3QueSArIHJlY3QuaCArIG1hcmdpbiAqIDIpO1xuICB9LFxuXG4gIC8vIFNlcGFyYXRpbmcgQXhpcyBUaGVvcmVtXG4gIC8vIGh0dHBzOi8vZ2FtZWRldmVsb3BtZW50LnR1dHNwbHVzLmNvbS90dXRvcmlhbHMvY29sbGlzaW9uLWRldGVjdGlvbi11c2luZy10aGUtc2VwYXJhdGluZy1heGlzLXRoZW9yZW0tLWdhbWVkZXYtMTY5XG4gIGludGVyc2VjdHM6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgdmFyIHIwID0gdGhpcy5fcG9pbnRzKCk7XG4gICAgdmFyIHIxID0gb3RoZXIuX3BvaW50cygpO1xuICAgIHZhciBheGVzID0gW1xuICAgICAgdG9BeGlzKHIwWzBdLCByMFsxXSksXG4gICAgICB0b0F4aXMocjBbMF0sIHIwWzNdKVxuICAgIF07XG4gICAgdmFyIGksIHByMCwgcHIxO1xuXG4gICAgaWYgKHRoaXMuX3JvdGF0aW9uICE9PSBvdGhlci5fcm90YXRpb24pIHtcbiAgICAgIC8vIE9ubHkgc2VwYXJhdGUgd2l0aCByMSBheGlzIGlmIHRoZSByb3RhdGlvbiBpcyBkaWZmZXJlbnQsXG4gICAgICAvLyBlbHNlIGl0J3MgZW5vdWdoIHRvIHNlcGFyYXRlIHIwIGFuZCByMSB3aXRoIHIwIGF4aXMgb25seSFcbiAgICAgIGF4ZXMucHVzaChcbiAgICAgICAgdG9BeGlzKHIxWzBdLCByMVsxXSksXG4gICAgICAgIHRvQXhpcyhyMVswXSwgcjFbM10pXG4gICAgICApO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwcjAgPSBwcm9qZWN0ZWQocjAsIGF4ZXNbaV0pO1xuICAgICAgcHIxID0gcHJvamVjdGVkKHIxLCBheGVzW2ldKTtcblxuICAgICAgaWYgKHByMC5tYXggPCBwcjEubWluIHx8IHByMS5tYXggPCBwcjAubWluKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIHJlY3QgPSBtZS5fcmVjdDtcbiAgICB2YXIgYW5nbGUgPSBtZS5fcm90YXRpb247XG4gICAgdmFyIGNlbnRlciA9IG1lLmNlbnRlcigpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCwgeTogcmVjdC55fSwgY2VudGVyLCBhbmdsZSksXG4gICAgICByb3RhdGVkKHt4OiByZWN0LnggKyByZWN0LncsIHk6IHJlY3QueX0sIGNlbnRlciwgYW5nbGUpLFxuICAgICAgcm90YXRlZCh7eDogcmVjdC54ICsgcmVjdC53LCB5OiByZWN0LnkgKyByZWN0Lmh9LCBjZW50ZXIsIGFuZ2xlKSxcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCwgeTogcmVjdC55ICsgcmVjdC5ofSwgY2VudGVyLCBhbmdsZSlcbiAgICBdO1xuICB9XG59KTtcblxuZnVuY3Rpb24gY29vcmRpbmF0ZXMoZWwsIG1vZGVsLCBnZW9tZXRyeSkge1xuICB2YXIgcG9pbnQgPSBtb2RlbC5wb3NpdGlvbmVyKGVsLCBtb2RlbCk7XG4gIHZhciB2eCA9IHBvaW50LnZ4O1xuICB2YXIgdnkgPSBwb2ludC52eTtcblxuICBpZiAoIXZ4ICYmICF2eSkge1xuICAgIC8vIGlmIGFsaWduZWQgY2VudGVyLCB3ZSBkb24ndCB3YW50IHRvIG9mZnNldCB0aGUgY2VudGVyIHBvaW50XG4gICAgcmV0dXJuIHt4OiBwb2ludC54LCB5OiBwb2ludC55fTtcbiAgfVxuXG4gIHZhciB3ID0gZ2VvbWV0cnkudztcbiAgdmFyIGggPSBnZW9tZXRyeS5oO1xuXG4gIC8vIHRha2UgaW4gYWNjb3VudCB0aGUgbGFiZWwgcm90YXRpb25cbiAgdmFyIHJvdGF0aW9uID0gbW9kZWwucm90YXRpb247XG4gIHZhciBkeCA9IE1hdGguYWJzKHcgLyAyICogTWF0aC5jb3Mocm90YXRpb24pKSArIE1hdGguYWJzKGggLyAyICogTWF0aC5zaW4ocm90YXRpb24pKTtcbiAgdmFyIGR5ID0gTWF0aC5hYnModyAvIDIgKiBNYXRoLnNpbihyb3RhdGlvbikpICsgTWF0aC5hYnMoaCAvIDIgKiBNYXRoLmNvcyhyb3RhdGlvbikpO1xuXG4gIC8vIHNjYWxlIHRoZSB1bml0IHZlY3RvciAodngsIHZ5KSB0byBnZXQgYXQgbGVhc3QgZHggb3IgZHkgZXF1YWwgdG9cbiAgLy8gdyBvciBoIHJlc3BlY3RpdmVseSAoZWxzZSB3ZSB3b3VsZCBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIHRvIHRoZVxuICAvLyBlbGxpcHNlIGluc2NyaWJlZCBpbiB0aGUgYm91bmRpbmcgcmVjdClcbiAgdmFyIHZzID0gMSAvIE1hdGgubWF4KE1hdGguYWJzKHZ4KSwgTWF0aC5hYnModnkpKTtcbiAgZHggKj0gdnggKiB2cztcbiAgZHkgKj0gdnkgKiB2cztcblxuICAvLyBmaW5hbGx5LCBpbmNsdWRlIHRoZSBleHBsaWNpdCBvZmZzZXRcbiAgZHggKz0gbW9kZWwub2Zmc2V0ICogdng7XG4gIGR5ICs9IG1vZGVsLm9mZnNldCAqIHZ5O1xuXG4gIHJldHVybiB7XG4gICAgeDogcG9pbnQueCArIGR4LFxuICAgIHk6IHBvaW50LnkgKyBkeVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb2xsaWRlKGxhYmVscywgY29sbGlkZXIpIHtcbiAgdmFyIGksIGosIHMwLCBzMTtcblxuICAvLyBJTVBPUlRBTlQgSXRlcmF0ZSBpbiB0aGUgcmV2ZXJzZSBvcmRlciBzaW5jZSBpdGVtcyBhdCB0aGUgZW5kIG9mIHRoZVxuICAvLyBsaXN0IGhhdmUgYW4gaGlnaGVyIHdlaWdodC9wcmlvcml0eSBhbmQgdGh1cyBzaG91bGQgYmUgbGVzcyBpbXBhY3RlZFxuICAvLyBieSB0aGUgb3ZlcmxhcHBpbmcgc3RyYXRlZ3kuXG5cbiAgZm9yIChpID0gbGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgczAgPSBsYWJlbHNbaV0uJGxheW91dDtcblxuICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDAgJiYgczAuX3Zpc2libGU7IC0taikge1xuICAgICAgczEgPSBsYWJlbHNbal0uJGxheW91dDtcblxuICAgICAgaWYgKHMxLl92aXNpYmxlICYmIHMwLl9ib3guaW50ZXJzZWN0cyhzMS5fYm94KSkge1xuICAgICAgICBjb2xsaWRlcihzMCwgczEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYWJlbHM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGUobGFiZWxzKSB7XG4gIHZhciBpLCBpbGVuLCBsYWJlbCwgc3RhdGUsIGdlb21ldHJ5LCBjZW50ZXIsIHByb3h5O1xuXG4gIC8vIEluaXRpYWxpemUgbGFiZWxzIGZvciBvdmVybGFwIGRldGVjdGlvblxuICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgIHN0YXRlID0gbGFiZWwuJGxheW91dDtcblxuICAgIGlmIChzdGF0ZS5fdmlzaWJsZSkge1xuICAgICAgLy8gQ2hhcnQuanMgMyByZW1vdmVkIGVsLl9tb2RlbCBpbiBmYXZvciBvZiBnZXRQcm9wcygpLCBtYWtpbmcgaGFyZGVyIHRvXG4gICAgICAvLyBhYnN0cmFjdCByZWFkaW5nIHZhbHVlcyBpbiBwb3NpdGlvbmVycy4gQWxzbywgdXNpbmcgc3RyaW5nIGFycmF5cyB0b1xuICAgICAgLy8gcmVhZCB2YWx1ZXMgKGkuZS4gdmFyIHthLGIsY30gPSBlbC5nZXRQcm9wcyhbXCJhXCIsXCJiXCIsXCJjXCJdKSkgd291bGQgbWFrZVxuICAgICAgLy8gcG9zaXRpb25lcnMgaW5lZmZpY2llbnQgaW4gdGhlIG5vcm1hbCBjYXNlIChpLmUuIG5vdCB0aGUgZmluYWwgdmFsdWVzKVxuICAgICAgLy8gYW5kIHRoZSBjb2RlIGEgYml0IHVnbHksIHNvIGxldCdzIHVzZSBhIFByb3h5IGluc3RlYWQuXG4gICAgICBwcm94eSA9IG5ldyBQcm94eShsYWJlbC5fZWwsIHtnZXQ6IChlbCwgcCkgPT4gZWwuZ2V0UHJvcHMoW3BdLCB0cnVlKVtwXX0pO1xuXG4gICAgICBnZW9tZXRyeSA9IGxhYmVsLmdlb21ldHJ5KCk7XG4gICAgICBjZW50ZXIgPSBjb29yZGluYXRlcyhwcm94eSwgbGFiZWwubW9kZWwoKSwgZ2VvbWV0cnkpO1xuICAgICAgc3RhdGUuX2JveC51cGRhdGUoY2VudGVyLCBnZW9tZXRyeSwgbGFiZWwucm90YXRpb24oKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXV0byBoaWRlIG92ZXJsYXBwaW5nIGxhYmVsc1xuICByZXR1cm4gY29sbGlkZShsYWJlbHMsIGZ1bmN0aW9uKHMwLCBzMSkge1xuICAgIHZhciBoMCA9IHMwLl9oaWRhYmxlO1xuICAgIHZhciBoMSA9IHMxLl9oaWRhYmxlO1xuXG4gICAgaWYgKChoMCAmJiBoMSkgfHwgaDEpIHtcbiAgICAgIHMxLl92aXNpYmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChoMCkge1xuICAgICAgczAuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbGF5b3V0ID0ge1xuICBwcmVwYXJlOiBmdW5jdGlvbihkYXRhc2V0cykge1xuICAgIHZhciBsYWJlbHMgPSBbXTtcbiAgICB2YXIgaSwgaiwgaWxlbiwgamxlbiwgbGFiZWw7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gZGF0YXNldHNbaV0ubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgIGxhYmVsID0gZGF0YXNldHNbaV1bal07XG4gICAgICAgIGxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgbGFiZWwuJGxheW91dCA9IHtcbiAgICAgICAgICBfYm94OiBuZXcgSGl0Qm94KCksXG4gICAgICAgICAgX2hpZGFibGU6IGZhbHNlLFxuICAgICAgICAgIF92aXNpYmxlOiB0cnVlLFxuICAgICAgICAgIF9zZXQ6IGksXG4gICAgICAgICAgX2lkeDogbGFiZWwuX2luZGV4XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyBOZXcgYHpgIG9wdGlvbjogbGFiZWxzIHdpdGggYSBoaWdoZXIgei1pbmRleCBhcmUgZHJhd25cbiAgICAvLyBvZiB0b3Agb2YgdGhlIG9uZXMgd2l0aCBhIGxvd2VyIGluZGV4LiBMb3dlc3Qgei1pbmRleCBsYWJlbHNcbiAgICAvLyBhcmUgYWxzbyBkaXNjYXJkZWQgZmlyc3Qgd2hlbiBoaWRpbmcgb3ZlcmxhcHBpbmcgbGFiZWxzLlxuICAgIGxhYmVscy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHZhciBzYSA9IGEuJGxheW91dDtcbiAgICAgIHZhciBzYiA9IGIuJGxheW91dDtcblxuICAgICAgcmV0dXJuIHNhLl9pZHggPT09IHNiLl9pZHhcbiAgICAgICAgPyBzYi5fc2V0IC0gc2EuX3NldFxuICAgICAgICA6IHNiLl9pZHggLSBzYS5faWR4O1xuICAgIH0pO1xuXG4gICAgdGhpcy51cGRhdGUobGFiZWxzKTtcblxuICAgIHJldHVybiBsYWJlbHM7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbihsYWJlbHMpIHtcbiAgICB2YXIgZGlydHkgPSBmYWxzZTtcbiAgICB2YXIgaSwgaWxlbiwgbGFiZWwsIG1vZGVsLCBzdGF0ZTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgIG1vZGVsID0gbGFiZWwubW9kZWwoKTtcbiAgICAgIHN0YXRlID0gbGFiZWwuJGxheW91dDtcbiAgICAgIHN0YXRlLl9oaWRhYmxlID0gbW9kZWwgJiYgbW9kZWwuZGlzcGxheSA9PT0gJ2F1dG8nO1xuICAgICAgc3RhdGUuX3Zpc2libGUgPSBsYWJlbC52aXNpYmxlKCk7XG4gICAgICBkaXJ0eSB8PSBzdGF0ZS5faGlkYWJsZTtcbiAgICB9XG5cbiAgICBpZiAoZGlydHkpIHtcbiAgICAgIGNvbXB1dGUobGFiZWxzKTtcbiAgICB9XG4gIH0sXG5cbiAgbG9va3VwOiBmdW5jdGlvbihsYWJlbHMsIHBvaW50KSB7XG4gICAgdmFyIGksIHN0YXRlO1xuXG4gICAgLy8gSU1QT1JUQU5UIEl0ZXJhdGUgaW4gdGhlIHJldmVyc2Ugb3JkZXIgc2luY2UgaXRlbXMgYXQgdGhlIGVuZCBvZlxuICAgIC8vIHRoZSBsaXN0IGhhdmUgYW4gaGlnaGVyIHotaW5kZXgsIHRodXMgc2hvdWxkIGJlIHBpY2tlZCBmaXJzdC5cblxuICAgIGZvciAoaSA9IGxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgc3RhdGUgPSBsYWJlbHNbaV0uJGxheW91dDtcblxuICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLl92aXNpYmxlICYmIHN0YXRlLl9ib3guY29udGFpbnMocG9pbnQpKSB7XG4gICAgICAgIHJldHVybiBsYWJlbHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZHJhdzogZnVuY3Rpb24oY2hhcnQsIGxhYmVscykge1xuICAgIHZhciBpLCBpbGVuLCBsYWJlbCwgc3RhdGUsIGdlb21ldHJ5LCBjZW50ZXI7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgICBzdGF0ZSA9IGxhYmVsLiRsYXlvdXQ7XG5cbiAgICAgIGlmIChzdGF0ZS5fdmlzaWJsZSkge1xuICAgICAgICBnZW9tZXRyeSA9IGxhYmVsLmdlb21ldHJ5KCk7XG4gICAgICAgIGNlbnRlciA9IGNvb3JkaW5hdGVzKGxhYmVsLl9lbCwgbGFiZWwubW9kZWwoKSwgZ2VvbWV0cnkpO1xuICAgICAgICBzdGF0ZS5fYm94LnVwZGF0ZShjZW50ZXIsIGdlb21ldHJ5LCBsYWJlbC5yb3RhdGlvbigpKTtcbiAgICAgICAgbGFiZWwuZHJhdyhjaGFydCwgY2VudGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBmb3JtYXR0ZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoaGVscGVycy5pc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxhYmVsID0gdmFsdWU7XG4gIHZhciBrZXlzLCBrbGVuLCBrO1xuICBpZiAoaGVscGVycy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICBpZiAoIWhlbHBlcnMuaXNOdWxsT3JVbmRlZih2YWx1ZS5sYWJlbCkpIHtcbiAgICAgIGxhYmVsID0gdmFsdWUubGFiZWw7XG4gICAgfSBlbHNlIGlmICghaGVscGVycy5pc051bGxPclVuZGVmKHZhbHVlLnIpKSB7XG4gICAgICBsYWJlbCA9IHZhbHVlLnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsID0gJyc7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgZm9yIChrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICAgIGxhYmVsICs9IChrICE9PSAwID8gJywgJyA6ICcnKSArIGtleXNba10gKyAnOiAnICsgdmFsdWVba2V5c1trXV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnICsgbGFiZWw7XG59O1xuXG4vKipcbiAqIElNUE9SVEFOVDogbWFrZSBzdXJlIHRvIGFsc28gdXBkYXRlIHRlc3RzIGFuZCBUeXBlU2NyaXB0IGRlZmluaXRpb25cbiAqIGZpbGVzIChgL3Rlc3Qvc3BlY3MvZGVmYXVsdHMuc3BlYy5qc2AgYW5kIGAvdHlwZXMvb3B0aW9ucy5kLnRzYClcbiAqL1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFsaWduOiAnY2VudGVyJyxcbiAgYW5jaG9yOiAnY2VudGVyJyxcbiAgYmFja2dyb3VuZENvbG9yOiBudWxsLFxuICBib3JkZXJDb2xvcjogbnVsbCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJXaWR0aDogMCxcbiAgY2xhbXA6IGZhbHNlLFxuICBjbGlwOiBmYWxzZSxcbiAgY29sb3I6IHVuZGVmaW5lZCxcbiAgZGlzcGxheTogdHJ1ZSxcbiAgZm9udDoge1xuICAgIGZhbWlseTogdW5kZWZpbmVkLFxuICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgICB3ZWlnaHQ6IG51bGxcbiAgfSxcbiAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gIGxhYmVsczogdW5kZWZpbmVkLFxuICBsaXN0ZW5lcnM6IHt9LFxuICBvZmZzZXQ6IDQsXG4gIG9wYWNpdHk6IDEsXG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDQsXG4gICAgcmlnaHQ6IDQsXG4gICAgYm90dG9tOiA0LFxuICAgIGxlZnQ6IDRcbiAgfSxcbiAgcm90YXRpb246IDAsXG4gIHRleHRBbGlnbjogJ3N0YXJ0JyxcbiAgdGV4dFN0cm9rZUNvbG9yOiB1bmRlZmluZWQsXG4gIHRleHRTdHJva2VXaWR0aDogMCxcbiAgdGV4dFNoYWRvd0JsdXI6IDAsXG4gIHRleHRTaGFkb3dDb2xvcjogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNzZcbiAqL1xuXG52YXIgRVhQQU5ET19LRVkgPSAnJGRhdGFsYWJlbHMnO1xudmFyIERFRkFVTFRfS0VZID0gJyRkZWZhdWx0JztcblxuZnVuY3Rpb24gY29uZmlndXJlKGRhdGFzZXQsIG9wdGlvbnMpIHtcbiAgdmFyIG92ZXJyaWRlID0gZGF0YXNldC5kYXRhbGFiZWxzO1xuICB2YXIgbGlzdGVuZXJzID0ge307XG4gIHZhciBjb25maWdzID0gW107XG4gIHZhciBsYWJlbHMsIGtleXM7XG5cbiAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xuICAgIG92ZXJyaWRlID0ge307XG4gIH1cblxuICBvcHRpb25zID0gaGVscGVycy5tZXJnZSh7fSwgW29wdGlvbnMsIG92ZXJyaWRlXSk7XG4gIGxhYmVscyA9IG9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICBrZXlzID0gT2JqZWN0LmtleXMobGFiZWxzKTtcbiAgZGVsZXRlIG9wdGlvbnMubGFiZWxzO1xuXG4gIGlmIChrZXlzLmxlbmd0aCkge1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChsYWJlbHNba2V5XSkge1xuICAgICAgICBjb25maWdzLnB1c2goaGVscGVycy5tZXJnZSh7fSwgW1xuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgbGFiZWxzW2tleV0sXG4gICAgICAgICAge19rZXk6IGtleX1cbiAgICAgICAgXSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIERlZmF1bHQgbGFiZWwgaWYgbm8gXCJuYW1lZFwiIGxhYmVsIGRlZmluZWQuXG4gICAgY29uZmlncy5wdXNoKG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gbGlzdGVuZXJzOiB7PGV2ZW50LXR5cGU+OiB7PGxhYmVsLWtleT46IDxmbj59fVxuICBsaXN0ZW5lcnMgPSBjb25maWdzLnJlZHVjZShmdW5jdGlvbih0YXJnZXQsIGNvbmZpZykge1xuICAgIGhlbHBlcnMuZWFjaChjb25maWcubGlzdGVuZXJzIHx8IHt9LCBmdW5jdGlvbihmbiwgZXZlbnQpIHtcbiAgICAgIHRhcmdldFtldmVudF0gPSB0YXJnZXRbZXZlbnRdIHx8IHt9O1xuICAgICAgdGFyZ2V0W2V2ZW50XVtjb25maWcuX2tleSB8fCBERUZBVUxUX0tFWV0gPSBmbjtcbiAgICB9KTtcblxuICAgIGRlbGV0ZSBjb25maWcubGlzdGVuZXJzO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sIHt9KTtcblxuICByZXR1cm4ge1xuICAgIGxhYmVsczogY29uZmlncyxcbiAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICB9O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBsaXN0ZW5lcnMsIGxhYmVsLCBldmVudCkge1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0gbGFiZWwuJGNvbnRleHQ7XG4gIHZhciBncm91cHMgPSBsYWJlbC4kZ3JvdXBzO1xuICB2YXIgY2FsbGJhY2s7XG5cbiAgaWYgKCFsaXN0ZW5lcnNbZ3JvdXBzLl9zZXRdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY2FsbGJhY2sgPSBsaXN0ZW5lcnNbZ3JvdXBzLl9zZXRdW2dyb3Vwcy5fa2V5XTtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChoZWxwZXJzLmNhbGxiYWNrKGNhbGxiYWNrLCBbY29udGV4dCwgZXZlbnRdKSA9PT0gdHJ1ZSkge1xuICAgIC8vIFVzZXJzIGFyZSBhbGxvd2VkIHRvIHR3ZWFrIHRoZSBnaXZlbiBjb250ZXh0IGJ5IGluamVjdGluZyB2YWx1ZXMgdGhhdCBjYW4gYmVcbiAgICAvLyB1c2VkIGluIHNjcmlwdGFibGUgb3B0aW9ucyB0byBkaXNwbGF5IGxhYmVscyBkaWZmZXJlbnRseSBiYXNlZCBvbiB0aGUgY3VycmVudFxuICAgIC8vIGV2ZW50IChlLmcuIGhpZ2hsaWdodCBhbiBob3ZlcmVkIGxhYmVsKS4gVGhhdCdzIHdoeSB3ZSB1cGRhdGUgdGhlIGxhYmVsIHdpdGhcbiAgICAvLyB0aGUgb3V0cHV0IGNvbnRleHQgYW5kIHNjaGVkdWxlIGEgbmV3IGNoYXJ0IHJlbmRlciBieSBzZXR0aW5nIGl0IGRpcnR5LlxuICAgIGNoYXJ0W0VYUEFORE9fS0VZXS5fZGlydHkgPSB0cnVlO1xuICAgIGxhYmVsLnVwZGF0ZShjb250ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaE1vdmVFdmVudHMoY2hhcnQsIGxpc3RlbmVycywgcHJldmlvdXMsIGxhYmVsLCBldmVudCkge1xuICB2YXIgZW50ZXIsIGxlYXZlO1xuXG4gIGlmICghcHJldmlvdXMgJiYgIWxhYmVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFwcmV2aW91cykge1xuICAgIGVudGVyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICghbGFiZWwpIHtcbiAgICBsZWF2ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAocHJldmlvdXMgIT09IGxhYmVsKSB7XG4gICAgbGVhdmUgPSBlbnRlciA9IHRydWU7XG4gIH1cblxuICBpZiAobGVhdmUpIHtcbiAgICBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBsaXN0ZW5lcnMubGVhdmUsIHByZXZpb3VzLCBldmVudCk7XG4gIH1cbiAgaWYgKGVudGVyKSB7XG4gICAgZGlzcGF0Y2hFdmVudChjaGFydCwgbGlzdGVuZXJzLmVudGVyLCBsYWJlbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1vdmVFdmVudHMoY2hhcnQsIGV2ZW50KSB7XG4gIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICB2YXIgbGlzdGVuZXJzID0gZXhwYW5kby5fbGlzdGVuZXJzO1xuICB2YXIgcHJldmlvdXMsIGxhYmVsO1xuXG4gIGlmICghbGlzdGVuZXJzLmVudGVyICYmICFsaXN0ZW5lcnMubGVhdmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICBsYWJlbCA9IGxheW91dC5sb29rdXAoZXhwYW5kby5fbGFiZWxzLCBldmVudCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQudHlwZSAhPT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByZXZpb3VzID0gZXhwYW5kby5faG92ZXJlZDtcbiAgZXhwYW5kby5faG92ZXJlZCA9IGxhYmVsO1xuICBkaXNwYXRjaE1vdmVFdmVudHMoY2hhcnQsIGxpc3RlbmVycywgcHJldmlvdXMsIGxhYmVsLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrRXZlbnRzKGNoYXJ0LCBldmVudCkge1xuICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgdmFyIGhhbmRsZXJzID0gZXhwYW5kby5fbGlzdGVuZXJzLmNsaWNrO1xuICB2YXIgbGFiZWwgPSBoYW5kbGVycyAmJiBsYXlvdXQubG9va3VwKGV4cGFuZG8uX2xhYmVscywgZXZlbnQpO1xuICBpZiAobGFiZWwpIHtcbiAgICBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBoYW5kbGVycywgbGFiZWwsIGV2ZW50KTtcbiAgfVxufVxuXG52YXIgcGx1Z2luID0ge1xuICBpZDogJ2RhdGFsYWJlbHMnLFxuXG4gIGRlZmF1bHRzOiBkZWZhdWx0cyxcblxuICBiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuICAgIGNoYXJ0W0VYUEFORE9fS0VZXSA9IHtcbiAgICAgIF9hY3RpdmVzOiBbXVxuICAgIH07XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuICAgIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICAgIGV4cGFuZG8uX2xpc3RlbmVkID0gZmFsc2U7XG4gICAgZXhwYW5kby5fbGlzdGVuZXJzID0ge307ICAgICAvLyB7PGV2ZW50LXR5cGU+OiB7PGRhdGFzZXQtaW5kZXg+OiB7PGxhYmVsLWtleT46IDxmbj59fX1cbiAgICBleHBhbmRvLl9kYXRhc2V0cyA9IFtdOyAgICAgIC8vIHBlciBkYXRhc2V0IGxhYmVsczogW0xhYmVsW11dXG4gICAgZXhwYW5kby5fbGFiZWxzID0gW107ICAgICAgICAvLyBsYXlvdXRlZCBsYWJlbHM6IExhYmVsW11cbiAgfSxcblxuICBhZnRlckRhdGFzZXRVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgdmFyIGRhdGFzZXRJbmRleCA9IGFyZ3MuaW5kZXg7XG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gICAgdmFyIGxhYmVscyA9IGV4cGFuZG8uX2RhdGFzZXRzW2RhdGFzZXRJbmRleF0gPSBbXTtcbiAgICB2YXIgdmlzaWJsZSA9IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KTtcbiAgICB2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICB2YXIgY29uZmlnID0gY29uZmlndXJlKGRhdGFzZXQsIG9wdGlvbnMpO1xuICAgIHZhciBlbGVtZW50cyA9IGFyZ3MubWV0YS5kYXRhIHx8IFtdO1xuICAgIHZhciBjdHggPSBjaGFydC5jdHg7XG4gICAgdmFyIGksIGosIGlsZW4sIGpsZW4sIGNmZywga2V5LCBlbCwgbGFiZWw7XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgZWwgPSBlbGVtZW50c1tpXTtcbiAgICAgIGVsW0VYUEFORE9fS0VZXSA9IFtdO1xuXG4gICAgICBpZiAodmlzaWJsZSAmJiBlbCAmJiBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSAmJiAhZWwuc2tpcCkge1xuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gY29uZmlnLmxhYmVscy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBjZmcgPSBjb25maWcubGFiZWxzW2pdO1xuICAgICAgICAgIGtleSA9IGNmZy5fa2V5O1xuXG4gICAgICAgICAgbGFiZWwgPSBuZXcgTGFiZWwoY2ZnLCBjdHgsIGVsLCBpKTtcbiAgICAgICAgICBsYWJlbC4kZ3JvdXBzID0ge1xuICAgICAgICAgICAgX3NldDogZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgX2tleToga2V5IHx8IERFRkFVTFRfS0VZXG4gICAgICAgICAgfTtcbiAgICAgICAgICBsYWJlbC4kY29udGV4dCA9IHtcbiAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBjaGFydDogY2hhcnQsXG4gICAgICAgICAgICBkYXRhSW5kZXg6IGksXG4gICAgICAgICAgICBkYXRhc2V0OiBkYXRhc2V0LFxuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXhcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbGFiZWwudXBkYXRlKGxhYmVsLiRjb250ZXh0KTtcbiAgICAgICAgICBlbFtFWFBBTkRPX0tFWV0ucHVzaChsYWJlbCk7XG4gICAgICAgICAgbGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcblxuICAgIC8vIFN0b3JlIGxpc3RlbmVycyBhdCB0aGUgY2hhcnQgbGV2ZWwgYW5kIHBlciBldmVudCB0eXBlIHRvIG9wdGltaXplXG4gICAgLy8gY2FzZXMgd2hlcmUgbm8gbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGZvciBhIHNwZWNpZmljIGV2ZW50LlxuICAgIGhlbHBlcnMubWVyZ2UoZXhwYW5kby5fbGlzdGVuZXJzLCBjb25maWcubGlzdGVuZXJzLCB7XG4gICAgICBtZXJnZXI6IGZ1bmN0aW9uKGV2ZW50LCB0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICB0YXJnZXRbZXZlbnRdID0gdGFyZ2V0W2V2ZW50XSB8fCB7fTtcbiAgICAgICAgdGFyZ2V0W2V2ZW50XVthcmdzLmluZGV4XSA9IHNvdXJjZVtldmVudF07XG4gICAgICAgIGV4cGFuZG8uX2xpc3RlbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBhZnRlclVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICBjaGFydFtFWFBBTkRPX0tFWV0uX2xhYmVscyA9IGxheW91dC5wcmVwYXJlKGNoYXJ0W0VYUEFORE9fS0VZXS5fZGF0YXNldHMpO1xuICB9LFxuXG4gIC8vIERyYXcgbGFiZWxzIG9uIHRvcCBvZiBhbGwgZGF0YXNldCBlbGVtZW50c1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy8yOVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy8zMlxuICBhZnRlckRhdGFzZXRzRHJhdzogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICBsYXlvdXQuZHJhdyhjaGFydCwgY2hhcnRbRVhQQU5ET19LRVldLl9sYWJlbHMpO1xuICB9LFxuXG4gIGJlZm9yZUV2ZW50OiBmdW5jdGlvbihjaGFydCwgYXJncykge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGxpc3RlbmVyIHJlZ2lzdGVyZWQgZm9yIHRoaXMgY2hhcnQsIGBsaXN0ZW5lZGAgd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBtZWFuaW5nIHdlIGNhbiBpbW1lZGlhdGVseSBpZ25vcmUgdGhlIGluY29taW5nIGV2ZW50IGFuZCBhdm9pZCB1c2VsZXNzIGV4dHJhXG4gICAgLy8gY29tcHV0YXRpb24gZm9yIHVzZXJzIHdobyBkb24ndCBpbXBsZW1lbnQgbGFiZWwgaW50ZXJhY3Rpb25zLlxuICAgIGlmIChjaGFydFtFWFBBTkRPX0tFWV0uX2xpc3RlbmVkKSB7XG4gICAgICB2YXIgZXZlbnQgPSBhcmdzLmV2ZW50O1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgY2FzZSAnbW91c2VvdXQnOlxuICAgICAgICBoYW5kbGVNb3ZlRXZlbnRzKGNoYXJ0LCBldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICBoYW5kbGVDbGlja0V2ZW50cyhjaGFydCwgZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJFdmVudDogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgICB2YXIgcHJldmlvdXMgPSBleHBhbmRvLl9hY3RpdmVzO1xuICAgIHZhciBhY3RpdmVzID0gZXhwYW5kby5fYWN0aXZlcyA9IGNoYXJ0LmdldEFjdGl2ZUVsZW1lbnRzKCk7XG4gICAgdmFyIHVwZGF0ZXMgPSB1dGlscy5hcnJheURpZmYocHJldmlvdXMsIGFjdGl2ZXMpO1xuICAgIHZhciBpLCBpbGVuLCBqLCBqbGVuLCB1cGRhdGUsIGxhYmVsLCBsYWJlbHM7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdXBkYXRlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZXNbaV07XG4gICAgICBpZiAodXBkYXRlWzFdKSB7XG4gICAgICAgIGxhYmVscyA9IHVwZGF0ZVswXS5lbGVtZW50W0VYUEFORE9fS0VZXSB8fCBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVscy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBsYWJlbCA9IGxhYmVsc1tqXTtcbiAgICAgICAgICBsYWJlbC4kY29udGV4dC5hY3RpdmUgPSAodXBkYXRlWzFdID09PSAxKTtcbiAgICAgICAgICBsYWJlbC51cGRhdGUobGFiZWwuJGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4cGFuZG8uX2RpcnR5IHx8IHVwZGF0ZXMubGVuZ3RoKSB7XG4gICAgICBsYXlvdXQudXBkYXRlKGV4cGFuZG8uX2xhYmVscyk7XG4gICAgICBjaGFydC5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgZXhwYW5kby5fZGlydHk7XG4gIH1cbn07XG5cbnJldHVybiBwbHVnaW47XG5cbn0pKTtcbiIsICIvLyBXZSBpbXBvcnQgdGhlIENTUyB3aGljaCBpcyBleHRyYWN0ZWQgdG8gaXRzIG93biBmaWxlIGJ5IGVzYnVpbGQuXHJcbi8vIFJlbW92ZSB0aGlzIGxpbmUgaWYgeW91IGFkZCBhIHlvdXIgb3duIENTUyBidWlsZCBwaXBlbGluZSAoZS5nIHBvc3Rjc3MpLlxyXG5pbXBvcnQgXCIuLi9jc3MvYXBwLmNzc1wiO1xyXG5cclxuaW1wb3J0IFwiLi9Cb2FyZENvbnRyb2xlLmpzXCI7XHJcblxyXG5pbXBvcnQgXCJ0b20tc2VsZWN0XCI7XHJcbmltcG9ydCB7IGFkZFJvdywgaGF2ZUxpbmVOb3RTYXZlZCB9IGZyb20gXCIuL3RvbV9zZWxlY3Rfc2Fpc2llX3BhZ2UuanNcIjtcclxuaW1wb3J0IFRvbVNlbGVjdCBmcm9tIFwidG9tLXNlbGVjdFwiO1xyXG5pbXBvcnQgeyBkZXNhY3RpdmF0ZUFsbGlucHV0cywgc2hvd1Rhc2sgfSBmcm9tIFwiLi9zaG93aW5nX3Rhc2suanNcIjtcclxuXHJcbi8vaW1wb3J0IFwiLi90YWJsZV9zYWlzaWVfdGVtcF9jb250cm9sZS5qc1wiXHJcblxyXG4vLyBJZiB5b3Ugd2FudCB0byB1c2UgUGhvZW5peCBjaGFubmVscywgcnVuIGBtaXggaGVscCBwaHguZ2VuLmNoYW5uZWxgXHJcbi8vIHRvIGdldCBzdGFydGVkIGFuZCB0aGVuIHVuY29tbWVudCB0aGUgbGluZSBiZWxvdy5cclxuLy8gaW1wb3J0IFwiLi91c2VyX3NvY2tldC5qc1wiXHJcblxyXG4vLyBZb3UgY2FuIGluY2x1ZGUgZGVwZW5kZW5jaWVzIGluIHR3byB3YXlzLlxyXG4vL1xyXG4vLyBUaGUgc2ltcGxlc3Qgb3B0aW9uIGlzIHRvIHB1dCB0aGVtIGluIGFzc2V0cy92ZW5kb3IgYW5kXHJcbi8vIGltcG9ydCB0aGVtIHVzaW5nIHJlbGF0aXZlIHBhdGhzOlxyXG4vL1xyXG4vLyAgICAgaW1wb3J0IFwiLi4vdmVuZG9yL3NvbWUtcGFja2FnZS5qc1wiXHJcbi8vXHJcbi8vIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gYG5wbSBpbnN0YWxsIHNvbWUtcGFja2FnZSAtLXByZWZpeCBhc3NldHNgIGFuZCBpbXBvcnRcclxuLy8gdGhlbSB1c2luZyBhIHBhdGggc3RhcnRpbmcgd2l0aCB0aGUgcGFja2FnZSBuYW1lOlxyXG4vL1xyXG4vLyAgICAgaW1wb3J0IFwic29tZS1wYWNrYWdlXCJcclxuLy9cclxuXHJcbnJlcXVpcmUoXCJib290c3RyYXAtaWNvbnMvZm9udC9ib290c3RyYXAtaWNvbnMuY3NzXCIpO1xyXG5yZXF1aXJlKFwibWF0ZXJpYWwtaWNvbnMvaWNvbmZvbnQvbWF0ZXJpYWwtaWNvbnMuY3NzXCIpO1xyXG5cclxuLy8gaW1wb3J0ICdib290c3RyYXAtaWNvbnMvZm9udC9ib290c3RyYXAtaWNvbnMuY3NzJztcclxuLy8gaW1wb3J0ICdtYXRlcmlhbC1pY29ucy9pY29uZm9udC9tYXRlcmlhbC1pY29ucy5jc3MnO1xyXG5cclxuLy8gSW5jbHVkZSBwaG9lbml4X2h0bWwgdG8gaGFuZGxlIG1ldGhvZD1QVVQvREVMRVRFIGluIGZvcm1zIGFuZCBidXR0b25zLlxyXG5pbXBvcnQgXCJwaG9lbml4X2h0bWxcIjtcclxuLy8gRXN0YWJsaXNoIFBob2VuaXggU29ja2V0IGFuZCBMaXZlVmlldyBjb25maWd1cmF0aW9uLlxyXG5pbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwicGhvZW5peFwiO1xyXG5pbXBvcnQgeyBMaXZlU29ja2V0IH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCI7XHJcbmltcG9ydCB7IFNvcnRhYmxlLCBQbHVnaW5zIH0gZnJvbSBcIkBzaG9waWZ5L2RyYWdnYWJsZVwiO1xyXG5pbXBvcnQgdG9wYmFyIGZyb20gXCIuLi92ZW5kb3IvdG9wYmFyXCI7XHJcbmltcG9ydCB7XHJcbiAgRG91Z2hOdXRDaGFydCxcclxuICBIb3Jpem9udGFsQmFyQ2hhcnQsXHJcbiAgU3RhY2tlZEJhckNoYXJ0LFxyXG4gIExpbmVDaGFydCxcclxuICBTdXJ2ZXlDaGFydCxcclxufSBmcm9tIFwiLi9jaGFydC5qc1wiO1xyXG5pbXBvcnQgY2hhcnQgZnJvbSBcImNoYXJ0LmpzL2Rpc3QvY2hhcnRcIjtcclxuXHJcbi8qXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gVlx1MDBFOXJpZmllciBzaSBsZXMgXHUwMEU5bFx1MDBFOW1lbnRzIGV4aXN0ZW50IHN1ciBsYSBwYWdlXHJcbiAgY29uc3QgdGFibGVCb2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlY29yZC10YWJsZS1ib2R5Jyk7XHJcbiAgY29uc3QgYWRkUm93TGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhZGRSb3dJY29uJyk7XHJcbiAgY29uc3QgZGF0YUNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkYXRhLWNvbnRhaW5lcicpO1xyXG5cclxuICAvLyBWXHUwMEU5cmlmaWVyIHNpIGxlcyBcdTAwRTlsXHUwMEU5bWVudHMgblx1MDBFOWNlc3NhaXJlcyBleGlzdGVudFxyXG4gIGlmICh0YWJsZUJvZHkgJiYgYWRkUm93TGluayAmJiBkYXRhQ29udGFpbmVyKSB7XHJcbiAgICAvLyBSXHUwMEU5Y3VwXHUwMEU5cmVyIGxlcyBkb25uXHUwMEU5ZXMgdW5pcXVlbWVudCBzaSBsZXMgXHUwMEU5bFx1MDBFOW1lbnRzIGV4aXN0ZW50XHJcbiAgICBjb25zdCB1c2VySWQgPSBkYXRhQ29udGFpbmVyLmRhdGFzZXQudXNlcklkO1xyXG4gICAgLy9jb25zb2xlLmxvZyh1c2VySWQpXHJcbiAgICBjb25zdCBkYXRlID0gZGF0YUNvbnRhaW5lci5kYXRhc2V0LnRvZGF5O1xyXG4gICAgLy9jb25zb2xlLmxvZyhkYXRlKVxyXG4gICAgY29uc3QgdXNlcm5hbWUgPSBkYXRhQ29udGFpbmVyLmRhdGFzZXQudXNlcm5hbWU7XHJcbiAgICAvL2NvbnNvbGUubG9nKHVzZXJuYW1lKVxyXG4gICAgLy9jb25zb2xlLmxvZyhkYXRhQ29udGFpbmVyLmRhdGFzZXQucHJvamVjdHMpXHJcbiAgICBjb25zdCBwcm9qZWN0cyA9IEpTT04ucGFyc2UoZGF0YUNvbnRhaW5lci5kYXRhc2V0LnByb2plY3RzKTtcclxuICAgIC8vY29uc29sZS5sb2cocHJvamVjdHMpXHJcblxyXG4gICAgLy8gQWpvdXRlciB1biBcdTAwRTljb3V0ZXVyIGQnXHUwMEU5dlx1MDBFOW5lbWVudHMgdW5pcXVlbWVudCBzaSBsJ2ljXHUwMEY0bmUgZCdham91dCBkZSBsaWduZSBleGlzdGVcclxuICAgIGFkZFJvd0xpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICBsaW5lTm90U2F2ZWQgPSBoYXZlTGluZU5vdFNhdmVkKHRhYmxlQm9keSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGxpbmVOb3RTYXZlZCk7XHJcbiAgICAgIGlmICghbGluZU5vdFNhdmVkKSB7XHJcbiAgICAgICAgYWRkUm93KHRhYmxlQm9keSwgVG9tU2VsZWN0LCB1c2VySWQsIGRhdGUsIHVzZXJuYW1lLCBwcm9qZWN0cyk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgIHZhciBhZGRSb3dJY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2FkZFJvd0ljb24gaScpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGFkZFJvd0ljb24pO1xyXG4gICAgICAgIGFkZFJvd0xpbmsuY2xhc3NMaXN0LmFkZCgnbm9uLWNsaXF1YWJsZScpO1xyXG4gICAgICAgIGFkZFJvd0ljb24uc3R5bGUuY3Vyc29yID0gJ25vdC1hbGxvd2VkJztcclxuXHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuXHJcblxyXG59KTtcclxuKi9cclxuY29uc3QgSG9va3MgPSB7fTtcclxuXHJcbi8vIEhvb2tzLkRvdWdoTnV0Q2hhcnQgPSB7XHJcbi8vICAgbW91bnRlZCgpIHtcclxuLy8gICAgIGNvbnN0IHsgbGFiZWxzX3Rhc2tzX2J5X2NvbnRyaWJ1dG9ycywgdmFsdWVzX3Rhc2tzX2J5X2NvbnRyaWJ1dG9ycyB9ID0gSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQuY2hhcnREYXRhKVxyXG4vLyAgICAgdGhpcy5jaGFydCA9IG5ldyBEb3VnaE51dENoYXJ0KHRoaXMuZWwsIGxhYmVsc190YXNrc19ieV9jb250cmlidXRvcnMsIHZhbHVlc190YXNrc19ieV9jb250cmlidXRvcnMpXHJcbi8vICAgfVxyXG4vLyB9XHJcblxyXG4vL2hvb2tzIHBvdXIgZ2VyZXIgbGVzIHNhaXNpZSBkZSB0ZW1wc1xyXG4vL25iIDogdXRpbGlzZXIgcGFyIGxhIHBhZ2Ugc2Fpc2llX2luZGV4Lmh0bWwgLCBzYWlzaWVfZGV0YWlscy5odG1sXHJcblxyXG5Ib29rcy5zYWlzaWVBY3Rpb24gPSB7XHJcbiAgbW91bnRlZCgpIHtcclxuICAgIGNvbnN0IHRhYmxlQm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVjb3JkLXRhYmxlLWJvZHlcIik7XHJcbiAgICBjb25zdCBhZGRSb3dMaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZGRSb3dJY29uXCIpO1xyXG4gICAgY29uc3QgZGF0YUNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGF0YS1jb250YWluZXJcIik7XHJcbiAgICAvLyBWXHUwMEU5cmlmaWVyIHNpIGxlcyBcdTAwRTlsXHUwMEU5bWVudHMgblx1MDBFOWNlc3NhaXJlcyBleGlzdGVudFxyXG4gICAgaWYgKHRhYmxlQm9keSAmJiBhZGRSb3dMaW5rICYmIGRhdGFDb250YWluZXIpIHtcclxuICAgICAgLy8gUlx1MDBFOWN1cFx1MDBFOXJlciBsZXMgZG9ublx1MDBFOWVzIHVuaXF1ZW1lbnQgc2kgbGVzIFx1MDBFOWxcdTAwRTltZW50cyBleGlzdGVudFxyXG4gICAgICBjb25zdCB1c2VySWQgPSBkYXRhQ29udGFpbmVyLmRhdGFzZXQudXNlcklkO1xyXG4gICAgICAvL2NvbnNvbGUubG9nKHVzZXJJZClcclxuICAgICAgY29uc3QgZGF0ZSA9IGRhdGFDb250YWluZXIuZGF0YXNldC50b2RheTtcclxuICAgICAgLy9jb25zb2xlLmxvZyhkYXRlKVxyXG4gICAgICBjb25zdCB1c2VybmFtZSA9IGRhdGFDb250YWluZXIuZGF0YXNldC51c2VybmFtZTtcclxuICAgICAgLy9jb25zb2xlLmxvZyh1c2VybmFtZSlcclxuICAgICAgLy9jb25zb2xlLmxvZyhkYXRhQ29udGFpbmVyLmRhdGFzZXQucHJvamVjdHMpXHJcbiAgICAgIGNvbnN0IHByb2plY3RzID0gSlNPTi5wYXJzZShkYXRhQ29udGFpbmVyLmRhdGFzZXQucHJvamVjdHMpO1xyXG4gICAgICAvL2NvbnNvbGUubG9nKHByb2plY3RzKVxyXG5cclxuICAgICAgLy8gQWpvdXRlciB1biBcdTAwRTljb3V0ZXVyIGQnXHUwMEU5dlx1MDBFOW5lbWVudHMgdW5pcXVlbWVudCBzaSBsJ2ljXHUwMEY0bmUgZCdham91dCBkZSBsaWduZSBleGlzdGVcclxuICAgICAgYWRkUm93TGluay5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxpbmVOb3RTYXZlZCA9IGhhdmVMaW5lTm90U2F2ZWQodGFibGVCb2R5KTtcclxuICAgICAgICBjb25zb2xlLmxvZyhsaW5lTm90U2F2ZWQpO1xyXG4gICAgICAgIGlmICghbGluZU5vdFNhdmVkKSB7XHJcbiAgICAgICAgICBhZGRSb3codGFibGVCb2R5LCBUb21TZWxlY3QsIHVzZXJJZCwgZGF0ZSwgdXNlcm5hbWUsIHByb2plY3RzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIGFkZFJvd0ljb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2FkZFJvd0ljb24gaVwiKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGFkZFJvd0ljb24pO1xyXG4gICAgICAgICAgYWRkUm93TGluay5jbGFzc0xpc3QuYWRkKFwibm9uLWNsaXF1YWJsZVwiKTtcclxuICAgICAgICAgIGFkZFJvd0ljb24uc3R5bGUuY3Vyc29yID0gXCJub3QtYWxsb3dlZFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuXHJcbi8vaG9va3M6IGdlc3Rpb24gZGUgbCdhZmZpY2hhZ2UgZGUgbGEgZGV0YWlscyBwYWdlc1xyXG5cclxuSG9va3Muc2hvd1Rhc2sgPSB7XHJcbiAgbW91bnRlZCgpIHtcclxuICAgIGRlc2FjdGl2YXRlQWxsaW5wdXRzKCk7XHJcbiAgICBjb25zdCBwcm9maWxlID0gdGhpcy5lbC5kYXRhc2V0LnByb2ZpbGU7XHJcbiAgICBjb25zb2xlLmxvZyhwcm9maWxlKTtcclxuICAgIHNob3dUYXNrKHByb2ZpbGUpO1xyXG4gIH0sXHJcbiAgdXBkYXRlZCgpIHtcclxuICAgIGRlc2FjdGl2YXRlQWxsaW5wdXRzKCk7XHJcbiAgfSxcclxufTtcclxuXHJcbi8qIGhvb2tzIHBob2VuaXggcG91ciBsZXMgY2hhbmdlbWVudCBjb3VsZXVyIGRlcyBsaWduZXMgc3Vydm9sXHUwMEU5XHJcbm1ldHRyZSBjZXR0ZSBob29rcyBlbiBhdHRyaWJ1dCBkdSBiYWxpc2UgPHRhYmxlPjwvdGFibGU+IHNpIGxlIHRhYmxlIGEgYmVzb2luIGRlIGNldHRlIGZvbmN0aW9uYWxpdFx1MDBFOVxyXG5OQiA6IGEgbWV0dHJlIHVuaXF1ZW1lbnQgc3VyIHVuZSBlbGVtZW50IGh0bWwgdGFibGVcclxuXHJcbiovXHJcblxyXG5Ib29rcy50YWJsZUhvdmVyID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuZWw7IC8vIFJcdTAwRTljdXBcdTAwRTlyZXIgbGEgdGFibGUgXHUwMEUwIHBhcnRpciBkZSB0aGlzLmVsXHJcblxyXG4gICAgdGFibGUucXVlcnlTZWxlY3RvckFsbChcInRib2R5IHRyXCIpLmZvckVhY2goKHJvdykgPT4ge1xyXG4gICAgICBsZXQgY3VycmVudENvbG9yID0gXCJcIjtcclxuXHJcbiAgICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsICgpID0+IHtcclxuICAgICAgICBjdXJyZW50Q29sb3IgPSByb3cuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIHJvdy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiM2MGIwZjBcIjtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsICgpID0+IHtcclxuICAgICAgICByb3cuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY3VycmVudENvbG9yO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbn07XHJcblxyXG5Ib29rcy5DdXN0b21TYW1wbGVTZWxlY3QgPSB7XHJcbiAgbW91bnRlZCgpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiQ3VzdG9tU2FtcGxlU2VsZWN0IGhvb2sgaW5pdGlhbGl6ZWRcIik7XHJcblxyXG4gICAgLy8gUlx1MDBFOWN1cFx1MDBFOXJlciBsJ1x1MDBFOWxcdTAwRTltZW50IHNlbGVjdFxyXG4gICAgdmFyIHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15U2VsZWN0XCIpO1xyXG5cclxuICAgIC8vIEFzc3VyZXotdm91cyBxdWUgbCdcdTAwRTlsXHUwMEU5bWVudCBzZWxlY3QgZXN0IHJlbmR1IGRhbnMgbGUgRE9NXHJcbiAgICBpZiAoc2VsZWN0RWxlbWVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkVsZW1lbnQgZm91bmQ6XCIsIHNlbGVjdEVsZW1lbnQpO1xyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZXogVG9tU2VsZWN0IGF2ZWMgbCdcdTAwRTlsXHUwMEU5bWVudCBzZWxlY3QgcydpbCBuJ2V4aXN0ZSBwYXMgZFx1MDBFOWpcdTAwRTAgZCdpbnN0YW5jZVxyXG4gICAgICBpZiAoIXNlbGVjdEVsZW1lbnQudG9tc2VsZWN0KSB7XHJcbiAgICAgICAgc2VsZWN0RWxlbWVudC50b21zZWxlY3QgPSBuZXcgVG9tU2VsZWN0KHNlbGVjdEVsZW1lbnQsIHtcclxuICAgICAgICAgIC8vIENvbmZpZ3VyYXRpb25zIGRlIFRvbVNlbGVjdCBpY2lcclxuICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXHJcbiAgICAgICAgICBzb3J0RmllbGQ6IHtcclxuICAgICAgICAgICAgZmllbGQ6IFwidGV4dFwiLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiYXNjXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVG9tU2VsZWN0IG9wdGlvbnM6XCIsIHNlbGVjdEVsZW1lbnQudG9tc2VsZWN0Lm9wdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiU2VsZWN0IGVsZW1lbnQgbm90IGZvdW5kXCIpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgdXBkYXRlZCgpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiQ3VzdG9tU2FtcGxlU2VsZWN0IGhvb2sgdXBkYXRlZFwiKTtcclxuXHJcbiAgICAvLyBSXHUwMEU5Y3VwXHUwMEU5cmVyIGwnXHUwMEU5bFx1MDBFOW1lbnQgc2VsZWN0XHJcbiAgICB2YXIgc2VsZWN0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlTZWxlY3RcIik7XHJcblxyXG4gICAgLy8gVlx1MDBFOXJpZmlleiBzaSB1bmUgaW5zdGFuY2UgZGUgVG9tU2VsZWN0IGVzdCBhdHRhY2hcdTAwRTllIFx1MDBFMCBsJ1x1MDBFOWxcdTAwRTltZW50IHNlbGVjdFxyXG4gICAgaWYgKHNlbGVjdEVsZW1lbnQgJiYgc2VsZWN0RWxlbWVudC50b21zZWxlY3QpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50IGZvdW5kOlwiLCBzZWxlY3RFbGVtZW50KTtcclxuXHJcbiAgICAgIC8vIFN1cHByaW1leiB0b3V0ZXMgbGVzIG9wdGlvbnMgYWN0dWVsbGVzIGRlIFRvbVNlbGVjdFxyXG4gICAgICBzZWxlY3RFbGVtZW50LnRvbXNlbGVjdC5jbGVhck9wdGlvbnMoKTtcclxuXHJcbiAgICAgIC8vIEFqb3V0ZXogZGUgbm91dmVsbGVzIG9wdGlvbnMgXHUwMEUwIFRvbVNlbGVjdCBcdTAwRTAgcGFydGlyIGRlIGwnXHUwMEU5bFx1MDBFOW1lbnQgc2VsZWN0XHJcbiAgICAgIHZhciBzZWxlY3RPcHRpb25zID0gc2VsZWN0RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwib3B0aW9uXCIpO1xyXG4gICAgICBzZWxlY3RPcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgIHNlbGVjdEVsZW1lbnQudG9tc2VsZWN0LmFkZE9wdGlvbih7XHJcbiAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlLFxyXG4gICAgICAgICAgdGV4dDogb3B0aW9uLnRleHRDb250ZW50LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEFjdHVhbGlzZXogbGUgVG9tU2VsZWN0IHBvdXIgcmVmbFx1MDBFOXRlciBsZXMgbW9kaWZpY2F0aW9uc1xyXG4gICAgICBzZWxlY3RFbGVtZW50LnRvbXNlbGVjdC5yZWZyZXNoT3B0aW9ucygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlNlbGVjdCBlbGVtZW50IG9yIFRvbVNlbGVjdCBpbnN0YW5jZSBub3QgZm91bmRcIik7XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuXHJcbkhvb2tzLkNzdkV4cG9ydEhvb2sgPSB7XHJcbiAgbW91bnRlZCgpIHtcclxuICAgIHRoaXMuaGFuZGxlRXhwb3J0Q2xpY2sgPSB0aGlzLmhhbmRsZUV4cG9ydENsaWNrLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmhhbmRsZUV4cG9ydENsaWNrKTtcclxuICB9LFxyXG4gIGRlc3Ryb3llZCgpIHtcclxuICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlRXhwb3J0Q2xpY2spO1xyXG4gIH0sXHJcblxyXG4gIGhhbmRsZUV4cG9ydENsaWNrKGV2ZW50KSB7XHJcbiAgICBsZXQgY3N2RGF0YSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1jc3ZcIik7XHJcbiAgICBjb25zb2xlLmxvZyhcImF2YW50IDpcIiwgY3N2RGF0YSk7XHJcbiAgICBjc3ZEYXRhID0gY3N2RGF0YS5yZXBsYWNlKC9cXFxcclxcXFxuL2csIFwiXFxuXCIpO1xyXG4gICAgLy9sZXQgdGVzdCA9IFwiTmFtZSxBZ2UsQ2l0eVxcbkpvaG4sMzAsTmV3IFlvcmtcXG5KYW5lLDI1LFNhbiBGcmFuY2lzY29cXG5Cb2IsMzUsQ2hpY2Fnb1wiO1xyXG4gICAgY29uc29sZS5sb2coXCJhcHJlcyA6XCIsIGNzdkRhdGEpO1xyXG4gICAgLy8gQ3JcdTAwRTllciB1biBvYmpldCBCbG9iIFx1MDBFMCBwYXJ0aXIgZGUgbGEgY2hhXHUwMEVFbmUgQ1NWXHJcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2NzdkRhdGFdLCB7IHR5cGU6IFwidGV4dC9jc3Y7Y2hhcnNldD11dGYtODtcIiB9KTtcclxuXHJcbiAgICAvLyBDclx1MDBFOWVyIHVuIFx1MDBFOWxcdTAwRTltZW50IDxhPiBwb3VyIHRcdTAwRTlsXHUwMEU5Y2hhcmdlciBsZSBmaWNoaWVyIENTVlxyXG4gICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gICAgbGluay5ocmVmID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICBsaW5rLmRvd25sb2FkID0gXCJleGVtcGxlLmNzdlwiO1xyXG5cclxuICAgIC8vIEFqb3V0ZXIgbCdcdTAwRTlsXHUwMEU5bWVudCA8YT4gXHUwMEUwIGxhIHBhZ2VcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XHJcblxyXG4gICAgLy8gU2ltdWxlciB1biBjbGljIHN1ciBsZSBsaWVuIHBvdXIgZFx1MDBFOWNsZW5jaGVyIGxlIHRcdTAwRTlsXHUwMEU5Y2hhcmdlbWVudFxyXG4gICAgbGluay5jbGljaygpO1xyXG5cclxuICAgIC8vIFN1cHByaW1lciBsJ1x1MDBFOWxcdTAwRTltZW50IDxhPiBhcHJcdTAwRThzIGxlIHRcdTAwRTlsXHUwMEU5Y2hhcmdlbWVudFxyXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcclxuXHJcbiAgICAvLyAuLi4gQXV0cmVzIGFjdGlvbnMgXHUwMEUwIGVmZmVjdHVlciBhdmVjIGNzdkRhdGEgLi4uXHJcbiAgfSxcclxufTtcclxuXHJcbkhvb2tzLkhvcml6b250YWxCYXJDaGFydCA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgY29uc3QgeyBsYWJlbHNfdGFza3NfYnlfY29udHJpYnV0b3JzLCB2YWx1ZXNfdGFza3NfYnlfY29udHJpYnV0b3JzIH0gPVxyXG4gICAgICBKU09OLnBhcnNlKHRoaXMuZWwuZGF0YXNldC5jaGFydERhdGEpO1xyXG4gICAgdGhpcy5jaGFydCA9IG5ldyBIb3Jpem9udGFsQmFyQ2hhcnQoXHJcbiAgICAgIHRoaXMuZWwsXHJcbiAgICAgIGxhYmVsc190YXNrc19ieV9jb250cmlidXRvcnMsXHJcbiAgICAgIHZhbHVlc190YXNrc19ieV9jb250cmlidXRvcnNcclxuICAgICk7XHJcbiAgfSxcclxufTtcclxuXHJcbkhvb2tzLlN0YWNrZWRCYXJDaGFydCA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB2YWx1ZXNfdGFza3NfdG9kb19ieV9tb250aCxcclxuICAgICAgdmFsdWVzX2Jsb2NraW5nX3Rhc2tzX2J5X21vbnRoLFxyXG4gICAgICB2YWx1ZXNfdGFza3NfaW5fcHJvZ3Jlc3NfYnlfbW9udGgsXHJcbiAgICAgIHZhbHVlc190YXNrc19pbl9jb250cm9sX2J5X21vbnRoLFxyXG4gICAgICB2YWx1ZXNfdGFza3NfYWNoaWV2ZWRfYnlfbW9udGgsXHJcbiAgICB9ID0gSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQuY2hhcnREYXRhKTtcclxuICAgIHRoaXMuY2hhcnQgPSBuZXcgU3RhY2tlZEJhckNoYXJ0KFxyXG4gICAgICB0aGlzLmVsLFxyXG4gICAgICB2YWx1ZXNfdGFza3NfdG9kb19ieV9tb250aCxcclxuICAgICAgdmFsdWVzX2Jsb2NraW5nX3Rhc2tzX2J5X21vbnRoLFxyXG4gICAgICB2YWx1ZXNfdGFza3NfaW5fcHJvZ3Jlc3NfYnlfbW9udGgsXHJcbiAgICAgIHZhbHVlc190YXNrc19pbl9jb250cm9sX2J5X21vbnRoLFxyXG4gICAgICB2YWx1ZXNfdGFza3NfYWNoaWV2ZWRfYnlfbW9udGhcclxuICAgICk7XHJcbiAgfSxcclxufTtcclxuXHJcbkhvb2tzLlN1cnZleUNoYXJ0ID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcImlzIG1vdW50ZWRcIik7XHJcblxyXG4gICAgY29uc3QgeyB2YWx1ZXMgfSA9IEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LmNoYXJ0RGF0YSk7XHJcblxyXG4gICAgdGhpcy5teWNoYXJ0ID0gbmV3IFN1cnZleUNoYXJ0KHRoaXMuZWwsIHZhbHVlcyk7XHJcbiAgfSxcclxufTtcclxuXHJcbi8vIEhvb2tzLkxpbmVDaGFydCA9IHtcclxuLy8gICBtb3VudGVkKCkge1xyXG4vLyAgICAgY29uc3QgeyB2YWx1ZXNfdGFza3NfdG9kb19ieV9tb250aCwgdmFsdWVzX2Jsb2NraW5nX3Rhc2tzX2J5X21vbnRoLCB2YWx1ZXNfdGFza3NfaW5fcHJvZ3Jlc3NfYnlfbW9udGgsIHZhbHVlc190YXNrc19pbl9jb250cm9sX2J5X21vbnRoLCB2YWx1ZXNfdGFza3NfYWNoaWV2ZWRfYnlfbW9udGggfSA9IEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LmNoYXJ0RGF0YSlcclxuLy8gICAgIHRoaXMuY2hhcnQgPSBuZXcgTGluZUNoYXJ0KHRoaXMuZWwsIHZhbHVlc190YXNrc190b2RvX2J5X21vbnRoLCB2YWx1ZXNfYmxvY2tpbmdfdGFza3NfYnlfbW9udGgsIHZhbHVlc190YXNrc19pbl9wcm9ncmVzc19ieV9tb250aCwgdmFsdWVzX3Rhc2tzX2luX2NvbnRyb2xfYnlfbW9udGgsIHZhbHVlc190YXNrc19hY2hpZXZlZF9ieV9tb250aClcclxuLy8gICB9XHJcbi8vIH1cclxuXHJcbkhvb2tzLkJvYXJkID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICB0aGlzLmluaXREcmFnZ2FibGVzKCk7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlZCgpIHtcclxuICAgIHRoaXMuc29ydGFibGVDYXJkLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuc29ydGFibGVTdGFnZS5kZXN0cm95KCk7XHJcbiAgICB0aGlzLmluaXREcmFnZ2FibGVzKCk7XHJcbiAgfSxcclxuXHJcbiAgaW5pdERyYWdnYWJsZXMoKSB7XHJcbiAgICB0aGlzLnNvcnRhYmxlQ2FyZCA9IG5ldyBTb3J0YWJsZShcclxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5zdGFnZV9fY2FyZHNcIiksXHJcbiAgICAgIHtcclxuICAgICAgICBkcmFnZ2FibGU6IFwiLmNhcmRcIixcclxuICAgICAgICBtaXJyb3I6IHtcclxuICAgICAgICAgIGNvbnN0cmFpbkRpbWVuc2lvbnM6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzd2FwQW5pbWF0aW9uOiB7XHJcbiAgICAgICAgICBkdXJhdGlvbjogMjAwLFxyXG4gICAgICAgICAgZWFzaW5nRnVuY3Rpb246IFwiZWFzZS1pbi1vdXRcIixcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBsdWdpbnM6IFtQbHVnaW5zLlN3YXBBbmltYXRpb25dLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuc29ydGFibGVDYXJkLm9uKFwic29ydGFibGU6c3RvcFwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgY29uc3Qgc291cmNlID0gZXZlbnQuZGF0YS5kcmFnRXZlbnQuZGF0YS5zb3VyY2U7XHJcbiAgICAgIGNvbnN0IGNhcmRJZCA9IHBhcnNlSW50KHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNhcmQtaWRcIikpO1xyXG4gICAgICBjb25zdCBuZXdTdGFnZUlkID0gcGFyc2VJbnQoXHJcbiAgICAgICAgZXZlbnQuZGF0YS5uZXdDb250YWluZXIuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdGFnZS1pZFwiKVxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBuZXdJbmRleCA9IHBhcnNlSW50KGV2ZW50LmRhdGEubmV3SW5kZXgpO1xyXG4gICAgICBjb25zdCBjYXJkUGF5bG9hZCA9IHtcclxuICAgICAgICBjYXJkOiB7XHJcbiAgICAgICAgICBpZDogY2FyZElkLFxyXG4gICAgICAgICAgc3RhZ2VfaWQ6IG5ld1N0YWdlSWQsXHJcbiAgICAgICAgICBwb3NpdGlvbjogbmV3SW5kZXgsXHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5wdXNoRXZlbnQoXCJ1cGRhdGVfY2FyZFwiLCBjYXJkUGF5bG9hZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnNvcnRhYmxlU3RhZ2UgPSBuZXcgU29ydGFibGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ib2FyZFwiKSwge1xyXG4gICAgICBkcmFnZ2FibGU6IFwiLnN0YWdlXCIsXHJcbiAgICAgIGhhbmRsZTogXCIuZHJhZ2dhYmxlLWhhbmRsZVwiLFxyXG4gICAgICBtaXJyb3I6IHtcclxuICAgICAgICBjb25zdHJhaW5EaW1lbnNpb25zOiB0cnVlLFxyXG4gICAgICAgIHlBeGlzOiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc29ydGFibGVTdGFnZS5vbihcInNvcnRhYmxlOnN0b3BcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGV2ZW50LmRhdGEuZHJhZ0V2ZW50LmRhdGEuc291cmNlO1xyXG4gICAgICBjb25zdCBzdGFnZUlkID0gcGFyc2VJbnQoc291cmNlLmdldEF0dHJpYnV0ZShcImRhdGEtc3RhZ2UtaWRcIikpO1xyXG4gICAgICBjb25zdCBuZXdJbmRleCA9IHBhcnNlSW50KGV2ZW50LmRhdGEubmV3SW5kZXgpO1xyXG4gICAgICBjb25zdCBzdGFnZVBheWxvYWQgPSB7XHJcbiAgICAgICAgc3RhZ2U6IHtcclxuICAgICAgICAgIGlkOiBzdGFnZUlkLFxyXG4gICAgICAgICAgcG9zaXRpb246IG5ld0luZGV4LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMucHVzaEV2ZW50KFwidXBkYXRlX3N0YWdlXCIsIHN0YWdlUGF5bG9hZCk7XHJcbiAgICB9KTtcclxuICB9LFxyXG59O1xyXG5cclxuSG9va3MuQW5pbWF0ZUFsZXJ0ID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhcInRhZmlkaXRyYSBhbGVydFwiKVxyXG4gICAgdGhpcy5oYW5kbGVFdmVudChcIkFuaW1hdGVBbGVydFwiLCAoe30pID0+IHRoaXMucmVzZXRfb3BhY2l0eSgpKTtcclxuICB9LFxyXG4gIHVwZGF0ZWQoKSB7fSxcclxuICByZXNldF9vcGFjaXR5KCkge1xyXG4gICAgdmFyIGFsZXJ0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNhbGVydF9hbmltXCIpO1xyXG4gICAgYWxlcnQuc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIC8qIGFsZXJ0LnN0eWxlLm9wYWNpdHkgPSAwOyAqL1xyXG4gICAgICBhbGVydC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICB9LCAyMDAwKTtcclxuICB9LFxyXG4gIGFuaW1fb25sb2FkKCkge1xyXG4gICAgdmFyIGFsZXJ0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWxlcnRcIik7XHJcbiAgICAvLyAgY29uc29sZS5sb2coYWxlcnRzKTtcclxuXHJcbiAgICBhbGVydHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICBpdGVtLnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gICAgICBpdGVtLm9ubG9hZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpdGVtLnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICB9LCAyMDAwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxlcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGFsZXJ0c1tpXS5zdHlsZS5vcGFjaXR5ID0gMTtcclxuICAgICAgYWxlcnRzW2ldLm9ubG9hZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhbGVydHNbaV0uc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgIH0sIDIwMDApO1xyXG4gICAgfVxyXG4gIH0sXHJcbn07XHJcblxyXG5Ib29rcy5ibHVySG9vayA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgLy8gY29uc29sZS5sb2coXCJ0YWZpZGl0cmEgYmx1ckhvb2tcIilcclxuICAgIHRoaXMuaGFuZGxlRXZlbnQoXCJibHVyQm9keVwiLCAoeyBwYXJhbTEsIHBhcmFtMiB9KSA9PlxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhwYXJhbTEpXHJcbiAgICAgIHRoaXMuYmx1ckJvZHkoKVxyXG4gICAgKTtcclxuICB9LFxyXG4gIGJsdXJCb2R5KCkge1xyXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgdmFyIHJlcXVlc3RfZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjdGhlX3JlcXVlc3RfZm9ybVwiKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKHJlcXVlc3RfZm9ybSk7XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coYm9keSk7XHJcbiAgICBib2R5LnN0eWxlLm9wYWNpdHkgPSAwLjU7XHJcblxyXG4gICAgLy8gdmFyIG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5tb2RhbC1jb250YWluZXJcIik7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhtb2RhbCk7XHJcbiAgICAvLyBtb2RhbC5zdHlsZS5maWx0ZXIgPSBcImJsdXIoMXB4KVwiO1xyXG4gICAgcmVxdWVzdF9mb3JtLnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gIH0sXHJcbn07XHJcblxyXG5Ib29rcy5NZXNzYWdlQm9keSA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgdmFyIG1lc3NhZ2VCb2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNtZXNzYWdlQm9keVwiKTtcclxuICAgIHRoaXMuaGFuZGxlRXZlbnQoXHJcbiAgICAgIFwidXBkYXRlU2Nyb2xsXCIsXHJcbiAgICAgICh7fSkgPT5cclxuICAgICAgICAobWVzc2FnZUJvZHkuc2Nyb2xsVG9wID1cclxuICAgICAgICAgIG1lc3NhZ2VCb2R5LnNjcm9sbEhlaWdodCAtIG1lc3NhZ2VCb2R5LmNsaWVudEhlaWdodClcclxuICAgICk7XHJcbiAgfSxcclxufTtcclxuXHJcbi8vIEdldCB1cmwgbG9jYXRpb25cclxuSG9va3MudXJsUHJvY2VzcyA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgbGV0IG1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI21haW5cIik7XHJcblxyXG4gICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xyXG5cclxuICAgIC8vIFRlcm5hcnkgZnVuY3Rpb25cclxuICAgIHVybC5pbmNsdWRlcyhcIi9sb2dzXCIpXHJcbiAgICAgID8gbWFpbi5jbGFzc0xpc3QucmVtb3ZlKFwiY29udGFpbmVyXCIpXHJcbiAgICAgIDogbWFpbi5jbGFzc0xpc3QuYWRkKFwiY29udGFpbmVyXCIpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5Ib29rcy5TcGluVGVzdCA9IHtcclxuICBtb3VudGVkKCkge1xyXG4gICAgLy8gY29uc29sZS5sb2coXCJ0YWZpZGl0cmEgaG9va1wiKVxyXG4gICAgdGhpcy5oYW5kbGVFdmVudChcIlNwaW5UZXN0XCIsICh7fSkgPT4gdGhpcy5zcGluX2ljb24oKSk7XHJcbiAgICB0aGlzLmhhbmRsZUV2ZW50KFwiU3BpbkNvbW1lbnRcIiwgKHt9KSA9PiB0aGlzLnNwaW5fY29tbWVudF9pY29uKCkpO1xyXG4gIH0sXHJcbiAgc3Bpbl9pY29uKCkge1xyXG4gICAgdmFyIHNwaW5zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ub3RpZl9fbG9hZFwiKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKHNwaW4pO1xyXG4gICAgLy8gc3BpbnMuY2xhc3NMaXN0LmFkZCgncm90YXRlX19pY29uJyk7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhzcGluKTtcclxuICAgIC8vIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c3BpbnMuY2xhc3NMaXN0LnJlbW92ZSgncm90YXRlX19pY29uJyk7fSwgNTAwKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKCdub3RpZicpXHJcbiAgICBzcGlucy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChcIm5ld19fcm90YXRlX19pY29uXCIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc3BpbnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKFwibmV3X19yb3RhdGVfX2ljb25cIik7XHJcbiAgICAgIH0sIDUwMCk7XHJcbiAgICB9KTtcclxuICB9LFxyXG4gIHNwaW5fY29tbWVudF9pY29uKCkge1xyXG4gICAgLy8gY29uc29sZS5sb2coJ2NvbW1lbnQnKVxyXG4gICAgdmFyIGNsb2NrX2NvbW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNsb2NrX2NvbW1lbnRcIik7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhjbG9ja19jb21tZW50KTtcclxuICAgIGNsb2NrX2NvbW1lbnQuY2xhc3NMaXN0LmFkZChcInJvdGF0ZV9faWNvblwiKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKGNsb2NrX2NvbW1lbnQpO1xyXG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICBjbG9ja19jb21tZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJyb3RhdGVfX2ljb25cIik7XHJcbiAgICB9LCA1MDApO1xyXG4gICAgLy8gY29uc29sZS5sb2coY2xvY2tfY29tbWVudCk7XHJcbiAgfSxcclxufTtcclxuXHJcbmxldCBuYXZUb2dnbGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLm5hdl9fdG9nZ2xlXCIpO1xyXG5sZXQgbmF2V3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubmF2X193cmFwcGVyXCIpO1xyXG5uYXZUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcclxuICBpZiAobmF2V3JhcHBlci5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIikpIHtcclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpO1xyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwibWVudVwiKTtcclxuICAgIG5hdldyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbmF2V3JhcHBlci5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiY2xvc2UgbWVudVwiKTtcclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XHJcbiAgfVxyXG59KTtcclxuLy8gUlx1MDBFOWN1cFx1MDBFOXJleiBsJ1x1MDBFOWxcdTAwRTltZW50IHBhciBzb24gSURcclxudmFyIGNvcHlyaWdodEljb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvcHlyaWdodF9faWNvblwiKTtcclxuXHJcbi8vIFZcdTAwRTlyaWZpZXogc2kgbCdcdTAwRTlsXHUwMEU5bWVudCBhIFx1MDBFOXRcdTAwRTkgdHJvdXZcdTAwRTkgYXZhbnQgZGUgbGUgbW9kaWZpZXJcclxuaWYgKGNvcHlyaWdodEljb24pIHtcclxuICBjb3B5cmlnaHRJY29uLmlubmVySFRNTCA9IFwiY29weXJpZ2h0IFBISURJQSAvIFByb2plY3QgbW9uaXRvcmluZyAtMjAyNFwiO1xyXG59XHJcbmNvbnN0IG1lbnVCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLm1lbnUtYnRuXCIpO1xyXG5sZXQgbWVudU9wZW4gPSBmYWxzZTtcclxubWVudUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gIGlmICghbWVudU9wZW4pIHtcclxuICAgIG1lbnVCdG4uY2xhc3NMaXN0LmFkZChcIm9wZW5cIik7XHJcbiAgICBtZW51T3BlbiA9IHRydWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIG1lbnVCdG4uY2xhc3NMaXN0LnJlbW92ZShcIm9wZW5cIik7XHJcbiAgICBtZW51T3BlbiA9IGZhbHNlO1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgYWxlcnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5hbGVydFwiKTtcclxuXHJcbmFsZXJ0cy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgaXRlbS5zdHlsZS5vcGFjaXR5ID0gMTtcclxuICBpdGVtLm9ubG9hZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgIGl0ZW0uc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgfSwgMjAwMCk7XHJcbn0pO1xyXG5cclxubGV0IGNzcmZUb2tlbiA9IGRvY3VtZW50XHJcbiAgLnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW25hbWU9J2NzcmYtdG9rZW4nXVwiKVxyXG4gIC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpO1xyXG5sZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7XHJcbiAgcGFyYW1zOiB7IF9jc3JmX3Rva2VuOiBjc3JmVG9rZW4gfSxcclxuICBob29rczogSG9va3MsXHJcbn0pO1xyXG5cclxubGV0IHRvcEJhclNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcclxuXHJcbi8vIFNob3cgcHJvZ3Jlc3MgYmFyIG9uIGxpdmUgbmF2aWdhdGlvbiBhbmQgZm9ybSBzdWJtaXRzXHJcbnRvcGJhci5jb25maWcoeyBiYXJDb2xvcnM6IHsgMDogXCIjMjlkXCIgfSwgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAwLCAwLCAuMylcIiB9KTtcclxuXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCAoaW5mbykgPT4gdG9wYmFyLnNob3coKSk7XHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsIChpbmZvKSA9PiB0b3BiYXIuaGlkZSgpKTtcclxuXHJcbi8vIGNvbm5lY3QgaWYgdGhlcmUgYXJlIGFueSBMaXZlVmlld3Mgb24gdGhlIHBhZ2VcclxubGl2ZVNvY2tldC5jb25uZWN0KCk7XHJcblxyXG4vLyBleHBvc2UgbGl2ZVNvY2tldCBvbiB3aW5kb3cgZm9yIHdlYiBjb25zb2xlIGRlYnVnIGxvZ3MgYW5kIGxhdGVuY3kgc2ltdWxhdGlvbjpcclxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVEZWJ1ZygpXHJcbi8vID4+IGxpdmVTb2NrZXQuZW5hYmxlTGF0ZW5jeVNpbSgxMDAwKSAgLy8gZW5hYmxlZCBmb3IgZHVyYXRpb24gb2YgYnJvd3NlciBzZXNzaW9uXHJcbi8vID4+IGxpdmVTb2NrZXQuZGlzYWJsZUxhdGVuY3lTaW0oKVxyXG53aW5kb3cubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXQ7XHJcbiIsICIvKlxyXG5maWNoaWVyIEpTIHBvdXIgbGEgZ2VuZXJlcmF0aW9uIGV0IHNhdXZnYXJkZSBkZSBsaWduZSBkZSBzYWlzaWVcclxucmVxdWlyZWQgVG9tU2VsZWN0XHJcbmEgdm9pciBhdXNzaSBUYXNrQ29udHJvbGxlci50YXNrX2J5X3Byb2plY3QgIC8vYXBpIGRlIHJlY3VwZXJhdGlvbiBkZXMgdGFjaGVzIGV0IGluZm8gY2xpZW50IHBhciBwcm9qZXRcclxuU2Fpc2llQ29udHJvbGxlci5jcmVhdGUgIC8vYXBpIGRlIHNhdXZnYXJkZSBkJ3VuZSBsaWduZVxyXG5hdXRob3IgIDogbG9pY1JhdmVsbzA1QGdtYWlsLmNvbVxyXG4qL1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5pbXBvcnQgVG9tU2VsZWN0IGZyb20gXCJ0b20tc2VsZWN0XCI7XHJcblxyXG5cclxuXHJcblxyXG4vLyBGb25jdGlvbiBwb3VyIHNhdXZlZ2FyZGVyIHVuZSBsaWduZVxyXG5mdW5jdGlvbiBzYXZlUm93KGljb24pIHtcclxuICAgIGNvbnN0IHJvdyA9IGljb24uY2xvc2VzdCgndHInKTtcclxuICAgIGNvbnN0IGlucHV0cyA9IHJvdy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCwgc2VsZWN0Jyk7IC8vIGdldCBhbGwgaW5wdXRzIFxyXG4gICAgY29uc3Qgcm93RGF0YSA9IHt9OyAvL2xlcyB2YWxldXIgZGUgY2hhcXVlIGlucHV0XHJcbiAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XHJcbiAgICAgICAgcm93RGF0YVtpbnB1dC5uYW1lXSA9IGlucHV0LnZhbHVlO1xyXG4gICAgfSk7XHJcbiAgICAvLyBWb3VzIHBvdXZleiBtYWludGVuYW50IHNvdW1ldHRyZSBjZXR0ZSBsaWduZSBkZSBkb25uXHUwMEU5ZXMgXHUwMEUwIHZvdHJlIGJhY2tlbmQgb3UgZWZmZWN0dWVyIGQnYXV0cmVzIGFjdGlvbnNcclxuICAgIGNvbnNvbGUubG9nKFwiRG9ublx1MDBFOWVzIFx1MDBFMCBzYXV2ZWdhcmRlcjpcIiwgcm93RGF0YSk7XHJcblxyXG4gICAgLy8gUlx1MDBFOWN1cFx1MDBFOXJlciBsZSBqZXRvbiBDU1JGIGRlcHVpcyB1biBjaGFtcCBjYWNoXHUwMEU5IGRhbnMgbGUgZm9ybXVsYWlyZVxyXG4gICAgY29uc3QgY3NyZlRva2VuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpLmdldEF0dHJpYnV0ZSgnY29udGVudCcpO1xyXG5cclxuICAgIC8vIEVudm9pIGRlcyBkb25uXHUwMEU5ZXMgYXUgYmFja2VuZCBhdmVjIGxlIGpldG9uIENTUkZcclxuICAgIGZldGNoKCcvc2F2ZV9zYWlzaWUnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAnWC1DU1JGLVRva2VuJzogY3NyZlRva2VuICAvLyBJbmNsdXJlIGxlIGpldG9uIENTUkYgZGFucyBsZXMgZW4tdFx1MDBFQXRlcyBkZSBsYSByZXF1XHUwMEVBdGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJvd0RhdGEpXHJcbiAgICB9KVxyXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCIgcmVzcG9uc2UgOiBcIiwgcmVzcG9uc2UpXHJcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyZXVyIGxvcnMgZGUgbGEgc2F1dmVnYXJkZSBkZXMgZG9ublx1MDBFOWVzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAvLyBUcmFpdGVtZW50IGRlIGxhIHJcdTAwRTlwb25zZSBkdSBiYWNrZW5kXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTdWNjXHUwMEU4czonLCBkYXRhLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7IC8vIG91IHRvdXRlIGF1dHJlIGFjdGlvbiBxdWUgdm91cyB2b3VsZXogZWZmZWN0dWVyIGVuIGNhcyBkZSBzdWNjXHUwMEU4c1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyZXVyIDonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIGFsZXJ0KCdVbmUgZXJyZXVyIGVzdCBzdXJ2ZW51ZSBsb3JzIGRlIGxhIHNhdXZlZ2FyZGUuIFZldWlsbGV6IHZcdTAwRTlyaWZpZXIgcXVlIHRvdXMgbGVzIGNoYW1wcyBzb250IGJpZW4gcmVtcGxpcyBldCBhdSBib24gZm9ybWF0Jyk7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuLy8gRm9uY3Rpb24gcG91ciBzdXBwcmltZXIgdW5lIGxpZ25lXHJcbmZ1bmN0aW9uIHJlbW92ZVJvdyhpY29uKSB7XHJcbiAgICBpY29uLmNsb3Nlc3QoJ3RyJykucmVtb3ZlKCk7XHJcbn1cclxuXHJcbi8vIGZvbmN0aW9uIGRlIHZhbGlkYXRpb24gZHUgY2hhbXAgZGVjaW1hbCBkZSBsJ2lucHV0XHJcbmZ1bmN0aW9uIGlzRGVjaW1hbFZhbGlkKGlucHV0VmFsdWUpIHtcclxuICAgIC8vIFZcdTAwRTlyaWZpZSBzaSBsYSB2YWxldXIgc2Fpc2llIGVzdCB1biBub21icmUgZFx1MDBFOWNpbWFsIHZhbGlkZSBlbnRyZSAwIGV0IDIwXHJcbiAgICBjb25zdCBudW1lcmljVmFsdWUgPSBwYXJzZUZsb2F0KGlucHV0VmFsdWUpO1xyXG4gICAgcmV0dXJuICFpc05hTihudW1lcmljVmFsdWUpICYmIG51bWVyaWNWYWx1ZSA+PSAwICYmIG51bWVyaWNWYWx1ZSA8PSAyMCA7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBpc0xhYmVsVmFsaWQoaW5wdXRWYWx1ZSkge1xyXG4gICAgLy8gVlx1MDBFOXJpZmllIHNpIGxhIHZhbGV1ciBzYWlzaWUgbidlc3QgcGFzIHZpZGUgZXQgbmUgZFx1MDBFOXBhc3NlIHBhcyAyNTUgY2FyYWN0XHUwMEU4cmVzXHJcbiAgICByZXR1cm4gaW5wdXRWYWx1ZS50cmltKCkgIT09ICcnICYmIGlucHV0VmFsdWUubGVuZ3RoIDw9IDI1NTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNQcm9qZWN0SWRWYWxpZCh2YWx1ZSkge1xyXG4gICAgLy8gVlx1MDBFOXJpZmllIHNpIGxhIHZhbGV1ciBkdSBjaGFtcCBkZSBzXHUwMEU5bGVjdGlvbiBkZSBwcm9qZXQgbidlc3QgcGFzIHZpZGVcclxuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09ICcnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1Rhc2tWYWxpZChzZWxlY3RlZFRhc2spIHtcclxuICAgIC8vIFZcdTAwRTlyaWZpZSBzaSB1bmUgdFx1MDBFMmNoZSBlc3Qgc1x1MDBFOWxlY3Rpb25uXHUwMEU5ZVxyXG4gICAgcmV0dXJuIHNlbGVjdGVkVGFzayAhPT0gJyc7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8vIGVjb3V0ZXVyIGQnZXZlbmVtZW50IGR1IGNoYW1wIGRlY2ltYWxcclxuXHJcbmZ1bmN0aW9uIGhhbmRsZURlY2ltYWxJbnB1dChldmVudCkge1xyXG4gICAvLyBjb25zdCBzdHJpbmdGb3JtYXQgPSB0aGlzLnZhbHVlO1xyXG5cclxuICAgIC8vIFN1cHByaW1lciBsZXMgc2lnbmVzICcrJyBldCAnLScgZGUgbGEgdmFsZXVyIHNhaXNpZVxyXG4gICAgaWYgKHRoaXMudmFsdWUuaW5jbHVkZXMoJysnKSB8fCB0aGlzLnZhbHVlLmluY2x1ZGVzKCctJykpIHtcclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHN0cmluZ0Zvcm1hdC5yZXBsYWNlKC9bKy1dL2csICcnKTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XHJcbiAgICB9XHJcbiAgIFxyXG4gICAgLy8gVmFsaWRlciBsYSB2YWxldXIgc2Fpc2llIGV0IGNoYW5nZXIgbGEgY291bGV1ciBkZSBsYSBib3JkdXJlIGVuIGNvbnNcdTAwRTlxdWVuY2VcclxuICAgIGlmICghaXNEZWNpbWFsVmFsaWQodGhpcy52YWx1ZSkpIHtcclxuICAgICAgICB0aGlzLnN0eWxlLmJvcmRlckNvbG9yID0gJ3JlZCc7IC8vIENoYW5nZW1lbnQgZGUgbGEgY291bGV1ciBkZSBsYSBib3JkdXJlIGVuIHJvdWdlIGVuIGNhcyBkJ2VycmV1clxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBWXHUwMEU5cmlmaWVyIGxhIGxvbmd1ZXVyIGRlIGxhIHBhcnRpZSBkXHUwMEU5Y2ltYWxlXHJcbiAgICAgICAgY29uc3QgZGVjaW1hbExlbmd0aCA9ICh0aGlzLnZhbHVlLnNwbGl0KCcuJylbMV0gfHwgJycpLmxlbmd0aDtcclxuICAgICAgICBjb25zb2xlLmxvZyhkZWNpbWFsTGVuZ3RoKTtcclxuICAgICAgICBpZiAoZGVjaW1hbExlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgdmFsZXVyID0gcGFyc2VGbG9hdCh0aGlzLnZhbHVlKS50b0ZpeGVkKDIpO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsZXVyOyAvLyBMaW1pdGVyIFx1MDBFMCBkZXV4IGNoaWZmcmVzIGFwclx1MDBFOHMgbGEgdmlyZ3VsZVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0eWxlLmJvcmRlckNvbG9yID0gJ2dyZWVuJzsgLy8gUlx1MDBFOWluaXRpYWxpc2F0aW9uIGRlIGxhIGNvdWxldXIgZGUgbGEgYm9yZHVyZSBcdTAwRTAgc2EgdmFsZXVyIHBhciBkXHUwMEU5ZmF1dFxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUxhYmVsSW5wdXQoZXZlbnQpIHtcclxuICAgIGlmICghaXNMYWJlbFZhbGlkKHRoaXMudmFsdWUpKSB7XHJcbiAgICAgICAgdGhpcy5zdHlsZS5ib3JkZXJDb2xvciA9ICdyZWQnOyAvLyBDaGFuZ2VtZW50IGRlIGxhIGNvdWxldXIgZGUgbGEgYm9yZHVyZSBlbiByb3VnZSBlbiBjYXMgZCdlcnJldXJcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zdHlsZS5ib3JkZXJDb2xvciA9ICdncmVlbic7IC8vIFJcdTAwRTlpbml0aWFsaXNhdGlvbiBkZSBsYSBjb3VsZXVyIGRlIGxhIGJvcmR1cmUgXHUwMEUwIHNhIHZhbGV1ciBwYXIgZFx1MDBFOWZhdXRcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vL2dlc3Rpb24gZCdldmVuZW1lbnQgZHUgbGEgbGlzdGUgZGVyb3VsYW50ZSBkZXMgcHJvamV0XHJcbmZ1bmN0aW9uIGhhbmRsZVByb2plY3RTZWxlY3RDaGFuZ2UoZXZlbnQgLCB0YXNrX3RvbV9zZWxlY3QpIHtcclxuICAgIGNvbnN0IHByb2plY3RFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnByb2plY3RfaWQnKTtcclxuICAgIGNvbnN0IHRzQ29udHJvbEVsZW1lbnQgPSBwcm9qZWN0RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudHMtY29udHJvbCcpO1xyXG4gICAgY29uc3Qgc2VsZWN0ZWRQcm9qZWN0SWQgPSBldmVudC50YXJnZXQudmFsdWU7XHJcblxyXG4gICAgaWYgKCFpc1Byb2plY3RJZFZhbGlkKHNlbGVjdGVkUHJvamVjdElkKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwibWFrYXRvIGFtaW4gcmVkXCIpO1xyXG4gICAgICAgIHRzQ29udHJvbEVsZW1lbnQuc3R5bGUuYm9yZGVyQ29sb3IgPSAncmVkJzsgLy8gQ2hhbmdlbWVudCBkZSBsYSBjb3VsZXVyIGRlIGxhIGJvcmR1cmUgZW4gcm91Z2UgZW4gY2FzIGQnZXJyZXVyXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwibWFrYXRvIGFtaW4gZ3JlZW5cIik7XHJcbiAgICAgICAgdHNDb250cm9sRWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9ICdncmVlbic7IC8vIFJcdTAwRTlpbml0aWFsaXNhdGlvbiBkZSBsYSBjb3VsZXVyIGRlIGxhIGJvcmR1cmUgXHUwMEUwIHNhIHZhbGV1ciBwYXIgZFx1MDBFOWZhdXRcclxuICAgIH1cclxuXHJcbiAgICAvLyBNaXNlIFx1MDBFMCBqb3VyIGRlIGxhIGxpc3RlIGRcdTAwRTlyb3VsYW50ZSBkZXMgdFx1MDBFMmNoZXMgZW4gZm9uY3Rpb24gZHUgcHJvamV0IHNcdTAwRTlsZWN0aW9ublx1MDBFOVxyXG4gICAgdXBkYXRlVGFza09wdGlvbnMoc2VsZWN0ZWRQcm9qZWN0SWQsIHRhc2tfdG9tX3NlbGVjdCk7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8qXHJcbmVjb3V0ZXVyIGQnZXZlbmVtZW50IHN1ciBsYSBsaXN0ZSBkZXJvdWxhbnRlIGRlIHByb2pldFxyXG4qL1xyXG5mdW5jdGlvbiBoYW5kbGVUYXNrU2VsZWN0Q2hhbmdlKGV2ZW50KSB7XHJcbiAgICBjb25zdCB0YXNrRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YXNrJyk7XHJcbiAgICBjb25zdCB0c0NvbnRyb2xFbGVtZW50ID0gdGFza0VsZW1lbnQucXVlcnlTZWxlY3RvcignLnRzLWNvbnRyb2wnKTtcclxuICAgIGNvbnN0IHNlbGVjdGVkVGFzayA9IGV2ZW50LnRhcmdldC52YWx1ZTtcclxuXHJcbiAgICBpZiAoIWlzVGFza1ZhbGlkKHNlbGVjdGVkVGFzaykpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkxhIHRcdTAwRTJjaGUgc1x1MDBFOWxlY3Rpb25uXHUwMEU5ZSBlc3QgaW52YWxpZGVcIik7XHJcbiAgICAgICAgdHNDb250cm9sRWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9ICdyZWQnOyAvLyBDaGFuZ2VtZW50IGRlIGxhIGNvdWxldXIgZGUgbGEgYm9yZHVyZSBlbiByb3VnZSBlbiBjYXMgZCdlcnJldXJcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJMYSB0XHUwMEUyY2hlIHNcdTAwRTlsZWN0aW9ublx1MDBFOWUgZXN0IHZhbGlkZVwiKTtcclxuICAgICAgICB0c0NvbnRyb2xFbGVtZW50LnN0eWxlLmJvcmRlckNvbG9yID0gJ2dyZWVuJzsgLy8gUlx1MDBFOWluaXRpYWxpc2F0aW9uIGRlIGxhIGNvdWxldXIgZGUgbGEgYm9yZHVyZSBcdTAwRTAgc2EgdmFsZXVyIHBhciBkXHUwMEU5ZmF1dFxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuLyogZm9uY3Rpb24gcXVpIGFqb3V0IGxlcyBjb3VsZXVyIHBhciBkZWZhdXQgcm91Z2Ugc3VyIGxlcyBjaGFtcCBwdWlzcXVlIGxlcyBjaGFtcCBzb250IHRvdXMgdmlkZSBsb3JzIGRlIGxhIGdlbmVyYXRpb24gZCd1bmUgbm91dmVsbGUgbGlnbmUgXHJcbk5CIDogYXBwZWxlciBjZXR0ZSAgZm9uY3Rpb24ganVzdGUgYXByZXMgYXZvaXIgY3JlZXIgbGVzIGluc3RhbmNlIGRlIHRvbVNlbGVjdCBzdXIgbGVzIGxpc3RlIGRlcm91bGFudGUgPT4gaWwgeSBhIGRlcyBkaXYgZ2VuZXJlciBqdXN0ZSBhcHJlcyBhdm9pciBtaXMgdW5lIGluc3RhbmNlIGRlIHRvbVNlbGVjdCBzdXIgdW5lIGxpc3RlIGRlcm91bGFudGUgKC50cy1jb250cm9sKVxyXG4qL1xyXG5cclxuZnVuY3Rpb24gYXBwbHlGaWVsZFZhbGlkYXRpb25zKHRhYmxlQm9keSkge1xyXG5cclxuICAgIGNvbnN0IHRhc2tFbGVtZW50ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJy50YXNrJyk7XHJcbiAgICBjb25zdCB0c0NvbnRyb2xFbGVtZW50MSA9IHRhc2tFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy50cy1jb250cm9sJyk7XHJcbiAgICB0c0NvbnRyb2xFbGVtZW50MS5zdHlsZS5ib3JkZXJDb2xvciA9ICdyZWQnO1xyXG5cclxuICAgIGNvbnN0IHByb2plY3RFbGVtZW50ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJy5wcm9qZWN0X2lkJyk7XHJcbiAgICBjb25zdCB0c0NvbnRyb2xFbGVtZW50ID0gcHJvamVjdEVsZW1lbnQucXVlcnlTZWxlY3RvcignLnRzLWNvbnRyb2wnKTtcclxuICAgIHRzQ29udHJvbEVsZW1lbnQuc3R5bGUuYm9yZGVyQ29sb3IgPSAncmVkJztcclxuXHJcbiAgICBjb25zdCBsYWJlbElucHV0ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJ3RyOmxhc3QtY2hpbGQgaW5wdXRbbmFtZT1cImxhYmVsc1wiXScpO1xyXG4gICAgLy8gYWpvdXQgZGUgbGEgY291bGV1ciBpbnRpYWwgXHJcbiAgICBsYWJlbElucHV0LnN0eWxlLmJvcmRlckNvbG9yID0gJ3JlZCc7XHJcbiAgIFxyXG59XHJcblxyXG5mdW5jdGlvbiBsaW5lVmFsaWRhdGlvbih0YWJsZUJvZHkpIHtcclxuICAgIGNvbnN0IGxhYmVsSW5wdXQgPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcigndHI6bGFzdC1jaGlsZCBpbnB1dFtuYW1lPVwibGFiZWxzXCJdJyk7XHJcbiAgICBjb25zdCB0YXNrU2VsZWN0ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJ3RyOmxhc3QtY2hpbGQgc2VsZWN0W25hbWU9XCJ0YXNrXCJdJyk7XHJcbiAgICBjb25zdCBwcm9qZWN0U2VsZWN0ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJ3RyOmxhc3QtY2hpbGQgc2VsZWN0W25hbWU9XCJwcm9qZWN0X2lkXCJdJyk7XHJcbiAgICBjb25zdCBkZWNpbWFsSW5wdXQgPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcigndHI6bGFzdC1jaGlsZCBpbnB1dFtuYW1lPVwiaG91cnNcIl0nKTtcclxuXHJcbiAgICAvLyBWYWxpZGF0aW9uIGR1IGNoYW1wIGRlIGxpYmVsbFx1MDBFOVxyXG4gICAgY29uc3QgaXNMYWJlbFZhbGlkUmVzdWx0ID0gaXNMYWJlbFZhbGlkKGxhYmVsSW5wdXQudmFsdWUpO1xyXG5cclxuICAgIC8vIFZhbGlkYXRpb24gZHUgY2hhbXAgZGUgc1x1MDBFOWxlY3Rpb24gZGUgdFx1MDBFMmNoZVxyXG4gICAgY29uc3QgaXNUYXNrVmFsaWRSZXN1bHQgPSBpc1Rhc2tWYWxpZCh0YXNrU2VsZWN0LnZhbHVlKTtcclxuXHJcbiAgICAvLyBWYWxpZGF0aW9uIGR1IGNoYW1wIGRlIHNcdTAwRTlsZWN0aW9uIGRlIHByb2pldFxyXG4gICAgY29uc3QgaXNQcm9qZWN0SWRWYWxpZFJlc3VsdCA9IGlzUHJvamVjdElkVmFsaWQocHJvamVjdFNlbGVjdC52YWx1ZSk7XHJcblxyXG4gICAgLy8gVmFsaWRhdGlvbiBkdSBjaGFtcCBkXHUwMEU5Y2ltYWxcclxuICAgIGNvbnN0IGlzRGVjaW1hbFZhbGlkUmVzdWx0ID0gaXNEZWNpbWFsVmFsaWQoZGVjaW1hbElucHV0LnZhbHVlKTtcclxuXHJcbiAgICAvLyBTaSB0b3V0ZXMgbGVzIHZhbGlkYXRpb25zIHNvbnQgdmFsaWRlcywgcmV0b3VybmV6IHRydWUsIHNpbm9uIHJldG91cm5leiBmYWxzZVxyXG4gICAgcmV0dXJuIGlzTGFiZWxWYWxpZFJlc3VsdCAmJiBpc1Rhc2tWYWxpZFJlc3VsdCAmJiBpc1Byb2plY3RJZFZhbGlkUmVzdWx0ICYmIGlzRGVjaW1hbFZhbGlkUmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaGF2ZUxpbmVOb3RTYXZlZCh0YWJsZUJvZHkpIHtcclxuICAgIGNvbnN0IG5ld1Rhc2tTZWxlY3QgPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcigndHI6bGFzdC1jaGlsZCBzZWxlY3RbbmFtZT1cInRhc2tcIl0nKTtcclxuICAgIGlmIChuZXdUYXNrU2VsZWN0ICE9IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIFxyXG59XHJcblxyXG5cclxuXHJcblxyXG4vL2ZvbmN0aW9uIGRlIGdcdTAwRTluXHUwMEU5cmF0aW9uIGR5bmFtaXF1ZSBkZXMgbGlnbmUgZGUgc2Fpc2llXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRSb3codGFibGVCb2R5LCBUb21TZWxlY3QsIHVzZXJJZCwgZGF0ZSwgdXNlcm5hbWUsIHByb2plY3RzKSB7XHJcbiAgICAvL2xlcyBlbGVtZW50IGRlIGxpZ25lcyBcclxuICAgIGNvbnN0IG5ld1JvdyA9IGBcclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cInVzZXJfaWRcIiB2YWx1ZT1cIiR7dXNlcklkfVwiPlxyXG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJkYXRlXCI+PGlucHV0IHR5cGU9XCJkYXRlXCIgbmFtZT1cImRhdGVcIiB2YWx1ZT1cIiR7ZGF0ZX1cIj48L3RkPlxyXG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJ1c2VyXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cInVzZXJcIiB2YWx1ZT1cIiR7dXNlcm5hbWV9XCIgcmVhZG9ubHk+PC90ZD5cclxuICAgICAgICAgICAgPHRkIGNsYXNzPVwicHJvamVjdF9pZFwiPlxyXG4gICAgICAgICAgICAgICAgPHNlbGVjdCBuYW1lPVwicHJvamVjdF9pZFwiIGlkPVwidG9tX3NlbGVjdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj5TXHUwMEU5bGVjdGlvbm5lciB1biBwcm9qZXQ8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAke3Byb2plY3RzLm1hcChwcm9qZWN0ID0+IGA8b3B0aW9uIHZhbHVlPVwiJHtwcm9qZWN0LmlkfVwiPiR7cHJvamVjdC50aXRsZX08L29wdGlvbj5gKS5qb2luKCcnKX1cclxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJjbGllbnRcIj5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJjbGllbnRfbmFtZVwiIHZhbHVlPVwiXCIgcmVhZG9ubHk+XHJcbiAgICAgICAgICAgIDwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cInRhc2tcIj5cclxuICAgICAgICAgICAgICAgIDxzZWxlY3QgbmFtZT1cInRhc2tcIiBpZD1cInRhc2tzX3NlbGVjdFwiIHBsYWNlaG9sZGVyPVwiU1x1MDBFOWxlY3Rpb25lciB1bmUgdFx1MDBFMmNoZVwiPjwvc2VsZWN0PlxyXG4gICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJsYWJlbHNcIj48aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwibGFiZWxzXCIgcGxhY2Vob2xkZXI9XCJMaWJlbGxcdTAwRTlcIj48L3RkPlxyXG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJ0ZW1wc1wiPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBpZD1cImRlY2ltYWxfaW5wdXRcIiBuYW1lPVwiaG91cnNcIiBzdGVwPVwiMC4xXCIgdmFsdWU9XCIwLjBcIj5cclxuICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgPHRkIGNsYXNzPVwiYWN0aW9uc1wiPlxyXG4gICAgICAgICAgICAgICAgPGkgdGl0bGU9XCJTYXV2ZWdhcmRlclwiIGNsYXNzPVwiYmkgYmktc2F2ZVwiIHN0eWxlPVwiY3Vyc29yOiBwb2ludGVyO1wiPjwvaT5cclxuICAgICAgICAgICAgICAgIDxpIHRpdGxlPVwiU3VwcHJpbWVyXCIgaWQ9XCJzdXBwclwiIGNsYXNzPVwiYmkgYmktdHJhc2hcIiBzdHlsZT1cImN1cnNvcjogcG9pbnRlcjtcIiA+PC9pPlxyXG4gICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgIDwvdHI+XHJcbiAgICBgO1xyXG4gXHJcbiAgICB0YWJsZUJvZHkuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBuZXdSb3cpO1xyXG4gIFxyXG5cclxuXHJcbiAgICAvL2Fqb3V0IHRvbVNlbGVjdCBhIGxhIGxpc3RlIGRlcm91bGFudGUgZGVzIHByb2pldFxyXG4gICAgY29uc3QgbmV3UHJvamVjdFNlbGVjdCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIHNlbGVjdFtuYW1lPVwicHJvamVjdF9pZFwiXScpO1xyXG5cclxuICAgIG5ldyBUb21TZWxlY3QobmV3UHJvamVjdFNlbGVjdCwge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gZGUgVG9tU2VsZWN0XHJcbiAgICAgICAgc2VhcmNoYWJsZTogdHJ1ZSxcclxuICAgICAgICBzb3J0RmllbGQ6IHtcclxuICAgICAgICAgICAgZmllbGQ6IFwidGV4dFwiLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiYXNjXCJcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvL2NyZWF0aW9uIGQndW4gaW5zdGFuY2UgZGUgdG9tU2VsZWN0IGF2ZWMgbGEgbGlzdGUgZGVyb3VsYW50ZSBkZXMgdGFjaGVzIGRhbnMgbGEgbGlnbmUgbm91dmVsbGVtZW50IGdlbnJlclxyXG4gICAgY29uc3QgbmV3VGFza1NlbGVjdCA9IHRhYmxlQm9keS5xdWVyeVNlbGVjdG9yKCd0cjpsYXN0LWNoaWxkIHNlbGVjdFtuYW1lPVwidGFza1wiXScpO1xyXG4gICAgbmV3VGFza1NlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVUYXNrU2VsZWN0Q2hhbmdlKTtcclxuICAgIC8vY29uc29sZS5sb2cobmV3VGFza1NlbGVjdClcclxuICAgIHRhc2tfdG9tX3NlbGVjdCA9IG5ldyBUb21TZWxlY3QobmV3VGFza1NlbGVjdCwge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gZGUgVG9tU2VsZWN0XHJcbiAgICAgICAgc2VhcmNoYWJsZTogdHJ1ZSxcclxuICAgICAgICBzb3J0RmllbGQ6IHtcclxuICAgICAgICAgICAgZmllbGQ6IFwidGV4dFwiLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiYXNjXCJcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLy9hcHBlbGUgZGUgbGEgZm9uY3Rpb24gcXVpIGFqb3V0ZSBsZXMgc3R5bGUgZGUgY291bGV1ciBwYXJkZWZhdXQgZGVzIGNoYW1wIGp1c3RlIGFwcmVzIGF2b2lyIGNyZWVyIGxlcyBpbnN0YW5jZSBkZSB0b21TZWxlY3RcclxuICAgIGFwcGx5RmllbGRWYWxpZGF0aW9ucyh0YWJsZUJvZHkpXHJcblxyXG4gICAgLy9leHRyYWN0IGxlIHByb2pldCBzZWxlY3Rpb25lciBwb3VyIHJlY3VwZXJlciBsZXMgdGFjaGUgY29ycmVzcG9uZGFudFxyXG4gICAgY29uc3QgcHJvamVjdFNlbGVjdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdFtuYW1lPVwicHJvamVjdF9pZFwiXScpO1xyXG4gICAgLy8gQWpvdXQgZCd1biBcdTAwRTljb3V0ZXVyIGQnXHUwMEU5dlx1MDBFOW5lbWVudHMgXHUwMEUwIHByb2plY3RTZWxlY3QgYXZlYyB1bmUgZm9uY3Rpb24gZGUgcmFwcGVsXHJcbiAgICBwcm9qZWN0U2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIC8vIEFwcGVsIGRlIGhhbmRsZVByb2plY3RTZWxlY3RDaGFuZ2UgYXZlYyBsJ29iamV0IGV2ZW50IGV0IHRhc2tfdG9tX3NlbGVjdFxyXG4gICAgICAgIGhhbmRsZVByb2plY3RTZWxlY3RDaGFuZ2UoZXZlbnQsIHRhc2tfdG9tX3NlbGVjdCk7XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLy8gQWpvdXQgZCd1biBcdTAwRTljb3V0ZXVyIGQnXHUwMEU5dlx1MDBFOW5lbWVudHMgc3VyIGwnZW50clx1MDBFOWUgZFx1MDBFOWNpbWFsZSBwb3VyIGxhIHZhbGlkYXRpb24gZW4gZGlyZWN0XHJcbiAgICBjb25zdCBkZWNpbWFsSW5wdXQgPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcigndHI6bGFzdC1jaGlsZCBpbnB1dFtuYW1lPVwiaG91cnNcIl0nKTtcclxuICAgIGRlY2ltYWxJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGhhbmRsZURlY2ltYWxJbnB1dCk7XHJcblxyXG4gICAgXHJcbiAgICBjb25zdCBsYWJlbElucHV0ID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJ3RyOmxhc3QtY2hpbGQgaW5wdXRbbmFtZT1cImxhYmVsc1wiXScpO1xyXG4gICAgLy8gQWpvdXQgZCd1biBcdTAwRTljb3V0ZXVyIGQnXHUwMEU5dlx1MDBFOW5lbWVudHMgc3VyIGxlIGNoYW1wIGRlIHRleHRlIHBvdXIgbGEgdmFsaWRhdGlvbiBlbiBkaXJlY3RcclxuICAgIGxhYmVsSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBoYW5kbGVMYWJlbElucHV0KTtcclxuXHJcbiAgICAvLyBBam91dGV6IGxlcyBcdTAwRTljb3V0ZXVycyBkJ1x1MDBFOXZcdTAwRTluZW1lbnRzIGF1eCBpY1x1MDBGNG5lcyBzYXV2ZWdhcmRlciBldCBzdXBwcmltZXIgZGUgbGEgbm91dmVsbGUgbGlnbmVcclxuICAgIGNvbnN0IG5ld1NhdmVJY29uID0gdGFibGVCb2R5LnF1ZXJ5U2VsZWN0b3IoJy5iaS1zYXZlJyk7XHJcbiAgICBuZXdTYXZlSWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBWXHUwMEU5cmlmaWV6IGxhIHZhbGlkaXRcdTAwRTkgZGVzIGNoYW1wcyBkZSBsYSBkZXJuaVx1MDBFOHJlIGxpZ25lXHJcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGxpbmVWYWxpZGF0aW9uKHRhYmxlQm9keSk7XHJcblxyXG4gICAgICAgIC8vIFNpIHRvdXMgbGVzIGNoYW1wcyBzb250IHZhbGlkZXMsIGFwcGVsZXogbGEgZm9uY3Rpb24gc2F2ZVJvd1xyXG4gICAgICAgIGlmIChpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHNhdmVSb3cobmV3U2F2ZUljb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFNpbm9uLCBhZmZpY2hleiB1biBtZXNzYWdlIGQnZXJyZXVyIG91IGVmZmVjdHVleiB1bmUgYXV0cmUgYWN0aW9uXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMZXMgY2hhbXBzIG5lIHNvbnQgcGFzIHZhbGlkZXMuIFZldWlsbGV6IHZcdTAwRTlyaWZpZXIgdm9zIHNhaXNpZXMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gc3VwcHJlc3Npb24gZGVzIGxpZ25lcyBnZW5yZXJcclxuICAgIGNvbnN0IG5ld1JlbW92ZUljb24gPSB0YWJsZUJvZHkucXVlcnlTZWxlY3RvcignI3N1cHByJyk7XHJcbiAgICBjb25zb2xlLmxvZyhuZXdSZW1vdmVJY29uKVxyXG4gICAgbmV3UmVtb3ZlSWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZW1vdmVSb3cobmV3UmVtb3ZlSWNvbik7XHJcbiAgICAgICAgcmVzZXRBZGRSb3dJY29uKCk7XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiAgICBcclxuICAgXHJcblxyXG5cclxuXHJcbn1cclxuLy9mb25jdGlvbiBkZSBtaXNlIFx1MDBFMCBqb3VyIGRlIGxhIGxpc3RlIGRcdTAwRTlyb3VsYW50ZSBkZXMgdFx1MDBFMmNoZXMgcGFyIHByb2pldCBzXHUwMEU5bGVjdGlvbm5cdTAwRTlcclxuLy9hcHBlbCBcdTAwRTAgdW5lIEFQSSBkYW5zIFRhc2tDb250cm9sbGVyLnRhc2tfYnlfcHJvamVjdCA9PiByZXRvdXJuZSBsZXMgdFx1MDBFMmNoZXMgZXQgbGVzIGRcdTAwRTl0YWlscyBkdSBjbGllbnQgcmF0dGFjaFx1MDBFOSBhdSBwcm9qZXQgc1x1MDBFOWxlY3Rpb25uXHUwMEU5XHJcbmZ1bmN0aW9uIHVwZGF0ZVRhc2tPcHRpb25zKHNlbGVjdGVkUHJvamVjdElkLCB0YXNrVG9tU2VsZWN0KSB7XHJcbiAgICAvLyBWb3RyZSBsb2dpcXVlIHBvdXIgbWV0dHJlIFx1MDBFMCBqb3VyIGxlcyBvcHRpb25zIGR1IG1lbnUgZFx1MDBFOXJvdWxhbnQgZGVzIHRcdTAwRTJjaGVzIGljaVxyXG4gICAgLy9jb25zb2xlLmxvZygnUHJvamV0IHNcdTAwRTlsZWN0aW9ublx1MDBFOTonLCBzZWxlY3RlZFByb2plY3RJZCk7XHJcblxyXG4gICAgLy8gRWZmZWN0dWVyIHVuZSByZXF1XHUwMEVBdGUgQUpBWCB2ZXJzIHZvdHJlIGVuZHBvaW50IGJhY2tlbmQgcG91ciByXHUwMEU5Y3VwXHUwMEU5cmVyIGxlcyB0XHUwMEUyY2hlcyBhc3NvY2lcdTAwRTllcyBhdSBwcm9qZXQgc1x1MDBFOWxlY3Rpb25uXHUwMEU5XHJcbiAgICBmZXRjaChgL3Rhc2tzLyR7c2VsZWN0ZWRQcm9qZWN0SWR9YClcclxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKVxyXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VycmV1ciBsb3JzIGRlIGxhIHJcdTAwRTljdXBcdTAwRTlyYXRpb24gZGVzIHRcdTAwRTJjaGVzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAvLyBNZXR0cmUgXHUwMEUwIGpvdXIgbGEgbGlzdGUgZFx1MDBFOXJvdWxhbnRlIGRlcyB0XHUwMEUyY2hlcyBhdmVjIGxlcyBkb25uXHUwMEU5ZXMgclx1MDBFOWN1cFx1MDBFOXJcdTAwRTllc1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxyXG4gICAgICAgICAgICBjb25zdCB0YXNrcyA9IGRhdGEudGFza3M7XHJcbiAgICAgICAgICAgIHRhc2tUb21TZWxlY3QuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGFza1RvbVNlbGVjdC5jbGVhck9wdGlvbnMoKTsgLy8gRWZmYWNlciBsZXMgb3B0aW9ucyBwclx1MDBFOWNcdTAwRTlkZW50ZXNcclxuICAgICAgICAgICAgdGFza3MuZm9yRWFjaCh0YXNrID0+IHtcclxuICAgICAgICAgICAgICAgIHRhc2tUb21TZWxlY3QuYWRkT3B0aW9uKHsgdmFsdWU6IHRhc2suaWQsIHRleHQ6IHRhc2sudGl0bGUgfSk7ICAvL2Fqb3V0IGRlcyBub3V2ZWxsZXMgb3B0aW9uIGEgbCdpbnN0YW5jZSBkdSB0b21TZWxlY3QgcGFzc2VyIGVuIHBhcmFtZXRyZXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIFRyYWl0ZW1lbnQgZGVzIGRcdTAwRTl0YWlscyBjbGllbnRzXHJcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudERldGFpbHMgPSBkYXRhLmNsaWVudF9kZXRhaWxzO1xyXG4gICAgICAgICAgICAvLyBFeGVtcGxlIGQndXRpbGlzYXRpb24gZGVzIGRcdTAwRTl0YWlscyBkdSBjbGllbnRcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ05vbSBkdSBjbGllbnQ6JywgY2xpZW50RGV0YWlscy5jbGllbnRzX25hbWUpO1xyXG4gICAgICAgICAgICBjb25zdCBjbGllbnROYW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwiY2xpZW50X25hbWVcIl0nKTtcclxuICAgICAgICAgICAgY2xpZW50TmFtZUlucHV0LnZhbHVlID0gY2xpZW50RGV0YWlscy5jbGllbnRzX25hbWU7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjbGllbnROYW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwiY2xpZW50X25hbWVcIl0nKTtcclxuICAgICAgICAgICAgY2xpZW50TmFtZUlucHV0LnZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIHRhc2tUb21TZWxlY3QuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGFza1RvbVNlbGVjdC5jbGVhck9wdGlvbnMoKTsgLy8gRWZmYWNlciBsZXMgb3B0aW9ucyBwclx1MDBFOWNcdTAwRTlkZW50ZXNcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGFza1RvbVNlbGVjdCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0VycmV1ciA6JywgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxuLy9yZXNldCBhZGQgcm93IGljb24gXHJcbmZ1bmN0aW9uIHJlc2V0QWRkUm93SWNvbigpIHtcclxuICAgIHZhciBhZGRSb3dMaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZFJvd0ljb24nKTsgXHJcbiAgICB2YXIgYWRkUm93SWNvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhZGRSb3dJY29uIGknKTtcclxuICAgIGFkZFJvd0xpbmsuY2xhc3NMaXN0LnJlbW92ZSgnbm9uLWNsaXF1YWJsZScpO1xyXG4gICAgYWRkUm93SWNvbi5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XHJcbn1cclxuXHJcblxyXG4iLCAidmFyIGF1dGhvcml6ZWRJbnB1dHMgPSB7XHJcbiAgQWRtaW46IFtcclxuICAgIFwidGFza190aXRsZVwiLFxyXG4gICAgXCJ0YXNrX2Rlc2NyaXB0aW9uXCIsXHJcbiAgICBcInBhcmVudF90YXNrXCIsXHJcbiAgICBcImFzc2lnbmVkX3BlcnNvblwiLFxyXG4gICAgXCJkdWVfZGF0ZVwiLFxyXG4gICAgXCJzdGFydF9kYXRlXCIsXHJcbiAgICBcIm9yaWdpbmFsX2VzdGltYXRlXCIsXHJcbiAgICBcInByb2dyZXNzXCIsXHJcbiAgICBcInNhdmVcIixcclxuICAgIFwiY3Vycl91c2VyXCIsXHJcbiAgICBcInByb19pZFwiLFxyXG4gICAgXCJzdGF0dXNfaWRcIixcclxuICAgIFwicHJpb3JpdHlfaWRcIixcclxuICAgIFwidGFza19kZWFkbGluZVwiLFxyXG4gIF0sXHJcbiAgQXR0cmlidXRldXI6IFtcclxuICAgIFwidGFza190aXRsZVwiLFxyXG4gICAgXCJ0YXNrX2Rlc2NyaXB0aW9uXCIsXHJcbiAgICBcInBhcmVudF90YXNrXCIsXHJcbiAgICBcImFzc2lnbmVkX3BlcnNvblwiLFxyXG4gICAgXCJkdWVfZGF0ZVwiLFxyXG4gICAgXCJzdGFydF9kYXRlXCIsXHJcbiAgICBcIm9yaWdpbmFsX2VzdGltYXRlXCIsXHJcbiAgICBcInByb2dyZXNzXCIsXHJcbiAgICBcInNhdmVcIixcclxuICAgIFwiY3Vycl91c2VyXCIsXHJcbiAgICBcInByb19pZFwiLFxyXG4gICAgXCJzdGF0dXNfaWRcIixcclxuICAgIFwicHJpb3JpdHlfaWRcIixcclxuICAgIFwidGFza19kZWFkbGluZVwiLFxyXG4gIF0sXHJcbiAgQ29udHJpYnV0ZXVyOiBbXHJcbiAgICBcInRhc2tfdGl0bGVcIixcclxuICAgIFwidGFza19kZXNjcmlwdGlvblwiLFxyXG4gICAgXCJwcm9ncmVzc1wiLFxyXG4gICAgXCJzYXZlXCIsXHJcbiAgICBcImN1cnJfdXNlclwiLFxyXG4gICAgXCJwcm9faWRcIixcclxuICAgIFwic3RhdHVzX2lkXCIsXHJcbiAgICBcInByaW9yaXR5X2lkXCIsXHJcbiAgICBcInRhc2tfZGVhZGxpbmVcIixcclxuICBdLFxyXG4gIC8vIEFqb3V0ZXogZCdhdXRyZXMgcHJvZmlscyBldCBsZXVycyBsaXN0ZXMgZCdpbnB1dHMgYXV0b3Jpc1x1MDBFOXMgc2kgblx1MDBFOWNlc3NhaXJlXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0b2dnbGVJbnB1dHMocHJvZmlsZSkge1xyXG4gIC8vIFNcdTAwRTlsZWN0aW9ubmV6IHRvdXMgbGVzIGNoYW1wcyBkZSBmb3JtdWxhaXJlXHJcbiAgY29uc3QgaW5wdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0XCIpO1xyXG4gIGNvbnN0IHByb2ZpbGVJbnB1dHMgPSBhdXRob3JpemVkSW5wdXRzW3Byb2ZpbGVdO1xyXG4gIC8vIGNvbnNvbGUubG9nKHByb2ZpbGVJbnB1dHMsIHByb2ZpbGUpO1xyXG4gIC8vIFBhcmNvdXJleiBjaGFxdWUgY2hhbXAgZGUgZm9ybXVsYWlyZVxyXG4gIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgLy8gVlx1MDBFOXJpZmlleiBzaSBsZSBjaGFtcCBmYWl0IHBhcnRpZSBkZXMgaW5wdXRzIGF1dG9yaXNcdTAwRTlzIHBvdXIgbGUgcHJvZmlsXHJcblxyXG4gICAgaWYgKHByb2ZpbGVJbnB1dHMgJiYgcHJvZmlsZUlucHV0cy5pbmNsdWRlcyhpbnB1dC5uYW1lKSkge1xyXG4gICAgICAvLyBBY3RpdmVyIGxlIGNoYW1wIHNpIGF1dG9yaXNcdTAwRTkgcG91ciBjZSBwcm9maWxcclxuICAgICAgLy8gY29uc29sZS5sb2coaW5wdXQuaWQpO1xyXG4gICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIERcdTAwRTlzYWN0aXZlciBsZSBjaGFtcCBzJ2lsIG4nZXN0IHBhcyBhdXRvcmlzXHUwMEU5IHBvdXIgY2UgcHJvZmlsXHJcbiAgICAgIGlucHV0LmRpc2FibGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNGaXJzdERhdGVCZWZvcmVTZWNvbmREYXRlKGRhdGUxLCBkYXRlMikge1xyXG4gIC8vIENvbnZlcnRpciBsZXMgZGF0ZXMgZW4gb2JqZXRzIERhdGVcclxuICB2YXIgZmlyc3REYXRlID0gbmV3IERhdGUoZGF0ZTEpO1xyXG4gIHZhciBzZWNvbmREYXRlID0gbmV3IERhdGUoZGF0ZTIpO1xyXG5cclxuICAvLyBDb21wYXJlciBsZXMgZGF0ZXNcclxuICByZXR1cm4gZmlyc3REYXRlIDwgc2Vjb25kRGF0ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlc2FjdGl2YXRlQWxsaW5wdXRzKCkge1xyXG4gIC8vIFNcdTAwRTlsZWN0aW9uIGRlIGxhIGRpdiBwcmluY2lwYWxlXHJcbiAgdmFyIG1haW5EaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNob3dpbmdfdGFza1wiKTtcclxuXHJcbiAgLy8gU1x1MDBFOWxlY3Rpb24gZGUgdG91cyBsZXMgXHUwMEU5bFx1MDBFOW1lbnRzIGRlIGZvcm11bGFpcmUgZGFucyBsYSBkaXYgcHJpbmNpcGFsZVxyXG4gIHZhciBpbnB1dHMgPSBtYWluRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdFwiKTtcclxuXHJcbiAgLy8gUGFyY291cmlyIHRvdXMgbGVzIFx1MDBFOWxcdTAwRTltZW50cyBkZSBmb3JtdWxhaXJlIGV0IGFjdGl2ZXIgbGVzIGNoYW1wc1xyXG4gIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlO1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPbk1vZGlmQnRuKHByb2ZpbGUpIHtcclxuICB2YXIgc2F2ZUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2F2ZVwiKTtcclxuICB2YXIgY2FuY2VsQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW5jZWxcIik7XHJcbiAgdmFyIG1vZGlmQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2RpZnlcIik7XHJcbiAgLy8gdmFyIHRhc2tfaW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRhc2tfdGl0bGVcIik7XHJcbiAgc2F2ZUJ0bi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcclxuICBzYXZlQnRuLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xyXG4gIGNhbmNlbEJ0bi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcclxuICBjYW5jZWxCdG4uc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XHJcbiAgbW9kaWZCdG4uc3R5bGUuZGlzcGxheSA9IFwiY29udGVudHNcIjtcclxuICBtb2RpZkJ0bi5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIjtcclxuICB0b2dnbGVJbnB1dHMocHJvZmlsZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVDbGlja09uQ2FuY2VsQnRuKCkge1xyXG4gIHZhciBzYXZlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYXZlXCIpO1xyXG4gIHZhciBjYW5jZWxCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbmNlbFwiKTtcclxuICB2YXIgbW9kaWZCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1vZGlmeVwiKTtcclxuXHJcbiAgc2F2ZUJ0bi5zdHlsZS5kaXNwbGF5ID0gXCJjb250ZW50c1wiO1xyXG4gIHNhdmVCdG4uc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCI7XHJcbiAgY2FuY2VsQnRuLnN0eWxlLmRpc3BsYXkgPSBcImNvbnRlbnRzXCI7XHJcbiAgY2FuY2VsQnRuLnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiO1xyXG4gIG1vZGlmQnRuLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gIG1vZGlmQnRuLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xyXG4gIGRlc2FjdGl2YXRlQWxsaW5wdXRzKCk7XHJcbn1cclxuXHJcbi8vIEZvbmN0aW9uIHBvdXIgdmFsaWRlciBsYSBzYWlzaWUgZGFucyBsZSBjaGFtcCBcInByb2dyZXNzXCJcclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9ncmVzc0lucHV0KHZhbHVlKSB7XHJcbiAgLy8gVlx1MDBFOXJpZmllIHNpIGxhIHZhbGV1ciBlc3QgdW4gbm9tYnJlXHJcbiAgaWYgKCFpc05hTih2YWx1ZSkpIHtcclxuICAgIC8vIFZcdTAwRTlyaWZpZSBzaSBsYSB2YWxldXIgZXN0IGNvbXByaXNlIGVudHJlIDAgZXQgMTAwXHJcbiAgICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxMDApIHtcclxuICAgICAgLy8gTGEgdmFsZXVyIGVzdCB2YWxpZGVcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJMYSB2YWxldXIgZXN0IHZhbGlkZSA6XCIsIHZhbHVlKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBMYSB2YWxldXIgZXN0IGVuIGRlaG9ycyBkZSBsYSBwbGFnZSBhdXRvcmlzXHUwMEU5ZVxyXG4gICAgICAvL2NvbnNvbGUubG9nKFwiTGEgdmFsZXVyIGRvaXQgXHUwMEVBdHJlIGNvbXByaXNlIGVudHJlIDAgZXQgMTAwXCIpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIExhIHZhbGV1ciBuJ2VzdCBwYXMgdW4gbm9tYnJlXHJcbiAgICAvL2NvbnNvbGUubG9nKFwiTGEgdmFsZXVyIGRvaXQgXHUwMEVBdHJlIHVuIG5vbWJyZVwiKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlRGF0ZUlucHV0cygpIHtcclxuICAvLyBSXHUwMEU5Y3VwXHUwMEU5cmVyIGxlcyBcdTAwRTlsXHUwMEU5bWVudHMgaW5wdXQgZGVzIGNoYW1wcyBkZSBkYXRlXHJcbiAgdmFyIHN0YXJ0RGF0ZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGFydF9kYXRlXCIpO1xyXG4gIHZhciBkdWVEYXRlSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR1ZV9kYXRlXCIpO1xyXG5cclxuICAvLyBSXHUwMEU5Y3VwXHUwMEU5cmVyIGxlcyB2YWxldXJzIGRlcyBjaGFtcHMgZGUgZGF0ZVxyXG4gIHZhciBzdGFydERhdGVWYWx1ZSA9IHN0YXJ0RGF0ZUlucHV0LnZhbHVlO1xyXG4gIHZhciBkdWVEYXRlVmFsdWUgPSBkdWVEYXRlSW5wdXQudmFsdWU7XHJcblxyXG4gIC8vIFJcdTAwRTlpbml0aWFsaXNlciBsZXMgbWVzc2FnZXMgZCdlcnJldXIgZGFucyBsZXMgbGFiZWxzXHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGFydF9kYXRlX2Vycm9yXCIpLnRleHRDb250ZW50ID1cclxuICAgIFwiTGEgZGF0ZSBkJ1x1MDBFOWNoXHUwMEU5YW5jZSBuZSBwZXV0IHBhcyBcdTAwRUF0cmUgYW50XHUwMEU5cmlldXJlIFx1MDBFMCBsYSBkYXRlIGRlIGRcdTAwRTlidXRcIjtcclxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXJ0X2RhdGVfZXJyb3JcIikuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkdWVfZGF0ZV9lcnJvclwiKS50ZXh0Q29udGVudCA9XHJcbiAgICBcIkxhIGRhdGUgZCdcdTAwRTljaFx1MDBFOWFuY2UgbmUgcGV1dCBwYXMgXHUwMEVBdHJlIGFudFx1MDBFOXJpZXVyZSBcdTAwRTAgbGEgZGF0ZSBkZSBkXHUwMEU5YnV0XCI7XHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkdWVfZGF0ZV9lcnJvclwiKS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcclxuXHJcbiAgLy8gVlx1MDBFOXJpZmllciBzaSBsZXMgY2hhbXBzIGRlIGRhdGUgc29udCB2aWRlc1xyXG4gIGlmICghc3RhcnREYXRlVmFsdWUpIHtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhcnRfZGF0ZV9lcnJvclwiKS50ZXh0Q29udGVudCA9XHJcbiAgICAgIFwiVmV1aWxsZXogZW50cmVyIHVuZSBkYXRlIGRlIGRcdTAwRTlidXRcIjtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhcnRfZGF0ZV9lcnJvclwiKS5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIjtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICghZHVlRGF0ZVZhbHVlKSB7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR1ZV9kYXRlX2Vycm9yXCIpLnRleHRDb250ZW50ID1cclxuICAgICAgXCJWZXVpbGxleiBlbnRyZXIgdW5lIGRhdGUgZCdcdTAwRTljaFx1MDBFOWFuY2VcIjtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHVlX2RhdGVfZXJyb3JcIikuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBWXHUwMEU5cmlmaWVyIHNpIGxlcyBkYXRlcyBzb250IGF1IGJvbiBmb3JtYXRcclxuICBpZiAoaXNOYU4oRGF0ZS5wYXJzZShzdGFydERhdGVWYWx1ZSkpKSB7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXJ0X2RhdGVfZXJyb3JcIikudGV4dENvbnRlbnQgPVxyXG4gICAgICBcIkZvcm1hdCBkZSBkYXRlIGludmFsaWRlXCI7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXJ0X2RhdGVfZXJyb3JcIikuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNOYU4oRGF0ZS5wYXJzZShkdWVEYXRlVmFsdWUpKSkge1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkdWVfZGF0ZV9lcnJvclwiKS50ZXh0Q29udGVudCA9XHJcbiAgICAgIFwiRm9ybWF0IGRlIGRhdGUgaW52YWxpZGVcIjtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHVlX2RhdGVfZXJyb3JcIikuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBWXHUwMEU5cmlmaWVyIHNpIGxhIGRhdGUgZCdcdTAwRTljaFx1MDBFOWFuY2UgZXN0IGFudFx1MDBFOXJpZXVyZSBcdTAwRTAgbGEgZGF0ZSBkZSBkXHUwMEU5YnV0XHJcbiAgaWYgKGlzRmlyc3REYXRlQmVmb3JlU2Vjb25kRGF0ZShkdWVEYXRlVmFsdWUsIHN0YXJ0RGF0ZVZhbHVlKSkge1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkdWVfZGF0ZV9lcnJvclwiKS50ZXh0Q29udGVudCA9XHJcbiAgICAgIFwiTGEgZGF0ZSBkJ1x1MDBFOWNoXHUwMEU5YW5jZSBuZSBwZXV0IHBhcyBcdTAwRUF0cmUgYW50XHUwMEU5cmlldXJlIFx1MDBFMCBsYSBkYXRlIGRlIGRcdTAwRTlidXRcIjtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHVlX2RhdGVfZXJyb3JcIikuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0RGVjaW1hbFZhbCh2YWx1ZSkge1xyXG4gIHZhciBudW1WYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IG51bVZhbHVlLnRvRml4ZWQoMik7XHJcbiAgcmV0dXJuIGZvcm1hdHRlZFZhbHVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZUVzdGltYXRpb25JbnB1dCh2YWx1ZSkge1xyXG4gIHZhciBudW1WYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG5cclxuICAvLyBWXHUwMEU5cmlmaWVyIHNpIGxhIHZhbGV1ciBlc3QgdW4gbm9tYnJlXHJcbiAgaWYgKGlzTmFOKG51bVZhbHVlKSkge1xyXG4gICAgLy8gY29uc29sZS5sb2coXCJMYSB2YWxldXIgZW50clx1MDBFOWUgbidlc3QgcGFzIHVuIG5vbWJyZSB2YWxpZGUuXCIpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gVlx1MDBFOXJpZmllciBzaSBsYSB2YWxldXIgZXN0IG5cdTAwRTlnYXRpdmVcclxuICBpZiAobnVtVmFsdWUgPCAwKSB7XHJcbiAgICAvL2NvbnNvbGUubG9nKFwiTGEgdmFsZXVyIG5lIHBldXQgcGFzIFx1MDBFQXRyZSBuXHUwMEU5Z2F0aXZlLlwiKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXROdW1iZXJJbnB1dCh2YWx1ZSkge1xyXG4gIC8vIFJlbXBsYWNleiB0b3V0ZXMgbGVzIGNhcmFjdFx1MDBFOHJlcyBub24gbnVtXHUwMEU5cmlxdWVzIHBhciB1bmUgY2hhXHUwMEVFbmUgdmlkZVxyXG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXEQvZywgXCJcIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzSW5wdXQoZXZlbnQpIHtcclxuICBmb3JtYXRlZF92YWx1ZSA9IGZvcm1hdE51bWJlcklucHV0KHRoaXMudmFsdWUpO1xyXG4gIGlzX3ZhbGlkID0gdmFsaWRhdGVQcm9ncmVzc0lucHV0KHRoaXMudmFsdWUpO1xyXG4gIC8vY29uc29sZS5sb2codGhpcy52YWx1ZSwgZm9ybWF0ZWRfdmFsdWUsIGlzX3ZhbGlkKTtcclxuICBpZiAoaXNfdmFsaWQpIHtcclxuICAgIHRoaXMudmFsdWUgPSBmb3JtYXRlZF92YWx1ZTtcclxuICB9IGVsc2UgdGhpcy52YWx1ZSA9IFwiXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZURhdGVJbnB1dENoYW5nZShldmVudCkge1xyXG4gIC8vIFJcdTAwRTljdXBcdTAwRTlyZXIgbCdcdTAwRTlsXHUwMEU5bWVudCBpbnB1dCBxdWkgYSBkXHUwMEU5Y2xlbmNoXHUwMEU5IGwnXHUwMEU5dlx1MDBFOW5lbWVudFxyXG4gIHZhciBpbnB1dCA9IGV2ZW50LnRhcmdldDtcclxuICBjb25zb2xlLmxvZyhcIm1ha2F0b1wiKTtcclxuICAvLyBWYWxpZGVyIGxhIHZhbGV1ciBzYWlzaWUgZGFucyBsZSBjaGFtcCBkZSBkYXRlXHJcbiAgY29uc29sZS5sb2codmFsaWRhdGVEYXRlSW5wdXRzKCkpO1xyXG5cclxuICAvLyBWb3VzIHBvdXZleiBham91dGVyIGQnYXV0cmVzIGFjdGlvbnMgZW4gZm9uY3Rpb24gZGUgbGEgdmFsaWRhdGlvbiBpY2lcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlRXN0aW1hdGlvbklucHV0KGV2ZW50KSB7XHJcbiAgbGV0IGZpbHRyZWR2YWwgPSB0aGlzLnZhbHVlLnJlcGxhY2UoL1teMC05Ll0vZywgXCJcIik7XHJcbiAgY29uc29sZS5sb2coZmlsdHJlZHZhbCk7XHJcbiAgdmFsID0gcGFyc2VGbG9hdChmaWx0cmVkdmFsKTtcclxuICBjb25zb2xlLmxvZyhpc05hTih2YWwpLCB2YWwsIGZpbHRyZWR2YWwpO1xyXG4gIGlmICghaXNOYU4odmFsKSB8fCB2YWwgPiAwKSB7XHJcbiAgICBjb25zb2xlLmxvZyhmaWx0cmVkdmFsKTtcclxuICAgIC8vdGhpcy52YWx1ZSA9IGZpbHRyZWR2YWw7XHJcbiAgICBsZXQgZGVjaW1hbExlbmd0aCA9IChmaWx0cmVkdmFsLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XHJcbiAgICAvL2NvbnNvbGUubG9nKGRlY2ltYWxMZW5ndGgpO1xyXG4gICAgaWYgKGRlY2ltYWxMZW5ndGggPiAyKSB7XHJcbiAgICAgIHZhbGV1ciA9IHBhcnNlRmxvYXQoZmlsdHJlZHZhbCkudG9GaXhlZCgyKTtcclxuICAgICAgdGhpcy52YWx1ZSA9IHZhbGV1cjsgLy8gTGltaXRlciBcdTAwRTAgZGV1eCBjaGlmZnJlcyBhcHJcdTAwRThzIGxhIHZpcmd1bGVcclxuICAgIH1cclxuICB9IGVsc2UgdGhpcy52YWx1ZSA9IFwiXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRCdXR0b25BY3Rpb24ocHJvZmlsZSkge1xyXG4gIHZhciBtb2RpZkJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibW9kaWZ5XCIpO1xyXG4gIG1vZGlmQnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBoYW5kbGVDbGlja09uTW9kaWZCdG4ocHJvZmlsZSk7XHJcbiAgfSk7XHJcblxyXG4gIHZhciBjYW5jZWxCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbmNlbFwiKTtcclxuICBjYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgIGhhbmRsZUNsaWNrT25DYW5jZWxCdG4oKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZEFsbElucHV0c0V2ZW50KCkge1xyXG4gIHZhciBwcm9ncmVzc0lucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcm9ncmVzc1wiKTtcclxuICBwcm9ncmVzc0lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBoYW5kbGVQcm9ncmVzc0lucHV0KTtcclxuICAvLyBTXHUwMEU5bGVjdGlvbm5lciBsZXMgXHUwMEU5bFx1MDBFOW1lbnRzIGlucHV0IGRlcyBjaGFtcHMgZGUgZGF0ZVxyXG4gIHZhciBzdGFydERhdGVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhcnRfZGF0ZVwiKTtcclxuICB2YXIgZHVlRGF0ZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkdWVfZGF0ZVwiKTtcclxuXHJcbiAgdmFyIGVzdGltYXRpb25JbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZXN0aW1hdGlvbl92YWxcIik7XHJcbiAgY29uc29sZS5sb2coZXN0aW1hdGlvbklucHV0KTtcclxuICBlc3RpbWF0aW9uSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGhhbmRsZUVzdGltYXRpb25JbnB1dCk7XHJcblxyXG4gIC8vIEFqb3V0ZXIgdW4gXHUwMEU5Y291dGV1ciBkJ1x1MDBFOXZcdTAwRTluZW1lbnRzIHBvdXIgc3VydmVpbGxlciBsZXMgbW9kaWZpY2F0aW9ucyBkYW5zIGxlIGNoYW1wIGRlIGRhdGUgZGUgZFx1MDBFOWJ1dFxyXG4gIHN0YXJ0RGF0ZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRGF0ZUlucHV0Q2hhbmdlKTtcclxuXHJcbiAgLy8gQWpvdXRlciB1biBcdTAwRTljb3V0ZXVyIGQnXHUwMEU5dlx1MDBFOW5lbWVudHMgcG91ciBzdXJ2ZWlsbGVyIGxlcyBtb2RpZmljYXRpb25zIGRhbnMgbGUgY2hhbXAgZGUgZGF0ZSBkJ1x1MDBFOWNoXHUwMEU5YW5jZVxyXG4gIGR1ZURhdGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURhdGVJbnB1dENoYW5nZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlcklucHV0KGlucHV0KSB7XHJcbiAgLy8gUmVtcGxhY2UgdG91dCBjZSBxdWkgbidlc3QgbmkgdW4gY2hpZmZyZSBuaSB1biBwb2ludCBwYXIgdW5lIGNoYVx1MDBFRW5lIHZpZGVcclxuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxEL2csIFwiXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2hvd1Rhc2socHJvZmlsZSkge1xyXG4gIHZhciBzYXZlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYXZlXCIpO1xyXG4gIHNhdmVCdG4uc3R5bGUuZGlzcGxheSA9IFwiY29udGVudHNcIjtcclxuICBsb2FkQnV0dG9uQWN0aW9uKHByb2ZpbGUpO1xyXG5cclxuICBsb2FkQWxsSW5wdXRzRXZlbnQoKTtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFBvbHlmaWxsRXZlbnQgPSBldmVudENvbnN0cnVjdG9yKCk7XG5cbiAgZnVuY3Rpb24gZXZlbnRDb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gd2luZG93LkN1c3RvbUV2ZW50O1xuICAgIC8vIElFPD05IFN1cHBvcnRcbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge2J1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWR9O1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfVxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRIaWRkZW5JbnB1dChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGVsZW1lbnQsIHRhcmdldE1vZGlmaWVyS2V5KSB7XG4gICAgdmFyIHRvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvXCIpLFxuICAgICAgICBtZXRob2QgPSBidWlsZEhpZGRlbklucHV0KFwiX21ldGhvZFwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSxcbiAgICAgICAgY3NyZiA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfY3NyZl90b2tlblwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY3NyZlwiKSksXG4gICAgICAgIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgc3VibWl0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuICAgICAgICB0YXJnZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcblxuICAgIGZvcm0ubWV0aG9kID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikgPT09IFwiZ2V0XCIpID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICAgIGZvcm0uYWN0aW9uID0gdG87XG4gICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICBpZiAodGFyZ2V0KSBmb3JtLnRhcmdldCA9IHRhcmdldDtcbiAgICBlbHNlIGlmICh0YXJnZXRNb2RpZmllcktleSkgZm9ybS50YXJnZXQgPSBcIl9ibGFua1wiO1xuXG4gICAgZm9ybS5hcHBlbmRDaGlsZChjc3JmKTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKG1ldGhvZCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIC8vIEluc2VydCBhIGJ1dHRvbiBhbmQgY2xpY2sgaXQgaW5zdGVhZCBvZiB1c2luZyBgZm9ybS5zdWJtaXRgXG4gICAgLy8gYmVjYXVzZSB0aGUgYHN1Ym1pdGAgZnVuY3Rpb24gZG9lcyBub3QgZW1pdCBhIGBzdWJtaXRgIGV2ZW50LlxuICAgIHN1Ym1pdC50eXBlID0gXCJzdWJtaXRcIjtcbiAgICBmb3JtLmFwcGVuZENoaWxkKHN1Ym1pdCk7XG4gICAgc3VibWl0LmNsaWNrKCk7XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGUudGFyZ2V0O1xuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKSB7XG4gICAgICB2YXIgcGhvZW5peExpbmtFdmVudCA9IG5ldyBQb2x5ZmlsbEV2ZW50KCdwaG9lbml4LmxpbmsuY2xpY2snLCB7XG4gICAgICAgIFwiYnViYmxlc1wiOiB0cnVlLCBcImNhbmNlbGFibGVcIjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghZWxlbWVudC5kaXNwYXRjaEV2ZW50KHBob2VuaXhMaW5rRXZlbnQpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSkge1xuICAgICAgICBoYW5kbGVDbGljayhlbGVtZW50LCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIGZhbHNlKTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGhvZW5peC5saW5rLmNsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbWVzc2FnZSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29uZmlybVwiKTtcbiAgICBpZihtZXNzYWdlICYmICF3aW5kb3cuY29uZmlybShtZXNzYWdlKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xufSkoKTtcbiIsICIvLyB3cmFwcyB2YWx1ZSBpbiBjbG9zdXJlIG9yIHJldHVybnMgY2xvc3VyZVxuZXhwb3J0IGxldCBjbG9zdXJlID0gKHZhbHVlKSA9PiB7XG4gIGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKXtcbiAgICByZXR1cm4gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBsZXQgY2xvc3VyZSA9IGZ1bmN0aW9uICgpeyByZXR1cm4gdmFsdWUgfVxuICAgIHJldHVybiBjbG9zdXJlXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgZ2xvYmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IG51bGxcbmV4cG9ydCBjb25zdCBwaHhXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogbnVsbFxuZXhwb3J0IGNvbnN0IGdsb2JhbCA9IGdsb2JhbFNlbGYgfHwgcGh4V2luZG93IHx8IGdsb2JhbFxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVlNOID0gXCIyLjAuMFwiXG5leHBvcnQgY29uc3QgU09DS0VUX1NUQVRFUyA9IHtjb25uZWN0aW5nOiAwLCBvcGVuOiAxLCBjbG9zaW5nOiAyLCBjbG9zZWQ6IDN9XG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FT1VUID0gMTAwMDBcbmV4cG9ydCBjb25zdCBXU19DTE9TRV9OT1JNQUwgPSAxMDAwXG5leHBvcnQgY29uc3QgQ0hBTk5FTF9TVEFURVMgPSB7XG4gIGNsb3NlZDogXCJjbG9zZWRcIixcbiAgZXJyb3JlZDogXCJlcnJvcmVkXCIsXG4gIGpvaW5lZDogXCJqb2luZWRcIixcbiAgam9pbmluZzogXCJqb2luaW5nXCIsXG4gIGxlYXZpbmc6IFwibGVhdmluZ1wiLFxufVxuZXhwb3J0IGNvbnN0IENIQU5ORUxfRVZFTlRTID0ge1xuICBjbG9zZTogXCJwaHhfY2xvc2VcIixcbiAgZXJyb3I6IFwicGh4X2Vycm9yXCIsXG4gIGpvaW46IFwicGh4X2pvaW5cIixcbiAgcmVwbHk6IFwicGh4X3JlcGx5XCIsXG4gIGxlYXZlOiBcInBoeF9sZWF2ZVwiXG59XG5cbmV4cG9ydCBjb25zdCBUUkFOU1BPUlRTID0ge1xuICBsb25ncG9sbDogXCJsb25ncG9sbFwiLFxuICB3ZWJzb2NrZXQ6IFwid2Vic29ja2V0XCJcbn1cbmV4cG9ydCBjb25zdCBYSFJfU1RBVEVTID0ge1xuICBjb21wbGV0ZTogNFxufVxuIiwgIi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBDaGFubmVsXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IDEyM31gXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCAtIFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2gge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsLCBldmVudCwgcGF5bG9hZCwgdGltZW91dCl7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbFxuICAgIHRoaXMuZXZlbnQgPSBldmVudFxuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQgfHwgZnVuY3Rpb24gKCl7IHJldHVybiB7fSB9XG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbFxuICAgIHRoaXMucmVjSG9va3MgPSBbXVxuICAgIHRoaXMuc2VudCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAgICovXG4gIHJlc2VuZCh0aW1lb3V0KXtcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgdGhpcy5yZXNldCgpXG4gICAgdGhpcy5zZW5kKClcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgc2VuZCgpe1xuICAgIGlmKHRoaXMuaGFzUmVjZWl2ZWQoXCJ0aW1lb3V0XCIpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnN0YXJ0VGltZW91dCgpXG4gICAgdGhpcy5zZW50ID0gdHJ1ZVxuICAgIHRoaXMuY2hhbm5lbC5zb2NrZXQucHVzaCh7XG4gICAgICB0b3BpYzogdGhpcy5jaGFubmVsLnRvcGljLFxuICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICBwYXlsb2FkOiB0aGlzLnBheWxvYWQoKSxcbiAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHsqfSBzdGF0dXNcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcmVjZWl2ZShzdGF0dXMsIGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLmhhc1JlY2VpdmVkKHN0YXR1cykpe1xuICAgICAgY2FsbGJhY2sodGhpcy5yZWNlaXZlZFJlc3AucmVzcG9uc2UpXG4gICAgfVxuXG4gICAgdGhpcy5yZWNIb29rcy5wdXNoKHtzdGF0dXMsIGNhbGxiYWNrfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldCgpe1xuICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKVxuICAgIHRoaXMucmVmID0gbnVsbFxuICAgIHRoaXMucmVmRXZlbnQgPSBudWxsXG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy5zZW50ID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbWF0Y2hSZWNlaXZlKHtzdGF0dXMsIHJlc3BvbnNlLCBfcmVmfSl7XG4gICAgdGhpcy5yZWNIb29rcy5maWx0ZXIoaCA9PiBoLnN0YXR1cyA9PT0gc3RhdHVzKVxuICAgICAgLmZvckVhY2goaCA9PiBoLmNhbGxiYWNrKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuY2VsUmVmRXZlbnQoKXtcbiAgICBpZighdGhpcy5yZWZFdmVudCl7IHJldHVybiB9XG4gICAgdGhpcy5jaGFubmVsLm9mZih0aGlzLnJlZkV2ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxUaW1lb3V0KCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKVxuICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydFRpbWVvdXQoKXtcbiAgICBpZih0aGlzLnRpbWVvdXRUaW1lcil7IHRoaXMuY2FuY2VsVGltZW91dCgpIH1cbiAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQubWFrZVJlZigpXG4gICAgdGhpcy5yZWZFdmVudCA9IHRoaXMuY2hhbm5lbC5yZXBseUV2ZW50TmFtZSh0aGlzLnJlZilcblxuICAgIHRoaXMuY2hhbm5lbC5vbih0aGlzLnJlZkV2ZW50LCBwYXlsb2FkID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKVxuICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KClcbiAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZFxuICAgICAgdGhpcy5tYXRjaFJlY2VpdmUocGF5bG9hZClcbiAgICB9KVxuXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihcInRpbWVvdXRcIiwge30pXG4gICAgfSwgdGhpcy50aW1lb3V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXNSZWNlaXZlZChzdGF0dXMpe1xuICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1c1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyKHN0YXR1cywgcmVzcG9uc2Upe1xuICAgIHRoaXMuY2hhbm5lbC50cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHtzdGF0dXMsIHJlc3BvbnNlfSlcbiAgfVxufVxuIiwgIi8qKlxuICpcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtXG4gKiBjYWxjdWxhdGVkIHRpbWVvdXQgcmV0cmllcywgc3VjaCBhcyBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgcmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5jb25uZWN0KCksIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogfSlcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDUwMDBcbiAqIHJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gdGltZXJDYWxjXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHRpbWVyQ2FsYyl7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGNcbiAgICB0aGlzLnRpbWVyID0gbnVsbFxuICAgIHRoaXMudHJpZXMgPSAwXG4gIH1cblxuICByZXNldCgpe1xuICAgIHRoaXMudHJpZXMgPSAwXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhbnkgcHJldmlvdXMgc2NoZWR1bGVUaW1lb3V0IGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAgICovXG4gIHNjaGVkdWxlVGltZW91dCgpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuXG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxXG4gICAgICB0aGlzLmNhbGxiYWNrKClcbiAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpXG4gIH1cbn1cbiIsICJpbXBvcnQge2Nsb3N1cmV9IGZyb20gXCIuL3V0aWxzXCJcbmltcG9ydCB7XG4gIENIQU5ORUxfRVZFTlRTLFxuICBDSEFOTkVMX1NUQVRFUyxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IFB1c2ggZnJvbSBcIi4vcHVzaFwiXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vdGltZXJcIlxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAqIEBwYXJhbSB7KE9iamVjdHxmdW5jdGlvbil9IHBhcmFtc1xuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFubmVsIHtcbiAgY29uc3RydWN0b3IodG9waWMsIHBhcmFtcywgc29ja2V0KXtcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkXG4gICAgdGhpcy50b3BpYyA9IHRvcGljXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyB8fCB7fSlcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIHRoaXMuYmluZGluZ3MgPSBbXVxuICAgIHRoaXMuYmluZGluZ1JlZiA9IDBcbiAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0XG4gICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2VcbiAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dClcbiAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzID0gW11cblxuICAgIHRoaXMucmVqb2luVGltZXIgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luKCkgfVxuICAgIH0sIHRoaXMuc29ja2V0LnJlam9pbkFmdGVyTXMpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbkVycm9yKCgpID0+IHRoaXMucmVqb2luVGltZXIucmVzZXQoKSkpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbk9wZW4oKCkgPT4ge1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICBpZih0aGlzLmlzRXJyb3JlZCgpKXsgdGhpcy5yZWpvaW4oKSB9XG4gICAgfSlcbiAgICApXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwib2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZFxuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaChwdXNoRXZlbnQgPT4gcHVzaEV2ZW50LnNlbmQoKSlcbiAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdXG4gICAgfSlcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5vbkNsb3NlKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLmpvaW5SZWYoKX1gKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlKHRoaXMpXG4gICAgfSlcbiAgICB0aGlzLm9uRXJyb3IocmVhc29uID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKVxuICAgICAgaWYodGhpcy5pc0pvaW5pbmcoKSl7IHRoaXMuam9pblB1c2gucmVzZXQoKSB9XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgdGltZW91dCAke3RoaXMudG9waWN9ICgke3RoaXMuam9pblJlZigpfSlgLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpXG4gICAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aGlzLnRpbWVvdXQpXG4gICAgICBsZWF2ZVB1c2guc2VuZCgpXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgdGhpcy5qb2luUHVzaC5yZXNldCgpXG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKSB9XG4gICAgfSlcbiAgICB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLnJlcGx5LCAocGF5bG9hZCwgcmVmKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIodGhpcy5yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSm9pbiB0aGUgY2hhbm5lbFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRpbWVvdXRcbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIGlmKHRoaXMuam9pbmVkT25jZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmllZCB0byBqb2luIG11bHRpcGxlIHRpbWVzLiAnam9pbicgY2FuIG9ubHkgYmUgY2FsbGVkIGEgc2luZ2xlIHRpbWUgcGVyIGNoYW5uZWwgaW5zdGFuY2VcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZVxuICAgICAgdGhpcy5yZWpvaW4oKVxuICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2hcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSG9vayBpbnRvIGNoYW5uZWwgY2xvc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgaW50byBjaGFubmVsIGVycm9yc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgcmV0dXJuIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHJlYXNvbiA9PiBjYWxsYmFjayhyZWFzb24pKVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgb24gY2hhbm5lbCBldmVudHNcbiAgICpcbiAgICogU3Vic2NyaXB0aW9uIHJldHVybnMgYSByZWYgY291bnRlciwgd2hpY2ggY2FuIGJlIHVzZWQgbGF0ZXIgdG9cbiAgICogdW5zdWJzY3JpYmUgdGhlIGV4YWN0IGV2ZW50IGxpc3RlbmVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlZjEgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fc3R1ZmYpXG4gICAqIGNvbnN0IHJlZjIgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fb3RoZXJfc3R1ZmYpXG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIiwgcmVmMSlcbiAgICogLy8gU2luY2UgdW5zdWJzY3JpcHRpb24sIGRvX3N0dWZmIHdvbid0IGZpcmUsXG4gICAqIC8vIHdoaWxlIGRvX290aGVyX3N0dWZmIHdpbGwga2VlcCBmaXJpbmcgb24gdGhlIFwiZXZlbnRcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge2ludGVnZXJ9IHJlZlxuICAgKi9cbiAgb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5iaW5kaW5nUmVmKytcbiAgICB0aGlzLmJpbmRpbmdzLnB1c2goe2V2ZW50LCByZWYsIGNhbGxiYWNrfSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIG9mZiBvZiBjaGFubmVsIGV2ZW50c1xuICAgKlxuICAgKiBVc2UgdGhlIHJlZiByZXR1cm5lZCBmcm9tIGEgY2hhbm5lbC5vbigpIHRvIHVuc3Vic2NyaWJlIG9uZVxuICAgKiBoYW5kbGVyLCBvciBwYXNzIG5vdGhpbmcgZm9yIHRoZSByZWYgdG8gdW5zdWJzY3JpYmUgYWxsXG4gICAqIGhhbmRsZXJzIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFVuc3Vic2NyaWJlIHRoZSBkb19zdHVmZiBoYW5kbGVyXG4gICAqIGNvbnN0IHJlZjEgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fc3R1ZmYpXG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIiwgcmVmMSlcbiAgICpcbiAgICogLy8gVW5zdWJzY3JpYmUgYWxsIGhhbmRsZXJzIGZyb20gZXZlbnRcbiAgICogY2hhbm5lbC5vZmYoXCJldmVudFwiKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSByZWZcbiAgICovXG4gIG9mZihldmVudCwgcmVmKXtcbiAgICB0aGlzLmJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgIHJldHVybiAhKGJpbmQuZXZlbnQgPT09IGV2ZW50ICYmICh0eXBlb2YgcmVmID09PSBcInVuZGVmaW5lZFwiIHx8IHJlZiA9PT0gYmluZC5yZWYpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhblB1c2goKXsgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5pc0pvaW5lZCgpIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlIGBldmVudGAgdG8gcGhvZW5peCB3aXRoIHRoZSBwYXlsb2FkIGBwYXlsb2FkYC5cbiAgICogUGhvZW5peCByZWNlaXZlcyB0aGlzIGluIHRoZSBgaGFuZGxlX2luKGV2ZW50LCBwYXlsb2FkLCBzb2NrZXQpYFxuICAgKiBmdW5jdGlvbi4gaWYgcGhvZW5peCByZXBsaWVzIG9yIGl0IHRpbWVzIG91dCAoZGVmYXVsdCAxMDAwMG1zKSxcbiAgICogdGhlbiBvcHRpb25hbGx5IHRoZSByZXBseSBjYW4gYmUgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNoYW5uZWwucHVzaChcImV2ZW50XCIpXG4gICAqICAgLnJlY2VpdmUoXCJva1wiLCBwYXlsb2FkID0+IGNvbnNvbGUubG9nKFwicGhvZW5peCByZXBsaWVkOlwiLCBwYXlsb2FkKSlcbiAgICogICAucmVjZWl2ZShcImVycm9yXCIsIGVyciA9PiBjb25zb2xlLmxvZyhcInBob2VuaXggZXJyb3JlZFwiLCBlcnIpKVxuICAgKiAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiBjb25zb2xlLmxvZyhcInRpbWVkIG91dCBwdXNoaW5nXCIpKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0XVxuICAgKiBAcmV0dXJucyB7UHVzaH1cbiAgICovXG4gIHB1c2goZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIHBheWxvYWQgPSBwYXlsb2FkIHx8IHt9XG4gICAgaWYoIXRoaXMuam9pbmVkT25jZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNgKVxuICAgIH1cbiAgICBsZXQgcHVzaEV2ZW50ID0gbmV3IFB1c2godGhpcywgZXZlbnQsIGZ1bmN0aW9uICgpeyByZXR1cm4gcGF5bG9hZCB9LCB0aW1lb3V0KVxuICAgIGlmKHRoaXMuY2FuUHVzaCgpKXtcbiAgICAgIHB1c2hFdmVudC5zZW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIucHVzaChwdXNoRXZlbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHB1c2hFdmVudFxuICB9XG5cbiAgLyoqIExlYXZlcyB0aGUgY2hhbm5lbFxuICAgKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBzZXJ2ZXIgZXZlbnRzLCBhbmRcbiAgICogaW5zdHJ1Y3RzIGNoYW5uZWwgdG8gdGVybWluYXRlIG9uIHNlcnZlclxuICAgKlxuICAgKiBUcmlnZ2VycyBvbkNsb3NlKCkgaG9va3NcbiAgICpcbiAgICogVG8gcmVjZWl2ZSBsZWF2ZSBhY2tub3dsZWRnZW1lbnRzLCB1c2UgdGhlIGByZWNlaXZlYFxuICAgKiBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFubmVsLmxlYXZlKCkucmVjZWl2ZShcIm9rXCIsICgpID0+IGFsZXJ0KFwibGVmdCFcIikgKVxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRpbWVvdXRcbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBsZWF2ZSh0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICB0aGlzLmpvaW5QdXNoLmNhbmNlbFRpbWVvdXQoKVxuXG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmdcbiAgICBsZXQgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBsZWF2ZSAke3RoaXMudG9waWN9YClcbiAgICAgIHRoaXMudHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5jbG9zZSwgXCJsZWF2ZVwiKVxuICAgIH1cbiAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aW1lb3V0KVxuICAgIGxlYXZlUHVzaC5yZWNlaXZlKFwib2tcIiwgKCkgPT4gb25DbG9zZSgpKVxuICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IG9uQ2xvc2UoKSlcbiAgICBsZWF2ZVB1c2guc2VuZCgpXG4gICAgaWYoIXRoaXMuY2FuUHVzaCgpKXsgbGVhdmVQdXNoLnRyaWdnZXIoXCJva1wiLCB7fSkgfVxuXG4gICAgcmV0dXJuIGxlYXZlUHVzaFxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgKlxuICAgKiBSZWNlaXZlcyBhbGwgZXZlbnRzIGZvciBzcGVjaWFsaXplZCBtZXNzYWdlIGhhbmRsaW5nXG4gICAqIGJlZm9yZSBkaXNwYXRjaGluZyB0byB0aGUgY2hhbm5lbCBjYWxsYmFja3MuXG4gICAqXG4gICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHJlZlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgb25NZXNzYWdlKF9ldmVudCwgcGF5bG9hZCwgX3JlZil7IHJldHVybiBwYXlsb2FkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTWVtYmVyKHRvcGljLCBldmVudCwgcGF5bG9hZCwgam9pblJlZil7XG4gICAgaWYodGhpcy50b3BpYyAhPT0gdG9waWMpeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYoam9pblJlZiAmJiBqb2luUmVmICE9PSB0aGlzLmpvaW5SZWYoKSl7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBcImRyb3BwaW5nIG91dGRhdGVkIG1lc3NhZ2VcIiwge3RvcGljLCBldmVudCwgcGF5bG9hZCwgam9pblJlZn0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGpvaW5SZWYoKXsgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBpZih0aGlzLmlzTGVhdmluZygpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnNvY2tldC5sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKVxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nXG4gICAgdGhpcy5qb2luUHVzaC5yZXNlbmQodGltZW91dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luUmVmKXtcbiAgICBsZXQgaGFuZGxlZFBheWxvYWQgPSB0aGlzLm9uTWVzc2FnZShldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luUmVmKVxuICAgIGlmKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKXsgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXCIpIH1cblxuICAgIGxldCBldmVudEJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoYmluZCA9PiBiaW5kLmV2ZW50ID09PSBldmVudClcblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBldmVudEJpbmRpbmdzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGxldCBiaW5kID0gZXZlbnRCaW5kaW5nc1tpXVxuICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmLCBqb2luUmVmIHx8IHRoaXMuam9pblJlZigpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVwbHlFdmVudE5hbWUocmVmKXsgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNDbG9zZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0Vycm9yZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmVycm9yZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNKb2luZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0pvaW5pbmcoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmcgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNMZWF2aW5nKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nIH1cbn1cbiIsICJpbXBvcnQge1xuICBnbG9iYWwsXG4gIFhIUl9TVEFURVNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWpheCB7XG5cbiAgc3RhdGljIHJlcXVlc3QobWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICBpZihnbG9iYWwuWERvbWFpblJlcXVlc3Qpe1xuICAgICAgbGV0IHJlcSA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKSAvLyBJRTgsIElFOVxuICAgICAgcmV0dXJuIHRoaXMueGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVxID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpIC8vIElFNyssIEZpcmVmb3gsIENocm9tZSwgT3BlcmEsIFNhZmFyaVxuICAgICAgcmV0dXJuIHRoaXMueGhyUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgeGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICByZXEudGltZW91dCA9IHRpbWVvdXRcbiAgICByZXEub3BlbihtZXRob2QsIGVuZFBvaW50KVxuICAgIHJlcS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcG9uc2UpXG4gICAgfVxuICAgIGlmKG9udGltZW91dCl7IHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQgfVxuXG4gICAgLy8gV29yayBhcm91bmQgYnVnIGluIElFOSB0aGF0IHJlcXVpcmVzIGFuIGF0dGFjaGVkIG9ucHJvZ3Jlc3MgaGFuZGxlclxuICAgIHJlcS5vbnByb2dyZXNzID0gKCkgPT4geyB9XG5cbiAgICByZXEuc2VuZChib2R5KVxuICAgIHJldHVybiByZXFcbiAgfVxuXG4gIHN0YXRpYyB4aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICByZXEub3BlbihtZXRob2QsIGVuZFBvaW50LCB0cnVlKVxuICAgIHJlcS50aW1lb3V0ID0gdGltZW91dFxuICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIGFjY2VwdClcbiAgICByZXEub25lcnJvciA9ICgpID0+IGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpXG4gICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmKHJlcS5yZWFkeVN0YXRlID09PSBYSFJfU1RBVEVTLmNvbXBsZXRlICYmIGNhbGxiYWNrKXtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdGhpcy5wYXJzZUpTT04ocmVxLnJlc3BvbnNlVGV4dClcbiAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKG9udGltZW91dCl7IHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQgfVxuXG4gICAgcmVxLnNlbmQoYm9keSlcbiAgICByZXR1cm4gcmVxXG4gIH1cblxuICBzdGF0aWMgcGFyc2VKU09OKHJlc3Ape1xuICAgIGlmKCFyZXNwIHx8IHJlc3AgPT09IFwiXCIpeyByZXR1cm4gbnVsbCB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcClcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgIGNvbnNvbGUgJiYgY29uc29sZS5sb2coXCJmYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZVwiLCByZXNwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgc2VyaWFsaXplKG9iaiwgcGFyZW50S2V5KXtcbiAgICBsZXQgcXVlcnlTdHIgPSBbXVxuICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICBpZighT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSl7IGNvbnRpbnVlIH1cbiAgICAgIGxldCBwYXJhbUtleSA9IHBhcmVudEtleSA/IGAke3BhcmVudEtleX1bJHtrZXl9XWAgOiBrZXlcbiAgICAgIGxldCBwYXJhbVZhbCA9IG9ialtrZXldXG4gICAgICBpZih0eXBlb2YgcGFyYW1WYWwgPT09IFwib2JqZWN0XCIpe1xuICAgICAgICBxdWVyeVN0ci5wdXNoKHRoaXMuc2VyaWFsaXplKHBhcmFtVmFsLCBwYXJhbUtleSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeVN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwYXJhbUtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbCkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVN0ci5qb2luKFwiJlwiKVxuICB9XG5cbiAgc3RhdGljIGFwcGVuZFBhcmFtcyh1cmwsIHBhcmFtcyl7XG4gICAgaWYoT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApeyByZXR1cm4gdXJsIH1cblxuICAgIGxldCBwcmVmaXggPSB1cmwubWF0Y2goL1xcPy8pID8gXCImXCIgOiBcIj9cIlxuICAgIHJldHVybiBgJHt1cmx9JHtwcmVmaXh9JHt0aGlzLnNlcmlhbGl6ZShwYXJhbXMpfWBcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFNPQ0tFVF9TVEFURVMsXG4gIFRSQU5TUE9SVFNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IEFqYXggZnJvbSBcIi4vYWpheFwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvbmdQb2xsIHtcblxuICBjb25zdHJ1Y3RvcihlbmRQb2ludCl7XG4gICAgdGhpcy5lbmRQb2ludCA9IG51bGxcbiAgICB0aGlzLnRva2VuID0gbnVsbFxuICAgIHRoaXMuc2tpcEhlYXJ0YmVhdCA9IHRydWVcbiAgICB0aGlzLnJlcXMgPSBuZXcgU2V0KClcbiAgICB0aGlzLm9ub3BlbiA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbmNsb3NlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMucG9sbEVuZHBvaW50ID0gdGhpcy5ub3JtYWxpemVFbmRwb2ludChlbmRQb2ludClcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcbiAgICB0aGlzLnBvbGwoKVxuICB9XG5cbiAgbm9ybWFsaXplRW5kcG9pbnQoZW5kUG9pbnQpe1xuICAgIHJldHVybiAoZW5kUG9pbnRcbiAgICAgIC5yZXBsYWNlKFwid3M6Ly9cIiwgXCJodHRwOi8vXCIpXG4gICAgICAucmVwbGFjZShcIndzczovL1wiLCBcImh0dHBzOi8vXCIpXG4gICAgICAucmVwbGFjZShuZXcgUmVnRXhwKFwiKC4qKVxcL1wiICsgVFJBTlNQT1JUUy53ZWJzb2NrZXQpLCBcIiQxL1wiICsgVFJBTlNQT1JUUy5sb25ncG9sbCkpXG4gIH1cblxuICBlbmRwb2ludFVSTCgpe1xuICAgIHJldHVybiBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLnBvbGxFbmRwb2ludCwge3Rva2VuOiB0aGlzLnRva2VufSlcbiAgfVxuXG4gIGNsb3NlQW5kUmV0cnkoY29kZSwgcmVhc29uLCB3YXNDbGVhbil7XG4gICAgdGhpcy5jbG9zZShjb2RlLCByZWFzb24sIHdhc0NsZWFuKVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZ1xuICB9XG5cbiAgb250aW1lb3V0KCl7XG4gICAgdGhpcy5vbmVycm9yKFwidGltZW91dFwiKVxuICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDA1LCBcInRpbWVvdXRcIiwgZmFsc2UpXG4gIH1cblxuICBpc0FjdGl2ZSgpeyByZXR1cm4gdGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLm9wZW4gfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmcgfVxuXG4gIHBvbGwoKXtcbiAgICB0aGlzLmFqYXgoXCJHRVRcIiwgbnVsbCwgKCkgPT4gdGhpcy5vbnRpbWVvdXQoKSwgcmVzcCA9PiB7XG4gICAgICBpZihyZXNwKXtcbiAgICAgICAgdmFyIHtzdGF0dXMsIHRva2VuLCBtZXNzYWdlc30gPSByZXNwXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gMFxuICAgICAgfVxuXG4gICAgICBzd2l0Y2goc3RhdHVzKXtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgLy8gVGFza3MgYXJlIHdoYXQgdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIHNldFRpbWVvdXQgY2FsbGJhY2tzLFxuICAgICAgICAgICAgLy8gcHJvbWlzZSByZXNvbHZlcyBhbmQgbW9yZSBhcmUgcnVuIHdpdGhpbi5cbiAgICAgICAgICAgIC8vIEluIG1vZGVybiBicm93c2VycywgdGhlcmUgYXJlIHR3byBkaWZmZXJlbnQga2luZHMgb2YgdGFza3MsXG4gICAgICAgICAgICAvLyBtaWNyb3Rhc2tzIGFuZCBtYWNyb3Rhc2tzLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhcmUgbWFpbmx5IHVzZWQgZm9yIFByb21pc2VzLCB3aGlsZSBtYWNyb3Rhc2tzIGFyZVxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhbHdheXMgaGF2ZSBwcmlvcml0eSBvdmVyIG1hY3JvdGFza3MuIElmIHRoZSBKUyBlbmdpbmVcbiAgICAgICAgICAgIC8vIGlzIGxvb2tpbmcgZm9yIGEgdGFzayB0byBydW4sIGl0IHdpbGwgYWx3YXlzIHRyeSB0byBlbXB0eSB0aGVcbiAgICAgICAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byBydW4gYW55dGhpbmcgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIG1hY3JvdGFzayBxdWV1ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3IgdGhlIFdlYlNvY2tldCB0cmFuc3BvcnQsIG1lc3NhZ2VzIGFsd2F5cyBhcnJpdmUgaW4gdGhlaXIgb3duXG4gICAgICAgICAgICAvLyBldmVudC4gVGhpcyBtZWFucyB0aGF0IGlmIGFueSBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgZnJvbSB3aXRoaW4sXG4gICAgICAgICAgICAvLyB0aGVpciBjYWxsYmFja3Mgd2lsbCBhbHdheXMgZmluaXNoIGV4ZWN1dGlvbiBieSB0aGUgdGltZSB0aGVcbiAgICAgICAgICAgIC8vIG5leHQgbWVzc2FnZSBldmVudCBoYW5kbGVyIGlzIHJ1bi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBlbXVsYXRlIHRoaXMgYmVoYXZpb3VyLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBlYWNoXG4gICAgICAgICAgICAvLyBvbm1lc3NhZ2UgaGFuZGxlciBpcyBydW4gd2l0aGluIGl0J3Mgb3duIG1hY3JvdGFzay5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5vbm1lc3NhZ2Uoe2RhdGE6IG1zZ30pLCAwKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDEwOlxuICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMub3BlblxuICAgICAgICAgIHRoaXMub25vcGVuKHt9KVxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0MDM6XG4gICAgICAgICAgdGhpcy5vbmVycm9yKDQwMylcbiAgICAgICAgICB0aGlzLmNsb3NlKDEwMDgsIFwiZm9yYmlkZGVuXCIsIGZhbHNlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSA1MDA6XG4gICAgICAgICAgdGhpcy5vbmVycm9yKDUwMClcbiAgICAgICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoMTAxMSwgXCJpbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIiwgNTAwKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHBvbGwgc3RhdHVzICR7c3RhdHVzfWApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNlbmQoYm9keSl7XG4gICAgdGhpcy5hamF4KFwiUE9TVFwiLCBib2R5LCAoKSA9PiB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpLCByZXNwID0+IHtcbiAgICAgIGlmKCFyZXNwIHx8IHJlc3Auc3RhdHVzICE9PSAyMDApe1xuICAgICAgICB0aGlzLm9uZXJyb3IocmVzcCAmJiByZXNwLnN0YXR1cylcbiAgICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMTEsIFwiaW50ZXJuYWwgc2VydmVyIGVycm9yXCIsIGZhbHNlKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjbG9zZShjb2RlLCByZWFzb24sIHdhc0NsZWFuKXtcbiAgICBmb3IobGV0IHJlcSBvZiB0aGlzLnJlcXMpeyByZXEuYWJvcnQoKSB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jbG9zZWRcbiAgICBsZXQgb3B0cyA9IE9iamVjdC5hc3NpZ24oe2NvZGU6IDEwMDAsIHJlYXNvbjogdW5kZWZpbmVkLCB3YXNDbGVhbjogdHJ1ZX0sIHtjb2RlLCByZWFzb24sIHdhc0NsZWFufSlcbiAgICBpZih0eXBlb2YoQ2xvc2VFdmVudCkgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgdGhpcy5vbmNsb3NlKG5ldyBDbG9zZUV2ZW50KFwiY2xvc2VcIiwgb3B0cykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25jbG9zZShvcHRzKVxuICAgIH1cbiAgfVxuXG4gIGFqYXgobWV0aG9kLCBib2R5LCBvbkNhbGxlclRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICBsZXQgcmVxXG4gICAgbGV0IG9udGltZW91dCA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVxcy5kZWxldGUocmVxKVxuICAgICAgb25DYWxsZXJUaW1lb3V0KClcbiAgICB9XG4gICAgcmVxID0gQWpheC5yZXF1ZXN0KG1ldGhvZCwgdGhpcy5lbmRwb2ludFVSTCgpLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgYm9keSwgdGhpcy50aW1lb3V0LCBvbnRpbWVvdXQsIHJlc3AgPT4ge1xuICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyZXEpXG4gICAgICBpZih0aGlzLmlzQWN0aXZlKCkpeyBjYWxsYmFjayhyZXNwKSB9XG4gICAgfSlcbiAgICB0aGlzLnJlcXMuYWRkKHJlcSlcbiAgfVxufVxuIiwgIi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFByZXNlbmNlXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWwgLSBUaGUgQ2hhbm5lbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyxcbiAqICAgICAgICBmb3IgZXhhbXBsZSBge2V2ZW50czoge3N0YXRlOiBcInN0YXRlXCIsIGRpZmY6IFwiZGlmZlwifX1gXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZXNlbmNlIHtcblxuICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzID0ge30pe1xuICAgIGxldCBldmVudHMgPSBvcHRzLmV2ZW50cyB8fCB7c3RhdGU6IFwicHJlc2VuY2Vfc3RhdGVcIiwgZGlmZjogXCJwcmVzZW5jZV9kaWZmXCJ9XG4gICAgdGhpcy5zdGF0ZSA9IHt9XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWxcbiAgICB0aGlzLmpvaW5SZWYgPSBudWxsXG4gICAgdGhpcy5jYWxsZXIgPSB7XG4gICAgICBvbkpvaW46IGZ1bmN0aW9uICgpeyB9LFxuICAgICAgb25MZWF2ZTogZnVuY3Rpb24gKCl7IH0sXG4gICAgICBvblN5bmM6IGZ1bmN0aW9uICgpeyB9XG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5zdGF0ZSwgbmV3U3RhdGUgPT4ge1xuICAgICAgbGV0IHtvbkpvaW4sIG9uTGVhdmUsIG9uU3luY30gPSB0aGlzLmNhbGxlclxuXG4gICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuam9pblJlZigpXG4gICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpXG5cbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goZGlmZiA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpXG4gICAgICB9KVxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgICAgb25TeW5jKClcbiAgICB9KVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5kaWZmLCBkaWZmID0+IHtcbiAgICAgIGxldCB7b25Kb2luLCBvbkxlYXZlLCBvblN5bmN9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgaWYodGhpcy5pblBlbmRpbmdTeW5jU3RhdGUoKSl7XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpXG4gICAgICAgIG9uU3luYygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbihjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uSm9pbiA9IGNhbGxiYWNrIH1cblxuICBvbkxlYXZlKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25MZWF2ZSA9IGNhbGxiYWNrIH1cblxuICBvblN5bmMoY2FsbGJhY2speyB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjayB9XG5cbiAgbGlzdChieSl7IHJldHVybiBQcmVzZW5jZS5saXN0KHRoaXMuc3RhdGUsIGJ5KSB9XG5cbiAgaW5QZW5kaW5nU3luY1N0YXRlKCl7XG4gICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgKHRoaXMuam9pblJlZiAhPT0gdGhpcy5jaGFubmVsLmpvaW5SZWYoKSlcbiAgfVxuXG4gIC8vIGxvd2VyLWxldmVsIHB1YmxpYyBzdGF0aWMgQVBJXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlclxuICAgKiB3aXRoIHRoZSBjbGllbnQncyBzdGF0ZS4gQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW5cbiAgICogYmUgcHJvdmlkZWQgdG8gcmVhY3QgdG8gY2hhbmdlcyBpbiB0aGUgY2xpZW50J3MgbG9jYWwgcHJlc2VuY2VzIGFjcm9zc1xuICAgKiBkaXNjb25uZWN0cyBhbmQgcmVjb25uZWN0cyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBzeW5jU3RhdGUoY3VycmVudFN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKXtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmNsb25lKGN1cnJlbnRTdGF0ZSlcbiAgICBsZXQgam9pbnMgPSB7fVxuICAgIGxldCBsZWF2ZXMgPSB7fVxuXG4gICAgdGhpcy5tYXAoc3RhdGUsIChrZXksIHByZXNlbmNlKSA9PiB7XG4gICAgICBpZighbmV3U3RhdGVba2V5XSl7XG4gICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMubWFwKG5ld1N0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZSl7XG4gICAgICAgIGxldCBuZXdSZWZzID0gbmV3UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgY3VyUmVmcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICAgIGxldCBqb2luZWRNZXRhcyA9IG5ld1ByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IGN1clJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgbGV0IGxlZnRNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBuZXdSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIGlmKGpvaW5lZE1ldGFzLmxlbmd0aCA+IDApe1xuICAgICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZVxuICAgICAgICAgIGpvaW5zW2tleV0ubWV0YXMgPSBqb2luZWRNZXRhc1xuICAgICAgICB9XG4gICAgICAgIGlmKGxlZnRNZXRhcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICBsZWF2ZXNba2V5XSA9IHRoaXMuY2xvbmUoY3VycmVudFByZXNlbmNlKVxuICAgICAgICAgIGxlYXZlc1trZXldLm1ldGFzID0gbGVmdE1ldGFzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHtqb2luczogam9pbnMsIGxlYXZlczogbGVhdmVzfSwgb25Kb2luLCBvbkxlYXZlKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIFVzZWQgdG8gc3luYyBhIGRpZmYgb2YgcHJlc2VuY2Ugam9pbiBhbmQgbGVhdmVcbiAgICogZXZlbnRzIGZyb20gdGhlIHNlcnZlciwgYXMgdGhleSBoYXBwZW4uIExpa2UgYHN5bmNTdGF0ZWAsIGBzeW5jRGlmZmBcbiAgICogYWNjZXB0cyBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrcyB0byByZWFjdCB0byBhIHVzZXJcbiAgICogam9pbmluZyBvciBsZWF2aW5nIGZyb20gYSBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBzeW5jRGlmZihzdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKXtcbiAgICBsZXQge2pvaW5zLCBsZWF2ZXN9ID0gdGhpcy5jbG9uZShkaWZmKVxuICAgIGlmKCFvbkpvaW4peyBvbkpvaW4gPSBmdW5jdGlvbiAoKXsgfSB9XG4gICAgaWYoIW9uTGVhdmUpeyBvbkxlYXZlID0gZnVuY3Rpb24gKCl7IH0gfVxuXG4gICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmUobmV3UHJlc2VuY2UpXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2Upe1xuICAgICAgICBsZXQgam9pbmVkUmVmcyA9IHN0YXRlW2tleV0ubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgY3VyTWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gam9pbmVkUmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBzdGF0ZVtrZXldLm1ldGFzLnVuc2hpZnQoLi4uY3VyTWV0YXMpXG4gICAgICB9XG4gICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2UsIG5ld1ByZXNlbmNlKVxuICAgIH0pXG4gICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBpZighY3VycmVudFByZXNlbmNlKXsgcmV0dXJuIH1cbiAgICAgIGxldCByZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgY3VycmVudFByZXNlbmNlLm1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihwID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZnNUb1JlbW92ZS5pbmRleE9mKHAucGh4X3JlZikgPCAwXG4gICAgICB9KVxuICAgICAgb25MZWF2ZShrZXksIGN1cnJlbnRQcmVzZW5jZSwgbGVmdFByZXNlbmNlKVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlLm1ldGFzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZVtrZXldXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcmVzZW5jZXMsIHdpdGggc2VsZWN0ZWQgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVzZW5jZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hvb3NlclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgbGlzdChwcmVzZW5jZXMsIGNob29zZXIpe1xuICAgIGlmKCFjaG9vc2VyKXsgY2hvb3NlciA9IGZ1bmN0aW9uIChrZXksIHByZXMpeyByZXR1cm4gcHJlcyB9IH1cblxuICAgIHJldHVybiB0aGlzLm1hcChwcmVzZW5jZXMsIChrZXksIHByZXNlbmNlKSA9PiB7XG4gICAgICByZXR1cm4gY2hvb3NlcihrZXksIHByZXNlbmNlKVxuICAgIH0pXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgc3RhdGljIG1hcChvYmosIGZ1bmMpe1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcChrZXkgPT4gZnVuYyhrZXksIG9ialtrZXldKSlcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShvYmopeyByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKSB9XG59XG4iLCAiLyogVGhlIGRlZmF1bHQgc2VyaWFsaXplciBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIG1lc3NhZ2VzICovXG5pbXBvcnQge1xuICBDSEFOTkVMX0VWRU5UU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEhFQURFUl9MRU5HVEg6IDEsXG4gIE1FVEFfTEVOR1RIOiA0LFxuICBLSU5EUzoge3B1c2g6IDAsIHJlcGx5OiAxLCBicm9hZGNhc3Q6IDJ9LFxuXG4gIGVuY29kZShtc2csIGNhbGxiYWNrKXtcbiAgICBpZihtc2cucGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RW5jb2RlKG1zZykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXlsb2FkID0gW21zZy5qb2luX3JlZiwgbXNnLnJlZiwgbXNnLnRvcGljLCBtc2cuZXZlbnQsIG1zZy5wYXlsb2FkXVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgIH1cbiAgfSxcblxuICBkZWNvZGUocmF3UGF5bG9hZCwgY2FsbGJhY2spe1xuICAgIGlmKHJhd1BheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmJpbmFyeURlY29kZShyYXdQYXlsb2FkKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IFtqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWRdID0gSlNPTi5wYXJzZShyYXdQYXlsb2FkKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKHtqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWR9KVxuICAgIH1cbiAgfSxcblxuICAvLyBwcml2YXRlXG5cbiAgYmluYXJ5RW5jb2RlKG1lc3NhZ2Upe1xuICAgIGxldCB7am9pbl9yZWYsIHJlZiwgZXZlbnQsIHRvcGljLCBwYXlsb2FkfSA9IG1lc3NhZ2VcbiAgICBsZXQgbWV0YUxlbmd0aCA9IHRoaXMuTUVUQV9MRU5HVEggKyBqb2luX3JlZi5sZW5ndGggKyByZWYubGVuZ3RoICsgdG9waWMubGVuZ3RoICsgZXZlbnQubGVuZ3RoXG4gICAgbGV0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKVxuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGhlYWRlcilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdGhpcy5LSU5EUy5wdXNoKSAvLyBraW5kXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgam9pbl9yZWYubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHJlZi5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdG9waWMubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGV2ZW50Lmxlbmd0aClcbiAgICBBcnJheS5mcm9tKGpvaW5fcmVmLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbShyZWYsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKHRvcGljLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbShldmVudCwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuXG4gICAgdmFyIGNvbWJpbmVkID0gbmV3IFVpbnQ4QXJyYXkoaGVhZGVyLmJ5dGVMZW5ndGggKyBwYXlsb2FkLmJ5dGVMZW5ndGgpXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGhlYWRlciksIDApXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBoZWFkZXIuYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiBjb21iaW5lZC5idWZmZXJcbiAgfSxcblxuICBiaW5hcnlEZWNvZGUoYnVmZmVyKXtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXG4gICAgbGV0IGtpbmQgPSB2aWV3LmdldFVpbnQ4KDApXG4gICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5wdXNoOiByZXR1cm4gdGhpcy5kZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5yZXBseTogcmV0dXJuIHRoaXMuZGVjb2RlUmVwbHkoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICAgICAgY2FzZSB0aGlzLktJTkRTLmJyb2FkY2FzdDogcmV0dXJuIHRoaXMuZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICB9XG4gIH0sXG5cbiAgZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDMpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEggLSAxIC8vIHB1c2hlcyBoYXZlIG5vIHJlZlxuICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgcmV0dXJuIHtqb2luX3JlZjogam9pblJlZiwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YX1cbiAgfSxcblxuICBkZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgcmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgzKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDQpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEhcbiAgICBsZXQgam9pblJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGpvaW5SZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBqb2luUmVmU2l6ZVxuICAgIGxldCByZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyByZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyByZWZTaXplXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgbGV0IHBheWxvYWQgPSB7c3RhdHVzOiBldmVudCwgcmVzcG9uc2U6IGRhdGF9XG4gICAgcmV0dXJuIHtqb2luX3JlZjogam9pblJlZiwgcmVmOiByZWYsIHRvcGljOiB0b3BpYywgZXZlbnQ6IENIQU5ORUxfRVZFTlRTLnJlcGx5LCBwYXlsb2FkOiBwYXlsb2FkfVxuICB9LFxuXG4gIGRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMlxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuXG4gICAgcmV0dXJuIHtqb2luX3JlZjogbnVsbCwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YX1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIGdsb2JhbCxcbiAgcGh4V2luZG93LFxuICBDSEFOTkVMX0VWRU5UUyxcbiAgREVGQVVMVF9USU1FT1VULFxuICBERUZBVUxUX1ZTTixcbiAgU09DS0VUX1NUQVRFUyxcbiAgVFJBTlNQT1JUUyxcbiAgV1NfQ0xPU0VfTk9STUFMXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNsb3N1cmVcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQWpheCBmcm9tIFwiLi9hamF4XCJcbmltcG9ydCBDaGFubmVsIGZyb20gXCIuL2NoYW5uZWxcIlxuaW1wb3J0IExvbmdQb2xsIGZyb20gXCIuL2xvbmdwb2xsXCJcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gXCIuL3NlcmlhbGl6ZXJcIlxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL3RpbWVyXCJcblxuLyoqIEluaXRpYWxpemVzIHRoZSBTb2NrZXQgKlxuICpcbiAqIEZvciBJRTggc3VwcG9ydCB1c2UgYW4gRVM1LXNoaW0gKGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kUG9pbnQgLSBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIGBcIndzOi8vZXhhbXBsZS5jb20vc29ja2V0XCJgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIndzczovL2V4YW1wbGUuY29tXCJgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFwiL3NvY2tldFwiYCAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy50cmFuc3BvcnRdIC0gVGhlIFdlYnNvY2tldCBUcmFuc3BvcnQsIGZvciBleGFtcGxlIFdlYlNvY2tldCBvciBQaG9lbml4LkxvbmdQb2xsLlxuICpcbiAqIERlZmF1bHRzIHRvIFdlYlNvY2tldCB3aXRoIGF1dG9tYXRpYyBMb25nUG9sbCBmYWxsYmFjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmVuY29kZV0gLSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLlxuICpcbiAqIERlZmF1bHRzIHRvIEpTT04gZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5kZWNvZGVdIC0gVGhlIGZ1bmN0aW9uIHRvIGRlY29kZSBpbmNvbWluZyBtZXNzYWdlcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBKU09OOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIChwYXlsb2FkLCBjYWxsYmFjaykgPT4gY2FsbGJhY2soSlNPTi5wYXJzZShwYXlsb2FkKSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0XSAtIFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAqXG4gKiBEZWZhdWx0cyBgREVGQVVMVF9USU1FT1VUYFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlYXJ0YmVhdEludGVydmFsTXNdIC0gVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJlY29ubmVjdEFmdGVyTXNdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbGlzZWNcbiAqIHNvY2tldCByZWNvbm5lY3QgaW50ZXJ2YWwuXG4gKlxuICogRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMucmVqb2luQWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsaXNlY1xuICogcmVqb2luIGludGVydmFsIGZvciBpbmRpdmlkdWFsIGNoYW5uZWxzLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiB9XG4gKiBgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMubG9nZ2VyXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24oa2luZCwgbXNnLCBkYXRhKSB7XG4gKiAgIGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxvbmdwb2xsZXJUaW1lb3V0XSAtIFRoZSBtYXhpbXVtIHRpbWVvdXQgb2YgYSBsb25nIHBvbGwgQUpBWCByZXF1ZXN0LlxuICpcbiAqIERlZmF1bHRzIHRvIDIwcyAoZG91YmxlIHRoZSBzZXJ2ZXIgbG9uZyBwb2xsIHRpbWVyKS5cbiAqXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBbb3B0cy5wYXJhbXNdIC0gVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJpbmFyeVR5cGVdIC0gVGhlIGJpbmFyeSB0eXBlIHRvIHVzZSBmb3IgYmluYXJ5IFdlYlNvY2tldCBmcmFtZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gXCJhcnJheWJ1ZmZlclwiXG4gKlxuICogQHBhcmFtIHt2c259IFtvcHRzLnZzbl0gLSBUaGUgc2VyaWFsaXplcidzIHByb3RvY29sIHZlcnNpb24gdG8gc2VuZCBvbiBjb25uZWN0LlxuICpcbiAqIERlZmF1bHRzIHRvIERFRkFVTFRfVlNOLlxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRzID0ge30pe1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7b3BlbjogW10sIGNsb3NlOiBbXSwgZXJyb3I6IFtdLCBtZXNzYWdlOiBbXX1cbiAgICB0aGlzLmNoYW5uZWxzID0gW11cbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIHRoaXMucmVmID0gMFxuICAgIHRoaXMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVRcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG9wdHMudHJhbnNwb3J0IHx8IGdsb2JhbC5XZWJTb2NrZXQgfHwgTG9uZ1BvbGxcbiAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnMgPSAwXG4gICAgdGhpcy5kZWZhdWx0RW5jb2RlciA9IFNlcmlhbGl6ZXIuZW5jb2RlLmJpbmQoU2VyaWFsaXplcilcbiAgICB0aGlzLmRlZmF1bHREZWNvZGVyID0gU2VyaWFsaXplci5kZWNvZGUuYmluZChTZXJpYWxpemVyKVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5iaW5hcnlUeXBlID0gb3B0cy5iaW5hcnlUeXBlIHx8IFwiYXJyYXlidWZmZXJcIlxuICAgIHRoaXMuY29ubmVjdENsb2NrID0gMVxuICAgIGlmKHRoaXMudHJhbnNwb3J0ICE9PSBMb25nUG9sbCl7XG4gICAgICB0aGlzLmVuY29kZSA9IG9wdHMuZW5jb2RlIHx8IHRoaXMuZGVmYXVsdEVuY29kZXJcbiAgICAgIHRoaXMuZGVjb2RlID0gb3B0cy5kZWNvZGUgfHwgdGhpcy5kZWZhdWx0RGVjb2RlclxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuY29kZSA9IHRoaXMuZGVmYXVsdEVuY29kZXJcbiAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWZhdWx0RGVjb2RlclxuICAgIH1cbiAgICBsZXQgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGxcbiAgICBpZihwaHhXaW5kb3cgJiYgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIpe1xuICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfZSA9PiB7XG4gICAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gdGhpcy5jb25uZWN0Q2xvY2tcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwgX2UgPT4ge1xuICAgICAgICBpZihhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID09PSB0aGlzLmNvbm5lY3RDbG9jayl7XG4gICAgICAgICAgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGxcbiAgICAgICAgICB0aGlzLmNvbm5lY3QoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBvcHRzLmhlYXJ0YmVhdEludGVydmFsTXMgfHwgMzAwMDBcbiAgICB0aGlzLnJlam9pbkFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgIGlmKG9wdHMucmVqb2luQWZ0ZXJNcyl7XG4gICAgICAgIHJldHVybiBvcHRzLnJlam9pbkFmdGVyTXModHJpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEwMDAsIDIwMDAsIDUwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZWNvbm5lY3RBZnRlck1zID0gKHRyaWVzKSA9PiB7XG4gICAgICBpZihvcHRzLnJlY29ubmVjdEFmdGVyTXMpe1xuICAgICAgICByZXR1cm4gb3B0cy5yZWNvbm5lY3RBZnRlck1zKHRyaWVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBvcHRzLmxvZ2dlciB8fCBudWxsXG4gICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMjAwMDBcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pXG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLnZzbiA9IG9wdHMudnNuIHx8IERFRkFVTFRfVlNOXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lb3V0VGltZXIgPSBudWxsXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKVxuICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBMb25nUG9sbCB0cmFuc3BvcnQgcmVmZXJlbmNlXG4gICAqL1xuICBnZXRMb25nUG9sbFRyYW5zcG9ydCgpeyByZXR1cm4gTG9uZ1BvbGwgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyBhbmQgcmVwbGFjZXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3VHJhbnNwb3J0IC0gVGhlIG5ldyB0cmFuc3BvcnQgY2xhc3MgdG8gaW5zdGFudGlhdGVcbiAgICpcbiAgICovXG4gIHJlcGxhY2VUcmFuc3BvcnQobmV3VHJhbnNwb3J0KXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdXG4gICAgaWYodGhpcy5jb25uKXtcbiAgICAgIHRoaXMuY29ubi5jbG9zZSgpXG4gICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgfVxuICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc29ja2V0IHByb3RvY29sXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBwcm90b2NvbCgpeyByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL15odHRwcy8pID8gXCJ3c3NcIiA6IFwid3NcIiB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxseSBxdWFsaWZpZWQgc29ja2V0IHVybFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZW5kUG9pbnRVUkwoKXtcbiAgICBsZXQgdXJpID0gQWpheC5hcHBlbmRQYXJhbXMoXG4gICAgICBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCB0aGlzLnBhcmFtcygpKSwge3ZzbjogdGhpcy52c259KVxuICAgIGlmKHVyaS5jaGFyQXQoMCkgIT09IFwiL1wiKXsgcmV0dXJuIHVyaSB9XG4gICAgaWYodXJpLmNoYXJBdCgxKSA9PT0gXCIvXCIpeyByZXR1cm4gYCR7dGhpcy5wcm90b2NvbCgpfToke3VyaX1gIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9Oi8vJHtsb2NhdGlvbi5ob3N0fSR7dXJpfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0XG4gICAqXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXMgZm9yIHZhbGlkIHN0YXR1cyBjb2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgc29ja2V0IGlzIGRpc2Nvbm5lY3RlZC5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBjb2RlIC0gQSBzdGF0dXMgY29kZSBmb3IgZGlzY29ubmVjdGlvbiAoT3B0aW9uYWwpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gQSB0ZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSByZWFzb24gdG8gZGlzY29ubmVjdC4gKE9wdGlvbmFsKVxuICAgKi9cbiAgZGlzY29ubmVjdChjYWxsYmFjaywgY29kZSwgcmVhc29uKXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMudGVhcmRvd24oY2FsbGJhY2ssIGNvZGUsIHJlYXNvbilcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtcyB0byBzZW5kIHdoZW4gY29ubmVjdGluZywgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiB1c2VyVG9rZW59YFxuICAgKlxuICAgKiBQYXNzaW5nIHBhcmFtcyB0byBjb25uZWN0IGlzIGRlcHJlY2F0ZWQ7IHBhc3MgdGhlbSBpbiB0aGUgU29ja2V0IGNvbnN0cnVjdG9yIGluc3RlYWQ6XG4gICAqIGBuZXcgU29ja2V0KFwiL3NvY2tldFwiLCB7cGFyYW1zOiB7dXNlcl9pZDogdXNlclRva2VufX0pYC5cbiAgICovXG4gIGNvbm5lY3QocGFyYW1zKXtcbiAgICBpZihwYXJhbXMpe1xuICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcInBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBwYXNzIDpwYXJhbXMgdG8gdGhlIFNvY2tldCBjb25zdHJ1Y3RvclwiKVxuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcylcbiAgICB9XG4gICAgaWYodGhpcy5jb25uKXsgcmV0dXJuIH1cblxuICAgIHRoaXMuY29ubmVjdENsb2NrKytcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZFBvaW50VVJMKCkpXG4gICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSB0aGlzLmJpbmFyeVR5cGVcbiAgICB0aGlzLmNvbm4udGltZW91dCA9IHRoaXMubG9uZ3BvbGxlclRpbWVvdXRcbiAgICB0aGlzLmNvbm4ub25vcGVuID0gKCkgPT4gdGhpcy5vbkNvbm5PcGVuKClcbiAgICB0aGlzLmNvbm4ub25lcnJvciA9IGVycm9yID0+IHRoaXMub25Db25uRXJyb3IoZXJyb3IpXG4gICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IGV2ZW50ID0+IHRoaXMub25Db25uTWVzc2FnZShldmVudClcbiAgICB0aGlzLmNvbm4ub25jbG9zZSA9IGV2ZW50ID0+IHRoaXMub25Db25uQ2xvc2UoZXZlbnQpXG4gIH1cblxuICAvKipcbiAgICogTG9ncyB0aGUgbWVzc2FnZS4gT3ZlcnJpZGUgYHRoaXMubG9nZ2VyYCBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZy4gbm9vcHMgYnkgZGVmYXVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXNnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBsb2coa2luZCwgbXNnLCBkYXRhKXsgdGhpcy5sb2dnZXIoa2luZCwgbXNnLCBkYXRhKSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGxvZ2dlciBoYXMgYmVlbiBzZXQgb24gdGhpcyBzb2NrZXQuXG4gICAqL1xuICBoYXNMb2dnZXIoKXsgcmV0dXJuIHRoaXMubG9nZ2VyICE9PSBudWxsIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBvcGVuIGV2ZW50c1xuICAgKlxuICAgKiBAZXhhbXBsZSBzb2NrZXQub25PcGVuKGZ1bmN0aW9uKCl7IGNvbnNvbGUuaW5mbyhcInRoZSBzb2NrZXQgd2FzIG9wZW5lZFwiKSB9KVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25PcGVuKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4ucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gY2xvc2UgZXZlbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkNsb3NlKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLnB1c2goW3JlZiwgY2FsbGJhY2tdKVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIGVycm9yIGV2ZW50c1xuICAgKlxuICAgKiBAZXhhbXBsZSBzb2NrZXQub25FcnJvcihmdW5jdGlvbihlcnJvcil7IGFsZXJ0KFwiQW4gZXJyb3Igb2NjdXJyZWRcIikgfSlcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uRXJyb3IoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gbWVzc2FnZSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uTWVzc2FnZShjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLnB1c2goW3JlZiwgY2FsbGJhY2tdKVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBQaW5ncyB0aGUgc2VydmVyIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBSVFQgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGluZyB3YXMgcHVzaGVkIG9yIGZhbHNlIGlmIHVuYWJsZSB0byBiZSBwdXNoZWQuXG4gICAqL1xuICBwaW5nKGNhbGxiYWNrKXtcbiAgICBpZighdGhpcy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIHRoaXMucHVzaCh7dG9waWM6IFwicGhvZW5peFwiLCBldmVudDogXCJoZWFydGJlYXRcIiwgcGF5bG9hZDoge30sIHJlZjogcmVmfSlcbiAgICBsZXQgb25Nc2dSZWYgPSB0aGlzLm9uTWVzc2FnZShtc2cgPT4ge1xuICAgICAgaWYobXNnLnJlZiA9PT0gcmVmKXtcbiAgICAgICAgdGhpcy5vZmYoW29uTXNnUmVmXSlcbiAgICAgICAgY2FsbGJhY2soRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgY2xlYXJIZWFydGJlYXRzKCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZW91dFRpbWVyKVxuICB9XG5cbiAgb25Db25uT3Blbigpe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBjb25uZWN0ZWQgdG8gJHt0aGlzLmVuZFBvaW50VVJMKCl9YClcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucysrXG4gICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMucmVzZXRIZWFydGJlYXQoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IGNhbGxiYWNrKCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgaGVhcnRiZWF0VGltZW91dCgpe1xuICAgIGlmKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZil7XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKXsgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblwiKSB9XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICAgIHRoaXMudGVhcmRvd24oKCkgPT4gdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSwgV1NfQ0xPU0VfTk9STUFMLCBcImhlYXJ0YmVhdCB0aW1lb3V0XCIpXG4gICAgfVxuICB9XG5cbiAgcmVzZXRIZWFydGJlYXQoKXtcbiAgICBpZih0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnNraXBIZWFydGJlYXQpeyByZXR1cm4gfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICB0aGlzLmNsZWFySGVhcnRiZWF0cygpXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgfVxuXG4gIHRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pe1xuICAgIGlmKCF0aGlzLmNvbm4pe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB0aGlzLndhaXRGb3JCdWZmZXJEb25lKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgIGlmKGNvZGUpeyB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uIHx8IFwiXCIpIH0gZWxzZSB7IHRoaXMuY29ubi5jbG9zZSgpIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKCgpID0+IHtcbiAgICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgICB0aGlzLmNvbm4ub25vcGVuID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgd2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzID0gMSl7XG4gICAgaWYodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCAhdGhpcy5jb25uLmJ1ZmZlcmVkQW1vdW50KXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgd2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgPSAxKXtcbiAgICBpZih0cmllcyA9PT0gNSB8fCAhdGhpcy5jb25uIHx8IHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNsb3NlZCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgb25Db25uQ2xvc2UoZXZlbnQpe1xuICAgIGxldCBjbG9zZUNvZGUgPSBldmVudCAmJiBldmVudC5jb2RlXG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJjbG9zZVwiLCBldmVudClcbiAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIHRoaXMuY2xlYXJIZWFydGJlYXRzKClcbiAgICBpZighdGhpcy5jbG9zZVdhc0NsZWFuICYmIGNsb3NlQ29kZSAhPT0gMTAwMCl7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjayhldmVudCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uQ29ubkVycm9yKGVycm9yKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBlcnJvcilcbiAgICBsZXQgdHJhbnNwb3J0QmVmb3JlID0gdGhpcy50cmFuc3BvcnRcbiAgICBsZXQgZXN0YWJsaXNoZWRCZWZvcmUgPSB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnNcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIHRyYW5zcG9ydEJlZm9yZSwgZXN0YWJsaXNoZWRCZWZvcmUpXG4gICAgfSlcbiAgICBpZih0cmFuc3BvcnRCZWZvcmUgPT09IHRoaXMudHJhbnNwb3J0IHx8IGVzdGFibGlzaGVkQmVmb3JlID4gMCl7XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlckNoYW5FcnJvcigpe1xuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgIGlmKCEoY2hhbm5lbC5pc0Vycm9yZWQoKSB8fCBjaGFubmVsLmlzTGVhdmluZygpIHx8IGNoYW5uZWwuaXNDbG9zZWQoKSkpe1xuICAgICAgICBjaGFubmVsLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCl7XG4gICAgc3dpdGNoKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSl7XG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzogcmV0dXJuIFwiY29ubmVjdGluZ1wiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMub3BlbjogcmV0dXJuIFwib3BlblwiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzogcmV0dXJuIFwiY2xvc2luZ1wiXG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJjbG9zZWRcIlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBcIm9wZW5cIiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q2hhbm5lbH1cbiAgICovXG4gIHJlbW92ZShjaGFubmVsKXtcbiAgICB0aGlzLm9mZihjaGFubmVsLnN0YXRlQ2hhbmdlUmVmcylcbiAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5maWx0ZXIoYyA9PiBjLmpvaW5SZWYoKSAhPT0gY2hhbm5lbC5qb2luUmVmKCkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBgb25PcGVuYCwgYG9uQ2xvc2VgLCBgb25FcnJvcixgIGFuZCBgb25NZXNzYWdlYCByZWdpc3RyYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge3JlZnN9IC0gbGlzdCBvZiByZWZzIHJldHVybmVkIGJ5IGNhbGxzIHRvXG4gICAqICAgICAgICAgICAgICAgICBgb25PcGVuYCwgYG9uQ2xvc2VgLCBgb25FcnJvcixgIGFuZCBgb25NZXNzYWdlYFxuICAgKi9cbiAgb2ZmKHJlZnMpe1xuICAgIGZvcihsZXQga2V5IGluIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mpe1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldLmZpbHRlcigoW3JlZl0pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZnMuaW5kZXhPZihyZWYpID09PSAtMVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgbmV3IGNoYW5uZWwgZm9yIHRoZSBnaXZlbiB0b3BpY1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5QYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgY2hhbm5lbFxuICAgKiBAcmV0dXJucyB7Q2hhbm5lbH1cbiAgICovXG4gIGNoYW5uZWwodG9waWMsIGNoYW5QYXJhbXMgPSB7fSl7XG4gICAgbGV0IGNoYW4gPSBuZXcgQ2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcywgdGhpcylcbiAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbilcbiAgICByZXR1cm4gY2hhblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBwdXNoKGRhdGEpe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpe1xuICAgICAgbGV0IHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWZ9ID0gZGF0YVxuICAgICAgdGhpcy5sb2coXCJwdXNoXCIsIGAke3RvcGljfSAke2V2ZW50fSAoJHtqb2luX3JlZn0sICR7cmVmfSlgLCBwYXlsb2FkKVxuICAgIH1cblxuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSl7XG4gICAgICB0aGlzLmVuY29kZShkYXRhLCByZXN1bHQgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goKCkgPT4gdGhpcy5lbmNvZGUoZGF0YSwgcmVzdWx0ID0+IHRoaXMuY29ubi5zZW5kKHJlc3VsdCkpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5leHQgbWVzc2FnZSByZWYsIGFjY291bnRpbmcgZm9yIG92ZXJmbG93c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgbWFrZVJlZigpe1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDFcbiAgICBpZihuZXdSZWYgPT09IHRoaXMucmVmKXsgdGhpcy5yZWYgPSAwIH0gZWxzZSB7IHRoaXMucmVmID0gbmV3UmVmIH1cblxuICAgIHJldHVybiB0aGlzLnJlZi50b1N0cmluZygpXG4gIH1cblxuICBzZW5kSGVhcnRiZWF0KCl7XG4gICAgaWYodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmICYmICF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5wdXNoKHt0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWZ9KVxuICAgIHRoaXMuaGVhcnRiZWF0VGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhlYXJ0YmVhdFRpbWVvdXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICB9XG5cbiAgZmx1c2hTZW5kQnVmZmVyKCl7XG4gICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKXtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpXG4gICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSl7XG4gICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCBtc2cgPT4ge1xuICAgICAgbGV0IHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWZ9ID0gbXNnXG4gICAgICBpZihyZWYgJiYgcmVmID09PSB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpe1xuICAgICAgICB0aGlzLmNsZWFySGVhcnRiZWF0cygpXG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJyZWNlaXZlXCIsIGAke3BheWxvYWQuc3RhdHVzIHx8IFwiXCJ9ICR7dG9waWN9ICR7ZXZlbnR9ICR7cmVmICYmIFwiKFwiICsgcmVmICsgXCIpXCIgfHwgXCJcIn1gLCBwYXlsb2FkKVxuXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldXG4gICAgICAgIGlmKCFjaGFubmVsLmlzTWVtYmVyKHRvcGljLCBldmVudCwgcGF5bG9hZCwgam9pbl9yZWYpKXsgY29udGludWUgfVxuICAgICAgICBjaGFubmVsLnRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWYpXG4gICAgICB9XG5cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UubGVuZ3RoOyBpKyspe1xuICAgICAgICBsZXQgWywgY2FsbGJhY2tdID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlW2ldXG4gICAgICAgIGNhbGxiYWNrKG1zZylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgbGVhdmVPcGVuVG9waWModG9waWMpe1xuICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKGMgPT4gYy50b3BpYyA9PT0gdG9waWMgJiYgKGMuaXNKb2luZWQoKSB8fCBjLmlzSm9pbmluZygpKSlcbiAgICBpZihkdXBDaGFubmVsKXtcbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKVxuICAgICAgZHVwQ2hhbm5lbC5sZWF2ZSgpXG4gICAgfVxuICB9XG59IiwgIlxuZXhwb3J0IGNvbnN0IENPTlNFQ1VUSVZFX1JFTE9BRFMgPSBcImNvbnNlY3V0aXZlLXJlbG9hZHNcIlxuZXhwb3J0IGNvbnN0IE1BWF9SRUxPQURTID0gMTBcbmV4cG9ydCBjb25zdCBSRUxPQURfSklUVEVSX01JTiA9IDUwMDBcbmV4cG9ydCBjb25zdCBSRUxPQURfSklUVEVSX01BWCA9IDEwMDAwXG5leHBvcnQgY29uc3QgRkFJTFNBRkVfSklUVEVSID0gMzAwMDBcbmV4cG9ydCBjb25zdCBQSFhfRVZFTlRfQ0xBU1NFUyA9IFtcbiAgXCJwaHgtY2xpY2stbG9hZGluZ1wiLCBcInBoeC1jaGFuZ2UtbG9hZGluZ1wiLCBcInBoeC1zdWJtaXQtbG9hZGluZ1wiLFxuICBcInBoeC1rZXlkb3duLWxvYWRpbmdcIiwgXCJwaHgta2V5dXAtbG9hZGluZ1wiLCBcInBoeC1ibHVyLWxvYWRpbmdcIiwgXCJwaHgtZm9jdXMtbG9hZGluZ1wiXG5dXG5leHBvcnQgY29uc3QgUEhYX0NPTVBPTkVOVCA9IFwiZGF0YS1waHgtY29tcG9uZW50XCJcbmV4cG9ydCBjb25zdCBQSFhfTElWRV9MSU5LID0gXCJkYXRhLXBoeC1saW5rXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJBQ0tfU1RBVElDID0gXCJ0cmFjay1zdGF0aWNcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSU5LX1NUQVRFID0gXCJkYXRhLXBoeC1saW5rLXN0YXRlXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVGID0gXCJkYXRhLXBoeC1yZWZcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUZfU1JDID0gXCJkYXRhLXBoeC1yZWYtc3JjXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJBQ0tfVVBMT0FEUyA9IFwidHJhY2stdXBsb2Fkc1wiXG5leHBvcnQgY29uc3QgUEhYX1VQTE9BRF9SRUYgPSBcImRhdGEtcGh4LXVwbG9hZC1yZWZcIlxuZXhwb3J0IGNvbnN0IFBIWF9QUkVGTElHSFRFRF9SRUZTID0gXCJkYXRhLXBoeC1wcmVmbGlnaHRlZC1yZWZzXCJcbmV4cG9ydCBjb25zdCBQSFhfRE9ORV9SRUZTID0gXCJkYXRhLXBoeC1kb25lLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9EUk9QX1RBUkdFVCA9IFwiZHJvcC10YXJnZXRcIlxuZXhwb3J0IGNvbnN0IFBIWF9BQ1RJVkVfRU5UUllfUkVGUyA9IFwiZGF0YS1waHgtYWN0aXZlLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCA9IFwicGh4OmxpdmUtZmlsZTp1cGRhdGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfU0tJUCA9IFwiZGF0YS1waHgtc2tpcFwiXG5leHBvcnQgY29uc3QgUEhYX1BSVU5FID0gXCJkYXRhLXBoeC1wcnVuZVwiXG5leHBvcnQgY29uc3QgUEhYX1BBR0VfTE9BRElORyA9IFwicGFnZS1sb2FkaW5nXCJcbmV4cG9ydCBjb25zdCBQSFhfQ09OTkVDVEVEX0NMQVNTID0gXCJwaHgtY29ubmVjdGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQ09OTkVDVEVEX0NMQVNTID0gXCJwaHgtbG9hZGluZ1wiXG5leHBvcnQgY29uc3QgUEhYX05PX0ZFRURCQUNLX0NMQVNTID0gXCJwaHgtbm8tZmVlZGJhY2tcIlxuZXhwb3J0IGNvbnN0IFBIWF9FUlJPUl9DTEFTUyA9IFwicGh4LWVycm9yXCJcbmV4cG9ydCBjb25zdCBQSFhfUEFSRU5UX0lEID0gXCJkYXRhLXBoeC1wYXJlbnQtaWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9NQUlOID0gXCJkYXRhLXBoeC1tYWluXCJcbmV4cG9ydCBjb25zdCBQSFhfUk9PVF9JRCA9IFwiZGF0YS1waHgtcm9vdC1pZFwiXG5leHBvcnQgY29uc3QgUEhYX1RSSUdHRVJfQUNUSU9OID0gXCJ0cmlnZ2VyLWFjdGlvblwiXG5leHBvcnQgY29uc3QgUEhYX0ZFRURCQUNLX0ZPUiA9IFwiZmVlZGJhY2stZm9yXCJcbmV4cG9ydCBjb25zdCBQSFhfSEFTX0ZPQ1VTRUQgPSBcInBoeC1oYXMtZm9jdXNlZFwiXG5leHBvcnQgY29uc3QgRk9DVVNBQkxFX0lOUFVUUyA9IFtcInRleHRcIiwgXCJ0ZXh0YXJlYVwiLCBcIm51bWJlclwiLCBcImVtYWlsXCIsIFwicGFzc3dvcmRcIiwgXCJzZWFyY2hcIiwgXCJ0ZWxcIiwgXCJ1cmxcIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsIFwiY29sb3JcIiwgXCJyYW5nZVwiXVxuZXhwb3J0IGNvbnN0IENIRUNLQUJMRV9JTlBVVFMgPSBbXCJjaGVja2JveFwiLCBcInJhZGlvXCJdXG5leHBvcnQgY29uc3QgUEhYX0hBU19TVUJNSVRURUQgPSBcInBoeC1oYXMtc3VibWl0dGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfU0VTU0lPTiA9IFwiZGF0YS1waHgtc2Vzc2lvblwiXG5leHBvcnQgY29uc3QgUEhYX1ZJRVdfU0VMRUNUT1IgPSBgWyR7UEhYX1NFU1NJT059XWBcbmV4cG9ydCBjb25zdCBQSFhfU1RJQ0tZID0gXCJkYXRhLXBoeC1zdGlja3lcIlxuZXhwb3J0IGNvbnN0IFBIWF9TVEFUSUMgPSBcImRhdGEtcGh4LXN0YXRpY1wiXG5leHBvcnQgY29uc3QgUEhYX1JFQURPTkxZID0gXCJkYXRhLXBoeC1yZWFkb25seVwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVEID0gXCJkYXRhLXBoeC1kaXNhYmxlZFwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVfV0lUSCA9IFwiZGlzYWJsZS13aXRoXCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUgPSBcImRhdGEtcGh4LWRpc2FibGUtd2l0aC1yZXN0b3JlXCJcbmV4cG9ydCBjb25zdCBQSFhfSE9PSyA9IFwiaG9va1wiXG5leHBvcnQgY29uc3QgUEhYX0RFQk9VTkNFID0gXCJkZWJvdW5jZVwiXG5leHBvcnQgY29uc3QgUEhYX1RIUk9UVExFID0gXCJ0aHJvdHRsZVwiXG5leHBvcnQgY29uc3QgUEhYX1VQREFURSA9IFwidXBkYXRlXCJcbmV4cG9ydCBjb25zdCBQSFhfS0VZID0gXCJrZXlcIlxuZXhwb3J0IGNvbnN0IFBIWF9QUklWQVRFID0gXCJwaHhQcml2YXRlXCJcbmV4cG9ydCBjb25zdCBQSFhfQVVUT19SRUNPVkVSID0gXCJhdXRvLXJlY292ZXJcIlxuZXhwb3J0IGNvbnN0IFBIWF9MVl9ERUJVRyA9IFwicGh4OmxpdmUtc29ja2V0OmRlYnVnXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfUFJPRklMRSA9IFwicGh4OmxpdmUtc29ja2V0OnByb2ZpbGluZ1wiXG5leHBvcnQgY29uc3QgUEhYX0xWX0xBVEVOQ1lfU0lNID0gXCJwaHg6bGl2ZS1zb2NrZXQ6bGF0ZW5jeS1zaW1cIlxuZXhwb3J0IGNvbnN0IFBIWF9QUk9HUkVTUyA9IFwicHJvZ3Jlc3NcIlxuZXhwb3J0IGNvbnN0IExPQURFUl9USU1FT1VUID0gMVxuZXhwb3J0IGNvbnN0IEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQgPSAyMDBcbmV4cG9ydCBjb25zdCBCSU5ESU5HX1BSRUZJWCA9IFwicGh4LVwiXG5leHBvcnQgY29uc3QgUFVTSF9USU1FT1VUID0gMzAwMDBcbmV4cG9ydCBjb25zdCBMSU5LX0hFQURFUiA9IFwieC1yZXF1ZXN0ZWQtd2l0aFwiXG5leHBvcnQgY29uc3QgUkVTUE9OU0VfVVJMX0hFQURFUiA9IFwieC1yZXNwb25zZS11cmxcIlxuZXhwb3J0IGNvbnN0IERFQk9VTkNFX1RSSUdHRVIgPSBcImRlYm91bmNlLXRyaWdnZXJcIlxuZXhwb3J0IGNvbnN0IFRIUk9UVExFRCA9IFwidGhyb3R0bGVkXCJcbmV4cG9ydCBjb25zdCBERUJPVU5DRV9QUkVWX0tFWSA9IFwiZGVib3VuY2UtcHJldi1rZXlcIlxuZXhwb3J0IGNvbnN0IERFRkFVTFRTID0ge1xuICBkZWJvdW5jZTogMzAwLFxuICB0aHJvdHRsZTogMzAwXG59XG5cbi8vIFJlbmRlcmVkXG5leHBvcnQgY29uc3QgRFlOQU1JQ1MgPSBcImRcIlxuZXhwb3J0IGNvbnN0IFNUQVRJQyA9IFwic1wiXG5leHBvcnQgY29uc3QgQ09NUE9ORU5UUyA9IFwiY1wiXG5leHBvcnQgY29uc3QgRVZFTlRTID0gXCJlXCJcbmV4cG9ydCBjb25zdCBSRVBMWSA9IFwiclwiXG5leHBvcnQgY29uc3QgVElUTEUgPSBcInRcIlxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFUyA9IFwicFwiXG4iLCAiaW1wb3J0IHtcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRyeVVwbG9hZGVyIHtcbiAgY29uc3RydWN0b3IoZW50cnksIGNodW5rU2l6ZSwgbGl2ZVNvY2tldCl7XG4gICAgdGhpcy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuICAgIHRoaXMuZW50cnkgPSBlbnRyeVxuICAgIHRoaXMub2Zmc2V0ID0gMFxuICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplXG4gICAgdGhpcy5jaHVua1RpbWVyID0gbnVsbFxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbCA9IGxpdmVTb2NrZXQuY2hhbm5lbChgbHZ1OiR7ZW50cnkucmVmfWAsIHt0b2tlbjogZW50cnkubWV0YWRhdGEoKX0pXG4gIH1cblxuICBlcnJvcihyZWFzb24pe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmNodW5rVGltZXIpXG4gICAgdGhpcy51cGxvYWRDaGFubmVsLmxlYXZlKClcbiAgICB0aGlzLmVudHJ5LmVycm9yKHJlYXNvbilcbiAgfVxuXG4gIHVwbG9hZCgpe1xuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5vbkVycm9yKHJlYXNvbiA9PiB0aGlzLmVycm9yKHJlYXNvbikpXG4gICAgdGhpcy51cGxvYWRDaGFubmVsLmpvaW4oKVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCBfZGF0YSA9PiB0aGlzLnJlYWROZXh0Q2h1bmsoKSlcbiAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgcmVhc29uID0+IHRoaXMuZXJyb3IocmVhc29uKSlcbiAgfVxuXG4gIGlzRG9uZSgpeyByZXR1cm4gdGhpcy5vZmZzZXQgPj0gdGhpcy5lbnRyeS5maWxlLnNpemUgfVxuXG4gIHJlYWROZXh0Q2h1bmsoKXtcbiAgICBsZXQgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKClcbiAgICBsZXQgYmxvYiA9IHRoaXMuZW50cnkuZmlsZS5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5jaHVua1NpemUgKyB0aGlzLm9mZnNldClcbiAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgIGlmKGUudGFyZ2V0LmVycm9yID09PSBudWxsKXtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gZS50YXJnZXQucmVzdWx0LmJ5dGVMZW5ndGhcbiAgICAgICAgdGhpcy5wdXNoQ2h1bmsoZS50YXJnZXQucmVzdWx0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvZ0Vycm9yKFwiUmVhZCBlcnJvcjogXCIgKyBlLnRhcmdldC5lcnJvcilcbiAgICAgIH1cbiAgICB9XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gIH1cblxuICBwdXNoQ2h1bmsoY2h1bmspe1xuICAgIGlmKCF0aGlzLnVwbG9hZENoYW5uZWwuaXNKb2luZWQoKSl7IHJldHVybiB9XG4gICAgdGhpcy51cGxvYWRDaGFubmVsLnB1c2goXCJjaHVua1wiLCBjaHVuaylcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmVudHJ5LnByb2dyZXNzKCh0aGlzLm9mZnNldCAvIHRoaXMuZW50cnkuZmlsZS5zaXplKSAqIDEwMClcbiAgICAgICAgaWYoIXRoaXMuaXNEb25lKCkpe1xuICAgICAgICAgIHRoaXMuY2h1bmtUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWFkTmV4dENodW5rKCksIHRoaXMubGl2ZVNvY2tldC5nZXRMYXRlbmN5U2ltKCkgfHwgMClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFBIWF9WSUVXX1NFTEVDVE9SXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBFbnRyeVVwbG9hZGVyIGZyb20gXCIuL2VudHJ5X3VwbG9hZGVyXCJcblxuZXhwb3J0IGxldCBsb2dFcnJvciA9IChtc2csIG9iaikgPT4gY29uc29sZS5lcnJvciAmJiBjb25zb2xlLmVycm9yKG1zZywgb2JqKVxuXG5leHBvcnQgbGV0IGlzQ2lkID0gKGNpZCkgPT4ge1xuICBsZXQgdHlwZSA9IHR5cGVvZihjaWQpXG4gIHJldHVybiB0eXBlID09PSBcIm51bWJlclwiIHx8ICh0eXBlID09PSBcInN0cmluZ1wiICYmIC9eKDB8WzEtOV1cXGQqKSQvLnRlc3QoY2lkKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdER1cGxpY2F0ZUlkcygpe1xuICBsZXQgaWRzID0gbmV3IFNldCgpXG4gIGxldCBlbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkXVwiKVxuICBmb3IobGV0IGkgPSAwLCBsZW4gPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgaWYoaWRzLmhhcyhlbGVtc1tpXS5pZCkpe1xuICAgICAgY29uc29sZS5lcnJvcihgTXVsdGlwbGUgSURzIGRldGVjdGVkOiAke2VsZW1zW2ldLmlkfS4gRW5zdXJlIHVuaXF1ZSBlbGVtZW50IGlkcy5gKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZHMuYWRkKGVsZW1zW2ldLmlkKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgbGV0IGRlYnVnID0gKHZpZXcsIGtpbmQsIG1zZywgb2JqKSA9PiB7XG4gIGlmKHZpZXcubGl2ZVNvY2tldC5pc0RlYnVnRW5hYmxlZCgpKXtcbiAgICBjb25zb2xlLmxvZyhgJHt2aWV3LmlkfSAke2tpbmR9OiAke21zZ30gLSBgLCBvYmopXG4gIH1cbn1cblxuLy8gd3JhcHMgdmFsdWUgaW4gY2xvc3VyZSBvciByZXR1cm5zIGNsb3N1cmVcbmV4cG9ydCBsZXQgY2xvc3VyZSA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiA/IHZhbCA6IGZ1bmN0aW9uICgpeyByZXR1cm4gdmFsIH1cblxuZXhwb3J0IGxldCBjbG9uZSA9IChvYmopID0+IHsgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkgfVxuXG5leHBvcnQgbGV0IGNsb3Nlc3RQaHhCaW5kaW5nID0gKGVsLCBiaW5kaW5nLCBib3JkZXJFbCkgPT4ge1xuICBkbyB7XG4gICAgaWYoZWwubWF0Y2hlcyhgWyR7YmluZGluZ31dYCkpeyByZXR1cm4gZWwgfVxuICAgIGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlXG4gIH0gd2hpbGUoZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEgJiYgISgoYm9yZGVyRWwgJiYgYm9yZGVyRWwuaXNTYW1lTm9kZShlbCkpIHx8IGVsLm1hdGNoZXMoUEhYX1ZJRVdfU0VMRUNUT1IpKSlcbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGxldCBpc09iamVjdCA9IChvYmopID0+IHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmICEob2JqIGluc3RhbmNlb2YgQXJyYXkpXG59XG5cbmV4cG9ydCBsZXQgaXNFcXVhbE9iaiA9IChvYmoxLCBvYmoyKSA9PiBKU09OLnN0cmluZ2lmeShvYmoxKSA9PT0gSlNPTi5zdHJpbmdpZnkob2JqMilcblxuZXhwb3J0IGxldCBpc0VtcHR5ID0gKG9iaikgPT4ge1xuICBmb3IobGV0IHggaW4gb2JqKXsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0IGxldCBtYXliZSA9IChlbCwgY2FsbGJhY2spID0+IGVsICYmIGNhbGxiYWNrKGVsKVxuXG5leHBvcnQgbGV0IGNoYW5uZWxVcGxvYWRlciA9IGZ1bmN0aW9uIChlbnRyaWVzLCBvbkVycm9yLCByZXNwLCBsaXZlU29ja2V0KXtcbiAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICBsZXQgZW50cnlVcGxvYWRlciA9IG5ldyBFbnRyeVVwbG9hZGVyKGVudHJ5LCByZXNwLmNvbmZpZy5jaHVua19zaXplLCBsaXZlU29ja2V0KVxuICAgIGVudHJ5VXBsb2FkZXIudXBsb2FkKClcbiAgfSlcbn1cbiIsICJsZXQgQnJvd3NlciA9IHtcbiAgY2FuUHVzaFN0YXRlKCl7IHJldHVybiAodHlwZW9mIChoaXN0b3J5LnB1c2hTdGF0ZSkgIT09IFwidW5kZWZpbmVkXCIpIH0sXG5cbiAgZHJvcExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpe1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KSlcbiAgfSxcblxuICB1cGRhdGVMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5LCBpbml0aWFsLCBmdW5jKXtcbiAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0TG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSlcbiAgICBsZXQga2V5ID0gdGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSlcbiAgICBsZXQgbmV3VmFsID0gY3VycmVudCA9PT0gbnVsbCA/IGluaXRpYWwgOiBmdW5jKGN1cnJlbnQpXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShuZXdWYWwpKVxuICAgIHJldHVybiBuZXdWYWxcbiAgfSxcblxuICBnZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KXtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KSkpXG4gIH0sXG5cbiAgdXBkYXRlQ3VycmVudFN0YXRlKGNhbGxiYWNrKXtcbiAgICBpZighdGhpcy5jYW5QdXNoU3RhdGUoKSl7IHJldHVybiB9XG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY2FsbGJhY2soaGlzdG9yeS5zdGF0ZSB8fCB7fSksIFwiXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICB9LFxuXG4gIHB1c2hTdGF0ZShraW5kLCBtZXRhLCB0byl7XG4gICAgaWYodGhpcy5jYW5QdXNoU3RhdGUoKSl7XG4gICAgICBpZih0byAhPT0gd2luZG93LmxvY2F0aW9uLmhyZWYpe1xuICAgICAgICBpZihtZXRhLnR5cGUgPT0gXCJyZWRpcmVjdFwiICYmIG1ldGEuc2Nyb2xsKXtcbiAgICAgICAgICAvLyBJZiB3ZSdyZSByZWRpcmVjdGluZyBzdG9yZSB0aGUgY3VycmVudCBzY3JvbGxZIGZvciB0aGUgY3VycmVudCBoaXN0b3J5IHN0YXRlLlxuICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSBoaXN0b3J5LnN0YXRlIHx8IHt9XG4gICAgICAgICAgY3VycmVudFN0YXRlLnNjcm9sbCA9IG1ldGEuc2Nyb2xsXG4gICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY3VycmVudFN0YXRlLCBcIlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBtZXRhLnNjcm9sbCAvLyBPbmx5IHN0b3JlIHRoZSBzY3JvbGwgaW4gdGhlIHJlZGlyZWN0IGNhc2UuXG4gICAgICAgIGhpc3Rvcnlba2luZCArIFwiU3RhdGVcIl0obWV0YSwgXCJcIiwgdG8gfHwgbnVsbCkgLy8gSUUgd2lsbCBjb2VyY2UgdW5kZWZpbmVkIHRvIHN0cmluZ1xuICAgICAgICBsZXQgaGFzaEVsID0gdGhpcy5nZXRIYXNoVGFyZ2V0RWwod2luZG93LmxvY2F0aW9uLmhhc2gpXG5cbiAgICAgICAgaWYoaGFzaEVsKXtcbiAgICAgICAgICBoYXNoRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICB9IGVsc2UgaWYobWV0YS50eXBlID09PSBcInJlZGlyZWN0XCIpe1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgMClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZGlyZWN0KHRvKVxuICAgIH1cbiAgfSxcblxuICBzZXRDb29raWUobmFtZSwgdmFsdWUpe1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke25hbWV9PSR7dmFsdWV9YFxuICB9LFxuXG4gIGdldENvb2tpZShuYW1lKXtcbiAgICByZXR1cm4gZG9jdW1lbnQuY29va2llLnJlcGxhY2UobmV3IFJlZ0V4cChgKD86KD86XnwuKjtcXHMqKSR7bmFtZX1cXHMqXFw9XFxzKihbXjtdKikuKiQpfF4uKiRgKSwgXCIkMVwiKVxuICB9LFxuXG4gIHJlZGlyZWN0KHRvVVJMLCBmbGFzaCl7XG4gICAgaWYoZmxhc2gpeyBCcm93c2VyLnNldENvb2tpZShcIl9fcGhvZW5peF9mbGFzaF9fXCIsIGZsYXNoICsgXCI7IG1heC1hZ2U9NjAwMDA7IHBhdGg9L1wiKSB9XG4gICAgd2luZG93LmxvY2F0aW9uID0gdG9VUkxcbiAgfSxcblxuICBsb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSl7IHJldHVybiBgJHtuYW1lc3BhY2V9LSR7c3Via2V5fWAgfSxcblxuICBnZXRIYXNoVGFyZ2V0RWwobWF5YmVIYXNoKXtcbiAgICBsZXQgaGFzaCA9IG1heWJlSGFzaC50b1N0cmluZygpLnN1YnN0cmluZygxKVxuICAgIGlmKGhhc2ggPT09IFwiXCIpeyByZXR1cm4gfVxuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKSB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBhW25hbWU9XCIke2hhc2h9XCJdYClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCcm93c2VyXG4iLCAiaW1wb3J0IHtcbiAgQ0hFQ0tBQkxFX0lOUFVUUyxcbiAgREVCT1VOQ0VfUFJFVl9LRVksXG4gIERFQk9VTkNFX1RSSUdHRVIsXG4gIEZPQ1VTQUJMRV9JTlBVVFMsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9FVkVOVF9DTEFTU0VTLFxuICBQSFhfSEFTX0ZPQ1VTRUQsXG4gIFBIWF9IQVNfU1VCTUlUVEVELFxuICBQSFhfTUFJTixcbiAgUEhYX05PX0ZFRURCQUNLX0NMQVNTLFxuICBQSFhfUEFSRU5UX0lELFxuICBQSFhfUFJJVkFURSxcbiAgUEhYX1JFRixcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX1NUQVRJQyxcbiAgUEhYX1VQTE9BRF9SRUYsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfU1RJQ0tZLFxuICBUSFJPVFRMRURcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5sZXQgRE9NID0ge1xuICBieUlkKGlkKXsgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSB8fCBsb2dFcnJvcihgbm8gaWQgZm91bmQgZm9yICR7aWR9YCkgfSxcblxuICByZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKXtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSlcbiAgICBpZihlbC5jbGFzc0xpc3QubGVuZ3RoID09PSAwKXsgZWwucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIikgfVxuICB9LFxuXG4gIGFsbChub2RlLCBxdWVyeSwgY2FsbGJhY2spe1xuICAgIGlmKCFub2RlKXsgcmV0dXJuIFtdIH1cbiAgICBsZXQgYXJyYXkgPSBBcnJheS5mcm9tKG5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSkpXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gYXJyYXkuZm9yRWFjaChjYWxsYmFjaykgOiBhcnJheVxuICB9LFxuXG4gIGNoaWxkTm9kZUxlbmd0aChodG1sKXtcbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sXG4gICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuY2hpbGRFbGVtZW50Q291bnRcbiAgfSxcblxuICBpc1VwbG9hZElucHV0KGVsKXsgcmV0dXJuIGVsLnR5cGUgPT09IFwiZmlsZVwiICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRikgIT09IG51bGwgfSxcblxuICBmaW5kVXBsb2FkSW5wdXRzKG5vZGUpeyByZXR1cm4gdGhpcy5hbGwobm9kZSwgYGlucHV0W3R5cGU9XCJmaWxlXCJdWyR7UEhYX1VQTE9BRF9SRUZ9XWApIH0sXG5cbiAgZmluZENvbXBvbmVudE5vZGVMaXN0KG5vZGUsIGNpZCl7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KHRoaXMuYWxsKG5vZGUsIGBbJHtQSFhfQ09NUE9ORU5UfT1cIiR7Y2lkfVwiXWApLCBub2RlKVxuICB9LFxuXG4gIGlzUGh4RGVzdHJveWVkKG5vZGUpe1xuICAgIHJldHVybiBub2RlLmlkICYmIERPTS5wcml2YXRlKG5vZGUsIFwiZGVzdHJveWVkXCIpID8gdHJ1ZSA6IGZhbHNlXG4gIH0sXG5cbiAgbWFya1BoeENoaWxkRGVzdHJveWVkKGVsKXtcbiAgICBpZih0aGlzLmlzUGh4Q2hpbGQoZWwpKXsgZWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBcIlwiKSB9XG4gICAgdGhpcy5wdXRQcml2YXRlKGVsLCBcImRlc3Ryb3llZFwiLCB0cnVlKVxuICB9LFxuXG4gIGZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQoaHRtbCwgcGFyZW50SWQpe1xuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcbiAgICByZXR1cm4gdGhpcy5maW5kUGh4Q2hpbGRyZW4odGVtcGxhdGUuY29udGVudCwgcGFyZW50SWQpXG4gIH0sXG5cbiAgaXNJZ25vcmVkKGVsLCBwaHhVcGRhdGUpe1xuICAgIHJldHVybiAoZWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkgfHwgZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtdXBkYXRlXCIpKSA9PT0gXCJpZ25vcmVcIlxuICB9LFxuXG4gIGlzUGh4VXBkYXRlKGVsLCBwaHhVcGRhdGUsIHVwZGF0ZVR5cGVzKXtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICYmIHVwZGF0ZVR5cGVzLmluZGV4T2YoZWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkpID49IDBcbiAgfSxcblxuICBmaW5kUGh4U3RpY2t5KGVsKXsgcmV0dXJuIHRoaXMuYWxsKGVsLCBgWyR7UEhYX1NUSUNLWX1dYCkgfSxcblxuICBmaW5kUGh4Q2hpbGRyZW4oZWwsIHBhcmVudElkKXtcbiAgICByZXR1cm4gdGhpcy5hbGwoZWwsIGAke1BIWF9WSUVXX1NFTEVDVE9SfVske1BIWF9QQVJFTlRfSUR9PVwiJHtwYXJlbnRJZH1cIl1gKVxuICB9LFxuXG4gIGZpbmRQYXJlbnRDSURzKG5vZGUsIGNpZHMpe1xuICAgIGxldCBpbml0aWFsID0gbmV3IFNldChjaWRzKVxuICAgIHJldHVybiBjaWRzLnJlZHVjZSgoYWNjLCBjaWQpID0+IHtcbiAgICAgIGxldCBzZWxlY3RvciA9IGBbJHtQSFhfQ09NUE9ORU5UfT1cIiR7Y2lkfVwiXSBbJHtQSFhfQ09NUE9ORU5UfV1gXG5cbiAgICAgIHRoaXMuZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KHRoaXMuYWxsKG5vZGUsIHNlbGVjdG9yKSwgbm9kZSlcbiAgICAgICAgLm1hcChlbCA9PiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkpKVxuICAgICAgICAuZm9yRWFjaChjaGlsZENJRCA9PiBhY2MuZGVsZXRlKGNoaWxkQ0lEKSlcblxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIGluaXRpYWwpXG4gIH0sXG5cbiAgZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KG5vZGVzLCBwYXJlbnQpe1xuICAgIGlmKHBhcmVudC5xdWVyeVNlbGVjdG9yKFBIWF9WSUVXX1NFTEVDVE9SKSl7XG4gICAgICByZXR1cm4gbm9kZXMuZmlsdGVyKGVsID0+IHRoaXMud2l0aGluU2FtZUxpdmVWaWV3KGVsLCBwYXJlbnQpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gIH0sXG5cbiAgd2l0aGluU2FtZUxpdmVWaWV3KG5vZGUsIHBhcmVudCl7XG4gICAgd2hpbGUobm9kZSA9IG5vZGUucGFyZW50Tm9kZSl7XG4gICAgICBpZihub2RlLmlzU2FtZU5vZGUocGFyZW50KSl7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmKG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSAhPT0gbnVsbCl7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICB9LFxuXG4gIHByaXZhdGUoZWwsIGtleSl7IHJldHVybiBlbFtQSFhfUFJJVkFURV0gJiYgZWxbUEhYX1BSSVZBVEVdW2tleV0gfSxcblxuICBkZWxldGVQcml2YXRlKGVsLCBrZXkpeyBlbFtQSFhfUFJJVkFURV0gJiYgZGVsZXRlIChlbFtQSFhfUFJJVkFURV1ba2V5XSkgfSxcblxuICBwdXRQcml2YXRlKGVsLCBrZXksIHZhbHVlKXtcbiAgICBpZighZWxbUEhYX1BSSVZBVEVdKXsgZWxbUEhYX1BSSVZBVEVdID0ge30gfVxuICAgIGVsW1BIWF9QUklWQVRFXVtrZXldID0gdmFsdWVcbiAgfSxcblxuICB1cGRhdGVQcml2YXRlKGVsLCBrZXksIGRlZmF1bHRWYWwsIHVwZGF0ZUZ1bmMpe1xuICAgIGxldCBleGlzdGluZyA9IHRoaXMucHJpdmF0ZShlbCwga2V5KVxuICAgIGlmKGV4aXN0aW5nID09PSB1bmRlZmluZWQpe1xuICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHVwZGF0ZUZ1bmMoZGVmYXVsdFZhbCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB1cGRhdGVGdW5jKGV4aXN0aW5nKSlcbiAgICB9XG4gIH0sXG5cbiAgY29weVByaXZhdGVzKHRhcmdldCwgc291cmNlKXtcbiAgICBpZihzb3VyY2VbUEhYX1BSSVZBVEVdKXtcbiAgICAgIHRhcmdldFtQSFhfUFJJVkFURV0gPSBzb3VyY2VbUEhYX1BSSVZBVEVdXG4gICAgfVxuICB9LFxuXG4gIHB1dFRpdGxlKHN0cil7XG4gICAgbGV0IHRpdGxlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGl0bGVcIilcbiAgICBsZXQge3ByZWZpeCwgc3VmZml4fSA9IHRpdGxlRWwuZGF0YXNldFxuICAgIGRvY3VtZW50LnRpdGxlID0gYCR7cHJlZml4IHx8IFwiXCJ9JHtzdHJ9JHtzdWZmaXggfHwgXCJcIn1gXG4gIH0sXG5cbiAgZGVib3VuY2UoZWwsIGV2ZW50LCBwaHhEZWJvdW5jZSwgZGVmYXVsdERlYm91bmNlLCBwaHhUaHJvdHRsZSwgZGVmYXVsdFRocm90dGxlLCBhc3luY0ZpbHRlciwgY2FsbGJhY2spe1xuICAgIGxldCBkZWJvdW5jZSA9IGVsLmdldEF0dHJpYnV0ZShwaHhEZWJvdW5jZSlcbiAgICBsZXQgdGhyb3R0bGUgPSBlbC5nZXRBdHRyaWJ1dGUocGh4VGhyb3R0bGUpXG4gICAgaWYoZGVib3VuY2UgPT09IFwiXCIpeyBkZWJvdW5jZSA9IGRlZmF1bHREZWJvdW5jZSB9XG4gICAgaWYodGhyb3R0bGUgPT09IFwiXCIpeyB0aHJvdHRsZSA9IGRlZmF1bHRUaHJvdHRsZSB9XG4gICAgbGV0IHZhbHVlID0gZGVib3VuY2UgfHwgdGhyb3R0bGVcbiAgICBzd2l0Y2godmFsdWUpe1xuICAgICAgY2FzZSBudWxsOiByZXR1cm4gY2FsbGJhY2soKVxuXG4gICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICBpZih0aGlzLm9uY2UoZWwsIFwiZGVib3VuY2UtYmx1clwiKSl7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gY2FsbGJhY2soKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGV0IHRpbWVvdXQgPSBwYXJzZUludCh2YWx1ZSlcbiAgICAgICAgbGV0IHRyaWdnZXIgPSAoKSA9PiB0aHJvdHRsZSA/IHRoaXMuZGVsZXRlUHJpdmF0ZShlbCwgVEhST1RUTEVEKSA6IGNhbGxiYWNrKClcbiAgICAgICAgbGV0IGN1cnJlbnRDeWNsZSA9IHRoaXMuaW5jQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIsIHRyaWdnZXIpXG4gICAgICAgIGlmKGlzTmFOKHRpbWVvdXQpKXsgcmV0dXJuIGxvZ0Vycm9yKGBpbnZhbGlkIHRocm90dGxlL2RlYm91bmNlIHZhbHVlOiAke3ZhbHVlfWApIH1cbiAgICAgICAgaWYodGhyb3R0bGUpe1xuICAgICAgICAgIGxldCBuZXdLZXlEb3duID0gZmFsc2VcbiAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImtleWRvd25cIil7XG4gICAgICAgICAgICBsZXQgcHJldktleSA9IHRoaXMucHJpdmF0ZShlbCwgREVCT1VOQ0VfUFJFVl9LRVkpXG4gICAgICAgICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZLCBldmVudC5rZXkpXG4gICAgICAgICAgICBuZXdLZXlEb3duID0gcHJldktleSAhPT0gZXZlbnQua2V5XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIW5ld0tleURvd24gJiYgdGhpcy5wcml2YXRlKGVsLCBUSFJPVFRMRUQpKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIFRIUk9UVExFRCwgdHJ1ZSlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZihhc3luY0ZpbHRlcigpKXsgdGhpcy50cmlnZ2VyQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIpIH1cbiAgICAgICAgICAgIH0sIHRpbWVvdXQpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYoYXN5bmNGaWx0ZXIoKSl7IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCBjdXJyZW50Q3ljbGUpIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvcm0gPSBlbC5mb3JtXG4gICAgICAgIGlmKGZvcm0gJiYgdGhpcy5vbmNlKGZvcm0sIFwiYmluZC1kZWJvdW5jZVwiKSl7XG4gICAgICAgICAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsICgpID0+IHtcbiAgICAgICAgICAgIEFycmF5LmZyb20oKG5ldyBGb3JtRGF0YShmb3JtKSkuZW50cmllcygpLCAoW25hbWVdKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpbnB1dCA9IGZvcm0ucXVlcnlTZWxlY3RvcihgW25hbWU9XCIke25hbWV9XCJdYClcbiAgICAgICAgICAgICAgdGhpcy5pbmNDeWNsZShpbnB1dCwgREVCT1VOQ0VfVFJJR0dFUilcbiAgICAgICAgICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBUSFJPVFRMRUQpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5vbmNlKGVsLCBcImJpbmQtZGVib3VuY2VcIikpe1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSlcbiAgICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0cmlnZ2VyQ3ljbGUoZWwsIGtleSwgY3VycmVudEN5Y2xlKXtcbiAgICBsZXQgW2N5Y2xlLCB0cmlnZ2VyXSA9IHRoaXMucHJpdmF0ZShlbCwga2V5KVxuICAgIGlmKCFjdXJyZW50Q3ljbGUpeyBjdXJyZW50Q3ljbGUgPSBjeWNsZSB9XG4gICAgaWYoY3VycmVudEN5Y2xlID09PSBjeWNsZSl7XG4gICAgICB0aGlzLmluY0N5Y2xlKGVsLCBrZXkpXG4gICAgICB0cmlnZ2VyKClcbiAgICB9XG4gIH0sXG5cbiAgb25jZShlbCwga2V5KXtcbiAgICBpZih0aGlzLnByaXZhdGUoZWwsIGtleSkgPT09IHRydWUpeyByZXR1cm4gZmFsc2UgfVxuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB0cnVlKVxuICAgIHJldHVybiB0cnVlXG4gIH0sXG5cbiAgaW5jQ3ljbGUoZWwsIGtleSwgdHJpZ2dlciA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICBsZXQgW2N1cnJlbnRDeWNsZV0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSkgfHwgWzAsIHRyaWdnZXJdXG4gICAgY3VycmVudEN5Y2xlKytcbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgW2N1cnJlbnRDeWNsZSwgdHJpZ2dlcl0pXG4gICAgcmV0dXJuIGN1cnJlbnRDeWNsZVxuICB9LFxuXG4gIGRpc2NhcmRFcnJvcihjb250YWluZXIsIGVsLCBwaHhGZWVkYmFja0Zvcil7XG4gICAgbGV0IGZpZWxkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhGZWVkYmFja0ZvcilcbiAgICAvLyBUT0RPOiBSZW1vdmUgaWQgbG9va3VwIGFmdGVyIHdlIHVwZGF0ZSBQaG9lbml4IHRvIHVzZSBpbnB1dF9uYW1lIGluc3RlYWQgb2YgaW5wdXRfaWRcbiAgICBsZXQgaW5wdXQgPSBmaWVsZCAmJiBjb250YWluZXIucXVlcnlTZWxlY3RvcihgW2lkPVwiJHtmaWVsZH1cIl0sIFtuYW1lPVwiJHtmaWVsZH1cIl1gKVxuICAgIGlmKCFpbnB1dCl7IHJldHVybiB9XG5cbiAgICBpZighKHRoaXMucHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VEKSB8fCB0aGlzLnByaXZhdGUoaW5wdXQuZm9ybSwgUEhYX0hBU19TVUJNSVRURUQpKSl7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKFBIWF9OT19GRUVEQkFDS19DTEFTUylcbiAgICB9XG4gIH0sXG5cbiAgc2hvd0Vycm9yKGlucHV0RWwsIHBoeEZlZWRiYWNrRm9yKXtcbiAgICBpZihpbnB1dEVsLmlkIHx8IGlucHV0RWwubmFtZSl7XG4gICAgICB0aGlzLmFsbChpbnB1dEVsLmZvcm0sIGBbJHtwaHhGZWVkYmFja0Zvcn09XCIke2lucHV0RWwuaWR9XCJdLCBbJHtwaHhGZWVkYmFja0Zvcn09XCIke2lucHV0RWwubmFtZX1cIl1gLCAoZWwpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcyhlbCwgUEhYX05PX0ZFRURCQUNLX0NMQVNTKVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgaXNQaHhDaGlsZChub2RlKXtcbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRClcbiAgfSxcblxuICBpc1BoeFN0aWNreShub2RlKXtcbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1NUSUNLWSkgIT09IG51bGxcbiAgfSxcblxuICBmaXJzdFBoeENoaWxkKGVsKXtcbiAgICByZXR1cm4gdGhpcy5pc1BoeENoaWxkKGVsKSA/IGVsIDogdGhpcy5hbGwoZWwsIGBbJHtQSFhfUEFSRU5UX0lEfV1gKVswXVxuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCBuYW1lLCBvcHRzID0ge30pe1xuICAgIGxldCBidWJibGVzID0gb3B0cy5idWJibGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFvcHRzLmJ1YmJsZXNcbiAgICBsZXQgZXZlbnRPcHRzID0ge2J1YmJsZXM6IGJ1YmJsZXMsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbDogb3B0cy5kZXRhaWwgfHwge319XG4gICAgbGV0IGV2ZW50ID0gbmFtZSA9PT0gXCJjbGlja1wiID8gbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiLCBldmVudE9wdHMpIDogbmV3IEN1c3RvbUV2ZW50KG5hbWUsIGV2ZW50T3B0cylcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudClcbiAgfSxcblxuICBjbG9uZU5vZGUobm9kZSwgaHRtbCl7XG4gICAgaWYodHlwZW9mIChodG1sKSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNsb25lZCA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKVxuICAgICAgY2xvbmVkLmlubmVySFRNTCA9IGh0bWxcbiAgICAgIHJldHVybiBjbG9uZWRcbiAgICB9XG4gIH0sXG5cbiAgbWVyZ2VBdHRycyh0YXJnZXQsIHNvdXJjZSwgb3B0cyA9IHt9KXtcbiAgICBsZXQgZXhjbHVkZSA9IG9wdHMuZXhjbHVkZSB8fCBbXVxuICAgIGxldCBpc0lnbm9yZWQgPSBvcHRzLmlzSWdub3JlZFxuICAgIGxldCBzb3VyY2VBdHRycyA9IHNvdXJjZS5hdHRyaWJ1dGVzXG4gICAgZm9yKGxldCBpID0gc291cmNlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgbGV0IG5hbWUgPSBzb3VyY2VBdHRyc1tpXS5uYW1lXG4gICAgICBpZihleGNsdWRlLmluZGV4T2YobmFtZSkgPCAwKXsgdGFyZ2V0LnNldEF0dHJpYnV0ZShuYW1lLCBzb3VyY2UuZ2V0QXR0cmlidXRlKG5hbWUpKSB9XG4gICAgfVxuXG4gICAgbGV0IHRhcmdldEF0dHJzID0gdGFyZ2V0LmF0dHJpYnV0ZXNcbiAgICBmb3IobGV0IGkgPSB0YXJnZXRBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICBsZXQgbmFtZSA9IHRhcmdldEF0dHJzW2ldLm5hbWVcbiAgICAgIGlmKGlzSWdub3JlZCl7XG4gICAgICAgIGlmKG5hbWUuc3RhcnRzV2l0aChcImRhdGEtXCIpICYmICFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpKXsgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZighc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSl7IHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtZXJnZUZvY3VzZWRJbnB1dCh0YXJnZXQsIHNvdXJjZSl7XG4gICAgLy8gc2tpcCBzZWxlY3RzIGJlY2F1c2UgRkYgd2lsbCByZXNldCBoaWdobGlnaHRlZCBpbmRleCBmb3IgYW55IHNldEF0dHJpYnV0ZVxuICAgIGlmKCEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpKXsgRE9NLm1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIHtleGNsdWRlOiBbXCJ2YWx1ZVwiXX0pIH1cbiAgICBpZihzb3VyY2UucmVhZE9ubHkpe1xuICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJyZWFkb25seVwiKVxuICAgIH1cbiAgfSxcblxuICBoYXNTZWxlY3Rpb25SYW5nZShlbCl7XG4gICAgcmV0dXJuIGVsLnNldFNlbGVjdGlvblJhbmdlICYmIChlbC50eXBlID09PSBcInRleHRcIiB8fCBlbC50eXBlID09PSBcInRleHRhcmVhXCIpXG4gIH0sXG5cbiAgcmVzdG9yZUZvY3VzKGZvY3VzZWQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpe1xuICAgIGlmKCFET00uaXNUZXh0dWFsSW5wdXQoZm9jdXNlZCkpeyByZXR1cm4gfVxuICAgIGxldCB3YXNGb2N1c2VkID0gZm9jdXNlZC5tYXRjaGVzKFwiOmZvY3VzXCIpXG4gICAgaWYoZm9jdXNlZC5yZWFkT25seSl7IGZvY3VzZWQuYmx1cigpIH1cbiAgICBpZighd2FzRm9jdXNlZCl7IGZvY3VzZWQuZm9jdXMoKSB9XG4gICAgaWYodGhpcy5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSl7XG4gICAgICBmb2N1c2VkLnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpXG4gICAgfVxuICB9LFxuXG4gIGlzRm9ybUlucHV0KGVsKXsgcmV0dXJuIC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KGVsLnRhZ05hbWUpICYmIGVsLnR5cGUgIT09IFwiYnV0dG9uXCIgfSxcblxuICBzeW5jQXR0cnNUb1Byb3BzKGVsKXtcbiAgICBpZihlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgQ0hFQ0tBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSkgPj0gMCl7XG4gICAgICBlbC5jaGVja2VkID0gZWwuZ2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiKSAhPT0gbnVsbFxuICAgIH1cbiAgfSxcblxuICBpc1RleHR1YWxJbnB1dChlbCl7IHJldHVybiBGT0NVU0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCB9LFxuXG4gIGlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKXtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhUcmlnZ2VyRXh0ZXJuYWwpICE9PSBudWxsXG4gIH0sXG5cbiAgc3luY1BlbmRpbmdSZWYoZnJvbUVsLCB0b0VsLCBkaXNhYmxlV2l0aCl7XG4gICAgbGV0IHJlZiA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1JFRilcbiAgICBpZihyZWYgPT09IG51bGwpeyByZXR1cm4gdHJ1ZSB9XG4gICAgbGV0IHJlZlNyYyA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG5cbiAgICBpZihET00uaXNGb3JtSW5wdXQoZnJvbUVsKSB8fCBmcm9tRWwuZ2V0QXR0cmlidXRlKGRpc2FibGVXaXRoKSAhPT0gbnVsbCl7XG4gICAgICBpZihET00uaXNVcGxvYWRJbnB1dChmcm9tRWwpKXsgRE9NLm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7aXNJZ25vcmVkOiB0cnVlfSkgfVxuICAgICAgRE9NLnB1dFByaXZhdGUoZnJvbUVsLCBQSFhfUkVGLCB0b0VsKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIFBIWF9FVkVOVF9DTEFTU0VTLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICAgICAgZnJvbUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpICYmIHRvRWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICB9KVxuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRiwgcmVmKVxuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHJlZlNyYylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9LFxuXG4gIGNsZWFuQ2hpbGROb2Rlcyhjb250YWluZXIsIHBoeFVwZGF0ZSl7XG4gICAgaWYoRE9NLmlzUGh4VXBkYXRlKGNvbnRhaW5lciwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSl7XG4gICAgICBsZXQgdG9SZW1vdmUgPSBbXVxuICAgICAgY29udGFpbmVyLmNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICBpZighY2hpbGROb2RlLmlkKXtcbiAgICAgICAgICAvLyBTa2lwIHdhcm5pbmcgaWYgaXQncyBhbiBlbXB0eSB0ZXh0IG5vZGUgKGUuZy4gYSBuZXctbGluZSlcbiAgICAgICAgICBsZXQgaXNFbXB0eVRleHROb2RlID0gY2hpbGROb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiBjaGlsZE5vZGUubm9kZVZhbHVlLnRyaW0oKSA9PT0gXCJcIlxuICAgICAgICAgIGlmKCFpc0VtcHR5VGV4dE5vZGUpe1xuICAgICAgICAgICAgbG9nRXJyb3IoXCJvbmx5IEhUTUwgZWxlbWVudCB0YWdzIHdpdGggYW4gaWQgYXJlIGFsbG93ZWQgaW5zaWRlIGNvbnRhaW5lcnMgd2l0aCBwaHgtdXBkYXRlLlxcblxcblwiICtcbiAgICAgICAgICAgICAgYHJlbW92aW5nIGlsbGVnYWwgbm9kZTogXCIkeyhjaGlsZE5vZGUub3V0ZXJIVE1MIHx8IGNoaWxkTm9kZS5ub2RlVmFsdWUpLnRyaW0oKX1cIlxcblxcbmApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRvUmVtb3ZlLnB1c2goY2hpbGROb2RlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdG9SZW1vdmUuZm9yRWFjaChjaGlsZE5vZGUgPT4gY2hpbGROb2RlLnJlbW92ZSgpKVxuICAgIH1cbiAgfSxcblxuICByZXBsYWNlUm9vdENvbnRhaW5lcihjb250YWluZXIsIHRhZ05hbWUsIGF0dHJzKXtcbiAgICBsZXQgcmV0YWluZWRBdHRycyA9IG5ldyBTZXQoW1wiaWRcIiwgUEhYX1NFU1NJT04sIFBIWF9TVEFUSUMsIFBIWF9NQUlOLCBQSFhfUk9PVF9JRF0pXG4gICAgaWYoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpKXtcbiAgICAgIEFycmF5LmZyb20oY29udGFpbmVyLmF0dHJpYnV0ZXMpXG4gICAgICAgIC5maWx0ZXIoYXR0ciA9PiAhcmV0YWluZWRBdHRycy5oYXMoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAuZm9yRWFjaChhdHRyID0+IGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKSlcblxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpXG4gICAgICAgIC5maWx0ZXIobmFtZSA9PiAhcmV0YWluZWRBdHRycy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgLmZvckVhY2goYXR0ciA9PiBjb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSlcblxuICAgICAgcmV0dXJuIGNvbnRhaW5lclxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpXG4gICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChhdHRyID0+IG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pKVxuICAgICAgcmV0YWluZWRBdHRycy5mb3JFYWNoKGF0dHIgPT4gbmV3Q29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBjb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHIpKSlcbiAgICAgIG5ld0NvbnRhaW5lci5pbm5lckhUTUwgPSBjb250YWluZXIuaW5uZXJIVE1MXG4gICAgICBjb250YWluZXIucmVwbGFjZVdpdGgobmV3Q29udGFpbmVyKVxuICAgICAgcmV0dXJuIG5ld0NvbnRhaW5lclxuICAgIH1cbiAgfSxcblxuICBnZXRTdGlja3koZWwsIG5hbWUsIGRlZmF1bHRWYWwpe1xuICAgIGxldCBvcCA9IChET00ucHJpdmF0ZShlbCwgXCJzdGlja3lcIikgfHwgW10pLmZpbmQoKFtleGlzdGluZ05hbWUsIF0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSlcbiAgICBpZihvcCl7XG4gICAgICBsZXQgW19uYW1lLCBfb3AsIHN0YXNoZWRSZXN1bHRdID0gb3BcbiAgICAgIHJldHVybiBzdGFzaGVkUmVzdWx0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0eXBlb2YoZGVmYXVsdFZhbCkgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWwoKSA6IGRlZmF1bHRWYWxcbiAgICB9XG4gIH0sXG5cbiAgZGVsZXRlU3RpY2t5KGVsLCBuYW1lKXtcbiAgICB0aGlzLnVwZGF0ZVByaXZhdGUoZWwsIFwic3RpY2t5XCIsIFtdLCBvcHMgPT4ge1xuICAgICAgcmV0dXJuIG9wcy5maWx0ZXIoKFtleGlzdGluZ05hbWUsIF9dKSA9PiBleGlzdGluZ05hbWUgIT09IG5hbWUpXG4gICAgfSlcbiAgfSxcblxuICBwdXRTdGlja3koZWwsIG5hbWUsIG9wKXtcbiAgICBsZXQgc3Rhc2hlZFJlc3VsdCA9IG9wKGVsKVxuICAgIHRoaXMudXBkYXRlUHJpdmF0ZShlbCwgXCJzdGlja3lcIiwgW10sIG9wcyA9PiB7XG4gICAgICBsZXQgZXhpc3RpbmdJbmRleCA9IG9wcy5maW5kSW5kZXgoKFtleGlzdGluZ05hbWUsIF0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSlcbiAgICAgIGlmKGV4aXN0aW5nSW5kZXggPj0gMCl7XG4gICAgICAgIG9wc1tleGlzdGluZ0luZGV4XSA9IFtuYW1lLCBvcCwgc3Rhc2hlZFJlc3VsdF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wcy5wdXNoKFtuYW1lLCBvcCwgc3Rhc2hlZFJlc3VsdF0pXG4gICAgICB9XG4gICAgICByZXR1cm4gb3BzXG4gICAgfSlcbiAgfSxcblxuICBhcHBseVN0aWNreU9wZXJhdGlvbnMoZWwpe1xuICAgIGxldCBvcHMgPSBET00ucHJpdmF0ZShlbCwgXCJzdGlja3lcIilcbiAgICBpZighb3BzKXsgcmV0dXJuIH1cblxuICAgIG9wcy5mb3JFYWNoKChbbmFtZSwgb3AsIF9zdGFzaGVkXSkgPT4gdGhpcy5wdXRTdGlja3koZWwsIG5hbWUsIG9wKSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBET01cbiIsICJpbXBvcnQge1xuICBQSFhfQUNUSVZFX0VOVFJZX1JFRlMsXG4gIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2hhbm5lbFVwbG9hZGVyLFxuICBsb2dFcnJvclxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwbG9hZEVudHJ5IHtcbiAgc3RhdGljIGlzQWN0aXZlKGZpbGVFbCwgZmlsZSl7XG4gICAgbGV0IGlzTmV3ID0gZmlsZS5fcGh4UmVmID09PSB1bmRlZmluZWRcbiAgICBsZXQgYWN0aXZlUmVmcyA9IGZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKS5zcGxpdChcIixcIilcbiAgICBsZXQgaXNBY3RpdmUgPSBhY3RpdmVSZWZzLmluZGV4T2YoTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSkpID49IDBcbiAgICByZXR1cm4gZmlsZS5zaXplID4gMCAmJiAoaXNOZXcgfHwgaXNBY3RpdmUpXG4gIH1cblxuICBzdGF0aWMgaXNQcmVmbGlnaHRlZChmaWxlRWwsIGZpbGUpe1xuICAgIGxldCBwcmVmbGlnaHRlZFJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKS5zcGxpdChcIixcIilcbiAgICBsZXQgaXNQcmVmbGlnaHRlZCA9IHByZWZsaWdodGVkUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwXG4gICAgcmV0dXJuIGlzUHJlZmxpZ2h0ZWQgJiYgdGhpcy5pc0FjdGl2ZShmaWxlRWwsIGZpbGUpXG4gIH1cblxuICBjb25zdHJ1Y3RvcihmaWxlRWwsIGZpbGUsIHZpZXcpe1xuICAgIHRoaXMucmVmID0gTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSlcbiAgICB0aGlzLmZpbGVFbCA9IGZpbGVFbFxuICAgIHRoaXMuZmlsZSA9IGZpbGVcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5tZXRhID0gbnVsbFxuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2VcbiAgICB0aGlzLl9pc0RvbmUgPSBmYWxzZVxuICAgIHRoaXMuX3Byb2dyZXNzID0gMFxuICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSAtMVxuICAgIHRoaXMuX29uRG9uZSA9IGZ1bmN0aW9uICgpeyB9XG4gICAgdGhpcy5fb25FbFVwZGF0ZWQgPSB0aGlzLm9uRWxVcGRhdGVkLmJpbmQodGhpcylcbiAgICB0aGlzLmZpbGVFbC5hZGRFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpXG4gIH1cblxuICBtZXRhZGF0YSgpeyByZXR1cm4gdGhpcy5tZXRhIH1cblxuICBwcm9ncmVzcyhwcm9ncmVzcyl7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSBNYXRoLmZsb29yKHByb2dyZXNzKVxuICAgIGlmKHRoaXMuX3Byb2dyZXNzID4gdGhpcy5fbGFzdFByb2dyZXNzU2VudCl7XG4gICAgICBpZih0aGlzLl9wcm9ncmVzcyA+PSAxMDApe1xuICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDEwMFxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gMTAwXG4gICAgICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCAxMDAsICgpID0+IHtcbiAgICAgICAgICBMaXZlVXBsb2FkZXIudW50cmFja0ZpbGUodGhpcy5maWxlRWwsIHRoaXMuZmlsZSlcbiAgICAgICAgICB0aGlzLl9vbkRvbmUoKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IHRoaXMuX3Byb2dyZXNzXG4gICAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgdGhpcy5fcHJvZ3Jlc3MpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2FuY2VsKCl7XG4gICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlXG4gICAgdGhpcy5faXNEb25lID0gdHJ1ZVxuICAgIHRoaXMuX29uRG9uZSgpXG4gIH1cblxuICBpc0RvbmUoKXsgcmV0dXJuIHRoaXMuX2lzRG9uZSB9XG5cbiAgZXJyb3IocmVhc29uID0gXCJmYWlsZWRcIil7XG4gICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCB7ZXJyb3I6IHJlYXNvbn0pXG4gICAgTGl2ZVVwbG9hZGVyLmNsZWFyRmlsZXModGhpcy5maWxlRWwpXG4gIH1cblxuICAvL3ByaXZhdGVcblxuICBvbkRvbmUoY2FsbGJhY2spe1xuICAgIHRoaXMuX29uRG9uZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuZmlsZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZClcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICBvbkVsVXBkYXRlZCgpe1xuICAgIGxldCBhY3RpdmVSZWZzID0gdGhpcy5maWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgaWYoYWN0aXZlUmVmcy5pbmRleE9mKHRoaXMucmVmKSA9PT0gLTEpeyB0aGlzLmNhbmNlbCgpIH1cbiAgfVxuXG4gIHRvUHJlZmxpZ2h0UGF5bG9hZCgpe1xuICAgIHJldHVybiB7XG4gICAgICBsYXN0X21vZGlmaWVkOiB0aGlzLmZpbGUubGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZTogdGhpcy5maWxlLm5hbWUsXG4gICAgICBzaXplOiB0aGlzLmZpbGUuc2l6ZSxcbiAgICAgIHR5cGU6IHRoaXMuZmlsZS50eXBlLFxuICAgICAgcmVmOiB0aGlzLnJlZlxuICAgIH1cbiAgfVxuXG4gIHVwbG9hZGVyKHVwbG9hZGVycyl7XG4gICAgaWYodGhpcy5tZXRhLnVwbG9hZGVyKXtcbiAgICAgIGxldCBjYWxsYmFjayA9IHVwbG9hZGVyc1t0aGlzLm1ldGEudXBsb2FkZXJdIHx8IGxvZ0Vycm9yKGBubyB1cGxvYWRlciBjb25maWd1cmVkIGZvciAke3RoaXMubWV0YS51cGxvYWRlcn1gKVxuICAgICAgcmV0dXJuIHtuYW1lOiB0aGlzLm1ldGEudXBsb2FkZXIsIGNhbGxiYWNrOiBjYWxsYmFja31cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtuYW1lOiBcImNoYW5uZWxcIiwgY2FsbGJhY2s6IGNoYW5uZWxVcGxvYWRlcn1cbiAgICB9XG4gIH1cblxuICB6aXBQb3N0RmxpZ2h0KHJlc3Ape1xuICAgIHRoaXMubWV0YSA9IHJlc3AuZW50cmllc1t0aGlzLnJlZl1cbiAgICBpZighdGhpcy5tZXRhKXsgbG9nRXJyb3IoYG5vIHByZWZsaWdodCB1cGxvYWQgcmVzcG9uc2UgcmV0dXJuZWQgd2l0aCByZWYgJHt0aGlzLnJlZn1gLCB7aW5wdXQ6IHRoaXMuZmlsZUVsLCByZXNwb25zZTogcmVzcH0pIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFBIWF9ET05FX1JFRlMsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTLFxuICBQSFhfVVBMT0FEX1JFRlxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBVcGxvYWRFbnRyeSBmcm9tIFwiLi91cGxvYWRfZW50cnlcIlxuXG5sZXQgbGl2ZVVwbG9hZGVyRmlsZVJlZiA9IDBcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVVwbG9hZGVyIHtcbiAgc3RhdGljIGdlbkZpbGVSZWYoZmlsZSl7XG4gICAgbGV0IHJlZiA9IGZpbGUuX3BoeFJlZlxuICAgIGlmKHJlZiAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiByZWZcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsZS5fcGh4UmVmID0gKGxpdmVVcGxvYWRlckZpbGVSZWYrKykudG9TdHJpbmcoKVxuICAgICAgcmV0dXJuIGZpbGUuX3BoeFJlZlxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRFbnRyeURhdGFVUkwoaW5wdXRFbCwgcmVmLCBjYWxsYmFjayl7XG4gICAgbGV0IGZpbGUgPSB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpLmZpbmQoZmlsZSA9PiB0aGlzLmdlbkZpbGVSZWYoZmlsZSkgPT09IHJlZilcbiAgICBjYWxsYmFjayhVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpKVxuICB9XG5cbiAgc3RhdGljIGhhc1VwbG9hZHNJblByb2dyZXNzKGZvcm1FbCl7XG4gICAgbGV0IGFjdGl2ZSA9IDBcbiAgICBET00uZmluZFVwbG9hZElucHV0cyhmb3JtRWwpLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgaWYoaW5wdXQuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKSAhPT0gaW5wdXQuZ2V0QXR0cmlidXRlKFBIWF9ET05FX1JFRlMpKXtcbiAgICAgICAgYWN0aXZlKytcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBhY3RpdmUgPiAwXG4gIH1cblxuICBzdGF0aWMgc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKXtcbiAgICBsZXQgZmlsZXMgPSB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpXG4gICAgbGV0IGZpbGVEYXRhID0ge31cbiAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgbGV0IGVudHJ5ID0ge3BhdGg6IGlucHV0RWwubmFtZX1cbiAgICAgIGxldCB1cGxvYWRSZWYgPSBpbnB1dEVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRilcbiAgICAgIGZpbGVEYXRhW3VwbG9hZFJlZl0gPSBmaWxlRGF0YVt1cGxvYWRSZWZdIHx8IFtdXG4gICAgICBlbnRyeS5yZWYgPSB0aGlzLmdlbkZpbGVSZWYoZmlsZSlcbiAgICAgIGVudHJ5Lm5hbWUgPSBmaWxlLm5hbWUgfHwgZW50cnkucmVmXG4gICAgICBlbnRyeS50eXBlID0gZmlsZS50eXBlXG4gICAgICBlbnRyeS5zaXplID0gZmlsZS5zaXplXG4gICAgICBmaWxlRGF0YVt1cGxvYWRSZWZdLnB1c2goZW50cnkpXG4gICAgfSlcbiAgICByZXR1cm4gZmlsZURhdGFcbiAgfVxuXG4gIHN0YXRpYyBjbGVhckZpbGVzKGlucHV0RWwpe1xuICAgIGlucHV0RWwudmFsdWUgPSBudWxsXG4gICAgaW5wdXRFbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpXG4gICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBbXSlcbiAgfVxuXG4gIHN0YXRpYyB1bnRyYWNrRmlsZShpbnB1dEVsLCBmaWxlKXtcbiAgICBET00ucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIERPTS5wcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIikuZmlsdGVyKGYgPT4gIU9iamVjdC5pcyhmLCBmaWxlKSkpXG4gIH1cblxuICBzdGF0aWMgdHJhY2tGaWxlcyhpbnB1dEVsLCBmaWxlcyl7XG4gICAgaWYoaW5wdXRFbC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAhPT0gbnVsbCl7XG4gICAgICBsZXQgbmV3RmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiAhdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKGYgPT4gT2JqZWN0LmlzKGYsIGZpbGUpKSlcbiAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5jb25jYXQobmV3RmlsZXMpKVxuICAgICAgaW5wdXRFbC52YWx1ZSA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBmaWxlcylcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYWN0aXZlRmlsZUlucHV0cyhmb3JtRWwpe1xuICAgIGxldCBmaWxlSW5wdXRzID0gRE9NLmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGZpbGVJbnB1dHMpLmZpbHRlcihlbCA9PiBlbC5maWxlcyAmJiB0aGlzLmFjdGl2ZUZpbGVzKGVsKS5sZW5ndGggPiAwKVxuICB9XG5cbiAgc3RhdGljIGFjdGl2ZUZpbGVzKGlucHV0KXtcbiAgICByZXR1cm4gKERPTS5wcml2YXRlKGlucHV0LCBcImZpbGVzXCIpIHx8IFtdKS5maWx0ZXIoZiA9PiBVcGxvYWRFbnRyeS5pc0FjdGl2ZShpbnB1dCwgZikpXG4gIH1cblxuICBzdGF0aWMgaW5wdXRzQXdhaXRpbmdQcmVmbGlnaHQoZm9ybUVsKXtcbiAgICBsZXQgZmlsZUlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoaW5wdXQgPT4gdGhpcy5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KS5sZW5ndGggPiAwKVxuICB9XG5cbiAgc3RhdGljIGZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXQpe1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0KS5maWx0ZXIoZiA9PiAhVXBsb2FkRW50cnkuaXNQcmVmbGlnaHRlZChpbnB1dCwgZikpXG4gIH1cblxuICBjb25zdHJ1Y3RvcihpbnB1dEVsLCB2aWV3LCBvbkNvbXBsZXRlKXtcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZVxuICAgIHRoaXMuX2VudHJpZXMgPVxuICAgICAgQXJyYXkuZnJvbShMaXZlVXBsb2FkZXIuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dEVsKSB8fCBbXSlcbiAgICAgICAgLm1hcChmaWxlID0+IG5ldyBVcGxvYWRFbnRyeShpbnB1dEVsLCBmaWxlLCB2aWV3KSlcblxuICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPSB0aGlzLl9lbnRyaWVzLmxlbmd0aFxuICB9XG5cbiAgZW50cmllcygpeyByZXR1cm4gdGhpcy5fZW50cmllcyB9XG5cbiAgaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgbGl2ZVNvY2tldCl7XG4gICAgdGhpcy5fZW50cmllcyA9XG4gICAgICB0aGlzLl9lbnRyaWVzLm1hcChlbnRyeSA9PiB7XG4gICAgICAgIGVudHJ5LnppcFBvc3RGbGlnaHQocmVzcClcbiAgICAgICAgZW50cnkub25Eb25lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzLS1cbiAgICAgICAgICBpZih0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID09PSAwKXsgdGhpcy5vbkNvbXBsZXRlKCkgfVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gZW50cnlcbiAgICAgIH0pXG5cbiAgICBsZXQgZ3JvdXBlZEVudHJpZXMgPSB0aGlzLl9lbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgICAgbGV0IHtuYW1lLCBjYWxsYmFja30gPSBlbnRyeS51cGxvYWRlcihsaXZlU29ja2V0LnVwbG9hZGVycylcbiAgICAgIGFjY1tuYW1lXSA9IGFjY1tuYW1lXSB8fCB7Y2FsbGJhY2s6IGNhbGxiYWNrLCBlbnRyaWVzOiBbXX1cbiAgICAgIGFjY1tuYW1lXS5lbnRyaWVzLnB1c2goZW50cnkpXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwge30pXG5cbiAgICBmb3IobGV0IG5hbWUgaW4gZ3JvdXBlZEVudHJpZXMpe1xuICAgICAgbGV0IHtjYWxsYmFjaywgZW50cmllc30gPSBncm91cGVkRW50cmllc1tuYW1lXVxuICAgICAgY2FsbGJhY2soZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldClcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfQUNUSVZFX0VOVFJZX1JFRlMsXG4gIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5cbmxldCBIb29rcyA9IHtcbiAgTGl2ZUZpbGVVcGxvYWQ6IHtcbiAgICBhY3RpdmVSZWZzKCl7IHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpIH0sXG5cbiAgICBwcmVmbGlnaHRlZFJlZnMoKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKSB9LFxuXG4gICAgbW91bnRlZCgpeyB0aGlzLnByZWZsaWdodGVkV2FzID0gdGhpcy5wcmVmbGlnaHRlZFJlZnMoKSB9LFxuXG4gICAgdXBkYXRlZCgpe1xuICAgICAgbGV0IG5ld1ByZWZsaWdodHMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpXG4gICAgICBpZih0aGlzLnByZWZsaWdodGVkV2FzICE9PSBuZXdQcmVmbGlnaHRzKXtcbiAgICAgICAgdGhpcy5wcmVmbGlnaHRlZFdhcyA9IG5ld1ByZWZsaWdodHNcbiAgICAgICAgaWYobmV3UHJlZmxpZ2h0cyA9PT0gXCJcIil7XG4gICAgICAgICAgdGhpcy5fX3ZpZXcuY2FuY2VsU3VibWl0KHRoaXMuZWwuZm9ybSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZih0aGlzLmFjdGl2ZVJlZnMoKSA9PT0gXCJcIil7IHRoaXMuZWwudmFsdWUgPSBudWxsIH1cbiAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoUEhYX0xJVkVfRklMRV9VUERBVEVEKSlcbiAgICB9XG4gIH0sXG5cbiAgTGl2ZUltZ1ByZXZpZXc6IHtcbiAgICBtb3VudGVkKCl7XG4gICAgICB0aGlzLnJlZiA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZW50cnktcmVmXCIpXG4gICAgICB0aGlzLmlucHV0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRikpXG4gICAgICBMaXZlVXBsb2FkZXIuZ2V0RW50cnlEYXRhVVJMKHRoaXMuaW5wdXRFbCwgdGhpcy5yZWYsIHVybCA9PiB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsXG4gICAgICAgIHRoaXMuZWwuc3JjID0gdXJsXG4gICAgICB9KVxuICAgIH0sXG4gICAgZGVzdHJveWVkKCl7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMudXJsKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBIb29rc1xuIiwgImltcG9ydCB7XG4gIG1heWJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01Qb3N0TW9ycGhSZXN0b3JlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lckJlZm9yZSwgY29udGFpbmVyQWZ0ZXIsIHVwZGF0ZVR5cGUpe1xuICAgIGxldCBpZHNCZWZvcmUgPSBuZXcgU2V0KClcbiAgICBsZXQgaWRzQWZ0ZXIgPSBuZXcgU2V0KFsuLi5jb250YWluZXJBZnRlci5jaGlsZHJlbl0ubWFwKGNoaWxkID0+IGNoaWxkLmlkKSlcblxuICAgIGxldCBlbGVtZW50c1RvTW9kaWZ5ID0gW11cblxuICAgIEFycmF5LmZyb20oY29udGFpbmVyQmVmb3JlLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmKGNoaWxkLmlkKXsgLy8gYWxsIG9mIG91ciBjaGlsZHJlbiBzaG91bGQgYmUgZWxlbWVudHMgd2l0aCBpZHNcbiAgICAgICAgaWRzQmVmb3JlLmFkZChjaGlsZC5pZClcbiAgICAgICAgaWYoaWRzQWZ0ZXIuaGFzKGNoaWxkLmlkKSl7XG4gICAgICAgICAgbGV0IHByZXZpb3VzRWxlbWVudElkID0gY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkXG4gICAgICAgICAgZWxlbWVudHNUb01vZGlmeS5wdXNoKHtlbGVtZW50SWQ6IGNoaWxkLmlkLCBwcmV2aW91c0VsZW1lbnRJZDogcHJldmlvdXNFbGVtZW50SWR9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuY29udGFpbmVySWQgPSBjb250YWluZXJBZnRlci5pZFxuICAgIHRoaXMudXBkYXRlVHlwZSA9IHVwZGF0ZVR5cGVcbiAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkgPSBlbGVtZW50c1RvTW9kaWZ5XG4gICAgdGhpcy5lbGVtZW50SWRzVG9BZGQgPSBbLi4uaWRzQWZ0ZXJdLmZpbHRlcihpZCA9PiAhaWRzQmVmb3JlLmhhcyhpZCkpXG4gIH1cblxuICAvLyBXZSBkbyB0aGUgZm9sbG93aW5nIHRvIG9wdGltaXplIGFwcGVuZC9wcmVwZW5kIG9wZXJhdGlvbnM6XG4gIC8vICAgMSkgVHJhY2sgaWRzIG9mIG1vZGlmaWVkIGVsZW1lbnRzICYgb2YgbmV3IGVsZW1lbnRzXG4gIC8vICAgMikgQWxsIHRoZSBtb2RpZmllZCBlbGVtZW50cyBhcmUgcHV0IGJhY2sgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIERPTSB0cmVlXG4gIC8vICAgICAgYnkgc3RvcmluZyB0aGUgaWQgb2YgdGhlaXIgcHJldmlvdXMgc2libGluZ1xuICAvLyAgIDMpIE5ldyBlbGVtZW50cyBhcmUgZ29pbmcgdG8gYmUgcHV0IGluIHRoZSByaWdodCBwbGFjZSBieSBtb3JwaGRvbSBkdXJpbmcgYXBwZW5kLlxuICAvLyAgICAgIEZvciBwcmVwZW5kLCB3ZSBtb3ZlIHRoZW0gdG8gdGhlIGZpcnN0IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXJcbiAgcGVyZm9ybSgpe1xuICAgIGxldCBjb250YWluZXIgPSBET00uYnlJZCh0aGlzLmNvbnRhaW5lcklkKVxuICAgIHRoaXMuZWxlbWVudHNUb01vZGlmeS5mb3JFYWNoKGVsZW1lbnRUb01vZGlmeSA9PiB7XG4gICAgICBpZihlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpe1xuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpLCBwcmV2aW91c0VsZW0gPT4ge1xuICAgICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCBlbGVtID0+IHtcbiAgICAgICAgICAgIGxldCBpc0luUmlnaHRQbGFjZSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWQgPT0gcHJldmlvdXNFbGVtLmlkXG4gICAgICAgICAgICBpZighaXNJblJpZ2h0UGxhY2Upe1xuICAgICAgICAgICAgICBwcmV2aW91c0VsZW0uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgZWxlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgY29udGFpbmVyXG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCBlbGVtID0+IHtcbiAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT0gbnVsbFxuICAgICAgICAgIGlmKCFpc0luUmlnaHRQbGFjZSl7XG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBlbGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYodGhpcy51cGRhdGVUeXBlID09IFwicHJlcGVuZFwiKXtcbiAgICAgIHRoaXMuZWxlbWVudElkc1RvQWRkLnJldmVyc2UoKS5mb3JFYWNoKGVsZW1JZCA9PiB7XG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1JZCksIGVsZW0gPT4gY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSkpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuIiwgInZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbmZ1bmN0aW9uIG1vcnBoQXR0cnMoZnJvbU5vZGUsIHRvTm9kZSkge1xuICAgIHZhciB0b05vZGVBdHRycyA9IHRvTm9kZS5hdHRyaWJ1dGVzO1xuICAgIHZhciBhdHRyO1xuICAgIHZhciBhdHRyTmFtZTtcbiAgICB2YXIgYXR0ck5hbWVzcGFjZVVSSTtcbiAgICB2YXIgYXR0clZhbHVlO1xuICAgIHZhciBmcm9tVmFsdWU7XG5cbiAgICAvLyBkb2N1bWVudC1mcmFnbWVudHMgZG9udCBoYXZlIGF0dHJpYnV0ZXMgc28gbGV0cyBub3QgZG8gYW55dGhpbmdcbiAgICBpZiAodG9Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IGZyb21Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnRcbiAgICBmb3IgKHZhciBpID0gdG9Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXR0ciA9IHRvTm9kZUF0dHJzW2ldO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgICBhdHRyVmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoZnJvbVZhbHVlICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5wcmVmaXggPT09ICd4bWxucycpe1xuICAgICAgICAgICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTsgLy8gSXQncyBub3QgYWxsb3dlZCB0byBzZXQgYW4gYXR0cmlidXRlIHdpdGggdGhlIFhNTE5TIG5hbWVzcGFjZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGB4bWxuc2AgcHJlZml4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBleHRyYSBhdHRyaWJ1dGVzIGZvdW5kIG9uIHRoZSBvcmlnaW5hbCBET00gZWxlbWVudCB0aGF0XG4gICAgLy8gd2VyZW4ndCBmb3VuZCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgdmFyIGZyb21Ob2RlQXR0cnMgPSBmcm9tTm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgZCA9IGZyb21Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgYXR0ciA9IGZyb21Ob2RlQXR0cnNbZF07XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICBhdHRyTmFtZXNwYWNlVVJJID0gYXR0ci5uYW1lc3BhY2VVUkk7XG5cbiAgICAgICAgaWYgKGF0dHJOYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG5cbiAgICAgICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgcmFuZ2U7IC8vIENyZWF0ZSBhIHJhbmdlIG9iamVjdCBmb3IgZWZmaWNlbnRseSByZW5kZXJpbmcgc3RyaW5ncyB0byBlbGVtZW50cy5cbnZhciBOU19YSFRNTCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcblxudmFyIGRvYyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBkb2N1bWVudDtcbnZhciBIQVNfVEVNUExBVEVfU1VQUE9SVCA9ICEhZG9jICYmICdjb250ZW50JyBpbiBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbnZhciBIQVNfUkFOR0VfU1VQUE9SVCA9ICEhZG9jICYmIGRvYy5jcmVhdGVSYW5nZSAmJiAnY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50JyBpbiBkb2MuY3JlYXRlUmFuZ2UoKTtcblxuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cikge1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShkb2MuYm9keSk7XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50ID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHN0cik7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2JvZHknKTtcbiAgICBmcmFnbWVudC5pbm5lckhUTUwgPSBzdHI7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbi8qKlxuICogVGhpcyBpcyBhYm91dCB0aGUgc2FtZVxuICogdmFyIGh0bWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHN0ciwgJ3RleHQvaHRtbCcpO1xuICogcmV0dXJuIGh0bWwuYm9keS5maXJzdENoaWxkO1xuICpcbiAqIEBtZXRob2QgdG9FbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHRvRWxlbWVudChzdHIpIHtcbiAgICBzdHIgPSBzdHIudHJpbSgpO1xuICAgIGlmIChIQVNfVEVNUExBVEVfU1VQUE9SVCkge1xuICAgICAgLy8gYXZvaWQgcmVzdHJpY3Rpb25zIG9uIGNvbnRlbnQgZm9yIHRoaW5ncyBsaWtlIGA8dHI+PHRoPkhpPC90aD48L3RyPmAgd2hpY2hcbiAgICAgIC8vIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCBkb2Vzbid0IHN1cHBvcnRcbiAgICAgIC8vIDx0ZW1wbGF0ZT4gc3VwcG9ydCBub3QgYXZhaWxhYmxlIGluIElFXG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKTtcbiAgICB9IGVsc2UgaWYgKEhBU19SQU5HRV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tUmFuZ2Uoc3RyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tV3JhcChzdHIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0d28gbm9kZSdzIG5hbWVzIGFyZSB0aGUgc2FtZS5cbiAqXG4gKiBOT1RFOiBXZSBkb24ndCBib3RoZXIgY2hlY2tpbmcgYG5hbWVzcGFjZVVSSWAgYmVjYXVzZSB5b3Ugd2lsbCBuZXZlciBmaW5kIHR3byBIVE1MIGVsZW1lbnRzIHdpdGggdGhlIHNhbWVcbiAqICAgICAgIG5vZGVOYW1lIGFuZCBkaWZmZXJlbnQgbmFtZXNwYWNlIFVSSXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGIgVGhlIHRhcmdldCBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb21wYXJlTm9kZU5hbWVzKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBmcm9tTm9kZU5hbWUgPSBmcm9tRWwubm9kZU5hbWU7XG4gICAgdmFyIHRvTm9kZU5hbWUgPSB0b0VsLm5vZGVOYW1lO1xuICAgIHZhciBmcm9tQ29kZVN0YXJ0LCB0b0NvZGVTdGFydDtcblxuICAgIGlmIChmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnJvbUNvZGVTdGFydCA9IGZyb21Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuICAgIHRvQ29kZVN0YXJ0ID0gdG9Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuXG4gICAgLy8gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgdmlydHVhbCBET00gbm9kZSBvciBTVkcgbm9kZSB0aGVuIHdlIG1heVxuICAgIC8vIG5lZWQgdG8gbm9ybWFsaXplIHRoZSB0YWcgbmFtZSBiZWZvcmUgY29tcGFyaW5nLiBOb3JtYWwgSFRNTCBlbGVtZW50cyB0aGF0IGFyZVxuICAgIC8vIGluIHRoZSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIlxuICAgIC8vIGFyZSBjb252ZXJ0ZWQgdG8gdXBwZXIgY2FzZVxuICAgIGlmIChmcm9tQ29kZVN0YXJ0IDw9IDkwICYmIHRvQ29kZVN0YXJ0ID49IDk3KSB7IC8vIGZyb20gaXMgdXBwZXIgYW5kIHRvIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiBmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKHRvQ29kZVN0YXJ0IDw9IDkwICYmIGZyb21Db2RlU3RhcnQgPj0gOTcpIHsgLy8gdG8gaXMgdXBwZXIgYW5kIGZyb20gaXMgbG93ZXJcbiAgICAgICAgcmV0dXJuIHRvTm9kZU5hbWUgPT09IGZyb21Ob2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVsZW1lbnQsIG9wdGlvbmFsbHkgd2l0aCBhIGtub3duIG5hbWVzcGFjZSBVUkkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGVsZW1lbnQgbmFtZSwgZS5nLiAnZGl2JyBvciAnc3ZnJ1xuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lc3BhY2VVUkldIHRoZSBlbGVtZW50J3MgbmFtZXNwYWNlIFVSSSwgaS5lLiB0aGUgdmFsdWUgb2ZcbiAqIGl0cyBgeG1sbnNgIGF0dHJpYnV0ZSBvciBpdHMgaW5mZXJyZWQgbmFtZXNwYWNlLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lLCBuYW1lc3BhY2VVUkkpIHtcbiAgICByZXR1cm4gIW5hbWVzcGFjZVVSSSB8fCBuYW1lc3BhY2VVUkkgPT09IE5TX1hIVE1MID9cbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSkgOlxuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgbmFtZSk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSBjaGlsZHJlbiBvZiBvbmUgRE9NIGVsZW1lbnQgdG8gYW5vdGhlciBET00gZWxlbWVudFxuICovXG5mdW5jdGlvbiBtb3ZlQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKSB7XG4gICAgdmFyIGN1ckNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgdG9FbC5hcHBlbmRDaGlsZChjdXJDaGlsZCk7XG4gICAgICAgIGN1ckNoaWxkID0gbmV4dENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gdG9FbDtcbn1cblxuZnVuY3Rpb24gc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIG5hbWUpIHtcbiAgICBpZiAoZnJvbUVsW25hbWVdICE9PSB0b0VsW25hbWVdKSB7XG4gICAgICAgIGZyb21FbFtuYW1lXSA9IHRvRWxbbmFtZV07XG4gICAgICAgIGlmIChmcm9tRWxbbmFtZV0pIHtcbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHNwZWNpYWxFbEhhbmRsZXJzID0ge1xuICAgIE9QVElPTjogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZnJvbUVsLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lID09PSAnT1BUR1JPVVAnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBwYXJlbnROYW1lID0gcGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ1NFTEVDVCcgJiYgIXBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21FbC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgJiYgIXRvRWwuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgTVMgRWRnZSBidWcgd2hlcmUgdGhlICdzZWxlY3RlZCcgYXR0cmlidXRlIGNhbiBvbmx5IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZWQgaWYgc2V0IHRvIGEgbm9uLWVtcHR5IHZhbHVlOlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMjA4NzY3OS9cbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byByZXNldCBzZWxlY3QgZWxlbWVudCdzIHNlbGVjdGVkSW5kZXggdG8gLTEsIG90aGVyd2lzZSBzZXR0aW5nXG4gICAgICAgICAgICAgICAgLy8gZnJvbUVsLnNlbGVjdGVkIHVzaW5nIHRoZSBzeW5jQm9vbGVhbkF0dHJQcm9wIGJlbG93IGhhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvcnJlY3Qgc2VsZWN0ZWRJbmRleCB3aWxsIGJlIHNldCBpbiB0aGUgU0VMRUNUIHNwZWNpYWwgaGFuZGxlciBiZWxvdy5cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ3NlbGVjdGVkJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgXCJ2YWx1ZVwiIGF0dHJpYnV0ZSBpcyBzcGVjaWFsIGZvciB0aGUgPGlucHV0PiBlbGVtZW50IHNpbmNlIGl0IHNldHNcbiAgICAgKiB0aGUgaW5pdGlhbCB2YWx1ZS4gQ2hhbmdpbmcgdGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgd2l0aG91dCBjaGFuZ2luZyB0aGVcbiAgICAgKiBcInZhbHVlXCIgcHJvcGVydHkgd2lsbCBoYXZlIG5vIGVmZmVjdCBzaW5jZSBpdCBpcyBvbmx5IHVzZWQgdG8gdGhlIHNldCB0aGVcbiAgICAgKiBpbml0aWFsIHZhbHVlLiAgU2ltaWxhciBmb3IgdGhlIFwiY2hlY2tlZFwiIGF0dHJpYnV0ZSwgYW5kIFwiZGlzYWJsZWRcIi5cbiAgICAgKi9cbiAgICBJTlBVVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnY2hlY2tlZCcpO1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2Rpc2FibGVkJyk7XG5cbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gdG9FbC52YWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgVEVYVEFSRUE6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgLy8gTmVlZGVkIGZvciBJRS4gQXBwYXJlbnRseSBJRSBzZXRzIHRoZSBwbGFjZWhvbGRlciBhcyB0aGVcbiAgICAgICAgICAgIC8vIG5vZGUgdmFsdWUgYW5kIHZpc2UgdmVyc2EuIFRoaXMgaWdub3JlcyBhbiBlbXB0eSB1cGRhdGUuXG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBmaXJzdENoaWxkLm5vZGVWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlID09IG5ld1ZhbHVlIHx8ICghbmV3VmFsdWUgJiYgb2xkVmFsdWUgPT0gZnJvbUVsLnBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgU0VMRUNUOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgaWYgKCF0b0VsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbG9vcCB0aHJvdWdoIGNoaWxkcmVuIG9mIGZyb21FbCwgbm90IHRvRWwgc2luY2Ugbm9kZXMgY2FuIGJlIG1vdmVkXG4gICAgICAgICAgICAvLyBmcm9tIHRvRWwgdG8gZnJvbUVsIGRpcmVjdGx5IHdoZW4gbW9ycGhpbmcuXG4gICAgICAgICAgICAvLyBBdCB0aGUgdGltZSB0aGlzIHNwZWNpYWwgaGFuZGxlciBpcyBpbnZva2VkLCBhbGwgY2hpbGRyZW4gaGF2ZSBhbHJlYWR5IGJlZW4gbW9ycGhlZFxuICAgICAgICAgICAgLy8gYW5kIGFwcGVuZGVkIHRvIC8gcmVtb3ZlZCBmcm9tIGZyb21FbCwgc28gdXNpbmcgZnJvbUVsIGhlcmUgaXMgc2FmZSBhbmQgY29ycmVjdC5cbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdmFyIG9wdGdyb3VwO1xuICAgICAgICAgICAgdmFyIG5vZGVOYW1lO1xuICAgICAgICAgICAgd2hpbGUoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBub2RlTmFtZSA9IGN1ckNoaWxkLm5vZGVOYW1lICYmIGN1ckNoaWxkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUR1JPVVAnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gY3VyQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdPUFRJT04nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJDaGlsZCAmJiBvcHRncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBvcHRncm91cC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbUVsLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxID0gMTE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZGVmYXVsdEdldE5vZGVLZXkobm9kZSkge1xuICBpZiAobm9kZSkge1xuICAgICAgcmV0dXJuIChub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSkgfHwgbm9kZS5pZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3JwaGRvbUZhY3RvcnkobW9ycGhBdHRycykge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1vcnBoZG9tKGZyb21Ob2RlLCB0b05vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRvTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCcgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09ICdIVE1MJyB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvTm9kZUh0bWwgPSB0b05vZGU7XG4gICAgICAgICAgICAgICAgdG9Ob2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICAgICAgICAgICAgICB0b05vZGUuaW5uZXJIVE1MID0gdG9Ob2RlSHRtbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9Ob2RlID0gdG9FbGVtZW50KHRvTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0Tm9kZUtleSA9IG9wdGlvbnMuZ2V0Tm9kZUtleSB8fCBkZWZhdWx0R2V0Tm9kZUtleTtcbiAgICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25Ob2RlQWRkZWQgPSBvcHRpb25zLm9uTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkJlZm9yZUVsVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uRWxVcGRhdGVkID0gb3B0aW9ucy5vbkVsVXBkYXRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVOb2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25Ob2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBjaGlsZHJlbk9ubHkgPSBvcHRpb25zLmNoaWxkcmVuT25seSA9PT0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIG9iamVjdCBpcyB1c2VkIGFzIGEgbG9va3VwIHRvIHF1aWNrbHkgZmluZCBhbGwga2V5ZWQgZWxlbWVudHMgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLlxuICAgICAgICB2YXIgZnJvbU5vZGVzTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdmFyIGtleWVkUmVtb3ZhbExpc3QgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBhZGRLZXllZFJlbW92YWwoa2V5KSB7XG4gICAgICAgICAgICBrZXllZFJlbW92YWxMaXN0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBLZXllZE5vZGVzICYmIChrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBza2lwcGluZyBrZXllZCBub2RlcyB0aGVuIHdlIGFkZCB0aGUga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhIGxpc3Qgc28gdGhhdCBpdCBjYW4gYmUgaGFuZGxlZCBhdCB0aGUgdmVyeSBlbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVwb3J0IHRoZSBub2RlIGFzIGRpc2NhcmRlZCBpZiBpdCBpcyBub3Qga2V5ZWQuIFdlIGRvIHRoaXMgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXQgdGhlIGVuZCB3ZSBsb29wIHRocm91Z2ggYWxsIGtleWVkIGVsZW1lbnRzIHRoYXQgd2VyZSB1bm1hdGNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVuIGRpc2NhcmQgdGhlbSBpbiBvbmUgZmluYWwgcGFzcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKGN1ckNoaWxkLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgRE9NIG5vZGUgb3V0IG9mIHRoZSBvcmlnaW5hbCBET01cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAgICAgICAgICogQHBhcmFtICB7Tm9kZX0gcGFyZW50Tm9kZSBUaGUgbm9kZXMgcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHNraXBLZXllZE5vZGVzIElmIHRydWUgdGhlbiBlbGVtZW50cyB3aXRoIGtleXMgd2lsbCBiZSBza2lwcGVkIGFuZCBub3QgZGlzY2FyZGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUsIHBhcmVudE5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlRGlzY2FyZGVkKG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQobm9kZSk7XG4gICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAvLyBUcmVlV2Fsa2VyIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAvLyBmdW5jdGlvbiBpbmRleFRyZWUocm9vdCkge1xuICAgICAgICAvLyAgICAgdmFyIHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgICAvLyAgICAgICAgIHJvb3QsXG4gICAgICAgIC8vICAgICAgICAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgdmFyIGVsO1xuICAgICAgICAvLyAgICAgd2hpbGUoKGVsID0gdHJlZVdhbGtlci5uZXh0Tm9kZSgpKSkge1xuICAgICAgICAvLyAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGVsKTtcbiAgICAgICAgLy8gICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gZWw7XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gLy8gTm9kZUl0ZXJhdG9yIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAvL1xuICAgICAgICAvLyBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgICAvLyAgICAgdmFyIG5vZGVJdGVyYXRvciA9IGRvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcihub2RlLCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgICAgIC8vICAgICB2YXIgZWw7XG4gICAgICAgIC8vICAgICB3aGlsZSgoZWwgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2FsayByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgICAgICBpbmRleFRyZWUoY3VyQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXhUcmVlKGZyb21Ob2RlKTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVOb2RlQWRkZWQoZWwpIHtcbiAgICAgICAgICAgIG9uTm9kZUFkZGVkKGVsKTtcblxuICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVubWF0Y2hlZEZyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIGEgZHVwbGljYXRlICNpZCBub2RlIGluIGNhY2hlLCByZXBsYWNlIGBlbGAgd2l0aCBjYWNoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbW9ycGggaXQgdG8gdGhlIGNoaWxkIG5vZGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1bm1hdGNoZWRGcm9tRWwgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJDaGlsZCwgdW5tYXRjaGVkRnJvbUVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgY2FsbCBmb3IgY3VyQ2hpbGQgYW5kIGl0J3MgY2hpbGRyZW4gdG8gc2VlIGlmIHdlIGZpbmQgc29tZXRoaW5nIGluXG4gICAgICAgICAgICAgICAgICAvLyBmcm9tTm9kZXNMb29rdXBcbiAgICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBuZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG9mIHRoZSBcInRvIG5vZGVzXCIuIElmIGN1ckZyb21Ob2RlQ2hpbGQgaXNcbiAgICAgICAgICAgIC8vIG5vbi1udWxsIHRoZW4gd2Ugc3RpbGwgaGF2ZSBzb21lIGZyb20gbm9kZXMgbGVmdCBvdmVyIHRoYXQgbmVlZFxuICAgICAgICAgICAgLy8gdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAoKGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3JwaEVsKGZyb21FbCwgdG9FbCwgY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICB2YXIgdG9FbEtleSA9IGdldE5vZGVLZXkodG9FbCk7XG5cbiAgICAgICAgICAgIGlmICh0b0VsS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gZWxlbWVudCB3aXRoIGFuIElEIGlzIGJlaW5nIG1vcnBoZWQgdGhlbiBpdCB3aWxsIGJlIGluIHRoZSBmaW5hbFxuICAgICAgICAgICAgICAgIC8vIERPTSBzbyBjbGVhciBpdCBvdXQgb2YgdGhlIHNhdmVkIGVsZW1lbnRzIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBkZWxldGUgZnJvbU5vZGVzTG9va3VwW3RvRWxLZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuT25seSkge1xuICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlRWxVcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYXR0cmlidXRlcyBvbiBvcmlnaW5hbCBET00gZWxlbWVudCBmaXJzdFxuICAgICAgICAgICAgICAgIG1vcnBoQXR0cnMoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICAgICAgICAgIG9uRWxVcGRhdGVkKGZyb21FbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZChmcm9tRWwsIHRvRWwpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZnJvbUVsLm5vZGVOYW1lICE9PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgICAgIG1vcnBoQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNwZWNpYWxFbEhhbmRsZXJzLlRFWFRBUkVBKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgICAgICAgICAgdmFyIGN1clRvTm9kZUNoaWxkID0gdG9FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBjdXJUb05vZGVLZXk7XG4gICAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVLZXk7XG5cbiAgICAgICAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB2YXIgdG9OZXh0U2libGluZztcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ0Zyb21FbDtcblxuICAgICAgICAgICAgLy8gd2FsayB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIG91dGVyOiB3aGlsZSAoY3VyVG9Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0b05leHRTaWJsaW5nID0gY3VyVG9Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY3VyVG9Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJUb05vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAvLyB3YWxrIHRoZSBmcm9tTm9kZSBjaGlsZHJlbiBhbGwgdGhlIHdheSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZSAmJiBjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlVHlwZSA9IGN1ckZyb21Ob2RlQ2hpbGQubm9kZVR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtZWFucyBpZiB0aGUgY3VyRnJvbU5vZGVDaGlsZCBkb2VzbnQgaGF2ZSBhIG1hdGNoIHdpdGggdGhlIGN1clRvTm9kZUNoaWxkXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0NvbXBhdGlibGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIEVsZW1lbnQgbm9kZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBub2RlIGhhcyBhIGtleSBzbyB3ZSB3YW50IHRvIG1hdGNoIGl0IHVwIHdpdGggdGhlIGNvcnJlY3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSAhPT0gY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlIGRvZXMgbm90IGhhdmUgYSBtYXRjaGluZyBrZXkgc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGNoZWNrIG91ciBsb29rdXAgdG8gc2VlIGlmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21OZXh0U2libGluZyA9PT0gbWF0Y2hpbmdGcm9tRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBzaW5nbGUgZWxlbWVudCByZW1vdmFscy4gVG8gYXZvaWQgcmVtb3ZpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERPTSBub2RlIG91dCBvZiB0aGUgdHJlZSAoc2luY2UgdGhhdCBjYW4gYnJlYWsgQ1NTIHRyYW5zaXRpb25zLCBldGMuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBpbnN0ZWFkIGRpc2NhcmQgdGhlIGN1cnJlbnQgbm9kZSBhbmQgd2FpdCB1bnRpbCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24gdG8gcHJvcGVybHkgbWF0Y2ggdXAgdGhlIGtleWVkIHRhcmdldCBlbGVtZW50IHdpdGggaXRzIG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBtYXRjaGluZyBrZXllZCBlbGVtZW50IHNvbWV3aGVyZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIG1vdmUgdGhlIG9yaWdpbmFsIERPTSBub2RlIGludG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIG1vcnBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIHVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiByZXBsYWNlQ2hpbGQgYmVjYXVzZSB3ZSB3YW50IHRvIGdvIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGByZW1vdmVOb2RlKClgIGZ1bmN0aW9uIGZvciB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRpc2NhcmRlZCBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBsaWZlY3ljbGUgaG9va3MgYXJlIGNvcnJlY3RseSBpbnZva2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5pbnNlcnRCZWZvcmUobWF0Y2hpbmdGcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBtYXRjaGluZ0Zyb21FbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBub2RlcyBhcmUgbm90IGNvbXBhdGlibGUgc2luY2UgdGhlIFwidG9cIiBub2RlIGhhcyBhIGtleSBhbmQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBubyBtYXRjaGluZyBrZXllZCBub2RlIGluIHRoZSBzb3VyY2UgdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgaGFzIGEga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGlzQ29tcGF0aWJsZSAhPT0gZmFsc2UgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBjb21wYXRpYmxlIERPTSBlbGVtZW50cyBzbyB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgXCJmcm9tXCIgbm9kZSB0byBtYXRjaCB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgRE9NIG5vZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1PUlBIXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoRWwoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBjdXJGcm9tTm9kZVR5cGUgPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQm90aCBub2RlcyBiZWluZyBjb21wYXJlZCBhcmUgVGV4dCBvciBDb21tZW50IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbHkgdXBkYXRlIG5vZGVWYWx1ZSBvbiB0aGUgb3JpZ2luYWwgbm9kZSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgdGV4dCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSAhPT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlID0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBib3RoIHRoZSBcInRvXCIgY2hpbGQgYW5kIHRoZSBcImZyb21cIiBjaGlsZCBzaW5jZSB3ZSBmb3VuZCBhIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGVsc2UgdG8gZG8gYXMgd2UgYWxyZWFkeSByZWN1cnNpdmVseSBjYWxsZWQgbW9ycGhDaGlsZHJlbiBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY29tcGF0aWJsZSBtYXRjaCBzbyByZW1vdmUgdGhlIG9sZCBub2RlIGZyb20gdGhlIERPTSBhbmQgY29udGludWUgdHJ5aW5nIHRvIGZpbmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCBpbiB0aGUgb3JpZ2luYWwgRE9NLiBIb3dldmVyLCB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIGZyb20gbm9kZSBpcyBub3Qga2V5ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXQgaXMgcG9zc2libGUgdGhhdCBhIGtleWVkIG5vZGUgbWlnaHQgbWF0Y2ggdXAgd2l0aCBhIG5vZGUgc29tZXdoZXJlIGVsc2UgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhcmdldCB0cmVlIGFuZCB3ZSBkb24ndCB3YW50IHRvIGRpc2NhcmQgaXQganVzdCB5ZXQgc2luY2UgaXQgc3RpbGwgbWlnaHQgZmluZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGhvbWUgaW4gdGhlIGZpbmFsIERPTSB0cmVlLiBBZnRlciBldmVyeXRoaW5nIGlzIGRvbmUgd2Ugd2lsbCByZW1vdmUgYW55IGtleWVkIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgZGlkbid0IGZpbmQgYSBob21lXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH0gLy8gRU5EOiB3aGlsZShjdXJGcm9tTm9kZUNoaWxkKSB7fVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHRoZW4gd2UgZGlkIG5vdCBmaW5kIGEgY2FuZGlkYXRlIG1hdGNoIGZvclxuICAgICAgICAgICAgICAgIC8vIG91ciBcInRvIG5vZGVcIiBhbmQgd2UgZXhoYXVzdGVkIGFsbCBvZiB0aGUgY2hpbGRyZW4gXCJmcm9tXCJcbiAgICAgICAgICAgICAgICAvLyBub2Rlcy4gVGhlcmVmb3JlLCB3ZSB3aWxsIGp1c3QgYXBwZW5kIHRoZSBjdXJyZW50IFwidG9cIiBub2RlXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIGVuZFxuICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgJiYgKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pICYmIGNvbXBhcmVOb2RlTmFtZXMobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tRWwuYXBwZW5kQ2hpbGQobWF0Y2hpbmdGcm9tRWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBNT1JQSFxuICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ID0gb25CZWZvcmVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBjdXJUb05vZGVDaGlsZC5hY3R1YWxpemUoZnJvbUVsLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5hcHBlbmRDaGlsZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSk7XG5cbiAgICAgICAgICAgIHZhciBzcGVjaWFsRWxIYW5kbGVyID0gc3BlY2lhbEVsSGFuZGxlcnNbZnJvbUVsLm5vZGVOYW1lXTtcbiAgICAgICAgICAgIGlmIChzcGVjaWFsRWxIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbEVsSGFuZGxlcihmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIEVORDogbW9ycGhDaGlsZHJlbiguLi4pXG5cbiAgICAgICAgdmFyIG1vcnBoZWROb2RlID0gZnJvbU5vZGU7XG4gICAgICAgIHZhciBtb3JwaGVkTm9kZVR5cGUgPSBtb3JwaGVkTm9kZS5ub2RlVHlwZTtcbiAgICAgICAgdmFyIHRvTm9kZVR5cGUgPSB0b05vZGUubm9kZVR5cGU7XG5cbiAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBhcmUgZ2l2ZW4gdHdvIERPTSBub2RlcyB0aGF0IGFyZSBub3RcbiAgICAgICAgICAgIC8vIGNvbXBhdGlibGUgKGUuZy4gPGRpdj4gLS0+IDxzcGFuPiBvciA8ZGl2PiAtLT4gVEVYVClcbiAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIGlmICh0b05vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlTm9kZU5hbWVzKGZyb21Ob2RlLCB0b05vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3ZlQ2hpbGRyZW4oZnJvbU5vZGUsIGNyZWF0ZUVsZW1lbnROUyh0b05vZGUubm9kZU5hbWUsIHRvTm9kZS5uYW1lc3BhY2VVUkkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdvaW5nIGZyb20gYW4gZWxlbWVudCBub2RlIHRvIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBURVhUX05PREUgfHwgbW9ycGhlZE5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHsgLy8gVGV4dCBvciBjb21tZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gbW9ycGhlZE5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZS5ub2RlVmFsdWUgIT09IHRvTm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlLm5vZGVWYWx1ZSA9IHRvTm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGV4dCBub2RlIHRvIHNvbWV0aGluZyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3JwaGVkTm9kZSA9PT0gdG9Ob2RlKSB7XG4gICAgICAgICAgICAvLyBUaGUgXCJ0byBub2RlXCIgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIFwiZnJvbSBub2RlXCIgc28gd2UgaGFkIHRvXG4gICAgICAgICAgICAvLyB0b3NzIG91dCB0aGUgXCJmcm9tIG5vZGVcIiBhbmQgdXNlIHRoZSBcInRvIG5vZGVcIlxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b05vZGUuaXNTYW1lTm9kZSAmJiB0b05vZGUuaXNTYW1lTm9kZShtb3JwaGVkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vcnBoRWwobW9ycGhlZE5vZGUsIHRvTm9kZSwgY2hpbGRyZW5Pbmx5KTtcblxuICAgICAgICAgICAgLy8gV2Ugbm93IG5lZWQgdG8gbG9vcCBvdmVyIGFueSBrZXllZCBub2RlcyB0aGF0IG1pZ2h0IG5lZWQgdG8gYmVcbiAgICAgICAgICAgIC8vIHJlbW92ZWQuIFdlIG9ubHkgZG8gdGhlIHJlbW92YWwgaWYgd2Uga25vdyB0aGF0IHRoZSBrZXllZCBub2RlXG4gICAgICAgICAgICAvLyBuZXZlciBmb3VuZCBhIG1hdGNoLiBXaGVuIGEga2V5ZWQgbm9kZSBpcyBtYXRjaGVkIHVwIHdlIHJlbW92ZVxuICAgICAgICAgICAgLy8gaXQgb3V0IG9mIGZyb21Ob2Rlc0xvb2t1cCBhbmQgd2UgdXNlIGZyb21Ob2Rlc0xvb2t1cCB0byBkZXRlcm1pbmVcbiAgICAgICAgICAgIC8vIGlmIGEga2V5ZWQgbm9kZSBoYXMgYmVlbiBtYXRjaGVkIHVwIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGtleWVkUmVtb3ZhbExpc3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1rZXllZFJlbW92YWxMaXN0Lmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxUb1JlbW92ZSA9IGZyb21Ob2Rlc0xvb2t1cFtrZXllZFJlbW92YWxMaXN0W2ldXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsVG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoZWxUb1JlbW92ZSwgZWxUb1JlbW92ZS5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoaWxkcmVuT25seSAmJiBtb3JwaGVkTm9kZSAhPT0gZnJvbU5vZGUgJiYgZnJvbU5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKG1vcnBoZWROb2RlLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW9ycGhlZE5vZGUuYWN0dWFsaXplKGZyb21Ob2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhZCB0byBzd2FwIG91dCB0aGUgZnJvbSBub2RlIHdpdGggYSBuZXcgbm9kZSBiZWNhdXNlIHRoZSBvbGRcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIHRhcmdldCBub2RlIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgb2xkIERPTSBub2RlIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS4gVGhpcyBpcyBvbmx5XG4gICAgICAgICAgICAvLyBwb3NzaWJsZSBpZiB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgd2FzIHBhcnQgb2YgYSBET00gdHJlZSB3aGljaFxuICAgICAgICAgICAgLy8gd2Uga25vdyBpcyB0aGUgY2FzZSBpZiBpdCBoYXMgYSBwYXJlbnQgbm9kZS5cbiAgICAgICAgICAgIGZyb21Ob2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG1vcnBoZWROb2RlLCBmcm9tTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgfTtcbn1cblxudmFyIG1vcnBoZG9tID0gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpO1xuXG5leHBvcnQgZGVmYXVsdCBtb3JwaGRvbTtcbiIsICJpbXBvcnQge1xuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfRElTQUJMRV9XSVRILFxuICBQSFhfRkVFREJBQ0tfRk9SLFxuICBQSFhfUFJVTkUsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX1NLSVAsXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9UUklHR0VSX0FDVElPTixcbiAgUEhYX1VQREFURVxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBkZXRlY3REdXBsaWNhdGVJZHMsXG4gIGlzQ2lkXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IERPTVBvc3RNb3JwaFJlc3RvcmVyIGZyb20gXCIuL2RvbV9wb3N0X21vcnBoX3Jlc3RvcmVyXCJcbmltcG9ydCBtb3JwaGRvbSBmcm9tIFwibW9ycGhkb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01QYXRjaCB7XG4gIHN0YXRpYyBwYXRjaEVsKGZyb21FbCwgdG9FbCwgYWN0aXZlRWxlbWVudCl7XG4gICAgbW9ycGhkb20oZnJvbUVsLCB0b0VsLCB7XG4gICAgICBjaGlsZHJlbk9ubHk6IGZhbHNlLFxuICAgICAgb25CZWZvcmVFbFVwZGF0ZWQ6IChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgICAgaWYoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LmlzU2FtZU5vZGUoZnJvbUVsKSAmJiBET00uaXNGb3JtSW5wdXQoZnJvbUVsKSl7XG4gICAgICAgICAgRE9NLm1lcmdlRm9jdXNlZElucHV0KGZyb21FbCwgdG9FbClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjb25zdHJ1Y3Rvcih2aWV3LCBjb250YWluZXIsIGlkLCBodG1sLCB0YXJnZXRDSUQpe1xuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgICB0aGlzLmxpdmVTb2NrZXQgPSB2aWV3LmxpdmVTb2NrZXRcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lclxuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMucm9vdElEID0gdmlldy5yb290LmlkXG4gICAgdGhpcy5odG1sID0gaHRtbFxuICAgIHRoaXMudGFyZ2V0Q0lEID0gdGFyZ2V0Q0lEXG4gICAgdGhpcy5jaWRQYXRjaCA9IGlzQ2lkKHRoaXMudGFyZ2V0Q0lEKVxuICAgIHRoaXMuY2FsbGJhY2tzID0ge1xuICAgICAgYmVmb3JlYWRkZWQ6IFtdLCBiZWZvcmV1cGRhdGVkOiBbXSwgYmVmb3JlcGh4Q2hpbGRBZGRlZDogW10sXG4gICAgICBhZnRlcmFkZGVkOiBbXSwgYWZ0ZXJ1cGRhdGVkOiBbXSwgYWZ0ZXJkaXNjYXJkZWQ6IFtdLCBhZnRlcnBoeENoaWxkQWRkZWQ6IFtdLFxuICAgICAgYWZ0ZXJ0cmFuc2l0aW9uc0Rpc2NhcmRlZDogW11cbiAgICB9XG4gIH1cblxuICBiZWZvcmUoa2luZCwgY2FsbGJhY2speyB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLnB1c2goY2FsbGJhY2spIH1cbiAgYWZ0ZXIoa2luZCwgY2FsbGJhY2speyB0aGlzLmNhbGxiYWNrc1tgYWZ0ZXIke2tpbmR9YF0ucHVzaChjYWxsYmFjaykgfVxuXG4gIHRyYWNrQmVmb3JlKGtpbmQsIC4uLmFyZ3Mpe1xuICAgIHRoaXMuY2FsbGJhY2tzW2BiZWZvcmUke2tpbmR9YF0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayguLi5hcmdzKSlcbiAgfVxuXG4gIHRyYWNrQWZ0ZXIoa2luZCwgLi4uYXJncyl7XG4gICAgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soLi4uYXJncykpXG4gIH1cblxuICBtYXJrUHJ1bmFibGVDb250ZW50Rm9yUmVtb3ZhbCgpe1xuICAgIERPTS5hbGwodGhpcy5jb250YWluZXIsIFwiW3BoeC11cGRhdGU9YXBwZW5kXSA+ICosIFtwaHgtdXBkYXRlPXByZXBlbmRdID4gKlwiLCBlbCA9PiB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1BSVU5FLCBcIlwiKVxuICAgIH0pXG4gIH1cblxuICBwZXJmb3JtKCl7XG4gICAgbGV0IHt2aWV3LCBsaXZlU29ja2V0LCBjb250YWluZXIsIGh0bWx9ID0gdGhpc1xuICAgIGxldCB0YXJnZXRDb250YWluZXIgPSB0aGlzLmlzQ0lEUGF0Y2goKSA/IHRoaXMudGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpIDogY29udGFpbmVyXG4gICAgaWYodGhpcy5pc0NJRFBhdGNoKCkgJiYgIXRhcmdldENvbnRhaW5lcil7IHJldHVybiB9XG5cbiAgICBsZXQgZm9jdXNlZCA9IGxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpXG4gICAgbGV0IHtzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kfSA9IGZvY3VzZWQgJiYgRE9NLmhhc1NlbGVjdGlvblJhbmdlKGZvY3VzZWQpID8gZm9jdXNlZCA6IHt9XG4gICAgbGV0IHBoeFVwZGF0ZSA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVVBEQVRFKVxuICAgIGxldCBwaHhGZWVkYmFja0ZvciA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKVxuICAgIGxldCBkaXNhYmxlV2l0aCA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKVxuICAgIGxldCBwaHhUcmlnZ2VyRXh0ZXJuYWwgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1RSSUdHRVJfQUNUSU9OKVxuICAgIGxldCBwaHhSZW1vdmUgPSBsaXZlU29ja2V0LmJpbmRpbmcoXCJyZW1vdmVcIilcbiAgICBsZXQgYWRkZWQgPSBbXVxuICAgIGxldCB1cGRhdGVzID0gW11cbiAgICBsZXQgYXBwZW5kUHJlcGVuZFVwZGF0ZXMgPSBbXVxuICAgIGxldCBwZW5kaW5nUmVtb3ZlcyA9IFtdXG4gICAgbGV0IGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IG51bGxcblxuICAgIGxldCBkaWZmSFRNTCA9IGxpdmVTb2NrZXQudGltZShcInByZW1vcnBoIGNvbnRhaW5lciBwcmVwXCIsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmJ1aWxkRGlmZkhUTUwoY29udGFpbmVyLCBodG1sLCBwaHhVcGRhdGUsIHRhcmdldENvbnRhaW5lcilcbiAgICB9KVxuXG4gICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGNvbnRhaW5lcilcbiAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBjb250YWluZXIsIGNvbnRhaW5lcilcblxuICAgIGxpdmVTb2NrZXQudGltZShcIm1vcnBoZG9tXCIsICgpID0+IHtcbiAgICAgIG1vcnBoZG9tKHRhcmdldENvbnRhaW5lciwgZGlmZkhUTUwsIHtcbiAgICAgICAgY2hpbGRyZW5Pbmx5OiB0YXJnZXRDb250YWluZXIuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpID09PSBudWxsLFxuICAgICAgICBnZXROb2RlS2V5OiAobm9kZSkgPT4ge1xuICAgICAgICAgIHJldHVybiBET00uaXNQaHhEZXN0cm95ZWQobm9kZSkgPyBudWxsIDogbm9kZS5pZFxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZU5vZGVBZGRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGVsKVxuICAgICAgICAgIHJldHVybiBlbFxuICAgICAgICB9LFxuICAgICAgICBvbk5vZGVBZGRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgLy8gaGFjayB0byBmaXggU2FmYXJpIGhhbmRsaW5nIG9mIGltZyBzcmNzZXQgYW5kIHZpZGVvIHRhZ3NcbiAgICAgICAgICBpZihlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgZWwuc3Jjc2V0KXtcbiAgICAgICAgICAgIGVsLnNyY3NldCA9IGVsLnNyY3NldFxuICAgICAgICAgIH0gZWxzZSBpZihlbCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgJiYgZWwuYXV0b3BsYXkpe1xuICAgICAgICAgICAgZWwucGxheSgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKERPTS5pc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCkpe1xuICAgICAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gZWxcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9pbnB1dCBoYW5kbGluZ1xuICAgICAgICAgIERPTS5kaXNjYXJkRXJyb3IodGFyZ2V0Q29udGFpbmVyLCBlbCwgcGh4RmVlZGJhY2tGb3IpXG4gICAgICAgICAgLy8gbmVzdGVkIHZpZXcgaGFuZGxpbmdcbiAgICAgICAgICBpZigoRE9NLmlzUGh4Q2hpbGQoZWwpICYmIHZpZXcub3duc0VsZW1lbnQoZWwpKSB8fCBET00uaXNQaHhTdGlja3koZWwpICYmIHZpZXcub3duc0VsZW1lbnQoZWwucGFyZW50Tm9kZSkpe1xuICAgICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwicGh4Q2hpbGRBZGRlZFwiLCBlbClcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkZWQucHVzaChlbClcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob2RlRGlzY2FyZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgICAgICAgIGlmKERPTS5pc1BoeENoaWxkKGVsKSB8fCBET00uaXNQaHhTdGlja3koZWwpKXsgbGl2ZVNvY2tldC5kZXN0cm95Vmlld0J5RWwoZWwpIH1cbiAgICAgICAgICB0aGlzLnRyYWNrQWZ0ZXIoXCJkaXNjYXJkZWRcIiwgZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfUFJVTkUpICE9PSBudWxsKXsgcmV0dXJuIHRydWUgfVxuICAgICAgICAgIGlmKGVsLnBhcmVudE5vZGUgIT09IG51bGwgJiYgRE9NLmlzUGh4VXBkYXRlKGVsLnBhcmVudE5vZGUsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkgJiYgZWwuaWQpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUocGh4UmVtb3ZlKSl7XG4gICAgICAgICAgICBwZW5kaW5nUmVtb3Zlcy5wdXNoKGVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRoaXMuc2tpcENJRFNpYmxpbmcoZWwpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBvbkVsVXBkYXRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgaWYoRE9NLmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSl7XG4gICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbFxuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVzLnB1c2goZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICAgICAgRE9NLmNsZWFuQ2hpbGROb2Rlcyh0b0VsLCBwaHhVcGRhdGUpXG4gICAgICAgICAgaWYodGhpcy5za2lwQ0lEU2libGluZyh0b0VsKSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgaWYoRE9NLmlzUGh4U3RpY2t5KGZyb21FbCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKERPTS5pc0lnbm9yZWQoZnJvbUVsLCBwaHhVcGRhdGUpKXtcbiAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbClcbiAgICAgICAgICAgIERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwge2lzSWdub3JlZDogdHJ1ZX0pXG4gICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZnJvbUVsLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgKGZyb21FbC52YWxpZGl0eSAmJiBmcm9tRWwudmFsaWRpdHkuYmFkSW5wdXQpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZighRE9NLnN5bmNQZW5kaW5nUmVmKGZyb21FbCwgdG9FbCwgZGlzYWJsZVdpdGgpKXtcbiAgICAgICAgICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGZyb21FbCkpe1xuICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYoRE9NLmlzUGh4Q2hpbGQodG9FbCkpe1xuICAgICAgICAgICAgbGV0IHByZXZTZXNzaW9uID0gZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTilcbiAgICAgICAgICAgIERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwge2V4Y2x1ZGU6IFtQSFhfU1RBVElDXX0pXG4gICAgICAgICAgICBpZihwcmV2U2Vzc2lvbiAhPT0gXCJcIil7IGZyb21FbC5zZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04sIHByZXZTZXNzaW9uKSB9XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3RJRClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaW5wdXQgaGFuZGxpbmdcbiAgICAgICAgICBET00uY29weVByaXZhdGVzKHRvRWwsIGZyb21FbClcbiAgICAgICAgICBET00uZGlzY2FyZEVycm9yKHRhcmdldENvbnRhaW5lciwgdG9FbCwgcGh4RmVlZGJhY2tGb3IpXG5cbiAgICAgICAgICBsZXQgaXNGb2N1c2VkRm9ybUVsID0gZm9jdXNlZCAmJiBmcm9tRWwuaXNTYW1lTm9kZShmb2N1c2VkKSAmJiBET00uaXNGb3JtSW5wdXQoZnJvbUVsKVxuICAgICAgICAgIGlmKGlzRm9jdXNlZEZvcm1FbCl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VGb2N1c2VkSW5wdXQoZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgRE9NLnN5bmNBdHRyc1RvUHJvcHMoZnJvbUVsKVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKERPTS5pc1BoeFVwZGF0ZSh0b0VsLCBwaHhVcGRhdGUsIFtcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pKXtcbiAgICAgICAgICAgICAgYXBwZW5kUHJlcGVuZFVwZGF0ZXMucHVzaChuZXcgRE9NUG9zdE1vcnBoUmVzdG9yZXIoZnJvbUVsLCB0b0VsLCB0b0VsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIERPTS5zeW5jQXR0cnNUb1Byb3BzKHRvRWwpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKHRvRWwpXG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYobGl2ZVNvY2tldC5pc0RlYnVnRW5hYmxlZCgpKXsgZGV0ZWN0RHVwbGljYXRlSWRzKCkgfVxuXG4gICAgaWYoYXBwZW5kUHJlcGVuZFVwZGF0ZXMubGVuZ3RoID4gMCl7XG4gICAgICBsaXZlU29ja2V0LnRpbWUoXCJwb3N0LW1vcnBoIGFwcGVuZC9wcmVwZW5kIHJlc3RvcmF0aW9uXCIsICgpID0+IHtcbiAgICAgICAgYXBwZW5kUHJlcGVuZFVwZGF0ZXMuZm9yRWFjaCh1cGRhdGUgPT4gdXBkYXRlLnBlcmZvcm0oKSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgbGl2ZVNvY2tldC5zaWxlbmNlRXZlbnRzKCgpID0+IERPTS5yZXN0b3JlRm9jdXMoZm9jdXNlZCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCkpXG4gICAgRE9NLmRpc3BhdGNoRXZlbnQoZG9jdW1lbnQsIFwicGh4OnVwZGF0ZVwiKVxuICAgIGFkZGVkLmZvckVhY2goZWwgPT4gdGhpcy50cmFja0FmdGVyKFwiYWRkZWRcIiwgZWwpKVxuICAgIHVwZGF0ZXMuZm9yRWFjaChlbCA9PiB0aGlzLnRyYWNrQWZ0ZXIoXCJ1cGRhdGVkXCIsIGVsKSlcblxuICAgIGlmKHBlbmRpbmdSZW1vdmVzLmxlbmd0aCA+IDApe1xuICAgICAgbGl2ZVNvY2tldC50cmFuc2l0aW9uUmVtb3ZlcyhwZW5kaW5nUmVtb3ZlcylcbiAgICAgIGxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIHBlbmRpbmdSZW1vdmVzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGxldCBjaGlsZCA9IERPTS5maXJzdFBoeENoaWxkKGVsKVxuICAgICAgICAgIGlmKGNoaWxkKXsgbGl2ZVNvY2tldC5kZXN0cm95Vmlld0J5RWwoY2hpbGQpIH1cbiAgICAgICAgICBlbC5yZW1vdmUoKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnRyYWNrQWZ0ZXIoXCJ0cmFuc2l0aW9uc0Rpc2NhcmRlZFwiLCBwZW5kaW5nUmVtb3ZlcylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkKXtcbiAgICAgIGxpdmVTb2NrZXQuZGlzY29ubmVjdCgpXG4gICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQuc3VibWl0KClcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlzQ0lEUGF0Y2goKXsgcmV0dXJuIHRoaXMuY2lkUGF0Y2ggfVxuXG4gIHNraXBDSURTaWJsaW5nKGVsKXtcbiAgICByZXR1cm4gZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfU0tJUCkgIT09IG51bGxcbiAgfVxuXG4gIHRhcmdldENJRENvbnRhaW5lcihodG1sKXtcbiAgICBpZighdGhpcy5pc0NJRFBhdGNoKCkpeyByZXR1cm4gfVxuICAgIGxldCBbZmlyc3QsIC4uLnJlc3RdID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmNvbnRhaW5lciwgdGhpcy50YXJnZXRDSUQpXG4gICAgaWYocmVzdC5sZW5ndGggPT09IDAgJiYgRE9NLmNoaWxkTm9kZUxlbmd0aChodG1sKSA9PT0gMSl7XG4gICAgICByZXR1cm4gZmlyc3RcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnBhcmVudE5vZGVcbiAgICB9XG4gIH1cblxuICAvLyBidWlsZHMgSFRNTCBmb3IgbW9ycGhkb20gcGF0Y2hcbiAgLy8gLSBmb3IgZnVsbCBwYXRjaGVzIG9mIExpdmVWaWV3IG9yIGEgY29tcG9uZW50IHdpdGggYSBzaW5nbGVcbiAgLy8gICByb290IG5vZGUsIHNpbXBseSByZXR1cm5zIHRoZSBIVE1MXG4gIC8vIC0gZm9yIHBhdGNoZXMgb2YgYSBjb21wb25lbnQgd2l0aCBtdWx0aXBsZSByb290IG5vZGVzLCB0aGVcbiAgLy8gICBwYXJlbnQgbm9kZSBiZWNvbWVzIHRoZSB0YXJnZXQgY29udGFpbmVyIGFuZCBub24tY29tcG9uZW50XG4gIC8vICAgc2libGluZ3MgYXJlIG1hcmtlZCBhcyBza2lwLlxuICBidWlsZERpZmZIVE1MKGNvbnRhaW5lciwgaHRtbCwgcGh4VXBkYXRlLCB0YXJnZXRDb250YWluZXIpe1xuICAgIGxldCBpc0NJRFBhdGNoID0gdGhpcy5pc0NJRFBhdGNoKClcbiAgICBsZXQgaXNDSURXaXRoU2luZ2xlUm9vdCA9IGlzQ0lEUGF0Y2ggJiYgdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gdGhpcy50YXJnZXRDSUQudG9TdHJpbmcoKVxuICAgIGlmKCFpc0NJRFBhdGNoIHx8IGlzQ0lEV2l0aFNpbmdsZVJvb3Qpe1xuICAgICAgcmV0dXJuIGh0bWxcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcG9uZW50IHBhdGNoIHdpdGggbXVsdGlwbGUgQ0lEIHJvb3RzXG4gICAgICBsZXQgZGlmZkNvbnRhaW5lciA9IG51bGxcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgICAgZGlmZkNvbnRhaW5lciA9IERPTS5jbG9uZU5vZGUodGFyZ2V0Q29udGFpbmVyKVxuICAgICAgbGV0IFtmaXJzdENvbXBvbmVudCwgLi4ucmVzdF0gPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KGRpZmZDb250YWluZXIsIHRoaXMudGFyZ2V0Q0lEKVxuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgICAgcmVzdC5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKVxuICAgICAgQXJyYXkuZnJvbShkaWZmQ29udGFpbmVyLmNoaWxkTm9kZXMpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAvLyB3ZSBjYW4gb25seSBza2lwIHRyYWNrYWJsZSBub2RlcyB3aXRoIGFuIElEXG4gICAgICAgIGlmKGNoaWxkLmlkICYmIGNoaWxkLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkgIT09IHRoaXMudGFyZ2V0Q0lELnRvU3RyaW5nKCkpe1xuICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShQSFhfU0tJUCwgXCJcIilcbiAgICAgICAgICBjaGlsZC5pbm5lckhUTUwgPSBcIlwiXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBBcnJheS5mcm9tKHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2RlcykuZm9yRWFjaChlbCA9PiBkaWZmQ29udGFpbmVyLmluc2VydEJlZm9yZShlbCwgZmlyc3RDb21wb25lbnQpKVxuICAgICAgZmlyc3RDb21wb25lbnQucmVtb3ZlKClcbiAgICAgIHJldHVybiBkaWZmQ29udGFpbmVyLm91dGVySFRNTFxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIENPTVBPTkVOVFMsXG4gIERZTkFNSUNTLFxuICBURU1QTEFURVMsXG4gIEVWRU5UUyxcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX1NLSVAsXG4gIFJFUExZLFxuICBTVEFUSUMsXG4gIFRJVExFXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGlzT2JqZWN0LFxuICBsb2dFcnJvcixcbiAgaXNDaWQsXG59IGZyb20gXCIuL3V0aWxzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyZWQge1xuICBzdGF0aWMgZXh0cmFjdChkaWZmKXtcbiAgICBsZXQge1tSRVBMWV06IHJlcGx5LCBbRVZFTlRTXTogZXZlbnRzLCBbVElUTEVdOiB0aXRsZX0gPSBkaWZmXG4gICAgZGVsZXRlIGRpZmZbUkVQTFldXG4gICAgZGVsZXRlIGRpZmZbRVZFTlRTXVxuICAgIGRlbGV0ZSBkaWZmW1RJVExFXVxuICAgIHJldHVybiB7ZGlmZiwgdGl0bGUsIHJlcGx5OiByZXBseSB8fCBudWxsLCBldmVudHM6IGV2ZW50cyB8fCBbXX1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHZpZXdJZCwgcmVuZGVyZWQpe1xuICAgIHRoaXMudmlld0lkID0gdmlld0lkXG4gICAgdGhpcy5yZW5kZXJlZCA9IHt9XG4gICAgdGhpcy5tZXJnZURpZmYocmVuZGVyZWQpXG4gIH1cblxuICBwYXJlbnRWaWV3SWQoKXsgcmV0dXJuIHRoaXMudmlld0lkIH1cblxuICB0b1N0cmluZyhvbmx5Q2lkcyl7XG4gICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlVG9TdHJpbmcodGhpcy5yZW5kZXJlZCwgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSwgb25seUNpZHMpXG4gIH1cblxuICByZWN1cnNpdmVUb1N0cmluZyhyZW5kZXJlZCwgY29tcG9uZW50cyA9IHJlbmRlcmVkW0NPTVBPTkVOVFNdLCBvbmx5Q2lkcyl7XG4gICAgb25seUNpZHMgPSBvbmx5Q2lkcyA/IG5ldyBTZXQob25seUNpZHMpIDogbnVsbFxuICAgIGxldCBvdXRwdXQgPSB7YnVmZmVyOiBcIlwiLCBjb21wb25lbnRzOiBjb21wb25lbnRzLCBvbmx5Q2lkczogb25seUNpZHN9XG4gICAgdGhpcy50b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgbnVsbCwgb3V0cHV0KVxuICAgIHJldHVybiBvdXRwdXQuYnVmZmVyXG4gIH1cblxuICBjb21wb25lbnRDSURzKGRpZmYpeyByZXR1cm4gT2JqZWN0LmtleXMoZGlmZltDT01QT05FTlRTXSB8fCB7fSkubWFwKGkgPT4gcGFyc2VJbnQoaSkpIH1cblxuICBpc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpe1xuICAgIGlmKCFkaWZmW0NPTVBPTkVOVFNdKXsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGlmZikubGVuZ3RoID09PSAxXG4gIH1cblxuICBnZXRDb21wb25lbnQoZGlmZiwgY2lkKXsgcmV0dXJuIGRpZmZbQ09NUE9ORU5UU11bY2lkXSB9XG5cbiAgbWVyZ2VEaWZmKGRpZmYpe1xuICAgIGxldCBuZXdjID0gZGlmZltDT01QT05FTlRTXVxuICAgIGxldCBjYWNoZSA9IHt9XG4gICAgZGVsZXRlIGRpZmZbQ09NUE9ORU5UU11cbiAgICB0aGlzLnJlbmRlcmVkID0gdGhpcy5tdXRhYmxlTWVyZ2UodGhpcy5yZW5kZXJlZCwgZGlmZilcbiAgICB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdID0gdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSB8fCB7fVxuXG4gICAgaWYobmV3Yyl7XG4gICAgICBsZXQgb2xkYyA9IHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU11cblxuICAgICAgZm9yKGxldCBjaWQgaW4gbmV3Yyl7XG4gICAgICAgIG5ld2NbY2lkXSA9IHRoaXMuY2FjaGVkRmluZENvbXBvbmVudChjaWQsIG5ld2NbY2lkXSwgb2xkYywgbmV3YywgY2FjaGUpXG4gICAgICB9XG5cbiAgICAgIGZvcihsZXQgY2lkIGluIG5ld2MpeyBvbGRjW2NpZF0gPSBuZXdjW2NpZF0gfVxuICAgICAgZGlmZltDT01QT05FTlRTXSA9IG5ld2NcbiAgICB9XG4gIH1cblxuICBjYWNoZWRGaW5kQ29tcG9uZW50KGNpZCwgY2RpZmYsIG9sZGMsIG5ld2MsIGNhY2hlKXtcbiAgICBpZihjYWNoZVtjaWRdKXtcbiAgICAgIHJldHVybiBjYWNoZVtjaWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZGlmZiwgc3RhdCwgc2NpZCA9IGNkaWZmW1NUQVRJQ11cblxuICAgICAgaWYoaXNDaWQoc2NpZCkpe1xuICAgICAgICBsZXQgdGRpZmZcblxuICAgICAgICBpZihzY2lkID4gMCl7XG4gICAgICAgICAgdGRpZmYgPSB0aGlzLmNhY2hlZEZpbmRDb21wb25lbnQoc2NpZCwgbmV3Y1tzY2lkXSwgb2xkYywgbmV3YywgY2FjaGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGRpZmYgPSBvbGRjWy1zY2lkXVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdCA9IHRkaWZmW1NUQVRJQ11cbiAgICAgICAgbmRpZmYgPSB0aGlzLmNsb25lTWVyZ2UodGRpZmYsIGNkaWZmKVxuICAgICAgICBuZGlmZltTVEFUSUNdID0gc3RhdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmRpZmYgPSBjZGlmZltTVEFUSUNdICE9PSB1bmRlZmluZWQgPyBjZGlmZiA6IHRoaXMuY2xvbmVNZXJnZShvbGRjW2NpZF0gfHwge30sIGNkaWZmKVxuICAgICAgfVxuXG4gICAgICBjYWNoZVtjaWRdID0gbmRpZmZcbiAgICAgIHJldHVybiBuZGlmZlxuICAgIH1cbiAgfVxuXG4gIG11dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSl7XG4gICAgaWYoc291cmNlW1NUQVRJQ10gIT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gc291cmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2UpXG4gICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfVxuICB9XG5cbiAgZG9NdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2Upe1xuICAgIGZvcihsZXQga2V5IGluIHNvdXJjZSl7XG4gICAgICBsZXQgdmFsID0gc291cmNlW2tleV1cbiAgICAgIGxldCB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XVxuICAgICAgaWYoaXNPYmplY3QodmFsKSAmJiB2YWxbU1RBVElDXSA9PT0gdW5kZWZpbmVkICYmIGlzT2JqZWN0KHRhcmdldFZhbCkpe1xuICAgICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldFZhbCwgdmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbG9uZU1lcmdlKHRhcmdldCwgc291cmNlKXtcbiAgICBsZXQgbWVyZ2VkID0gey4uLnRhcmdldCwgLi4uc291cmNlfVxuICAgIGZvcihsZXQga2V5IGluIG1lcmdlZCl7XG4gICAgICBsZXQgdmFsID0gc291cmNlW2tleV1cbiAgICAgIGxldCB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XVxuICAgICAgaWYoaXNPYmplY3QodmFsKSAmJiB2YWxbU1RBVElDXSA9PT0gdW5kZWZpbmVkICYmIGlzT2JqZWN0KHRhcmdldFZhbCkpe1xuICAgICAgICBtZXJnZWRba2V5XSA9IHRoaXMuY2xvbmVNZXJnZSh0YXJnZXRWYWwsIHZhbClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZFxuICB9XG5cbiAgY29tcG9uZW50VG9TdHJpbmcoY2lkKXsgcmV0dXJuIHRoaXMucmVjdXJzaXZlQ0lEVG9TdHJpbmcodGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSwgY2lkKSB9XG5cbiAgcHJ1bmVDSURzKGNpZHMpe1xuICAgIGNpZHMuZm9yRWFjaChjaWQgPT4gZGVsZXRlIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU11bY2lkXSlcbiAgfVxuXG4gIC8vIHByaXZhdGVcblxuICBnZXQoKXsgcmV0dXJuIHRoaXMucmVuZGVyZWQgfVxuXG4gIGlzTmV3RmluZ2VycHJpbnQoZGlmZiA9IHt9KXsgcmV0dXJuICEhZGlmZltTVEFUSUNdIH1cblxuICB0ZW1wbGF0ZVN0YXRpYyhwYXJ0LCB0ZW1wbGF0ZXMpe1xuICAgIGlmKHR5cGVvZiAocGFydCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZXNbcGFydF1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnRcbiAgICB9XG4gIH1cblxuICB0b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGlmKHJlbmRlcmVkW0RZTkFNSUNTXSl7IHJldHVybiB0aGlzLmNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpIH1cbiAgICBsZXQge1tTVEFUSUNdOiBzdGF0aWNzfSA9IHJlbmRlcmVkXG4gICAgc3RhdGljcyA9IHRoaXMudGVtcGxhdGVTdGF0aWMoc3RhdGljcywgdGVtcGxhdGVzKVxuXG4gICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzWzBdXG4gICAgZm9yKGxldCBpID0gMTsgaSA8IHN0YXRpY3MubGVuZ3RoOyBpKyspe1xuICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIocmVuZGVyZWRbaSAtIDFdLCB0ZW1wbGF0ZXMsIG91dHB1dClcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXVxuICAgIH1cbiAgfVxuXG4gIGNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGxldCB7W0RZTkFNSUNTXTogZHluYW1pY3MsIFtTVEFUSUNdOiBzdGF0aWNzfSA9IHJlbmRlcmVkXG4gICAgc3RhdGljcyA9IHRoaXMudGVtcGxhdGVTdGF0aWMoc3RhdGljcywgdGVtcGxhdGVzKVxuICAgIGxldCBjb21wVGVtcGxhdGVzID0gdGVtcGxhdGVzIHx8IHJlbmRlcmVkW1RFTVBMQVRFU11cblxuICAgIGZvcihsZXQgZCA9IDA7IGQgPCBkeW5hbWljcy5sZW5ndGg7IGQrKyl7XG4gICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNzW2RdXG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF1cbiAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIoZHluYW1pY1tpIC0gMV0sIGNvbXBUZW1wbGF0ZXMsIG91dHB1dClcbiAgICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCl7XG4gICAgaWYodHlwZW9mIChyZW5kZXJlZCkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgb3V0cHV0LmJ1ZmZlciArPSB0aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKG91dHB1dC5jb21wb25lbnRzLCByZW5kZXJlZCwgb3V0cHV0Lm9ubHlDaWRzKVxuICAgIH0gZWxzZSBpZihpc09iamVjdChyZW5kZXJlZCkpe1xuICAgICAgdGhpcy50b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gcmVuZGVyZWRcbiAgICB9XG4gIH1cblxuICByZWN1cnNpdmVDSURUb1N0cmluZyhjb21wb25lbnRzLCBjaWQsIG9ubHlDaWRzKXtcbiAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdIHx8IGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm9yIENJRCAke2NpZH1gLCBjb21wb25lbnRzKVxuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRoaXMucmVjdXJzaXZlVG9TdHJpbmcoY29tcG9uZW50LCBjb21wb25lbnRzLCBvbmx5Q2lkcylcbiAgICBsZXQgY29udGFpbmVyID0gdGVtcGxhdGUuY29udGVudFxuICAgIGxldCBza2lwID0gb25seUNpZHMgJiYgIW9ubHlDaWRzLmhhcyhjaWQpXG5cbiAgICBsZXQgW2hhc0NoaWxkTm9kZXMsIGhhc0NoaWxkQ29tcG9uZW50c10gPVxuICAgICAgQXJyYXkuZnJvbShjb250YWluZXIuY2hpbGROb2RlcykucmVkdWNlKChbaGFzTm9kZXMsIGhhc0NvbXBvbmVudHNdLCBjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZihjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpe1xuICAgICAgICAgIGlmKGNoaWxkLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSl7XG4gICAgICAgICAgICByZXR1cm4gW2hhc05vZGVzLCB0cnVlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCwgY2lkKVxuICAgICAgICAgIGlmKCFjaGlsZC5pZCl7IGNoaWxkLmlkID0gYCR7dGhpcy5wYXJlbnRWaWV3SWQoKX0tJHtjaWR9LSR7aX1gIH1cbiAgICAgICAgICBpZihza2lwKXtcbiAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShQSFhfU0tJUCwgXCJcIilcbiAgICAgICAgICAgIGNoaWxkLmlubmVySFRNTCA9IFwiXCJcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFt0cnVlLCBoYXNDb21wb25lbnRzXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKGNoaWxkLm5vZGVWYWx1ZS50cmltKCkgIT09IFwiXCIpe1xuICAgICAgICAgICAgbG9nRXJyb3IoXCJvbmx5IEhUTUwgZWxlbWVudCB0YWdzIGFyZSBhbGxvd2VkIGF0IHRoZSByb290IG9mIGNvbXBvbmVudHMuXFxuXFxuXCIgK1xuICAgICAgICAgICAgICBgZ290OiBcIiR7Y2hpbGQubm9kZVZhbHVlLnRyaW0oKX1cIlxcblxcbmAgK1xuICAgICAgICAgICAgICBcIndpdGhpbjpcXG5cIiwgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSlcbiAgICAgICAgICAgIGNoaWxkLnJlcGxhY2VXaXRoKHRoaXMuY3JlYXRlU3BhbihjaGlsZC5ub2RlVmFsdWUsIGNpZCkpXG4gICAgICAgICAgICByZXR1cm4gW3RydWUsIGhhc0NvbXBvbmVudHNdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpXG4gICAgICAgICAgICByZXR1cm4gW2hhc05vZGVzLCBoYXNDb21wb25lbnRzXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgW2ZhbHNlLCBmYWxzZV0pXG5cbiAgICBpZighaGFzQ2hpbGROb2RlcyAmJiAhaGFzQ2hpbGRDb21wb25lbnRzKXtcbiAgICAgIGxvZ0Vycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgdGhlIGNvbXBvbmVudCBpcyBlbXB0eTpcXG5cIixcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSlcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNwYW4oXCJcIiwgY2lkKS5vdXRlckhUTUxcbiAgICB9IGVsc2UgaWYoIWhhc0NoaWxkTm9kZXMgJiYgaGFzQ2hpbGRDb21wb25lbnRzKXtcbiAgICAgIGxvZ0Vycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgZGlyZWN0bHkgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgb25seSBzdWJjb21wb25lbnRzIHdlcmUgZm91bmQuIEEgY29tcG9uZW50IG11c3QgcmVuZGVyIGF0IGxlYXN0IG9uZSBIVE1MIHRhZyBkaXJlY3RseSBpbnNpZGUgaXRzZWxmLlwiLFxuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwudHJpbSgpKVxuICAgICAgcmV0dXJuIHRlbXBsYXRlLmlubmVySFRNTFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGUuaW5uZXJIVE1MXG4gICAgfVxuICB9XG5cbiAgY3JlYXRlU3Bhbih0ZXh0LCBjaWQpe1xuICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIilcbiAgICBzcGFuLmlubmVyVGV4dCA9IHRleHRcbiAgICBzcGFuLnNldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5ULCBjaWQpXG4gICAgcmV0dXJuIHNwYW5cbiAgfVxufVxuIiwgImxldCB2aWV3SG9va0lEID0gMVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld0hvb2sge1xuICBzdGF0aWMgbWFrZUlEKCl7IHJldHVybiB2aWV3SG9va0lEKysgfVxuICBzdGF0aWMgZWxlbWVudElEKGVsKXsgcmV0dXJuIGVsLnBoeEhvb2tJZCB9XG5cbiAgY29uc3RydWN0b3IodmlldywgZWwsIGNhbGxiYWNrcyl7XG4gICAgdGhpcy5fX3ZpZXcgPSB2aWV3XG4gICAgdGhpcy5saXZlU29ja2V0ID0gdmlldy5saXZlU29ja2V0XG4gICAgdGhpcy5fX2NhbGxiYWNrcyA9IGNhbGxiYWNrc1xuICAgIHRoaXMuX19saXN0ZW5lcnMgPSBuZXcgU2V0KClcbiAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMuZWwgPSBlbFxuICAgIHRoaXMuZWwucGh4SG9va0lkID0gdGhpcy5jb25zdHJ1Y3Rvci5tYWtlSUQoKVxuICAgIGZvcihsZXQga2V5IGluIHRoaXMuX19jYWxsYmFja3MpeyB0aGlzW2tleV0gPSB0aGlzLl9fY2FsbGJhY2tzW2tleV0gfVxuICB9XG5cbiAgX19tb3VudGVkKCl7IHRoaXMubW91bnRlZCAmJiB0aGlzLm1vdW50ZWQoKSB9XG4gIF9fdXBkYXRlZCgpeyB0aGlzLnVwZGF0ZWQgJiYgdGhpcy51cGRhdGVkKCkgfVxuICBfX2JlZm9yZVVwZGF0ZSgpeyB0aGlzLmJlZm9yZVVwZGF0ZSAmJiB0aGlzLmJlZm9yZVVwZGF0ZSgpIH1cbiAgX19kZXN0cm95ZWQoKXsgdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5kZXN0cm95ZWQoKSB9XG4gIF9fcmVjb25uZWN0ZWQoKXtcbiAgICBpZih0aGlzLl9faXNEaXNjb25uZWN0ZWQpe1xuICAgICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgIHRoaXMucmVjb25uZWN0ZWQgJiYgdGhpcy5yZWNvbm5lY3RlZCgpXG4gICAgfVxuICB9XG4gIF9fZGlzY29ubmVjdGVkKCl7XG4gICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gdHJ1ZVxuICAgIHRoaXMuZGlzY29ubmVjdGVkICYmIHRoaXMuZGlzY29ubmVjdGVkKClcbiAgfVxuXG4gIHB1c2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy5wdXNoSG9va0V2ZW50KG51bGwsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KVxuICB9XG5cbiAgcHVzaEV2ZW50VG8ocGh4VGFyZ2V0LCBldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgcmV0dXJuIHZpZXcucHVzaEhvb2tFdmVudCh0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVFdmVudChldmVudCwgY2FsbGJhY2spe1xuICAgIGxldCBjYWxsYmFja1JlZiA9IChjdXN0b21FdmVudCwgYnlwYXNzKSA9PiBieXBhc3MgPyBldmVudCA6IGNhbGxiYWNrKGN1c3RvbUV2ZW50LmRldGFpbClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpXG4gICAgdGhpcy5fX2xpc3RlbmVycy5hZGQoY2FsbGJhY2tSZWYpXG4gICAgcmV0dXJuIGNhbGxiYWNrUmVmXG4gIH1cblxuICByZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZil7XG4gICAgbGV0IGV2ZW50ID0gY2FsbGJhY2tSZWYobnVsbCwgdHJ1ZSlcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpXG4gICAgdGhpcy5fX2xpc3RlbmVycy5kZWxldGUoY2FsbGJhY2tSZWYpXG4gIH1cblxuICB1cGxvYWQobmFtZSwgZmlsZXMpe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy5kaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXMpXG4gIH1cblxuICB1cGxvYWRUbyhwaHhUYXJnZXQsIG5hbWUsIGZpbGVzKXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIHZpZXcgPT4gdmlldy5kaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXMpKVxuICB9XG5cbiAgX19jbGVhbnVwX18oKXtcbiAgICB0aGlzLl9fbGlzdGVuZXJzLmZvckVhY2goY2FsbGJhY2tSZWYgPT4gdGhpcy5yZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikpXG4gIH1cbn1cbiIsICJpbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5cbmxldCBKUyA9IHtcbiAgZXhlYyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZGVmYXVsdHMpe1xuICAgIGxldCBbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXSA9IGRlZmF1bHRzIHx8IFtudWxsLCB7fV1cbiAgICBsZXQgY29tbWFuZHMgPSBwaHhFdmVudC5jaGFyQXQoMCkgPT09IFwiW1wiID9cbiAgICAgIEpTT04ucGFyc2UocGh4RXZlbnQpIDogW1tkZWZhdWx0S2luZCwgZGVmYXVsdEFyZ3NdXVxuXG4gICAgY29tbWFuZHMuZm9yRWFjaCgoW2tpbmQsIGFyZ3NdKSA9PiB7XG4gICAgICBpZihraW5kID09PSBkZWZhdWx0S2luZCAmJiBkZWZhdWx0QXJncy5kYXRhKXtcbiAgICAgICAgYXJncy5kYXRhID0gT2JqZWN0LmFzc2lnbihhcmdzLmRhdGEgfHwge30sIGRlZmF1bHRBcmdzLmRhdGEpXG4gICAgICB9XG4gICAgICB0aGlzLmZpbHRlclRvRWxzKHNvdXJjZUVsLCBhcmdzKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgdGhpc1tgZXhlY18ke2tpbmR9YF0oZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCBhcmdzKVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIGlzVmlzaWJsZShlbCl7XG4gICAgcmV0dXJuICEhKGVsLm9mZnNldFdpZHRoIHx8IGVsLm9mZnNldEhlaWdodCB8fCBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDApXG4gIH0sXG5cbiAgLy8gcHJpdmF0ZVxuXG4gIC8vIGNvbW1hbmRzXG5cbiAgZXhlY19kaXNwYXRjaChldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHt0bywgZXZlbnQsIGRldGFpbCwgYnViYmxlc30pe1xuICAgIGRldGFpbCA9IGRldGFpbCB8fCB7fVxuICAgIGRldGFpbC5kaXNwYXRjaGVyID0gc291cmNlRWxcbiAgICBET00uZGlzcGF0Y2hFdmVudChlbCwgZXZlbnQsIHtkZXRhaWwsIGJ1YmJsZXN9KVxuICB9LFxuXG4gIGV4ZWNfcHVzaChldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIGFyZ3Mpe1xuICAgIGlmKCF2aWV3LmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuXG4gICAgbGV0IHtldmVudCwgZGF0YSwgdGFyZ2V0LCBwYWdlX2xvYWRpbmcsIGxvYWRpbmcsIHZhbHVlLCBkaXNwYXRjaGVyfSA9IGFyZ3NcbiAgICBsZXQgcHVzaE9wdHMgPSB7bG9hZGluZywgdmFsdWUsIHRhcmdldCwgcGFnZV9sb2FkaW5nOiAhIXBhZ2VfbG9hZGluZ31cbiAgICBsZXQgdGFyZ2V0U3JjID0gZXZlbnRUeXBlID09PSBcImNoYW5nZVwiICYmIGRpc3BhdGNoZXIgPyBkaXNwYXRjaGVyIDogc291cmNlRWxcbiAgICBsZXQgcGh4VGFyZ2V0ID0gdGFyZ2V0IHx8IHRhcmdldFNyYy5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFwidGFyZ2V0XCIpKSB8fCB0YXJnZXRTcmNcbiAgICB2aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodGFyZ2V0VmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICBpZihldmVudFR5cGUgPT09IFwiY2hhbmdlXCIpe1xuICAgICAgICBsZXQge25ld0NpZCwgX3RhcmdldCwgY2FsbGJhY2t9ID0gYXJnc1xuICAgICAgICBfdGFyZ2V0ID0gX3RhcmdldCB8fCAoc291cmNlRWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ID8gc291cmNlRWwubmFtZSA6IHVuZGVmaW5lZClcbiAgICAgICAgaWYoX3RhcmdldCl7IHB1c2hPcHRzLl90YXJnZXQgPSBfdGFyZ2V0IH1cbiAgICAgICAgdGFyZ2V0Vmlldy5wdXNoSW5wdXQoc291cmNlRWwsIHRhcmdldEN0eCwgbmV3Q2lkLCBldmVudCB8fCBwaHhFdmVudCwgcHVzaE9wdHMsIGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIGlmKGV2ZW50VHlwZSA9PT0gXCJzdWJtaXRcIil7XG4gICAgICAgIHRhcmdldFZpZXcuc3VibWl0Rm9ybShzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgcHVzaE9wdHMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRWaWV3LnB1c2hFdmVudChldmVudFR5cGUsIHNvdXJjZUVsLCB0YXJnZXRDdHgsIGV2ZW50IHx8IHBoeEV2ZW50LCBkYXRhLCBwdXNoT3B0cylcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuXG4gIGV4ZWNfYWRkX2NsYXNzKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge25hbWVzLCB0cmFuc2l0aW9uLCB0aW1lfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG5hbWVzLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldylcbiAgfSxcblxuICBleGVjX3JlbW92ZV9jbGFzcyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtuYW1lcywgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgbmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcpXG4gIH0sXG5cbiAgZXhlY190cmFuc2l0aW9uKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge3RpbWUsIHRyYW5zaXRpb259KXtcbiAgICBsZXQgW3RyYW5zaXRpb25fc3RhcnQsIHJ1bm5pbmcsIHRyYW5zaXRpb25fZW5kXSA9IHRyYW5zaXRpb25cbiAgICBsZXQgb25TdGFydCA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uX3N0YXJ0LmNvbmNhdChydW5uaW5nKSwgW10pXG4gICAgbGV0IG9uRG9uZSA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uX2VuZCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQocnVubmluZykpXG4gICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfSxcblxuICBleGVjX3RvZ2dsZShldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWV9KXtcbiAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWUpXG4gIH0sXG5cbiAgZXhlY19zaG93KGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2Rpc3BsYXksIHRyYW5zaXRpb24sIHRpbWV9KXtcbiAgICB0aGlzLnNob3coZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSlcbiAgfSxcblxuICBleGVjX2hpZGUoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7ZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKVxuICB9LFxuXG4gIGV4ZWNfc2V0X2F0dHIoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7YXR0cjogW2F0dHIsIHZhbF19KXtcbiAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtbYXR0ciwgdmFsXV0sIFtdKVxuICB9LFxuXG4gIGV4ZWNfcmVtb3ZlX2F0dHIoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7YXR0cn0pe1xuICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW10sIFthdHRyXSlcbiAgfSxcblxuICAvLyB1dGlscyBmb3IgY29tbWFuZHNcblxuICBzaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpe1xuICAgIGlmKCF0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgdGhpcy50b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgbnVsbCwgdGltZSlcbiAgICB9XG4gIH0sXG5cbiAgaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKXtcbiAgICBpZih0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgdGhpcy50b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgbnVsbCwgdHJhbnNpdGlvbiwgdGltZSlcbiAgICB9XG4gIH0sXG5cbiAgdG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIGlucywgb3V0cywgdGltZSl7XG4gICAgbGV0IFtpbkNsYXNzZXMsIGluU3RhcnRDbGFzc2VzLCBpbkVuZENsYXNzZXNdID0gaW5zIHx8IFtbXSwgW10sIFtdXVxuICAgIGxldCBbb3V0Q2xhc3Nlcywgb3V0U3RhcnRDbGFzc2VzLCBvdXRFbmRDbGFzc2VzXSA9IG91dHMgfHwgW1tdLCBbXSwgW11dXG4gICAgaWYoaW5DbGFzc2VzLmxlbmd0aCA+IDAgfHwgb3V0Q2xhc3Nlcy5sZW5ndGggPiAwKXtcbiAgICAgIGlmKHRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRTdGFydENsYXNzZXMsIGluQ2xhc3Nlcy5jb25jYXQoaW5TdGFydENsYXNzZXMpLmNvbmNhdChpbkVuZENsYXNzZXMpKVxuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dENsYXNzZXMsIFtdKVxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgb3V0RW5kQ2xhc3Nlcywgb3V0U3RhcnRDbGFzc2VzKSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtc3RhcnRcIikpXG4gICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBvdXRDbGFzc2VzLmNvbmNhdChvdXRFbmRDbGFzc2VzKSlcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIilcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKGV2ZW50VHlwZSA9PT0gXCJyZW1vdmVcIil7IHJldHVybiB9XG4gICAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpblN0YXJ0Q2xhc3Nlcywgb3V0Q2xhc3Nlcy5jb25jYXQob3V0U3RhcnRDbGFzc2VzKS5jb25jYXQob3V0RW5kQ2xhc3NlcykpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gKGRpc3BsYXkgfHwgXCJibG9ja1wiKSlcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpbkNsYXNzZXMsIFtdKVxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5FbmRDbGFzc2VzLCBpblN0YXJ0Q2xhc3NlcykpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LXN0YXJ0XCIpKVxuICAgICAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgaW5DbGFzc2VzLmNvbmNhdChpbkVuZENsYXNzZXMpKVxuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctZW5kXCIpKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZih0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLXN0YXJ0XCIpKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKVxuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtZW5kXCIpKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1zdGFydFwiKSlcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5IHx8IFwiYmxvY2tcIilcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBhZGRzLCByZW1vdmVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KXtcbiAgICBsZXQgW3RyYW5zaXRpb25fcnVuLCB0cmFuc2l0aW9uX3N0YXJ0LCB0cmFuc2l0aW9uX2VuZF0gPSB0cmFuc2l0aW9uIHx8IFtbXSwgW10sIFtdXVxuICAgIGlmKHRyYW5zaXRpb25fcnVuLmxlbmd0aCA+IDApe1xuICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQodHJhbnNpdGlvbl9ydW4pLCBbXSlcbiAgICAgIGxldCBvbkRvbmUgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgYWRkcy5jb25jYXQodHJhbnNpdGlvbl9lbmQpLCByZW1vdmVzLmNvbmNhdCh0cmFuc2l0aW9uX3J1bikuY29uY2F0KHRyYW5zaXRpb25fc3RhcnQpKVxuICAgICAgcmV0dXJuIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gICAgfVxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgbGV0IFtwcmV2QWRkcywgcHJldlJlbW92ZXNdID0gRE9NLmdldFN0aWNreShlbCwgXCJjbGFzc2VzXCIsIFtbXSwgW11dKVxuICAgICAgbGV0IGtlZXBBZGRzID0gYWRkcy5maWx0ZXIobmFtZSA9PiBwcmV2QWRkcy5pbmRleE9mKG5hbWUpIDwgMCAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgbGV0IGtlZXBSZW1vdmVzID0gcmVtb3Zlcy5maWx0ZXIobmFtZSA9PiBwcmV2UmVtb3Zlcy5pbmRleE9mKG5hbWUpIDwgMCAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpXG4gICAgICBsZXQgbmV3QWRkcyA9IHByZXZBZGRzLmZpbHRlcihuYW1lID0+IHJlbW92ZXMuaW5kZXhPZihuYW1lKSA8IDApLmNvbmNhdChrZWVwQWRkcylcbiAgICAgIGxldCBuZXdSZW1vdmVzID0gcHJldlJlbW92ZXMuZmlsdGVyKG5hbWUgPT4gYWRkcy5pbmRleE9mKG5hbWUpIDwgMCkuY29uY2F0KGtlZXBSZW1vdmVzKVxuXG4gICAgICBET00ucHV0U3RpY2t5KGVsLCBcImNsYXNzZXNcIiwgY3VycmVudEVsID0+IHtcbiAgICAgICAgY3VycmVudEVsLmNsYXNzTGlzdC5yZW1vdmUoLi4ubmV3UmVtb3ZlcylcbiAgICAgICAgY3VycmVudEVsLmNsYXNzTGlzdC5hZGQoLi4ubmV3QWRkcylcbiAgICAgICAgcmV0dXJuIFtuZXdBZGRzLCBuZXdSZW1vdmVzXVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIHNldE9yUmVtb3ZlQXR0cnMoZWwsIHNldHMsIHJlbW92ZXMpe1xuICAgIGxldCBbcHJldlNldHMsIHByZXZSZW1vdmVzXSA9IERPTS5nZXRTdGlja3koZWwsIFwiYXR0cnNcIiwgW1tdLCBbXV0pXG5cbiAgICBsZXQgYWx0ZXJlZEF0dHJzID0gc2V0cy5tYXAoKFthdHRyLCBfdmFsXSkgPT4gYXR0cikuY29uY2F0KHJlbW92ZXMpO1xuICAgIGxldCBuZXdTZXRzID0gcHJldlNldHMuZmlsdGVyKChbYXR0ciwgX3ZhbF0pID0+ICFhbHRlcmVkQXR0cnMuaW5jbHVkZXMoYXR0cikpLmNvbmNhdChzZXRzKTtcbiAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcigoYXR0cikgPT4gIWFsdGVyZWRBdHRycy5pbmNsdWRlcyhhdHRyKSkuY29uY2F0KHJlbW92ZXMpO1xuXG4gICAgRE9NLnB1dFN0aWNreShlbCwgXCJhdHRyc1wiLCBjdXJyZW50RWwgPT4ge1xuICAgICAgbmV3UmVtb3Zlcy5mb3JFYWNoKGF0dHIgPT4gY3VycmVudEVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKSlcbiAgICAgIG5ld1NldHMuZm9yRWFjaCgoW2F0dHIsIHZhbF0pID0+IGN1cnJlbnRFbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsKSlcbiAgICAgIHJldHVybiBbbmV3U2V0cywgbmV3UmVtb3Zlc11cbiAgICB9KVxuICB9LFxuXG4gIGhhc0FsbENsYXNzZXMoZWwsIGNsYXNzZXMpeyByZXR1cm4gY2xhc3Nlcy5ldmVyeShuYW1lID0+IGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSkgfSxcblxuICBpc1RvZ2dsZWRPdXQoZWwsIG91dENsYXNzZXMpe1xuICAgIHJldHVybiAhdGhpcy5pc1Zpc2libGUoZWwpIHx8IHRoaXMuaGFzQWxsQ2xhc3NlcyhlbCwgb3V0Q2xhc3NlcylcbiAgfSxcblxuICBmaWx0ZXJUb0Vscyhzb3VyY2VFbCwge3RvfSl7XG4gICAgcmV0dXJuIHRvID8gRE9NLmFsbChkb2N1bWVudCwgdG8pIDogW3NvdXJjZUVsXVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEpTXG4iLCAiaW1wb3J0IHtcbiAgQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCxcbiAgQ0hFQ0tBQkxFX0lOUFVUUyxcbiAgQ09OU0VDVVRJVkVfUkVMT0FEUyxcbiAgUEhYX0FVVE9fUkVDT1ZFUixcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX0NPTk5FQ1RFRF9DTEFTUyxcbiAgUEhYX0RJU0FCTEVfV0lUSCxcbiAgUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLFxuICBQSFhfRElTQUJMRUQsXG4gIFBIWF9ESVNDT05ORUNURURfQ0xBU1MsXG4gIFBIWF9FVkVOVF9DTEFTU0VTLFxuICBQSFhfRVJST1JfQ0xBU1MsXG4gIFBIWF9GRUVEQkFDS19GT1IsXG4gIFBIWF9IQVNfU1VCTUlUVEVELFxuICBQSFhfSE9PSyxcbiAgUEhYX1BBR0VfTE9BRElORyxcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1BST0dSRVNTLFxuICBQSFhfUkVBRE9OTFksXG4gIFBIWF9SRUYsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9UUkFDS19TVEFUSUMsXG4gIFBIWF9UUkFDS19VUExPQURTLFxuICBQSFhfVVBEQVRFLFxuICBQSFhfVVBMT0FEX1JFRixcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBVU0hfVElNRU9VVCxcbiAgUEhYX01BSU4sXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNsb25lLFxuICBjbG9zZXN0UGh4QmluZGluZyxcbiAgaXNFbXB0eSxcbiAgaXNFcXVhbE9iaixcbiAgbG9nRXJyb3IsXG4gIG1heWJlLFxuICBpc0NpZCxcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQnJvd3NlciBmcm9tIFwiLi9icm93c2VyXCJcbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBET01QYXRjaCBmcm9tIFwiLi9kb21fcGF0Y2hcIlxuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCJcbmltcG9ydCBSZW5kZXJlZCBmcm9tIFwiLi9yZW5kZXJlZFwiXG5pbXBvcnQgVmlld0hvb2sgZnJvbSBcIi4vdmlld19ob29rXCJcbmltcG9ydCBKUyBmcm9tIFwiLi9qc1wiXG5cbmxldCBzZXJpYWxpemVGb3JtID0gKGZvcm0sIG1ldGEsIG9ubHlOYW1lcyA9IFtdKSA9PiB7XG4gIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKVxuICBsZXQgdG9SZW1vdmUgPSBbXVxuXG4gIGZvcm1EYXRhLmZvckVhY2goKHZhbCwga2V5LCBfaW5kZXgpID0+IHtcbiAgICBpZih2YWwgaW5zdGFuY2VvZiBGaWxlKXsgdG9SZW1vdmUucHVzaChrZXkpIH1cbiAgfSlcblxuICAvLyBDbGVhbnVwIGFmdGVyIGJ1aWxkaW5nIGZpbGVEYXRhXG4gIHRvUmVtb3ZlLmZvckVhY2goa2V5ID0+IGZvcm1EYXRhLmRlbGV0ZShrZXkpKVxuXG4gIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgZm9yKGxldCBba2V5LCB2YWxdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSl7XG4gICAgaWYob25seU5hbWVzLmxlbmd0aCA9PT0gMCB8fCBvbmx5TmFtZXMuaW5kZXhPZihrZXkpID49IDApe1xuICAgICAgcGFyYW1zLmFwcGVuZChrZXksIHZhbClcbiAgICB9XG4gIH1cbiAgZm9yKGxldCBtZXRhS2V5IGluIG1ldGEpeyBwYXJhbXMuYXBwZW5kKG1ldGFLZXksIG1ldGFbbWV0YUtleV0pIH1cblxuICByZXR1cm4gcGFyYW1zLnRvU3RyaW5nKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlldyB7XG4gIGNvbnN0cnVjdG9yKGVsLCBsaXZlU29ja2V0LCBwYXJlbnRWaWV3LCBmbGFzaCl7XG4gICAgdGhpcy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuICAgIHRoaXMuZmxhc2ggPSBmbGFzaFxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50Vmlld1xuICAgIHRoaXMucm9vdCA9IHBhcmVudFZpZXcgPyBwYXJlbnRWaWV3LnJvb3QgOiB0aGlzXG4gICAgdGhpcy5lbCA9IGVsXG4gICAgdGhpcy5pZCA9IHRoaXMuZWwuaWRcbiAgICB0aGlzLnJlZiA9IDBcbiAgICB0aGlzLmNoaWxkSm9pbnMgPSAwXG4gICAgdGhpcy5sb2FkZXJUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgdGhpcy5wcnVuaW5nQ0lEcyA9IFtdXG4gICAgdGhpcy5yZWRpcmVjdCA9IGZhbHNlXG4gICAgdGhpcy5ocmVmID0gbnVsbFxuICAgIHRoaXMuam9pbkNvdW50ID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5qb2luQ291bnQgLSAxIDogMFxuICAgIHRoaXMuam9pblBlbmRpbmcgPSB0cnVlXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIHRoaXMuam9pbkNhbGxiYWNrID0gZnVuY3Rpb24ob25Eb25lKXsgb25Eb25lICYmIG9uRG9uZSgpIH1cbiAgICB0aGlzLnN0b3BDYWxsYmFjayA9IGZ1bmN0aW9uKCl7IH1cbiAgICB0aGlzLnBlbmRpbmdKb2luT3BzID0gdGhpcy5wYXJlbnQgPyBudWxsIDogW11cbiAgICB0aGlzLnZpZXdIb29rcyA9IHt9XG4gICAgdGhpcy51cGxvYWRlcnMgPSB7fVxuICAgIHRoaXMuZm9ybVN1Ym1pdHMgPSBbXVxuICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLnBhcmVudCA/IG51bGwgOiB7fVxuICAgIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSA9IHt9XG4gICAgdGhpcy5jaGFubmVsID0gdGhpcy5saXZlU29ja2V0LmNoYW5uZWwoYGx2OiR7dGhpcy5pZH1gLCAoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWRpcmVjdDogdGhpcy5yZWRpcmVjdCA/IHRoaXMuaHJlZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgdXJsOiB0aGlzLnJlZGlyZWN0ID8gdW5kZWZpbmVkIDogdGhpcy5ocmVmIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyYW1zOiB0aGlzLmNvbm5lY3RQYXJhbXMoKSxcbiAgICAgICAgc2Vzc2lvbjogdGhpcy5nZXRTZXNzaW9uKCksXG4gICAgICAgIHN0YXRpYzogdGhpcy5nZXRTdGF0aWMoKSxcbiAgICAgICAgZmxhc2g6IHRoaXMuZmxhc2hcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuc2hvd0xvYWRlcih0aGlzLmxpdmVTb2NrZXQubG9hZGVyVGltZW91dClcbiAgICB0aGlzLmJpbmRDaGFubmVsKClcbiAgfVxuXG4gIHNldEhyZWYoaHJlZil7IHRoaXMuaHJlZiA9IGhyZWYgfVxuXG4gIHNldFJlZGlyZWN0KGhyZWYpe1xuICAgIHRoaXMucmVkaXJlY3QgPSB0cnVlXG4gICAgdGhpcy5ocmVmID0gaHJlZlxuICB9XG5cbiAgaXNNYWluKCl7IHJldHVybiB0aGlzLmVsLmhhc0F0dHJpYnV0ZShQSFhfTUFJTikgfVxuXG4gIGNvbm5lY3RQYXJhbXMoKXtcbiAgICBsZXQgcGFyYW1zID0gdGhpcy5saXZlU29ja2V0LnBhcmFtcyh0aGlzLmVsKVxuICAgIGxldCBtYW5pZmVzdCA9XG4gICAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9UUkFDS19TVEFUSUMpfV1gKVxuICAgICAgICAubWFwKG5vZGUgPT4gbm9kZS5zcmMgfHwgbm9kZS5ocmVmKS5maWx0ZXIodXJsID0+IHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIilcblxuICAgIGlmKG1hbmlmZXN0Lmxlbmd0aCA+IDApeyBwYXJhbXNbXCJfdHJhY2tfc3RhdGljXCJdID0gbWFuaWZlc3QgfVxuICAgIHBhcmFtc1tcIl9tb3VudHNcIl0gPSB0aGlzLmpvaW5Db3VudFxuXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuY2hhbm5lbC5jYW5QdXNoKCkgfVxuXG4gIGdldFNlc3Npb24oKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSB9XG5cbiAgZ2V0U3RhdGljKCl7XG4gICAgbGV0IHZhbCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9TVEFUSUMpXG4gICAgcmV0dXJuIHZhbCA9PT0gXCJcIiA/IG51bGwgOiB2YWxcbiAgfVxuXG4gIGRlc3Ryb3koY2FsbGJhY2sgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgIGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1cbiAgICBpZih0aGlzLnBhcmVudCl7IGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5wYXJlbnQuaWRdW3RoaXMuaWRdIH1cbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICBsZXQgb25GaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3Mpe1xuICAgICAgICB0aGlzLmRlc3Ryb3lIb29rKHRoaXMudmlld0hvb2tzW2lkXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBET00ubWFya1BoeENoaWxkRGVzdHJveWVkKHRoaXMuZWwpXG5cbiAgICB0aGlzLmxvZyhcImRlc3Ryb3llZFwiLCAoKSA9PiBbXCJ0aGUgY2hpbGQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnRcIl0pXG4gICAgdGhpcy5jaGFubmVsLmxlYXZlKClcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgb25GaW5pc2hlZClcbiAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgb25GaW5pc2hlZClcbiAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCBvbkZpbmlzaGVkKVxuICB9XG5cbiAgc2V0Q29udGFpbmVyQ2xhc3NlcyguLi5jbGFzc2VzKXtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICBQSFhfQ09OTkVDVEVEX0NMQVNTLFxuICAgICAgUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUyxcbiAgICAgIFBIWF9FUlJPUl9DTEFTU1xuICAgIClcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3NlcylcbiAgfVxuXG4gIHNob3dMb2FkZXIodGltZW91dCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpXG4gICAgaWYodGltZW91dCl7XG4gICAgICB0aGlzLmxvYWRlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNob3dMb2FkZXIoKSwgdGltZW91dClcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcyl7IHRoaXMudmlld0hvb2tzW2lkXS5fX2Rpc2Nvbm5lY3RlZCgpIH1cbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfRElTQ09OTkVDVEVEX0NMQVNTKVxuICAgIH1cbiAgfVxuXG4gIGhpZGVMb2FkZXIoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0NPTk5FQ1RFRF9DTEFTUylcbiAgfVxuXG4gIHRyaWdnZXJSZWNvbm5lY3RlZCgpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpeyB0aGlzLnZpZXdIb29rc1tpZF0uX19yZWNvbm5lY3RlZCgpIH1cbiAgfVxuXG4gIGxvZyhraW5kLCBtc2dDYWxsYmFjayl7XG4gICAgdGhpcy5saXZlU29ja2V0LmxvZyh0aGlzLCBraW5kLCBtc2dDYWxsYmFjaylcbiAgfVxuXG4gIHRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lID0gZnVuY3Rpb24oKXt9KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gIH1cblxuICB3aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgY2FsbGJhY2spe1xuICAgIGlmKHBoeFRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHBoeFRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpe1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5vd25lcihwaHhUYXJnZXQsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgcGh4VGFyZ2V0KSlcbiAgICB9XG5cbiAgICBpZihpc0NpZChwaHhUYXJnZXQpKXtcbiAgICAgIGxldCB0YXJnZXRzID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBwaHhUYXJnZXQpXG4gICAgICBpZih0YXJnZXRzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm91bmQgbWF0Y2hpbmcgcGh4LXRhcmdldCBvZiAke3BoeFRhcmdldH1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcywgcGFyc2VJbnQocGh4VGFyZ2V0KSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRhcmdldHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocGh4VGFyZ2V0KSlcbiAgICAgIGlmKHRhcmdldHMubGVuZ3RoID09PSAwKXsgbG9nRXJyb3IoYG5vdGhpbmcgZm91bmQgbWF0Y2hpbmcgdGhlIHBoeC10YXJnZXQgc2VsZWN0b3IgXCIke3BoeFRhcmdldH1cImApIH1cbiAgICAgIHRhcmdldHMuZm9yRWFjaCh0YXJnZXQgPT4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHRhcmdldCwgdmlldyA9PiBjYWxsYmFjayh2aWV3LCB0YXJnZXQpKSlcbiAgICB9XG4gIH1cblxuICBhcHBseURpZmYodHlwZSwgcmF3RGlmZiwgY2FsbGJhY2spe1xuICAgIHRoaXMubG9nKHR5cGUsICgpID0+IFtcIlwiLCBjbG9uZShyYXdEaWZmKV0pXG4gICAgbGV0IHtkaWZmLCByZXBseSwgZXZlbnRzLCB0aXRsZX0gPSBSZW5kZXJlZC5leHRyYWN0KHJhd0RpZmYpXG4gICAgaWYodGl0bGUpeyBET00ucHV0VGl0bGUodGl0bGUpIH1cblxuICAgIGNhbGxiYWNrKHtkaWZmLCByZXBseSwgZXZlbnRzfSlcbiAgICByZXR1cm4gcmVwbHlcbiAgfVxuXG4gIG9uSm9pbihyZXNwKXtcbiAgICBsZXQge3JlbmRlcmVkLCBjb250YWluZXJ9ID0gcmVzcFxuICAgIGlmKGNvbnRhaW5lcil7XG4gICAgICBsZXQgW3RhZywgYXR0cnNdID0gY29udGFpbmVyXG4gICAgICB0aGlzLmVsID0gRE9NLnJlcGxhY2VSb290Q29udGFpbmVyKHRoaXMuZWwsIHRhZywgYXR0cnMpXG4gICAgfVxuICAgIHRoaXMuY2hpbGRKb2lucyA9IDBcbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXMuZmxhc2ggPSBudWxsXG5cbiAgICBCcm93c2VyLmRyb3BMb2NhbCh0aGlzLmxpdmVTb2NrZXQubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMpXG4gICAgdGhpcy5hcHBseURpZmYoXCJtb3VudFwiLCByZW5kZXJlZCwgKHtkaWZmLCBldmVudHN9KSA9PiB7XG4gICAgICB0aGlzLnJlbmRlcmVkID0gbmV3IFJlbmRlcmVkKHRoaXMuaWQsIGRpZmYpXG4gICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyQ29udGFpbmVyKG51bGwsIFwiam9pblwiKVxuICAgICAgdGhpcy5kcm9wUGVuZGluZ1JlZnMoKVxuICAgICAgbGV0IGZvcm1zID0gdGhpcy5mb3Jtc0ZvclJlY292ZXJ5KGh0bWwpXG4gICAgICB0aGlzLmpvaW5Db3VudCsrXG5cbiAgICAgIGlmKGZvcm1zLmxlbmd0aCA+IDApe1xuICAgICAgICBmb3Jtcy5mb3JFYWNoKChbZm9ybSwgbmV3Rm9ybSwgbmV3Q2lkXSwgaSkgPT4ge1xuICAgICAgICAgIHRoaXMucHVzaEZvcm1SZWNvdmVyeShmb3JtLCBuZXdDaWQsIHJlc3AgPT4ge1xuICAgICAgICAgICAgaWYoaSA9PT0gZm9ybXMubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcCwgaHRtbCwgZXZlbnRzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uSm9pbkNvbXBsZXRlKHJlc3AsIGh0bWwsIGV2ZW50cylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZHJvcFBlbmRpbmdSZWZzKCl7XG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske1BIWF9SRUZfU1JDfT1cIiR7dGhpcy5pZH1cIl1bJHtQSFhfUkVGfV1gLCBlbCA9PiB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRilcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX1NSQylcbiAgICB9KVxuICB9XG5cbiAgb25Kb2luQ29tcGxldGUoe2xpdmVfcGF0Y2h9LCBodG1sLCBldmVudHMpe1xuICAgIC8vIEluIG9yZGVyIHRvIHByb3ZpZGUgYSBiZXR0ZXIgZXhwZXJpZW5jZSwgd2Ugd2FudCB0byBqb2luXG4gICAgLy8gYWxsIExpdmVWaWV3cyBmaXJzdCBhbmQgb25seSB0aGVuIGFwcGx5IHRoZWlyIHBhdGNoZXMuXG4gICAgaWYodGhpcy5qb2luQ291bnQgPiAxIHx8ICh0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQuaXNKb2luUGVuZGluZygpKSl7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXG4gICAgfVxuXG4gICAgLy8gT25lIGRvd25zaWRlIG9mIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB3ZSBuZWVkIHRvIGZpbmQgcGh4Q2hpbGRyZW5cbiAgICAvLyBpbiB0aGUgaHRtbCBmcmFnbWVudCwgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgRE9NLiBUaGUgZnJhZ21lbnRcbiAgICAvLyBhbHNvIGRvZXMgbm90IGluY2x1ZGUgUEhYX1NUQVRJQywgc28gd2UgbmVlZCB0byBjb3B5IGl0IG92ZXIgZnJvbVxuICAgIC8vIHRoZSBET00uXG4gICAgbGV0IG5ld0NoaWxkcmVuID0gRE9NLmZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQoaHRtbCwgdGhpcy5pZCkuZmlsdGVyKHRvRWwgPT4ge1xuICAgICAgbGV0IGZyb21FbCA9IHRvRWwuaWQgJiYgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKGBbaWQ9XCIke3RvRWwuaWR9XCJdYClcbiAgICAgIGxldCBwaHhTdGF0aWMgPSBmcm9tRWwgJiYgZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKVxuICAgICAgaWYocGh4U3RhdGljKXsgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQywgcGh4U3RhdGljKSB9XG4gICAgICByZXR1cm4gdGhpcy5qb2luQ2hpbGQodG9FbClcbiAgICB9KVxuXG4gICAgaWYobmV3Q2hpbGRyZW4ubGVuZ3RoID09PSAwKXtcbiAgICAgIGlmKHRoaXMucGFyZW50KXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKV0pXG4gICAgICAgIHRoaXMucGFyZW50LmFja0pvaW4odGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKVxuICAgICAgICB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKV0pXG4gICAgfVxuICB9XG5cbiAgYXR0YWNoVHJ1ZURvY0VsKCl7XG4gICAgdGhpcy5lbCA9IERPTS5ieUlkKHRoaXMuaWQpXG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZClcbiAgfVxuXG4gIGFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cyl7XG4gICAgdGhpcy5hdHRhY2hUcnVlRG9jRWwoKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBudWxsKVxuICAgIHBhdGNoLm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKClcbiAgICB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgZmFsc2UpXG4gICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKVxuICAgIERPTS5hbGwodGhpcy5lbCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XSwgW2RhdGEtcGh4LSR7UEhYX0hPT0t9XWAsIGhvb2tFbCA9PiB7XG4gICAgICBsZXQgaG9vayA9IHRoaXMuYWRkSG9vayhob29rRWwpXG4gICAgICBpZihob29rKXsgaG9vay5fX21vdW50ZWQoKSB9XG4gICAgfSlcblxuICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZVxuICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpXG4gICAgdGhpcy5hcHBseVBlbmRpbmdVcGRhdGVzKClcblxuICAgIGlmKGxpdmVfcGF0Y2gpe1xuICAgICAgbGV0IHtraW5kLCB0b30gPSBsaXZlX3BhdGNoXG4gICAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKVxuICAgIH1cbiAgICB0aGlzLmhpZGVMb2FkZXIoKVxuICAgIGlmKHRoaXMuam9pbkNvdW50ID4gMSl7IHRoaXMudHJpZ2dlclJlY29ubmVjdGVkKCkgfVxuICAgIHRoaXMuc3RvcENhbGxiYWNrKClcbiAgfVxuXG4gIHRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbCl7XG4gICAgdGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbkJlZm9yZUVsVXBkYXRlZFwiLCBbZnJvbUVsLCB0b0VsXSlcbiAgICBsZXQgaG9vayA9IHRoaXMuZ2V0SG9vayhmcm9tRWwpXG4gICAgbGV0IGlzSWdub3JlZCA9IGhvb2sgJiYgRE9NLmlzSWdub3JlZChmcm9tRWwsIHRoaXMuYmluZGluZyhQSFhfVVBEQVRFKSlcbiAgICBpZihob29rICYmICFmcm9tRWwuaXNFcXVhbE5vZGUodG9FbCkgJiYgIShpc0lnbm9yZWQgJiYgaXNFcXVhbE9iaihmcm9tRWwuZGF0YXNldCwgdG9FbC5kYXRhc2V0KSkpe1xuICAgICAgaG9vay5fX2JlZm9yZVVwZGF0ZSgpXG4gICAgICByZXR1cm4gaG9va1xuICAgIH1cbiAgfVxuXG4gIHBlcmZvcm1QYXRjaChwYXRjaCwgcHJ1bmVDaWRzKXtcbiAgICBsZXQgcmVtb3ZlZEVscyA9IFtdXG4gICAgbGV0IHBoeENoaWxkcmVuQWRkZWQgPSBmYWxzZVxuICAgIGxldCB1cGRhdGVkSG9va0lkcyA9IG5ldyBTZXQoKVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJhZGRlZFwiLCBlbCA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uTm9kZUFkZGVkXCIsIFtlbF0pXG5cbiAgICAgIGxldCBuZXdIb29rID0gdGhpcy5hZGRIb29rKGVsKVxuICAgICAgaWYobmV3SG9vayl7IG5ld0hvb2suX19tb3VudGVkKCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwgPT4ge1xuICAgICAgaWYoRE9NLmlzUGh4U3RpY2t5KGVsKSl7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5qb2luUm9vdFZpZXdzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHBhdGNoLmJlZm9yZShcInVwZGF0ZWRcIiwgKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbClcbiAgICAgIGlmKGhvb2speyB1cGRhdGVkSG9va0lkcy5hZGQoZnJvbUVsLmlkKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidXBkYXRlZFwiLCBlbCA9PiB7XG4gICAgICBpZih1cGRhdGVkSG9va0lkcy5oYXMoZWwuaWQpKXsgdGhpcy5nZXRIb29rKGVsKS5fX3VwZGF0ZWQoKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwiZGlzY2FyZGVkXCIsIChlbCkgPT4ge1xuICAgICAgaWYoZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKXsgcmVtb3ZlZEVscy5wdXNoKGVsKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgZWxzID0+IHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQoZWxzLCBwcnVuZUNpZHMpKVxuICAgIHBhdGNoLnBlcmZvcm0oKVxuICAgIHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQocmVtb3ZlZEVscywgcHJ1bmVDaWRzKVxuXG4gICAgcmV0dXJuIHBoeENoaWxkcmVuQWRkZWRcbiAgfVxuXG4gIGFmdGVyRWxlbWVudHNSZW1vdmVkKGVsZW1lbnRzLCBwcnVuZUNpZHMpe1xuICAgIGxldCBkZXN0cm95ZWRDSURzID0gW11cbiAgICBlbGVtZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICBsZXQgY29tcG9uZW50cyA9IERPTS5hbGwocGFyZW50LCBgWyR7UEhYX0NPTVBPTkVOVH1dYClcbiAgICAgIGxldCBob29rcyA9IERPTS5hbGwocGFyZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9IT09LKX1dYClcbiAgICAgIGNvbXBvbmVudHMuY29uY2F0KHBhcmVudCkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGxldCBjaWQgPSB0aGlzLmNvbXBvbmVudElEKGVsKVxuICAgICAgICBpZihpc0NpZChjaWQpICYmIGRlc3Ryb3llZENJRHMuaW5kZXhPZihjaWQpID09PSAtMSl7IGRlc3Ryb3llZENJRHMucHVzaChjaWQpIH1cbiAgICAgIH0pXG4gICAgICBob29rcy5jb25jYXQocGFyZW50KS5mb3JFYWNoKGhvb2tFbCA9PiB7XG4gICAgICAgIGxldCBob29rID0gdGhpcy5nZXRIb29rKGhvb2tFbClcbiAgICAgICAgaG9vayAmJiB0aGlzLmRlc3Ryb3lIb29rKGhvb2spXG4gICAgICB9KVxuICAgIH0pXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcnVuZUNpZHMgb24gam9pbnMuIE90aGVyd2lzZSwgaW4gY2FzZSBvZlxuICAgIC8vIHJlam9pbnMsIHdlIG1heSBub3RpZnkgY2lkcyB0aGF0IG5vIGxvbmdlciBiZWxvbmcgdG8gdGhlXG4gICAgLy8gY3VycmVudCBMaXZlVmlldyB0byBiZSByZW1vdmVkLlxuICAgIGlmKHBydW5lQ2lkcyl7XG4gICAgICB0aGlzLm1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWQoZGVzdHJveWVkQ0lEcylcbiAgICB9XG4gIH1cblxuICBqb2luTmV3Q2hpbGRyZW4oKXtcbiAgICBET00uZmluZFBoeENoaWxkcmVuKHRoaXMuZWwsIHRoaXMuaWQpLmZvckVhY2goZWwgPT4gdGhpcy5qb2luQ2hpbGQoZWwpKVxuICB9XG5cbiAgZ2V0Q2hpbGRCeUlkKGlkKXsgcmV0dXJuIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXVtpZF0gfVxuXG4gIGdldERlc2NlbmRlbnRCeUVsKGVsKXtcbiAgICBpZihlbC5pZCA9PT0gdGhpcy5pZCl7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCldW2VsLmlkXVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lEZXNjZW5kZW50KGlkKXtcbiAgICBmb3IobGV0IHBhcmVudElkIGluIHRoaXMucm9vdC5jaGlsZHJlbil7XG4gICAgICBmb3IobGV0IGNoaWxkSWQgaW4gdGhpcy5yb290LmNoaWxkcmVuW3BhcmVudElkXSl7XG4gICAgICAgIGlmKGNoaWxkSWQgPT09IGlkKXsgcmV0dXJuIHRoaXMucm9vdC5jaGlsZHJlbltwYXJlbnRJZF1bY2hpbGRJZF0uZGVzdHJveSgpIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBqb2luQ2hpbGQoZWwpe1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRCeUlkKGVsLmlkKVxuICAgIGlmKCFjaGlsZCl7XG4gICAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLmxpdmVTb2NrZXQsIHRoaXMpXG4gICAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bdmlldy5pZF0gPSB2aWV3XG4gICAgICB2aWV3LmpvaW4oKVxuICAgICAgdGhpcy5jaGlsZEpvaW5zKytcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgaXNKb2luUGVuZGluZygpeyByZXR1cm4gdGhpcy5qb2luUGVuZGluZyB9XG5cbiAgYWNrSm9pbihfY2hpbGQpe1xuICAgIHRoaXMuY2hpbGRKb2lucy0tXG5cbiAgICBpZih0aGlzLmNoaWxkSm9pbnMgPT09IDApe1xuICAgICAgaWYodGhpcy5wYXJlbnQpe1xuICAgICAgICB0aGlzLnBhcmVudC5hY2tKb2luKHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpe1xuICAgIHRoaXMuam9pbkNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMuZm9yRWFjaCgoW3ZpZXcsIG9wXSkgPT4ge1xuICAgICAgICBpZighdmlldy5pc0Rlc3Ryb3llZCgpKXsgb3AoKSB9XG4gICAgICB9KVxuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IFtdXG4gICAgfSlcbiAgfVxuXG4gIHVwZGF0ZShkaWZmLCBldmVudHMpe1xuICAgIGlmKHRoaXMuaXNKb2luUGVuZGluZygpIHx8ICh0aGlzLmxpdmVTb2NrZXQuaGFzUGVuZGluZ0xpbmsoKSAmJiAhRE9NLmlzUGh4U3RpY2t5KHRoaXMuZWwpKSl7XG4gICAgICByZXR1cm4gdGhpcy5wZW5kaW5nRGlmZnMucHVzaCh7ZGlmZiwgZXZlbnRzfSlcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihkaWZmKVxuICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2VcblxuICAgIC8vIFdoZW4gdGhlIGRpZmYgb25seSBjb250YWlucyBjb21wb25lbnQgZGlmZnMsIHRoZW4gd2FsayBjb21wb25lbnRzXG4gICAgLy8gYW5kIHBhdGNoIG9ubHkgdGhlIHBhcmVudCBjb21wb25lbnQgY29udGFpbmVycyBmb3VuZCBpbiB0aGUgZGlmZi5cbiAgICAvLyBPdGhlcndpc2UsIHBhdGNoIGVudGlyZSBMViBjb250YWluZXIuXG4gICAgaWYodGhpcy5yZW5kZXJlZC5pc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiY29tcG9uZW50IHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgbGV0IHBhcmVudENpZHMgPSBET00uZmluZFBhcmVudENJRHModGhpcy5lbCwgdGhpcy5yZW5kZXJlZC5jb21wb25lbnRDSURzKGRpZmYpKVxuICAgICAgICBwYXJlbnRDaWRzLmZvckVhY2gocGFyZW50Q0lEID0+IHtcbiAgICAgICAgICBpZih0aGlzLmNvbXBvbmVudFBhdGNoKHRoaXMucmVuZGVyZWQuZ2V0Q29tcG9uZW50KGRpZmYsIHBhcmVudENJRCksIHBhcmVudENJRCkpeyBwaHhDaGlsZHJlbkFkZGVkID0gdHJ1ZSB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZighaXNFbXB0eShkaWZmKSl7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImZ1bGwgcGF0Y2ggY29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyQ29udGFpbmVyKGRpZmYsIFwidXBkYXRlXCIpXG4gICAgICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBudWxsKVxuICAgICAgICBwaHhDaGlsZHJlbkFkZGVkID0gdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIHRydWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpXG4gICAgaWYocGh4Q2hpbGRyZW5BZGRlZCl7IHRoaXMuam9pbk5ld0NoaWxkcmVuKCkgfVxuICB9XG5cbiAgcmVuZGVyQ29udGFpbmVyKGRpZmYsIGtpbmQpe1xuICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQudGltZShgdG9TdHJpbmcgZGlmZiAoJHtraW5kfSlgLCAoKSA9PiB7XG4gICAgICBsZXQgdGFnID0gdGhpcy5lbC50YWdOYW1lXG4gICAgICAvLyBEb24ndCBza2lwIGFueSBjb21wb25lbnQgaW4gdGhlIGRpZmYgbm9yIGFueSBtYXJrZWQgYXMgcHJ1bmVkXG4gICAgICAvLyAoYXMgdGhleSBtYXkgaGF2ZSBiZWVuIGFkZGVkIGJhY2spXG4gICAgICBsZXQgY2lkcyA9IGRpZmYgPyB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudENJRHMoZGlmZikuY29uY2F0KHRoaXMucHJ1bmluZ0NJRHMpIDogbnVsbFxuICAgICAgbGV0IGh0bWwgPSB0aGlzLnJlbmRlcmVkLnRvU3RyaW5nKGNpZHMpXG4gICAgICByZXR1cm4gYDwke3RhZ30+JHtodG1sfTwvJHt0YWd9PmBcbiAgICB9KVxuICB9XG5cbiAgY29tcG9uZW50UGF0Y2goZGlmZiwgY2lkKXtcbiAgICBpZihpc0VtcHR5KGRpZmYpKSByZXR1cm4gZmFsc2VcbiAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyZWQuY29tcG9uZW50VG9TdHJpbmcoY2lkKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBjaWQpXG4gICAgbGV0IGNoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSlcbiAgICByZXR1cm4gY2hpbGRyZW5BZGRlZFxuICB9XG5cbiAgZ2V0SG9vayhlbCl7IHJldHVybiB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoZWwpXSB9XG5cbiAgYWRkSG9vayhlbCl7XG4gICAgaWYoVmlld0hvb2suZWxlbWVudElEKGVsKSB8fCAhZWwuZ2V0QXR0cmlidXRlKXsgcmV0dXJuIH1cbiAgICBsZXQgaG9va05hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoYGRhdGEtcGh4LSR7UEhYX0hPT0t9YCkgfHwgZWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfSE9PSykpXG4gICAgaWYoaG9va05hbWUgJiYgIXRoaXMub3duc0VsZW1lbnQoZWwpKXsgcmV0dXJuIH1cbiAgICBsZXQgY2FsbGJhY2tzID0gdGhpcy5saXZlU29ja2V0LmdldEhvb2tDYWxsYmFja3MoaG9va05hbWUpXG5cbiAgICBpZihjYWxsYmFja3Mpe1xuICAgICAgaWYoIWVsLmlkKXsgbG9nRXJyb3IoYG5vIERPTSBJRCBmb3IgaG9vayBcIiR7aG9va05hbWV9XCIuIEhvb2tzIHJlcXVpcmUgYSB1bmlxdWUgSUQgb24gZWFjaCBlbGVtZW50LmAsIGVsKSB9XG4gICAgICBsZXQgaG9vayA9IG5ldyBWaWV3SG9vayh0aGlzLCBlbCwgY2FsbGJhY2tzKVxuICAgICAgdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGhvb2suZWwpXSA9IGhvb2tcbiAgICAgIHJldHVybiBob29rXG4gICAgfSBlbHNlIGlmKGhvb2tOYW1lICE9PSBudWxsKXtcbiAgICAgIGxvZ0Vycm9yKGB1bmtub3duIGhvb2sgZm91bmQgZm9yIFwiJHtob29rTmFtZX1cImAsIGVsKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lIb29rKGhvb2spe1xuICAgIGhvb2suX19kZXN0cm95ZWQoKVxuICAgIGhvb2suX19jbGVhbnVwX18oKVxuICAgIGRlbGV0ZSB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoaG9vay5lbCldXG4gIH1cblxuICBhcHBseVBlbmRpbmdVcGRhdGVzKCl7XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICB9XG5cbiAgb25DaGFubmVsKGV2ZW50LCBjYil7XG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIGV2ZW50LCByZXNwID0+IHtcbiAgICAgIGlmKHRoaXMuaXNKb2luUGVuZGluZygpKXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IGNiKHJlc3ApXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IGNiKHJlc3ApKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBiaW5kQ2hhbm5lbCgpe1xuICAgIC8vIFRoZSBkaWZmIGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSByZWd1bGFyIHVwZGF0ZSBvcGVyYXRpb25zLlxuICAgIC8vIEFsbCBvdGhlciBvcGVyYXRpb25zIGFyZSBxdWV1ZWQgdG8gYmUgYXBwbGllZCBvbmx5IGFmdGVyIGpvaW4uXG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIFwiZGlmZlwiLCAocmF3RGlmZikgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByYXdEaWZmLCAoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJyZWRpcmVjdFwiLCAoe3RvLCBmbGFzaH0pID0+IHRoaXMub25SZWRpcmVjdCh7dG8sIGZsYXNofSkpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3BhdGNoXCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVQYXRjaChyZWRpcikpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZWRpcikpXG4gICAgdGhpcy5jaGFubmVsLm9uRXJyb3IocmVhc29uID0+IHRoaXMub25FcnJvcihyZWFzb24pKVxuICAgIHRoaXMuY2hhbm5lbC5vbkNsb3NlKHJlYXNvbiA9PiB0aGlzLm9uQ2xvc2UocmVhc29uKSlcbiAgfVxuXG4gIGRlc3Ryb3lBbGxDaGlsZHJlbigpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdKXtcbiAgICAgIHRoaXMuZ2V0Q2hpbGRCeUlkKGlkKS5kZXN0cm95KClcbiAgICB9XG4gIH1cblxuICBvbkxpdmVSZWRpcmVjdChyZWRpcil7XG4gICAgbGV0IHt0bywga2luZCwgZmxhc2h9ID0gcmVkaXJcbiAgICBsZXQgdXJsID0gdGhpcy5leHBhbmRVUkwodG8pXG4gICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlSZWRpcmVjdCh1cmwsIGtpbmQsIGZsYXNoKVxuICB9XG5cbiAgb25MaXZlUGF0Y2gocmVkaXIpe1xuICAgIGxldCB7dG8sIGtpbmR9ID0gcmVkaXJcbiAgICB0aGlzLmhyZWYgPSB0aGlzLmV4cGFuZFVSTCh0bylcbiAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKVxuICB9XG5cbiAgZXhwYW5kVVJMKHRvKXtcbiAgICByZXR1cm4gdG8uc3RhcnRzV2l0aChcIi9cIikgPyBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0fSR7dG99YCA6IHRvXG4gIH1cblxuICBvblJlZGlyZWN0KHt0bywgZmxhc2h9KXsgdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHRvLCBmbGFzaCkgfVxuXG4gIGlzRGVzdHJveWVkKCl7IHJldHVybiB0aGlzLmRlc3Ryb3llZCB9XG5cbiAgam9pbihjYWxsYmFjayl7XG4gICAgaWYodGhpcy5pc01haW4oKSl7XG4gICAgICB0aGlzLnN0b3BDYWxsYmFjayA9IHRoaXMubGl2ZVNvY2tldC53aXRoUGFnZUxvYWRpbmcoe3RvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiaW5pdGlhbFwifSlcbiAgICB9XG4gICAgdGhpcy5qb2luQ2FsbGJhY2sgPSAob25Eb25lKSA9PiB7XG4gICAgICBvbkRvbmUgPSBvbkRvbmUgfHwgZnVuY3Rpb24oKXt9XG4gICAgICBjYWxsYmFjayA/IGNhbGxiYWNrKHRoaXMuam9pbkNvdW50LCBvbkRvbmUpIDogb25Eb25lKClcbiAgICB9XG4gICAgdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMsIHt0aW1lb3V0OiBmYWxzZX0sICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwuam9pbigpXG4gICAgICAgIC5yZWNlaXZlKFwib2tcIiwgZGF0YSA9PiB7XG4gICAgICAgICAgaWYoIXRoaXMuaXNEZXN0cm95ZWQoKSl7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB0aGlzLm9uSm9pbihkYXRhKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgcmVzcCA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIHRoaXMub25Kb2luRXJyb3IocmVzcCkpXG4gICAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIHRoaXMub25Kb2luRXJyb3Ioe3JlYXNvbjogXCJ0aW1lb3V0XCJ9KSlcbiAgICB9KVxuICB9XG5cbiAgb25Kb2luRXJyb3IocmVzcCl7XG4gICAgaWYocmVzcC5yZWFzb24gPT09IFwidW5hdXRob3JpemVkXCIgfHwgcmVzcC5yZWFzb24gPT09IFwic3RhbGVcIil7XG4gICAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInVuYXV0aG9yaXplZCBsaXZlX3JlZGlyZWN0LiBGYWxsaW5nIGJhY2sgdG8gcGFnZSByZXF1ZXN0XCIsIHJlc3BdKVxuICAgICAgcmV0dXJuIHRoaXMub25SZWRpcmVjdCh7dG86IHRoaXMuaHJlZn0pXG4gICAgfVxuICAgIGlmKHJlc3AucmVkaXJlY3QgfHwgcmVzcC5saXZlX3JlZGlyZWN0KXtcbiAgICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZVxuICAgICAgdGhpcy5jaGFubmVsLmxlYXZlKClcbiAgICB9XG4gICAgaWYocmVzcC5yZWRpcmVjdCl7IHJldHVybiB0aGlzLm9uUmVkaXJlY3QocmVzcC5yZWRpcmVjdCkgfVxuICAgIGlmKHJlc3AubGl2ZV9yZWRpcmVjdCl7IHJldHVybiB0aGlzLm9uTGl2ZVJlZGlyZWN0KHJlc3AubGl2ZV9yZWRpcmVjdCkgfVxuICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hYmxlIHRvIGpvaW5cIiwgcmVzcF0pXG4gICAgaWYodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLmxpdmVTb2NrZXQucmVsb2FkV2l0aEppdHRlcih0aGlzKSB9XG4gIH1cblxuICBvbkNsb3NlKHJlYXNvbil7XG4gICAgaWYodGhpcy5pc0Rlc3Ryb3llZCgpKXsgcmV0dXJuIH1cbiAgICBpZih0aGlzLmxpdmVTb2NrZXQuaGFzUGVuZGluZ0xpbmsoKSAmJiByZWFzb24gIT09IFwibGVhdmVcIil7XG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcylcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKVxuICAgIHRoaXMubGl2ZVNvY2tldC5kcm9wQWN0aXZlRWxlbWVudCh0aGlzKVxuICAgIC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIGJlIG51bGwgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbiAgICBpZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KXsgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCkgfVxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpe1xuICAgICAgdGhpcy5zaG93TG9hZGVyKEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQpXG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihyZWFzb24pe1xuICAgIHRoaXMub25DbG9zZShyZWFzb24pXG4gICAgaWYodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInZpZXcgY3Jhc2hlZFwiLCByZWFzb25dKSB9XG4gICAgaWYoIXRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpeyB0aGlzLmRpc3BsYXlFcnJvcigpIH1cbiAgfVxuXG4gIGRpc3BsYXlFcnJvcigpe1xuICAgIGlmKHRoaXMuaXNNYWluKCkpeyBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7ZGV0YWlsOiB7dG86IHRoaXMuaHJlZiwga2luZDogXCJlcnJvclwifX0pIH1cbiAgICB0aGlzLnNob3dMb2FkZXIoKVxuICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfRElTQ09OTkVDVEVEX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MpXG4gIH1cblxuICBwdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7IHJldHVybiB9XG5cbiAgICBsZXQgW3JlZiwgW2VsXSwgb3B0c10gPSByZWZHZW5lcmF0b3IgPyByZWZHZW5lcmF0b3IoKSA6IFtudWxsLCBbXSwge31dXG4gICAgbGV0IG9uTG9hZGluZ0RvbmUgPSBmdW5jdGlvbigpeyB9XG4gICAgaWYob3B0cy5wYWdlX2xvYWRpbmcgfHwgKGVsICYmIChlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9QQUdFX0xPQURJTkcpKSAhPT0gbnVsbCkpKXtcbiAgICAgIG9uTG9hZGluZ0RvbmUgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHtraW5kOiBcImVsZW1lbnRcIiwgdGFyZ2V0OiBlbH0pXG4gICAgfVxuXG4gICAgaWYodHlwZW9mIChwYXlsb2FkLmNpZCkgIT09IFwibnVtYmVyXCIpeyBkZWxldGUgcGF5bG9hZC5jaWQgfVxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcywge3RpbWVvdXQ6IHRydWV9LCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwucHVzaChldmVudCwgcGF5bG9hZCwgUFVTSF9USU1FT1VUKS5yZWNlaXZlKFwib2tcIiwgcmVzcCA9PiB7XG4gICAgICAgICAgaWYocmVmICE9PSBudWxsKXsgdGhpcy51bmRvUmVmcyhyZWYpIH1cbiAgICAgICAgICBsZXQgZmluaXNoID0gKGhvb2tSZXBseSkgPT4ge1xuICAgICAgICAgICAgaWYocmVzcC5yZWRpcmVjdCl7IHRoaXMub25SZWRpcmVjdChyZXNwLnJlZGlyZWN0KSB9XG4gICAgICAgICAgICBpZihyZXNwLmxpdmVfcGF0Y2gpeyB0aGlzLm9uTGl2ZVBhdGNoKHJlc3AubGl2ZV9wYXRjaCkgfVxuICAgICAgICAgICAgaWYocmVzcC5saXZlX3JlZGlyZWN0KXsgdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpIH1cbiAgICAgICAgICAgIG9uTG9hZGluZ0RvbmUoKVxuICAgICAgICAgICAgb25SZXBseShyZXNwLCBob29rUmVwbHkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlc3AuZGlmZil7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBob29rUmVwbHkgPSB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByZXNwLmRpZmYsICh7ZGlmZiwgZXZlbnRzfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgZmluaXNoKGhvb2tSZXBseSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbmlzaChudWxsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgdW5kb1JlZnMocmVmKXtcbiAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7UEhYX1JFRl9TUkN9PVwiJHt0aGlzLmlkfVwiXVske1BIWF9SRUZ9PVwiJHtyZWZ9XCJdYCwgZWwgPT4ge1xuICAgICAgbGV0IGRpc2FibGVkVmFsID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRClcbiAgICAgIC8vIHJlbW92ZSByZWZzXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRilcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX1NSQylcbiAgICAgIC8vIHJlc3RvcmUgaW5wdXRzXG4gICAgICBpZihlbC5nZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZKSAhPT0gbnVsbCl7XG4gICAgICAgIGVsLnJlYWRPbmx5ID0gZmFsc2VcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUFET05MWSlcbiAgICAgIH1cbiAgICAgIGlmKGRpc2FibGVkVmFsICE9PSBudWxsKXtcbiAgICAgICAgZWwuZGlzYWJsZWQgPSBkaXNhYmxlZFZhbCA9PT0gXCJ0cnVlXCIgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9ESVNBQkxFRClcbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSBjbGFzc2VzXG4gICAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKGNsYXNzTmFtZSA9PiBET00ucmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSkpXG4gICAgICAvLyByZXN0b3JlIGRpc2FibGVzXG4gICAgICBsZXQgZGlzYWJsZVJlc3RvcmUgPSBlbC5nZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFKVxuICAgICAgaWYoZGlzYWJsZVJlc3RvcmUgIT09IG51bGwpe1xuICAgICAgICBlbC5pbm5lclRleHQgPSBkaXNhYmxlUmVzdG9yZVxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFKVxuICAgICAgfVxuICAgICAgbGV0IHRvRWwgPSBET00ucHJpdmF0ZShlbCwgUEhYX1JFRilcbiAgICAgIGlmKHRvRWwpe1xuICAgICAgICBsZXQgaG9vayA9IHRoaXMudHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZWwsIHRvRWwpXG4gICAgICAgIERPTVBhdGNoLnBhdGNoRWwoZWwsIHRvRWwsIHRoaXMubGl2ZVNvY2tldC5nZXRBY3RpdmVFbGVtZW50KCkpXG4gICAgICAgIGlmKGhvb2speyBob29rLl9fdXBkYXRlZCgpIH1cbiAgICAgICAgRE9NLmRlbGV0ZVByaXZhdGUoZWwsIFBIWF9SRUYpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHB1dFJlZihlbGVtZW50cywgZXZlbnQsIG9wdHMgPSB7fSl7XG4gICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmKytcbiAgICBsZXQgZGlzYWJsZVdpdGggPSB0aGlzLmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSClcbiAgICBpZihvcHRzLmxvYWRpbmcpeyBlbGVtZW50cyA9IGVsZW1lbnRzLmNvbmNhdChET00uYWxsKGRvY3VtZW50LCBvcHRzLmxvYWRpbmcpKX1cblxuICAgIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChgcGh4LSR7ZXZlbnR9LWxvYWRpbmdgKVxuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9SRUYsIG5ld1JlZilcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGX1NSQywgdGhpcy5lbC5pZClcbiAgICAgIGxldCBkaXNhYmxlVGV4dCA9IGVsLmdldEF0dHJpYnV0ZShkaXNhYmxlV2l0aClcbiAgICAgIGlmKGRpc2FibGVUZXh0ICE9PSBudWxsKXtcbiAgICAgICAgaWYoIWVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpKXtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLCBlbC5pbm5lclRleHQpXG4gICAgICAgIH1cbiAgICAgICAgaWYoZGlzYWJsZVRleHQgIT09IFwiXCIpeyBlbC5pbm5lclRleHQgPSBkaXNhYmxlVGV4dCB9XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gW25ld1JlZiwgZWxlbWVudHMsIG9wdHNdXG4gIH1cblxuICBjb21wb25lbnRJRChlbCl7XG4gICAgbGV0IGNpZCA9IGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVClcbiAgICByZXR1cm4gY2lkID8gcGFyc2VJbnQoY2lkKSA6IG51bGxcbiAgfVxuXG4gIHRhcmdldENvbXBvbmVudElEKHRhcmdldCwgdGFyZ2V0Q3R4LCBvcHRzID0ge30pe1xuICAgIGlmKGlzQ2lkKHRhcmdldEN0eCkpeyByZXR1cm4gdGFyZ2V0Q3R4IH1cblxuICAgIGxldCBjaWRPclNlbGVjdG9yID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJ0YXJnZXRcIikpXG4gICAgaWYoaXNDaWQoY2lkT3JTZWxlY3Rvcikpe1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGNpZE9yU2VsZWN0b3IpXG4gICAgfSBlbHNlIGlmKHRhcmdldEN0eCAmJiAoY2lkT3JTZWxlY3RvciAhPT0gbnVsbCB8fCBvcHRzLnRhcmdldCkpe1xuICAgICAgcmV0dXJuIHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBjbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KXtcbiAgICBpZihpc0NpZCh0YXJnZXRDdHgpKXtcbiAgICAgIHJldHVybiB0YXJnZXRDdHhcbiAgICB9IGVsc2UgaWYodGFyZ2V0Q3R4KXtcbiAgICAgIHJldHVybiBtYXliZSh0YXJnZXRDdHguY2xvc2VzdChgWyR7UEhYX0NPTVBPTkVOVH1dYCksIGVsID0+IHRoaXMub3duc0VsZW1lbnQoZWwpICYmIHRoaXMuY29tcG9uZW50SUQoZWwpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHB1c2hIb29rRXZlbnQodGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgb25SZXBseSl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7XG4gICAgICB0aGlzLmxvZyhcImhvb2tcIiwgKCkgPT4gW1widW5hYmxlIHRvIHB1c2ggaG9vayBldmVudC4gTGl2ZVZpZXcgbm90IGNvbm5lY3RlZFwiLCBldmVudCwgcGF5bG9hZF0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgbGV0IFtyZWYsIGVscywgb3B0c10gPSB0aGlzLnB1dFJlZihbXSwgXCJob29rXCIpXG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KCgpID0+IFtyZWYsIGVscywgb3B0c10sIFwiZXZlbnRcIiwge1xuICAgICAgdHlwZTogXCJob29rXCIsXG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICB2YWx1ZTogcGF5bG9hZCxcbiAgICAgIGNpZDogdGhpcy5jbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KVxuICAgIH0sIChyZXNwLCByZXBseSkgPT4gb25SZXBseShyZXBseSwgcmVmKSlcblxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIGV4dHJhY3RNZXRhKGVsLCBtZXRhLCB2YWx1ZSl7XG4gICAgbGV0IHByZWZpeCA9IHRoaXMuYmluZGluZyhcInZhbHVlLVwiKVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBlbC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmKCFtZXRhKXsgbWV0YSA9IHt9IH1cbiAgICAgIGxldCBuYW1lID0gZWwuYXR0cmlidXRlc1tpXS5uYW1lXG4gICAgICBpZihuYW1lLnN0YXJ0c1dpdGgocHJlZml4KSl7IG1ldGFbbmFtZS5yZXBsYWNlKHByZWZpeCwgXCJcIildID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpIH1cbiAgICB9XG4gICAgaWYoZWwudmFsdWUgIT09IHVuZGVmaW5lZCl7XG4gICAgICBpZighbWV0YSl7IG1ldGEgPSB7fSB9XG4gICAgICBtZXRhLnZhbHVlID0gZWwudmFsdWVcblxuICAgICAgaWYoZWwudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIENIRUNLQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlKSA+PSAwICYmICFlbC5jaGVja2VkKXtcbiAgICAgICAgZGVsZXRlIG1ldGEudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYodmFsdWUpe1xuICAgICAgaWYoIW1ldGEpeyBtZXRhID0ge30gfVxuICAgICAgZm9yKGxldCBrZXkgaW4gdmFsdWUpeyBtZXRhW2tleV0gPSB2YWx1ZVtrZXldIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ldGFcbiAgfVxuXG4gIHB1c2hFdmVudCh0eXBlLCBlbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgbWV0YSwgb3B0cyA9IHt9KXtcbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkoKCkgPT4gdGhpcy5wdXRSZWYoW2VsXSwgdHlwZSwgb3B0cyksIFwiZXZlbnRcIiwge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgIHZhbHVlOiB0aGlzLmV4dHJhY3RNZXRhKGVsLCBtZXRhLCBvcHRzLnZhbHVlKSxcbiAgICAgIGNpZDogdGhpcy50YXJnZXRDb21wb25lbnRJRChlbCwgdGFyZ2V0Q3R4LCBvcHRzKVxuICAgIH0pXG4gIH1cblxuICBwdXNoRmlsZVByb2dyZXNzKGZpbGVFbCwgZW50cnlSZWYsIHByb2dyZXNzLCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHRoaXMubGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZmlsZUVsLmZvcm0sICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIHZpZXcucHVzaFdpdGhSZXBseShudWxsLCBcInByb2dyZXNzXCIsIHtcbiAgICAgICAgZXZlbnQ6IGZpbGVFbC5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFBIWF9QUk9HUkVTUykpLFxuICAgICAgICByZWY6IGZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpLFxuICAgICAgICBlbnRyeV9yZWY6IGVudHJ5UmVmLFxuICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3MsXG4gICAgICAgIGNpZDogdmlldy50YXJnZXRDb21wb25lbnRJRChmaWxlRWwuZm9ybSwgdGFyZ2V0Q3R4KVxuICAgICAgfSwgb25SZXBseSlcbiAgICB9KVxuICB9XG5cbiAgcHVzaElucHV0KGlucHV0RWwsIHRhcmdldEN0eCwgZm9yY2VDaWQsIHBoeEV2ZW50LCBvcHRzLCBjYWxsYmFjayl7XG4gICAgbGV0IHVwbG9hZHNcbiAgICBsZXQgY2lkID0gaXNDaWQoZm9yY2VDaWQpID8gZm9yY2VDaWQgOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4KVxuICAgIGxldCByZWZHZW5lcmF0b3IgPSAoKSA9PiB0aGlzLnB1dFJlZihbaW5wdXRFbCwgaW5wdXRFbC5mb3JtXSwgXCJjaGFuZ2VcIiwgb3B0cylcbiAgICBsZXQgZm9ybURhdGFcbiAgICBpZihpbnB1dEVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpKXtcbiAgICAgIGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHtfdGFyZ2V0OiBvcHRzLl90YXJnZXR9LCBbaW5wdXRFbC5uYW1lXSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGlucHV0RWwuZm9ybSwge190YXJnZXQ6IG9wdHMuX3RhcmdldH0pXG4gICAgfVxuICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGlucHV0RWwpICYmIGlucHV0RWwuZmlsZXMgJiYgaW5wdXRFbC5maWxlcy5sZW5ndGggPiAwKXtcbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKGlucHV0RWwsIEFycmF5LmZyb20oaW5wdXRFbC5maWxlcykpXG4gICAgfVxuICAgIHVwbG9hZHMgPSBMaXZlVXBsb2FkZXIuc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKVxuICAgIGxldCBldmVudCA9IHtcbiAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgdXBsb2FkczogdXBsb2FkcyxcbiAgICAgIGNpZDogY2lkXG4gICAgfVxuICAgIHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIFwiZXZlbnRcIiwgZXZlbnQsIHJlc3AgPT4ge1xuICAgICAgRE9NLnNob3dFcnJvcihpbnB1dEVsLCB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKSlcbiAgICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGlucHV0RWwpICYmIGlucHV0RWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtYXV0by11cGxvYWRcIikgIT09IG51bGwpe1xuICAgICAgICBpZihMaXZlVXBsb2FkZXIuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dEVsKS5sZW5ndGggPiAwKXtcbiAgICAgICAgICBsZXQgW3JlZiwgX2Vsc10gPSByZWZHZW5lcmF0b3IoKVxuICAgICAgICAgIHRoaXMudXBsb2FkRmlsZXMoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgsIHJlZiwgY2lkLCAoX3VwbG9hZHMpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3ApXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJBd2FpdGluZ1N1Ym1pdChpbnB1dEVsLmZvcm0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdHJpZ2dlckF3YWl0aW5nU3VibWl0KGZvcm1FbCl7XG4gICAgbGV0IGF3YWl0aW5nU3VibWl0ID0gdGhpcy5nZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKVxuICAgIGlmKGF3YWl0aW5nU3VibWl0KXtcbiAgICAgIGxldCBbX2VsLCBfcmVmLCBfb3B0cywgY2FsbGJhY2tdID0gYXdhaXRpbmdTdWJtaXRcbiAgICAgIHRoaXMuY2FuY2VsU3VibWl0KGZvcm1FbClcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICBnZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKXtcbiAgICByZXR1cm4gdGhpcy5mb3JtU3VibWl0cy5maW5kKChbZWwsIF9yZWYsIF9vcHRzLCBfY2FsbGJhY2tdKSA9PiBlbC5pc1NhbWVOb2RlKGZvcm1FbCkpXG4gIH1cblxuICBzY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCkpeyByZXR1cm4gdHJ1ZSB9XG4gICAgdGhpcy5mb3JtU3VibWl0cy5wdXNoKFtmb3JtRWwsIHJlZiwgb3B0cywgY2FsbGJhY2tdKVxuICB9XG5cbiAgY2FuY2VsU3VibWl0KGZvcm1FbCl7XG4gICAgdGhpcy5mb3JtU3VibWl0cyA9IHRoaXMuZm9ybVN1Ym1pdHMuZmlsdGVyKChbZWwsIHJlZiwgX2NhbGxiYWNrXSkgPT4ge1xuICAgICAgaWYoZWwuaXNTYW1lTm9kZShmb3JtRWwpKXtcbiAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCBvblJlcGx5KXtcbiAgICBsZXQgZmlsdGVySWdub3JlZCA9IGVsID0+IHtcbiAgICAgIGxldCB1c2VySWdub3JlZCA9IGNsb3Nlc3RQaHhCaW5kaW5nKGVsLCBgJHt0aGlzLmJpbmRpbmcoUEhYX1VQREFURSl9PWlnbm9yZWAsIGVsLmZvcm0pXG4gICAgICByZXR1cm4gISh1c2VySWdub3JlZCB8fCBjbG9zZXN0UGh4QmluZGluZyhlbCwgXCJkYXRhLXBoeC11cGRhdGU9aWdub3JlXCIsIGVsLmZvcm0pKVxuICAgIH1cbiAgICBsZXQgZmlsdGVyRGlzYWJsZXMgPSBlbCA9PiB7XG4gICAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKSlcbiAgICB9XG4gICAgbGV0IGZpbHRlckJ1dHRvbiA9IGVsID0+IGVsLnRhZ05hbWUgPT0gXCJCVVRUT05cIlxuXG4gICAgbGV0IGZpbHRlcklucHV0ID0gZWwgPT4gW1wiSU5QVVRcIiwgXCJURVhUQVJFQVwiLCBcIlNFTEVDVFwiXS5pbmNsdWRlcyhlbC50YWdOYW1lKVxuXG4gICAgbGV0IHJlZkdlbmVyYXRvciA9ICgpID0+IHtcbiAgICAgIGxldCBmb3JtRWxlbWVudHMgPSBBcnJheS5mcm9tKGZvcm1FbC5lbGVtZW50cylcbiAgICAgIGxldCBkaXNhYmxlcyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyRGlzYWJsZXMpXG4gICAgICBsZXQgYnV0dG9ucyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyQnV0dG9uKS5maWx0ZXIoZmlsdGVySWdub3JlZClcbiAgICAgIGxldCBpbnB1dHMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlcklucHV0KS5maWx0ZXIoZmlsdGVySWdub3JlZClcblxuICAgICAgYnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBidXR0b24uZGlzYWJsZWQpXG4gICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IHRydWVcbiAgICAgIH0pXG4gICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFksIGlucHV0LnJlYWRPbmx5KVxuICAgICAgICBpbnB1dC5yZWFkT25seSA9IHRydWVcbiAgICAgICAgaWYoaW5wdXQuZmlsZXMpe1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQsIGlucHV0LmRpc2FibGVkKVxuICAgICAgICAgIGlucHV0LmRpc2FibGVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgZm9ybUVsLnNldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX1BBR0VfTE9BRElORyksIFwiXCIpXG4gICAgICByZXR1cm4gdGhpcy5wdXRSZWYoW2Zvcm1FbF0uY29uY2F0KGRpc2FibGVzKS5jb25jYXQoYnV0dG9ucykuY29uY2F0KGlucHV0cyksIFwic3VibWl0XCIsIG9wdHMpXG4gICAgfVxuXG4gICAgbGV0IGNpZCA9IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZm9ybUVsLCB0YXJnZXRDdHgpXG4gICAgaWYoTGl2ZVVwbG9hZGVyLmhhc1VwbG9hZHNJblByb2dyZXNzKGZvcm1FbCkpe1xuICAgICAgbGV0IFtyZWYsIF9lbHNdID0gcmVmR2VuZXJhdG9yKClcbiAgICAgIGxldCBwdXNoID0gKCkgPT4gdGhpcy5wdXNoRm9ybVN1Ym1pdChmb3JtRWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG9wdHMsIG9uUmVwbHkpXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgcHVzaClcbiAgICB9IGVsc2UgaWYoTGl2ZVVwbG9hZGVyLmlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCkubGVuZ3RoID4gMCl7XG4gICAgICBsZXQgW3JlZiwgZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHJveHlSZWZHZW4gPSAoKSA9PiBbcmVmLCBlbHMsIG9wdHNdXG4gICAgICB0aGlzLnVwbG9hZEZpbGVzKGZvcm1FbCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgIGxldCBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oZm9ybUVsLCB7fSlcbiAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHByb3h5UmVmR2VuLCBcImV2ZW50XCIsIHtcbiAgICAgICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgICAgIGNpZDogY2lkXG4gICAgICAgIH0sIG9uUmVwbHkpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGZvcm1FbCwge30pXG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIHtcbiAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgICBjaWQ6IGNpZFxuICAgICAgfSwgb25SZXBseSlcbiAgICB9XG4gIH1cblxuICB1cGxvYWRGaWxlcyhmb3JtRWwsIHRhcmdldEN0eCwgcmVmLCBjaWQsIG9uQ29tcGxldGUpe1xuICAgIGxldCBqb2luQ291bnRBdFVwbG9hZCA9IHRoaXMuam9pbkNvdW50XG4gICAgbGV0IGlucHV0RWxzID0gTGl2ZVVwbG9hZGVyLmFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKVxuICAgIGxldCBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcyA9IGlucHV0RWxzLmxlbmd0aFxuXG4gICAgLy8gZ2V0IGVhY2ggZmlsZSBpbnB1dFxuICAgIGlucHV0RWxzLmZvckVhY2goaW5wdXRFbCA9PiB7XG4gICAgICBsZXQgdXBsb2FkZXIgPSBuZXcgTGl2ZVVwbG9hZGVyKGlucHV0RWwsIHRoaXMsICgpID0+IHtcbiAgICAgICAgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MtLVxuICAgICAgICBpZihudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcyA9PT0gMCl7IG9uQ29tcGxldGUoKSB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy51cGxvYWRlcnNbaW5wdXRFbF0gPSB1cGxvYWRlclxuICAgICAgbGV0IGVudHJpZXMgPSB1cGxvYWRlci5lbnRyaWVzKCkubWFwKGVudHJ5ID0+IGVudHJ5LnRvUHJlZmxpZ2h0UGF5bG9hZCgpKVxuXG4gICAgICBsZXQgcGF5bG9hZCA9IHtcbiAgICAgICAgcmVmOiBpbnB1dEVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgICAgIGNpZDogdGhpcy50YXJnZXRDb21wb25lbnRJRChpbnB1dEVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW1wic2VuZGluZyBwcmVmbGlnaHQgcmVxdWVzdFwiLCBwYXlsb2FkXSlcblxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiYWxsb3dfdXBsb2FkXCIsIHBheWxvYWQsIHJlc3AgPT4ge1xuICAgICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbXCJnb3QgcHJlZmxpZ2h0IHJlc3BvbnNlXCIsIHJlc3BdKVxuICAgICAgICBpZihyZXNwLmVycm9yKXtcbiAgICAgICAgICB0aGlzLnVuZG9SZWZzKHJlZilcbiAgICAgICAgICBsZXQgW2VudHJ5X3JlZiwgcmVhc29uXSA9IHJlc3AuZXJyb3JcbiAgICAgICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbYGVycm9yIGZvciBlbnRyeSAke2VudHJ5X3JlZn1gLCByZWFzb25dKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBvbkVycm9yID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwub25FcnJvcigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmKHRoaXMuam9pbkNvdW50ID09PSBqb2luQ291bnRBdFVwbG9hZCl7IGNhbGxiYWNrKCkgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBsb2FkZXIuaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgdGhpcy5saXZlU29ja2V0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBkaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXNPckJsb2JzKXtcbiAgICBsZXQgaW5wdXRzID0gRE9NLmZpbmRVcGxvYWRJbnB1dHModGhpcy5lbCkuZmlsdGVyKGVsID0+IGVsLm5hbWUgPT09IG5hbWUpXG4gICAgaWYoaW5wdXRzLmxlbmd0aCA9PT0gMCl7IGxvZ0Vycm9yKGBubyBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCkgfVxuICAgIGVsc2UgaWYoaW5wdXRzLmxlbmd0aCA+IDEpeyBsb2dFcnJvcihgZHVwbGljYXRlIGxpdmUgZmlsZSBpbnB1dHMgZm91bmQgbWF0Y2hpbmcgdGhlIG5hbWUgXCIke25hbWV9XCJgKSB9XG4gICAgZWxzZSB7IERPTS5kaXNwYXRjaEV2ZW50KGlucHV0c1swXSwgUEhYX1RSQUNLX1VQTE9BRFMsIHtkZXRhaWw6IHtmaWxlczogZmlsZXNPckJsb2JzfX0pIH1cbiAgfVxuXG4gIHB1c2hGb3JtUmVjb3ZlcnkoZm9ybSwgbmV3Q2lkLCBjYWxsYmFjayl7XG4gICAgdGhpcy5saXZlU29ja2V0LndpdGhpbk93bmVycyhmb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICBsZXQgaW5wdXQgPSBmb3JtLmVsZW1lbnRzWzBdXG4gICAgICBsZXQgcGh4RXZlbnQgPSBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0FVVE9fUkVDT1ZFUikpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcImNoYW5nZVwiKSlcblxuICAgICAgSlMuZXhlYyhcImNoYW5nZVwiLCBwaHhFdmVudCwgdmlldywgaW5wdXQsIFtcInB1c2hcIiwge190YXJnZXQ6IGlucHV0Lm5hbWUsIG5ld0NpZDogbmV3Q2lkLCBjYWxsYmFjazogY2FsbGJhY2t9XSlcbiAgICB9KVxuICB9XG5cbiAgcHVzaExpbmtQYXRjaChocmVmLCB0YXJnZXRFbCwgY2FsbGJhY2spe1xuICAgIGxldCBsaW5rUmVmID0gdGhpcy5saXZlU29ja2V0LnNldFBlbmRpbmdMaW5rKGhyZWYpXG4gICAgbGV0IHJlZkdlbiA9IHRhcmdldEVsID8gKCkgPT4gdGhpcy5wdXRSZWYoW3RhcmdldEVsXSwgXCJjbGlja1wiKSA6IG51bGxcbiAgICBsZXQgZmFsbGJhY2sgPSAoKSA9PiB0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3Qod2luZG93LmxvY2F0aW9uLmhyZWYpXG5cbiAgICBsZXQgcHVzaCA9IHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW4sIFwibGl2ZV9wYXRjaFwiLCB7dXJsOiBocmVmfSwgcmVzcCA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmKHJlc3AubGlua19yZWRpcmVjdCl7XG4gICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcGxhY2VNYWluKGhyZWYsIG51bGwsIGNhbGxiYWNrLCBsaW5rUmVmKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKHRoaXMubGl2ZVNvY2tldC5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSl7XG4gICAgICAgICAgICB0aGlzLmhyZWYgPSBocmVmXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpXG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobGlua1JlZilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYocHVzaCl7XG4gICAgICBwdXNoLnJlY2VpdmUoXCJ0aW1lb3V0XCIsIGZhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBmYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgZm9ybXNGb3JSZWNvdmVyeShodG1sKXtcbiAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gMCl7IHJldHVybiBbXSB9XG5cbiAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuXG4gICAgcmV0dXJuIChcbiAgICAgIERPTS5hbGwodGhpcy5lbCwgYGZvcm1bJHtwaHhDaGFuZ2V9XWApXG4gICAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmlkICYmIHRoaXMub3duc0VsZW1lbnQoZm9ybSkpXG4gICAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmVsZW1lbnRzLmxlbmd0aCA+IDApXG4gICAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0FVVE9fUkVDT1ZFUikpICE9PSBcImlnbm9yZVwiKVxuICAgICAgICAubWFwKGZvcm0gPT4ge1xuICAgICAgICAgIGxldCBuZXdGb3JtID0gdGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yKGBmb3JtW2lkPVwiJHtmb3JtLmlkfVwiXVske3BoeENoYW5nZX09XCIke2Zvcm0uZ2V0QXR0cmlidXRlKHBoeENoYW5nZSl9XCJdYClcbiAgICAgICAgICBpZihuZXdGb3JtKXtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybSwgbmV3Rm9ybSwgdGhpcy50YXJnZXRDb21wb25lbnRJRChuZXdGb3JtKV1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtmb3JtLCBudWxsLCBudWxsXVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmZpbHRlcigoW2Zvcm0sIG5ld0Zvcm0sIG5ld0NpZF0pID0+IG5ld0Zvcm0pXG4gICAgKVxuICB9XG5cbiAgbWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChkZXN0cm95ZWRDSURzKXtcbiAgICBsZXQgd2lsbERlc3Ryb3lDSURzID0gZGVzdHJveWVkQ0lEcy5maWx0ZXIoY2lkID0+IHtcbiAgICAgIHJldHVybiBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsIGNpZCkubGVuZ3RoID09PSAwXG4gICAgfSlcbiAgICBpZih3aWxsRGVzdHJveUNJRHMubGVuZ3RoID4gMCl7XG4gICAgICB0aGlzLnBydW5pbmdDSURzLnB1c2goLi4ud2lsbERlc3Ryb3lDSURzKVxuXG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJjaWRzX3dpbGxfZGVzdHJveVwiLCB7Y2lkczogd2lsbERlc3Ryb3lDSURzfSwgKCkgPT4ge1xuICAgICAgICAvLyBUaGUgY2lkcyBhcmUgZWl0aGVyIGJhY2sgb24gdGhlIHBhZ2Ugb3IgdGhleSB3aWxsIGJlIGZ1bGx5IHJlbW92ZWQsXG4gICAgICAgIC8vIHNvIHdlIGNhbiByZW1vdmUgdGhlbSBmcm9tIHRoZSBwcnVuaW5nQ0lEcy5cbiAgICAgICAgdGhpcy5wcnVuaW5nQ0lEcyA9IHRoaXMucHJ1bmluZ0NJRHMuZmlsdGVyKGNpZCA9PiB3aWxsRGVzdHJveUNJRHMuaW5kZXhPZihjaWQpICE9PSAtMSlcblxuICAgICAgICAvLyBTZWUgaWYgYW55IG9mIHRoZSBjaWRzIHdlIHdhbnRlZCB0byBkZXN0cm95IHdlcmUgYWRkZWQgYmFjayxcbiAgICAgICAgLy8gaWYgdGhleSB3ZXJlIGFkZGVkIGJhY2ssIHdlIGRvbid0IGFjdHVhbGx5IGRlc3Ryb3kgdGhlbS5cbiAgICAgICAgbGV0IGNvbXBsZXRlbHlEZXN0cm95Q0lEcyA9IHdpbGxEZXN0cm95Q0lEcy5maWx0ZXIoY2lkID0+IHtcbiAgICAgICAgICByZXR1cm4gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBjaWQpLmxlbmd0aCA9PT0gMFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmKGNvbXBsZXRlbHlEZXN0cm95Q0lEcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJjaWRzX2Rlc3Ryb3llZFwiLCB7Y2lkczogY29tcGxldGVseURlc3Ryb3lDSURzfSwgKHJlc3ApID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWQucHJ1bmVDSURzKHJlc3AuY2lkcylcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIG93bnNFbGVtZW50KGVsKXtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpID09PSB0aGlzLmlkIHx8XG4gICAgICBtYXliZShlbC5jbG9zZXN0KFBIWF9WSUVXX1NFTEVDVE9SKSwgbm9kZSA9PiBub2RlLmlkKSA9PT0gdGhpcy5pZFxuICB9XG5cbiAgc3VibWl0Rm9ybShmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzID0ge30pe1xuICAgIERPTS5wdXRQcml2YXRlKGZvcm0sIFBIWF9IQVNfU1VCTUlUVEVELCB0cnVlKVxuICAgIGxldCBwaHhGZWVkYmFjayA9IHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9GRUVEQkFDS19GT1IpXG4gICAgbGV0IGlucHV0cyA9IEFycmF5LmZyb20oZm9ybS5lbGVtZW50cylcbiAgICB0aGlzLmxpdmVTb2NrZXQuYmx1ckFjdGl2ZUVsZW1lbnQodGhpcylcbiAgICB0aGlzLnB1c2hGb3JtU3VibWl0KGZvcm0sIHRhcmdldEN0eCwgcGh4RXZlbnQsIG9wdHMsICgpID0+IHtcbiAgICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IERPTS5zaG93RXJyb3IoaW5wdXQsIHBoeEZlZWRiYWNrKSlcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKClcbiAgICB9KVxuICB9XG5cbiAgYmluZGluZyhraW5kKXsgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKGtpbmQpIH1cbn1cbiIsICIvKiogSW5pdGlhbGl6ZXMgdGhlIExpdmVTb2NrZXRcbiAqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuZFBvaW50IC0gVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBgXCJ3c3M6Ly9leGFtcGxlLmNvbS9saXZlXCJgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIi9saXZlXCJgIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICogQHBhcmFtIHtQaG9lbml4LlNvY2tldH0gc29ja2V0IC0gdGhlIHJlcXVpcmVkIFBob2VuaXggU29ja2V0IGNsYXNzIGltcG9ydGVkIGZyb20gXCJwaG9lbml4XCIuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuICogICAgIGltcG9ydCB7TGl2ZVNvY2tldH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcbiAqICAgICBsZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7Li4ufSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbi4gT3V0c2lkZSBvZiBrZXlzIGxpc3RlZCBiZWxvdywgYWxsXG4gKiBjb25maWd1cmF0aW9uIGlzIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgUGhvZW5peCBTb2NrZXQgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMuZGVmYXVsdHNdIC0gVGhlIG9wdGlvbmFsIGRlZmF1bHRzIHRvIHVzZSBmb3IgdmFyaW91cyBiaW5kaW5ncyxcbiAqIHN1Y2ggYXMgYHBoeC1kZWJvdW5jZWAuIFN1cHBvcnRzIHRoZSBmb2xsb3dpbmcga2V5czpcbiAqXG4gKiAgIC0gZGVib3VuY2UgLSB0aGUgbWlsbGlzZWNvbmQgcGh4LWRlYm91bmNlIHRpbWUuIERlZmF1bHRzIDMwMFxuICogICAtIHRocm90dGxlIC0gdGhlIG1pbGxpc2Vjb25kIHBoeC10aHJvdHRsZSB0aW1lLiBEZWZhdWx0cyAzMDBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5wYXJhbXNdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBwYXNzaW5nIGNvbm5lY3QgcGFyYW1zLlxuICogVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIExpdmVWaWV3LiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgKGVsKSA9PiB7dmlldzogZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1teS12aWV3LW5hbWVcIiwgdG9rZW46IHdpbmRvdy5teVRva2VufVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iaW5kaW5nUHJlZml4XSAtIFRoZSBvcHRpb25hbCBwcmVmaXggdG8gdXNlIGZvciBhbGwgcGh4IERPTSBhbm5vdGF0aW9ucy5cbiAqIERlZmF1bHRzIHRvIFwicGh4LVwiLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmhvb2tzXSAtIFRoZSBvcHRpb25hbCBvYmplY3QgZm9yIHJlZmVyZW5jaW5nIExpdmVWaWV3IGhvb2sgY2FsbGJhY2tzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnVwbG9hZGVyc10gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IGZvciByZWZlcmVuY2luZyBMaXZlVmlldyB1cGxvYWRlciBjYWxsYmFja3MuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLmxvYWRlclRpbWVvdXRdIC0gVGhlIG9wdGlvbmFsIGRlbGF5IGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhcHBseVxuICogbG9hZGluZyBzdGF0ZXMuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLm1heFJlbG9hZHNdIC0gVGhlIG1heGltdW0gcmVsb2FkcyBiZWZvcmUgZW50ZXJpbmcgZmFpbHNhZmUgbW9kZS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMucmVsb2FkSml0dGVyTWluXSAtIFRoZSBtaW5pbXVtIHRpbWUgYmV0d2VlbiBub3JtYWwgcmVsb2FkIGF0dGVtcHRzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5yZWxvYWRKaXR0ZXJNYXhdIC0gVGhlIG1heGltdW0gdGltZSBiZXR3ZWVuIG5vcm1hbCByZWxvYWQgYXR0ZW1wdHMuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLmZhaWxzYWZlSml0dGVyXSAtIFRoZSB0aW1lIGJldHdlZW4gcmVsb2FkIGF0dGVtcHRzIGluIGZhaWxzYWZlIG1vZGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy52aWV3TG9nZ2VyXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0byBsb2cgZGVidWcgaW5mb3JtYXRpb24uIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAodmlldywga2luZCwgbXNnLCBvYmopID0+IGNvbnNvbGUubG9nKGAke3ZpZXcuaWR9ICR7a2luZH06ICR7bXNnfSAtIGAsIG9iailcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubWV0YWRhdGFdIC0gVGhlIG9wdGlvbmFsIG9iamVjdCBtYXBwaW5nIGV2ZW50IG5hbWVzIHRvIGZ1bmN0aW9ucyBmb3JcbiAqIHBvcHVsYXRpbmcgZXZlbnQgbWV0YWRhdGEuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBtZXRhZGF0YToge1xuICogICAgICAgY2xpY2s6IChlLCBlbCkgPT4ge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAqICAgICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gKiAgICAgICAgICAgZGV0YWlsOiBlLmRldGFpbCB8fCAxLFxuICogICAgICAgICB9XG4gKiAgICAgICB9LFxuICogICAgICAga2V5ZG93bjogKGUsIGVsKSA9PiB7XG4gKiAgICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgICAga2V5OiBlLmtleSxcbiAqICAgICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gKiAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICogICAgICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMuc2Vzc2lvblN0b3JhZ2VdIC0gQW4gb3B0aW9uYWwgU3RvcmFnZSBjb21wYXRpYmxlIG9iamVjdFxuICogVXNlZnVsIHdoZW4gTGl2ZVZpZXcgd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gYHNlc3Npb25TdG9yYWdlYC4gIEZvciBleGFtcGxlLCBUaGlzIGNvdWxkXG4gKiBoYXBwZW4gaWYgYSBzaXRlIGxvYWRzIGEgY3Jvc3MtZG9tYWluIExpdmVWaWV3IGluIGFuIGlmcmFtZS4gIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICAgIGNsYXNzIEluTWVtb3J5U3RvcmFnZSB7XG4gKiAgICAgICBjb25zdHJ1Y3RvcigpIHsgdGhpcy5zdG9yYWdlID0ge30gfVxuICogICAgICAgZ2V0SXRlbShrZXlOYW1lKSB7IHJldHVybiB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfVxuICogICAgICAgcmVtb3ZlSXRlbShrZXlOYW1lKSB7IGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfVxuICogICAgICAgc2V0SXRlbShrZXlOYW1lLCBrZXlWYWx1ZSkgeyB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gPSBrZXlWYWx1ZSB9XG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5sb2NhbFN0b3JhZ2VdIC0gQW4gb3B0aW9uYWwgU3RvcmFnZSBjb21wYXRpYmxlIG9iamVjdFxuICogVXNlZnVsIGZvciB3aGVuIExpdmVWaWV3IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBsb2NhbFN0b3JhZ2VgLlxuICogU2VlIGBvcHRzLnNlc3Npb25TdG9yYWdlYCBmb3IgZXhhbXBsZXMuXG4qL1xuXG5pbXBvcnQge1xuICBCSU5ESU5HX1BSRUZJWCxcbiAgQ09OU0VDVVRJVkVfUkVMT0FEUyxcbiAgREVGQVVMVFMsXG4gIEZBSUxTQUZFX0pJVFRFUixcbiAgTE9BREVSX1RJTUVPVVQsXG4gIE1BWF9SRUxPQURTLFxuICBQSFhfREVCT1VOQ0UsXG4gIFBIWF9EUk9QX1RBUkdFVCxcbiAgUEhYX0hBU19GT0NVU0VELFxuICBQSFhfS0VZLFxuICBQSFhfTElOS19TVEFURSxcbiAgUEhYX0xJVkVfTElOSyxcbiAgUEhYX0xWX0RFQlVHLFxuICBQSFhfTFZfTEFURU5DWV9TSU0sXG4gIFBIWF9MVl9QUk9GSUxFLFxuICBQSFhfTUFJTixcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfVEhST1RUTEUsXG4gIFBIWF9UUkFDS19VUExPQURTLFxuICBQSFhfU0VTU0lPTixcbiAgUkVMT0FEX0pJVFRFUl9NSU4sXG4gIFJFTE9BRF9KSVRURVJfTUFYLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9uZSxcbiAgY2xvc2VzdFBoeEJpbmRpbmcsXG4gIGNsb3N1cmUsXG4gIGRlYnVnLFxuICBpc09iamVjdCxcbiAgbWF5YmVcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQnJvd3NlciBmcm9tIFwiLi9icm93c2VyXCJcbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBIb29rcyBmcm9tIFwiLi9ob29rc1wiXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuaW1wb3J0IFZpZXcgZnJvbSBcIi4vdmlld1wiXG5pbXBvcnQgSlMgZnJvbSBcIi4vanNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXZlU29ja2V0IHtcbiAgY29uc3RydWN0b3IodXJsLCBwaHhTb2NrZXQsIG9wdHMgPSB7fSl7XG4gICAgdGhpcy51bmxvYWRlZCA9IGZhbHNlXG4gICAgaWYoIXBoeFNvY2tldCB8fCBwaHhTb2NrZXQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIil7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgYSBwaG9lbml4IFNvY2tldCBtdXN0IGJlIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIExpdmVTb2NrZXQgY29uc3RydWN0b3IuIEZvciBleGFtcGxlOlxuXG4gICAgICAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAgICAgICAgICBpbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG4gICAgICAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXG4gICAgICBgKVxuICAgIH1cbiAgICB0aGlzLnNvY2tldCA9IG5ldyBwaHhTb2NrZXQodXJsLCBvcHRzKVxuICAgIHRoaXMuYmluZGluZ1ByZWZpeCA9IG9wdHMuYmluZGluZ1ByZWZpeCB8fCBCSU5ESU5HX1BSRUZJWFxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pXG4gICAgdGhpcy52aWV3TG9nZ2VyID0gb3B0cy52aWV3TG9nZ2VyXG4gICAgdGhpcy5tZXRhZGF0YUNhbGxiYWNrcyA9IG9wdHMubWV0YWRhdGEgfHwge31cbiAgICB0aGlzLmRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihjbG9uZShERUZBVUxUUyksIG9wdHMuZGVmYXVsdHMgfHwge30pXG4gICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gbnVsbFxuICAgIHRoaXMucHJldkFjdGl2ZSA9IG51bGxcbiAgICB0aGlzLnNpbGVuY2VkID0gZmFsc2VcbiAgICB0aGlzLm1haW4gPSBudWxsXG4gICAgdGhpcy5vdXRnb2luZ01haW5FbCA9IG51bGxcbiAgICB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gbnVsbFxuICAgIHRoaXMubGlua1JlZiA9IDFcbiAgICB0aGlzLnJvb3RzID0ge31cbiAgICB0aGlzLmhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgIHRoaXMucGVuZGluZ0xpbmsgPSBudWxsXG4gICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZSh3aW5kb3cubG9jYXRpb24pXG4gICAgdGhpcy5ob29rcyA9IG9wdHMuaG9va3MgfHwge31cbiAgICB0aGlzLnVwbG9hZGVycyA9IG9wdHMudXBsb2FkZXJzIHx8IHt9XG4gICAgdGhpcy5sb2FkZXJUaW1lb3V0ID0gb3B0cy5sb2FkZXJUaW1lb3V0IHx8IExPQURFUl9USU1FT1VUXG4gICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIgPSBudWxsXG4gICAgdGhpcy5tYXhSZWxvYWRzID0gb3B0cy5tYXhSZWxvYWRzIHx8IE1BWF9SRUxPQURTXG4gICAgdGhpcy5yZWxvYWRKaXR0ZXJNaW4gPSBvcHRzLnJlbG9hZEppdHRlck1pbiB8fCBSRUxPQURfSklUVEVSX01JTlxuICAgIHRoaXMucmVsb2FkSml0dGVyTWF4ID0gb3B0cy5yZWxvYWRKaXR0ZXJNYXggfHwgUkVMT0FEX0pJVFRFUl9NQVhcbiAgICB0aGlzLmZhaWxzYWZlSml0dGVyID0gb3B0cy5mYWlsc2FmZUppdHRlciB8fCBGQUlMU0FGRV9KSVRURVJcbiAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IG9wdHMubG9jYWxTdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2VcbiAgICB0aGlzLnNlc3Npb25TdG9yYWdlID0gb3B0cy5zZXNzaW9uU3RvcmFnZSB8fCB3aW5kb3cuc2Vzc2lvblN0b3JhZ2VcbiAgICB0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMgPSBmYWxzZVxuICAgIHRoaXMuZG9tQ2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbih7b25Ob2RlQWRkZWQ6IGNsb3N1cmUoKSwgb25CZWZvcmVFbFVwZGF0ZWQ6IGNsb3N1cmUoKX0sIG9wdHMuZG9tIHx8IHt9KVxuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgVHJhbnNpdGlvblNldCgpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfZSA9PiB7XG4gICAgICB0aGlzLnVubG9hZGVkID0gdHJ1ZVxuICAgIH0pXG4gICAgdGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuaXNVbmxvYWRlZCgpKXtcbiAgICAgICAgLy8gcmVsb2FkIHBhZ2UgaWYgYmVpbmcgcmVzdG9yZWQgZnJvbSBiYWNrL2ZvcndhcmQgY2FjaGUgYW5kIGJyb3dzZXIgZG9lcyBub3QgZW1pdCBcInBhZ2VzaG93XCJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIHB1YmxpY1xuXG4gIGlzUHJvZmlsZUVuYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfUFJPRklMRSkgPT09IFwidHJ1ZVwiIH1cblxuICBpc0RlYnVnRW5hYmxlZCgpeyByZXR1cm4gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9ERUJVRykgPT09IFwidHJ1ZVwiIH1cblxuICBpc0RlYnVnRGlzYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfREVCVUcpID09PSBcImZhbHNlXCIgfVxuXG4gIGVuYWJsZURlYnVnKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwidHJ1ZVwiKSB9XG5cbiAgZW5hYmxlUHJvZmlsaW5nKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfUFJPRklMRSwgXCJ0cnVlXCIpIH1cblxuICBkaXNhYmxlRGVidWcoKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ERUJVRywgXCJmYWxzZVwiKSB9XG5cbiAgZGlzYWJsZVByb2ZpbGluZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEhYX0xWX1BST0ZJTEUpIH1cblxuICBlbmFibGVMYXRlbmN5U2ltKHVwcGVyQm91bmRNcyl7XG4gICAgdGhpcy5lbmFibGVEZWJ1ZygpXG4gICAgY29uc29sZS5sb2coXCJsYXRlbmN5IHNpbXVsYXRvciBlbmFibGVkIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBicm93c2VyIHNlc3Npb24uIENhbGwgZGlzYWJsZUxhdGVuY3lTaW0oKSB0byBkaXNhYmxlXCIpXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSwgdXBwZXJCb3VuZE1zKVxuICB9XG5cbiAgZGlzYWJsZUxhdGVuY3lTaW0oKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSkgfVxuXG4gIGdldExhdGVuY3lTaW0oKXtcbiAgICBsZXQgc3RyID0gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSlcbiAgICByZXR1cm4gc3RyID8gcGFyc2VJbnQoc3RyKSA6IG51bGxcbiAgfVxuXG4gIGdldFNvY2tldCgpeyByZXR1cm4gdGhpcy5zb2NrZXQgfVxuXG4gIGNvbm5lY3QoKXtcbiAgICAvLyBlbmFibGUgZGVidWcgYnkgZGVmYXVsdCBpZiBvbiBsb2NhbGhvc3QgYW5kIG5vdCBleHBsaWNpdGx5IGRpc2FibGVkXG4gICAgaWYod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09PSBcImxvY2FsaG9zdFwiICYmICF0aGlzLmlzRGVidWdEaXNhYmxlZCgpKXsgdGhpcy5lbmFibGVEZWJ1ZygpIH1cbiAgICBsZXQgZG9Db25uZWN0ID0gKCkgPT4ge1xuICAgICAgaWYodGhpcy5qb2luUm9vdFZpZXdzKCkpe1xuICAgICAgICB0aGlzLmJpbmRUb3BMZXZlbEV2ZW50cygpXG4gICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKVxuICAgICAgfSBlbHNlIGlmKHRoaXMubWFpbil7XG4gICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihbXCJjb21wbGV0ZVwiLCBcImxvYWRlZFwiLCBcImludGVyYWN0aXZlXCJdLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSkgPj0gMCl7XG4gICAgICBkb0Nvbm5lY3QoKVxuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiBkb0Nvbm5lY3QoKSlcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0KGNhbGxiYWNrKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIpXG4gICAgdGhpcy5zb2NrZXQuZGlzY29ubmVjdChjYWxsYmFjaylcbiAgfVxuXG4gIHJlcGxhY2VUcmFuc3BvcnQodHJhbnNwb3J0KXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIpXG4gICAgdGhpcy5zb2NrZXQucmVwbGFjZVRyYW5zcG9ydCh0cmFuc3BvcnQpXG4gICAgdGhpcy5jb25uZWN0KClcbiAgfVxuXG4gIGV4ZWNKUyhlbCwgZW5jb2RlZEpTLCBldmVudFR5cGUgPSBudWxsKXtcbiAgICB0aGlzLm93bmVyKGVsLCB2aWV3ID0+IEpTLmV4ZWMoZXZlbnRUeXBlLCBlbmNvZGVkSlMsIHZpZXcsIGVsKSlcbiAgfVxuXG4gIC8vIHByaXZhdGVcblxuICB0cmlnZ2VyRE9NKGtpbmQsIGFyZ3MpeyB0aGlzLmRvbUNhbGxiYWNrc1traW5kXSguLi5hcmdzKSB9XG5cbiAgdGltZShuYW1lLCBmdW5jKXtcbiAgICBpZighdGhpcy5pc1Byb2ZpbGVFbmFibGVkKCkgfHwgIWNvbnNvbGUudGltZSl7IHJldHVybiBmdW5jKCkgfVxuICAgIGNvbnNvbGUudGltZShuYW1lKVxuICAgIGxldCByZXN1bHQgPSBmdW5jKClcbiAgICBjb25zb2xlLnRpbWVFbmQobmFtZSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBsb2codmlldywga2luZCwgbXNnQ2FsbGJhY2spe1xuICAgIGlmKHRoaXMudmlld0xvZ2dlcil7XG4gICAgICBsZXQgW21zZywgb2JqXSA9IG1zZ0NhbGxiYWNrKClcbiAgICAgIHRoaXMudmlld0xvZ2dlcih2aWV3LCBraW5kLCBtc2csIG9iailcbiAgICB9IGVsc2UgaWYodGhpcy5pc0RlYnVnRW5hYmxlZCgpKXtcbiAgICAgIGxldCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKVxuICAgICAgZGVidWcodmlldywga2luZCwgbXNnLCBvYmopXG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdERPTVVwZGF0ZShjYWxsYmFjayl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZnRlcihjYWxsYmFjaylcbiAgfVxuXG4gIHRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lID0gZnVuY3Rpb24oKXt9KXtcbiAgICB0aGlzLnRyYW5zaXRpb25zLmFkZFRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKVxuICB9XG5cbiAgb25DaGFubmVsKGNoYW5uZWwsIGV2ZW50LCBjYil7XG4gICAgY2hhbm5lbC5vbihldmVudCwgZGF0YSA9PiB7XG4gICAgICBsZXQgbGF0ZW5jeSA9IHRoaXMuZ2V0TGF0ZW5jeVNpbSgpXG4gICAgICBpZighbGF0ZW5jeSl7XG4gICAgICAgIGNiKGRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgc2ltdWxhdGluZyAke2xhdGVuY3l9bXMgb2YgbGF0ZW5jeSBmcm9tIHNlcnZlciB0byBjbGllbnRgKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGNiKGRhdGEpLCBsYXRlbmN5KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB3cmFwUHVzaCh2aWV3LCBvcHRzLCBwdXNoKXtcbiAgICBsZXQgbGF0ZW5jeSA9IHRoaXMuZ2V0TGF0ZW5jeVNpbSgpXG4gICAgbGV0IG9sZEpvaW5Db3VudCA9IHZpZXcuam9pbkNvdW50XG4gICAgaWYoIWxhdGVuY3kpe1xuICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpICYmIG9wdHMudGltZW91dCl7XG4gICAgICAgIHJldHVybiBwdXNoKCkucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICAgIGlmKHZpZXcuam9pbkNvdW50ID09PSBvbGRKb2luQ291bnQgJiYgIXZpZXcuaXNEZXN0cm95ZWQoKSl7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXIodmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZyh2aWV3LCBcInRpbWVvdXRcIiwgKCkgPT4gW1wicmVjZWl2ZWQgdGltZW91dCB3aGlsZSBjb21tdW5pY2F0aW5nIHdpdGggc2VydmVyLiBGYWxsaW5nIGJhY2sgdG8gaGFyZCByZWZyZXNoIGZvciByZWNvdmVyeVwiXSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHB1c2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBzaW11bGF0aW5nICR7bGF0ZW5jeX1tcyBvZiBsYXRlbmN5IGZyb20gY2xpZW50IHRvIHNlcnZlcmApXG4gICAgbGV0IGZha2VQdXNoID0ge1xuICAgICAgcmVjZWl2ZXM6IFtdLFxuICAgICAgcmVjZWl2ZShraW5kLCBjYil7IHRoaXMucmVjZWl2ZXMucHVzaChba2luZCwgY2JdKSB9XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYodmlldy5pc0Rlc3Ryb3llZCgpKXsgcmV0dXJuIH1cbiAgICAgIGZha2VQdXNoLnJlY2VpdmVzLnJlZHVjZSgoYWNjLCBba2luZCwgY2JdKSA9PiBhY2MucmVjZWl2ZShraW5kLCBjYiksIHB1c2goKSlcbiAgICB9LCBsYXRlbmN5KVxuICAgIHJldHVybiBmYWtlUHVzaFxuICB9XG5cbiAgcmVsb2FkV2l0aEppdHRlcih2aWV3LCBsb2cpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lcilcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIGxldCBtaW5NcyA9IHRoaXMucmVsb2FkSml0dGVyTWluXG4gICAgbGV0IG1heE1zID0gdGhpcy5yZWxvYWRKaXR0ZXJNYXhcbiAgICBsZXQgYWZ0ZXJNcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXhNcyAtIG1pbk1zICsgMSkpICsgbWluTXNcbiAgICBsZXQgdHJpZXMgPSBCcm93c2VyLnVwZGF0ZUxvY2FsKHRoaXMubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMsIDAsIGNvdW50ID0+IGNvdW50ICsgMSlcbiAgICBpZih0cmllcyA+IHRoaXMubWF4UmVsb2Fkcyl7XG4gICAgICBhZnRlck1zID0gdGhpcy5mYWlsc2FmZUppdHRlclxuICAgIH1cbiAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gaWYgdmlldyBoYXMgcmVjb3ZlcmVkLCBzdWNoIGFzIHRyYW5zcG9ydCByZXBsYWNlZCwgdGhlbiBjYW5jZWxcbiAgICAgIGlmKHZpZXcuaXNEZXN0cm95ZWQoKSB8fCB2aWV3LmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuICAgICAgdmlldy5kZXN0cm95KClcbiAgICAgIGxvZyA/IGxvZygpIDogdGhpcy5sb2codmlldywgXCJqb2luXCIsICgpID0+IFtgZW5jb3VudGVyZWQgJHt0cmllc30gY29uc2VjdXRpdmUgcmVsb2Fkc2BdKVxuICAgICAgaWYodHJpZXMgPiB0aGlzLm1heFJlbG9hZHMpe1xuICAgICAgICB0aGlzLmxvZyh2aWV3LCBcImpvaW5cIiwgKCkgPT4gW2BleGNlZWRlZCAke3RoaXMubWF4UmVsb2Fkc30gY29uc2VjdXRpdmUgcmVsb2Fkcy4gRW50ZXJpbmcgZmFpbHNhZmUgbW9kZWBdKVxuICAgICAgfVxuICAgICAgaWYodGhpcy5oYXNQZW5kaW5nTGluaygpKXtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gdGhpcy5wZW5kaW5nTGlua1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgfSwgYWZ0ZXJNcylcbiAgfVxuXG4gIGdldEhvb2tDYWxsYmFja3MobmFtZSl7XG4gICAgcmV0dXJuIG5hbWUgJiYgbmFtZS5zdGFydHNXaXRoKFwiUGhvZW5peC5cIikgPyBIb29rc1tuYW1lLnNwbGl0KFwiLlwiKVsxXV0gOiB0aGlzLmhvb2tzW25hbWVdXG4gIH1cblxuICBpc1VubG9hZGVkKCl7IHJldHVybiB0aGlzLnVubG9hZGVkIH1cblxuICBpc0Nvbm5lY3RlZCgpeyByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSB9XG5cbiAgZ2V0QmluZGluZ1ByZWZpeCgpeyByZXR1cm4gdGhpcy5iaW5kaW5nUHJlZml4IH1cblxuICBiaW5kaW5nKGtpbmQpeyByZXR1cm4gYCR7dGhpcy5nZXRCaW5kaW5nUHJlZml4KCl9JHtraW5kfWAgfVxuXG4gIGNoYW5uZWwodG9waWMsIHBhcmFtcyl7IHJldHVybiB0aGlzLnNvY2tldC5jaGFubmVsKHRvcGljLCBwYXJhbXMpIH1cblxuICBqb2luUm9vdFZpZXdzKCl7XG4gICAgbGV0IHJvb3RzRm91bmQgPSBmYWxzZVxuICAgIERPTS5hbGwoZG9jdW1lbnQsIGAke1BIWF9WSUVXX1NFTEVDVE9SfTpub3QoWyR7UEhYX1BBUkVOVF9JRH1dKWAsIHJvb3RFbCA9PiB7XG4gICAgICBpZighdGhpcy5nZXRSb290QnlJZChyb290RWwuaWQpKXtcbiAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5ld1Jvb3RWaWV3KHJvb3RFbClcbiAgICAgICAgdmlldy5zZXRIcmVmKHRoaXMuZ2V0SHJlZigpKVxuICAgICAgICB2aWV3LmpvaW4oKVxuICAgICAgICBpZihyb290RWwuaGFzQXR0cmlidXRlKFBIWF9NQUlOKSl7IHRoaXMubWFpbiA9IHZpZXcgfVxuICAgICAgfVxuICAgICAgcm9vdHNGb3VuZCA9IHRydWVcbiAgICB9KVxuICAgIHJldHVybiByb290c0ZvdW5kXG4gIH1cblxuICByZWRpcmVjdCh0bywgZmxhc2gpe1xuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgQnJvd3Nlci5yZWRpcmVjdCh0bywgZmxhc2gpXG4gIH1cblxuICByZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgY2FsbGJhY2sgPSBudWxsLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSl7XG4gICAgdGhpcy5vdXRnb2luZ01haW5FbCA9IHRoaXMub3V0Z29pbmdNYWluRWwgfHwgdGhpcy5tYWluLmVsXG4gICAgbGV0IG5ld01haW5FbCA9IERPTS5jbG9uZU5vZGUodGhpcy5vdXRnb2luZ01haW5FbCwgXCJcIilcbiAgICB0aGlzLm1haW4uc2hvd0xvYWRlcih0aGlzLmxvYWRlclRpbWVvdXQpXG4gICAgdGhpcy5tYWluLmRlc3Ryb3koKVxuXG4gICAgdGhpcy5tYWluID0gdGhpcy5uZXdSb290VmlldyhuZXdNYWluRWwsIGZsYXNoKVxuICAgIHRoaXMubWFpbi5zZXRSZWRpcmVjdChocmVmKVxuICAgIHRoaXMudHJhbnNpdGlvblJlbW92ZXMoKVxuICAgIHRoaXMubWFpbi5qb2luKChqb2luQ291bnQsIG9uRG9uZSkgPT4ge1xuICAgICAgaWYoam9pbkNvdW50ID09PSAxICYmIHRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpe1xuICAgICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIERPTS5maW5kUGh4U3RpY2t5KGRvY3VtZW50KS5mb3JFYWNoKGVsID0+IG5ld01haW5FbC5hcHBlbmRDaGlsZChlbCkpXG4gICAgICAgICAgdGhpcy5vdXRnb2luZ01haW5FbC5yZXBsYWNlV2l0aChuZXdNYWluRWwpXG4gICAgICAgICAgdGhpcy5vdXRnb2luZ01haW5FbCA9IG51bGxcbiAgICAgICAgICBjYWxsYmFjayAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spXG4gICAgICAgICAgb25Eb25lKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdHJhbnNpdGlvblJlbW92ZXMoZWxlbWVudHMpe1xuICAgIGxldCByZW1vdmVBdHRyID0gdGhpcy5iaW5kaW5nKFwicmVtb3ZlXCIpXG4gICAgZWxlbWVudHMgPSBlbGVtZW50cyB8fCBET00uYWxsKGRvY3VtZW50LCBgWyR7cmVtb3ZlQXR0cn1dYClcbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGlmKGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpKXsgLy8gc2tpcCBjaGlsZHJlbiBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgdGhpcy5leGVjSlMoZWwsIGVsLmdldEF0dHJpYnV0ZShyZW1vdmVBdHRyKSwgXCJyZW1vdmVcIilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaXNQaHhWaWV3KGVsKXsgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsIH1cblxuICBuZXdSb290VmlldyhlbCwgZmxhc2gpe1xuICAgIGxldCB2aWV3ID0gbmV3IFZpZXcoZWwsIHRoaXMsIG51bGwsIGZsYXNoKVxuICAgIHRoaXMucm9vdHNbdmlldy5pZF0gPSB2aWV3XG4gICAgcmV0dXJuIHZpZXdcbiAgfVxuXG4gIG93bmVyKGNoaWxkRWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgdmlldyA9IG1heWJlKGNoaWxkRWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIGVsID0+IHRoaXMuZ2V0Vmlld0J5RWwoZWwpKSB8fCB0aGlzLm1haW5cbiAgICBpZih2aWV3KXsgY2FsbGJhY2sodmlldykgfVxuICB9XG5cbiAgd2l0aGluT3duZXJzKGNoaWxkRWwsIGNhbGxiYWNrKXtcbiAgICB0aGlzLm93bmVyKGNoaWxkRWwsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgY2hpbGRFbCkpXG4gIH1cblxuICBnZXRWaWV3QnlFbChlbCl7XG4gICAgbGV0IHJvb3RJZCA9IGVsLmdldEF0dHJpYnV0ZShQSFhfUk9PVF9JRClcbiAgICByZXR1cm4gbWF5YmUodGhpcy5nZXRSb290QnlJZChyb290SWQpLCByb290ID0+IHJvb3QuZ2V0RGVzY2VuZGVudEJ5RWwoZWwpKVxuICB9XG5cbiAgZ2V0Um9vdEJ5SWQoaWQpeyByZXR1cm4gdGhpcy5yb290c1tpZF0gfVxuXG4gIGRlc3Ryb3lBbGxWaWV3cygpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy5yb290cyl7XG4gICAgICB0aGlzLnJvb3RzW2lkXS5kZXN0cm95KClcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW2lkXVxuICAgIH1cbiAgICB0aGlzLm1haW4gPSBudWxsXG4gIH1cblxuICBkZXN0cm95Vmlld0J5RWwoZWwpe1xuICAgIGxldCByb290ID0gdGhpcy5nZXRSb290QnlJZChlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpKVxuICAgIGlmKHJvb3QgJiYgcm9vdC5pZCA9PT0gZWwuaWQpe1xuICAgICAgcm9vdC5kZXN0cm95KClcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW3Jvb3QuaWRdXG4gICAgfSBlbHNlIGlmKHJvb3Qpe1xuICAgICAgcm9vdC5kZXN0cm95RGVzY2VuZGVudChlbC5pZClcbiAgICB9XG4gIH1cblxuICBzZXRBY3RpdmVFbGVtZW50KHRhcmdldCl7XG4gICAgaWYodGhpcy5hY3RpdmVFbGVtZW50ID09PSB0YXJnZXQpeyByZXR1cm4gfVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IHRhcmdldFxuICAgIGxldCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBpZih0YXJnZXQgPT09IHRoaXMuYWN0aXZlRWxlbWVudCl7IHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGwgfVxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMpXG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMpXG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBjYW5jZWwpXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBjYW5jZWwpXG4gIH1cblxuICBnZXRBY3RpdmVFbGVtZW50KCl7XG4gICAgaWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSl7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gYmUgbnVsbCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMVxuICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keVxuICAgIH1cbiAgfVxuXG4gIGRyb3BBY3RpdmVFbGVtZW50KHZpZXcpe1xuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAmJiB2aWV3Lm93bnNFbGVtZW50KHRoaXMucHJldkFjdGl2ZSkpe1xuICAgICAgdGhpcy5wcmV2QWN0aXZlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJlc3RvcmVQcmV2aW91c2x5QWN0aXZlRm9jdXMoKXtcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgJiYgdGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5KXtcbiAgICAgIHRoaXMucHJldkFjdGl2ZS5mb2N1cygpXG4gICAgfVxuICB9XG5cbiAgYmx1ckFjdGl2ZUVsZW1lbnQoKXtcbiAgICB0aGlzLnByZXZBY3RpdmUgPSB0aGlzLmdldEFjdGl2ZUVsZW1lbnQoKVxuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAhPT0gZG9jdW1lbnQuYm9keSl7IHRoaXMucHJldkFjdGl2ZS5ibHVyKCkgfVxuICB9XG5cbiAgYmluZFRvcExldmVsRXZlbnRzKCl7XG4gICAgaWYodGhpcy5ib3VuZFRvcExldmVsRXZlbnRzKXsgcmV0dXJuIH1cblxuICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IHRydWVcbiAgICAvLyBlbnRlciBmYWlsc2FmZSByZWxvYWQgaWYgc2VydmVyIGhhcyBnb25lIGF3YXkgaW50ZW50aW9uYWxseSwgc3VjaCBhcyBcImRpc2Nvbm5lY3RcIiBicm9hZGNhc3RcbiAgICB0aGlzLnNvY2tldC5vbkNsb3NlKGV2ZW50ID0+IHtcbiAgICAgIGlmKGV2ZW50ICYmIGV2ZW50LmNvZGUgPT09IDEwMDAgJiYgdGhpcy5tYWluKXtcbiAgICAgICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyKHRoaXMubWFpbilcbiAgICAgIH1cbiAgICB9KVxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpeyB9KSAvLyBlbnN1cmUgYWxsIGNsaWNrIGV2ZW50cyBidWJibGUgZm9yIG1vYmlsZSBTYWZhcmlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIGUgPT4ge1xuICAgICAgaWYoZS5wZXJzaXN0ZWQpeyAvLyByZWxvYWQgcGFnZSBpZiBiZWluZyByZXN0b3JlZCBmcm9tIGJhY2svZm9yd2FyZCBjYWNoZVxuICAgICAgICB0aGlzLmdldFNvY2tldCgpLmRpc2Nvbm5lY3QoKVxuICAgICAgICB0aGlzLndpdGhQYWdlTG9hZGluZyh7dG86IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBraW5kOiBcInJlZGlyZWN0XCJ9KVxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICB9LCB0cnVlKVxuICAgIHRoaXMuYmluZE5hdigpXG4gICAgdGhpcy5iaW5kQ2xpY2tzKClcbiAgICB0aGlzLmJpbmRGb3JtcygpXG4gICAgdGhpcy5iaW5kKHtrZXl1cDogXCJrZXl1cFwiLCBrZXlkb3duOiBcImtleWRvd25cIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIGV2ZW50VGFyZ2V0KSA9PiB7XG4gICAgICBsZXQgbWF0Y2hLZXkgPSB0YXJnZXRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9LRVkpKVxuICAgICAgbGV0IHByZXNzZWRLZXkgPSBlLmtleSAmJiBlLmtleS50b0xvd2VyQ2FzZSgpIC8vIGNocm9tZSBjbGlja2VkIGF1dG9jb21wbGV0ZXMgc2VuZCBhIGtleWRvd24gd2l0aG91dCBrZXlcbiAgICAgIGlmKG1hdGNoS2V5ICYmIG1hdGNoS2V5LnRvTG93ZXJDYXNlKCkgIT09IHByZXNzZWRLZXkpeyByZXR1cm4gfVxuXG4gICAgICBsZXQgZGF0YSA9IHtrZXk6IGUua2V5LCAuLi50aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbCl9XG4gICAgICBKUy5leGVjKHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgIH0pXG4gICAgdGhpcy5iaW5kKHtibHVyOiBcImZvY3Vzb3V0XCIsIGZvY3VzOiBcImZvY3VzaW5cIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIGV2ZW50VGFyZ2V0KSA9PiB7XG4gICAgICBpZighZXZlbnRUYXJnZXQpe1xuICAgICAgICBsZXQgZGF0YSA9IHtrZXk6IGUua2V5LCAuLi50aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbCl9XG4gICAgICAgIEpTLmV4ZWModHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHtkYXRhfV0pXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmJpbmQoe2JsdXI6IFwiYmx1clwiLCBmb2N1czogXCJmb2N1c1wifSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBwaHhUYXJnZXQpID0+IHtcbiAgICAgIC8vIGJsdXIgYW5kIGZvY3VzIGFyZSB0cmlnZ2VyZWQgb24gZG9jdW1lbnQgYW5kIHdpbmRvdy4gRGlzY2FyZCBvbmUgdG8gYXZvaWQgZHVwc1xuICAgICAgaWYocGh4VGFyZ2V0ID09PSBcIndpbmRvd1wiKXtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbClcbiAgICAgICAgSlMuZXhlYyh0eXBlLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0RWwsIFtcInB1c2hcIiwge2RhdGF9XSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgZSA9PiBlLnByZXZlbnREZWZhdWx0KCkpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBsZXQgZHJvcFRhcmdldElkID0gbWF5YmUoY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKSwgdHJ1ZVRhcmdldCA9PiB7XG4gICAgICAgIHJldHVybiB0cnVlVGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSlcbiAgICAgIH0pXG4gICAgICBsZXQgZHJvcFRhcmdldCA9IGRyb3BUYXJnZXRJZCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcm9wVGFyZ2V0SWQpXG4gICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGF0YVRyYW5zZmVyLmZpbGVzIHx8IFtdKVxuICAgICAgaWYoIWRyb3BUYXJnZXQgfHwgZHJvcFRhcmdldC5kaXNhYmxlZCB8fCBmaWxlcy5sZW5ndGggPT09IDAgfHwgIShkcm9wVGFyZ2V0LmZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpKXsgcmV0dXJuIH1cblxuICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXMoZHJvcFRhcmdldCwgZmlsZXMpXG4gICAgICBkcm9wVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIiwge2J1YmJsZXM6IHRydWV9KSlcbiAgICB9KVxuICAgIHRoaXMub24oUEhYX1RSQUNLX1VQTE9BRFMsIGUgPT4ge1xuICAgICAgbGV0IHVwbG9hZFRhcmdldCA9IGUudGFyZ2V0XG4gICAgICBpZighRE9NLmlzVXBsb2FkSW5wdXQodXBsb2FkVGFyZ2V0KSl7IHJldHVybiB9XG4gICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGV0YWlsLmZpbGVzIHx8IFtdKS5maWx0ZXIoZiA9PiBmIGluc3RhbmNlb2YgRmlsZSB8fCBmIGluc3RhbmNlb2YgQmxvYilcbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKHVwbG9hZFRhcmdldCwgZmlsZXMpXG4gICAgICB1cGxvYWRUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7YnViYmxlczogdHJ1ZX0pKVxuICAgIH0pXG4gIH1cblxuICBldmVudE1ldGEoZXZlbnROYW1lLCBlLCB0YXJnZXRFbCl7XG4gICAgbGV0IGNhbGxiYWNrID0gdGhpcy5tZXRhZGF0YUNhbGxiYWNrc1tldmVudE5hbWVdXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soZSwgdGFyZ2V0RWwpIDoge31cbiAgfVxuXG4gIHNldFBlbmRpbmdMaW5rKGhyZWYpe1xuICAgIHRoaXMubGlua1JlZisrXG4gICAgdGhpcy5wZW5kaW5nTGluayA9IGhyZWZcbiAgICByZXR1cm4gdGhpcy5saW5rUmVmXG4gIH1cblxuICBjb21taXRQZW5kaW5nTGluayhsaW5rUmVmKXtcbiAgICBpZih0aGlzLmxpbmtSZWYgIT09IGxpbmtSZWYpe1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaHJlZiA9IHRoaXMucGVuZGluZ0xpbmtcbiAgICAgIHRoaXMucGVuZGluZ0xpbmsgPSBudWxsXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGdldEhyZWYoKXsgcmV0dXJuIHRoaXMuaHJlZiB9XG5cbiAgaGFzUGVuZGluZ0xpbmsoKXsgcmV0dXJuICEhdGhpcy5wZW5kaW5nTGluayB9XG5cbiAgYmluZChldmVudHMsIGNhbGxiYWNrKXtcbiAgICBmb3IobGV0IGV2ZW50IGluIGV2ZW50cyl7XG4gICAgICBsZXQgYnJvd3NlckV2ZW50TmFtZSA9IGV2ZW50c1tldmVudF1cblxuICAgICAgdGhpcy5vbihicm93c2VyRXZlbnROYW1lLCBlID0+IHtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmcoZXZlbnQpXG4gICAgICAgIGxldCB3aW5kb3dCaW5kaW5nID0gdGhpcy5iaW5kaW5nKGB3aW5kb3ctJHtldmVudH1gKVxuICAgICAgICBsZXQgdGFyZ2V0UGh4RXZlbnQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgZS50YXJnZXQuZ2V0QXR0cmlidXRlKGJpbmRpbmcpXG4gICAgICAgIGlmKHRhcmdldFBoeEV2ZW50KXtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKGUudGFyZ2V0LCBlLCBicm93c2VyRXZlbnROYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGV2ZW50LCB2aWV3LCBlLnRhcmdldCwgdGFyZ2V0UGh4RXZlbnQsIG51bGwpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NLmFsbChkb2N1bWVudCwgYFske3dpbmRvd0JpbmRpbmd9XWAsIGVsID0+IHtcbiAgICAgICAgICAgIGxldCBwaHhFdmVudCA9IGVsLmdldEF0dHJpYnV0ZSh3aW5kb3dCaW5kaW5nKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZShlbCwgZSwgYnJvd3NlckV2ZW50TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlbCwgdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZXZlbnQsIHZpZXcsIGVsLCBwaHhFdmVudCwgXCJ3aW5kb3dcIilcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBiaW5kQ2xpY2tzKCl7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZSA9PiB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gZS50YXJnZXQpXG4gICAgdGhpcy5iaW5kQ2xpY2soXCJjbGlja1wiLCBcImNsaWNrXCIsIGZhbHNlKVxuICAgIHRoaXMuYmluZENsaWNrKFwibW91c2Vkb3duXCIsIFwiY2FwdHVyZS1jbGlja1wiLCB0cnVlKVxuICB9XG5cbiAgYmluZENsaWNrKGV2ZW50TmFtZSwgYmluZGluZ05hbWUsIGNhcHR1cmUpe1xuICAgIGxldCBjbGljayA9IHRoaXMuYmluZGluZyhiaW5kaW5nTmFtZSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGUgPT4ge1xuICAgICAgbGV0IHRhcmdldCA9IG51bGxcbiAgICAgIGlmKGNhcHR1cmUpe1xuICAgICAgICB0YXJnZXQgPSBlLnRhcmdldC5tYXRjaGVzKGBbJHtjbGlja31dYCkgPyBlLnRhcmdldCA6IGUudGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoYFske2NsaWNrfV1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCB8fCBlLnRhcmdldFxuICAgICAgICB0YXJnZXQgPSBjbG9zZXN0UGh4QmluZGluZyhjbGlja1N0YXJ0ZWRBdFRhcmdldCwgY2xpY2spXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hDbGlja0F3YXkoZSwgY2xpY2tTdGFydGVkQXRUYXJnZXQpXG4gICAgICAgIHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgPSBudWxsXG4gICAgICB9XG4gICAgICBsZXQgcGh4RXZlbnQgPSB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShjbGljaylcbiAgICAgIGlmKCFwaHhFdmVudCl7IHJldHVybiB9XG4gICAgICBpZih0YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIpeyBlLnByZXZlbnREZWZhdWx0KCkgfVxuXG4gICAgICB0aGlzLmRlYm91bmNlKHRhcmdldCwgZSwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMud2l0aGluT3duZXJzKHRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgICAgSlMuZXhlYyhcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXQsIFtcInB1c2hcIiwge2RhdGE6IHRoaXMuZXZlbnRNZXRhKFwiY2xpY2tcIiwgZSwgdGFyZ2V0KX1dKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9LCBjYXB0dXJlKVxuICB9XG5cbiAgZGlzcGF0Y2hDbGlja0F3YXkoZSwgY2xpY2tTdGFydGVkQXQpe1xuICAgIGxldCBwaHhDbGlja0F3YXkgPSB0aGlzLmJpbmRpbmcoXCJjbGljay1hd2F5XCIpXG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske3BoeENsaWNrQXdheX1dYCwgZWwgPT4ge1xuICAgICAgaWYoIShlbC5pc1NhbWVOb2RlKGNsaWNrU3RhcnRlZEF0KSB8fCBlbC5jb250YWlucyhjbGlja1N0YXJ0ZWRBdCkpKXtcbiAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgIGxldCBwaHhFdmVudCA9IGVsLmdldEF0dHJpYnV0ZShwaHhDbGlja0F3YXkpXG4gICAgICAgICAgaWYoSlMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICAgICAgICBKUy5leGVjKFwiY2xpY2tcIiwgcGh4RXZlbnQsIHZpZXcsIGVsLCBbXCJwdXNoXCIsIHtkYXRhOiB0aGlzLmV2ZW50TWV0YShcImNsaWNrXCIsIGUsIGUudGFyZ2V0KX1dKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYmluZE5hdigpe1xuICAgIGlmKCFCcm93c2VyLmNhblB1c2hTdGF0ZSgpKXsgcmV0dXJuIH1cbiAgICBpZihoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uKXsgaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCIgfVxuICAgIGxldCBzY3JvbGxUaW1lciA9IG51bGxcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBfZSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsVGltZXIpXG4gICAgICBzY3JvbGxUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBCcm93c2VyLnVwZGF0ZUN1cnJlbnRTdGF0ZShzdGF0ZSA9PiBPYmplY3QuYXNzaWduKHN0YXRlLCB7c2Nyb2xsOiB3aW5kb3cuc2Nyb2xsWX0pKVxuICAgICAgfSwgMTAwKVxuICAgIH0pXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBldmVudCA9PiB7XG4gICAgICBpZighdGhpcy5yZWdpc3Rlck5ld0xvY2F0aW9uKHdpbmRvdy5sb2NhdGlvbikpeyByZXR1cm4gfVxuICAgICAgbGV0IHt0eXBlLCBpZCwgcm9vdCwgc2Nyb2xsfSA9IGV2ZW50LnN0YXRlIHx8IHt9XG4gICAgICBsZXQgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG5cbiAgICAgIHRoaXMucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmKHRoaXMubWFpbi5pc0Nvbm5lY3RlZCgpICYmICh0eXBlID09PSBcInBhdGNoXCIgJiYgaWQgPT09IHRoaXMubWFpbi5pZCkpe1xuICAgICAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGhyZWYsIG51bGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZXBsYWNlTWFpbihocmVmLCBudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICBpZihyb290KXsgdGhpcy5yZXBsYWNlUm9vdEhpc3RvcnkoKSB9XG4gICAgICAgICAgICBpZih0eXBlb2Yoc2Nyb2xsKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzY3JvbGwpXG4gICAgICAgICAgICAgIH0sIDApIC8vIHRoZSBib2R5IG5lZWRzIHRvIHJlbmRlciBiZWZvcmUgd2Ugc2Nyb2xsLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSwgZmFsc2UpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlID0+IHtcbiAgICAgIGxldCB0YXJnZXQgPSBjbG9zZXN0UGh4QmluZGluZyhlLnRhcmdldCwgUEhYX0xJVkVfTElOSylcbiAgICAgIGxldCB0eXBlID0gdGFyZ2V0ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoUEhYX0xJVkVfTElOSylcbiAgICAgIGxldCB3YW50c05ld1RhYiA9IGUubWV0YUtleSB8fCBlLmN0cmxLZXkgfHwgZS5idXR0b24gPT09IDFcbiAgICAgIGlmKCF0eXBlIHx8ICF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMubWFpbiB8fCB3YW50c05ld1RhYil7IHJldHVybiB9XG5cbiAgICAgIGxldCBocmVmID0gdGFyZ2V0LmhyZWZcbiAgICAgIGxldCBsaW5rU3RhdGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSU5LX1NUQVRFKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIC8vIGRvIG5vdCBidWJibGUgY2xpY2sgdG8gcmVndWxhciBwaHgtY2xpY2sgYmluZGluZ3NcbiAgICAgIGlmKHRoaXMucGVuZGluZ0xpbmsgPT09IGhyZWYpeyByZXR1cm4gfVxuXG4gICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZih0eXBlID09PSBcInBhdGNoXCIpe1xuICAgICAgICAgIHRoaXMucHVzaEhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIHRhcmdldClcbiAgICAgICAgfSBlbHNlIGlmKHR5cGUgPT09IFwicmVkaXJlY3RcIil7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5UmVkaXJlY3QoaHJlZiwgbGlua1N0YXRlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHtQSFhfTElWRV9MSU5LfSB0byBiZSBcInBhdGNoXCIgb3IgXCJyZWRpcmVjdFwiLCBnb3Q6ICR7dHlwZX1gKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICB9XG5cbiAgZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9KXtcbiAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIGBwaHg6JHtldmVudH1gLCB7ZGV0YWlsOiBwYXlsb2FkfSlcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnRzKGV2ZW50cyl7XG4gICAgZXZlbnRzLmZvckVhY2goKFtldmVudCwgcGF5bG9hZF0pID0+IHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCkpXG4gIH1cblxuICB3aXRoUGFnZUxvYWRpbmcoaW5mbywgY2FsbGJhY2spe1xuICAgIERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIHtkZXRhaWw6IGluZm99KVxuICAgIGxldCBkb25lID0gKCkgPT4gRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLCB7ZGV0YWlsOiBpbmZvfSlcbiAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhkb25lKSA6IGRvbmVcbiAgfVxuXG4gIHB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXRFbCl7XG4gICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiBocmVmLCBraW5kOiBcInBhdGNoXCJ9LCBkb25lID0+IHtcbiAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGhyZWYsIHRhcmdldEVsLCBsaW5rUmVmID0+IHtcbiAgICAgICAgdGhpcy5oaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmKVxuICAgICAgICBkb25lKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIGxpbmtSZWYgPSB0aGlzLnNldFBlbmRpbmdMaW5rKGhyZWYpKXtcbiAgICBpZighdGhpcy5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSl7IHJldHVybiB9XG5cbiAgICBCcm93c2VyLnB1c2hTdGF0ZShsaW5rU3RhdGUsIHt0eXBlOiBcInBhdGNoXCIsIGlkOiB0aGlzLm1haW4uaWR9LCBocmVmKVxuICAgIHRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pXG4gIH1cblxuICBoaXN0b3J5UmVkaXJlY3QoaHJlZiwgbGlua1N0YXRlLCBmbGFzaCl7XG4gICAgbGV0IHNjcm9sbCA9IHdpbmRvdy5zY3JvbGxZXG4gICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiBocmVmLCBraW5kOiBcInJlZGlyZWN0XCJ9LCBkb25lID0+IHtcbiAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsICgpID0+IHtcbiAgICAgICAgQnJvd3Nlci5wdXNoU3RhdGUobGlua1N0YXRlLCB7dHlwZTogXCJyZWRpcmVjdFwiLCBpZDogdGhpcy5tYWluLmlkLCBzY3JvbGw6IHNjcm9sbH0sIGhyZWYpXG4gICAgICAgIHRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pXG4gICAgICAgIGRvbmUoKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmVwbGFjZVJvb3RIaXN0b3J5KCl7XG4gICAgQnJvd3Nlci5wdXNoU3RhdGUoXCJyZXBsYWNlXCIsIHtyb290OiB0cnVlLCB0eXBlOiBcInBhdGNoXCIsIGlkOiB0aGlzLm1haW4uaWR9KVxuICB9XG5cbiAgcmVnaXN0ZXJOZXdMb2NhdGlvbihuZXdMb2NhdGlvbil7XG4gICAgbGV0IHtwYXRobmFtZSwgc2VhcmNofSA9IHRoaXMuY3VycmVudExvY2F0aW9uXG4gICAgaWYocGF0aG5hbWUgKyBzZWFyY2ggPT09IG5ld0xvY2F0aW9uLnBhdGhuYW1lICsgbmV3TG9jYXRpb24uc2VhcmNoKXtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGNsb25lKG5ld0xvY2F0aW9uKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBiaW5kRm9ybXMoKXtcbiAgICBsZXQgaXRlcmF0aW9ucyA9IDBcbiAgICB0aGlzLm9uKFwic3VibWl0XCIsIGUgPT4ge1xuICAgICAgbGV0IHBoeEV2ZW50ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInN1Ym1pdFwiKSlcbiAgICAgIGlmKCFwaHhFdmVudCl7IHJldHVybiB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUudGFyZ2V0LmRpc2FibGVkID0gdHJ1ZVxuICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICBKUy5leGVjKFwic3VibWl0XCIsIHBoeEV2ZW50LCB2aWV3LCBlLnRhcmdldCwgW1wicHVzaFwiLCB7fV0pXG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuXG4gICAgZm9yKGxldCB0eXBlIG9mIFtcImNoYW5nZVwiLCBcImlucHV0XCJdKXtcbiAgICAgIHRoaXMub24odHlwZSwgZSA9PiB7XG4gICAgICAgIGxldCBwaHhDaGFuZ2UgPSB0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIilcbiAgICAgICAgbGV0IGlucHV0ID0gZS50YXJnZXRcbiAgICAgICAgbGV0IGlucHV0RXZlbnQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKVxuICAgICAgICBsZXQgZm9ybUV2ZW50ID0gaW5wdXQuZm9ybSAmJiBpbnB1dC5mb3JtLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpXG4gICAgICAgIGxldCBwaHhFdmVudCA9IGlucHV0RXZlbnQgfHwgZm9ybUV2ZW50XG4gICAgICAgIGlmKCFwaHhFdmVudCl7IHJldHVybiB9XG4gICAgICAgIGlmKGlucHV0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5wdXQudmFsaWRpdHkgJiYgaW5wdXQudmFsaWRpdHkuYmFkSW5wdXQpeyByZXR1cm4gfVxuXG4gICAgICAgIGxldCBkaXNwYXRjaGVyID0gaW5wdXRFdmVudCA/IGlucHV0IDogaW5wdXQuZm9ybVxuICAgICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zXG4gICAgICAgIGl0ZXJhdGlvbnMrK1xuICAgICAgICBsZXQge2F0OiBhdCwgdHlwZTogbGFzdFR5cGV9ID0gRE9NLnByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIikgfHwge31cbiAgICAgICAgLy8gZGV0ZWN0IGR1cCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgZGlzcGF0Y2ggYm90aCBcImlucHV0XCIgYW5kIFwiY2hhbmdlXCJcbiAgICAgICAgaWYoYXQgPT09IGN1cnJlbnRJdGVyYXRpb25zIC0gMSAmJiB0eXBlICE9PSBsYXN0VHlwZSl7IHJldHVybiB9XG5cbiAgICAgICAgRE9NLnB1dFByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIiwge2F0OiBjdXJyZW50SXRlcmF0aW9ucywgdHlwZTogdHlwZX0pXG5cbiAgICAgICAgdGhpcy5kZWJvdW5jZShpbnB1dCwgZSwgdHlwZSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGRpc3BhdGNoZXIsIHZpZXcgPT4ge1xuICAgICAgICAgICAgRE9NLnB1dFByaXZhdGUoaW5wdXQsIFBIWF9IQVNfRk9DVVNFRCwgdHJ1ZSlcbiAgICAgICAgICAgIGlmKCFET00uaXNUZXh0dWFsSW5wdXQoaW5wdXQpKXtcbiAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVFbGVtZW50KGlucHV0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSlMuZXhlYyhcImNoYW5nZVwiLCBwaHhFdmVudCwgdmlldywgaW5wdXQsIFtcInB1c2hcIiwge190YXJnZXQ6IGUudGFyZ2V0Lm5hbWUsIGRpc3BhdGNoZXI6IGRpc3BhdGNoZXJ9XSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSwgZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgZGVib3VuY2UoZWwsIGV2ZW50LCBldmVudFR5cGUsIGNhbGxiYWNrKXtcbiAgICBpZihldmVudFR5cGUgPT09IFwiYmx1clwiIHx8IGV2ZW50VHlwZSA9PT0gXCJmb2N1c291dFwiKXsgcmV0dXJuIGNhbGxiYWNrKCkgfVxuXG4gICAgbGV0IHBoeERlYm91bmNlID0gdGhpcy5iaW5kaW5nKFBIWF9ERUJPVU5DRSlcbiAgICBsZXQgcGh4VGhyb3R0bGUgPSB0aGlzLmJpbmRpbmcoUEhYX1RIUk9UVExFKVxuICAgIGxldCBkZWZhdWx0RGVib3VuY2UgPSB0aGlzLmRlZmF1bHRzLmRlYm91bmNlLnRvU3RyaW5nKClcbiAgICBsZXQgZGVmYXVsdFRocm90dGxlID0gdGhpcy5kZWZhdWx0cy50aHJvdHRsZS50b1N0cmluZygpXG5cbiAgICB0aGlzLndpdGhpbk93bmVycyhlbCwgdmlldyA9PiB7XG4gICAgICBsZXQgYXN5bmNGaWx0ZXIgPSAoKSA9PiAhdmlldy5pc0Rlc3Ryb3llZCgpICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpXG4gICAgICBET00uZGVib3VuY2UoZWwsIGV2ZW50LCBwaHhEZWJvdW5jZSwgZGVmYXVsdERlYm91bmNlLCBwaHhUaHJvdHRsZSwgZGVmYXVsdFRocm90dGxlLCBhc3luY0ZpbHRlciwgKCkgPT4ge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBzaWxlbmNlRXZlbnRzKGNhbGxiYWNrKXtcbiAgICB0aGlzLnNpbGVuY2VkID0gdHJ1ZVxuICAgIGNhbGxiYWNrKClcbiAgICB0aGlzLnNpbGVuY2VkID0gZmFsc2VcbiAgfVxuXG4gIG9uKGV2ZW50LCBjYWxsYmFjayl7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGUgPT4ge1xuICAgICAgaWYoIXRoaXMuc2lsZW5jZWQpeyBjYWxsYmFjayhlKSB9XG4gICAgfSlcbiAgfVxufVxuXG5jbGFzcyBUcmFuc2l0aW9uU2V0IHtcbiAgY29uc3RydWN0b3IoKXtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFNldCgpXG4gICAgdGhpcy5wZW5kaW5nT3BzID0gW11cbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIHJlc2V0KCl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5mb3JFYWNoKHRpbWVyID0+IHtcbiAgICAgIGNhbmNlbFRpbWVvdXQodGltZXIpXG4gICAgICB0aGlzLnRyYW5zaXRpb25zLmRlbGV0ZSh0aW1lcilcbiAgICB9KVxuICAgIHRoaXMuZmx1c2hQZW5kaW5nT3BzKClcbiAgfVxuXG4gIGFmdGVyKGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLnNpemUoKSA9PT0gMCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaFBlbmRpbmdPcChjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBhZGRUcmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSl7XG4gICAgb25TdGFydCgpXG4gICAgbGV0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25zLmRlbGV0ZSh0aW1lcilcbiAgICAgIG9uRG9uZSgpXG4gICAgICBpZih0aGlzLnNpemUoKSA9PT0gMCl7IHRoaXMuZmx1c2hQZW5kaW5nT3BzKCkgfVxuICAgIH0sIHRpbWUpXG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZGQodGltZXIpXG4gIH1cblxuICBwdXNoUGVuZGluZ09wKG9wKXsgdGhpcy5wZW5kaW5nT3BzLnB1c2gob3ApIH1cblxuICBzaXplKCl7IHJldHVybiB0aGlzLnRyYW5zaXRpb25zLnNpemUgfVxuXG4gIGZsdXNoUGVuZGluZ09wcygpe1xuICAgIHRoaXMucGVuZGluZ09wcy5mb3JFYWNoKG9wID0+IG9wKCkpXG4gICAgdGhpcy5wZW5kaW5nT3BzID0gW11cbiAgfVxufVxuIiwgImNsYXNzIEFic3RyYWN0RXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcblxuICAgIHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XG4gIH1cblxuICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jYW5jZWxhYmxlO1xuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuX2NhbmNlbGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNhbmNlbGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW5jZWxlZDtcbiAgfVxuXG4gIGNsb25lKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Ioe1xuICAgICAgLi4udGhpcy5kYXRhLFxuICAgICAgLi4uZGF0YVxuICAgIH0pO1xuICB9XG59XG5cbkFic3RyYWN0RXZlbnQudHlwZSA9ICdldmVudCc7XG5cbkFic3RyYWN0RXZlbnQuY2FuY2VsYWJsZSA9IGZhbHNlO1xuXG5leHBvcnQgeyBBYnN0cmFjdEV2ZW50IH07XG4iLCAiY2xhc3MgQWJzdHJhY3RQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIHRoaXMuZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuXG5leHBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9O1xuIiwgImNvbnN0IGRlZmF1bHREZWxheSA9IHtcbiAgbW91c2U6IDAsXG4gIGRyYWc6IDAsXG4gIHRvdWNoOiAxMDBcbn07XG5cbmNsYXNzIFNlbnNvciB7XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcblxuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi5jb250YWluZXJzXTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcblxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuXG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcblxuICAgIHRoaXMuZGVsYXkgPSBjYWxjRGVsYXkob3B0aW9ucy5kZWxheSk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRDb250YWluZXIoLi4uY29udGFpbmVycykge1xuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi50aGlzLmNvbnRhaW5lcnMsIC4uLmNvbnRhaW5lcnNdO1xuICB9XG5cbiAgcmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSB0aGlzLmNvbnRhaW5lcnMuZmlsdGVyKGNvbnRhaW5lciA9PiAhY29udGFpbmVycy5pbmNsdWRlcyhjb250YWluZXIpKTtcbiAgfVxuXG4gIHRyaWdnZXIoZWxlbWVudCwgc2Vuc29yRXZlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmRldGFpbCA9IHNlbnNvckV2ZW50O1xuICAgIGV2ZW50LmluaXRFdmVudChzZW5zb3JFdmVudC50eXBlLCB0cnVlLCB0cnVlKTtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHRoaXMubGFzdEV2ZW50ID0gc2Vuc29yRXZlbnQ7XG4gICAgcmV0dXJuIHNlbnNvckV2ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGNEZWxheShvcHRpb25zRGVsYXkpIHtcbiAgY29uc3QgZGVsYXkgPSB7fTtcbiAgaWYgKG9wdGlvbnNEZWxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHREZWxheVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zRGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdERlbGF5KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmF1bHREZWxheSwga2V5KSkge1xuICAgICAgICBkZWxheVtrZXldID0gb3B0aW9uc0RlbGF5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdERlbGF5KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZhdWx0RGVsYXksIGtleSkpIHtcbiAgICAgIGlmIChvcHRpb25zRGVsYXlba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGF5W2tleV0gPSBkZWZhdWx0RGVsYXlba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGF5W2tleV0gPSBvcHRpb25zRGVsYXlba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlbGF5O1xufVxuXG5leHBvcnQgeyBTZW5zb3IgYXMgZGVmYXVsdCB9O1xuIiwgImZ1bmN0aW9uIGNsb3Nlc3Qobm9kZSwgdmFsdWUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNvbmRpdGlvbkZuKGN1cnJlbnROb2RlKSB7XG4gICAgaWYgKGN1cnJlbnROb2RlID09IG51bGwgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNTZWxlY3Rvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzLmNhbGwoY3VycmVudE5vZGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTm9kZUxpc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gWy4uLnZhbHVlXS5pbmNsdWRlcyhjdXJyZW50Tm9kZSk7XG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZShjdXJyZW50Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgbGV0IGN1cnJlbnQgPSBub2RlO1xuICBkbyB7XG4gICAgY3VycmVudCA9IGN1cnJlbnQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQgfHwgY3VycmVudC5jb3JyZXNwb25kaW5nRWxlbWVudCB8fCBjdXJyZW50O1xuICAgIGlmIChjb25kaXRpb25GbihjdXJyZW50KSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQgPSBjdXJyZW50Py5wYXJlbnROb2RlIHx8IG51bGw7XG4gIH0gd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50KTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1NlbGVjdG9yKHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpO1xufVxuZnVuY3Rpb24gaXNOb2RlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlIGluc3RhbmNlb2YgTm9kZSk7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCB7IGNsb3Nlc3QgYXMgZGVmYXVsdCB9O1xuIiwgImZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICoqIDIgKyAoeTIgLSB5MSkgKiogMik7XG59XG5cbmV4cG9ydCB7IGRpc3RhbmNlIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdEV2ZW50IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL0Fic3RyYWN0RXZlbnQvQWJzdHJhY3RFdmVudC5tanMnO1xuXG5jbGFzcyBTZW5zb3JFdmVudCBleHRlbmRzIEFic3RyYWN0RXZlbnQge1xuXG4gIGdldCBvcmlnaW5hbEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxFdmVudDtcbiAgfVxuXG4gIGdldCBjbGllbnRYKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY2xpZW50WDtcbiAgfVxuXG4gIGdldCBjbGllbnRZKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY2xpZW50WTtcbiAgfVxuXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS50YXJnZXQ7XG4gIH1cblxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY29udGFpbmVyO1xuICB9XG5cbiAgZ2V0IG9yaWdpbmFsU291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxTb3VyY2U7XG4gIH1cblxuICBnZXQgcHJlc3N1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wcmVzc3VyZTtcbiAgfVxufVxuXG5jbGFzcyBEcmFnU3RhcnRTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XG5cbkRyYWdTdGFydFNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpzdGFydCc7XG5jbGFzcyBEcmFnTW92ZVNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cblxuRHJhZ01vdmVTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6bW92ZSc7XG5jbGFzcyBEcmFnU3RvcFNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cblxuRHJhZ1N0b3BTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6c3RvcCc7XG5jbGFzcyBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XG5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6cHJlc3N1cmUnO1xuXG5leHBvcnQgeyBEcmFnTW92ZVNlbnNvckV2ZW50LCBEcmFnUHJlc3N1cmVTZW5zb3JFdmVudCwgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQsIERyYWdTdG9wU2Vuc29yRXZlbnQsIFNlbnNvckV2ZW50IH07XG4iLCAiaW1wb3J0IGNsb3Nlc3QgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2Nsb3Nlc3QvY2xvc2VzdC5tanMnO1xuaW1wb3J0IGRpc3RhbmNlIGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy9kaXN0YW5jZS9kaXN0YW5jZS5tanMnO1xuaW1wb3J0IFNlbnNvciBmcm9tICcuLi9TZW5zb3IvU2Vuc29yLm1qcyc7XG5pbXBvcnQgeyBEcmFnU3RhcnRTZW5zb3JFdmVudCwgRHJhZ01vdmVTZW5zb3JFdmVudCwgRHJhZ1N0b3BTZW5zb3JFdmVudCB9IGZyb20gJy4uL1NlbnNvckV2ZW50L1NlbnNvckV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nID0gU3ltYm9sKCdvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZycpO1xuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XG5jb25zdCBvbk1vdXNlTW92ZSA9IFN5bWJvbCgnb25Nb3VzZU1vdmUnKTtcbmNvbnN0IG9uTW91c2VVcCA9IFN5bWJvbCgnb25Nb3VzZVVwJyk7XG5jb25zdCBzdGFydERyYWcgPSBTeW1ib2woJ3N0YXJ0RHJhZycpO1xuY29uc3Qgb25EaXN0YW5jZUNoYW5nZSA9IFN5bWJvbCgnb25EaXN0YW5jZUNoYW5nZScpO1xuXG5jbGFzcyBNb3VzZVNlbnNvciBleHRlbmRzIFNlbnNvciB7XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcblxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IG51bGw7XG5cbiAgICB0aGlzLnBhZ2VYID0gbnVsbDtcblxuICAgIHRoaXMucGFnZVkgPSBudWxsO1xuICAgIHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddID0gdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlTW92ZV0gPSB0aGlzW29uTW91c2VNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Nb3VzZVVwXSA9IHRoaXNbb25Nb3VzZVVwXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbc3RhcnREcmFnXSA9IHRoaXNbc3RhcnREcmFnXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0gPSB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcbiAgfVxuXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBjbG9zZXN0KGV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZSAmJiBldmVudC50YXJnZXQgJiYgIWNsb3Nlc3QoZXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuaGFuZGxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbFNvdXJjZSA9IGNsb3Nlc3QoZXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICBpZiAoIW9yaWdpbmFsU291cmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRlbGF5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSBldmVudDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9KTtcbiAgICB0aGlzLm9uTW91c2VEb3duQXQgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gb3JpZ2luYWxTb3VyY2U7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcHJldmVudE5hdGl2ZURyYWdTdGFydCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSh7XG4gICAgICAgIHBhZ2VYOiB0aGlzLnBhZ2VYLFxuICAgICAgICBwYWdlWTogdGhpcy5wYWdlWVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkubW91c2UpO1xuICB9XG5cbiAgW3N0YXJ0RHJhZ10oKSB7XG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IHRoaXMuc3RhcnRFdmVudDtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XG4gICAgY29uc3Qgb3JpZ2luYWxTb3VyY2UgPSB0aGlzLm9yaWdpbmFsU291cmNlO1xuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IERyYWdTdGFydFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IHN0YXJ0RXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IHN0YXJ0RXZlbnQuY2xpZW50WSxcbiAgICAgIHRhcmdldDogc3RhcnRFdmVudC50YXJnZXQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IHN0YXJ0RXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddLCB0cnVlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcbiAgICB9XG4gIH1cblxuICBbb25EaXN0YW5jZUNoYW5nZV0oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSQxXG4gICAgfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBzdGFydEV2ZW50LFxuICAgICAgZGVsYXlcbiAgICB9ID0gdGhpcztcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuY3VycmVudENvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aW1lRWxhcHNlZCA9IERhdGUubm93KCkgLSB0aGlzLm9uTW91c2VEb3duQXQ7XG4gICAgY29uc3QgZGlzdGFuY2VUcmF2ZWxsZWQgPSBkaXN0YW5jZShzdGFydEV2ZW50LnBhZ2VYLCBzdGFydEV2ZW50LnBhZ2VZLCBwYWdlWCwgcGFnZVkpIHx8IDA7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XG4gICAgaWYgKHRpbWVFbGFwc2VkIDwgZGVsYXkubW91c2UpIHtcblxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZVRyYXZlbGxlZCA+PSBkaXN0YW5jZSQxKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcbiAgICAgIHRoaXNbc3RhcnREcmFnXSgpO1xuICAgIH1cbiAgfVxuXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IERyYWdNb3ZlU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XG4gIH1cblxuICBbb25Nb3VzZVVwXShldmVudCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdXNlRG93blRpbWVvdXQpO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcHJldmVudE5hdGl2ZURyYWdTdGFydCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBEcmFnU3RvcFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10sIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xuICB9XG5cbiAgW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXZlbnROYXRpdmVEcmFnU3RhcnQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZXhwb3J0IHsgTW91c2VTZW5zb3IgYXMgZGVmYXVsdCB9O1xuIiwgImZ1bmN0aW9uIHRvdWNoQ29vcmRzKGV2ZW50KSB7XG4gIGNvbnN0IHtcbiAgICB0b3VjaGVzLFxuICAgIGNoYW5nZWRUb3VjaGVzXG4gIH0gPSBldmVudDtcbiAgcmV0dXJuIHRvdWNoZXMgJiYgdG91Y2hlc1swXSB8fCBjaGFuZ2VkVG91Y2hlcyAmJiBjaGFuZ2VkVG91Y2hlc1swXTtcbn1cblxuZXhwb3J0IHsgdG91Y2hDb29yZHMgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCBjbG9zZXN0IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy9jbG9zZXN0L2Nsb3Nlc3QubWpzJztcbmltcG9ydCBkaXN0YW5jZSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMvZGlzdGFuY2UvZGlzdGFuY2UubWpzJztcbmltcG9ydCB0b3VjaENvb3JkcyBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMvdG91Y2hDb29yZHMvdG91Y2hDb29yZHMubWpzJztcbmltcG9ydCBTZW5zb3IgZnJvbSAnLi4vU2Vuc29yL1NlbnNvci5tanMnO1xuaW1wb3J0IHsgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQsIERyYWdNb3ZlU2Vuc29yRXZlbnQsIERyYWdTdG9wU2Vuc29yRXZlbnQgfSBmcm9tICcuLi9TZW5zb3JFdmVudC9TZW5zb3JFdmVudC5tanMnO1xuXG5jb25zdCBvblRvdWNoU3RhcnQgPSBTeW1ib2woJ29uVG91Y2hTdGFydCcpO1xuY29uc3Qgb25Ub3VjaEVuZCA9IFN5bWJvbCgnb25Ub3VjaEVuZCcpO1xuY29uc3Qgb25Ub3VjaE1vdmUgPSBTeW1ib2woJ29uVG91Y2hNb3ZlJyk7XG5jb25zdCBzdGFydERyYWcgPSBTeW1ib2woJ3N0YXJ0RHJhZycpO1xuY29uc3Qgb25EaXN0YW5jZUNoYW5nZSA9IFN5bWJvbCgnb25EaXN0YW5jZUNoYW5nZScpO1xuXG5sZXQgcHJldmVudFNjcm9sbGluZyA9IGZhbHNlO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZXZlbnQgPT4ge1xuICBpZiAoIXByZXZlbnRTY3JvbGxpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufSwge1xuICBwYXNzaXZlOiBmYWxzZVxufSk7XG5cbmNsYXNzIFRvdWNoU2Vuc29yIGV4dGVuZHMgU2Vuc29yIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jdXJyZW50U2Nyb2xsYWJsZVBhcmVudCA9IG51bGw7XG5cbiAgICB0aGlzLnRhcFRpbWVvdXQgPSBudWxsO1xuXG4gICAgdGhpcy50b3VjaE1vdmVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnBhZ2VYID0gbnVsbDtcblxuICAgIHRoaXMucGFnZVkgPSBudWxsO1xuICAgIHRoaXNbb25Ub3VjaFN0YXJ0XSA9IHRoaXNbb25Ub3VjaFN0YXJ0XS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Ub3VjaEVuZF0gPSB0aGlzW29uVG91Y2hFbmRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvblRvdWNoTW92ZV0gPSB0aGlzW29uVG91Y2hNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbc3RhcnREcmFnXSA9IHRoaXNbc3RhcnREcmFnXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0gPSB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XG4gIH1cblxuICBbb25Ub3VjaFN0YXJ0XShldmVudCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNsb3Nlc3QoZXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlICYmIGV2ZW50LnRhcmdldCAmJiAhY2xvc2VzdChldmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5oYW5kbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gY2xvc2VzdChldmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIGlmICghb3JpZ2luYWxTb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGlzdGFuY2UgPSAwXG4gICAgfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBkZWxheVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdG91Y2hDb29yZHMoZXZlbnQpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0pO1xuICAgIHRoaXMub25Ub3VjaFN0YXJ0QXQgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gb3JpZ2luYWxTb3VyY2U7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzW29uVG91Y2hFbmRdKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUpO1xuICAgIGlmIChkaXN0YW5jZSkge1xuICAgICAgcHJldmVudFNjcm9sbGluZyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMudGFwVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXNbb25EaXN0YW5jZUNoYW5nZV0oe1xuICAgICAgICB0b3VjaGVzOiBbe1xuICAgICAgICAgIHBhZ2VYOiB0aGlzLnBhZ2VYLFxuICAgICAgICAgIHBhZ2VZOiB0aGlzLnBhZ2VZXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICB9LCBkZWxheS50b3VjaCk7XG4gIH1cblxuICBbc3RhcnREcmFnXSgpIHtcbiAgICBjb25zdCBzdGFydEV2ZW50ID0gdGhpcy5zdGFydEV2ZW50O1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcbiAgICBjb25zdCB0b3VjaCA9IHRvdWNoQ29vcmRzKHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gdGhpcy5vcmlnaW5hbFNvdXJjZTtcbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBEcmFnU3RhcnRTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiB0b3VjaC5wYWdlWCxcbiAgICAgIGNsaWVudFk6IHRvdWNoLnBhZ2VZLFxuICAgICAgdGFyZ2V0OiBzdGFydEV2ZW50LnRhcmdldCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgb3JpZ2luYWxFdmVudDogc3RhcnRFdmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25Ub3VjaE1vdmVdKTtcbiAgICB9XG4gICAgcHJldmVudFNjcm9sbGluZyA9IHRoaXMuZHJhZ2dpbmc7XG4gIH1cblxuICBbb25EaXN0YW5jZUNoYW5nZV0oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2UkMVxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRFdmVudCxcbiAgICAgIGRlbGF5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3RhcnQgPSB0b3VjaENvb3JkcyhzdGFydEV2ZW50KTtcbiAgICBjb25zdCBjdXJyZW50ID0gdG91Y2hDb29yZHMoZXZlbnQpO1xuICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gRGF0ZS5ub3coKSAtIHRoaXMub25Ub3VjaFN0YXJ0QXQ7XG4gICAgY29uc3QgZGlzdGFuY2VUcmF2ZWxsZWQgPSBkaXN0YW5jZShzdGFydC5wYWdlWCwgc3RhcnQucGFnZVksIGN1cnJlbnQucGFnZVgsIGN1cnJlbnQucGFnZVkpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY3VycmVudCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGFwVGltZW91dCk7XG4gICAgaWYgKHRpbWVFbGFwc2VkIDwgZGVsYXkudG91Y2gpIHtcblxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZVRyYXZlbGxlZCA+PSBkaXN0YW5jZSQxKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uRGlzdGFuY2VDaGFuZ2VdKTtcbiAgICAgIHRoaXNbc3RhcnREcmFnXSgpO1xuICAgIH1cbiAgfVxuXG4gIFtvblRvdWNoTW92ZV0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB0b3VjaENvb3JkcyhldmVudCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwYWdlWCAtIHdpbmRvdy5zY3JvbGxYLCBwYWdlWSAtIHdpbmRvdy5zY3JvbGxZKTtcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IERyYWdNb3ZlU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogcGFnZVgsXG4gICAgICBjbGllbnRZOiBwYWdlWSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcbiAgfVxuXG4gIFtvblRvdWNoRW5kXShldmVudCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRhcFRpbWVvdXQpO1xuICAgIHByZXZlbnRTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpc1tvblRvdWNoRW5kXSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvbkRpc3RhbmNlQ2hhbmdlXSk7XG4gICAgaWYgKHRoaXMuY3VycmVudENvbnRhaW5lcikge1xuICAgICAgdGhpcy5jdXJyZW50Q29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uVG91Y2hNb3ZlXSk7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB0b3VjaENvb3JkcyhldmVudCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwYWdlWCAtIHdpbmRvdy5zY3JvbGxYLCBwYWdlWSAtIHdpbmRvdy5zY3JvbGxZKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgRHJhZ1N0b3BTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiBwYWdlWCxcbiAgICAgIGNsaWVudFk6IHBhZ2VZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmV4cG9ydCB7IFRvdWNoU2Vuc29yIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgY2xvc2VzdCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMvY2xvc2VzdC9jbG9zZXN0Lm1qcyc7XG5pbXBvcnQgU2Vuc29yIGZyb20gJy4uL1NlbnNvci9TZW5zb3IubWpzJztcbmltcG9ydCB7IERyYWdTdGFydFNlbnNvckV2ZW50LCBEcmFnTW92ZVNlbnNvckV2ZW50LCBEcmFnU3RvcFNlbnNvckV2ZW50IH0gZnJvbSAnLi4vU2Vuc29yRXZlbnQvU2Vuc29yRXZlbnQubWpzJztcblxuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XG5jb25zdCBvbkRyYWdFbmQgPSBTeW1ib2woJ29uRHJhZ0VuZCcpO1xuY29uc3Qgb25Ecm9wID0gU3ltYm9sKCdvbkRyb3AnKTtcbmNvbnN0IHJlc2V0ID0gU3ltYm9sKCdyZXNldCcpO1xuXG5jbGFzcyBEcmFnU2Vuc29yIGV4dGVuZHMgU2Vuc29yIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGNvbnRhaW5lcnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gbnVsbDtcblxuICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ0VuZF0gPSB0aGlzW29uRHJhZ0VuZF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJvcF0gPSB0aGlzW29uRHJvcF0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xuICB9XG5cbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xuXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQnLCAnJyk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSB0aGlzLm9wdGlvbnMudHlwZTtcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gdGhpcy5kcmFnZ2FibGVFbGVtZW50O1xuICAgIGlmICghb3JpZ2luYWxTb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xuICAgICAgaWYgKGRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH1cblxuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBEcmFnTW92ZVNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcbiAgICBpZiAoIWRyYWdNb3ZlRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gdGhpcy5vcHRpb25zLnR5cGU7XG4gICAgfVxuICB9XG5cbiAgW29uRHJhZ0VuZF0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBEcmFnU3RvcFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcbiAgICB0aGlzW3Jlc2V0XSgpO1xuICB9XG5cbiAgW29uRHJvcF0oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgW29uTW91c2VEb3duXShldmVudCkge1xuXG4gICAgaWYgKGV2ZW50LnRhcmdldCAmJiAoZXZlbnQudGFyZ2V0LmZvcm0gfHwgZXZlbnQudGFyZ2V0LmNvbnRlbnRlZGl0YWJsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNsb3Nlc3QodGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xuICAgIGlmICghdGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlICYmIHRhcmdldCAmJiAhY2xvc2VzdCh0YXJnZXQsIHRoaXMub3B0aW9ucy5oYW5kbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gY2xvc2VzdCh0YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIGlmICghb3JpZ2luYWxTb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IGNsb3Nlc3QoZXZlbnQudGFyZ2V0LCBlbGVtZW50ID0+IGVsZW1lbnQuZHJhZ2dhYmxlKTtcbiAgICBpZiAobmF0aXZlRHJhZ2dhYmxlRWxlbWVudCkge1xuICAgICAgbmF0aXZlRHJhZ2dhYmxlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQ7XG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzW29uRHJhZ092ZXJdLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXNbb25EcmFnRW5kXSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzW29uRHJvcF0sIGZhbHNlKTtcbiAgICB0aGlzLnN0YXJ0RXZlbnQgPSBldmVudDtcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG9yaWdpbmFsU291cmNlLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQgPSBvcmlnaW5hbFNvdXJjZTtcbiAgICB9LCB0aGlzLmRlbGF5LmRyYWcpO1xuICB9XG5cbiAgW29uTW91c2VVcF0oKSB7XG4gICAgdGhpc1tyZXNldF0oKTtcbiAgfVxuXG4gIFtyZXNldF0oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpc1tvbkRyYWdFbmRdLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXNbb25Ecm9wXSwgZmFsc2UpO1xuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZHJhZ2dhYmxlRWxlbWVudCkge1xuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgRHJhZ1NlbnNvciBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IGNsb3Nlc3QgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2Nsb3Nlc3QvY2xvc2VzdC5tanMnO1xuaW1wb3J0IFNlbnNvciBmcm9tICcuLi9TZW5zb3IvU2Vuc29yLm1qcyc7XG5pbXBvcnQgeyBEcmFnU3RhcnRTZW5zb3JFdmVudCwgRHJhZ1N0b3BTZW5zb3JFdmVudCwgRHJhZ01vdmVTZW5zb3JFdmVudCwgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgfSBmcm9tICcuLi9TZW5zb3JFdmVudC9TZW5zb3JFdmVudC5tanMnO1xuXG5jb25zdCBvbk1vdXNlRm9yY2VXaWxsQmVnaW4gPSBTeW1ib2woJ29uTW91c2VGb3JjZVdpbGxCZWdpbicpO1xuY29uc3Qgb25Nb3VzZUZvcmNlRG93biA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlRG93bicpO1xuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XG5jb25zdCBvbk1vdXNlRm9yY2VDaGFuZ2UgPSBTeW1ib2woJ29uTW91c2VGb3JjZUNoYW5nZScpO1xuY29uc3Qgb25Nb3VzZU1vdmUgPSBTeW1ib2woJ29uTW91c2VNb3ZlJyk7XG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xuY29uc3Qgb25Nb3VzZUZvcmNlR2xvYmFsQ2hhbmdlID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2UnKTtcblxuY2xhc3MgRm9yY2VUb3VjaFNlbnNvciBleHRlbmRzIFNlbnNvciB7XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcblxuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XG4gICAgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dID0gdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSA9IHRoaXNbb25Nb3VzZUZvcmNlRG93bl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdID0gdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlTW92ZV0gPSB0aGlzW29uTW91c2VNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Nb3VzZVVwXSA9IHRoaXNbb25Nb3VzZVVwXS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIGZvciAoY29uc3QgY29udGFpbmVyIG9mIHRoaXMuY29udGFpbmVycykge1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLCB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0sIGZhbHNlKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlZG93bicsIHRoaXNbb25Nb3VzZUZvcmNlRG93bl0sIGZhbHNlKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWNoYW5nZWQnLCB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0sIGZhbHNlKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIGZvciAoY29uc3QgY29udGFpbmVyIG9mIHRoaXMuY29udGFpbmVycykge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLCB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0sIGZhbHNlKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNlZG93bicsIHRoaXNbb25Nb3VzZUZvcmNlRG93bl0sIGZhbHNlKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWNoYW5nZWQnLCB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0sIGZhbHNlKTtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xuICB9XG5cbiAgW29uTW91c2VGb3JjZVdpbGxCZWdpbl0oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMubWlnaHREcmFnID0gdHJ1ZTtcbiAgfVxuXG4gIFtvbk1vdXNlRm9yY2VEb3duXShldmVudCkge1xuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgY29uc3QgY29udGFpbmVyID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZSAmJiB0YXJnZXQgJiYgIWNsb3Nlc3QodGFyZ2V0LCB0aGlzLm9wdGlvbnMuaGFuZGxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbFNvdXJjZSA9IGNsb3Nlc3QodGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICBpZiAoIW9yaWdpbmFsU291cmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IERyYWdTdGFydFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XG4gIH1cblxuICBbb25Nb3VzZVVwXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IERyYWdTdG9wU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5taWdodERyYWcgPSBmYWxzZTtcbiAgfVxuXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMubWlnaHREcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IERyYWdNb3ZlU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XG4gIH1cblxuICBbb25Nb3VzZUZvcmNlQ2hhbmdlXShldmVudCkge1xuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IERyYWdQcmVzc3VyZVNlbnNvckV2ZW50KHtcbiAgICAgIHByZXNzdXJlOiBldmVudC53ZWJraXRGb3JjZSxcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnUHJlc3N1cmVFdmVudCk7XG4gIH1cblxuICBbb25Nb3VzZUZvcmNlR2xvYmFsQ2hhbmdlXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQoe1xuICAgICAgcHJlc3N1cmU6IGV2ZW50LndlYmtpdEZvcmNlLFxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1ByZXNzdXJlRXZlbnQpO1xuICB9XG59XG5cbmV4cG9ydCB7IEZvcmNlVG91Y2hTZW5zb3IgYXMgZGVmYXVsdCB9O1xuIiwgImV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sbGlkYWJsZSB9IGZyb20gJy4vQ29sbGlkYWJsZS9Db2xsaWRhYmxlLm1qcyc7XG5pbXBvcnQgJy4vQ29sbGlkYWJsZS9Db2xsaWRhYmxlRXZlbnQvQ29sbGlkYWJsZUV2ZW50Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlc2l6ZU1pcnJvciwgZGVmYXVsdE9wdGlvbnMgYXMgZGVmYXVsdFJlc2l6ZU1pcnJvck9wdGlvbnMgfSBmcm9tICcuL1Jlc2l6ZU1pcnJvci9SZXNpemVNaXJyb3IubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU25hcHBhYmxlIH0gZnJvbSAnLi9TbmFwcGFibGUvU25hcHBhYmxlLm1qcyc7XG5pbXBvcnQgJy4vU25hcHBhYmxlL1NuYXBwYWJsZUV2ZW50L1NuYXBwYWJsZUV2ZW50Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN3YXBBbmltYXRpb24sIGRlZmF1bHRPcHRpb25zIGFzIGRlZmF1bHRTd2FwQW5pbWF0aW9uT3B0aW9ucyB9IGZyb20gJy4vU3dhcEFuaW1hdGlvbi9Td2FwQW5pbWF0aW9uLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNvcnRBbmltYXRpb24sIGRlZmF1bHRPcHRpb25zIGFzIGRlZmF1bHRTb3J0QW5pbWF0aW9uT3B0aW9ucyB9IGZyb20gJy4vU29ydEFuaW1hdGlvbi9Tb3J0QW5pbWF0aW9uLm1qcyc7XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RFdmVudCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9BYnN0cmFjdEV2ZW50L0Fic3RyYWN0RXZlbnQubWpzJztcblxuY2xhc3MgQ29sbGlkYWJsZUV2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5Db2xsaWRhYmxlRXZlbnQudHlwZSA9ICdjb2xsaWRhYmxlJztcblxuY2xhc3MgQ29sbGlkYWJsZUluRXZlbnQgZXh0ZW5kcyBDb2xsaWRhYmxlRXZlbnQge1xuXG4gIGdldCBjb2xsaWRpbmdFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY29sbGlkaW5nRWxlbWVudDtcbiAgfVxufVxuQ29sbGlkYWJsZUluRXZlbnQudHlwZSA9ICdjb2xsaWRhYmxlOmluJztcblxuY2xhc3MgQ29sbGlkYWJsZU91dEV2ZW50IGV4dGVuZHMgQ29sbGlkYWJsZUV2ZW50IHtcblxuICBnZXQgY29sbGlkaW5nRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNvbGxpZGluZ0VsZW1lbnQ7XG4gIH1cbn1cbkNvbGxpZGFibGVPdXRFdmVudC50eXBlID0gJ2NvbGxpZGFibGU6b3V0JztcblxuZXhwb3J0IHsgQ29sbGlkYWJsZUV2ZW50LCBDb2xsaWRhYmxlSW5FdmVudCwgQ29sbGlkYWJsZU91dEV2ZW50IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RQbHVnaW4gfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RQbHVnaW4vQWJzdHJhY3RQbHVnaW4ubWpzJztcbmltcG9ydCBjbG9zZXN0IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy9jbG9zZXN0L2Nsb3Nlc3QubWpzJztcbmltcG9ydCB7IENvbGxpZGFibGVJbkV2ZW50LCBDb2xsaWRhYmxlT3V0RXZlbnQgfSBmcm9tICcuL0NvbGxpZGFibGVFdmVudC9Db2xsaWRhYmxlRXZlbnQubWpzJztcblxuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuY29uc3Qgb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBTeW1ib2woJ29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XG5cbmNsYXNzIENvbGxpZGFibGUgZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvblJlcXVlc3RBbmltYXRpb25GcmFtZV0gPSB0aGlzW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgZ2V0Q29sbGlkYWJsZXMoKSB7XG4gICAgY29uc3QgY29sbGlkYWJsZXMgPSB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLmNvbGxpZGFibGVzO1xuICAgIGlmICh0eXBlb2YgY29sbGlkYWJsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjb2xsaWRhYmxlcykpO1xuICAgIH0gZWxzZSBpZiAoY29sbGlkYWJsZXMgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBjb2xsaWRhYmxlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29sbGlkYWJsZXMpO1xuICAgIH0gZWxzZSBpZiAoY29sbGlkYWJsZXMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgcmV0dXJuIFtjb2xsaWRhYmxlc107XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29sbGlkYWJsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjb2xsaWRhYmxlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgW29uRHJhZ01vdmVdKGV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuc2Vuc29yRXZlbnQudGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdKHRhcmdldCkpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQpIHtcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgIH1cbiAgICBjb25zdCBjb2xsaWRhYmxlSW5FdmVudCA9IG5ldyBDb2xsaWRhYmxlSW5FdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgY29sbGlkaW5nRWxlbWVudDogdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50XG4gICAgfSk7XG4gICAgY29uc3QgY29sbGlkYWJsZU91dEV2ZW50ID0gbmV3IENvbGxpZGFibGVPdXRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgY29sbGlkaW5nRWxlbWVudDogdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudFxuICAgIH0pO1xuICAgIGNvbnN0IGVudGVyaW5nQ29sbGlkYWJsZSA9IEJvb2xlYW4odGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ICYmIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgIT09IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCk7XG4gICAgY29uc3QgbGVhdmluZ0NvbGxpZGFibGUgPSBCb29sZWFuKCF0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgJiYgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudCk7XG4gICAgaWYgKGVudGVyaW5nQ29sbGlkYWJsZSkge1xuICAgICAgaWYgKHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlSW5FdmVudCk7XG4gICAgfSBlbHNlIGlmIChsZWF2aW5nQ29sbGlkYWJsZSkge1xuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ID0gdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50O1xuICB9XG5cbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XG4gICAgY29uc3QgbGFzdENvbGxpZGluZ0VsZW1lbnQgPSB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgfHwgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudDtcbiAgICBjb25zdCBjb2xsaWRhYmxlT3V0RXZlbnQgPSBuZXcgQ29sbGlkYWJsZU91dEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBjb2xsaWRpbmdFbGVtZW50OiBsYXN0Q29sbGlkaW5nRWxlbWVudFxuICAgIH0pO1xuICAgIGlmIChsYXN0Q29sbGlkaW5nRWxlbWVudCkge1xuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xuICB9XG5cbiAgW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXSh0YXJnZXQpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY29sbGlkYWJsZXMgPSB0aGlzLmdldENvbGxpZGFibGVzKCk7XG4gICAgICB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgPSBjbG9zZXN0KHRhcmdldCwgZWxlbWVudCA9PiBjb2xsaWRhYmxlcy5pbmNsdWRlcyhlbGVtZW50KSk7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgeyBDb2xsaWRhYmxlIGFzIGRlZmF1bHQgfTtcbiIsICJmdW5jdGlvbiBjcmVhdGVBZGRJbml0aWFsaXplck1ldGhvZChlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAocikge1xuICAgIGFzc2VydE5vdEZpbmlzaGVkKHQsIFwiYWRkSW5pdGlhbGl6ZXJcIiksIGFzc2VydENhbGxhYmxlKHIsIFwiQW4gaW5pdGlhbGl6ZXJcIiksIGUucHVzaChyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFzc2VydEluc3RhbmNlSWZQcml2YXRlKGUsIHQpIHtcbiAgaWYgKCFlKHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXR0ZW1wdGVkIHRvIGFjY2VzcyBwcml2YXRlIGVsZW1lbnQgb24gbm9uLWluc3RhbmNlXCIpO1xufVxuZnVuY3Rpb24gbWVtYmVyRGVjKGUsIHQsIHIsIGEsIG4sIGksIHMsIG8sIGMsIGwsIHUpIHtcbiAgdmFyIGY7XG4gIHN3aXRjaCAoaSkge1xuICAgIGNhc2UgMTpcbiAgICAgIGYgPSBcImFjY2Vzc29yXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBmID0gXCJtZXRob2RcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGYgPSBcImdldHRlclwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZiA9IFwic2V0dGVyXCI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZiA9IFwiZmllbGRcIjtcbiAgfVxuICB2YXIgZCxcbiAgICBwLFxuICAgIGggPSB7XG4gICAgICBraW5kOiBmLFxuICAgICAgbmFtZTogbyA/IFwiI1wiICsgciA6IHIsXG4gICAgICBzdGF0aWM6IHMsXG4gICAgICBwcml2YXRlOiBvLFxuICAgICAgbWV0YWRhdGE6IHVcbiAgICB9LFxuICAgIHYgPSB7XG4gICAgICB2OiAhMVxuICAgIH07XG4gIGlmICgwICE9PSBpICYmIChoLmFkZEluaXRpYWxpemVyID0gY3JlYXRlQWRkSW5pdGlhbGl6ZXJNZXRob2QobiwgdikpLCBvIHx8IDAgIT09IGkgJiYgMiAhPT0gaSkge1xuICAgIGlmICgyID09PSBpKSBkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBhc3NlcnRJbnN0YW5jZUlmUHJpdmF0ZShsLCBlKSwgYS52YWx1ZTtcbiAgICB9O2Vsc2Uge1xuICAgICAgdmFyIHkgPSAwID09PSBpIHx8IDEgPT09IGk7XG4gICAgICAoeSB8fCAzID09PSBpKSAmJiAoZCA9IG8gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gYXNzZXJ0SW5zdGFuY2VJZlByaXZhdGUobCwgZSksIGEuZ2V0LmNhbGwoZSk7XG4gICAgICB9IDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0LmNhbGwoZSk7XG4gICAgICB9KSwgKHkgfHwgNCA9PT0gaSkgJiYgKHAgPSBvID8gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgYXNzZXJ0SW5zdGFuY2VJZlByaXZhdGUobCwgZSksIGEuc2V0LmNhbGwoZSwgdCk7XG4gICAgICB9IDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgYS5zZXQuY2FsbChlLCB0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlW3JdO1xuICB9LCAwID09PSBpICYmIChwID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICBlW3JdID0gdDtcbiAgfSk7XG4gIHZhciBtID0gbyA/IGwuYmluZCgpIDogZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gciBpbiBlO1xuICB9O1xuICBoLmFjY2VzcyA9IGQgJiYgcCA/IHtcbiAgICBnZXQ6IGQsXG4gICAgc2V0OiBwLFxuICAgIGhhczogbVxuICB9IDogZCA/IHtcbiAgICBnZXQ6IGQsXG4gICAgaGFzOiBtXG4gIH0gOiB7XG4gICAgc2V0OiBwLFxuICAgIGhhczogbVxuICB9O1xuICB0cnkge1xuICAgIHJldHVybiBlLmNhbGwodCwgYywgaCk7XG4gIH0gZmluYWxseSB7XG4gICAgdi52ID0gITA7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE5vdEZpbmlzaGVkKGUsIHQpIHtcbiAgaWYgKGUudikgdGhyb3cgbmV3IEVycm9yKFwiYXR0ZW1wdGVkIHRvIGNhbGwgXCIgKyB0ICsgXCIgYWZ0ZXIgZGVjb3JhdGlvbiB3YXMgZmluaXNoZWRcIik7XG59XG5mdW5jdGlvbiBhc3NlcnRDYWxsYWJsZShlLCB0KSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHRocm93IG5ldyBUeXBlRXJyb3IodCArIFwiIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUmV0dXJuVmFsdWUoZSwgdCkge1xuICB2YXIgciA9IHR5cGVvZiB0O1xuICBpZiAoMSA9PT0gZSkge1xuICAgIGlmIChcIm9iamVjdFwiICE9PSByIHx8IG51bGwgPT09IHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhY2Nlc3NvciBkZWNvcmF0b3JzIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGdldCwgc2V0LCBvciBpbml0IHByb3BlcnRpZXMgb3Igdm9pZCAwXCIpO1xuICAgIHZvaWQgMCAhPT0gdC5nZXQgJiYgYXNzZXJ0Q2FsbGFibGUodC5nZXQsIFwiYWNjZXNzb3IuZ2V0XCIpLCB2b2lkIDAgIT09IHQuc2V0ICYmIGFzc2VydENhbGxhYmxlKHQuc2V0LCBcImFjY2Vzc29yLnNldFwiKSwgdm9pZCAwICE9PSB0LmluaXQgJiYgYXNzZXJ0Q2FsbGFibGUodC5pbml0LCBcImFjY2Vzc29yLmluaXRcIik7XG4gIH0gZWxzZSBpZiAoXCJmdW5jdGlvblwiICE9PSByKSB7XG4gICAgdmFyIGE7XG4gICAgdGhyb3cgYSA9IDAgPT09IGUgPyBcImZpZWxkXCIgOiA1ID09PSBlID8gXCJjbGFzc1wiIDogXCJtZXRob2RcIiwgbmV3IFR5cGVFcnJvcihhICsgXCIgZGVjb3JhdG9ycyBtdXN0IHJldHVybiBhIGZ1bmN0aW9uIG9yIHZvaWQgMFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gY3VycnlUaGlzMShlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGUodGhpcyk7XG4gIH07XG59XG5mdW5jdGlvbiBjdXJyeVRoaXMyKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgZSh0aGlzLCB0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFwcGx5TWVtYmVyRGVjKGUsIHQsIHIsIGEsIG4sIGksIHMsIG8sIGMsIGwsIHUpIHtcbiAgdmFyIGYsXG4gICAgZCxcbiAgICBwLFxuICAgIGgsXG4gICAgdixcbiAgICB5LFxuICAgIG0gPSByWzBdO1xuICBhIHx8IEFycmF5LmlzQXJyYXkobSkgfHwgKG0gPSBbbV0pLCBvID8gZiA9IDAgPT09IGkgfHwgMSA9PT0gaSA/IHtcbiAgICBnZXQ6IGN1cnJ5VGhpczEoclszXSksXG4gICAgc2V0OiBjdXJyeVRoaXMyKHJbNF0pXG4gIH0gOiAzID09PSBpID8ge1xuICAgIGdldDogclszXVxuICB9IDogNCA9PT0gaSA/IHtcbiAgICBzZXQ6IHJbM11cbiAgfSA6IHtcbiAgICB2YWx1ZTogclszXVxuICB9IDogMCAhPT0gaSAmJiAoZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgbikpLCAxID09PSBpID8gcCA9IHtcbiAgICBnZXQ6IGYuZ2V0LFxuICAgIHNldDogZi5zZXRcbiAgfSA6IDIgPT09IGkgPyBwID0gZi52YWx1ZSA6IDMgPT09IGkgPyBwID0gZi5nZXQgOiA0ID09PSBpICYmIChwID0gZi5zZXQpO1xuICBmb3IgKHZhciBnID0gYSA/IDIgOiAxLCBiID0gbS5sZW5ndGggLSAxOyBiID49IDA7IGIgLT0gZykge1xuICAgIHZhciBJO1xuICAgIGlmICh2b2lkIDAgIT09IChoID0gbWVtYmVyRGVjKG1bYl0sIGEgPyBtW2IgLSAxXSA6IHZvaWQgMCwgbiwgZiwgYywgaSwgcywgbywgcCwgbCwgdSkpKSBhc3NlcnRWYWxpZFJldHVyblZhbHVlKGksIGgpLCAwID09PSBpID8gSSA9IGggOiAxID09PSBpID8gKEkgPSBoLmluaXQsIHYgPSBoLmdldCB8fCBwLmdldCwgeSA9IGguc2V0IHx8IHAuc2V0LCBwID0ge1xuICAgICAgZ2V0OiB2LFxuICAgICAgc2V0OiB5XG4gICAgfSkgOiBwID0gaCwgdm9pZCAwICE9PSBJICYmICh2b2lkIDAgPT09IGQgPyBkID0gSSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZCA/IGQgPSBbZCwgSV0gOiBkLnB1c2goSSkpO1xuICB9XG4gIGlmICgwID09PSBpIHx8IDEgPT09IGkpIHtcbiAgICBpZiAodm9pZCAwID09PSBkKSBkID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH07ZWxzZSBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBkKSB7XG4gICAgICB2YXIgdyA9IGQ7XG4gICAgICBkID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IHQsIGEgPSB3Lmxlbmd0aCAtIDE7IGEgPj0gMDsgYS0tKSByID0gd1thXS5jYWxsKGUsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBNID0gZDtcbiAgICAgIGQgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICByZXR1cm4gTS5jYWxsKGUsIHQpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZS5wdXNoKGQpO1xuICB9XG4gIDAgIT09IGkgJiYgKDEgPT09IGkgPyAoZi5nZXQgPSBwLmdldCwgZi5zZXQgPSBwLnNldCkgOiAyID09PSBpID8gZi52YWx1ZSA9IHAgOiAzID09PSBpID8gZi5nZXQgPSBwIDogNCA9PT0gaSAmJiAoZi5zZXQgPSBwKSwgbyA/IDEgPT09IGkgPyAoZS5wdXNoKGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgcmV0dXJuIHAuZ2V0LmNhbGwoZSwgdCk7XG4gIH0pLCBlLnB1c2goZnVuY3Rpb24gKGUsIHQpIHtcbiAgICByZXR1cm4gcC5zZXQuY2FsbChlLCB0KTtcbiAgfSkpIDogMiA9PT0gaSA/IGUucHVzaChwKSA6IGUucHVzaChmdW5jdGlvbiAoZSwgdCkge1xuICAgIHJldHVybiBwLmNhbGwoZSwgdCk7XG4gIH0pIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4sIGYpKTtcbn1cbmZ1bmN0aW9uIGFwcGx5TWVtYmVyRGVjcyhlLCB0LCByLCBhKSB7XG4gIGZvciAodmFyIG4sIGksIHMsIG8gPSBbXSwgYyA9IG5ldyBNYXAoKSwgbCA9IG5ldyBNYXAoKSwgdSA9IDA7IHUgPCB0Lmxlbmd0aDsgdSsrKSB7XG4gICAgdmFyIGYgPSB0W3VdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGYpKSB7XG4gICAgICB2YXIgZCxcbiAgICAgICAgcCxcbiAgICAgICAgaCA9IGZbMV0sXG4gICAgICAgIHYgPSBmWzJdLFxuICAgICAgICB5ID0gZi5sZW5ndGggPiAzLFxuICAgICAgICBtID0gMTYgJiBoLFxuICAgICAgICBnID0gISEoOCAmIGgpLFxuICAgICAgICBiID0gcjtcbiAgICAgIGlmIChoICY9IDcsIGcgPyAoZCA9IGUsIDAgIT09IGggJiYgKHAgPSBpID0gaSB8fCBbXSksIHkgJiYgIXMgJiYgKHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gX2NoZWNrSW5SSFModCkgPT09IGU7XG4gICAgICB9KSwgYiA9IHMpIDogKGQgPSBlLnByb3RvdHlwZSwgMCAhPT0gaCAmJiAocCA9IG4gPSBuIHx8IFtdKSksIDAgIT09IGggJiYgIXkpIHtcbiAgICAgICAgdmFyIEkgPSBnID8gbCA6IGMsXG4gICAgICAgICAgdyA9IEkuZ2V0KHYpIHx8IDA7XG4gICAgICAgIGlmICghMCA9PT0gdyB8fCAzID09PSB3ICYmIDQgIT09IGggfHwgNCA9PT0gdyAmJiAzICE9PSBoKSB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZGVjb3JhdGUgYSBwdWJsaWMgbWV0aG9kL2FjY2Vzc29yIHRoYXQgaGFzIHRoZSBzYW1lIG5hbWUgYXMgYSBwcmV2aW91c2x5IGRlY29yYXRlZCBwdWJsaWMgbWV0aG9kL2FjY2Vzc29yLiBUaGlzIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBkZWNvcmF0b3JzIHBsdWdpbi4gUHJvcGVydHkgbmFtZSB3YXM6IFwiICsgdik7XG4gICAgICAgIEkuc2V0KHYsICEoIXcgJiYgaCA+IDIpIHx8IGgpO1xuICAgICAgfVxuICAgICAgYXBwbHlNZW1iZXJEZWMobywgZCwgZiwgbSwgdiwgaCwgZywgeSwgcCwgYiwgYSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwdXNoSW5pdGlhbGl6ZXJzKG8sIG4pLCBwdXNoSW5pdGlhbGl6ZXJzKG8sIGkpLCBvO1xufVxuZnVuY3Rpb24gcHVzaEluaXRpYWxpemVycyhlLCB0KSB7XG4gIHQgJiYgZS5wdXNoKGZ1bmN0aW9uIChlKSB7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB0W3JdLmNhbGwoZSk7XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gYXBwbHlDbGFzc0RlY3MoZSwgdCwgciwgYSkge1xuICBpZiAodC5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBuID0gW10sIGkgPSBlLCBzID0gZS5uYW1lLCBvID0gciA/IDIgOiAxLCBjID0gdC5sZW5ndGggLSAxOyBjID49IDA7IGMgLT0gbykge1xuICAgICAgdmFyIGwgPSB7XG4gICAgICAgIHY6ICExXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHUgPSB0W2NdLmNhbGwociA/IHRbYyAtIDFdIDogdm9pZCAwLCBpLCB7XG4gICAgICAgICAga2luZDogXCJjbGFzc1wiLFxuICAgICAgICAgIG5hbWU6IHMsXG4gICAgICAgICAgYWRkSW5pdGlhbGl6ZXI6IGNyZWF0ZUFkZEluaXRpYWxpemVyTWV0aG9kKG4sIGwpLFxuICAgICAgICAgIG1ldGFkYXRhOiBhXG4gICAgICAgIH0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbC52ID0gITA7XG4gICAgICB9XG4gICAgICB2b2lkIDAgIT09IHUgJiYgKGFzc2VydFZhbGlkUmV0dXJuVmFsdWUoNSwgdSksIGkgPSB1KTtcbiAgICB9XG4gICAgcmV0dXJuIFtkZWZpbmVNZXRhZGF0YShpLCBhKSwgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBuLmxlbmd0aDsgZSsrKSBuW2VdLmNhbGwoaSk7XG4gICAgfV07XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKGUsIHQpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBTeW1ib2wubWV0YWRhdGEgfHwgU3ltYm9sLmZvcihcIlN5bWJvbC5tZXRhZGF0YVwiKSwge1xuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgdmFsdWU6IHRcbiAgfSk7XG59XG5mdW5jdGlvbiBfYXBwbHlEZWNzMjMwNShlLCB0LCByLCBhLCBuLCBpKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDYpIHZhciBzID0gaVtTeW1ib2wubWV0YWRhdGEgfHwgU3ltYm9sLmZvcihcIlN5bWJvbC5tZXRhZGF0YVwiKV07XG4gIHZhciBvID0gT2JqZWN0LmNyZWF0ZSh2b2lkIDAgPT09IHMgPyBudWxsIDogcyksXG4gICAgYyA9IGFwcGx5TWVtYmVyRGVjcyhlLCB0LCBuLCBvKTtcbiAgcmV0dXJuIHIubGVuZ3RoIHx8IGRlZmluZU1ldGFkYXRhKGUsIG8pLCB7XG4gICAgZTogYyxcbiAgICBnZXQgYygpIHtcbiAgICAgIHJldHVybiBhcHBseUNsYXNzRGVjcyhlLCByLCBhLCBvKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBfY2hlY2tJblJIUyhlKSB7XG4gIGlmIChPYmplY3QoZSkgIT09IGUpIHRocm93IFR5cGVFcnJvcihcInJpZ2h0LWhhbmQgc2lkZSBvZiAnaW4nIHNob3VsZCBiZSBhbiBvYmplY3QsIGdvdCBcIiArIChudWxsICE9PSBlID8gdHlwZW9mIGUgOiBcIm51bGxcIikpO1xuICByZXR1cm4gZTtcbn1cblxuZXhwb3J0IHsgX2FwcGx5RGVjczIzMDUgYXMgYXBwbHlEZWNzMjMwNSwgX2NoZWNrSW5SSFMgYXMgY2hlY2tJblJIUyB9O1xuIiwgImZ1bmN0aW9uIEF1dG9CaW5kKG9yaWdpbmFsTWV0aG9kLCB7XG4gIG5hbWUsXG4gIGFkZEluaXRpYWxpemVyXG59KSB7XG4gIGFkZEluaXRpYWxpemVyKGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXNbbmFtZV0gPSBvcmlnaW5hbE1ldGhvZC5iaW5kKHRoaXMpO1xuXG4gIH0pO1xufVxuXG5leHBvcnQgeyBBdXRvQmluZCB9O1xuIiwgImZ1bmN0aW9uIHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0RXZlbnQgfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RFdmVudC9BYnN0cmFjdEV2ZW50Lm1qcyc7XG5cbmNsYXNzIERyYWdFdmVudCBleHRlbmRzIEFic3RyYWN0RXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcihkYXRhKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZTtcbiAgfVxuXG4gIGdldCBvcmlnaW5hbFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9yaWdpbmFsU291cmNlO1xuICB9XG5cbiAgZ2V0IG1pcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcbiAgfVxuXG4gIGdldCBzb3VyY2VDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VDb250YWluZXI7XG4gIH1cblxuICBnZXQgc2Vuc29yRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZW5zb3JFdmVudDtcbiAgfVxuXG4gIGdldCBvcmlnaW5hbEV2ZW50KCkge1xuICAgIGlmICh0aGlzLnNlbnNvckV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5EcmFnRXZlbnQudHlwZSA9ICdkcmFnJztcbmNsYXNzIERyYWdTdGFydEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XG5cbkRyYWdTdGFydEV2ZW50LnR5cGUgPSAnZHJhZzpzdGFydCc7XG5EcmFnU3RhcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcbmNsYXNzIERyYWdNb3ZlRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cblxuRHJhZ01vdmVFdmVudC50eXBlID0gJ2RyYWc6bW92ZSc7XG5cbmNsYXNzIERyYWdPdmVyRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xuXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcbiAgfVxuXG4gIGdldCBvdmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlcjtcbiAgfVxufVxuRHJhZ092ZXJFdmVudC50eXBlID0gJ2RyYWc6b3Zlcic7XG5EcmFnT3ZlckV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuZnVuY3Rpb24gaXNEcmFnT3ZlckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSBEcmFnT3ZlckV2ZW50LnR5cGU7XG59XG5cbmNsYXNzIERyYWdPdXRFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XG5cbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xuICB9XG5cbiAgZ2V0IG92ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xuICB9XG59XG5cbkRyYWdPdXRFdmVudC50eXBlID0gJ2RyYWc6b3V0JztcblxuY2xhc3MgRHJhZ092ZXJDb250YWluZXJFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XG5cbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xuICB9XG59XG5cbkRyYWdPdmVyQ29udGFpbmVyRXZlbnQudHlwZSA9ICdkcmFnOm92ZXI6Y29udGFpbmVyJztcblxuY2xhc3MgRHJhZ091dENvbnRhaW5lckV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcblxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XG4gIH1cbn1cblxuRHJhZ091dENvbnRhaW5lckV2ZW50LnR5cGUgPSAnZHJhZzpvdXQ6Y29udGFpbmVyJztcblxuY2xhc3MgRHJhZ1ByZXNzdXJlRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xuXG4gIGdldCBwcmVzc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnByZXNzdXJlO1xuICB9XG59XG5cbkRyYWdQcmVzc3VyZUV2ZW50LnR5cGUgPSAnZHJhZzpwcmVzc3VyZSc7XG5jbGFzcyBEcmFnU3RvcEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XG5cbkRyYWdTdG9wRXZlbnQudHlwZSA9ICdkcmFnOnN0b3AnO1xuRHJhZ1N0b3BFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcbmNsYXNzIERyYWdTdG9wcGVkRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cbkRyYWdTdG9wcGVkRXZlbnQudHlwZSA9ICdkcmFnOnN0b3BwZWQnO1xuXG5leHBvcnQgeyBEcmFnRXZlbnQsIERyYWdNb3ZlRXZlbnQsIERyYWdPdXRDb250YWluZXJFdmVudCwgRHJhZ091dEV2ZW50LCBEcmFnT3ZlckNvbnRhaW5lckV2ZW50LCBEcmFnT3ZlckV2ZW50LCBEcmFnUHJlc3N1cmVFdmVudCwgRHJhZ1N0YXJ0RXZlbnQsIERyYWdTdG9wRXZlbnQsIERyYWdTdG9wcGVkRXZlbnQsIGlzRHJhZ092ZXJFdmVudCB9O1xuIiwgImltcG9ydCB7IGFwcGx5RGVjczIzMDUgYXMgX2FwcGx5RGVjczIzMDUgfSBmcm9tICcuLi8uLi9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLm1qcyc7XG5pbXBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMnO1xuaW1wb3J0IHsgQXV0b0JpbmQgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMvZGVjb3JhdG9ycy9BdXRvQmluZC5tanMnO1xuaW1wb3J0IHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUgZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzL3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUvcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZS5tanMnO1xuaW1wb3J0IHsgaXNEcmFnT3ZlckV2ZW50IH0gZnJvbSAnLi4vLi4vRHJhZ2dhYmxlL0RyYWdFdmVudC9EcmFnRXZlbnQubWpzJztcblxudmFyIF9pbml0UHJvdG8sIF9jbGFzcztcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuY2xhc3MgUmVzaXplTWlycm9yIGV4dGVuZHMgQWJzdHJhY3RQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIF9pbml0UHJvdG8oc3VwZXIoZHJhZ2dhYmxlKSk7XG5cbiAgICB0aGlzLmxhc3RXaWR0aCA9IDA7XG5cbiAgICB0aGlzLmxhc3RIZWlnaHQgPSAwO1xuXG4gICAgdGhpcy5taXJyb3IgPSBudWxsO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXMub25NaXJyb3JDcmVhdGVkKS5vbignZHJhZzpvdmVyJywgdGhpcy5vbkRyYWdPdmVyKS5vbignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXMub25EcmFnT3Zlcik7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXMub25NaXJyb3JDcmVhdGVkKS5vZmYoJ21pcnJvcjpkZXN0cm95JywgdGhpcy5vbk1pcnJvckRlc3Ryb3kpLm9mZignZHJhZzpvdmVyJywgdGhpcy5vbkRyYWdPdmVyKS5vZmYoJ2RyYWc6b3Zlcjpjb250YWluZXInLCB0aGlzLm9uRHJhZ092ZXIpO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5yZXNpemVNaXJyb3IgfHwge307XG4gIH1cblxuICBvbk1pcnJvckNyZWF0ZWQoe1xuICAgIG1pcnJvclxuICB9KSB7XG4gICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XG4gIH1cblxuICBvbk1pcnJvckRlc3Ryb3koKSB7XG4gICAgdGhpcy5taXJyb3IgPSBudWxsO1xuICB9XG5cbiAgb25EcmFnT3ZlcihkcmFnRXZlbnQpIHtcbiAgICB0aGlzLnJlc2l6ZShkcmFnRXZlbnQpO1xuICB9XG5cbiAgcmVzaXplKGRyYWdFdmVudCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBsZXQgb3ZlciA9IG51bGw7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG92ZXJDb250YWluZXJcbiAgICAgIH0gPSBkcmFnRXZlbnQ7XG4gICAgICBpZiAodGhpcy5taXJyb3IgPT0gbnVsbCB8fCB0aGlzLm1pcnJvci5wYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWlycm9yLnBhcmVudE5vZGUgIT09IG92ZXJDb250YWluZXIpIHtcbiAgICAgICAgb3ZlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1pcnJvcik7XG4gICAgICB9XG4gICAgICBpZiAoaXNEcmFnT3ZlckV2ZW50KGRyYWdFdmVudCkpIHtcbiAgICAgICAgb3ZlciA9IGRyYWdFdmVudC5vdmVyO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlckVsZW1lbnQgPSBvdmVyIHx8IHRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpWzBdO1xuICAgICAgaWYgKCFvdmVyRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb3ZlclJlY3QgPSBvdmVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yID09IG51bGwgfHwgdGhpcy5sYXN0SGVpZ2h0ID09PSBvdmVyUmVjdC5oZWlnaHQgJiYgdGhpcy5sYXN0V2lkdGggPT09IG92ZXJSZWN0LndpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWlycm9yLnN0eWxlLndpZHRoID0gYCR7b3ZlclJlY3Qud2lkdGh9cHhgO1xuICAgICAgICB0aGlzLm1pcnJvci5zdHlsZS5oZWlnaHQgPSBgJHtvdmVyUmVjdC5oZWlnaHR9cHhgO1xuICAgICAgICB0aGlzLmxhc3RXaWR0aCA9IG92ZXJSZWN0LndpZHRoO1xuICAgICAgICB0aGlzLmxhc3RIZWlnaHQgPSBvdmVyUmVjdC5oZWlnaHQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuX2NsYXNzID0gUmVzaXplTWlycm9yO1xuW19pbml0UHJvdG9dID0gX2FwcGx5RGVjczIzMDUoX2NsYXNzLCBbW0F1dG9CaW5kLCAyLCBcIm9uTWlycm9yQ3JlYXRlZFwiXSwgW0F1dG9CaW5kLCAyLCBcIm9uTWlycm9yRGVzdHJveVwiXSwgW0F1dG9CaW5kLCAyLCBcIm9uRHJhZ092ZXJcIl1dLCBbXSwgMCwgdm9pZCAwLCBBYnN0cmFjdFBsdWdpbikuZTtcblxuZXhwb3J0IHsgUmVzaXplTWlycm9yIGFzIGRlZmF1bHQsIGRlZmF1bHRPcHRpb25zIH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RFdmVudCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9BYnN0cmFjdEV2ZW50L0Fic3RyYWN0RXZlbnQubWpzJztcblxuY2xhc3MgU25hcEV2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgZ2V0IGRyYWdFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudDtcbiAgfVxuXG4gIGdldCBzbmFwcGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zbmFwcGFibGU7XG4gIH1cbn1cblxuU25hcEV2ZW50LnR5cGUgPSAnc25hcCc7XG5jbGFzcyBTbmFwSW5FdmVudCBleHRlbmRzIFNuYXBFdmVudCB7fVxuXG5TbmFwSW5FdmVudC50eXBlID0gJ3NuYXA6aW4nO1xuU25hcEluRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5jbGFzcyBTbmFwT3V0RXZlbnQgZXh0ZW5kcyBTbmFwRXZlbnQge31cblNuYXBPdXRFdmVudC50eXBlID0gJ3NuYXA6b3V0JztcblNuYXBPdXRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuZXhwb3J0IHsgU25hcEV2ZW50LCBTbmFwSW5FdmVudCwgU25hcE91dEV2ZW50IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RQbHVnaW4gfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RQbHVnaW4vQWJzdHJhY3RQbHVnaW4ubWpzJztcbmltcG9ydCB7IFNuYXBJbkV2ZW50LCBTbmFwT3V0RXZlbnQgfSBmcm9tICcuL1NuYXBwYWJsZUV2ZW50L1NuYXBwYWJsZUV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xuY29uc3Qgb25EcmFnT3V0ID0gU3ltYm9sKCdvbkRyYWdPdXQnKTtcbmNvbnN0IG9uTWlycm9yQ3JlYXRlZCA9IFN5bWJvbCgnb25NaXJyb3JDcmVhdGVkJyk7XG5jb25zdCBvbk1pcnJvckRlc3Ryb3kgPSBTeW1ib2woJ29uTWlycm9yRGVzdHJveScpO1xuXG5jbGFzcyBTbmFwcGFibGUgZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIHRoaXMuZmlyc3RTb3VyY2UgPSBudWxsO1xuXG4gICAgdGhpcy5taXJyb3IgPSBudWxsO1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdPdXRdID0gdGhpc1tvbkRyYWdPdXRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1pcnJvckRlc3Ryb3ldID0gdGhpc1tvbk1pcnJvckRlc3Ryb3ldLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9uKCdkcm9wcGFibGU6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcm9wcGFibGU6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub2ZmKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vZmYoJ2RyYWc6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vZmYoJ2Ryb3BwYWJsZTpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcm9wcGFibGU6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vZmYoJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vZmYoJ21pcnJvcjpkZXN0cm95JywgdGhpc1tvbk1pcnJvckRlc3Ryb3ldKTtcbiAgfVxuXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpcnN0U291cmNlID0gZXZlbnQuc291cmNlO1xuICB9XG5cbiAgW29uRHJhZ1N0b3BdKCkge1xuICAgIHRoaXMuZmlyc3RTb3VyY2UgPSBudWxsO1xuICB9XG5cbiAgW29uRHJhZ092ZXJdKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gZXZlbnQuc291cmNlIHx8IGV2ZW50LmRyYWdFdmVudC5zb3VyY2U7XG4gICAgaWYgKHNvdXJjZSA9PT0gdGhpcy5maXJzdFNvdXJjZSkge1xuICAgICAgdGhpcy5maXJzdFNvdXJjZSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNuYXBJbkV2ZW50ID0gbmV3IFNuYXBJbkV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXG4gICAgfSk7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihzbmFwSW5FdmVudCk7XG4gICAgaWYgKHNuYXBJbkV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWlycm9yKSB7XG4gICAgICB0aGlzLm1pcnJvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICBzb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XG4gICAgc291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOnBsYWNlZCcpKTtcbiAgICB9LCB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnBsYWNlZFRpbWVvdXQpO1xuICB9XG5cbiAgW29uRHJhZ091dF0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwgZXZlbnQuZHJhZ0V2ZW50LnNvdXJjZTtcbiAgICBjb25zdCBzbmFwT3V0RXZlbnQgPSBuZXcgU25hcE91dEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXG4gICAgfSk7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihzbmFwT3V0RXZlbnQpO1xuICAgIGlmIChzbmFwT3V0RXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5taXJyb3IpIHtcbiAgICAgIHRoaXMubWlycm9yLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9XG4gICAgc291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOmRyYWdnaW5nJykpO1xuICB9XG5cbiAgW29uTWlycm9yQ3JlYXRlZF0oe1xuICAgIG1pcnJvclxuICB9KSB7XG4gICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XG4gIH1cblxuICBbb25NaXJyb3JEZXN0cm95XSgpIHtcbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgU25hcHBhYmxlIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBhcHBseURlY3MyMzA1IGFzIF9hcHBseURlY3MyMzA1IH0gZnJvbSAnLi4vLi4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5tanMnO1xuaW1wb3J0IHsgQWJzdHJhY3RQbHVnaW4gfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RQbHVnaW4vQWJzdHJhY3RQbHVnaW4ubWpzJztcbmltcG9ydCB7IEF1dG9CaW5kIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzL2RlY29yYXRvcnMvQXV0b0JpbmQubWpzJztcblxudmFyIF9pbml0UHJvdG8sIF9jbGFzcztcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGR1cmF0aW9uOiAxNTAsXG4gIGVhc2luZ0Z1bmN0aW9uOiAnZWFzZS1pbi1vdXQnLFxuICBob3Jpem9udGFsOiBmYWxzZVxufTtcblxuY2xhc3MgU3dhcEFuaW1hdGlvbiBleHRlbmRzIEFic3RyYWN0UGx1Z2luIHtcblxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcbiAgICBfaW5pdFByb3RvKHN1cGVyKGRyYWdnYWJsZSkpO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi50aGlzLmdldE9wdGlvbnMoKVxuICAgIH07XG5cbiAgICB0aGlzLmxhc3RBbmltYXRpb25GcmFtZSA9IG51bGw7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ3NvcnRhYmxlOnNvcnRlZCcsIHRoaXMub25Tb3J0YWJsZVNvcnRlZCk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdzb3J0YWJsZTpzb3J0ZWQnLCB0aGlzLm9uU29ydGFibGVTb3J0ZWQpO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zd2FwQW5pbWF0aW9uIHx8IHt9O1xuICB9XG5cbiAgb25Tb3J0YWJsZVNvcnRlZCh7XG4gICAgb2xkSW5kZXgsXG4gICAgbmV3SW5kZXgsXG4gICAgZHJhZ0V2ZW50XG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2UsXG4gICAgICBvdmVyXG4gICAgfSA9IGRyYWdFdmVudDtcbiAgICBpZiAodGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAob2xkSW5kZXggPj0gbmV3SW5kZXgpIHtcbiAgICAgICAgYW5pbWF0ZShzb3VyY2UsIG92ZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRlKG92ZXIsIHNvdXJjZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5fY2xhc3MgPSBTd2FwQW5pbWF0aW9uO1xuW19pbml0UHJvdG9dID0gX2FwcGx5RGVjczIzMDUoX2NsYXNzLCBbW0F1dG9CaW5kLCAyLCBcIm9uU29ydGFibGVTb3J0ZWRcIl1dLCBbXSwgMCwgdm9pZCAwLCBBYnN0cmFjdFBsdWdpbikuZTtcbmZ1bmN0aW9uIGFuaW1hdGUoZnJvbSwgdG8sIHtcbiAgZHVyYXRpb24sXG4gIGVhc2luZ0Z1bmN0aW9uLFxuICBob3Jpem9udGFsXG59KSB7XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBbZnJvbSwgdG9dKSB7XG4gICAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICB9XG4gIGlmIChob3Jpem9udGFsKSB7XG4gICAgY29uc3Qgd2lkdGggPSBmcm9tLm9mZnNldFdpZHRoO1xuICAgIGZyb20uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7d2lkdGh9cHgsIDAsIDApYDtcbiAgICB0by5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoLSR7d2lkdGh9cHgsIDAsIDApYDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBoZWlnaHQgPSBmcm9tLm9mZnNldEhlaWdodDtcbiAgICBmcm9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwLCAke2hlaWdodH1weCwgMClgO1xuICAgIHRvLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwLCAtJHtoZWlnaHR9cHgsIDApYDtcbiAgfVxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbZnJvbSwgdG9dKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQpO1xuICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gYHRyYW5zZm9ybSAke2R1cmF0aW9ufW1zICR7ZWFzaW5nRnVuY3Rpb259YDtcbiAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRFbGVtZW50T25UcmFuc2l0aW9uRW5kKGV2ZW50KSB7XG4gIGlmIChldmVudC50YXJnZXQgPT0gbnVsbCB8fCAhaXNIVE1MRWxlbWVudChldmVudC50YXJnZXQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGV2ZW50LnRhcmdldC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gIGV2ZW50LnRhcmdldC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gIGV2ZW50LnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgcmVzZXRFbGVtZW50T25UcmFuc2l0aW9uRW5kKTtcbn1cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQoZXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIEJvb2xlYW4oJ3N0eWxlJyBpbiBldmVudFRhcmdldCk7XG59XG5cbmV4cG9ydCB7IFN3YXBBbmltYXRpb24gYXMgZGVmYXVsdCwgZGVmYXVsdE9wdGlvbnMgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMnO1xuXG5jb25zdCBvblNvcnRhYmxlU29ydGVkID0gU3ltYm9sKCdvblNvcnRhYmxlU29ydGVkJyk7XG5jb25zdCBvblNvcnRhYmxlU29ydCA9IFN5bWJvbCgnb25Tb3J0YWJsZVNvcnQnKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGR1cmF0aW9uOiAxNTAsXG4gIGVhc2luZ0Z1bmN0aW9uOiAnZWFzZS1pbi1vdXQnXG59O1xuXG5jbGFzcyBTb3J0QW5pbWF0aW9uIGV4dGVuZHMgQWJzdHJhY3RQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIHN1cGVyKGRyYWdnYWJsZSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLnRoaXMuZ2V0T3B0aW9ucygpXG4gICAgfTtcblxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICB0aGlzLmxhc3RFbGVtZW50cyA9IFtdO1xuICAgIHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0gPSB0aGlzW29uU29ydGFibGVTb3J0ZWRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvblNvcnRhYmxlU29ydF0gPSB0aGlzW29uU29ydGFibGVTb3J0XS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdzb3J0YWJsZTpzb3J0JywgdGhpc1tvblNvcnRhYmxlU29ydF0pO1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdzb3J0YWJsZTpzb3J0ZWQnLCB0aGlzW29uU29ydGFibGVTb3J0ZWRdKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ3NvcnRhYmxlOnNvcnQnLCB0aGlzW29uU29ydGFibGVTb3J0XSk7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdzb3J0YWJsZTpzb3J0ZWQnLCB0aGlzW29uU29ydGFibGVTb3J0ZWRdKTtcbiAgfVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuc29ydEFuaW1hdGlvbiB8fCB7fTtcbiAgfVxuXG4gIFtvblNvcnRhYmxlU29ydF0oe1xuICAgIGRyYWdFdmVudFxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgc291cmNlQ29udGFpbmVyXG4gICAgfSA9IGRyYWdFdmVudDtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKHNvdXJjZUNvbnRhaW5lcik7XG4gICAgdGhpcy5sYXN0RWxlbWVudHMgPSBBcnJheS5mcm9tKGVsZW1lbnRzKS5tYXAoZWwgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9tRWw6IGVsLFxuICAgICAgICBvZmZzZXRUb3A6IGVsLm9mZnNldFRvcCxcbiAgICAgICAgb2Zmc2V0TGVmdDogZWwub2Zmc2V0TGVmdFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIFtvblNvcnRhYmxlU29ydGVkXSh7XG4gICAgb2xkSW5kZXgsXG4gICAgbmV3SW5kZXhcbiAgfSkge1xuICAgIGlmIChvbGRJbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWZmZWN0ZWRFbGVtZW50cyA9IFtdO1xuICAgIGxldCBzdGFydDtcbiAgICBsZXQgZW5kO1xuICAgIGxldCBudW07XG4gICAgaWYgKG9sZEluZGV4ID4gbmV3SW5kZXgpIHtcbiAgICAgIHN0YXJ0ID0gbmV3SW5kZXg7XG4gICAgICBlbmQgPSBvbGRJbmRleCAtIDE7XG4gICAgICBudW0gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IG9sZEluZGV4ICsgMTtcbiAgICAgIGVuZCA9IG5ld0luZGV4O1xuICAgICAgbnVtID0gLTE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgZnJvbSA9IHRoaXMubGFzdEVsZW1lbnRzW2ldO1xuICAgICAgY29uc3QgdG8gPSB0aGlzLmxhc3RFbGVtZW50c1tpICsgbnVtXTtcbiAgICAgIGVmZmVjdGVkRWxlbWVudHMucHVzaCh7XG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvXG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUpO1xuXG4gICAgdGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgZWZmZWN0ZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4gYW5pbWF0ZShlbGVtZW50LCB0aGlzLm9wdGlvbnMpKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhbmltYXRlKHtcbiAgZnJvbSxcbiAgdG9cbn0sIHtcbiAgZHVyYXRpb24sXG4gIGVhc2luZ0Z1bmN0aW9uXG59KSB7XG4gIGNvbnN0IGRvbUVsID0gZnJvbS5kb21FbDtcbiAgY29uc3QgeCA9IGZyb20ub2Zmc2V0TGVmdCAtIHRvLm9mZnNldExlZnQ7XG4gIGNvbnN0IHkgPSBmcm9tLm9mZnNldFRvcCAtIHRvLm9mZnNldFRvcDtcbiAgZG9tRWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgZG9tRWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHt5fXB4LCAwKWA7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgZG9tRWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XG4gICAgZG9tRWwuc3R5bGUudHJhbnNpdGlvbiA9IGB0cmFuc2Zvcm0gJHtkdXJhdGlvbn1tcyAke2Vhc2luZ0Z1bmN0aW9ufWA7XG4gICAgZG9tRWwuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQoZXZlbnQpIHtcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgZXZlbnQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQpO1xufVxuXG5leHBvcnQgeyBTb3J0QW5pbWF0aW9uIGFzIGRlZmF1bHQsIGRlZmF1bHRPcHRpb25zIH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RQbHVnaW4gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvQWJzdHJhY3RQbHVnaW4vQWJzdHJhY3RQbHVnaW4ubWpzJztcblxuY29uc3Qgb25Jbml0aWFsaXplID0gU3ltYm9sKCdvbkluaXRpYWxpemUnKTtcbmNvbnN0IG9uRGVzdHJveSA9IFN5bWJvbCgnb25EZXN0cm95Jyk7XG5jb25zdCBhbm5vdW5jZUV2ZW50ID0gU3ltYm9sKCdhbm5vdW5jZUV2ZW50Jyk7XG5jb25zdCBhbm5vdW5jZU1lc3NhZ2UgPSBTeW1ib2woJ2Fubm91bmNlTWVzc2FnZScpO1xuY29uc3QgQVJJQV9SRUxFVkFOVCA9ICdhcmlhLXJlbGV2YW50JztcbmNvbnN0IEFSSUFfQVRPTUlDID0gJ2FyaWEtYXRvbWljJztcbmNvbnN0IEFSSUFfTElWRSA9ICdhcmlhLWxpdmUnO1xuY29uc3QgUk9MRSA9ICdyb2xlJztcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGV4cGlyZTogNzAwMFxufTtcblxuY2xhc3MgQW5ub3VuY2VtZW50IGV4dGVuZHMgQWJzdHJhY3RQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIHN1cGVyKGRyYWdnYWJsZSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLnRoaXMuZ2V0T3B0aW9ucygpXG4gICAgfTtcblxuICAgIHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kID0gdGhpcy5kcmFnZ2FibGUudHJpZ2dlcjtcbiAgICB0aGlzW29uSW5pdGlhbGl6ZV0gPSB0aGlzW29uSW5pdGlhbGl6ZV0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRGVzdHJveV0gPSB0aGlzW29uRGVzdHJveV0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9O1xuICB9XG5cbiAgW2Fubm91bmNlRXZlbnRdKGV2ZW50KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMub3B0aW9uc1tldmVudC50eXBlXTtcbiAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXNbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKGV2ZW50KSk7XG4gICAgfVxuICB9XG5cbiAgW2Fubm91bmNlTWVzc2FnZV0obWVzc2FnZSkge1xuICAgIGFubm91bmNlKG1lc3NhZ2UsIHtcbiAgICAgIGV4cGlyZTogdGhpcy5vcHRpb25zLmV4cGlyZVxuICAgIH0pO1xuICB9XG5cbiAgW29uSW5pdGlhbGl6ZV0oKSB7XG5cbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyID0gZXZlbnQgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpc1thbm5vdW5jZUV2ZW50XShldmVudCk7XG4gICAgICB9IGZpbmFsbHkge1xuXG4gICAgICAgIHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kLmNhbGwodGhpcy5kcmFnZ2FibGUsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgW29uRGVzdHJveV0oKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlciA9IHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kO1xuICB9XG59XG5cbmNvbnN0IGxpdmVSZWdpb24gPSBjcmVhdGVSZWdpb24oKTtcblxuZnVuY3Rpb24gYW5ub3VuY2UobWVzc2FnZSwge1xuICBleHBpcmVcbn0pIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgbGl2ZVJlZ2lvbi5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGxpdmVSZWdpb24ucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH0sIGV4cGlyZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZ2lvbigpIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCAnZHJhZ2dhYmxlLWxpdmUtcmVnaW9uJyk7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfUkVMRVZBTlQsICdhZGRpdGlvbnMnKTtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVJJQV9BVE9NSUMsICd0cnVlJyk7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfTElWRSwgJ2Fzc2VydGl2ZScpO1xuICBlbGVtZW50LnNldEF0dHJpYnV0ZShST0xFLCAnbG9nJyk7XG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBlbGVtZW50LnN0eWxlLndpZHRoID0gJzFweCc7XG4gIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzFweCc7XG4gIGVsZW1lbnQuc3R5bGUudG9wID0gJy0xcHgnO1xuICBlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpdmVSZWdpb24pO1xufSk7XG5cbmV4cG9ydCB7IEFubm91bmNlbWVudCBhcyBkZWZhdWx0LCBkZWZhdWx0T3B0aW9ucyB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0UGx1Z2luIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL0Fic3RyYWN0UGx1Z2luL0Fic3RyYWN0UGx1Z2luLm1qcyc7XG5cbmNvbnN0IG9uSW5pdGlhbGl6ZSA9IFN5bWJvbCgnb25Jbml0aWFsaXplJyk7XG5jb25zdCBvbkRlc3Ryb3kgPSBTeW1ib2woJ29uRGVzdHJveScpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG5jbGFzcyBGb2N1c2FibGUgZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4udGhpcy5nZXRPcHRpb25zKClcbiAgICB9O1xuICAgIHRoaXNbb25Jbml0aWFsaXplXSA9IHRoaXNbb25Jbml0aWFsaXplXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EZXN0cm95XSA9IHRoaXNbb25EZXN0cm95XS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnZ2FibGU6aW5pdGlhbGl6ZScsIHRoaXNbb25Jbml0aWFsaXplXSkub24oJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWdnYWJsZTppbml0aWFsaXplJywgdGhpc1tvbkluaXRpYWxpemVdKS5vZmYoJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcblxuICAgIHRoaXNbb25EZXN0cm95XSgpO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5mb2N1c2FibGUgfHwge307XG4gIH1cblxuICBnZXRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuZHJhZ2dhYmxlLmNvbnRhaW5lcnMsIC4uLnRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzKCldO1xuICB9XG5cbiAgW29uSW5pdGlhbGl6ZV0oKSB7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5nZXRFbGVtZW50cygpLmZvckVhY2goZWxlbWVudCA9PiBkZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCkpO1xuICAgIH0pO1xuICB9XG5cbiAgW29uRGVzdHJveV0oKSB7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5nZXRFbGVtZW50cygpLmZvckVhY2goZWxlbWVudCA9PiBzdHJpcEVsZW1lbnQoZWxlbWVudCkpO1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleCA9IFtdO1xuXG5mdW5jdGlvbiBkZWNvcmF0ZUVsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCBoYXNNaXNzaW5nVGFiSW5kZXggPSBCb29sZWFuKCFlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBlbGVtZW50LnRhYkluZGV4ID09PSAtMSk7XG4gIGlmIChoYXNNaXNzaW5nVGFiSW5kZXgpIHtcbiAgICBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXgucHVzaChlbGVtZW50KTtcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcEVsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCB0YWJJbmRleEVsZW1lbnRQb3NpdGlvbiA9IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5pbmRleE9mKGVsZW1lbnQpO1xuICBpZiAodGFiSW5kZXhFbGVtZW50UG9zaXRpb24gIT09IC0xKSB7XG4gICAgZWxlbWVudC50YWJJbmRleCA9IC0xO1xuICAgIGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5zcGxpY2UodGFiSW5kZXhFbGVtZW50UG9zaXRpb24sIDEpO1xuICB9XG59XG5cbmV4cG9ydCB7IEZvY3VzYWJsZSBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RFdmVudCB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9BYnN0cmFjdEV2ZW50L0Fic3RyYWN0RXZlbnQubWpzJztcblxuY2xhc3MgTWlycm9yRXZlbnQgZXh0ZW5kcyBBYnN0cmFjdEV2ZW50IHtcblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBzb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2U7XG4gIH1cblxuICBnZXQgb3JpZ2luYWxTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbFNvdXJjZTtcbiAgfVxuXG4gIGdldCBzb3VyY2VDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VDb250YWluZXI7XG4gIH1cblxuICBnZXQgc2Vuc29yRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZW5zb3JFdmVudDtcbiAgfVxuXG4gIGdldCBkcmFnRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XG4gIH1cblxuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcbiAgICBpZiAodGhpcy5zZW5zb3JFdmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuY2xhc3MgTWlycm9yQ3JlYXRlRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7fVxuTWlycm9yQ3JlYXRlRXZlbnQudHlwZSA9ICdtaXJyb3I6Y3JlYXRlJztcblxuY2xhc3MgTWlycm9yQ3JlYXRlZEV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xuXG4gIGdldCBtaXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XG4gIH1cbn1cbk1pcnJvckNyZWF0ZWRFdmVudC50eXBlID0gJ21pcnJvcjpjcmVhdGVkJztcblxuY2xhc3MgTWlycm9yQXR0YWNoZWRFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcblxuICBnZXQgbWlycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xuICB9XG59XG5NaXJyb3JBdHRhY2hlZEV2ZW50LnR5cGUgPSAnbWlycm9yOmF0dGFjaGVkJztcblxuY2xhc3MgTWlycm9yTW92ZUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xuXG4gIGdldCBtaXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XG4gIH1cblxuICBnZXQgcGFzc2VkVGhyZXNoWCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnBhc3NlZFRocmVzaFg7XG4gIH1cblxuICBnZXQgcGFzc2VkVGhyZXNoWSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnBhc3NlZFRocmVzaFk7XG4gIH1cbn1cbk1pcnJvck1vdmVFdmVudC50eXBlID0gJ21pcnJvcjptb3ZlJztcbk1pcnJvck1vdmVFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuY2xhc3MgTWlycm9yTW92ZWRFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcblxuICBnZXQgbWlycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xuICB9XG5cbiAgZ2V0IHBhc3NlZFRocmVzaFgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wYXNzZWRUaHJlc2hYO1xuICB9XG5cbiAgZ2V0IHBhc3NlZFRocmVzaFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wYXNzZWRUaHJlc2hZO1xuICB9XG59XG5NaXJyb3JNb3ZlZEV2ZW50LnR5cGUgPSAnbWlycm9yOm1vdmVkJztcblxuY2xhc3MgTWlycm9yRGVzdHJveUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xuXG4gIGdldCBtaXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XG4gIH1cbn1cbk1pcnJvckRlc3Ryb3lFdmVudC50eXBlID0gJ21pcnJvcjpkZXN0cm95Jztcbk1pcnJvckRlc3Ryb3lFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuZXhwb3J0IHsgTWlycm9yQXR0YWNoZWRFdmVudCwgTWlycm9yQ3JlYXRlRXZlbnQsIE1pcnJvckNyZWF0ZWRFdmVudCwgTWlycm9yRGVzdHJveUV2ZW50LCBNaXJyb3JFdmVudCwgTWlycm9yTW92ZUV2ZW50LCBNaXJyb3JNb3ZlZEV2ZW50IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RQbHVnaW4gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvQWJzdHJhY3RQbHVnaW4vQWJzdHJhY3RQbHVnaW4ubWpzJztcbmltcG9ydCB7IE1pcnJvckNyZWF0ZUV2ZW50LCBNaXJyb3JDcmVhdGVkRXZlbnQsIE1pcnJvckF0dGFjaGVkRXZlbnQsIE1pcnJvck1vdmVFdmVudCwgTWlycm9yRGVzdHJveUV2ZW50LCBNaXJyb3JNb3ZlZEV2ZW50IH0gZnJvbSAnLi9NaXJyb3JFdmVudC9NaXJyb3JFdmVudC5tanMnO1xuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IG9uTWlycm9yQ3JlYXRlZCA9IFN5bWJvbCgnb25NaXJyb3JDcmVhdGVkJyk7XG5jb25zdCBvbk1pcnJvck1vdmUgPSBTeW1ib2woJ29uTWlycm9yTW92ZScpO1xuY29uc3Qgb25TY3JvbGwgPSBTeW1ib2woJ29uU2Nyb2xsJyk7XG5jb25zdCBnZXRBcHBlbmRhYmxlQ29udGFpbmVyID0gU3ltYm9sKCdnZXRBcHBlbmRhYmxlQ29udGFpbmVyJyk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBjb25zdHJhaW5EaW1lbnNpb25zOiBmYWxzZSxcbiAgeEF4aXM6IHRydWUsXG4gIHlBeGlzOiB0cnVlLFxuICBjdXJzb3JPZmZzZXRYOiBudWxsLFxuICBjdXJzb3JPZmZzZXRZOiBudWxsLFxuICB0aHJlc2hvbGRYOiBudWxsLFxuICB0aHJlc2hvbGRZOiBudWxsXG59O1xuXG5jbGFzcyBNaXJyb3IgZXh0ZW5kcyBBYnN0cmFjdFBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4udGhpcy5nZXRPcHRpb25zKClcbiAgICB9O1xuXG4gICAgdGhpcy5zY3JvbGxPZmZzZXQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG5cbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7XG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZXG4gICAgfTtcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25NaXJyb3JDcmVhdGVkXSA9IHRoaXNbb25NaXJyb3JDcmVhdGVkXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25NaXJyb3JNb3ZlXSA9IHRoaXNbb25NaXJyb3JNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25TY3JvbGxdID0gdGhpc1tvblNjcm9sbF0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9uKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub24oJ21pcnJvcjptb3ZlJywgdGhpc1tvbk1pcnJvck1vdmVdKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9mZignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9mZignbWlycm9yOm1vdmUnLCB0aGlzW29uTWlycm9yTW92ZV0pO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5taXJyb3IgfHwge307XG4gIH1cbiAgW29uRHJhZ1N0YXJ0XShkcmFnRXZlbnQpIHtcbiAgICBpZiAoZHJhZ0V2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpc1tvblNjcm9sbF0sIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7XG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50XG4gICAgfSA9IGRyYWdFdmVudDtcblxuICAgIHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50ID0ge1xuICAgICAgeDogc2Vuc29yRXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IHNlbnNvckV2ZW50LmNsaWVudFlcbiAgICB9O1xuICAgIGNvbnN0IG1pcnJvckNyZWF0ZUV2ZW50ID0gbmV3IE1pcnJvckNyZWF0ZUV2ZW50KHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgc291cmNlQ29udGFpbmVyLFxuICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICBkcmFnRXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckNyZWF0ZUV2ZW50KTtcbiAgICBpZiAoaXNOYXRpdmVEcmFnRXZlbnQoc2Vuc29yRXZlbnQpIHx8IG1pcnJvckNyZWF0ZUV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXBwZW5kYWJsZUNvbnRhaW5lciA9IHRoaXNbZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcl0oc291cmNlKSB8fCBzb3VyY2VDb250YWluZXI7XG4gICAgdGhpcy5taXJyb3IgPSBzb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgIGNvbnN0IG1pcnJvckNyZWF0ZWRFdmVudCA9IG5ldyBNaXJyb3JDcmVhdGVkRXZlbnQoe1xuICAgICAgc291cmNlLFxuICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICBzb3VyY2VDb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIGRyYWdFdmVudCxcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcbiAgICB9KTtcbiAgICBjb25zdCBtaXJyb3JBdHRhY2hlZEV2ZW50ID0gbmV3IE1pcnJvckF0dGFjaGVkRXZlbnQoe1xuICAgICAgc291cmNlLFxuICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICBzb3VyY2VDb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIGRyYWdFdmVudCxcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcbiAgICB9KTtcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckNyZWF0ZWRFdmVudCk7XG4gICAgYXBwZW5kYWJsZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1pcnJvcik7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JBdHRhY2hlZEV2ZW50KTtcbiAgfVxuICBbb25EcmFnTW92ZV0oZHJhZ0V2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm1pcnJvciB8fCBkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50XG4gICAgfSA9IGRyYWdFdmVudDtcbiAgICBsZXQgcGFzc2VkVGhyZXNoWCA9IHRydWU7XG4gICAgbGV0IHBhc3NlZFRocmVzaFkgPSB0cnVlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGhyZXNob2xkWCB8fCB0aGlzLm9wdGlvbnMudGhyZXNob2xkWSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4OiBsYXN0WCxcbiAgICAgICAgeTogbGFzdFlcbiAgICAgIH0gPSB0aGlzLmxhc3RNaXJyb3JNb3ZlZENsaWVudDtcbiAgICAgIGlmIChNYXRoLmFicyhsYXN0WCAtIHNlbnNvckV2ZW50LmNsaWVudFgpIDwgdGhpcy5vcHRpb25zLnRocmVzaG9sZFgpIHtcbiAgICAgICAgcGFzc2VkVGhyZXNoWCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0TWlycm9yTW92ZWRDbGllbnQueCA9IHNlbnNvckV2ZW50LmNsaWVudFg7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMobGFzdFkgLSBzZW5zb3JFdmVudC5jbGllbnRZKSA8IHRoaXMub3B0aW9ucy50aHJlc2hvbGRZKSB7XG4gICAgICAgIHBhc3NlZFRocmVzaFkgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdE1pcnJvck1vdmVkQ2xpZW50LnkgPSBzZW5zb3JFdmVudC5jbGllbnRZO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXNzZWRUaHJlc2hYICYmICFwYXNzZWRUaHJlc2hZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWlycm9yTW92ZUV2ZW50ID0gbmV3IE1pcnJvck1vdmVFdmVudCh7XG4gICAgICBzb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgZHJhZ0V2ZW50LFxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcbiAgICAgIHBhc3NlZFRocmVzaFgsXG4gICAgICBwYXNzZWRUaHJlc2hZXG4gICAgfSk7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JNb3ZlRXZlbnQpO1xuICB9XG4gIFtvbkRyYWdTdG9wXShkcmFnRXZlbnQpIHtcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzW29uU2Nyb2xsXSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICBpZiAoIXRoaXMubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50XG4gICAgfSA9IGRyYWdFdmVudDtcbiAgICBjb25zdCBtaXJyb3JEZXN0cm95RXZlbnQgPSBuZXcgTWlycm9yRGVzdHJveUV2ZW50KHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXG4gICAgICBzb3VyY2VDb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIGRyYWdFdmVudFxuICAgIH0pO1xuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yRGVzdHJveUV2ZW50KTtcbiAgICBpZiAoIW1pcnJvckRlc3Ryb3lFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICB0aGlzLm1pcnJvci5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgW29uU2Nyb2xsXSgpIHtcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYIC0gdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0LngsXG4gICAgICB5OiB3aW5kb3cuc2Nyb2xsWSAtIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldC55XG4gICAgfTtcbiAgfVxuXG4gIFtvbk1pcnJvckNyZWF0ZWRdKHtcbiAgICBtaXJyb3IsXG4gICAgc291cmNlLFxuICAgIHNlbnNvckV2ZW50XG4gIH0pIHtcbiAgICBjb25zdCBtaXJyb3JDbGFzc2VzID0gdGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lc0ZvcignbWlycm9yJyk7XG4gICAgY29uc3Qgc2V0U3RhdGUgPSAoe1xuICAgICAgbWlycm9yT2Zmc2V0LFxuICAgICAgaW5pdGlhbFgsXG4gICAgICBpbml0aWFsWSxcbiAgICAgIC4uLmFyZ3NcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLm1pcnJvck9mZnNldCA9IG1pcnJvck9mZnNldDtcbiAgICAgIHRoaXMuaW5pdGlhbFggPSBpbml0aWFsWDtcbiAgICAgIHRoaXMuaW5pdGlhbFkgPSBpbml0aWFsWTtcbiAgICAgIHRoaXMubGFzdE1vdmVkWCA9IGluaXRpYWxYO1xuICAgICAgdGhpcy5sYXN0TW92ZWRZID0gaW5pdGlhbFk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaXJyb3JPZmZzZXQsXG4gICAgICAgIGluaXRpYWxYLFxuICAgICAgICBpbml0aWFsWSxcbiAgICAgICAgLi4uYXJnc1xuICAgICAgfTtcbiAgICB9O1xuICAgIG1pcnJvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICAgIG1pcnJvcixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgbWlycm9yQ2xhc3NlcyxcbiAgICAgIHNjcm9sbE9mZnNldDogdGhpcy5zY3JvbGxPZmZzZXQsXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICBwYXNzZWRUaHJlc2hYOiB0cnVlLFxuICAgICAgcGFzc2VkVGhyZXNoWTogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbml0aWFsU3RhdGUpXG5cbiAgICAudGhlbihjb21wdXRlTWlycm9yRGltZW5zaW9ucykudGhlbihjYWxjdWxhdGVNaXJyb3JPZmZzZXQpLnRoZW4ocmVzZXRNaXJyb3IpLnRoZW4oYWRkTWlycm9yQ2xhc3NlcykudGhlbihwb3NpdGlvbk1pcnJvcih7XG4gICAgICBpbml0aWFsOiB0cnVlXG4gICAgfSkpLnRoZW4ocmVtb3ZlTWlycm9ySUQpLnRoZW4oc2V0U3RhdGUpO1xuICB9XG5cbiAgW29uTWlycm9yTW92ZV0obWlycm9yRXZlbnQpIHtcbiAgICBpZiAobWlycm9yRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNldFN0YXRlID0gKHtcbiAgICAgIGxhc3RNb3ZlZFgsXG4gICAgICBsYXN0TW92ZWRZLFxuICAgICAgLi4uYXJnc1xuICAgIH0pID0+IHtcbiAgICAgIHRoaXMubGFzdE1vdmVkWCA9IGxhc3RNb3ZlZFg7XG4gICAgICB0aGlzLmxhc3RNb3ZlZFkgPSBsYXN0TW92ZWRZO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFzdE1vdmVkWCxcbiAgICAgICAgbGFzdE1vdmVkWSxcbiAgICAgICAgLi4uYXJnc1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHRyaWdnZXJNb3ZlZCA9IGFyZ3MgPT4ge1xuICAgICAgY29uc3QgbWlycm9yTW92ZWRFdmVudCA9IG5ldyBNaXJyb3JNb3ZlZEV2ZW50KHtcbiAgICAgICAgc291cmNlOiBtaXJyb3JFdmVudC5zb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiBtaXJyb3JFdmVudC5vcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBtaXJyb3JFdmVudC5zb3VyY2VDb250YWluZXIsXG4gICAgICAgIHNlbnNvckV2ZW50OiBtaXJyb3JFdmVudC5zZW5zb3JFdmVudCxcbiAgICAgICAgZHJhZ0V2ZW50OiBtaXJyb3JFdmVudC5kcmFnRXZlbnQsXG4gICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXG4gICAgICAgIHBhc3NlZFRocmVzaFg6IG1pcnJvckV2ZW50LnBhc3NlZFRocmVzaFgsXG4gICAgICAgIHBhc3NlZFRocmVzaFk6IG1pcnJvckV2ZW50LnBhc3NlZFRocmVzaFlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JNb3ZlZEV2ZW50KTtcbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH07XG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgbWlycm9yOiBtaXJyb3JFdmVudC5taXJyb3IsXG4gICAgICBzZW5zb3JFdmVudDogbWlycm9yRXZlbnQuc2Vuc29yRXZlbnQsXG4gICAgICBtaXJyb3JPZmZzZXQ6IHRoaXMubWlycm9yT2Zmc2V0LFxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgaW5pdGlhbFg6IHRoaXMuaW5pdGlhbFgsXG4gICAgICBpbml0aWFsWTogdGhpcy5pbml0aWFsWSxcbiAgICAgIHNjcm9sbE9mZnNldDogdGhpcy5zY3JvbGxPZmZzZXQsXG4gICAgICBwYXNzZWRUaHJlc2hYOiBtaXJyb3JFdmVudC5wYXNzZWRUaHJlc2hYLFxuICAgICAgcGFzc2VkVGhyZXNoWTogbWlycm9yRXZlbnQucGFzc2VkVGhyZXNoWSxcbiAgICAgIGxhc3RNb3ZlZFg6IHRoaXMubGFzdE1vdmVkWCxcbiAgICAgIGxhc3RNb3ZlZFk6IHRoaXMubGFzdE1vdmVkWVxuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbml0aWFsU3RhdGUpLnRoZW4ocG9zaXRpb25NaXJyb3Ioe1xuICAgICAgcmFmOiB0cnVlXG4gICAgfSkpLnRoZW4oc2V0U3RhdGUpLnRoZW4odHJpZ2dlck1vdmVkKTtcbiAgfVxuXG4gIFtnZXRBcHBlbmRhYmxlQ29udGFpbmVyXShzb3VyY2UpIHtcbiAgICBjb25zdCBhcHBlbmRUbyA9IHRoaXMub3B0aW9ucy5hcHBlbmRUbztcbiAgICBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXBwZW5kVG8pO1xuICAgIH0gZWxzZSBpZiAoYXBwZW5kVG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGFwcGVuZFRvO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYXBwZW5kVG8oc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNvdXJjZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlTWlycm9yRGltZW5zaW9ucyh7XG4gIHNvdXJjZSxcbiAgLi4uYXJnc1xufSkge1xuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgY29uc3Qgc291cmNlUmVjdCA9IHNvdXJjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXNvbHZlKHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNvdXJjZVJlY3QsXG4gICAgICAuLi5hcmdzXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVNaXJyb3JPZmZzZXQoe1xuICBzZW5zb3JFdmVudCxcbiAgc291cmNlUmVjdCxcbiAgb3B0aW9ucyxcbiAgLi4uYXJnc1xufSkge1xuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgY29uc3QgdG9wID0gb3B0aW9ucy5jdXJzb3JPZmZzZXRZID09PSBudWxsID8gc2Vuc29yRXZlbnQuY2xpZW50WSAtIHNvdXJjZVJlY3QudG9wIDogb3B0aW9ucy5jdXJzb3JPZmZzZXRZO1xuICAgIGNvbnN0IGxlZnQgPSBvcHRpb25zLmN1cnNvck9mZnNldFggPT09IG51bGwgPyBzZW5zb3JFdmVudC5jbGllbnRYIC0gc291cmNlUmVjdC5sZWZ0IDogb3B0aW9ucy5jdXJzb3JPZmZzZXRYO1xuICAgIGNvbnN0IG1pcnJvck9mZnNldCA9IHtcbiAgICAgIHRvcCxcbiAgICAgIGxlZnRcbiAgICB9O1xuICAgIHJlc29sdmUoe1xuICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICBzb3VyY2VSZWN0LFxuICAgICAgbWlycm9yT2Zmc2V0LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIC4uLmFyZ3NcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0TWlycm9yKHtcbiAgbWlycm9yLFxuICBzb3VyY2UsXG4gIG9wdGlvbnMsXG4gIC4uLmFyZ3Ncbn0pIHtcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGxldCBvZmZzZXRIZWlnaHQ7XG4gICAgbGV0IG9mZnNldFdpZHRoO1xuICAgIGlmIChvcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnMpIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVkU291cmNlU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShzb3VyY2UpO1xuICAgICAgb2Zmc2V0SGVpZ2h0ID0gY29tcHV0ZWRTb3VyY2VTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0Jyk7XG4gICAgICBvZmZzZXRXaWR0aCA9IGNvbXB1dGVkU291cmNlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJyk7XG4gICAgfVxuICAgIG1pcnJvci5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcbiAgICBtaXJyb3Iuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIG1pcnJvci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIG1pcnJvci5zdHlsZS50b3AgPSAwO1xuICAgIG1pcnJvci5zdHlsZS5sZWZ0ID0gMDtcbiAgICBtaXJyb3Iuc3R5bGUubWFyZ2luID0gMDtcbiAgICBpZiAob3B0aW9ucy5jb25zdHJhaW5EaW1lbnNpb25zKSB7XG4gICAgICBtaXJyb3Iuc3R5bGUuaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xuICAgICAgbWlycm9yLnN0eWxlLndpZHRoID0gb2Zmc2V0V2lkdGg7XG4gICAgfVxuICAgIHJlc29sdmUoe1xuICAgICAgbWlycm9yLFxuICAgICAgc291cmNlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIC4uLmFyZ3NcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZE1pcnJvckNsYXNzZXMoe1xuICBtaXJyb3IsXG4gIG1pcnJvckNsYXNzZXMsXG4gIC4uLmFyZ3Ncbn0pIHtcbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIG1pcnJvci5jbGFzc0xpc3QuYWRkKC4uLm1pcnJvckNsYXNzZXMpO1xuICAgIHJlc29sdmUoe1xuICAgICAgbWlycm9yLFxuICAgICAgbWlycm9yQ2xhc3NlcyxcbiAgICAgIC4uLmFyZ3NcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU1pcnJvcklEKHtcbiAgbWlycm9yLFxuICAuLi5hcmdzXG59KSB7XG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBtaXJyb3IucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgIGRlbGV0ZSBtaXJyb3IuaWQ7XG4gICAgcmVzb2x2ZSh7XG4gICAgICBtaXJyb3IsXG4gICAgICAuLi5hcmdzXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvbk1pcnJvcih7XG4gIHdpdGhGcmFtZSA9IGZhbHNlLFxuICBpbml0aWFsID0gZmFsc2Vcbn0gPSB7fSkge1xuICByZXR1cm4gKHtcbiAgICBtaXJyb3IsXG4gICAgc2Vuc29yRXZlbnQsXG4gICAgbWlycm9yT2Zmc2V0LFxuICAgIGluaXRpYWxZLFxuICAgIGluaXRpYWxYLFxuICAgIHNjcm9sbE9mZnNldCxcbiAgICBvcHRpb25zLFxuICAgIHBhc3NlZFRocmVzaFgsXG4gICAgcGFzc2VkVGhyZXNoWSxcbiAgICBsYXN0TW92ZWRYLFxuICAgIGxhc3RNb3ZlZFksXG4gICAgLi4uYXJnc1xuICB9KSA9PiB7XG4gICAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBtaXJyb3IsXG4gICAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgICBtaXJyb3JPZmZzZXQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIC4uLmFyZ3NcbiAgICAgIH07XG4gICAgICBpZiAobWlycm9yT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHggPSBwYXNzZWRUaHJlc2hYID8gTWF0aC5yb3VuZCgoc2Vuc29yRXZlbnQuY2xpZW50WCAtIG1pcnJvck9mZnNldC5sZWZ0IC0gc2Nyb2xsT2Zmc2V0LngpIC8gKG9wdGlvbnMudGhyZXNob2xkWCB8fCAxKSkgKiAob3B0aW9ucy50aHJlc2hvbGRYIHx8IDEpIDogTWF0aC5yb3VuZChsYXN0TW92ZWRYKTtcbiAgICAgICAgY29uc3QgeSA9IHBhc3NlZFRocmVzaFkgPyBNYXRoLnJvdW5kKChzZW5zb3JFdmVudC5jbGllbnRZIC0gbWlycm9yT2Zmc2V0LnRvcCAtIHNjcm9sbE9mZnNldC55KSAvIChvcHRpb25zLnRocmVzaG9sZFkgfHwgMSkpICogKG9wdGlvbnMudGhyZXNob2xkWSB8fCAxKSA6IE1hdGgucm91bmQobGFzdE1vdmVkWSk7XG4gICAgICAgIGlmIChvcHRpb25zLnhBeGlzICYmIG9wdGlvbnMueUF4aXMgfHwgaW5pdGlhbCkge1xuICAgICAgICAgIG1pcnJvci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsIDApYDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnhBeGlzICYmICFvcHRpb25zLnlBeGlzKSB7XG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7aW5pdGlhbFl9cHgsIDApYDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnlBeGlzICYmICFvcHRpb25zLnhBeGlzKSB7XG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2luaXRpYWxYfXB4LCAke3l9cHgsIDApYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbCkge1xuICAgICAgICAgIHJlc3VsdC5pbml0aWFsWCA9IHg7XG4gICAgICAgICAgcmVzdWx0LmluaXRpYWxZID0geTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQubGFzdE1vdmVkWCA9IHg7XG4gICAgICAgIHJlc3VsdC5sYXN0TW92ZWRZID0geTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9LCB7XG4gICAgICBmcmFtZTogd2l0aEZyYW1lXG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHdpdGhQcm9taXNlKGNhbGxiYWNrLCB7XG4gIHJhZiA9IGZhbHNlXG59ID0ge30pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAocmFmKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNOYXRpdmVEcmFnRXZlbnQoc2Vuc29yRXZlbnQpIHtcbiAgcmV0dXJuIC9eZHJhZy8udGVzdChzZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50LnR5cGUpO1xufVxuXG5leHBvcnQgeyBNaXJyb3IgYXMgZGVmYXVsdCwgZGVmYXVsdE9wdGlvbnMsIGdldEFwcGVuZGFibGVDb250YWluZXIsIG9uRHJhZ01vdmUsIG9uRHJhZ1N0YXJ0LCBvbkRyYWdTdG9wLCBvbk1pcnJvckNyZWF0ZWQsIG9uTWlycm9yTW92ZSwgb25TY3JvbGwgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdFBsdWdpbiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9BYnN0cmFjdFBsdWdpbi9BYnN0cmFjdFBsdWdpbi5tanMnO1xuaW1wb3J0IGNsb3Nlc3QgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2Nsb3Nlc3QvY2xvc2VzdC5tanMnO1xuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IHNjcm9sbCA9IFN5bWJvbCgnc2Nyb2xsJyk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBzcGVlZDogNixcbiAgc2Vuc2l0aXZpdHk6IDUwLFxuICBzY3JvbGxhYmxlRWxlbWVudHM6IFtdXG59O1xuXG5jbGFzcyBTY3JvbGxhYmxlIGV4dGVuZHMgQWJzdHJhY3RQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIHN1cGVyKGRyYWdnYWJsZSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLnRoaXMuZ2V0T3B0aW9ucygpXG4gICAgfTtcblxuICAgIHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24gPSBudWxsO1xuXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IG51bGw7XG5cbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSBudWxsO1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tzY3JvbGxdID0gdGhpc1tzY3JvbGxdLmJpbmQodGhpcyk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zY3JvbGxhYmxlIHx8IHt9O1xuICB9XG5cbiAgZ2V0U2Nyb2xsYWJsZUVsZW1lbnQodGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMuaGFzRGVmaW5lZFNjcm9sbGFibGVFbGVtZW50cygpKSB7XG4gICAgICByZXR1cm4gY2xvc2VzdCh0YXJnZXQsIHRoaXMub3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHMpIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNsb3Nlc3RTY3JvbGxhYmxlRWxlbWVudCh0YXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIGhhc0RlZmluZWRTY3JvbGxhYmxlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5vcHRpb25zLnNjcm9sbGFibGVFbGVtZW50cy5sZW5ndGggIT09IDApO1xuICB9XG5cbiAgW29uRHJhZ1N0YXJ0XShkcmFnRXZlbnQpIHtcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLmdldFNjcm9sbGFibGVFbGVtZW50KGRyYWdFdmVudC5zb3VyY2UpO1xuICAgIH0pO1xuICB9XG5cbiAgW29uRHJhZ01vdmVdKGRyYWdFdmVudCkge1xuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudCA9IHRoaXMuZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZHJhZ0V2ZW50LnNlbnNvckV2ZW50LnRhcmdldCk7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLnNjcm9sbGFibGVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZHJhZ0V2ZW50LnNlbnNvckV2ZW50O1xuICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgICBzY3JvbGxPZmZzZXQueSA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICBzY3JvbGxPZmZzZXQueCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgMDtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IHtcbiAgICAgIGNsaWVudFg6IHNlbnNvckV2ZW50LmNsaWVudFggLSBzY3JvbGxPZmZzZXQueCxcbiAgICAgIGNsaWVudFk6IHNlbnNvckV2ZW50LmNsaWVudFkgLSBzY3JvbGxPZmZzZXQueVxuICAgIH07XG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW3Njcm9sbF0pO1xuICB9XG5cbiAgW29uRHJhZ1N0b3BdKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUpO1xuICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24gPSBudWxsO1xuICB9XG5cbiAgW3Njcm9sbF0oKSB7XG4gICAgaWYgKCF0aGlzLnNjcm9sbGFibGVFbGVtZW50IHx8ICF0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNwZWVkLFxuICAgICAgc2Vuc2l0aXZpdHlcbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnNjcm9sbGFibGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGJvdHRvbUN1dE9mZiA9IHJlY3QuYm90dG9tID4gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGNvbnN0IHRvcEN1dE9mZiA9IHJlY3QudG9wIDwgMDtcbiAgICBjb25zdCBjdXRPZmYgPSB0b3BDdXRPZmYgfHwgYm90dG9tQ3V0T2ZmO1xuICAgIGNvbnN0IGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCA9IGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gdGhpcy5zY3JvbGxhYmxlRWxlbWVudDtcbiAgICBjb25zdCBjbGllbnRYID0gdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRYO1xuICAgIGNvbnN0IGNsaWVudFkgPSB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFk7XG4gICAgaWYgKHNjcm9sbGFibGVFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIHNjcm9sbGFibGVFbGVtZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgIWN1dE9mZikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXRIZWlnaHQsXG4gICAgICAgIG9mZnNldFdpZHRoXG4gICAgICB9ID0gc2Nyb2xsYWJsZUVsZW1lbnQ7XG4gICAgICBpZiAocmVjdC50b3AgKyBvZmZzZXRIZWlnaHQgLSBjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsVG9wICs9IHNwZWVkO1xuICAgICAgfSBlbHNlIGlmIChjbGllbnRZIC0gcmVjdC50b3AgPCBzZW5zaXRpdml0eSkge1xuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3AgLT0gc3BlZWQ7XG4gICAgICB9XG4gICAgICBpZiAocmVjdC5sZWZ0ICsgb2Zmc2V0V2lkdGggLSBjbGllbnRYIDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsTGVmdCArPSBzcGVlZDtcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50WCAtIHJlY3QubGVmdCA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbExlZnQgLT0gc3BlZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5uZXJIZWlnaHQsXG4gICAgICAgIGlubmVyV2lkdGhcbiAgICAgIH0gPSB3aW5kb3c7XG4gICAgICBpZiAoY2xpZW50WSA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgLT0gc3BlZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlubmVySGVpZ2h0IC0gY2xpZW50WSA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgKz0gc3BlZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0IC09IHNwZWVkO1xuICAgICAgfSBlbHNlIGlmIChpbm5lcldpZHRoIC0gY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ICs9IHNwZWVkO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbc2Nyb2xsXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzT3ZlcmZsb3coZWxlbWVudCkge1xuICBjb25zdCBvdmVyZmxvd1JlZ2V4ID0gLyhhdXRvfHNjcm9sbCkvO1xuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIGNvbnN0IG92ZXJmbG93ID0gY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cnKSArIGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXknKSArIGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXgnKTtcbiAgcmV0dXJuIG92ZXJmbG93UmVnZXgudGVzdChvdmVyZmxvdyk7XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljYWxseVBvc2l0aW9uZWQoZWxlbWVudCkge1xuICBjb25zdCBwb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAnc3RhdGljJztcbn1cblxuZnVuY3Rpb24gY2xvc2VzdFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGdldERvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCgpO1xuICB9XG4gIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuICBjb25zdCBleGNsdWRlU3RhdGljUGFyZW50cyA9IHBvc2l0aW9uID09PSAnYWJzb2x1dGUnO1xuICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IGNsb3Nlc3QoZWxlbWVudCwgcGFyZW50ID0+IHtcbiAgICBpZiAoZXhjbHVkZVN0YXRpY1BhcmVudHMgJiYgaXNTdGF0aWNhbGx5UG9zaXRpb25lZChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBoYXNPdmVyZmxvdyhwYXJlbnQpO1xuICB9KTtcbiAgaWYgKHBvc2l0aW9uID09PSAnZml4ZWQnIHx8ICFzY3JvbGxhYmxlRWxlbWVudCkge1xuICAgIHJldHVybiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2Nyb2xsYWJsZUVsZW1lbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCkge1xuICByZXR1cm4gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbmV4cG9ydCB7IFNjcm9sbGFibGUgYXMgZGVmYXVsdCwgZGVmYXVsdE9wdGlvbnMsIG9uRHJhZ01vdmUsIG9uRHJhZ1N0YXJ0LCBvbkRyYWdTdG9wLCBzY3JvbGwgfTtcbiIsICJjbGFzcyBFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgfVxuXG4gIG9uKHR5cGUsIC4uLmNhbGxiYWNrcykge1xuICAgIGlmICghdGhpcy5jYWxsYmFja3NbdHlwZV0pIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdID0gW107XG4gICAgfVxuICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdLnB1c2goLi4uY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9mZih0eXBlLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5jYWxsYmFja3NbdHlwZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjb3B5ID0gdGhpcy5jYWxsYmFja3NbdHlwZV0uc2xpY2UoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3B5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2FsbGJhY2sgPT09IGNvcHlbaV0pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3NbdHlwZV0uc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRyaWdnZXIoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50LnR5cGVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY2FsbGJhY2tzID0gWy4uLnRoaXMuY2FsbGJhY2tzW2V2ZW50LnR5cGVdXTtcbiAgICBjb25zdCBjYXVnaHRFcnJvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhdWdodEVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNhdWdodEVycm9ycy5sZW5ndGgpIHtcblxuICAgICAgY29uc29sZS5lcnJvcihgRHJhZ2dhYmxlIGNhdWdodCBlcnJvcnMgd2hpbGUgdHJpZ2dlcmluZyAnJHtldmVudC50eXBlfSdgLCBjYXVnaHRFcnJvcnMpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IHsgRW1pdHRlciBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RFdmVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9BYnN0cmFjdEV2ZW50L0Fic3RyYWN0RXZlbnQubWpzJztcblxuY2xhc3MgRHJhZ2dhYmxlRXZlbnQgZXh0ZW5kcyBBYnN0cmFjdEV2ZW50IHtcblxuICBnZXQgZHJhZ2dhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ2dhYmxlO1xuICB9XG59XG5cbkRyYWdnYWJsZUV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlJztcbmNsYXNzIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgZXh0ZW5kcyBEcmFnZ2FibGVFdmVudCB7fVxuXG5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlOmluaXRpYWxpemUnO1xuY2xhc3MgRHJhZ2dhYmxlRGVzdHJveUV2ZW50IGV4dGVuZHMgRHJhZ2dhYmxlRXZlbnQge31cbkRyYWdnYWJsZURlc3Ryb3lFdmVudC50eXBlID0gJ2RyYWdnYWJsZTpkZXN0cm95JztcblxuZXhwb3J0IHsgRHJhZ2dhYmxlRGVzdHJveUV2ZW50LCBEcmFnZ2FibGVFdmVudCwgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCB9O1xuIiwgImltcG9ydCBjbG9zZXN0IGZyb20gJy4uL3NoYXJlZC91dGlscy9jbG9zZXN0L2Nsb3Nlc3QubWpzJztcbmltcG9ydCBBbm5vdW5jZW1lbnQgZnJvbSAnLi9QbHVnaW5zL0Fubm91bmNlbWVudC9Bbm5vdW5jZW1lbnQubWpzJztcbmltcG9ydCBGb2N1c2FibGUgZnJvbSAnLi9QbHVnaW5zL0ZvY3VzYWJsZS9Gb2N1c2FibGUubWpzJztcbmltcG9ydCBNaXJyb3IgZnJvbSAnLi9QbHVnaW5zL01pcnJvci9NaXJyb3IubWpzJztcbmltcG9ydCBTY3JvbGxhYmxlIGZyb20gJy4vUGx1Z2lucy9TY3JvbGxhYmxlL1Njcm9sbGFibGUubWpzJztcbmltcG9ydCBFbWl0dGVyIGZyb20gJy4vRW1pdHRlci9FbWl0dGVyLm1qcyc7XG5pbXBvcnQgTW91c2VTZW5zb3IgZnJvbSAnLi9TZW5zb3JzL01vdXNlU2Vuc29yL01vdXNlU2Vuc29yLm1qcyc7XG5pbXBvcnQgVG91Y2hTZW5zb3IgZnJvbSAnLi9TZW5zb3JzL1RvdWNoU2Vuc29yL1RvdWNoU2Vuc29yLm1qcyc7XG5pbXBvcnQgJy4vU2Vuc29ycy9TZW5zb3JFdmVudC9TZW5zb3JFdmVudC5tanMnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCwgRHJhZ2dhYmxlRGVzdHJveUV2ZW50IH0gZnJvbSAnLi9EcmFnZ2FibGVFdmVudC9EcmFnZ2FibGVFdmVudC5tanMnO1xuaW1wb3J0IHsgRHJhZ1N0YXJ0RXZlbnQsIERyYWdNb3ZlRXZlbnQsIERyYWdPdXRFdmVudCwgRHJhZ091dENvbnRhaW5lckV2ZW50LCBEcmFnT3ZlckNvbnRhaW5lckV2ZW50LCBEcmFnT3ZlckV2ZW50LCBEcmFnU3RvcEV2ZW50LCBEcmFnU3RvcHBlZEV2ZW50LCBEcmFnUHJlc3N1cmVFdmVudCB9IGZyb20gJy4vRHJhZ0V2ZW50L0RyYWdFdmVudC5tanMnO1xuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IG9uRHJhZ1ByZXNzdXJlID0gU3ltYm9sKCdvbkRyYWdQcmVzc3VyZScpO1xuY29uc3QgZHJhZ1N0b3AgPSBTeW1ib2woJ2RyYWdTdG9wJyk7XG5cbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xuICAnZHJhZzpzdGFydCc6IGV2ZW50ID0+IGBQaWNrZWQgdXAgJHtldmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGV2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnfWAsXG4gICdkcmFnOnN0b3AnOiBldmVudCA9PiBgUmVsZWFzZWQgJHtldmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGV2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnfWBcbn07XG5jb25zdCBkZWZhdWx0Q2xhc3NlcyA9IHtcbiAgJ2NvbnRhaW5lcjpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1pcy1kcmFnZ2luZycsXG4gICdzb3VyY2U6ZHJhZ2dpbmcnOiAnZHJhZ2dhYmxlLXNvdXJjZS0taXMtZHJhZ2dpbmcnLFxuICAnc291cmNlOnBsYWNlZCc6ICdkcmFnZ2FibGUtc291cmNlLS1wbGFjZWQnLFxuICAnY29udGFpbmVyOnBsYWNlZCc6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1wbGFjZWQnLFxuICAnYm9keTpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtLWlzLWRyYWdnaW5nJyxcbiAgJ2RyYWdnYWJsZTpvdmVyJzogJ2RyYWdnYWJsZS0tb3ZlcicsXG4gICdjb250YWluZXI6b3Zlcic6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1vdmVyJyxcbiAgJ3NvdXJjZTpvcmlnaW5hbCc6ICdkcmFnZ2FibGUtLW9yaWdpbmFsJyxcbiAgbWlycm9yOiAnZHJhZ2dhYmxlLW1pcnJvcidcbn07XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZHJhZ2dhYmxlOiAnLmRyYWdnYWJsZS1zb3VyY2UnLFxuICBoYW5kbGU6IG51bGwsXG4gIGRlbGF5OiB7fSxcbiAgZGlzdGFuY2U6IDAsXG4gIHBsYWNlZFRpbWVvdXQ6IDgwMCxcbiAgcGx1Z2luczogW10sXG4gIHNlbnNvcnM6IFtdLFxuICBleGNsdWRlOiB7XG4gICAgcGx1Z2luczogW10sXG4gICAgc2Vuc29yczogW11cbiAgfVxufTtcblxuY2xhc3MgRHJhZ2dhYmxlIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW2RvY3VtZW50LmJvZHldLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmIChjb250YWluZXJzIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgY29udGFpbmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLmNvbnRhaW5lcnMgPSBbLi4uY29udGFpbmVyc107XG4gICAgfSBlbHNlIGlmIChjb250YWluZXJzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVycyA9IFtjb250YWluZXJzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcmFnZ2FibGUgY29udGFpbmVycyBhcmUgZXhwZWN0ZWQgdG8gYmUgb2YgdHlwZSBgTm9kZUxpc3RgLCBgSFRNTEVsZW1lbnRbXWAgb3IgYEhUTUxFbGVtZW50YCcpO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgIC4uLmRlZmF1bHRDbGFzc2VzLFxuICAgICAgICAuLi4ob3B0aW9ucy5jbGFzc2VzIHx8IHt9KVxuICAgICAgfSxcbiAgICAgIGFubm91bmNlbWVudHM6IHtcbiAgICAgICAgLi4uZGVmYXVsdEFubm91bmNlbWVudHMsXG4gICAgICAgIC4uLihvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXG4gICAgICB9LFxuICAgICAgZXhjbHVkZToge1xuICAgICAgICBwbHVnaW5zOiBvcHRpb25zLmV4Y2x1ZGUgJiYgb3B0aW9ucy5leGNsdWRlLnBsdWdpbnMgfHwgW10sXG4gICAgICAgIHNlbnNvcnM6IG9wdGlvbnMuZXhjbHVkZSAmJiBvcHRpb25zLmV4Y2x1ZGUuc2Vuc29ycyB8fCBbXVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5wbHVnaW5zID0gW107XG5cbiAgICB0aGlzLnNlbnNvcnMgPSBbXTtcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnUHJlc3N1cmVdID0gdGhpc1tvbkRyYWdQcmVzc3VyZV0uYmluZCh0aGlzKTtcbiAgICB0aGlzW2RyYWdTdG9wXSA9IHRoaXNbZHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnByZXNzdXJlJywgdGhpc1tvbkRyYWdQcmVzc3VyZV0sIHRydWUpO1xuICAgIGNvbnN0IGRlZmF1bHRQbHVnaW5zID0gT2JqZWN0LnZhbHVlcyhEcmFnZ2FibGUuUGx1Z2lucykuZmlsdGVyKFBsdWdpbiA9PiAhdGhpcy5vcHRpb25zLmV4Y2x1ZGUucGx1Z2lucy5pbmNsdWRlcyhQbHVnaW4pKTtcbiAgICBjb25zdCBkZWZhdWx0U2Vuc29ycyA9IE9iamVjdC52YWx1ZXMoRHJhZ2dhYmxlLlNlbnNvcnMpLmZpbHRlcihzZW5zb3IgPT4gIXRoaXMub3B0aW9ucy5leGNsdWRlLnNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yKSk7XG4gICAgdGhpcy5hZGRQbHVnaW4oLi4uWy4uLmRlZmF1bHRQbHVnaW5zLCAuLi50aGlzLm9wdGlvbnMucGx1Z2luc10pO1xuICAgIHRoaXMuYWRkU2Vuc29yKC4uLlsuLi5kZWZhdWx0U2Vuc29ycywgLi4udGhpcy5vcHRpb25zLnNlbnNvcnNdKTtcbiAgICBjb25zdCBkcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50ID0gbmV3IERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQoe1xuICAgICAgZHJhZ2dhYmxlOiB0aGlzXG4gICAgfSk7XG4gICAgdGhpcy5vbignbWlycm9yOmNyZWF0ZWQnLCAoe1xuICAgICAgbWlycm9yXG4gICAgfSkgPT4gdGhpcy5taXJyb3IgPSBtaXJyb3IpO1xuICAgIHRoaXMub24oJ21pcnJvcjpkZXN0cm95JywgKCkgPT4gdGhpcy5taXJyb3IgPSBudWxsKTtcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpwcmVzc3VyZScsIHRoaXNbb25EcmFnUHJlc3N1cmVdLCB0cnVlKTtcbiAgICBjb25zdCBkcmFnZ2FibGVEZXN0cm95RXZlbnQgPSBuZXcgRHJhZ2dhYmxlRGVzdHJveUV2ZW50KHtcbiAgICAgIGRyYWdnYWJsZTogdGhpc1xuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihkcmFnZ2FibGVEZXN0cm95RXZlbnQpO1xuICAgIHRoaXMucmVtb3ZlUGx1Z2luKC4uLnRoaXMucGx1Z2lucy5tYXAocGx1Z2luID0+IHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xuICAgIHRoaXMucmVtb3ZlU2Vuc29yKC4uLnRoaXMuc2Vuc29ycy5tYXAoc2Vuc29yID0+IHNlbnNvci5jb25zdHJ1Y3RvcikpO1xuICB9XG5cbiAgYWRkUGx1Z2luKC4uLnBsdWdpbnMpIHtcbiAgICBjb25zdCBhY3RpdmVQbHVnaW5zID0gcGx1Z2lucy5tYXAoUGx1Z2luID0+IG5ldyBQbHVnaW4odGhpcykpO1xuICAgIGFjdGl2ZVBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmF0dGFjaCgpKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBbLi4udGhpcy5wbHVnaW5zLCAuLi5hY3RpdmVQbHVnaW5zXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZVBsdWdpbiguLi5wbHVnaW5zKSB7XG4gICAgY29uc3QgcmVtb3ZlZFBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiBwbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xuICAgIHJlbW92ZWRQbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHBsdWdpbi5kZXRhY2goKSk7XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gIXBsdWdpbnMuaW5jbHVkZXMocGx1Z2luLmNvbnN0cnVjdG9yKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRTZW5zb3IoLi4uc2Vuc29ycykge1xuICAgIGNvbnN0IGFjdGl2ZVNlbnNvcnMgPSBzZW5zb3JzLm1hcChTZW5zb3IgPT4gbmV3IFNlbnNvcih0aGlzLmNvbnRhaW5lcnMsIHRoaXMub3B0aW9ucykpO1xuICAgIGFjdGl2ZVNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLmF0dGFjaCgpKTtcbiAgICB0aGlzLnNlbnNvcnMgPSBbLi4udGhpcy5zZW5zb3JzLCAuLi5hY3RpdmVTZW5zb3JzXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZVNlbnNvciguLi5zZW5zb3JzKSB7XG4gICAgY29uc3QgcmVtb3ZlZFNlbnNvcnMgPSB0aGlzLnNlbnNvcnMuZmlsdGVyKHNlbnNvciA9PiBzZW5zb3JzLmluY2x1ZGVzKHNlbnNvci5jb25zdHJ1Y3RvcikpO1xuICAgIHJlbW92ZWRTZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5kZXRhY2goKSk7XG4gICAgdGhpcy5zZW5zb3JzID0gdGhpcy5zZW5zb3JzLmZpbHRlcihzZW5zb3IgPT4gIXNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yLmNvbnN0cnVjdG9yKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRDb250YWluZXIoLi4uY29udGFpbmVycykge1xuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi50aGlzLmNvbnRhaW5lcnMsIC4uLmNvbnRhaW5lcnNdO1xuICAgIHRoaXMuc2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuYWRkQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSB7XG4gICAgdGhpcy5jb250YWluZXJzID0gdGhpcy5jb250YWluZXJzLmZpbHRlcihjb250YWluZXIgPT4gIWNvbnRhaW5lcnMuaW5jbHVkZXMoY29udGFpbmVyKSk7XG4gICAgdGhpcy5zZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5yZW1vdmVDb250YWluZXIoLi4uY29udGFpbmVycykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb24odHlwZSwgLi4uY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9uKHR5cGUsIC4uLmNhbGxiYWNrcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvZmYodHlwZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIub2ZmKHR5cGUsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRyaWdnZXIoZXZlbnQpIHtcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcihldmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRDbGFzc05hbWVGb3IobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdldENsYXNzTmFtZXNGb3IobmFtZSlbMF07XG4gIH1cblxuICBnZXRDbGFzc05hbWVzRm9yKG5hbWUpIHtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdGhpcy5vcHRpb25zLmNsYXNzZXNbbmFtZV07XG4gICAgaWYgKGNsYXNzTmFtZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZycgfHwgY2xhc3NOYW1lcyBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgcmV0dXJuIFtjbGFzc05hbWVzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIGlzRHJhZ2dpbmcoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5kcmFnZ2luZyk7XG4gIH1cblxuICBnZXREcmFnZ2FibGVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJzLnJlZHVjZSgoY3VycmVudCwgY29udGFpbmVyKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLmN1cnJlbnQsIC4uLnRoaXMuZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKV07XG4gICAgfSwgW10pO1xuICB9XG5cbiAgZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgY29uc3QgYWxsRHJhZ2dhYmxlRWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICByZXR1cm4gWy4uLmFsbERyYWdnYWJsZUVsZW1lbnRzXS5maWx0ZXIoY2hpbGRFbGVtZW50ID0+IHtcbiAgICAgIHJldHVybiBjaGlsZEVsZW1lbnQgIT09IHRoaXMub3JpZ2luYWxTb3VyY2UgJiYgY2hpbGRFbGVtZW50ICE9PSB0aGlzLm1pcnJvcjtcbiAgICB9KTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzW2RyYWdTdG9wXSgpO1xuICB9XG5cbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsU291cmNlXG4gICAgfSA9IHNlbnNvckV2ZW50O1xuICAgIGlmICghdGhpcy5jb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGUgJiYgdGFyZ2V0ICYmICFjbG9zZXN0KHRhcmdldCwgdGhpcy5vcHRpb25zLmhhbmRsZSkpIHtcbiAgICAgIHNlbnNvckV2ZW50LmNhbmNlbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gb3JpZ2luYWxTb3VyY2U7XG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgaWYgKHRoaXMubGFzdFBsYWNlZFNvdXJjZSAmJiB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBsYWNlZFRpbWVvdXRJRCk7XG4gICAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XG4gICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XG4gICAgfVxuICAgIHRoaXMuc291cmNlID0gdGhpcy5vcmlnaW5hbFNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnNvdXJjZSwgdGhpcy5vcmlnaW5hbFNvdXJjZSk7XG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IERyYWdTdGFydEV2ZW50KHtcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgc2Vuc29yRXZlbnRcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1N0YXJ0RXZlbnQpO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKTtcbiAgICBpZiAoZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgdGhpcy5zb3VyY2UucmVtb3ZlKCk7XG4gICAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6b3JpZ2luYWwnKSk7XG4gICAgdGhpcy5zb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOmRyYWdnaW5nJykpO1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2JvZHk6ZHJhZ2dpbmcnKSk7XG4gICAgYXBwbHlVc2VyU2VsZWN0KGRvY3VtZW50LmJvZHksICdub25lJyk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGNvbnN0IG9sZFNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xuICAgICAgY29uc3QgbmV3U2Vuc29yRXZlbnQgPSBvbGRTZW5zb3JFdmVudC5jbG9uZSh7XG4gICAgICAgIHRhcmdldDogdGhpcy5zb3VyY2VcbiAgICAgIH0pO1xuICAgICAgdGhpc1tvbkRyYWdNb3ZlXSh7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICBkZXRhaWw6IG5ld1NlbnNvckV2ZW50XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIFtvbkRyYWdNb3ZlXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXJcbiAgICB9ID0gc2Vuc29yRXZlbnQ7XG4gICAgbGV0IHRhcmdldCA9IHNlbnNvckV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IERyYWdNb3ZlRXZlbnQoe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihkcmFnTW92ZUV2ZW50KTtcbiAgICBpZiAoZHJhZ01vdmVFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICBzZW5zb3JFdmVudC5jYW5jZWwoKTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIGNvbnN0IHdpdGhpbkNvcnJlY3RDb250YWluZXIgPSBjbG9zZXN0KHNlbnNvckV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcbiAgICBjb25zdCBvdmVyQ29udGFpbmVyID0gc2Vuc29yRXZlbnQub3ZlckNvbnRhaW5lciB8fCB3aXRoaW5Db3JyZWN0Q29udGFpbmVyO1xuICAgIGNvbnN0IGlzTGVhdmluZ0NvbnRhaW5lciA9IHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgJiYgb3ZlckNvbnRhaW5lciAhPT0gdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcjtcbiAgICBjb25zdCBpc0xlYXZpbmdEcmFnZ2FibGUgPSB0aGlzLmN1cnJlbnRPdmVyICYmIHRhcmdldCAhPT0gdGhpcy5jdXJyZW50T3ZlcjtcbiAgICBjb25zdCBpc092ZXJDb250YWluZXIgPSBvdmVyQ29udGFpbmVyICYmIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgIT09IG92ZXJDb250YWluZXI7XG4gICAgY29uc3QgaXNPdmVyRHJhZ2dhYmxlID0gd2l0aGluQ29ycmVjdENvbnRhaW5lciAmJiB0YXJnZXQgJiYgdGhpcy5jdXJyZW50T3ZlciAhPT0gdGFyZ2V0O1xuICAgIGlmIChpc0xlYXZpbmdEcmFnZ2FibGUpIHtcbiAgICAgIGNvbnN0IGRyYWdPdXRFdmVudCA9IG5ldyBEcmFnT3V0RXZlbnQoe1xuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgICBvdmVyOiB0aGlzLmN1cnJlbnRPdmVyLFxuICAgICAgICBvdmVyQ29udGFpbmVyOiB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyXG4gICAgICB9KTtcbiAgICAgIHRoaXMuY3VycmVudE92ZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2RyYWdnYWJsZTpvdmVyJykpO1xuICAgICAgdGhpcy5jdXJyZW50T3ZlciA9IG51bGw7XG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ091dEV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzTGVhdmluZ0NvbnRhaW5lcikge1xuICAgICAgY29uc3QgZHJhZ091dENvbnRhaW5lckV2ZW50ID0gbmV3IERyYWdPdXRDb250YWluZXJFdmVudCh7XG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICAgIG92ZXJDb250YWluZXI6IHRoaXMuY3VycmVudE92ZXJDb250YWluZXJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOm92ZXInKSk7XG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gbnVsbDtcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3V0Q29udGFpbmVyRXZlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNPdmVyQ29udGFpbmVyKSB7XG4gICAgICBvdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdjb250YWluZXI6b3ZlcicpKTtcbiAgICAgIGNvbnN0IGRyYWdPdmVyQ29udGFpbmVyRXZlbnQgPSBuZXcgRHJhZ092ZXJDb250YWluZXJFdmVudCh7XG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICAgIG92ZXJDb250YWluZXJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciA9IG92ZXJDb250YWluZXI7XG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ092ZXJDb250YWluZXJFdmVudCk7XG4gICAgfVxuICAgIGlmIChpc092ZXJEcmFnZ2FibGUpIHtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJhZ2dhYmxlOm92ZXInKSk7XG4gICAgICBjb25zdCBkcmFnT3ZlckV2ZW50ID0gbmV3IERyYWdPdmVyRXZlbnQoe1xuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgICBvdmVyQ29udGFpbmVyLFxuICAgICAgICBvdmVyOiB0YXJnZXRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50T3ZlciA9IHRhcmdldDtcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3ZlckV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBbZHJhZ1N0b3BdKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IERyYWdTdG9wRXZlbnQoe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgc2Vuc29yRXZlbnQ6IGV2ZW50ID8gZXZlbnQuc2Vuc29yRXZlbnQgOiBudWxsLFxuICAgICAgc291cmNlQ29udGFpbmVyOiB0aGlzLnNvdXJjZUNvbnRhaW5lclxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihkcmFnU3RvcEV2ZW50KTtcbiAgICBpZiAoIWRyYWdTdG9wRXZlbnQuY2FuY2VsZWQoKSkgdGhpcy5zb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5vcmlnaW5hbFNvdXJjZSwgdGhpcy5zb3VyY2UpO1xuICAgIHRoaXMuc291cmNlLnJlbW92ZSgpO1xuICAgIHRoaXMub3JpZ2luYWxTb3VyY2Uuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIHRoaXMuc291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0Zvcignc291cmNlOm9yaWdpbmFsJykpO1xuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpkcmFnZ2luZycpKTtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdib2R5OmRyYWdnaW5nJykpO1xuICAgIGFwcGx5VXNlclNlbGVjdChkb2N1bWVudC5ib2R5LCAnJyk7XG4gICAgaWYgKHRoaXMuY3VycmVudE92ZXIpIHtcbiAgICAgIHRoaXMuY3VycmVudE92ZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2RyYWdnYWJsZTpvdmVyJykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignY29udGFpbmVyOm92ZXInKSk7XG4gICAgfVxuICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZSA9IHRoaXMub3JpZ2luYWxTb3VyY2U7XG4gICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyID0gdGhpcy5zb3VyY2VDb250YWluZXI7XG4gICAgdGhpcy5wbGFjZWRUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmxhc3RQbGFjZWRTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5sYXN0UGxhY2VkU291cmNlLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGFzdFBsYWNlZENvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLmdldENsYXNzTmFtZXNGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyID0gbnVsbDtcbiAgICB9LCB0aGlzLm9wdGlvbnMucGxhY2VkVGltZW91dCk7XG4gICAgY29uc3QgZHJhZ1N0b3BwZWRFdmVudCA9IG5ldyBEcmFnU3RvcHBlZEV2ZW50KHtcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNlbnNvckV2ZW50OiBldmVudCA/IGV2ZW50LnNlbnNvckV2ZW50IDogbnVsbCxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogdGhpcy5zb3VyY2VDb250YWluZXJcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1N0b3BwZWRFdmVudCk7XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudE92ZXIgPSBudWxsO1xuICAgIHRoaXMuc291cmNlQ29udGFpbmVyID0gbnVsbDtcbiAgfVxuXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xuICAgIHRoaXNbZHJhZ1N0b3BdKGV2ZW50KTtcbiAgfVxuXG4gIFtvbkRyYWdQcmVzc3VyZV0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UgfHwgY2xvc2VzdChzZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgRHJhZ1ByZXNzdXJlRXZlbnQoe1xuICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICBzb3VyY2UsXG4gICAgICBwcmVzc3VyZTogc2Vuc29yRXZlbnQucHJlc3N1cmVcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ1ByZXNzdXJlRXZlbnQpO1xuICB9XG59XG5cbkRyYWdnYWJsZS5QbHVnaW5zID0ge1xuICBBbm5vdW5jZW1lbnQsXG4gIEZvY3VzYWJsZSxcbiAgTWlycm9yLFxuICBTY3JvbGxhYmxlXG59O1xuXG5EcmFnZ2FibGUuU2Vuc29ycyA9IHtcbiAgTW91c2VTZW5zb3IsXG4gIFRvdWNoU2Vuc29yXG59O1xuZnVuY3Rpb24gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmRldGFpbDtcbn1cbmZ1bmN0aW9uIGFwcGx5VXNlclNlbGVjdChlbGVtZW50LCB2YWx1ZSkge1xuICBlbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSB2YWx1ZTtcbiAgZWxlbWVudC5zdHlsZS5tb3pVc2VyU2VsZWN0ID0gdmFsdWU7XG4gIGVsZW1lbnQuc3R5bGUubXNVc2VyU2VsZWN0ID0gdmFsdWU7XG4gIGVsZW1lbnQuc3R5bGUub1VzZXJTZWxlY3QgPSB2YWx1ZTtcbiAgZWxlbWVudC5zdHlsZS51c2VyU2VsZWN0ID0gdmFsdWU7XG59XG5cbmV4cG9ydCB7IERyYWdnYWJsZSBhcyBkZWZhdWx0LCBkZWZhdWx0T3B0aW9ucyB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0RXZlbnQgfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RFdmVudC9BYnN0cmFjdEV2ZW50Lm1qcyc7XG5cbmNsYXNzIERyb3BwYWJsZUV2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5Ecm9wcGFibGVFdmVudC50eXBlID0gJ2Ryb3BwYWJsZSc7XG5cbmNsYXNzIERyb3BwYWJsZVN0YXJ0RXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XG5cbiAgZ2V0IGRyb3B6b25lKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJvcHpvbmU7XG4gIH1cbn1cbkRyb3BwYWJsZVN0YXJ0RXZlbnQudHlwZSA9ICdkcm9wcGFibGU6c3RhcnQnO1xuRHJvcHBhYmxlU3RhcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuY2xhc3MgRHJvcHBhYmxlRHJvcHBlZEV2ZW50IGV4dGVuZHMgRHJvcHBhYmxlRXZlbnQge1xuXG4gIGdldCBkcm9wem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xuICB9XG59XG5Ecm9wcGFibGVEcm9wcGVkRXZlbnQudHlwZSA9ICdkcm9wcGFibGU6ZHJvcHBlZCc7XG5Ecm9wcGFibGVEcm9wcGVkRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5cbmNsYXNzIERyb3BwYWJsZVJldHVybmVkRXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XG5cbiAgZ2V0IGRyb3B6b25lKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJvcHpvbmU7XG4gIH1cbn1cbkRyb3BwYWJsZVJldHVybmVkRXZlbnQudHlwZSA9ICdkcm9wcGFibGU6cmV0dXJuZWQnO1xuRHJvcHBhYmxlUmV0dXJuZWRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuY2xhc3MgRHJvcHBhYmxlU3RvcEV2ZW50IGV4dGVuZHMgRHJvcHBhYmxlRXZlbnQge1xuXG4gIGdldCBkcm9wem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xuICB9XG59XG5Ecm9wcGFibGVTdG9wRXZlbnQudHlwZSA9ICdkcm9wcGFibGU6c3RvcCc7XG5Ecm9wcGFibGVTdG9wRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5cbmV4cG9ydCB7IERyb3BwYWJsZURyb3BwZWRFdmVudCwgRHJvcHBhYmxlRXZlbnQsIERyb3BwYWJsZVJldHVybmVkRXZlbnQsIERyb3BwYWJsZVN0YXJ0RXZlbnQsIERyb3BwYWJsZVN0b3BFdmVudCB9O1xuIiwgImltcG9ydCBjbG9zZXN0IGZyb20gJy4uL3NoYXJlZC91dGlscy9jbG9zZXN0L2Nsb3Nlc3QubWpzJztcbmltcG9ydCBEcmFnZ2FibGUgZnJvbSAnLi4vRHJhZ2dhYmxlL0RyYWdnYWJsZS5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvRHJhZ0V2ZW50L0RyYWdFdmVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvRHJhZ2dhYmxlRXZlbnQvRHJhZ2dhYmxlRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1BsdWdpbnMvQW5ub3VuY2VtZW50L0Fubm91bmNlbWVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvUGx1Z2lucy9NaXJyb3IvTWlycm9yRXZlbnQvTWlycm9yRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1NlbnNvcnMvU2Vuc29yRXZlbnQvU2Vuc29yRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1NlbnNvcnMvVG91Y2hTZW5zb3IvVG91Y2hTZW5zb3IubWpzJztcbmltcG9ydCB7IERyb3BwYWJsZVN0YXJ0RXZlbnQsIERyb3BwYWJsZVN0b3BFdmVudCwgRHJvcHBhYmxlRHJvcHBlZEV2ZW50LCBEcm9wcGFibGVSZXR1cm5lZEV2ZW50IH0gZnJvbSAnLi9Ecm9wcGFibGVFdmVudC9Ecm9wcGFibGVFdmVudC5tanMnO1xuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IGRyb3BJbkRyb3B6b25lID0gU3ltYm9sKCdkcm9wSW5Ecm9wWm9uZScpO1xuY29uc3QgcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lID0gU3ltYm9sKCdyZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmUnKTtcbmNvbnN0IGNsb3Nlc3REcm9wem9uZSA9IFN5bWJvbCgnY2xvc2VzdERyb3B6b25lJyk7XG5jb25zdCBnZXREcm9wem9uZXMgPSBTeW1ib2woJ2dldERyb3B6b25lcycpO1xuXG5mdW5jdGlvbiBvbkRyb3BwYWJsZURyb3BwZWREZWZhdWx0QW5ub3VuY2VtZW50KHtcbiAgZHJhZ0V2ZW50LFxuICBkcm9wem9uZVxufSkge1xuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnO1xuICBjb25zdCBkcm9wem9uZVRleHQgPSBkcm9wem9uZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJvcHpvbmUuaWQgfHwgJ2Ryb3BwYWJsZSBlbGVtZW50JztcbiAgcmV0dXJuIGBEcm9wcGVkICR7c291cmNlVGV4dH0gaW50byAke2Ryb3B6b25lVGV4dH1gO1xufVxuXG5mdW5jdGlvbiBvbkRyb3BwYWJsZVJldHVybmVkRGVmYXVsdEFubm91bmNlbWVudCh7XG4gIGRyYWdFdmVudCxcbiAgZHJvcHpvbmVcbn0pIHtcbiAgY29uc3Qgc291cmNlVGV4dCA9IGRyYWdFdmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5zb3VyY2UuaWQgfHwgJ2RyYWdnYWJsZSBlbGVtZW50JztcbiAgY29uc3QgZHJvcHpvbmVUZXh0ID0gZHJvcHpvbmUudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyb3B6b25lLmlkIHx8ICdkcm9wcGFibGUgZWxlbWVudCc7XG4gIHJldHVybiBgUmV0dXJuZWQgJHtzb3VyY2VUZXh0fSBmcm9tICR7ZHJvcHpvbmVUZXh0fWA7XG59XG5cbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xuICAnZHJvcHBhYmxlOmRyb3BwZWQnOiBvbkRyb3BwYWJsZURyb3BwZWREZWZhdWx0QW5ub3VuY2VtZW50LFxuICAnZHJvcHBhYmxlOnJldHVybmVkJzogb25Ecm9wcGFibGVSZXR1cm5lZERlZmF1bHRBbm5vdW5jZW1lbnRcbn07XG5jb25zdCBkZWZhdWx0Q2xhc3NlcyA9IHtcbiAgJ2Ryb3BwYWJsZTphY3RpdmUnOiAnZHJhZ2dhYmxlLWRyb3B6b25lLS1hY3RpdmUnLFxuICAnZHJvcHBhYmxlOm9jY3VwaWVkJzogJ2RyYWdnYWJsZS1kcm9wem9uZS0tb2NjdXBpZWQnXG59O1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGRyb3B6b25lOiAnLmRyYWdnYWJsZS1kcm9wcGFibGUnXG59O1xuXG5jbGFzcyBEcm9wcGFibGUgZXh0ZW5kcyBEcmFnZ2FibGUge1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoY29udGFpbmVycywge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAuLi5kZWZhdWx0Q2xhc3NlcyxcbiAgICAgICAgLi4uKG9wdGlvbnMuY2xhc3NlcyB8fCB7fSlcbiAgICAgIH0sXG4gICAgICBhbm5vdW5jZW1lbnRzOiB7XG4gICAgICAgIC4uLmRlZmF1bHRBbm5vdW5jZW1lbnRzLFxuICAgICAgICAuLi4ob3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9KVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5kcm9wem9uZXMgPSBudWxsO1xuXG4gICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBudWxsO1xuXG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUgPSBudWxsO1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZHJvcHpvbmVzID0gWy4uLnRoaXNbZ2V0RHJvcHpvbmVzXSgpXTtcbiAgICBjb25zdCBkcm9wem9uZSA9IGNsb3Nlc3QoZXZlbnQuc2Vuc29yRXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJvcHpvbmUpO1xuICAgIGlmICghZHJvcHpvbmUpIHtcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkcm9wcGFibGVTdGFydEV2ZW50ID0gbmV3IERyb3BwYWJsZVN0YXJ0RXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIGRyb3B6b25lXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVN0YXJ0RXZlbnQpO1xuICAgIGlmIChkcm9wcGFibGVTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxEcm9wem9uZSA9IGRyb3B6b25lO1xuICAgIGZvciAoY29uc3QgZHJvcHpvbmVFbGVtZW50IG9mIHRoaXMuZHJvcHpvbmVzKSB7XG4gICAgICBpZiAoZHJvcHpvbmVFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmdldENsYXNzTmFtZUZvcignZHJvcHBhYmxlOm9jY3VwaWVkJykpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZHJvcHpvbmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4udGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6YWN0aXZlJykpO1xuICAgIH1cbiAgfVxuXG4gIFtvbkRyYWdNb3ZlXShldmVudCkge1xuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRyb3B6b25lID0gdGhpc1tjbG9zZXN0RHJvcHpvbmVdKGV2ZW50LnNlbnNvckV2ZW50LnRhcmdldCk7XG4gICAgY29uc3Qgb3ZlckVtcHR5RHJvcHpvbmUgPSBkcm9wem9uZSAmJiAhZHJvcHpvbmUuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSk7XG4gICAgaWYgKG92ZXJFbXB0eURyb3B6b25lICYmIHRoaXNbZHJvcEluRHJvcHpvbmVdKGV2ZW50LCBkcm9wem9uZSkpIHtcbiAgICAgIHRoaXMubGFzdERyb3B6b25lID0gZHJvcHpvbmU7XG4gICAgfSBlbHNlIGlmICgoIWRyb3B6b25lIHx8IGRyb3B6b25lID09PSB0aGlzLmluaXRpYWxEcm9wem9uZSkgJiYgdGhpcy5sYXN0RHJvcHpvbmUpIHtcbiAgICAgIHRoaXNbcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lXShldmVudCk7XG4gICAgICB0aGlzLmxhc3REcm9wem9uZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XG4gICAgY29uc3QgZHJvcHBhYmxlU3RvcEV2ZW50ID0gbmV3IERyb3BwYWJsZVN0b3BFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgZHJvcHpvbmU6IHRoaXMubGFzdERyb3B6b25lIHx8IHRoaXMuaW5pdGlhbERyb3B6b25lXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVN0b3BFdmVudCk7XG4gICAgY29uc3Qgb2NjdXBpZWRDbGFzc2VzID0gdGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKTtcbiAgICBmb3IgKGNvbnN0IGRyb3B6b25lIG9mIHRoaXMuZHJvcHpvbmVzKSB7XG4gICAgICBkcm9wem9uZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJvcHBhYmxlOmFjdGl2ZScpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFzdERyb3B6b25lICYmIHRoaXMubGFzdERyb3B6b25lICE9PSB0aGlzLmluaXRpYWxEcm9wem9uZSkge1xuICAgICAgdGhpcy5pbml0aWFsRHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSguLi5vY2N1cGllZENsYXNzZXMpO1xuICAgIH1cbiAgICB0aGlzLmRyb3B6b25lcyA9IG51bGw7XG4gICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBudWxsO1xuICAgIHRoaXMuaW5pdGlhbERyb3B6b25lID0gbnVsbDtcbiAgfVxuXG4gIFtkcm9wSW5Ecm9wem9uZV0oZXZlbnQsIGRyb3B6b25lKSB7XG4gICAgY29uc3QgZHJvcHBhYmxlRHJvcHBlZEV2ZW50ID0gbmV3IERyb3BwYWJsZURyb3BwZWRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgZHJvcHpvbmVcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlRHJvcHBlZEV2ZW50KTtcbiAgICBpZiAoZHJvcHBhYmxlRHJvcHBlZEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb2NjdXBpZWRDbGFzc2VzID0gdGhpcy5nZXRDbGFzc05hbWVzRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKTtcbiAgICBpZiAodGhpcy5sYXN0RHJvcHpvbmUpIHtcbiAgICAgIHRoaXMubGFzdERyb3B6b25lLmNsYXNzTGlzdC5yZW1vdmUoLi4ub2NjdXBpZWRDbGFzc2VzKTtcbiAgICB9XG4gICAgZHJvcHpvbmUuYXBwZW5kQ2hpbGQoZXZlbnQuc291cmNlKTtcbiAgICBkcm9wem9uZS5jbGFzc0xpc3QuYWRkKC4uLm9jY3VwaWVkQ2xhc3Nlcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBbcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lXShldmVudCkge1xuICAgIGNvbnN0IGRyb3BwYWJsZVJldHVybmVkRXZlbnQgPSBuZXcgRHJvcHBhYmxlUmV0dXJuZWRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgZHJvcHpvbmU6IHRoaXMubGFzdERyb3B6b25lXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVJldHVybmVkRXZlbnQpO1xuICAgIGlmIChkcm9wcGFibGVSZXR1cm5lZEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUuYXBwZW5kQ2hpbGQoZXZlbnQuc291cmNlKTtcbiAgICB0aGlzLmxhc3REcm9wem9uZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuZ2V0Q2xhc3NOYW1lc0ZvcignZHJvcHBhYmxlOm9jY3VwaWVkJykpO1xuICB9XG5cbiAgW2Nsb3Nlc3REcm9wem9uZV0odGFyZ2V0KSB7XG4gICAgaWYgKCF0aGlzLmRyb3B6b25lcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjbG9zZXN0KHRhcmdldCwgdGhpcy5kcm9wem9uZXMpO1xuICB9XG5cbiAgW2dldERyb3B6b25lc10oKSB7XG4gICAgY29uc3QgZHJvcHpvbmUgPSB0aGlzLm9wdGlvbnMuZHJvcHpvbmU7XG4gICAgaWYgKHR5cGVvZiBkcm9wem9uZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGRyb3B6b25lKTtcbiAgICB9IGVsc2UgaWYgKGRyb3B6b25lIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgZHJvcHpvbmUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcmV0dXJuIGRyb3B6b25lO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRyb3B6b25lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZHJvcHpvbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBEcm9wcGFibGUgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IEFic3RyYWN0RXZlbnQgfSBmcm9tICcuLi8uLi9zaGFyZWQvQWJzdHJhY3RFdmVudC9BYnN0cmFjdEV2ZW50Lm1qcyc7XG5cbmNsYXNzIFN3YXBwYWJsZUV2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5cblN3YXBwYWJsZUV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlJztcbmNsYXNzIFN3YXBwYWJsZVN0YXJ0RXZlbnQgZXh0ZW5kcyBTd2FwcGFibGVFdmVudCB7fVxuU3dhcHBhYmxlU3RhcnRFdmVudC50eXBlID0gJ3N3YXBwYWJsZTpzdGFydCc7XG5Td2FwcGFibGVTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuXG5jbGFzcyBTd2FwcGFibGVTd2FwRXZlbnQgZXh0ZW5kcyBTd2FwcGFibGVFdmVudCB7XG5cbiAgZ2V0IG92ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xuICB9XG5cbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xuICB9XG59XG5Td2FwcGFibGVTd2FwRXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3dhcCc7XG5Td2FwcGFibGVTd2FwRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5cbmNsYXNzIFN3YXBwYWJsZVN3YXBwZWRFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHtcblxuICBnZXQgc3dhcHBlZEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zd2FwcGVkRWxlbWVudDtcbiAgfVxufVxuXG5Td2FwcGFibGVTd2FwcGVkRXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3dhcHBlZCc7XG5jbGFzcyBTd2FwcGFibGVTdG9wRXZlbnQgZXh0ZW5kcyBTd2FwcGFibGVFdmVudCB7fVxuU3dhcHBhYmxlU3RvcEV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlOnN0b3AnO1xuXG5leHBvcnQgeyBTd2FwcGFibGVFdmVudCwgU3dhcHBhYmxlU3RhcnRFdmVudCwgU3dhcHBhYmxlU3RvcEV2ZW50LCBTd2FwcGFibGVTd2FwRXZlbnQsIFN3YXBwYWJsZVN3YXBwZWRFdmVudCB9O1xuIiwgImltcG9ydCBEcmFnZ2FibGUgZnJvbSAnLi4vRHJhZ2dhYmxlL0RyYWdnYWJsZS5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvRHJhZ0V2ZW50L0RyYWdFdmVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvRHJhZ2dhYmxlRXZlbnQvRHJhZ2dhYmxlRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1BsdWdpbnMvQW5ub3VuY2VtZW50L0Fubm91bmNlbWVudC5tanMnO1xuaW1wb3J0ICcuLi9EcmFnZ2FibGUvUGx1Z2lucy9NaXJyb3IvTWlycm9yRXZlbnQvTWlycm9yRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1NlbnNvcnMvU2Vuc29yRXZlbnQvU2Vuc29yRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1NlbnNvcnMvVG91Y2hTZW5zb3IvVG91Y2hTZW5zb3IubWpzJztcbmltcG9ydCB7IFN3YXBwYWJsZVN0YXJ0RXZlbnQsIFN3YXBwYWJsZVN3YXBFdmVudCwgU3dhcHBhYmxlU3dhcHBlZEV2ZW50LCBTd2FwcGFibGVTdG9wRXZlbnQgfSBmcm9tICcuL1N3YXBwYWJsZUV2ZW50L1N3YXBwYWJsZUV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuXG5mdW5jdGlvbiBvblN3YXBwYWJsZVN3YXBwZWREZWZhdWx0QW5ub3VuY2VtZW50KHtcbiAgZHJhZ0V2ZW50LFxuICBzd2FwcGVkRWxlbWVudFxufSkge1xuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnc3dhcHBhYmxlIGVsZW1lbnQnO1xuICBjb25zdCBvdmVyVGV4dCA9IHN3YXBwZWRFbGVtZW50LnRleHRDb250ZW50LnRyaW0oKSB8fCBzd2FwcGVkRWxlbWVudC5pZCB8fCAnc3dhcHBhYmxlIGVsZW1lbnQnO1xuICByZXR1cm4gYFN3YXBwZWQgJHtzb3VyY2VUZXh0fSB3aXRoICR7b3ZlclRleHR9YDtcbn1cblxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XG4gICdzd2FwcGFibGVkOnN3YXBwZWQnOiBvblN3YXBwYWJsZVN3YXBwZWREZWZhdWx0QW5ub3VuY2VtZW50XG59O1xuXG5jbGFzcyBTd2FwcGFibGUgZXh0ZW5kcyBEcmFnZ2FibGUge1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoY29udGFpbmVycywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGFubm91bmNlbWVudHM6IHtcbiAgICAgICAgLi4uZGVmYXVsdEFubm91bmNlbWVudHMsXG4gICAgICAgIC4uLihvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmxhc3RPdmVyID0gbnVsbDtcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpLm9mZignZHJhZzpvdmVyJywgdGhpcy5fb25EcmFnT3Zlcikub2ZmKCdkcmFnOnN0b3AnLCB0aGlzLl9vbkRyYWdTdG9wKTtcbiAgfVxuXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcbiAgICBjb25zdCBzd2FwcGFibGVTdGFydEV2ZW50ID0gbmV3IFN3YXBwYWJsZVN0YXJ0RXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudFxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTdGFydEV2ZW50KTtcbiAgICBpZiAoc3dhcHBhYmxlU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICBldmVudC5jYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQub3ZlciA9PT0gZXZlbnQub3JpZ2luYWxTb3VyY2UgfHwgZXZlbnQub3ZlciA9PT0gZXZlbnQuc291cmNlIHx8IGV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3dhcHBhYmxlU3dhcEV2ZW50ID0gbmV3IFN3YXBwYWJsZVN3YXBFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgb3ZlcjogZXZlbnQub3ZlcixcbiAgICAgIG92ZXJDb250YWluZXI6IGV2ZW50Lm92ZXJDb250YWluZXJcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoc3dhcHBhYmxlU3dhcEV2ZW50KTtcbiAgICBpZiAoc3dhcHBhYmxlU3dhcEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sYXN0T3ZlciAmJiB0aGlzLmxhc3RPdmVyICE9PSBldmVudC5vdmVyKSB7XG4gICAgICBzd2FwKHRoaXMubGFzdE92ZXIsIGV2ZW50LnNvdXJjZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhc3RPdmVyID09PSBldmVudC5vdmVyKSB7XG4gICAgICB0aGlzLmxhc3RPdmVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXN0T3ZlciA9IGV2ZW50Lm92ZXI7XG4gICAgfVxuICAgIHN3YXAoZXZlbnQuc291cmNlLCBldmVudC5vdmVyKTtcbiAgICBjb25zdCBzd2FwcGFibGVTd2FwcGVkRXZlbnQgPSBuZXcgU3dhcHBhYmxlU3dhcHBlZEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBzd2FwcGVkRWxlbWVudDogZXZlbnQub3ZlclxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTd2FwcGVkRXZlbnQpO1xuICB9XG5cbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XG4gICAgY29uc3Qgc3dhcHBhYmxlU3RvcEV2ZW50ID0gbmV3IFN3YXBwYWJsZVN0b3BFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHN3YXBwYWJsZVN0b3BFdmVudCk7XG4gICAgdGhpcy5sYXN0T3ZlciA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhUZW1wRWxlbWVudChjYWxsYmFjaykge1xuICBjb25zdCB0bXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNhbGxiYWNrKHRtcEVsZW1lbnQpO1xuICB0bXBFbGVtZW50LnJlbW92ZSgpO1xufVxuZnVuY3Rpb24gc3dhcChzb3VyY2UsIG92ZXIpIHtcbiAgY29uc3Qgb3ZlclBhcmVudCA9IG92ZXIucGFyZW50Tm9kZTtcbiAgY29uc3Qgc291cmNlUGFyZW50ID0gc291cmNlLnBhcmVudE5vZGU7XG4gIHdpdGhUZW1wRWxlbWVudCh0bXBFbGVtZW50ID0+IHtcbiAgICBzb3VyY2VQYXJlbnQuaW5zZXJ0QmVmb3JlKHRtcEVsZW1lbnQsIHNvdXJjZSk7XG4gICAgb3ZlclBhcmVudC5pbnNlcnRCZWZvcmUoc291cmNlLCBvdmVyKTtcbiAgICBzb3VyY2VQYXJlbnQuaW5zZXJ0QmVmb3JlKG92ZXIsIHRtcEVsZW1lbnQpO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgU3dhcHBhYmxlIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBBYnN0cmFjdEV2ZW50IH0gZnJvbSAnLi4vLi4vc2hhcmVkL0Fic3RyYWN0RXZlbnQvQWJzdHJhY3RFdmVudC5tanMnO1xuXG5jbGFzcyBTb3J0YWJsZUV2ZW50IGV4dGVuZHMgQWJzdHJhY3RFdmVudCB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5Tb3J0YWJsZUV2ZW50LnR5cGUgPSAnc29ydGFibGUnO1xuXG5jbGFzcyBTb3J0YWJsZVN0YXJ0RXZlbnQgZXh0ZW5kcyBTb3J0YWJsZUV2ZW50IHtcblxuICBnZXQgc3RhcnRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0SW5kZXg7XG4gIH1cblxuICBnZXQgc3RhcnRDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zdGFydENvbnRhaW5lcjtcbiAgfVxufVxuU29ydGFibGVTdGFydEV2ZW50LnR5cGUgPSAnc29ydGFibGU6c3RhcnQnO1xuU29ydGFibGVTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuXG5jbGFzcyBTb3J0YWJsZVNvcnRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xuXG4gIGdldCBjdXJyZW50SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jdXJyZW50SW5kZXg7XG4gIH1cblxuICBnZXQgb3ZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXI7XG4gIH1cblxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudC5vdmVyQ29udGFpbmVyO1xuICB9XG59XG5Tb3J0YWJsZVNvcnRFdmVudC50eXBlID0gJ3NvcnRhYmxlOnNvcnQnO1xuU29ydGFibGVTb3J0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5cbmNsYXNzIFNvcnRhYmxlU29ydGVkRXZlbnQgZXh0ZW5kcyBTb3J0YWJsZUV2ZW50IHtcblxuICBnZXQgb2xkSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vbGRJbmRleDtcbiAgfVxuXG4gIGdldCBuZXdJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0luZGV4O1xuICB9XG5cbiAgZ2V0IG9sZENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZENvbnRhaW5lcjtcbiAgfVxuXG4gIGdldCBuZXdDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5uZXdDb250YWluZXI7XG4gIH1cbn1cblNvcnRhYmxlU29ydGVkRXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzb3J0ZWQnO1xuXG5jbGFzcyBTb3J0YWJsZVN0b3BFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xuXG4gIGdldCBvbGRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZEluZGV4O1xuICB9XG5cbiAgZ2V0IG5ld0luZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubmV3SW5kZXg7XG4gIH1cblxuICBnZXQgb2xkQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub2xkQ29udGFpbmVyO1xuICB9XG5cbiAgZ2V0IG5ld0NvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0NvbnRhaW5lcjtcbiAgfVxufVxuU29ydGFibGVTdG9wRXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzdG9wJztcblxuZXhwb3J0IHsgU29ydGFibGVFdmVudCwgU29ydGFibGVTb3J0RXZlbnQsIFNvcnRhYmxlU29ydGVkRXZlbnQsIFNvcnRhYmxlU3RhcnRFdmVudCwgU29ydGFibGVTdG9wRXZlbnQgfTtcbiIsICJpbXBvcnQgRHJhZ2dhYmxlIGZyb20gJy4uL0RyYWdnYWJsZS9EcmFnZ2FibGUubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL0RyYWdFdmVudC9EcmFnRXZlbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL0RyYWdnYWJsZUV2ZW50L0RyYWdnYWJsZUV2ZW50Lm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9QbHVnaW5zL0Fubm91bmNlbWVudC9Bbm5vdW5jZW1lbnQubWpzJztcbmltcG9ydCAnLi4vRHJhZ2dhYmxlL1BsdWdpbnMvTWlycm9yL01pcnJvckV2ZW50L01pcnJvckV2ZW50Lm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9TZW5zb3JzL1NlbnNvckV2ZW50L1NlbnNvckV2ZW50Lm1qcyc7XG5pbXBvcnQgJy4uL0RyYWdnYWJsZS9TZW5zb3JzL1RvdWNoU2Vuc29yL1RvdWNoU2Vuc29yLm1qcyc7XG5pbXBvcnQgeyBTb3J0YWJsZVN0YXJ0RXZlbnQsIFNvcnRhYmxlU29ydEV2ZW50LCBTb3J0YWJsZVNvcnRlZEV2ZW50LCBTb3J0YWJsZVN0b3BFdmVudCB9IGZyb20gJy4vU29ydGFibGVFdmVudC9Tb3J0YWJsZUV2ZW50Lm1qcyc7XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xuY29uc3Qgb25EcmFnT3ZlckNvbnRhaW5lciA9IFN5bWJvbCgnb25EcmFnT3ZlckNvbnRhaW5lcicpO1xuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xuXG5mdW5jdGlvbiBvblNvcnRhYmxlU29ydGVkRGVmYXVsdEFubm91bmNlbWVudCh7XG4gIGRyYWdFdmVudFxufSkge1xuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnc29ydGFibGUgZWxlbWVudCc7XG4gIGlmIChkcmFnRXZlbnQub3Zlcikge1xuICAgIGNvbnN0IG92ZXJUZXh0ID0gZHJhZ0V2ZW50Lm92ZXIudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5vdmVyLmlkIHx8ICdzb3J0YWJsZSBlbGVtZW50JztcbiAgICBjb25zdCBpc0ZvbGxvd2luZyA9IGRyYWdFdmVudC5zb3VyY2UuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZHJhZ0V2ZW50Lm92ZXIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gICAgaWYgKGlzRm9sbG93aW5nKSB7XG4gICAgICByZXR1cm4gYFBsYWNlZCAke3NvdXJjZVRleHR9IGFmdGVyICR7b3ZlclRleHR9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBQbGFjZWQgJHtzb3VyY2VUZXh0fSBiZWZvcmUgJHtvdmVyVGV4dH1gO1xuICAgIH1cbiAgfSBlbHNlIHtcblxuICAgIHJldHVybiBgUGxhY2VkICR7c291cmNlVGV4dH0gaW50byBhIGRpZmZlcmVudCBjb250YWluZXJgO1xuICB9XG59XG5cbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xuICAnc29ydGFibGU6c29ydGVkJzogb25Tb3J0YWJsZVNvcnRlZERlZmF1bHRBbm5vdW5jZW1lbnRcbn07XG5cbmNsYXNzIFNvcnRhYmxlIGV4dGVuZHMgRHJhZ2dhYmxlIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGNvbnRhaW5lcnMsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhbm5vdW5jZW1lbnRzOiB7XG4gICAgICAgIC4uLmRlZmF1bHRBbm5vdW5jZW1lbnRzLFxuICAgICAgICAuLi4ob3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9KVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5zdGFydEluZGV4ID0gbnVsbDtcblxuICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBudWxsO1xuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ092ZXJDb250YWluZXJdID0gdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXNbb25EcmFnT3ZlckNvbnRhaW5lcl0pLm9mZignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIGluZGV4KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0YWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGVsZW1lbnQucGFyZW50Tm9kZSkuaW5kZXhPZihlbGVtZW50KTtcbiAgfVxuXG4gIGdldFNvcnRhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgY29uc3QgYWxsU29ydGFibGVFbGVtZW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIHJldHVybiBbLi4uYWxsU29ydGFibGVFbGVtZW50c10uZmlsdGVyKGNoaWxkRWxlbWVudCA9PiB7XG4gICAgICByZXR1cm4gY2hpbGRFbGVtZW50ICE9PSB0aGlzLm9yaWdpbmFsU291cmNlICYmIGNoaWxkRWxlbWVudCAhPT0gdGhpcy5taXJyb3IgJiYgY2hpbGRFbGVtZW50LnBhcmVudE5vZGUgPT09IGNvbnRhaW5lcjtcbiAgICB9KTtcbiAgfVxuXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcbiAgICB0aGlzLnN0YXJ0Q29udGFpbmVyID0gZXZlbnQuc291cmNlLnBhcmVudE5vZGU7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gdGhpcy5pbmRleChldmVudC5zb3VyY2UpO1xuICAgIGNvbnN0IHNvcnRhYmxlU3RhcnRFdmVudCA9IG5ldyBTb3J0YWJsZVN0YXJ0RXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIHN0YXJ0SW5kZXg6IHRoaXMuc3RhcnRJbmRleCxcbiAgICAgIHN0YXJ0Q29udGFpbmVyOiB0aGlzLnN0YXJ0Q29udGFpbmVyXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU3RhcnRFdmVudCk7XG4gICAgaWYgKHNvcnRhYmxlU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICBldmVudC5jYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICBbb25EcmFnT3ZlckNvbnRhaW5lcl0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2UsXG4gICAgICBvdmVyLFxuICAgICAgb3ZlckNvbnRhaW5lclxuICAgIH0gPSBldmVudDtcbiAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuaW5kZXgoc291cmNlKTtcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRFdmVudCA9IG5ldyBTb3J0YWJsZVNvcnRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgY3VycmVudEluZGV4OiBvbGRJbmRleCxcbiAgICAgIHNvdXJjZSxcbiAgICAgIG92ZXJcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0RXZlbnQpO1xuICAgIGlmIChzb3J0YWJsZVNvcnRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRTb3J0YWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpO1xuICAgIGNvbnN0IG1vdmVzID0gbW92ZSh7XG4gICAgICBzb3VyY2UsXG4gICAgICBvdmVyLFxuICAgICAgb3ZlckNvbnRhaW5lcixcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gICAgaWYgKCFtb3Zlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvbGRDb250YWluZXIsXG4gICAgICBuZXdDb250YWluZXJcbiAgICB9ID0gbW92ZXM7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLmluZGV4KGV2ZW50LnNvdXJjZSk7XG4gICAgY29uc3Qgc29ydGFibGVTb3J0ZWRFdmVudCA9IG5ldyBTb3J0YWJsZVNvcnRlZEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBvbGRJbmRleCxcbiAgICAgIG5ld0luZGV4LFxuICAgICAgb2xkQ29udGFpbmVyLFxuICAgICAgbmV3Q29udGFpbmVyXG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU29ydGVkRXZlbnQpO1xuICB9XG5cbiAgW29uRHJhZ092ZXJdKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50Lm92ZXIgPT09IGV2ZW50Lm9yaWdpbmFsU291cmNlIHx8IGV2ZW50Lm92ZXIgPT09IGV2ZW50LnNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2UsXG4gICAgICBvdmVyLFxuICAgICAgb3ZlckNvbnRhaW5lclxuICAgIH0gPSBldmVudDtcbiAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuaW5kZXgoc291cmNlKTtcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRFdmVudCA9IG5ldyBTb3J0YWJsZVNvcnRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgY3VycmVudEluZGV4OiBvbGRJbmRleCxcbiAgICAgIHNvdXJjZSxcbiAgICAgIG92ZXJcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0RXZlbnQpO1xuICAgIGlmIChzb3J0YWJsZVNvcnRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihvdmVyQ29udGFpbmVyKTtcbiAgICBjb25zdCBtb3ZlcyA9IG1vdmUoe1xuICAgICAgc291cmNlLFxuICAgICAgb3ZlcixcbiAgICAgIG92ZXJDb250YWluZXIsXG4gICAgICBjaGlsZHJlblxuICAgIH0pO1xuICAgIGlmICghbW92ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgb2xkQ29udGFpbmVyLFxuICAgICAgbmV3Q29udGFpbmVyXG4gICAgfSA9IG1vdmVzO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5pbmRleChzb3VyY2UpO1xuICAgIGNvbnN0IHNvcnRhYmxlU29ydGVkRXZlbnQgPSBuZXcgU29ydGFibGVTb3J0ZWRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgb2xkSW5kZXgsXG4gICAgICBuZXdJbmRleCxcbiAgICAgIG9sZENvbnRhaW5lcixcbiAgICAgIG5ld0NvbnRhaW5lclxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRlZEV2ZW50KTtcbiAgfVxuXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xuICAgIGNvbnN0IHNvcnRhYmxlU3RvcEV2ZW50ID0gbmV3IFNvcnRhYmxlU3RvcEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBvbGRJbmRleDogdGhpcy5zdGFydEluZGV4LFxuICAgICAgbmV3SW5kZXg6IHRoaXMuaW5kZXgoZXZlbnQuc291cmNlKSxcbiAgICAgIG9sZENvbnRhaW5lcjogdGhpcy5zdGFydENvbnRhaW5lcixcbiAgICAgIG5ld0NvbnRhaW5lcjogZXZlbnQuc291cmNlLnBhcmVudE5vZGVcbiAgICB9KTtcbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTdG9wRXZlbnQpO1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IG51bGw7XG4gICAgdGhpcy5zdGFydENvbnRhaW5lciA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZWxlbWVudC5wYXJlbnROb2RlLmNoaWxkcmVuLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIG1vdmUoe1xuICBzb3VyY2UsXG4gIG92ZXIsXG4gIG92ZXJDb250YWluZXIsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGNvbnN0IGVtcHR5T3ZlckNvbnRhaW5lciA9ICFjaGlsZHJlbi5sZW5ndGg7XG4gIGNvbnN0IGRpZmZlcmVudENvbnRhaW5lciA9IHNvdXJjZS5wYXJlbnROb2RlICE9PSBvdmVyQ29udGFpbmVyO1xuICBjb25zdCBzYW1lQ29udGFpbmVyID0gb3ZlciAmJiBzb3VyY2UucGFyZW50Tm9kZSA9PT0gb3Zlci5wYXJlbnROb2RlO1xuICBpZiAoZW1wdHlPdmVyQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG1vdmVJbnNpZGVFbXB0eUNvbnRhaW5lcihzb3VyY2UsIG92ZXJDb250YWluZXIpO1xuICB9IGVsc2UgaWYgKHNhbWVDb250YWluZXIpIHtcbiAgICByZXR1cm4gbW92ZVdpdGhpbkNvbnRhaW5lcihzb3VyY2UsIG92ZXIpO1xuICB9IGVsc2UgaWYgKGRpZmZlcmVudENvbnRhaW5lcikge1xuICAgIHJldHVybiBtb3ZlT3V0c2lkZUNvbnRhaW5lcihzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBtb3ZlSW5zaWRlRW1wdHlDb250YWluZXIoc291cmNlLCBvdmVyQ29udGFpbmVyKSB7XG4gIGNvbnN0IG9sZENvbnRhaW5lciA9IHNvdXJjZS5wYXJlbnROb2RlO1xuICBvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHNvdXJjZSk7XG4gIHJldHVybiB7XG4gICAgb2xkQ29udGFpbmVyLFxuICAgIG5ld0NvbnRhaW5lcjogb3ZlckNvbnRhaW5lclxuICB9O1xufVxuZnVuY3Rpb24gbW92ZVdpdGhpbkNvbnRhaW5lcihzb3VyY2UsIG92ZXIpIHtcbiAgY29uc3Qgb2xkSW5kZXggPSBpbmRleChzb3VyY2UpO1xuICBjb25zdCBuZXdJbmRleCA9IGluZGV4KG92ZXIpO1xuICBpZiAob2xkSW5kZXggPCBuZXdJbmRleCkge1xuICAgIHNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBzb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc291cmNlLCBvdmVyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9sZENvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGUsXG4gICAgbmV3Q29udGFpbmVyOiBzb3VyY2UucGFyZW50Tm9kZVxuICB9O1xufVxuZnVuY3Rpb24gbW92ZU91dHNpZGVDb250YWluZXIoc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyKSB7XG4gIGNvbnN0IG9sZENvbnRhaW5lciA9IHNvdXJjZS5wYXJlbnROb2RlO1xuICBpZiAob3Zlcikge1xuICAgIG92ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc291cmNlLCBvdmVyKTtcbiAgfSBlbHNlIHtcblxuICAgIG92ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoc291cmNlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9sZENvbnRhaW5lcixcbiAgICBuZXdDb250YWluZXI6IHNvdXJjZS5wYXJlbnROb2RlXG4gIH07XG59XG5cbmV4cG9ydCB7IFNvcnRhYmxlIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgQ2hhcnQgZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NoYXJ0LmpzXCI7XHJcbmltcG9ydCBDaGFydERhdGFMYWJlbHMgZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2Rpc3QvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5qc1wiO1xyXG5pbXBvcnQgXCIuLi9ub2RlX21vZHVsZXMvY2hhcnQuanMtcGx1Z2luLWxhYmVscy1kdi9kaXN0L2NoYXJ0anMtcGx1Z2luLWxhYmVscy5taW4uanNcIjtcclxuXHJcbmNvbnN0IGNvbG9ycyA9IFtcIiMzNmEyZWJcIl07XHJcbmNvbnN0IG1vbnRoID0gW1xyXG4gIFwiSmFudmllclwiLFxyXG4gIFwiRlx1MDBFOXZyaWVyXCIsXHJcbiAgXCJNYXJzXCIsXHJcbiAgXCJBdnJpbFwiLFxyXG4gIFwiTWFpXCIsXHJcbiAgXCJKdWluXCIsXHJcbiAgXCJKdWlsbGV0XCIsXHJcbiAgXCJBb1x1MDBGQnRcIixcclxuICBcIlNlcHRlbWJyZVwiLFxyXG4gIFwiT2N0b2JyZVwiLFxyXG4gIFwiTm92ZW1icmVcIixcclxuICBcIkRcdTAwRTljZW1icmVcIixcclxuXTtcclxuXHJcbmNvbnN0IFNVUlZFWSA9IFtcclxuICBcIlF1YWxpdFx1MDBFOSBkdSB0cmF2YWlsIGVmZmVjdHVcdTAwRTlcIixcclxuICBcIkdhaW4gZGUgdGVtcHMgZHUgY2xpZW50XCIsXHJcbiAgXCJSZXNwZWN0IGR1IGRcdTAwRTlsYWkgZGUgbGl2cmFpc29uXCIsXHJcbiAgXCJRdWFsaXRcdTAwRTkgZGUgbGEgY29tbXVuaWNhdGlvblwiLFxyXG5dO1xyXG5cclxuY2xhc3MgRG91Z2hOdXRDaGFydCB7XHJcbiAgY29uc3RydWN0b3IoY3R4LCBsYWJlbHMsIHZhbHVlcykge1xyXG4gICAgdGhpcy5jaGFydCA9IG5ldyBDaGFydChjdHgsIHtcclxuICAgICAgdHlwZTogXCJkb3VnaG51dFwiLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgbGFiZWxzOiBsYWJlbHMsXHJcbiAgICAgICAgZGF0YXNldHM6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbGFiZWw6IFwiTGlzdGUgZGVzIHRcdTAwRTJjaGVzXCIsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JzLFxyXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZXMsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0sXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgICAgIHBsdWdpbnM6IHtcclxuICAgICAgICAgIGxlZ2VuZDoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB0aXRsZToge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiBcIkxpc3RlIGRlcyB0XHUwMEUyY2hlcyBwYXIgY29udHJpYnV0ZXVyc1wiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICBwbHVnaW5zOiBDaGFydERhdGFMYWJlbHMsXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEhvcml6b250YWxCYXJDaGFydCB7XHJcbiAgY29uc3RydWN0b3IoY3R4LCBsYWJlbHMsIHZhbHVlcykge1xyXG4gICAgdGhpcy5jaGFydCA9IG5ldyBDaGFydChjdHgsIHtcclxuICAgICAgdHlwZTogXCJiYXJcIixcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIGxhYmVsczogbGFiZWxzLFxyXG4gICAgICAgIGRhdGFzZXRzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGF4aXM6IFwieFwiLFxyXG4gICAgICAgICAgICBsYWJlbDogXCJMaXN0ZSBkZXMgdFx1MDBFMmNoZXNcIixcclxuICAgICAgICAgICAgZGF0YTogdmFsdWVzLFxyXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNvbG9ycyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMsXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxyXG4gICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0sXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBpbmRleEF4aXM6IFwieFwiLFxyXG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICAgICAgcGx1Z2luczoge1xyXG4gICAgICAgICAgbGFiZWxzOiB7XHJcbiAgICAgICAgICAgIHJlbmRlcjogXCJ2YWx1ZVwiLFxyXG4gICAgICAgICAgICBmb250Q29sb3I6IFwiIzVjNWM1Y1wiLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJvdXRzaWRlXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbGVnZW5kOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHQ6IFwiTGlzdGUgZGVzIHRcdTAwRTJjaGVzIHBhciBjb250cmlidXRldXJzXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZGF0YWxhYmVsczoge1xyXG4gICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFN0YWNrZWRCYXJDaGFydCB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBjdHgsXHJcbiAgICB0b2RvX3Rhc2tzLFxyXG4gICAgYmxvY2tlZF90YXNrcyxcclxuICAgIHRhc2tzX2luX3Byb2dyZXNzLFxyXG4gICAgdGFza3NfaW5fY29udHJvbCxcclxuICAgIGFjaGlldmVkX3Rhc2tzXHJcbiAgKSB7XHJcbiAgICB0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0KGN0eCwge1xyXG4gICAgICB0eXBlOiBcImJhclwiLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgbGFiZWxzOiBtb250aCxcclxuICAgICAgICBkYXRhc2V0czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBsYWJlbDogXCJUXHUwMEUyY2hlcyBcdTAwRTAgZmFpcmVcIixcclxuICAgICAgICAgICAgZGF0YTogdG9kb190YXNrcyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzNmEyZWJcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIGVuIGJsb2NhZ2VcIixcclxuICAgICAgICAgICAgZGF0YTogYmxvY2tlZF90YXNrcyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlNjdlMjJcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIGVuIGNvdXJzXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHRhc2tzX2luX3Byb2dyZXNzLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzI3YWU2MFwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgZW4gY29udHJcdTAwRjRsZVwiLFxyXG4gICAgICAgICAgICBkYXRhOiB0YXNrc19pbl9jb250cm9sLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzhlNDRhZFwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgYWNoZXZcdTAwRTllc1wiLFxyXG4gICAgICAgICAgICBkYXRhOiBhY2hpZXZlZF90YXNrcyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZjYzODRcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSxcclxuICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgIHBsdWdpbnM6IHtcclxuICAgICAgICAgIGxhYmVsczoge1xyXG4gICAgICAgICAgICByZW5kZXI6IFwidmFsdWVcIixcclxuICAgICAgICAgICAgZm9udENvbG9yOiBcIiM1YzVjNWNcIixcclxuICAgICAgICAgICAgcG9zaXRpb246IFwib3V0c2lkZVwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGxlZ2VuZDoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJib3R0b21cIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB0aXRsZToge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiBcIlRcdTAwRTJjaGVzIHBhciBtb2lzXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgTGluZUNoYXJ0IHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGN0eCxcclxuICAgIHRvZG9fdGFza3MsXHJcbiAgICBibG9ja2VkX3Rhc2tzLFxyXG4gICAgdGFza3NfaW5fcHJvZ3Jlc3MsXHJcbiAgICB0YXNrc19pbl9jb250cm9sLFxyXG4gICAgYWNoaWV2ZWRfdGFza3NcclxuICApIHtcclxuICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCB7XHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBsYWJlbHM6IG1vbnRoLFxyXG4gICAgICAgIGRhdGFzZXRzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiYmFyXCIsXHJcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIFx1MDBFMCBmYWlyZVwiLFxyXG4gICAgICAgICAgICBkYXRhOiB0b2RvX3Rhc2tzLFxyXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogXCJtb25vdG9uZVwiLFxyXG4gICAgICAgICAgICB0ZW5zaW9uOiAwLjQsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiNmZjYzODRcIixcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZjYzODRcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiYmFyXCIsXHJcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIGVuIGJsb2NrYWdlXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IGJsb2NrZWRfdGFza3MsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcIm1vbm90b25lXCIsXHJcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogXCJiYXJcIixcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgZW4gY291cnNcIixcclxuICAgICAgICAgICAgZGF0YTogdGFza3NfaW5fcHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcIm1vbm90b25lXCIsXHJcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogXCJiYXJcIixcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgZW4gY29udHJcdTAwRjRsZVwiLFxyXG4gICAgICAgICAgICBkYXRhOiB0YXNrc19pbl9jb250cm9sLFxyXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogXCJtb25vdG9uZVwiLFxyXG4gICAgICAgICAgICB0ZW5zaW9uOiAwLjQsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMzNmEyZWJcIixcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzNmEyZWJcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiYmFyXCIsXHJcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIGFjaGV2XHUwMEU5ZXNcIixcclxuICAgICAgICAgICAgZGF0YTogYWNoaWV2ZWRfdGFza3MsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcIm1vbm90b25lXCIsXHJcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9LFxyXG4gICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuICAgICAgICBwbHVnaW5zOiB7XHJcbiAgICAgICAgICBsZWdlbmQ6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dDogXCJUXHUwMEUyY2hlcyBwYXIgbW9pc1wiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBTdXJ2ZXlDaGFydCB7XHJcbiAgY29uc3RydWN0b3IoY3R4LCB2YWx1ZXMpIHtcclxuICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCB7XHJcbiAgICAgIHR5cGU6IFwiYmFyXCIsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBsYWJlbHM6IFNVUlZFWSxcclxuICAgICAgICBkYXRhc2V0czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBheGlzOiBcInhcIixcclxuICAgICAgICAgICAgbGFiZWw6IFwiUG91cmNlbnRhZ2UgZGUgc2F0aXNmYWN0aW9uIGVuICVcIixcclxuICAgICAgICAgICAgZGF0YTogdmFsdWVzLFxyXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNvbG9ycyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMsXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAyLFxyXG4gICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0sXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuICAgICAgICBpbmRleEF4aXM6IFwieVwiLFxyXG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICAgICAgcGx1Z2luczoge1xyXG4gICAgICAgICAgbGFiZWxzOiB7XHJcbiAgICAgICAgICAgIHJlbmRlcjogXCJ2YWx1ZVwiLFxyXG4gICAgICAgICAgICBmb250Q29sb3I6IFwiIzVjNWM1Y1wiLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJvdXRzaWRlXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbGVnZW5kOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHQ6IFwiVGF1eCBkZSBzYXRpc2ZhY3Rpb24gZHUgY2xpZW50XCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZGF0YWxhYmVsczoge1xyXG4gICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCB7XHJcbiAgRG91Z2hOdXRDaGFydCxcclxuICBIb3Jpem9udGFsQmFyQ2hhcnQsXHJcbiAgU3RhY2tlZEJhckNoYXJ0LFxyXG4gIExpbmVDaGFydCxcclxuICBTdXJ2ZXlDaGFydFxyXG59O1xyXG4iLCAiIWZ1bmN0aW9uKHQpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6dCgpfSgoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtcbi8qKlxuICAgKiBbY2hhcnRqcy1wbHVnaW4tbGFiZWxzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRlVmlvbGFudGUvY2hhcnRqcy1wbHVnaW4tbGFiZWxzfVxuICAgKlxuICAgKiBAdmVyc2lvbiAzLjEuMFxuICAgKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXSwgRGF2aWRlIFZpb2xhbnRlLCBZb3VzZWYgQWx0YWhlclxuICAgKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTctMjAxOFxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovIWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIENoYXJ0KXJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgZmluZCBDaGFydCBvYmplY3QuXCIpO2NvbnN0IHQ9Q2hhcnQuaGVscGVycztcImZ1bmN0aW9uXCIhPXR5cGVvZiBPYmplY3QuYXNzaWduJiYoT2JqZWN0LmFzc2lnbj1mdW5jdGlvbih0KXtpZighdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO2NvbnN0IGU9T2JqZWN0KHQpO2ZvcihsZXQgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe2NvbnN0IG89YXJndW1lbnRzW3RdO2lmKG8pZm9yKGNvbnN0IHQgaW4gbylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyx0KSYmKGVbdF09b1t0XSl9cmV0dXJuIGV9KTtjb25zdCBlPXt9O2Z1bmN0aW9uIG8oKXt0aGlzLnJlbmRlclRvRGF0YXNldD10aGlzLnJlbmRlclRvRGF0YXNldC5iaW5kKHRoaXMpfWZ1bmN0aW9uIG4odCl7Y29uc3QgZT10Ll9jb250ZXh0LmNoYXJ0LmNvbmZpZy5fY29uZmlnO3JldHVybiEoIWUub3B0aW9uc3x8IWUub3B0aW9ucy5wbHVnaW5zKSYmISFlLm9wdGlvbnMucGx1Z2lucy5sYWJlbHN9W1wicGllXCIsXCJkb3VnaG51dFwiLFwicG9sYXJBcmVhXCIsXCJiYXJcIl0uZm9yRWFjaCgoZnVuY3Rpb24odCl7ZVt0XT0hMH0pKSxvLnByb3RvdHlwZS5zZXR1cD1mdW5jdGlvbih0LGUpe3RoaXMuY2hhcnQ9dCx0aGlzLmN0eD10LmN0eCx0aGlzLmFyZ3M9e30sdGhpcy5iYXJUb3RhbD17fTtjb25zdCBvPXQuY29uZmlnLm9wdGlvbnM7dGhpcy5vcHRpb25zPU9iamVjdC5hc3NpZ24oe3Bvc2l0aW9uOlwiZGVmYXVsdFwiLHByZWNpc2lvbjowLGZvbnRTaXplOm8uZm9udD9vLmZvbnQuc2l6ZToxMixmb250Q29sb3I6by5jb2xvcnx8XCIjMzMzMzMzXCIsZm9udFN0eWxlOm8uZm9udD9vLmZvbnQuc3R5bGU6XCJub3JtYWxcIixmb250RmFtaWx5Om8uZm9udD9vLmZvbnQuZmFtaWx5OlwiJ0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWZcIixzaGFkb3dPZmZzZXRYOjMsc2hhZG93T2Zmc2V0WTozLHNoYWRvd0NvbG9yOlwicmdiYSgwLDAsMCwwLjMpXCIsc2hhZG93Qmx1cjo2LGltYWdlczpbXSxvdXRzaWRlUGFkZGluZzoyLHRleHRNYXJnaW46MixvdmVybGFwOiEwfSxlKSxcImJhclwiPT09dC5jb25maWcudHlwZSYmKHRoaXMub3B0aW9ucy5wb3NpdGlvbj1cImRlZmF1bHRcIix0aGlzLm9wdGlvbnMuYXJjPSExLHRoaXMub3B0aW9ucy5vdmVybGFwPSEwKX0sby5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7dGhpcy5sYWJlbEJvdW5kcz1bXSx0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCh0aGlzLnJlbmRlclRvRGF0YXNldCl9LG8ucHJvdG90eXBlLnJlbmRlclRvRGF0YXNldD1mdW5jdGlvbih0LGUpe3RoaXMudG90YWxQZXJjZW50YWdlPTAsdGhpcy50b3RhbD1udWxsO2NvbnN0IG89dGhpcy5hcmdzW2VdO28ubWV0YS5kYXRhLmZvckVhY2goZnVuY3Rpb24oZSxuKXt0aGlzLnJlbmRlclRvRWxlbWVudCh0LG8sZSxuKX0uYmluZCh0aGlzKSl9LG8ucHJvdG90eXBlLnJlbmRlclRvRWxlbWVudD1mdW5jdGlvbihlLG8sbixpKXtpZighdGhpcy5zaG91bGRSZW5kZXJUb0VsZW1lbnQoby5tZXRhLG4pKXJldHVybjt0aGlzLnBlcmNlbnRhZ2U9bnVsbDtjb25zdCBzPXRoaXMuZ2V0TGFiZWwoZSxuLGkpO2lmKCFzKXJldHVybjtjb25zdCByPXRoaXMuY3R4O3Iuc2F2ZSgpLHIuZm9udD10LmZvbnRTdHJpbmcodGhpcy5vcHRpb25zLmZvbnRTaXplLHRoaXMub3B0aW9ucy5mb250U3R5bGUsdGhpcy5vcHRpb25zLmZvbnRGYW1pbHkpO2NvbnN0IGE9dGhpcy5nZXRSZW5kZXJJbmZvKG4scyk7dGhpcy5kcmF3YWJsZShuLHMsYSk/KHIuYmVnaW5QYXRoKCksci5maWxsU3R5bGU9dGhpcy5nZXRGb250Q29sb3IoZSxuLGkpLHRoaXMucmVuZGVyTGFiZWwocyxhKSxyLnJlc3RvcmUoKSk6ci5yZXN0b3JlKCl9LG8ucHJvdG90eXBlLnJlbmRlckxhYmVsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMub3B0aW9ucy5hcmM/dGhpcy5yZW5kZXJBcmNMYWJlbCh0LGUpOnRoaXMucmVuZGVyQmFzZUxhYmVsKHQsZSl9LG8ucHJvdG90eXBlLnJlbmRlckJhc2VMYWJlbD1mdW5jdGlvbih0LGUpe2NvbnN0IG89dGhpcy5jdHg7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpby5kcmF3SW1hZ2UodCxlLngtdC53aWR0aC8yLGUueS10LmhlaWdodC8yLHQud2lkdGgsdC5oZWlnaHQpO2Vsc2V7by5zYXZlKCksby50ZXh0QmFzZWxpbmU9XCJ0b3BcIixvLnRleHRBbGlnbj1cImNlbnRlclwiLHRoaXMub3B0aW9ucy50ZXh0U2hhZG93JiYoby5zaGFkb3dPZmZzZXRYPXRoaXMub3B0aW9ucy5zaGFkb3dPZmZzZXRYLG8uc2hhZG93T2Zmc2V0WT10aGlzLm9wdGlvbnMuc2hhZG93T2Zmc2V0WSxvLnNoYWRvd0NvbG9yPXRoaXMub3B0aW9ucy5zaGFkb3dDb2xvcixvLnNoYWRvd0JsdXI9dGhpcy5vcHRpb25zLnNoYWRvd0JsdXIpO2NvbnN0IG49dC5zcGxpdChcIlxcblwiKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3QgaT1lLnktdGhpcy5vcHRpb25zLmZvbnRTaXplLzIqbi5sZW5ndGgrdGhpcy5vcHRpb25zLmZvbnRTaXplKnQ7by5maWxsVGV4dChuW3RdLGUueCxpKX1vLnJlc3RvcmUoKX19LG8ucHJvdG90eXBlLnJlbmRlckFyY0xhYmVsPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbz10aGlzLmN0eCxuPWUucmFkaXVzLGk9ZS52aWV3O2lmKG8uc2F2ZSgpLG8udHJhbnNsYXRlKGkueCxpLnkpLFwic3RyaW5nXCI9PXR5cGVvZiB0KXtvLnJvdGF0ZShlLnN0YXJ0QW5nbGUpLG8udGV4dEJhc2VsaW5lPVwibWlkZGxlXCIsby50ZXh0QWxpZ249XCJsZWZ0XCI7Y29uc3QgaT10LnNwbGl0KFwiXFxuXCIpO2xldCBzPTA7Y29uc3Qgcj1bXTtsZXQgYSxoPTA7XCJib3JkZXJcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbiYmKGg9KGkubGVuZ3RoLTEpKnRoaXMub3B0aW9ucy5mb250U2l6ZS8yKTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoOysrdClhPW8ubWVhc3VyZVRleHQoaVt0XSksYS53aWR0aD5zJiYocz1hLndpZHRoKSxyLnB1c2goYS53aWR0aCk7Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDsrK3Qpe2NvbnN0IGU9aVt0XSxsPShpLmxlbmd0aC0xLXQpKi10aGlzLm9wdGlvbnMuZm9udFNpemUraDtvLnNhdmUoKTtjb25zdCBjPShzLXJbdF0pLzI7by5yb3RhdGUoYy9uKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3QgaT1lLmNoYXJBdCh0KTthPW8ubWVhc3VyZVRleHQoaSksby5zYXZlKCksby50cmFuc2xhdGUoMCwtMSpuKSxvLmZpbGxUZXh0KGksMCxsKSxvLnJlc3RvcmUoKSxvLnJvdGF0ZShhLndpZHRoL24pfW8ucmVzdG9yZSgpfX1lbHNlIG8ucm90YXRlKChpLnN0YXJ0QW5nbGUrTWF0aC5QSS8yK2UuZW5kQW5nbGUpLzIpLG8udHJhbnNsYXRlKDAsLTEqbiksdGhpcy5yZW5kZXJMYWJlbCh0LHt4OjAseTowfSk7by5yZXN0b3JlKCl9LG8ucHJvdG90eXBlLnNob3VsZFJlbmRlclRvRWxlbWVudD1mdW5jdGlvbih0LGUpe3JldHVybiF0LmhpZGRlbiYmKHRoaXMub3B0aW9ucy5zaG93WmVyb3x8XCJwb2xhckFyZWFcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGU/MCE9PWUub3V0ZXJSYWRpdXM6MCE9PWUuY2lyY3VtZmVyZW5jZSl9LG8ucHJvdG90eXBlLmdldExhYmVsPWZ1bmN0aW9uKHQsZSxvKXtsZXQgbjtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMucmVuZGVyKW49dGhpcy5vcHRpb25zLnJlbmRlcih7bGFiZWw6dGhpcy5jaGFydC5jb25maWcuZGF0YS5sYWJlbHNbb10sdmFsdWU6dC5kYXRhW29dLHBlcmNlbnRhZ2U6dGhpcy5nZXRQZXJjZW50YWdlKHQsZSxvKSxkYXRhc2V0OnQsaW5kZXg6b30pO2Vsc2Ugc3dpdGNoKHRoaXMub3B0aW9ucy5yZW5kZXIpe2Nhc2VcInZhbHVlXCI6bj10LmRhdGFbb107YnJlYWs7Y2FzZVwibGFiZWxcIjpuPXRoaXMuY2hhcnQuY29uZmlnLmRhdGEubGFiZWxzW29dO2JyZWFrO2Nhc2VcImltYWdlXCI6bj10aGlzLm9wdGlvbnMuaW1hZ2VzW29dP3RoaXMubG9hZEltYWdlKHRoaXMub3B0aW9ucy5pbWFnZXNbb10pOlwiXCI7YnJlYWs7ZGVmYXVsdDpuPXRoaXMuZ2V0UGVyY2VudGFnZSh0LGUsbykrXCIlXCJ9cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIG4/bj10aGlzLmxvYWRJbWFnZShuKTpuJiYobj1uLnRvU3RyaW5nKCkpLG59LG8ucHJvdG90eXBlLmdldEZvbnRDb2xvcj1mdW5jdGlvbih0LGUsbyl7bGV0IG49dGhpcy5vcHRpb25zLmZvbnRDb2xvcjtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP249bih7bGFiZWw6dGhpcy5jaGFydC5jb25maWcuZGF0YS5sYWJlbHNbb10sdmFsdWU6dC5kYXRhW29dLHBlcmNlbnRhZ2U6dGhpcy5nZXRQZXJjZW50YWdlKHQsZSxvKSxiYWNrZ3JvdW5kQ29sb3I6dC5iYWNrZ3JvdW5kQ29sb3Jbb10sZGF0YXNldDp0LGluZGV4Om99KTpcInN0cmluZ1wiIT10eXBlb2YgbiYmKG49bltvXXx8dGhpcy5jaGFydC5jb25maWcub3B0aW9ucy5jb2xvciksbn0sby5wcm90b3R5cGUuZ2V0UGVyY2VudGFnZT1mdW5jdGlvbih0LGUsbyl7aWYodGhpcy5wZXJjZW50YWdlKXJldHVybiB0aGlzLnBlcmNlbnRhZ2U7bGV0IG47aWYoXCJwb2xhckFyZWFcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGV8fFwiZG91Z2hudXRcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGV8fFwicGllXCI9PT10aGlzLmNoYXJ0LmNvbmZpZy50eXBlKXtpZighdGhpcy50b3RhbCl7dGhpcy50b3RhbD0wO2ZvcihsZXQgZT0wO2U8dC5kYXRhLmxlbmd0aDsrK2UpdGhpcy50b3RhbCs9dC5kYXRhW2VdfW49dC5kYXRhW29dL3RoaXMudG90YWwqMTAwfWVsc2UgaWYoXCJiYXJcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGUpe2lmKCF0aGlzLmJhclRvdGFsW29dKXt0aGlzLmJhclRvdGFsW29dPTA7Zm9yKGxldCB0PTA7dDx0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOysrdCl0aGlzLmJhclRvdGFsW29dKz10aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdF0uZGF0YVtvXX1uPXQuZGF0YVtvXS90aGlzLmJhclRvdGFsW29dKjEwMH1lbHNlIG49ZS5jaXJjdW1mZXJlbmNlL3RoaXMuY2hhcnQuY29uZmlnLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSoxMDA7cmV0dXJuIG49cGFyc2VGbG9hdChuLnRvRml4ZWQodGhpcy5vcHRpb25zLnByZWNpc2lvbikpLHRoaXMub3B0aW9ucy5zaG93QWN0dWFsUGVyY2VudGFnZXN8fChcImJhclwiPT09dGhpcy5jaGFydC5jb25maWcudHlwZSYmKHRoaXMudG90YWxQZXJjZW50YWdlPXRoaXMuYmFyVG90YWxQZXJjZW50YWdlW29dfHwwKSx0aGlzLnRvdGFsUGVyY2VudGFnZSs9bix0aGlzLnRvdGFsUGVyY2VudGFnZT4xMDAmJihuLT10aGlzLnRvdGFsUGVyY2VudGFnZS0xMDAsbj1wYXJzZUZsb2F0KG4udG9GaXhlZCh0aGlzLm9wdGlvbnMucHJlY2lzaW9uKSkpLFwiYmFyXCI9PT10aGlzLmNoYXJ0LmNvbmZpZy50eXBlJiYodGhpcy5iYXJUb3RhbFBlcmNlbnRhZ2Vbb109dGhpcy50b3RhbFBlcmNlbnRhZ2UpKSx0aGlzLnBlcmNlbnRhZ2U9bixufSxvLnByb3RvdHlwZS5nZXRSZW5kZXJJbmZvPWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJiYXJcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGU/dGhpcy5nZXRCYXJSZW5kZXJJbmZvKHQsZSk6dGhpcy5vcHRpb25zLmFyYz90aGlzLmdldEFyY1JlbmRlckluZm8odCxlKTp0aGlzLmdldEJhc2VSZW5kZXJJbmZvKHQsZSl9LG8ucHJvdG90eXBlLmdldEJhc2VSZW5kZXJJbmZvPWZ1bmN0aW9uKHQsZSl7aWYoXCJvdXRzaWRlXCI9PT10aGlzLm9wdGlvbnMucG9zaXRpb258fFwiYm9yZGVyXCI9PT10aGlzLm9wdGlvbnMucG9zaXRpb24pe2xldCBvLG49e307Y29uc3QgaT10LHM9aS5zdGFydEFuZ2xlKyhpLmVuZEFuZ2xlLWkuc3RhcnRBbmdsZSkvMixyPWkub3V0ZXJSYWRpdXMvMjtpZihcImJvcmRlclwiPT09dGhpcy5vcHRpb25zLnBvc2l0aW9uP289KGkub3V0ZXJSYWRpdXMtcikvMityOlwib3V0c2lkZVwiPT09dGhpcy5vcHRpb25zLnBvc2l0aW9uJiYobz1pLm91dGVyUmFkaXVzLXIrcit0aGlzLm9wdGlvbnMudGV4dE1hcmdpbiksbj17eDppLngrTWF0aC5jb3Mocykqbyx5OmkueStNYXRoLnNpbihzKSpvfSxcIm91dHNpZGVcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbil7Y29uc3QgdD10aGlzLm9wdGlvbnMudGV4dE1hcmdpbit0aGlzLm1lYXN1cmVMYWJlbChlKS53aWR0aC8yO24ueCs9bi54PGkueD8tdDp0fXJldHVybiBufXJldHVybiB0LnRvb2x0aXBQb3NpdGlvbigpfSxvLnByb3RvdHlwZS5nZXRBcmNSZW5kZXJJbmZvPWZ1bmN0aW9uKHQsZSl7bGV0IG87Y29uc3Qgbj10O289XCJvdXRzaWRlXCI9PT10aGlzLm9wdGlvbnMucG9zaXRpb24/bi5vdXRlclJhZGl1cyt0aGlzLm9wdGlvbnMuZm9udFNpemUrdGhpcy5vcHRpb25zLnRleHRNYXJnaW46XCJib3JkZXJcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbj8obi5vdXRlclJhZGl1cy8yK24ub3V0ZXJSYWRpdXMpLzI6KG4uaW5uZXJSYWRpdXMrbi5vdXRlclJhZGl1cykvMjtsZXQgaT1uLnN0YXJ0QW5nbGUscz1uLmVuZEFuZ2xlO2NvbnN0IHI9cy1pO2krPU1hdGguUEkvMixzKz1NYXRoLlBJLzI7cmV0dXJuIGkrPShzLSh0aGlzLm1lYXN1cmVMYWJlbChlKS53aWR0aC9vK2kpKS8yLHtyYWRpdXM6byxzdGFydEFuZ2xlOmksZW5kQW5nbGU6cyx0b3RhbEFuZ2xlOnIsdmlldzpufX0sby5wcm90b3R5cGUuZ2V0QmFyUmVuZGVySW5mbz1mdW5jdGlvbih0LGUpe2NvbnN0IG89dC50b29sdGlwUG9zaXRpb24oKTtyZXR1cm4gby55LT10aGlzLm1lYXN1cmVMYWJlbChlKS5oZWlnaHQvMit0aGlzLm9wdGlvbnMudGV4dE1hcmdpbixvfSxvLnByb3RvdHlwZS5kcmF3YWJsZT1mdW5jdGlvbih0LGUsbyl7aWYodGhpcy5vcHRpb25zLm92ZXJsYXApcmV0dXJuITA7aWYodGhpcy5vcHRpb25zLmFyYylyZXR1cm4gby5lbmRBbmdsZS1vLnN0YXJ0QW5nbGU8PW8udG90YWxBbmdsZTt7Y29uc3Qgbj10aGlzLm1lYXN1cmVMYWJlbChlKSxpPW8ueC1uLndpZHRoLzIscz1vLngrbi53aWR0aC8yLHI9by55LW4uaGVpZ2h0LzIsYT1vLnkrbi5oZWlnaHQvMjtyZXR1cm5cIm91dHNpZGVcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbj90aGlzLm91dHNpZGVJblJhbmdlKGkscyxyLGEpOnQuaW5SYW5nZShpLHIpJiZ0LmluUmFuZ2UoaSxhKSYmdC5pblJhbmdlKHMscikmJnQuaW5SYW5nZShzLGEpfX0sby5wcm90b3R5cGUub3V0c2lkZUluUmFuZ2U9ZnVuY3Rpb24odCxlLG8sbil7Y29uc3QgaT10aGlzLmxhYmVsQm91bmRzO2ZvcihsZXQgcz0wO3M8aS5sZW5ndGg7KytzKXtjb25zdCByPWlbc107bGV0IGE9W1t0LG9dLFt0LG5dLFtlLG9dLFtlLG5dXTtmb3IobGV0IHQ9MDt0PGEubGVuZ3RoOysrdCl7Y29uc3QgZT1hW3RdWzBdLG89YVt0XVsxXTtpZihlPj1yLmxlZnQmJmU8PXIucmlnaHQmJm8+PXIudG9wJiZvPD1yLmJvdHRvbSlyZXR1cm4hMX1hPVtbci5sZWZ0LHIudG9wXSxbci5sZWZ0LHIuYm90dG9tXSxbci5yaWdodCxyLnRvcF0sW3IucmlnaHQsci5ib3R0b21dXTtmb3IobGV0IGk9MDtpPGEubGVuZ3RoOysraSl7Y29uc3Qgcz1hW2ldWzBdLHI9YVtpXVsxXTtpZihzPj10JiZzPD1lJiZyPj1vJiZyPD1uKXJldHVybiExfX1yZXR1cm4gaS5wdXNoKHtsZWZ0OnQscmlnaHQ6ZSx0b3A6byxib3R0b206bn0pLCEwfSxvLnByb3RvdHlwZS5tZWFzdXJlTGFiZWw9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpcmV0dXJue3dpZHRoOnQud2lkdGgsaGVpZ2h0OnQuaGVpZ2h0fTt7bGV0IGU9MDtjb25zdCBvPXQuc3BsaXQoXCJcXG5cIik7Zm9yKGxldCB0PTA7dDxvLmxlbmd0aDsrK3Qpe2NvbnN0IG49dGhpcy5jdHgubWVhc3VyZVRleHQob1t0XSk7bi53aWR0aD5lJiYoZT1uLndpZHRoKX1yZXR1cm57d2lkdGg6ZSxoZWlnaHQ6dGhpcy5vcHRpb25zLmZvbnRTaXplKm8ubGVuZ3RofX19LG8ucHJvdG90eXBlLmxvYWRJbWFnZT1mdW5jdGlvbih0KXtjb25zdCBlPW5ldyBJbWFnZTtyZXR1cm4gZS5zcmM9dC5zcmMsZS53aWR0aD10LndpZHRoLGUuaGVpZ2h0PXQuaGVpZ2h0LGV9LENoYXJ0LnJlZ2lzdGVyKHtpZDpcImxhYmVsc1wiLGJlZm9yZURhdGFzZXRzVXBkYXRlOmZ1bmN0aW9uKHQsaSxzKXtpZighZVt0LmNvbmZpZy50eXBlXXx8IW4ocykpcmV0dXJuO3MubGVuZ3RofHwocz1bc10pO2NvbnN0IHI9cy5sZW5ndGg7dC5fbGFiZWxzJiZyPT09dC5fbGFiZWxzLmxlbmd0aHx8KHQuX2xhYmVscz1zLm1hcCgoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG99KSkpO2xldCBhPSExLGg9MDtmb3IobGV0IGU9MDtlPHI7KytlKXtjb25zdCBvPXQuX2xhYmVsc1tlXTtpZihvLnNldHVwKHQsc1tlXSksXCJvdXRzaWRlXCI9PT1vLm9wdGlvbnMucG9zaXRpb24pe2E9ITA7Y29uc3QgdD0xLjUqby5vcHRpb25zLmZvbnRTaXplK28ub3B0aW9ucy5vdXRzaWRlUGFkZGluZzt0PmgmJihoPXQpfX1hJiYodC5jaGFydEFyZWEudG9wKz1oLHQuY2hhcnRBcmVhLmJvdHRvbS09aCl9LGFmdGVyRGF0YXNldFVwZGF0ZTpmdW5jdGlvbih0LG8saSl7ZVt0LmNvbmZpZy50eXBlXSYmbihpKSYmdC5fbGFiZWxzPy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmFyZ3Nbby5pbmRleF09b30pKX0sYmVmb3JlRHJhdzpmdW5jdGlvbih0LG8saSl7ZVt0LmNvbmZpZy50eXBlXSYmbihpKSYmdC5fbGFiZWxzPy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmJhclRvdGFsUGVyY2VudGFnZT17fX0pKX0sYWZ0ZXJEYXRhc2V0c0RyYXc6ZnVuY3Rpb24odCxvLGkpe2VbdC5jb25maWcudHlwZV0mJm4oaSkmJnQuX2xhYmVscz8uZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5yZW5kZXIoKX0pKX19KX0oKX0pKTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsMkJBQW1CLFFBQWMsVUFBNkI7QUFDN0QsaUJBQU8sTUFBTSxPQUFPLFFBQVMsV0FBUztBQUNyQyxxQkFBUzs7O0FBSUkseUJBQWdCO1VBSTlCLGNBQWE7QUFBQSxpQkFGTixVQUFPO0FBR2IsaUJBQUssVUFBVTs7VUFHaEIsR0FBRyxRQUFlLEtBQWM7QUFDL0Isc0JBQVUsUUFBUSxXQUFVO0FBQzNCLG9CQUFNLGNBQWMs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Q0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsR0FBRztBQUFBO0FBRUwsY0FBTSxVQUFVO0FBQUEsVUFDZCxRQUFRO0FBQUEsVUFDUixhQUFhO0FBQUEsVUFDYixNQUFNO0FBQUEsVUFDTixXQUFXO0FBQUEsVUFDWCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxjQUFjO0FBQUEsVUFDZCxJQUFJO0FBQUEsVUFDSixTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsVUFDTixXQUFXO0FBQUEsVUFDWCxRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxLQUFLO0FBQUEsVUFDTCxhQUFhO0FBQUEsVUFDYixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsVUFDTixLQUFLO0FBQUEsVUFDTCxPQUFPO0FBQUEsVUFDUCxTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxVQUFVO0FBQUEsVUFDVixRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxPQUFPO0FBQUEsVUFDUCxLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsVUFDVixRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxXQUFXO0FBQUEsVUFDWCxLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixLQUFLO0FBQUEsVUFDTCxLQUFLO0FBQUEsVUFDTCxPQUFPO0FBQUEsVUFDUCxLQUFLO0FBQUEsVUFDTCxTQUFTO0FBQUEsVUFDVCxRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixXQUFXO0FBQUEsVUFDWCxTQUFTO0FBQUEsVUFDVCxZQUFZO0FBQUEsVUFDWixLQUFLO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxXQUFXO0FBQUEsVUFDWCxNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxPQUFPO0FBQUEsVUFDUCxTQUFTO0FBQUEsVUFDVCxLQUFLO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixTQUFTO0FBQUEsVUFDVCxLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxZQUFZO0FBQUEsVUFDWixLQUFLO0FBQUEsVUFDTCxPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixNQUFNO0FBQUEsVUFDTixXQUFXO0FBQUEsVUFDWCxLQUFLO0FBQUEsVUFDTCxVQUFVO0FBQUEsVUFDVixZQUFZO0FB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QSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFB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
